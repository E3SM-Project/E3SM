#!/usr/bin/env python

import unittest, sys, os, tempfile, shutil, re, threading, time, signal

SCRIPT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(SCRIPT_DIR)
from acme_util import run_cmd
import acme_util

###############################################################################
class RunUnitTests(unittest.TestCase):
###############################################################################

    def do_unit_tests(self, script):
        stat, output, _ = run_cmd("./%s --test 2>&1" % script, ok_to_fail=True, from_dir=SCRIPT_DIR)
        self.assertEqual(stat, 0, msg=output)

    def test_acme_bisect_unit_test(self):
        self.do_unit_tests("acme_bisect")

    def test_cime_merge_helper_unit_test(self):
        self.do_unit_tests("cime_merge_helper")

    def test_compare_namelists_unit_test(self):
        self.do_unit_tests("compare_namelists")

    def test_jenkins_generic_job_unit_test(self):
        self.do_unit_tests("jenkins_generic_job")

    def test_simple_compare_unit_test(self):
        self.do_unit_tests("simple_compare")

    def test_update_acme_tests_unit_test(self):
        self.do_unit_tests("update_acme_tests")

    def test_wait_for_tests_unit_test(self):
        self.do_unit_tests("wait_for_tests")

###############################################################################
def make_fake_teststatus(path, testname, status):
###############################################################################
    fd = open(path, "w")
    fd.write("%s %s\n" % (status, testname))
    fd.close()

###############################################################################
def parse_test_status(line):
###############################################################################
    regex = re.compile(r"Test '(\w+)' finished with status '(\w+)'")
    m = regex.match(line)
    return m.groups()

###############################################################################
class TestWaitForTests(unittest.TestCase):
###############################################################################

    def setUp(self):
        self._testdir_all_pass     = tempfile.mkdtemp()
        self._testdir_with_fail    = tempfile.mkdtemp()
        self._testdir_unfinished   = tempfile.mkdtemp()

        for r in range(10):
            make_fake_teststatus(os.path.join(self._testdir_all_pass, "TestStatus_%d" % r), "Test_%d" % r, "PASS")

        for r in range(10):
            make_fake_teststatus(os.path.join(self._testdir_with_fail, "TestStatus_%d" % r), "Test_%d" % r, "PASS" if r % 2 == 0 else "FAIL")

        for r in range(10):
            make_fake_teststatus(os.path.join(self._testdir_unfinished, "TestStatus_%d" % r), "Test_%d" % r, "RUN" if r == 5 else "PASS")

        # Set up proxy if possible
        self._unset_proxy = False
        if ("http_proxy" not in os.environ):
            machine = acme_util.probe_machine_name()
            if (machine is not None):
                proxy = acme_util.get_machine_info(machine)[6]
                if (proxy is not None):
                    os.environ["http_proxy"] = proxy
                    self._unset_proxy = True

        self._threadError = None

    def tearDown(self):
        shutil.rmtree(self._testdir_all_pass)
        shutil.rmtree(self._testdir_with_fail)
        shutil.rmtree(self._testdir_unfinished)

        # Kill all subprocesses
        proc_ids = acme_util.find_proc_id("[Pp]ython", children_only=True)
        for proc_id in proc_ids:
           os.kill(proc_id, signal.SIGKILL)

        if (self._unset_proxy):
            del os.environ["http_proxy"]

    def simple_test(self, testdir, expected_results, extra_args=""):
        try:
            stat, output, errput = run_cmd("%s/wait_for_tests -p ACME_test TestStatus* %s" % (SCRIPT_DIR, extra_args), ok_to_fail=True, from_dir=testdir)
            if (expected_results == ["PASS"]*len(expected_results)):
                self.assertEqual(stat, 0, msg="wait_for_tests output:\n%s\n\nerrput:\n%s" % (output, errput))
            else:
                self.assertNotEqual(stat, 0, msg="wait_for_tests output:\n%s\n\nerrput:\n%s" % (output, errput))

            lines = [line for line in output.splitlines() if line.startswith("Test '")]
            self.assertEqual(len(lines), 10)
            for idx, line in enumerate(lines):
                testname, status = parse_test_status(line)
                self.assertEqual(status, expected_results[idx])
                self.assertEqual(testname, "Test_%d" % idx)

        except AssertionError as e:
            self._threadError = str(e)

    def test_wait_for_test_all_pass(self):
        self.simple_test(self._testdir_all_pass, ["PASS"] * 10)

    def test_wait_for_test_with_fail(self):
        expected_results = ["PASS" if item % 2 == 0 else "FAIL" for item in range(10)]
        self.simple_test(self._testdir_with_fail, expected_results)

    def test_wait_for_test_no_wait(self):
        expected_results = ["RUN" if item == 5 else "PASS" for item in range(10)]
        self.simple_test(self._testdir_unfinished, expected_results, "-n")

    def test_wait_for_test_wait(self):
        run_thread = threading.Thread(target=self.simple_test, args=(self._testdir_unfinished, ["PASS"] * 10))
        run_thread.daemon = True
        run_thread.start()

        time.sleep(5) # Kinda hacky

        self.assertTrue(run_thread.isAlive(), msg="wait_for_tests should have waited")

        make_fake_teststatus(os.path.join(self._testdir_unfinished, "TestStatus_5"), "Test_5", "PASS")

        run_thread.join(timeout=5)

        self.assertFalse(run_thread.isAlive(), msg="wait_for_tests should have finished")

        self.assertTrue(self._threadError is None, msg="Thread had failure: %s" % self._threadError)

    def test_wait_for_test_wait_kill(self):
        expected_results = ["RUN" if item == 5 else "PASS" for item in range(10)]
        run_thread = threading.Thread(target=self.simple_test, args=(self._testdir_unfinished, expected_results))
        run_thread.daemon = True
        run_thread.start()

        time.sleep(5)

        self.assertTrue(run_thread.isAlive(), msg="wait_for_tests should have waited")

        proc_ids = acme_util.find_proc_id("[Pp]ython", children_only=True)
        self.assertEqual(1, len(proc_ids), "Expected to find 1 process, found '%s'" % proc_ids)
        proc_id = proc_ids[0]

        os.kill(proc_id, signal.SIGTERM)

        run_thread.join(timeout=5)

        self.assertFalse(run_thread.isAlive(), msg="wait_for_tests should have finished")

        self.assertTrue(self._threadError is None, msg="Thread had failure: %s" % self._threadError)

    def test_wait_for_test_cdash_pass(self):
        expected_results = ["PASS"] * 10
        run_thread = threading.Thread(target=self.simple_test, args=(self._testdir_all_pass, expected_results, "-d regression_test_pass"))
        run_thread.daemon = True
        run_thread.start()

        run_thread.join(timeout=5)

        self.assertFalse(run_thread.isAlive(), msg="wait_for_tests should have finished")

        self.assertTrue(self._threadError is None, msg="Thread had failure: %s" % self._threadError)

    def test_wait_for_test_cdash_kill(self):
        expected_results = ["RUN" if item == 5 else "PASS" for item in range(10)]
        run_thread = threading.Thread(target=self.simple_test, args=(self._testdir_unfinished, expected_results, "-d regression_test_kill"))
        run_thread.daemon = True
        run_thread.start()

        time.sleep(5)

        self.assertTrue(run_thread.isAlive(), msg="wait_for_tests should have waited")

        proc_ids = acme_util.find_proc_id("[Pp]ython", children_only=True)
        self.assertEqual(1, len(proc_ids), "Expected to find 1 process, found '%s'" % proc_ids)
        proc_id = proc_ids[0]

        os.kill(proc_id, signal.SIGTERM)

        run_thread.join(timeout=5)

        self.assertFalse(run_thread.isAlive(), msg="wait_for_tests should have finished")

        self.assertTrue(self._threadError is None, msg="Thread had failure: %s" % self._threadError)

        cdash_result_dir = os.path.join(self._testdir_unfinished, "Testing")
        tag_file         = os.path.join(cdash_result_dir, "TAG")
        self.assertTrue(os.path.isdir(cdash_result_dir))
        self.assertTrue(os.path.isfile(tag_file))

        tag = open(tag_file, "r").readlines()[0].strip()
        xml_file = os.path.join(cdash_result_dir, tag, "Test.xml")
        self.assertTrue(os.path.isfile(xml_file))

        xml_contents = open(xml_file, "r").read()
        self.assertTrue(r'<TestList><Test>Test_0</Test><Test>Test_1</Test><Test>Test_2</Test><Test>Test_3</Test><Test>Test_4</Test><Test>Test_5</Test><Test>Test_6</Test><Test>Test_7</Test><Test>Test_8</Test><Test>Test_9</Test></TestList>'
                        in xml_contents)
        self.assertTrue(r'<Test Status="failed"><Name>Test_5</Name>' in xml_contents)

        # TODO: Any further checking of xml output worth doing?

# TODO: test jenkins_generic_job with a super-fast acme test category

if (__name__ == "__main__"):
    unittest.main()
