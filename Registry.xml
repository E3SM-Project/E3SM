<?xml version="1.0"?>
<registry model="mpas" core="landice" core_abbrev="li" version="4.0">


<!-- ======================================================================= -->
<!-- MODEL DIMENSIONS -->

	<dims>
		<dim name="nCells" units="unitless"
		     description="The number of polygons in the primary grid."
		/>
		<dim name="nEdges" units="unitless"
		     description="The number of edge midpoints in either the primary or dual grid."
		/>
		<dim name="maxEdges" units="unitless"
		     description="The largest number of edges any polygon within the grid has."
		/>
		<dim name="maxEdges2" units="unitless"
		     description="Two times the largest number of edges any polygon within the grid has."
		/>
		<dim name="nVertices" units="unitless"
		     description="The total number of cells in the dual grid. Also the number of corners in the primary grid."
		/>
		<dim name="ONE" definition="1" units="unitless"
		     description="The number one as a dimension."
		/>
		<dim name="TWO" definition="2" units="unitless"
		     description="The number two as a dimension."
		/>
		<dim name="R3" definition="3" units="unitless"
		     description="The number three as a dimension."
		/>
		<dim name="vertexDegree" units="unitless"
		     description="The number of cells or edges touching each vertex."
		/>
		<dim name="nVertLevels" units="unitless"
		     description="The number of levels in the vertical direction. All vertical levels share the same horizontal locations."
		/>
		<dim name="nVertInterfaces" definition="nVertLevels+1" units="unitless"
		     description="The number of interfaces in the vertical direction."
		/>
		<dim name="maxTracersAdvect" definition="1" units="unitless"
		     description="The maximum number of tracers to be advected."
		/>
		<dim name="nRegions" definition="1" units="unitless"
		     description="The number of regions used for AM_regionalStats"
		/>
		<dim name="nRegionGroups" definition="1" units="unitless"
		     description="The number of region groups used for AM_regionalStats"
		/>
		<dim name="maxRegionsInGroup" definition="1" units="unitless"
		     description="The maximum number of regions in a region group used for AM_regionalStats"
		/>
	</dims>


<!-- ======================================================================= -->
<!-- NAMELIST RECORDS -->

	<nml_record name="velocity_solver" in_defaults="true">
		<nml_option name="config_velocity_solver" type="character" default_value="sia" units="unitless"
		            description="Selection of the method for solving ice velocity. 'L1L2', 'FO', and 'Stokes' require compiling with external dycores. 'none' skips the calculation of velocity so the velocity field will be 0 or set to a field read from an input file.  'simple' gives a simple prescribed velocity field computed at initialization."
		            possible_values="'sia', 'L1L2', 'FO', 'Stokes', 'simple', 'none'"
		/>
		<nml_option name="config_sia_tangent_slope_calculation" type="character" default_value="from_vertex_barycentric" units="unitless"
		            description="Selection of the method for calculating the tangent component of surface slope at edges needed by the SIA velocity solver.
'from_vertex_barycentric' interpolates upperSurface values from cell centers to vertices using the barycentric interpolation routine in operators (mpas_cells_to_points_using_baryweights) and then calculates the slope between vertices.  It works for obtuse triangles, but will not work correctly across the edges of periodic meshes.
'from_vertex_barycentric_kiteareas' interpolates upperSurface values from cell centers to vertices using barycentric interpolation based on kiterea values and then calculates the slope between vertices.  It will work across the edges of periodic meshes, but will not work correctly for obtuse triangles.
'from_normal_slope' uses the vector operator mpas_tangential_vector_1d to calculate the tangent slopes from the normal slopes on the edges of the adjacent cells.  It will work for any mesh configuration, but is the least accurate method."
		            possible_values="'from_vertex_barycentric', 'from_vertex_barycentric_kiteareas', 'from_normal_slope'"
		/>
		<nml_option name="config_flowParamA_calculation" type="character" default_value="constant" units="unitless"
			description="Selection of the method for calculating the flow law parameter A.  If 'constant' is selected, the value is set to config_default_flowParamA.  The other options are calculated from the temperature field."
			possible_values="'constant', 'PB1982', 'CP2010'"
		/>
		<nml_option name="config_do_velocity_reconstruction_for_external_dycore" type="logical" default_value=".false." units="unitless"
		            description="By default, external, higher-order dycores return the uReconstructX and uReconstructY fields (which are the native locations of their FEM solution).  If this option is set to .true., uReconstructX and uReconstructY will be calculated by MPAS using framework's vector reconstruction routines based on the values of normalVelocity supplied by the external dycore.  This provides a way to test the calculation of normalVelocity in the interface."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_simple_velocity_type" type="character" default_value="uniform" units="unitless"
		            description="Selection of the type of simple velocity field computed at initialization when config_velocity_solver = 'simple'"
		            possible_values="'uniform', 'radial'"
		/>
	</nml_record>


	<nml_record name="advection" in_defaults="true">
		<nml_option name="config_thickness_advection" type="character" default_value="fo" units="unitless"
		            description="Selection of the method for advecting thickness."
		            possible_values="'fo', 'none'"
		/>
		<nml_option name="config_tracer_advection" type="character" default_value="none" units="unitless"
		            description="Selection of the method for advecting tracers."
		            possible_values="'fo', 'none'"
		/>
<!-- This option to be implemented in the future.
		<nml_option name="config_allow_additional_advance" type="logical" default_value=".true." units="none"
		            description="Determines whether ice can advance beyond its initial extent"
		            possible_values=".true. or .false."
		/>
-->
	</nml_record>

	<nml_record name="calving" in_defaults="true">
		<nml_option name="config_calving" type="character" default_value="none" units="unitless"
		            description="Selection of the method for calving ice."
		            possible_values="'none', 'floating', 'topographic_threshold', 'thickness_threshold' "
		/>
		<nml_option name="config_calving_topography" type="real" default_value="-500.0" units="m"
		            description="Defines the topographic height below which ice calves (for topographic_threshold option)."
		            possible_values="Any non-positive real value"
		/>
		<nml_option name="config_calving_thickness" type="real" default_value="100.0" units="m of ice"
		            description="Defines the ice thickness below which ice calves (for thickness_threshold option)."
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_data_calving" type="logical" default_value=".false." units="unitless"
		            description="Select whether or not to configure calving in a 'data' model mode (calc. calving flux but do not update ice geometry)"
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_calving_timescale" type="real" default_value="0.0" units="s"
		            description="Defines the timescale for calving. The fraction of eligible ice that calves is max(dt/calving_timescale, 1.0). A value of 0 means that all eligible ice calves."
		            possible_values="Any non-negative real value"
		/>
		<nml_option name="config_restore_calving_front" type="logical" default_value=".false." units="unitless"
		            description="If true, then restort the calving front to its initial position"
		            possible_values=".true. or .false."
		/>
	</nml_record>

	<nml_record name="thermal_solver" in_defaults="true">
		<nml_option name="config_thermal_solver" type="character" default_value="none" units="unitless"
		            description="Selection of the method for the vertical thermal solver."
		            possible_values="'none', 'temperature', 'enthalpy'"
		/>
		<nml_option name="config_temperature_init" type="character" default_value="file" units="unitless"
		            description="Selection of the method for initializing the ice temperature."
		            possible_values="'sfc_air_temperature', 'linear', 'file'"
		/>
		<nml_option name="config_thermal_thickness" type="real" default_value="1.0" units="m of ice"
		            description="Defines the minimum thickness for thermal calculations"
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_surface_air_temperature_source" type="character" default_value="file" units="unitless"
		            description="Selection of the method for setting the surface air temperature."
		            possible_values="'constant', 'file'  'constant' uses the value set by config_surface_air_temperature_value.  'file' reads the field from an input or forcing file or ESM coupler."
		/>
		<nml_option name="config_surface_air_temperature_value" type="real" default_value="273.15" units="Kelvin"
		            description="Constant value of the surface air temperature."
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_basal_heat_flux_source" type="character" default_value="file" units="unitless"
		            description="Selection of the method for setting the basal heat flux."
		            possible_values="'constant', 'file'  'constant' uses the value set by config_basal_heat_flux_value.  'file' reads the field from an input or forcing file or ESM coupler."
		/>
		<nml_option name="config_basal_heat_flux_value" type="real" default_value="0.0" units="W m^{-2}"
		            description="Constant value of the basal heat flux (positive upward)."
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_basal_mass_bal_float" type="character" default_value="none" units="unitless"
		            description="Selection of the method for computing the basal mass balance of floating ice.  'none' sets the basalMassBal field to 0 everywhere.  'file' uses without modification whatever value was read in through an input or forcing file or the value set by an ESM coupler.  'constant' and 'mismip' use hardcoded fields defined in the code."
		            possible_values="'none', 'file', 'constant', 'mismip'"
		/>
		<nml_option name="config_bmlt_float_flux" type="real" default_value="0.0" units="W m^{-2}"
		            description="Value of the constant heat flux applied to the base of floating ice (positive upward)."
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_bmlt_float_xlimit" type="real" default_value="0.0" units="m"
		            description="x value defining region where bmlt_float_flux is applied; melt only where abs(x) > xlimit."
		            possible_values="Any positive real value"
		/>
	</nml_record>

	<nml_record name="physical_parameters" in_defaults="true">
		<nml_option name="config_ice_density" type="real" default_value="910.0" units="kg m^{-3}"
		            description="ice density to use"
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_ocean_density" type="real" default_value="1028.0" units="kg m^{-3}"
		            description="ocean density to use for calculating floatation"
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_sea_level" type="real" default_value="0.0" units="m above datum"
		            description="sea level to use for calculating floatation"
		            possible_values="Any real value"
		/>
		<nml_option name="config_default_flowParamA" type="real" default_value="3.1709792e-24" units="s^{-1} Pa^{-n}"
		            description="Defines the default value of the flow law parameter A to be used if it is not being calculated from ice temperature.  Defaults to the SI representation of 1.0e-16 yr^{-1} Pa^{-3}."
		            possible_values="Any positive real value"
		/>
		<nml_option name="config_enhancementFactor" type="real" default_value="1.0" units="none"
			description="multiplier on the flow parameter A"
			possible_values="Any positive real value"
		/>
		<nml_option name="config_flowLawExponent" type="real" default_value="3.0" units="none"
		            description="Defines the value of the Glen flow law exponent, n."
		            possible_values="Any real value"
		/>
		<nml_option name="config_dynamic_thickness" type="real" default_value="10.0" units="m of ice"
		            description="Defines the ice thickness below which dynamics are not calculated."
		            possible_values="Any positive real value"
		/>
	</nml_record>


	<nml_record name="time_integration" in_defaults="true">
		<nml_option name="config_dt" type="character" default_value="0001-00-00_00:00:00" units="unitless"
		            description="Length of model time step defined as a time interval."
		            possible_values="Any time interval of the format 'YYYY-MM-DD_HH:MM:SS', but limited by CFL condition. (items in the format string may be dropped from the left if not needed, and the components on either side of the underscore may be replaced with a single integer representing the rightmost unit)"
		/>
		<nml_option name="config_time_integration" type="character" default_value="forward_euler" units="unitless"
		            description="Time integration method."
		            possible_values="'forward_euler'"
		/>
		<nml_option name="config_adaptive_timestep" type="logical" default_value=".false." units="unitless"
			description="Determines if the time step should be adjusted based on the CFL condition or should be steady in time. If true, the config_dt_* options are ignored."
			possible_values=".true. or .false."
		/>
		<nml_option name="config_min_adaptive_timestep" type="real" default_value="0.0" units="s"
			description="The minimum allowable time step in seconds.  If the CFL condition dictates the time step should be shorter than this, then the model aborts."
			possible_values="Any non-negative real value."
		/>
		<nml_option name="config_max_adaptive_timestep" type="real" default_value="3.15e9" units="s"
			description="The maximum allowable time step in seconds.  If the CFL condition allows the time step to be longer than this, then the model uses this value instead.  Defaults to 100 years (in seconds)."
			possible_values="Any non-negative real value."
		/>
		<nml_option name="config_adaptive_timestep_CFL_fraction" type="real" default_value="0.25" units="none"
			description="A multiplier on the minimum allowable time step calculated from the CFL condition. (Setting to 1.0 may be unstable, so smaller values are recommended.)"
			possible_values="Any positive real value less than 1.0."
		/>
		<nml_option name="config_adaptive_timestep_include_DCFL" type="logical" default_value=".false." units="none"
			description="Option of whether to include the diffusive CFL condition in the determination of the maximum allowable timestep."
			possible_values=".true. or .false."
		/>
		<nml_option name="config_adaptive_timestep_force_interval" type="character" default_value="1000-00-00_00:00:00" units="unitless"
		            description="If adaptive timestep is enabled, the model will ensure a timestep ends at multiples of this interval.  This is useful for ensuring you get output at a specific desired interval (rather than the closest time after) or for running coupled to earth system models that expect a certain interval."
		            possible_values="Any time interval of the format 'YYYY-MM-DD_HH:MM:SS'. (items in the format string may be dropped from the left if not needed, and the components on either side of the underscore may be replaced with a single integer representing the rightmost unit)"
		/>
	</nml_record>


	<nml_record name="time_management" in_defaults="true">
		<nml_option name="config_do_restart" type="logical" default_value=".false." units="unitless"
		            description="Determines if the initial conditions should be read from a restart file, or an input file.  To perform a restart, simply set this to true in the namelist.input file and modify the start time to be the time you want restart from.  A restart will read the grid information from the input field, and the restart state from the restart file.  It will perform a run normally, except velocity will not be solved on a restart."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_restart_timestamp_name" type="character" default_value="restart_timestamp" units="unitless"
		description="Path to the filename for restart timestamps to be read and written from."
		possible_values="Path to a file."
		/>
		<nml_option name="config_start_time" type="character" default_value="0000-01-01_00:00:00" units="unitless"
		            description="Timestamp describing the initial time of the simulation.  If it is set to 'file', the initial time is read from restart_timestamp"
		            possible_values="'YYYY-MM-DD_HH:MM:SS' (items in the format string may be dropped from the left if not needed, and the components on either side of the underscore may be replaced with a single integer representing the rightmost unit)"
		/>
		<nml_option name="config_stop_time" type="character" default_value="0000-01-01_00:00:00" units="unitless"
		            description="Timestamp describing the final time of the simulation. If it is set to 'none' the final time is determined from config_start_time and config_run_duration.  If config_run_duration is also specified, it takes precedence over config_stop_time.  Set config_stop_time to be equal to config_start_time (and config_run_duration to 'none') to perform a diagnostic solve only."
		            possible_values="'YYYY-MM-DD_HH:MM:SS' or 'none' (items in the format string may be dropped from the left if not needed, and the components on either side of the underscore may be replaced with a single integer representing the rightmost unit)"
		/>
		<nml_option name="config_run_duration" type="character" default_value="none" units="unitless"
		            description="Timestamp describing the length of the simulation. If it is set to 'none' the duration is determined from config_start_time and config_stop_time. config_run_duration overrides inconsistent values of config_stop_time. If a time value is specified for config_run_duration, it must be greater than 0."
		            possible_values="'YYYY-MM-DD_HH:MM:SS' or 'none' (items in the format string may be dropped from the left if not needed, and the components on either side of the underscore may be replaced with a single integer representing the rightmost unit)"
		/>
		<nml_option name="config_calendar_type" type="character" default_value="gregorian_noleap" units="unitless"
		            description="Selection of the type of calendar that should be used in the simulation."
		            possible_values="'gregorian', 'gregorian_noleap'"
		/>
	</nml_record>


	<nml_record name="io" in_defaults="true">
                <nml_option name="config_stats_interval" type="integer" default_value="0" units="unitless"
		            description="Integer specifying interval (number of timesteps) for writing global/local statistics. If set to 0, then statistics are not written (except perhaps at startup, as determined by 'config_write_stats_on_startup')."
		            possible_values="Any positive integer value greater than or equal to 0."
		/>
		<nml_option name="config_write_stats_on_startup" type="logical" default_value=".false." units="unitless"
		            description="Logical flag determining if statistics should be written prior to the first time step."
		            possible_values=".true. or .false."
                />
		<nml_option name="config_stats_cell_ID" type="integer" default_value="1" units="unitless"
		            description="global ID for the cell selected for local statistics/diagnostics"
		            possible_values="Any positive integer value greater than or equal to 0."
                />
		<nml_option name="config_write_output_on_startup" type="logical" default_value=".true." units="unitless"
		            description="Logical flag determining if an output file should be written prior to the first time step."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_pio_num_iotasks" type="integer" default_value="0" units="unitless"
		            description="Integer specifying how many IO tasks should be used within the PIO library. A value of 0 causes all MPI tasks to also be IO tasks. IO tasks are required to write contiguous blocks of data to a file."
		            possible_values="Any positive integer value greater than or equal to 0."
		/>
		<nml_option name="config_pio_stride" type="integer" default_value="1" units="unitless"
		            description="Integer specifying the stride of each IO task."
		            possible_values="Any positive integer value greater than 0."
		/>
		<nml_option name="config_year_digits" type="integer" default_value="4" units="unitless"
		            description="Integer specifying the number of digits used to represent the year in time strings."
		            possible_values="Any positive integer value greater than 0."
		/>
		<nml_option name="config_output_external_velocity_solver_data" type="logical" default_value=".false." units="unitless"
		            description="If .true., external velocity solvers (if enabled) will write their own output data in addition to any MPAS output that is configured."
		            possible_values=".true. or .false."
		/>
	</nml_record>


	<nml_record name="decomposition" in_defaults="true">
		<nml_option name="config_num_halos" type="integer" default_value="2" units="unitless"
		            description="Determines the number of halo cells extending from a blocks owned cells (Called the 0-Halo). Default FO advection requires a minimum of 2.  Note that a minimum of 3 is required for incremental remapping advection on a quad mesh or for FCT advection, neither of which is currently fully supported."
		            possible_values="Any positive interger value."
		/>
		<nml_option name="config_block_decomp_file_prefix" type="character" default_value="graph.info.part." units="unitless"
		            description="Defines the prefix for the block decomposition file. Can include a path. The number of blocks is appended to the end of the prefix at run-time."
					possible_values="Any path/prefix to a block decomposition file."
		/>
		<nml_option name="config_number_of_blocks" type="integer" default_value="0" units="unitless"
		            description="Determines the number of blocks a simulation should be run with. If it is set to 0, the number of blocks is the same as the number of MPI tasks at run-time."
					possible_values="Any integer $>=$ 0."
		/>
		<nml_option name="config_explicit_proc_decomp" type="logical" default_value=".false." units="unitless"
		            description="Determines if an explicit processor decomposition should be used. This is only useful if multiple blocks per processor are used."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_proc_decomp_file_prefix" type="character" default_value="graph.info.part." units="unitless"
		            description="Defines the prefix for the processor decomposition file. This file is only read if config_explicit_proc_decomp is .true. The number of processors is appended to the end of the prefix at run-time."
					possible_values="Any path/prefix to a processor decomposition file."
		/>
	</nml_record>


	<nml_record name="debug" in_defaults="true">
		<nml_option name="config_print_thickness_advection_info" type="logical" default_value=".false." units="unitless"
		            description="Prints additional information about thickness advection."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_print_calving_info" type="logical" default_value=".false." units="unitless"
		            description="Prints additional information about calving."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_print_thermal_info" type="logical" default_value=".false." units="unitless"
		            description="Prints additional information about thermal calculations."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_always_compute_fem_grid" type="logical" default_value=".false." units="unitless"
		            description="Always compute finite-element grid information for external dycores rather than only doing so when the ice extent changes."
		            possible_values=".true. or .false."
		/>
		<nml_option name="config_print_velocity_cleanup_details" type="logical" default_value=".false." units="unitless"
		            description="After velocity is calculated there are a few checks for appropriate values in certain geometric configurations.  Setting this option to .true. will cause detailed information about those adjustments to be printed."
		            possible_values=".true. or .false."
		/>
	</nml_record>


<!-- ======================================================================= -->
<!-- PACKAGE DEFINITIONS -->

	<packages>
		<package name="SIAvelocity" description="Variables only needed by the SIA velocity solver"/>

		<package name="higherOrderVelocity" description="This package includes variables required for higher order velocity solvers."/>

	</packages>


<!-- ======================================================================= -->
<!-- I/O STREAM DEFINITIONS -->

	<streams>

		<!-- basicmesh contains all the required MPAS mesh fields - attach this to other streams as needed -->
		<stream name="basicmesh"
				type="none"
				immutable="true"
				filename_template="not-to-be-used.nc">
			<var name="latCell"/>
			<var name="lonCell"/>
			<var name="xCell"/>
			<var name="yCell"/>
			<var name="zCell"/>
			<var name="indexToCellID"/>
			<var name="latEdge"/>
			<var name="lonEdge"/>
			<var name="xEdge"/>
			<var name="yEdge"/>
			<var name="zEdge"/>
			<var name="indexToEdgeID"/>
			<var name="latVertex"/>
			<var name="lonVertex"/>
			<var name="xVertex"/>
			<var name="yVertex"/>
			<var name="zVertex"/>
			<var name="indexToVertexID"/>
			<var name="cellsOnEdge"/>
			<var name="nEdgesOnCell"/>
			<var name="nEdgesOnEdge"/>
			<var name="edgesOnCell"/>
			<var name="edgesOnEdge"/>
			<var name="weightsOnEdge"/>
			<var name="dvEdge"/>
			<var name="dcEdge"/>
			<var name="angleEdge"/>
			<var name="areaCell"/>
			<var name="areaTriangle"/>
			<var name="cellsOnCell"/>
			<var name="verticesOnCell"/>
			<var name="verticesOnEdge"/>
			<var name="edgesOnVertex"/>
			<var name="cellsOnVertex"/>
			<var name="kiteAreasOnVertex"/>
			<var name="layerThicknessFractions"/>
			<var name="meshDensity"/>
		</stream>

<!-- WHL: When using the enthalpy heat-balance solver, will need to add waterfrac to the streams with temperature. -->
		<stream name="input"
				type="input"
				immutable="true"
				filename_template="landice_grid.nc"
				input_interval="initial_only">

			<stream name="basicmesh"/>
			<var name="thickness"/>
			<var name="bedTopography"/>
			<var name="temperature"/>
			<var name="sfcMassBal"/>
                        <var name="floatingBasalMassBal"/>
                        <var name="surfaceAirTemperature"/>
                        <var name="basalHeatFlux"/>
<!-- The following variables are used by HO only, and only enabled by the higherOrderVelocity package. -->
<!-- They do not need to be in the input file for the SIA dycore, and will be ignored if they are. -->
			<var name="beta" packages="higherOrderVelocity"/>
			<var name="dirichletVelocityMask" packages="higherOrderVelocity"/>
                        <var name="uReconstructX" packages="higherOrderVelocity"/>
			<var name="uReconstructY" packages="higherOrderVelocity"/>
			<var name="basalMeltInput" packages="hydro"/>
			<var name="externalWaterInput" packages="hydro"/>
			<var name="waterThickness" packages="hydro"/>
			<var name="waterPressure" packages="hydro"/>
			<var name="channelArea" packages="hydro"/>
			<var name="waterFluxMask" packages="hydro"/>
		</stream>

<!-- An alternate way to allow the HO variables to exist in a separate file.
		<stream name="inputHigherOrderVelocity"
				type="input"
				immutable="true"
				packages="higherOrderVelocity"
				filename_template="landice_grid.nc2"
				input_interval="initial_only">
			<var name="beta"/>
			<var name="dirichletVelocityMask"/>
			<var name="dirichletVelocityXValue"/>
			<var name="dirichletVelocityYValue"/>
		</stream>
-->


		<stream name="restart"
				type="input;output"
				immutable="true"
				filename_template="restart.$Y-$M-$D_$h.$m.$s.nc"
				filename_interval="output_interval"
				input_interval="initial_only"
				output_interval="0010-00-00_00:00:00"
				reference_time="0000-01-01_00:00:00"
				precision="double"
				clobber_mode="replace_files">

                        <!-- Note: Restart fields are currently configured to include
                             *all* fields necessary to restart a run, i.e., the input stream
                             is *not* read on a restart! -->
			<stream name="basicmesh"/>
                        <var name="xtime"/>
                        <var name="simulationStartTime"/>
			<var name="thickness"/>
			<var name="temperature"/>
			<var name="cellMask"/>
			<var name="bedTopography"/>
			<var name="sfcMassBal"/>
			<!-- normalVelocity is needed for advection on the next timestep -->
			<var name="normalVelocity"/>
			<!-- uReconstructX/Y are only needed for exact restarts of HO iterative solvers -->
			<var name="uReconstructX" packages="higherOrderVelocity"/>
			<var name="uReconstructY" packages="higherOrderVelocity"/>
                        <!-- beta is only used for HO solvers -->
			<var name="beta" packages="higherOrderVelocity"/>
                        <!-- dirichletVelocityMask is only used for HO solvers -->
                        <var name="dirichletVelocityMask" packages="higherOrderVelocity"/>
                        <!-- fields only needed by SGH -->
                        <!-- SGH forcing: -->
			<var name="basalMeltInput" packages="hydro"/>
                        <var name="externalWaterInput" packages="hydro"/>
                        <!-- SGH state variables: -->
			<var name="waterThickness" packages="hydro"/>
			<var name="tillWaterThickness" packages="hydro"/>
			<var name="waterPressure" packages="hydro"/>
                        <var name="channelArea" packages="hydro"/>  <!-- this is only needed if running with channels - could be package-controlled -->
			<var name="waterFluxMask" packages="hydro"/>
		</stream>


		<stream name="output"
				type="output"
				filename_template="output.nc"
				filename_interval="none"
				output_interval="0001-00-00_00:00:00"
				runtime_format="single_file"
				reference_time="0000-01-01_00:00:00"
				precision="double"
				clobber_mode="replace_files">
				<!-- Note: I had set the default precision to 'single', but MpasDraw currently only supports double precision files -->

	        <stream name="basicmesh"/>
			<var name="layerCenterSigma"/>
			<var name="layerInterfaceSigma"/>
                        <var name="xtime"/>
                        <var name="simulationStartTime"/>
                        <var name="daysSinceStart"/>
                        <var name="deltat"/>
                        <var name="allowableDtACFL"/>
                        <var name="allowableDtDCFL"/>
			<var name="thickness"/>
			<var name="lowerSurface"/>
			<var name="upperSurface"/>
			<var name="temperature"/>
			<var name="cellMask"/>
			<var name="edgeMask"/>
			<var name="normalVelocity"/>
			<var name="uReconstructX"/>
			<var name="uReconstructY"/>
		</stream>
                <!-- input stream for regions masks files (currently only used by regional stats AM, and 
                     the only field used is the regionCellMasks field -->
                <stream name="regionsInput" type="input"
                                mode="forward;analysis"
                                filename_template="regionMasks.nc"
                                input_interval="initial_only"
                                runtime_format="single_file">
                        <var name="regionCellMasks"/> 
                        <!--var name="nCellsInRegion"/>  
                        <var name="regionVertexMasks"/>  
                        <var name="nVerticesInRegion"/> 
                        <var name="nRegionsInGroup"/> 
                        <var name="regionsInGroup"/>
                        <var name="regionMaskNames"/>
                        <var name="regionGroupNames"/-->
		</stream>

	</streams>


<!-- ======================================================================= -->
<!-- INTERNAL MODEL VARIABLES -->

<!-- Note: by default, all MPAS-LI variables have only one time level.  There
are/will be some variables that require a second time level, and they are/can be
individually specified to have a second time level.  Within the code, all routines
assume there is only one time level, except where explicitly needed otherwise.
Therefore, to minimize confusion, the convention is that the current time to be
computed on is always time level 1.  And time level 2, if it exists for a variable,
is the value of that variable from the *previous* time level!
 -->


	<!-- Mesh Variables required by MPAS framework -->
	<var_struct name="mesh" time_levs="1">
		<!-- The following fields are part of the MPAS mesh spec. -->
		<var name="latCell" type="real" dimensions="nCells" units="radians"
			 description="Latitude location of cell centers in radians."
		/>
		<var name="lonCell" type="real" dimensions="nCells" units="radians"
		     description="Longitude location of cell centers in radians."
		/>
		<var name="xCell" type="real" dimensions="nCells" units="unitless"
		     description="X Coordinate in cartesian space of cell centers."
		/>
		<var name="yCell" type="real" dimensions="nCells" units="unitless"
		     description="Y Coordinate in cartesian space of cell centers."
		/>
		<var name="zCell" type="real" dimensions="nCells" units="unitless"
		     description="Z Coordinate in cartesian space of cell centers."
		/>
		<var name="indexToCellID" type="integer" dimensions="nCells" units="unitless"
		     description="List of global cell IDs."
		/>
		<var name="latEdge" type="real" dimensions="nEdges" units="radians"
		     description="Latitude location of edge midpoints in radians."
		/>
		<var name="lonEdge" type="real" dimensions="nEdges" units="radians"
		     description="Longitude location of edge midpoints in radians."
		/>
		<var name="xEdge" type="real" dimensions="nEdges" units="unitless"
		     description="X Coordinate in cartesian space of edge midpoints."
		/>
		<var name="yEdge" type="real" dimensions="nEdges" units="unitless"
		     description="Y Coordinate in cartesian space of edge midpoints."
		/>
		<var name="zEdge" type="real" dimensions="nEdges" units="unitless"
		     description="Z Coordinate in cartesian space of edge midpoints."
		/>
		<var name="indexToEdgeID" type="integer" dimensions="nEdges" units="unitless"
		     description="List of global edge IDs."
		/>
		<var name="latVertex" type="real" dimensions="nVertices" units="radians"
		     description="Latitude location of vertices in radians."
		/>
		<var name="lonVertex" type="real" dimensions="nVertices" units="radians"
		     description="Longitude location of vertices in radians."
		/>
		<var name="xVertex" type="real" dimensions="nVertices" units="unitless"
		     description="X Coordinate in cartesian space of vertices."
		/>
		<var name="yVertex" type="real" dimensions="nVertices" units="unitless"
		     description="Y Coordinate in cartesian space of vertices."
		/>
		<var name="zVertex" type="real" dimensions="nVertices" units="unitless"
		     description="Z Coordinate in cartesian space of vertices."
		/>
		<var name="indexToVertexID" type="integer" dimensions="nVertices" units="unitless"
		     description="List of global vertex IDs."
		/>
		<var name="nEdgesOnCell" type="integer" dimensions="nCells" units="unitless"
		     description="Number of edges that border each cell."
		/>
		<var name="nEdgesOnEdge" type="integer" dimensions="nEdges" units="unitless"
		     description="Number of edges that surround each of the cells that straddle each edge. These edges are used to reconstruct the tangential velocities."
		/>
		<var name="cellsOnEdge" type="integer" dimensions="TWO nEdges" units="unitless"
		     description="List of cells that straddle each edge."
		/>
		<var name="edgesOnCell" type="integer" dimensions="maxEdges nCells" units="unitless"
		     description="List of edges that border each cell."
		/>
		<var name="edgesOnEdge" type="integer" dimensions="maxEdges2 nEdges" units="unitless"
		     description="List of edges that border each of the cells that straddle each edge."
		/>
		<var name="cellsOnCell" type="integer" dimensions="maxEdges nCells" units="unitless"
		     description="List of cells that neighbor each cell."
		/>
		<var name="verticesOnCell" type="integer" dimensions="maxEdges nCells" units="unitless"
		     description="List of vertices that border each cell."
		/>
		<var name="verticesOnEdge" type="integer" dimensions="TWO nEdges" units="unitless"
		     description="List of vertices that straddle each edge."
		/>
		<var name="edgesOnVertex" type="integer" dimensions="vertexDegree nVertices" units="unitless"
		     description="List of edges that share a vertex as an endpoint."
		/>
		<var name="cellsOnVertex" type="integer" dimensions="vertexDegree nVertices" units="unitless"
		     description="List of cells that share a vertex."
		/>
		<var name="weightsOnEdge" type="real" dimensions="maxEdges2 nEdges" units="unitless"
		     description="Reconstruction weights associated with each of the edgesOnEdge."
		/>
		<var name="dvEdge" type="real" dimensions="nEdges" units="m"
		     description="Length of each edge, computed as the distance between verticesOnEdge."
		/>
		<var name="dcEdge" type="real" dimensions="nEdges" units="m"
		     description="Length of each edge, computed as the distance between cellsOnEdge."
		/>
		<var name="angleEdge" type="real" dimensions="nEdges" units="radians"
		     description="Angle the edge normal makes with local eastward direction."
		/>
		<var name="areaCell" type="real" dimensions="nCells" units="m^2"
		     description="Area of each cell in the primary grid."
		/>
		<var name="areaTriangle" type="real" dimensions="nVertices" units="m^2"
		     description="Area of each cell (triangle) in the dual grid."
		/>
		<var name="kiteAreasOnVertex" type="real" dimensions="vertexDegree nVertices" units="m^2"
		     description="Area of the portions of each dual cell that are part of each cellsOnVertex."
		/>
		<var name="meshDensity" type="real" dimensions="nCells" units="unitless"
		     description="The value of the generating density function at each cell center."
		/>
		<!-- The following fields are expected by some operators but not formally part of the MPAS mesh spec. -->
		<!-- They are not input by the model but calculated internally. -->
		<var name="localVerticalUnitVectors" type="real" dimensions="R3 nCells" units="unitless"
		     description="Unit surface normal vectors defined at cell centers."
		/>
		<var name="edgeNormalVectors" type="real" dimensions="R3 nEdges" units="unitless"
		     description="Normal vector defined at an edge."
		/>
		<var name="cellTangentPlane" type="real" dimensions="R3 TWO nCells" units="unitless"
		     description="The two vectors that define a tangent plane at a cell center."
		/>
		<var name="coeffs_reconstruct" type="real" dimensions="R3 maxEdges nCells" units="unitless"
		     description="Coefficients to reconstruct velocity vectors at cell centers."
		/>
		<!-- The following field is required as input by MPAS-LI -->
		<var name="layerThicknessFractions" type="real" dimensions="nVertLevels" units="none"
		     description="Fractional thickness of each sigma layer"
		/>
		<!-- The following fields are required by MPAS-LI but are calculated internally -->
		<var name="layerCenterSigma" type="real" dimensions="nVertLevels" units="none"
		     description="Sigma (fractional) level at center of each layer"
		/>
		<var name="layerInterfaceSigma" type="real" dimensions="nVertInterfaces" units="none"
		     description="Sigma (fractional) level at interface between each layer (including top and bottom)"
		/>
		<var name="edgeSignOnCell" type="integer" dimensions="maxEdges nCells" units="unitless"
		     description="Sign of edge contributions to a cell for each edge on cell. Used for bit-reproducible loops. Represents directionality of vector connecting cells."
		/>
		<var name="edgeSignOnVertex" type="integer" dimensions="maxEdges nVertices" units="unitless"
		     description="Sign of edge contributions to a vertex for each edge on vertex. Used for bit-reproducible loops. Represents directionality of vector connecting vertices."
                     />
                <!-- Useful Variables -->
                <var name="cellProcID" type="integer" dimensions="nCells" units="unitless"
                     description="processor number for each cell"
                />
		<!-- Variables only needed by SIA solver -->
		<var name="baryCellsOnVertex" type="integer" dimensions="R3 nVertices" units="unitless"
			 description="Cell center indices to use for interpolating from cell centers to vertex locations.  Note these are local indices!" packages="SIAvelocity"
		/>
		<var name="baryWeightsOnVertex" type="real" dimensions="R3 nVertices" units="unitless"
			 description="Weights to interpolate from cell centers to vertex locations.  Each weight is used with the corresponding cell center index indentified by baryCellsOnVertex." packages="SIAvelocity"
		/>
		<!-- time-related fields have to go somewhere.  "mesh" is a more general place than the other pools -->
		<var name="xtime" type="text" time_levs="1" dimensions="Time" units="unitless"
		     description="model time, with format 'YYYY-MM-DD_HH:MM:SS'"
		/>
		<var name="deltat" type="real" time_levs="1" dimensions="Time" units="s"
		     description="time step length, in seconds.  Value on a given time is the value used between the previous time level and the current time level."
		/>
		<var name="allowableDtACFL" type="real" time_levs="1" dimensions="Time" units="s"
		     description="The maximum allowable time step based on the advective CFL condition.  Value on a given time is the value appropriate for  between the previous time level and the current time level."
		/>
		<var name="allowableDtDCFL" type="real" time_levs="1" dimensions="Time" units="s"
		     description="The maximum allowable time step based on the diffusive CFL condition.  Value on a given time is the value appropriate for  between the previous time level and the current time level."
                />
                <var name="simulationStartTime" type="text" dimensions="" units="unitless" default_value="'no_date_available'"
                     description="start time of first simulation, with format 'YYYY-MM-DD_HH:MM:SS'"
                />
                <var name="daysSinceStart" type="real" dimensions="Time" units="days"
                     description="Time since simulationStartTime in days, for plotting"
                />
	</var_struct>

<!-- ================ -->

	<!--  Variables related to ice sheet geometry -->
	<var_struct name="geometry" time_levs="1">
		<var name="bedTopography" type="real" dimensions="nCells Time" units="m above datum"
		     description="Elevation of ice sheet bed.  Once isostasy is added to the model, this should become a state variable."
		/>
		<var name="thickness" type="real" dimensions="nCells Time" units="m" time_levs="1"
		     description="ice thickness"
		/>
		<var name="layerThickness" type="real" dimensions="nVertLevels nCells Time" units="m" time_levs="1"
		     description="layer thickness"
		/>
		<var name="lowerSurface" type="real" dimensions="nCells Time" units="m above datum"
		     description="elevation at bottom of ice"
		/>
		<var name="upperSurface" type="real" dimensions="nCells Time" units="m above datum"
		     description="elevation at top of ice"
		/>
		<var name="layerThicknessEdge" type="real" dimensions="nVertLevels nEdges Time" units="m"
		     description="layer thickness on cell edges"
		/>
		<var name="cellMask" type="integer" dimensions="nCells Time" units="none"
		     description="bitmask indicating various properties about the ice sheet on cells.  cellMask only needs to be a restart field if config_allow_additional_advance = false (to keep the mask of initial ice extent)"
		/>
		<var name="edgeMask" type="integer" dimensions="nEdges Time" units="none"
		     description="bitmask indicating various properties about the ice sheet on edges."
		/>
		<var name="vertexMask" type="integer" dimensions="nVertices Time" units="none" time_levs="2"
		     description="bitmask indicating various properties about the ice sheet on vertices."
		/>
		<!-- Note vertexMask has two time level to easily check if it changes - this is only used by the HO dycores -->

		<var name="sfcMassBal" type="real" dimensions="nCells Time" units="kg m^{-2} s^{-1}"
		     description="Surface mass balance"
		/>
		<var name="basalMassBal" type="real" dimensions="nCells Time" units="kg m^{-2} s^{-1}"
                     description="Basal mass balance applied"
                />
                <var name="groundedBasalMassBal" type="real" dimensions="nCells Time" units="kg m^{-2} s^{-1}"
                     description="Basal mass balance on grounded regions"
                />
                <var name="floatingBasalMassBal" type="real" dimensions="nCells Time" units="kg m^{-2} s^{-1}"
                     description="Basal mass balance on floating regions"
                />
		<var name="calvingThickness" type="real" dimensions="nCells Time" units="m" time_levs="1"
		     description="thickness of ice that calves (less than or equal to ice thickness)"
		/>
		<var name="basalWaterThickness" type="real" dimensions="nCells Time" units="m" time_levs="1"
		     description="thickness of basal water"
		/>
		<var name="restoreThickness" type="real" dimensions="nCells Time" units="m" time_levs="1"
		     description="thickness of ice added to restore the calving front to its initial position"
                />
                <!-- Variables only needed for calculating diffusivity at cell centers - this is always done now so no package is attached here -->
		<var name="normalSlopeEdge"            type="real"     dimensions="nEdges Time"
		     units="m m^{-1}"  description="normal surface slope on edges"
		/>
                <var name="apparentDiffusivity" type="real" dimensions="nCells Time"
                        units="m^2 s^{-1}"  description="apparent diffusivity at cell centers"
		/>
		<!-- Variables only needed by SIA solver -->
		<var name="upperSurfaceVertex" type="real" dimensions="nVertices Time" units="m above datum"
		     description="elevation at top of ice on vertices" packages="SIAvelocity"
		/>
		<var name="tangentSlopeEdge"            type="real"     dimensions="nEdges Time"
		     units="m m^{-1}"  description="tangent surface slope on edges" packages="SIAvelocity"
		/>
		<var name="slopeEdge"            type="real"     dimensions="nEdges Time"
		     units="m m^{-1}"  description="surface slope magnitude on edges" packages="SIAvelocity"
		/>
	</var_struct>

<!-- ================ -->

	<!-- Variables related to velocity -->
	<var_struct name="velocity" time_levs="1">
		<var name="flowParamA" type="real" dimensions="nVertLevels nCells Time" units="s^{-1} Pa^{-n}"
		     description="flow law parameter, A"
		/>
		<var name="normalVelocity" type="real" dimensions="nVertInterfaces nEdges Time" units="m s^{-1}"
		     description="horizonal velocity, normal component to an edge, layer interface"
		/>
		<var name="layerNormalVelocity" type="real" dimensions="nVertLevels nEdges Time" units="m s^{-1}"
		     description="horizonal velocity, normal component to an edge, layer midpoint"
		/>
		<var name="normalVelocityInitial" type="real" dimensions="nVertInterfaces nEdges Time" units="m s^{-1}"
		     description="horizonal velocity, normal component to an edge, computed at initialization"
		/>
		<var name="uReconstructX"                     type="real"     dimensions="nVertInterfaces nCells Time"
		     units="m s^{-1}"  description="x-component of velocity reconstructed on cell centers.  Also, for higher-order dycores, on input: value of the x-component of velocity that should be applied where dirichletVelocityMask==1."
		/>
		<var name="uReconstructY"                     type="real"     dimensions="nVertInterfaces nCells Time"
		     units="m s^{-1}"  description="y-component of velocity reconstructed on cell centers.    Also, for higher-order dycores, on input: value of the y-component of velocity that should be applied where dirichletVelocityMask==1."
		/>
		<var name="uReconstructZ"                     type="real"     dimensions="nVertInterfaces nCells Time"
		     units="m s^{-1}"  description="z-component of velocity reconstructed on cell centers"
		/>
		<var name="uReconstructZonal"                 type="real"     dimensions="nVertInterfaces nCells Time"
		     units="m s^{-1}"  description="zonal velocity reconstructed on cell centers"
		/>
		<var name="uReconstructMeridional"            type="real"     dimensions="nVertInterfaces nCells Time"
		     units="m s^{-1}"  description="meridional velocity reconstructed on cell centers"
		/>
		<var name="surfaceSpeed"                     type="real"     dimensions="nCells Time"
		     units="m s^{-1}"  description="ice surface speed reconstructed at cell centers"
		/>
		<var name="basalSpeed"                     type="real"     dimensions="nCells Time"
		     units="m s^{-1}"  description="ice basal speed reconstructed at cell centers"
		/>
		<var name="beta" type="real" dimensions="nCells Time" units="Pa s m^{1}"
		     description="higher-order basal traction parameter"
		/>
		<var name="betaSolve" type="real" dimensions="nCells Time" units="Pa s m^{1}"
		     description="higher-order basal traction parameter"
		/>

		<!-- Variables only needed by HO solver -->
		<var name="anyDynamicVertexMaskChanged"              type="integer"  dimensions="Time"
		     units="none"  description="flag needed by external velocity solvers that indicates if the region to solve on the block's domain has changed (treated as a logical)"
			packages="higherOrderVelocity"
		/>
		<var name="dirichletVelocityMask"            type="integer"     dimensions="nVertInterfaces nCells Time"
			units="none"  time_levs="2"
			description="mask of where Dirichlet boundary conditions should be applied to the velocity solution.  1 means apply a Dirichlet boundary condition, 0 means do not. (higher-order dycores only)"
			packages="higherOrderVelocity"
		/>
		<var name="dirichletMaskChanged"              type="integer"  dimensions="Time"
		     units="none"  description="flag needed by external velocity solvers that indicates if the Dirichlet boundary condition mask has changed (treated as a logical)"
			packages="higherOrderVelocity"
		/>
		<var name="floatingEdges"
			type="integer" dimensions="nEdges Time"
			units="unitless"
			description="edges which are floating have a value of 1.  non floating edges have a value of 0."
			packages="higherOrderVelocity"
		/>
	</var_struct>

<!-- ================ -->

	<!-- Variables related to thermal state -->
	<var_struct name="thermal" time_levs="1">
		<var name="temperature" type="real" dimensions="nVertLevels nCells Time" units="K"
		     description="interior ice temperature"
		/>
		<var name="waterfrac" type="real" dimensions="nVertLevels nCells Time" units="unitless"
		     description="interior water fraction"
		/>
		<var name="enthalpy" type="real" dimensions="nVertLevels nCells Time" units="J m^{-3}"
		     description="interior ice enthalpy"
		/>
		<var name="surfaceAirTemperature" type="real" dimensions="nCells Time" units="K"
		     description="surface air temperature"
		/>
		<var name="surfaceTemperature" type="real" dimensions="nCells Time" units="K"
		     description="upper surface ice temperature"
		/>
		<var name="basalTemperature" type="real" dimensions="nCells Time" units="K"
		     description="lower surface ice temperature"
		/>
		<var name="pmpTemperature" type="real" dimensions="nVertLevels nCells Time" units="K"
		     description="pressure melt temperature"
		/>
		<var name="basalPmpTemperature" type="real" dimensions="nCells Time" units="K"
		     description="lower surface pressure melt temperature"
		/>
		<var name="surfaceConductiveFlux" type="real" dimensions="nCells Time" units="W m^{-2}"
		     description="conductive heat flux at the upper surface (positive downward)"
		/>
		<var name="basalConductiveFlux" type="real" dimensions="nCells Time" units="W m^{-2}"
		     description="conductive heat flux at the lower surface (positive downward)"
		/>
		<var name="basalHeatFlux" type="real" dimensions="nCells Time" units="W m^{-2}"
		     description="basal heat flux into the ice (positive upward)"
		/>
		<var name="basalFrictionFlux" type="real" dimensions="nCells Time" units="W m^{-2}"
		     description="basal frictional flux into the ice (positive upward)"
		/>
		<var name="heatDissipation" type="real" dimensions="nVertLevels nCells Time" units="deg s"
		     description="interior heat dissipation rate, divided by rhoi*cp_ice"
		/>
	</var_struct>

<!-- ================ -->

	<!-- Scratch Variables -->
	<var_struct name="scratch" time_levs="1">
	  <var name="iceCellMask" type="integer" dimensions="nCells" units="none"
	       description="mask set to 1 in cells where some criterion is satisfied and 0 otherwise"
	       persistence="scratch"
	       />
	  <var name="iceCellMask2" type="integer" dimensions="nCells" units="none"
	       description="mask set to 1 in cells where some criterion is satisfied and 0 otherwise"
	       persistence="scratch"
	       />
	  <var name="iceCellMask3" type="integer" dimensions="nCells" units="none"
	       description="mask set to 1 in cells where some criterion is satisfied and 0 otherwise"
	       persistence="scratch"
	       />
	  <var name="iceEdgeMask" type="integer" dimensions="nEdges" units="none"
	       description="mask set to 1 for edges adjacent to ice-covered cells and 0 otherwise"
	       persistence="scratch"
	       />
	  <var name="workLevelCell" type="real" dimensions="nVertLevels nCells" units="none"
	       description="generic work array with dimensions of (nVertLevels nCells)"
	       persistence="scratch"
	       />
	  <var name="workLevelEdge" type="real" dimensions="nVertLevels nEdges" units="none"
	       description="generic work array with dimensions of (nVertLevels nEdges)"
	       persistence="scratch"
	       />
	  <var name="workCell" type="real" dimensions="nCells" units="none"
	       description="generic work array with dimensions of (nCells)"
	       persistence="scratch"
	       />
	  <var name="workCell2" type="real" dimensions="nCells" units="none"
	       description="generic work array with dimensions of (nCells)"
	       persistence="scratch"
	       />
	  <var name="workCell3" type="real" dimensions="nCells" units="none"
	       description="generic work array with dimensions of (nCells)"
	       persistence="scratch"
	       />
	  <var name="workTracerCell" type="real" dimensions="maxTracersAdvect nCells" units="none"
	       description="generic work array with dimensions of (maxTracersAdvect nCells)"
	       persistence="scratch"
	       />
	  <var name="workTracerCell2" type="real" dimensions="maxTracersAdvect nCells" units="none"
	       description="generic work array with dimensions of (maxTracersAdvect nCells)"
	       persistence="scratch"
	       />
	  <var name="workTracerLevelCell" type="real" dimensions="maxTracersAdvect nVertLevels nCells" units="none"
	       description="generic work array with dimensions of (maxTracersAdvect nVertLevels nCells)"
	       persistence="scratch"
	       />
	  <var name="workTracerLevelCell2" type="real" dimensions="maxTracersAdvect nVertLevels nCells" units="none"
	       description="generic work array with dimensions of (maxTracersAdvect nVertLevels nCells)"
	       persistence="scratch"
	       />
	  <var name="slopeCellX" type="real" dimensions="nCells" units="none"
	       descriptiom="x-component of slope on cell centers"
	       persistence="scratch"
	       />
	  <var name="slopeCellY" type="real" dimensions="nCells" units="none"
	       descriptiom="y-component of slope on cell centers"
	       persistence="scratch"
	       />
	  <var name="vertexIndices" type="integer" dimensions="nVertices" units="none"
	       description="local indices of each vertex"
	       persistence="scratch"
	       />
	</var_struct>

<!-- ================ -->

	<!-- Region Masks (currently only the regionCellMasks field is used by the regional stats AM) -->
        <var_struct name="regions" time_levs="1">
	  <var name="regionCellMasks" type="integer" dimensions="nRegions nCells" units="unitless"
	       description="masks set to 1 in cells that fall within a given region and 0 otherwise"
	       />
	  <!--var name="nCellsInRegion" type="integer" dimensions="nRegions" units="unitless"
	       description="number of cells that fall within a given region"
	       />
	  <var name="regionVertexMasks" type="integer" dimensions="nRegions nVertices" units="unitless"
	       description="masks set to 1 for vertices that fall within a given region and 0 otherwise"
	       />
	  <var name="nVerticesInRegion" type="integer" dimensions="nRegions" units="unitless"
	       description="number of vertices that fall within a given region"
	       />
	  <var name="nRegionsInGroup" type="integer" dimensions="nRegionGroups" units="unitless"
	       description="number of regions within a given group"
	       />
	  <var name="regionsInGroup" type="integer" dimensions="maxRegionsInGroup nRegionGroups" units="unitless"
	       description="list of region indices in each group"
	       />
	  <var name="regionMaskNames" type="text" dimensions="nRegions" units="unitless"
	       description="name of region masks"
	       />
	  <var name="regionGroupNames" type="text" dimensions="nRegionGroups" units="unitless"
	       description="name of region groups"
	       /-->
	</var_struct>

<!-- ======================================================================= -->

#include "subglacial_hydro/Registry_subglacial_hydro.xml"

#include "analysis_members/Registry_analysis_members.xml"

</registry>
