

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3. Design Details &#8212; CIME 5.3.0_alpha17 documentation</title>
    
    <link rel="stylesheet" href="../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '5.3.0_alpha17',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4. Data Model Science" href="data-model-science.html" />
    <link rel="prev" title="2. Input Streams" href="input-streams.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="data-model-science.html" title="4. Data Model Science"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="input-streams.html" title="2. Input Streams"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CIME 5.3.0_alpha17 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">CIME Data Models</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Design Details</a><ul>
<li><a class="reference internal" href="#io-through-data-models">3.1. IO Through Data Models</a></li>
<li><a class="reference internal" href="#restart-files">3.2. Restart Files</a></li>
<li><a class="reference internal" href="#data-structures">3.3. Data Structures</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="input-streams.html"
                        title="previous chapter">2. Input Streams</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="data-model-science.html"
                        title="next chapter">4. Data Model Science</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/data_models/design-details.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="design-details">
<span id="id1"></span><h1>3. Design Details<a class="headerlink" href="#design-details" title="Permalink to this headline">¶</a></h1>
<p>The data model functionality is executed via set of specific operations associated with reading and interpolating data in space and time.
The strdata implementation does the following:</p>
<ol class="arabic simple">
<li>determines nearest lower and upper bound data from the input dataset</li>
<li>if that is new data then read lower and upper bound data</li>
<li>fill lower and upper bound data</li>
<li>spatially map lower and upper bound data to model grid</li>
<li>time interpolate lower and upper bound data to model time</li>
<li>return fields to data model</li>
</ol>
<div class="section" id="io-through-data-models">
<span id="io-details"></span><h2>3.1. IO Through Data Models<a class="headerlink" href="#io-through-data-models" title="Permalink to this headline">¶</a></h2>
<p>Namlist variables referenced below are discussed in detail in <a class="reference internal" href="input-streams.html#shr-strdata-nml"><span class="std std-ref">stream data namelist section</span></a>.</p>
<p>The two timestamps of input data that bracket the present model time are read first.
These are called the lower and upper bounds of data and will change as the model advances.
Those two sets of inputdata are first filled based on the user setting of the namelist variables <code class="docutils literal"><span class="pre">str_fillalgo</span></code> and <code class="docutils literal"><span class="pre">str_fillmask</span></code>.
That operation occurs on the input data grid.
The lower and upper bound data are then spatially mapped to the model grid based upon the user setting of the namelist variables <code class="docutils literal"><span class="pre">str_mapalgo</span></code> and <code class="docutils literal"><span class="pre">str_mapmask</span></code>.
Spatial interpolation only occurs if the input data grid and model grid are not the identical, and this is determined in the strdata module automatically.
Time interpolation is the final step and is done using a time interpolation method specified by the user in namelist (via the shr_strdata_nml namelist variable &#8220;tintalgo&#8221;).
A final set of fields is then available to the data model on the model grid and for the current model time.</p>
<p>There are two primary costs associated with strdata, reading data and spatially mapping data.
Time interpolation is relatively cheap in the current implementation.
As much as possible, redundant operations are minimized.
Fill and mapping weights are generated at initialization and saved.
The upper and lower bound mapped input data is saved between time steps to reduce mapping costs in cases where data is time interpolated more often than new data is read.
If the input data timestep is relatively small (for example, hourly data as opposed to daily or monthly data) the cost of reading input data can be quite large.
Also, there can be significant variation in cost of the data model over the coarse of the run, for instance, when new inputdata must be read and interpolated, although it&#8217;s relatively predictable.
The present implementation doesn&#8217;t support changing the order of operations, for instance, time interpolating the data before spatial mapping.
Because the present computations are always linear, changing the order of operations will not fundamentally change the results.
The present order of operations generally minimizes the mapping cost for typical data model use cases.</p>
<p>There are several limitations in both options and usage within the data models at the present time.
Spatial interpolation can only be performed from a two-dimensional latitude-longitude input grid.
The target grid can be arbitrary but the source grid must be able to be described by simple one-dimensional lists of longitudes and latitudes, although they don&#8217;t have to have equally spaced.</p>
<p>At the present time, data models can only read netcdf data, and IO is handled through either standard netcdf interfaces or through the PIO library using either netcdf or pnetcdf.
If standard netcdf is used, global fields are read and then scattered one field at a time.
If PIO is used, then data will be read either serially or in parallel in chunks that are approximately the global field size divided by the number of io tasks.
If pnetcdf is used through PIO, then the pnetcdf library must be included during the build of the model.
The pnetcdf path and option is hardwired into the <code class="docutils literal"><span class="pre">Macros.make</span></code> file for the specific machine.
To turn on <code class="docutils literal"><span class="pre">pnetcdf</span></code> in the build, make sure the <code class="docutils literal"><span class="pre">Macros.make</span></code> variables PNETCDF_PATH, INC_PNETCDF, and LIB_PNETCDF are set and that the PIO CONFIG_ARGS sets the PNETCDF_PATH argument.</p>
<p>Beyond just the option of selecting IO with PIO, several namelist are available to help optimize PIO IO performance.
Those are <strong>TODO</strong> - list these.
The total mpi tasks that can be used for IO is limited to the total number of tasks used by the data model.
Often though, fewer io tasks result in improved performance.
In general, [io_root + (num_iotasks-1)*io_stride + 1] has to be less than the total number of data model tasks.
In practice, PIO seems to perform optimally somewhere between the extremes of 1 task and all tasks, and is highly machine and problem dependent.
.. _restart-files:</p>
</div>
<div class="section" id="restart-files">
<span id="id2"></span><h2>3.2. Restart Files<a class="headerlink" href="#restart-files" title="Permalink to this headline">¶</a></h2>
<p>Restart files are generated automatically by the data models based upon a flag sent from the driver.
The restart files must meet the CIME naming convention and an <code class="docutils literal"><span class="pre">rpointer</span></code> file is generated at the same time.
An <code class="docutils literal"><span class="pre">rpointer</span></code> file is a <em>restart pointer</em> file which contains the name of the most recently created restart file.
Normally, if restart files are read, the restart filenames are specified in the rpointer file.
Optionally though, there are namelist variables such as <cite>restfilm`</cite> to specify the restart filenames via namelist. If those namelist are set, the <code class="docutils literal"><span class="pre">rpointer</span></code> file will be ignored.
The default method is to use the <code class="docutils literal"><span class="pre">rpointer</span></code> files to specify the restart filenames.
In most cases, no model restart is required for the data models to restart exactly.
This is because there is no memory between timesteps in many of the data model science modes.
If a model restart is required, it will be written automatically and then must be used to continue the previous run.</p>
<p>There are separate stream restart files that only exist for performance reasons.
A stream restart file contains information about the time axis of the input streams.
This information helps reduce the start costs associated with reading the input dataset time axis information.
If a stream restart file is missing, the code will restart without it but may need to reread data from the input data files that would have been stored in the stream restart file.
This will take extra time but will not impact the results.</p>
</div>
<div class="section" id="data-structures">
<span id="id3"></span><h2>3.3. Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<p>The data models all use three fundamental routines.</p>
<ul class="simple">
<li>$CIMEROOT/src/utils/shr_dmodel_mod.F90</li>
<li>$CIMEROOT/src/utils/shr_stream_mod.F90</li>
<li>$CIMEROOT/src/utils/shr_strdata.F90</li>
</ul>
<p>These routines contain three data structures that are leveraged by all the data model code.</p>
<p>The most basic type, <code class="docutils literal"><span class="pre">shr_stream_fileType</span></code> is contained in <code class="docutils literal"><span class="pre">shr_stream_mod.F90</span></code> and specifies basic information related to a given stream file.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>type shr_stream_fileType
   character(SHR_KIND_CL) :: name = shr_stream_file_null     ! the file name
   logical                :: haveData = .false.              ! has t-coord data been read in?
   integer  (SHR_KIND_IN) :: nt = 0                          ! size of time dimension
   integer  (SHR_KIND_IN),allocatable :: date(:)             ! t-coord date: yyyymmdd
   integer  (SHR_KIND_IN),allocatable :: secs(:)             ! t-coord secs: elapsed on date
end type shr_stream_fileType
</pre></div>
</div>
<p>The following type, <code class="docutils literal"><span class="pre">shr_stream_streamType</span></code> contains information
that encapsulates the information related to all files specific to a
target stream. These are the list of files found in the <code class="docutils literal"><span class="pre">domainInfo</span></code>
and <code class="docutils literal"><span class="pre">fieldInfo</span></code> blocks of the target stream description file (see the overview of the <a class="reference internal" href="input-streams.html#stream-description-file"><span class="std std-ref">Stream Description File</span></a>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>type shr_stream_streamType
   !private                                    ! no public access to internal components
   !--- input data file names and data ---
   logical                   :: init           ! has stream been initialized?
   integer  (SHR_KIND_IN),pointer :: initarr(:) =&gt; null()! surrogate for init flag
   integer  (SHR_KIND_IN)    :: nFiles         ! number of data files
   character(SHR_KIND_CS)    :: dataSource     ! meta data identifying data source
   character(SHR_KIND_CL)    :: filePath       ! remote location of data files
   type(shr_stream_fileType), allocatable :: file(:) ! data specific to each file

   !--- specifies how model dates align with data dates ---
   integer(SHR_KIND_IN)      :: yearFirst      ! first year to use in t-axis (yyyymmdd)
   integer(SHR_KIND_IN)      :: yearLast       ! last  year to use in t-axis (yyyymmdd)
   integer(SHR_KIND_IN)      :: yearAlign      ! align yearFirst with this model year
   integer(SHR_KIND_IN)      :: offset         ! offset in seconds of stream data
   character(SHR_KIND_CS)    :: taxMode        ! cycling option for time axis

   !--- useful for quicker searching ---
   integer(SHR_KIND_IN) :: k_lvd,n_lvd         ! file/sample of least valid date
   logical              :: found_lvd           ! T &lt;=&gt; k_lvd,n_lvd have been set
   integer(SHR_KIND_IN) :: k_gvd,n_gvd         ! file/sample of greatest valid date
   logical              :: found_gvd           ! T &lt;=&gt; k_gvd,n_gvd have been set

   !---- for keeping files open
   logical                 :: fileopen         ! is current file open
   character(SHR_KIND_CL)  :: currfile         ! current filename
   type(file_desc_t)       :: currpioid        ! current pio file desc

   !--- stream data not used by stream module itself ---
   character(SHR_KIND_CXX):: fldListFile       ! field list: file&#39;s  field names
   character(SHR_KIND_CXX):: fldListModel      ! field list: model&#39;s field names
   character(SHR_KIND_CL) :: domFilePath       ! domain file: file path of domain file
   character(SHR_KIND_CL) :: domFileName       ! domain file: name
   character(SHR_KIND_CS) :: domTvarName       ! domain file: time-dim var name
   character(SHR_KIND_CS) :: domXvarName       ! domain file: x-dim var name
   character(SHR_KIND_CS) :: domYvarName       ! domain file: y-dim var name
   character(SHR_KIND_CS) :: domZvarName       ! domain file: z-dim var name
   character(SHR_KIND_CS) :: domAreaName       ! domain file: area  var name
   character(SHR_KIND_CS) :: domMaskName       ! domain file: mask  var name

   character(SHR_KIND_CS) :: tInterpAlgo       ! Algorithm to use for time interpolation
   character(SHR_KIND_CL) :: calendar          ! stream calendar
end type shr_stream_streamType
</pre></div>
</div>
<p>and finally, the <code class="docutils literal"><span class="pre">shr_strdata_type</span></code> is the heart of the CIME data
model implemenentation and contains information for all the streams
that are active for the target data model. The first part of the
shr_strdata_type is filled in by the namelist values read in from the
namelist group (see the <a class="reference internal" href="input-streams.html#shr-strdata-nml"><span class="std std-ref">stream data namelist section</span></a>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span> type shr_strdata_type
   ! --- set by input namelist ---
  character(CL)  :: dataMode          ! flags physics options wrt input data
  character(CL)  :: domainFile        ! file   containing domain info
  character(CL)  :: streams (nStrMax) ! stream description file names
  character(CL)  :: taxMode (nStrMax) ! time axis cycling mode
  real(R8)       :: dtlimit (nStrMax) ! dt max/min limit
  character(CL)  :: vectors (nVecMax) ! define vectors to vector map
  character(CL)  :: fillalgo(nStrMax) ! fill algorithm
  character(CL)  :: fillmask(nStrMax) ! fill mask
  character(CL)  :: fillread(nStrMax) ! fill mapping file to read
  character(CL)  :: fillwrit(nStrMax) ! fill mapping file to write
  character(CL)  :: mapalgo (nStrMax) ! scalar map algorithm
  character(CL)  :: mapmask (nStrMax) ! scalar map mask
  character(CL)  :: mapread (nStrMax) ! regrid mapping file to read
  character(CL)  :: mapwrit (nStrMax) ! regrid mapping file to write
  character(CL)  :: tintalgo(nStrMax) ! time interpolation algorithm
  integer(IN)    :: io_type           ! io type, currently pnetcdf or netcdf

  !--- data required by cosz t-interp method, ---
  real(R8)     :: eccen   ! orbital eccentricity
  real(R8)     :: mvelpp  ! moving vernal equinox long
  real(R8)     :: lambm0  ! mean long of perihelion at vernal equinox (radians)
  real(R8)     :: obliqr  ! obliquity in degrees
  integer(IN)  :: modeldt ! data model dt in seconds (set to the coupling frequency)

  ! --- data model grid, public ---
  integer(IN)     :: nxg          ! data model grid lon size
  integer(IN)     :: nyg          ! data model grid lat size
  integer(IN)     :: nzg          ! data model grid vertical size
  integer(IN)     :: lsize        ! data model grid local size
  type(mct_gsmap) :: gsmap        ! data model grid global seg map
  type(mct_ggrid) :: grid         ! data model grid ggrid
  type(mct_avect) :: avs(nStrMax) ! data model stream attribute vectors

  ! --- stream specific arrays, stream grid ---
  type(shr_stream_streamType)    :: stream(nStrMax)
  type(iosystem_desc_t), pointer :: pio_subsystem =&gt; null()
  type(io_desc_t)    :: pio_iodesc(nStrMax)
  integer(IN)        :: nstreams          ! actual number of streams
  integer(IN)        :: strnxg(nStrMax)   ! stream grid lon sizes
  integer(IN)        :: strnyg(nStrMax)   ! stream grid lat sizes
  integer(IN)        :: strnzg(nStrMax)   ! tream grid global sizes
  logical            :: dofill(nStrMax)   ! true if stream grid is different from data model grid
  logical            :: domaps(nStrMax)   ! true if stream grid is different from data model grid
  integer(IN)        :: lsizeR(nStrMax)   ! stream local size of gsmapR on processor
  type(mct_gsmap)    :: gsmapR(nStrMax)   ! stream global seg map
  type(mct_rearr)    :: rearrR(nStrMax)   ! rearranger
  type(mct_ggrid)    :: gridR(nStrMax)    ! local stream grid on processor
  type(mct_avect)    :: avRLB(nStrMax)    ! Read attrvect
  type(mct_avect)    :: avRUB(nStrMax)    ! Read attrvect
  type(mct_avect)    :: avFUB(nStrMax)    ! Final attrvect
  type(mct_avect)    :: avFLB(nStrMax)    ! Final attrvect
  type(mct_avect)    :: avCoszen(nStrMax) ! data assocaited with coszen time interp
  type(mct_sMatP)    :: sMatPf(nStrMax)   ! sparse matrix map for fill on stream grid
  type(mct_sMatP)    :: sMatPs(nStrMax)   ! sparse matrix map for mapping from stream to data model grid
  integer(IN)        :: ymdLB(nStrMax)    ! lower bound time for stream
  integer(IN)        :: todLB(nStrMax)    ! lower bound time for stream
  integer(IN)        :: ymdUB(nStrMax)    ! upper bound time for stream
  integer(IN)        :: todUB(nStrMax)    ! upper bound time for stream
  real(R8)           :: dtmin(nStrMax)
  real(R8)           :: dtmax(nStrMax)

  ! --- internal ---
  integer(IN)        :: ymd  ,tod
  character(CL)      :: calendar          ! model calendar for ymd,tod
  integer(IN)        :: nvectors          ! number of vectors
  integer(IN)        :: ustrm (nVecMax)
  integer(IN)        :: vstrm (nVecMax)
  character(CL)      :: allocstring
end type shr_strdata_type
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="data-model-science.html" title="4. Data Model Science"
             >next</a> |</li>
        <li class="right" >
          <a href="input-streams.html" title="2. Input Streams"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CIME 5.3.0_alpha17 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >CIME Data Models</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Mariana Vertenstein, Rob Jacob, Jim Edwards, Jim Foucar, Alice Bertini, Bill Sacks.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>