{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Energy Exascale Earth System Model (E3SM)","text":"<p>The documentation for the components of E3SM is found here.</p>"},{"location":"#components","title":"Components","text":"<ul> <li>EAM</li> <li>EAMxx</li> <li>ELM</li> <li>MOSART</li> <li>MPAS-seaice</li> </ul> <p>Please see Developing Docs to learn about developing documentation for E3SM.</p>"},{"location":"EAM/","title":"The E3SM Atmosphere Model (EAM)","text":"<p>Some introductory text here</p> <ul> <li>The EAM User's Guide explains how to control EAM when its running within E3SM.</li> <li>The EAM Developer's Guide explains EAM data structures and how to write new code.</li> <li>The EAM Techincal Guide explains the science behind EAM's code</li> </ul>"},{"location":"EAM/dev-guide/","title":"Developers's Guide","text":"<p>start of the EAM Developer's Guide</p>"},{"location":"EAM/tech-guide/","title":"Technical Guide","text":"<p>start of the EAM Technical Guide</p>"},{"location":"EAM/user-guide/","title":"Users's Guide","text":"<p>start of the EAM User's Guide</p>"},{"location":"EAMxx/","title":"The C++ E3SM Atmosphere Model (EAMxx)","text":"<p>Some nice introductory text goes here! Maybe some figures, too. Who knows?!</p> <ul> <li>The User Guide explains how to run EAMxx, both in   its standalone configuration and within E3SM.</li> <li>The Developer Guide contains all the information needed   to contribute to the development of EAMxx.</li> <li>The Technical Guide contains all the technical   information about EAMxx.</li> </ul>"},{"location":"EAMxx/common/eamxx_params/","title":"EAMxx runtime configurable parameters","text":""},{"location":"EAMxx/common/eamxx_params/#atmosphere-processes-parameters","title":"Atmosphere Processes Parameters","text":""},{"location":"EAMxx/common/eamxx_params/#sc_import","title":"sc_import","text":"<ul> <li>sc_import::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>sc_import::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>sc_import::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>sc_import::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>sc_import::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>sc_import::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#sc_export","title":"sc_export","text":"<ul> <li>sc_export::prescribed_constants::fields:  <ul> <li>description: MISSING </li> <li>type: array(string)  </li> </ul> </li> <li> <p>sc_export::prescribed_constants::values:  </p> <ul> <li>description: MISSING </li> <li>type: array(real)  </li> </ul> </li> <li> <p>sc_export::prescribed_from_file::fields:  </p> <ul> <li>description: MISSING </li> <li>type: array(string)  </li> </ul> </li> <li>sc_export::prescribed_from_file::files:  <ul> <li>description: MISSING </li> <li>type: array(string)  </li> </ul> </li> <li> <p>sc_export::prescribed_from_file::fields_alt_name:  </p> <ul> <li>description: MISSING </li> <li>type: array(string)  </li> </ul> </li> <li> <p>sc_export::number_of_subcycles:  </p> <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>sc_export::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>sc_export::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>sc_export::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>sc_export::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>sc_export::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#homme","title":"homme","text":"<ul> <li>homme::Moisture:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>homme::BfbHash:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>homme::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>homme::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>homme::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>homme::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>homme::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>homme::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#p3","title":"p3","text":"<ul> <li>p3::do_prescribed_ccn:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>p3::do_predict_nc:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>p3::enable_column_conservation_checks:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>p3::max_total_ni:  <ul> <li>description: maximum total ice concentration (sum of all categories)  </li> <li>type: real  </li> <li>constraints: gt 0  </li> </ul> </li> <li>p3::tables:  <ul> <li>description: MISSING </li> <li>type: array(file)  </li> </ul> </li> <li>p3::p3_autoconversion_prefactor:  <ul> <li>description: P3 autoconversion_prefactor (scale factor in autoconversion)  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_mu_r_constant:  <ul> <li>description: P3 mu_r_constant (rain shape parameter in gamma drop-size distribution)  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_spa_to_nc:  <ul> <li>description: P3 spa_to_nc (scaling factor for turning CCN into nc in SPA)  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_k_accretion:  <ul> <li>description: P3 k_accretion (scaling factor on accretion)  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_eci:  <ul> <li>description: P3 eci (liquid/ice collision/collection coefficient)  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_eri:  <ul> <li>description: P3 eri (ice/rain collision/collection coefficient)  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_rho_rime_min:  <ul> <li>description: P3 rho_rime_min (riming density maximum)  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_rho_rime_max:  <ul> <li>description: P3 rho_rime_max (riming density minimum)  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_a_imm:  <ul> <li>description: P3 a_imm (drop freezing exponent )  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_dep_nucleation_exponent:  <ul> <li>description: P3 dep_nucleation_exponent (deposition nucleation)  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_ice_sed_knob:  <ul> <li>description: P3 ice_sed_knob (ice fall speed)  </li> <li>type: real  </li> </ul> </li> <li>p3::p3_d_breakup_cutoff:  <ul> <li>description: P3 d_breakup_cutoff (rain self collection and breakup)  </li> <li>type: real  </li> </ul> </li> <li>p3::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>p3::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>p3::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>p3::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>p3::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>p3::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#shoc","title":"shoc","text":"<ul> <li>shoc::enable_column_conservation_checks:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>shoc::check_flux_state_consistency:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>shoc::lambda_low:  <ul> <li>description: minimum value of stability correction.  </li> <li>type: real  </li> </ul> </li> <li>shoc::lambda_high:  <ul> <li>description: maximum value of stability correction.  </li> <li>type: real  </li> </ul> </li> <li>shoc::lambda_slope:  <ul> <li>description: slope of change from lambda_low to lambda_high.  </li> <li>type: real  </li> </ul> </li> <li>shoc::lambda_thresh:  <ul> <li>description: stability threshold for which to apply more stability correction.  </li> <li>type: real  </li> </ul> </li> <li>shoc::thl2tune:  <ul> <li>description: Temperature variance tuning factor  </li> <li>type: real  </li> </ul> </li> <li>shoc::qw2tune:  <ul> <li>description: Moisture variance tuning factor  </li> <li>type: real  </li> </ul> </li> <li>shoc::qwthl2tune:  <ul> <li>description: Temperature moisture covariance  </li> <li>type: real  </li> </ul> </li> <li>shoc::w2tune:  <ul> <li>description: Vertical velocity variance  </li> <li>type: real  </li> </ul> </li> <li>shoc::length_fac:  <ul> <li>description: Length scale factor  </li> <li>type: real  </li> </ul> </li> <li>shoc::c_diag_3rd_mom:  <ul> <li>description: Third moment vertical velocity damping factor  </li> <li>type: real  </li> </ul> </li> <li>shoc::Ckh:  <ul> <li>description: Eddy diffusivity coefficient for heat  </li> <li>type: real  </li> </ul> </li> <li>shoc::Ckm:  <ul> <li>description: Eddy diffusivity coefficient for momentum  </li> <li>type: real  </li> </ul> </li> <li>shoc::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>shoc::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>shoc::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>shoc::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>shoc::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>shoc::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#cldfraction","title":"cldFraction","text":"<ul> <li>cldFraction::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>cldFraction::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>cldFraction::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>cldFraction::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>cldFraction::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>cldFraction::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#mam4_optics","title":"mam4_optics","text":"<ul> <li>mam4_optics::mam4_mode1_physical_properties_file:  <ul> <li>description: File containing optical properties for MAM4 mode 1, accumulation mode  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_mode2_physical_properties_file:  <ul> <li>description: File containing optical properties for MAM4 mode 2, Aitken mode  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_mode3_physical_properties_file:  <ul> <li>description: File containing optical properties for MAM4 mode 3, coarse mode  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_mode4_physical_properties_file:  <ul> <li>description: File containing optical properties for MAM4 mode 4, p-carbon mode  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_water_refindex_file:  <ul> <li>description: File containing optical properties for aerosol water  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_soa_physical_properties_file:  <ul> <li>description: File containing optical properties for secondary organic aerosol  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_dust_physical_properties_file:  <ul> <li>description: File containing optical properties for dust  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_nacl_physical_properties_file:  <ul> <li>description: File containing optical properties for sea salt  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_so4_physical_properties_file:  <ul> <li>description: File containing optical properties for sulfate  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_pom_physical_properties_file:  <ul> <li>description: File containing optical properties for primary organic aerosol  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_bc_physical_properties_file:  <ul> <li>description: File containing optical properties for black carbon  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::mam4_mom_physical_properties_file:  <ul> <li>description: File containing optical properties for marine organic aerosol  </li> <li>type: file  </li> </ul> </li> <li>mam4_optics::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>mam4_optics::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>mam4_optics::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>mam4_optics::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>mam4_optics::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>mam4_optics::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#nudging","title":"nudging","text":"<ul> <li>nudging::nudging_filenames_patterns:  <ul> <li>description: MISSING </li> <li>type: array(string)  </li> </ul> </li> <li>nudging::nudging_fields:  <ul> <li>description: List of fields to be nudged.  Note, syntax of 'A:B' represents nudging field A with data from field B in files, syntax of 'A' assumes that nudging file has the same variables name as EAMxx  </li> <li>type: array(string)  </li> </ul> </li> <li>nudging::nudging_timescale:  <ul> <li>description: Timescale to apply nudging tendencies, 0: full replacement, &gt;0: actual timescale  </li> <li>type: integer  </li> </ul> </li> <li>nudging::use_nudging_weights:  <ul> <li>description: Flag for nudging weights option  </li> <li>type: logical  </li> </ul> </li> <li>nudging::nudging_weights_file:  <ul> <li>description: weights that relax the nudging fields update  </li> <li>type: string  </li> </ul> </li> <li>nudging::skip_vert_interpolation:  <ul> <li>description: Flag for skipping vertical interpolation  </li> <li>type: logical  </li> </ul> </li> <li>nudging::source_pressure_type:  <ul> <li>description: Flag for how source pressure levels are handled in the nudging dataset.     TIME_DEPENDENT_3D_PROFILE: The dataset contains a time-varying pressure profile, variable name 'p_mid' with dimensions (time,ncol,nlev).     STATIC_1D_VERTICAL_PROFILE: The dataset uses a fixed in time single pressure profile, variable name 'p_lev' with dimension (nlev).  </li> <li>type: string  </li> <li>valid values: TIME_DEPENDENT_3D_PROFILE,STATIC_1D_VERTICAL_PROFILE  </li> </ul> </li> <li>nudging::source_pressure_file:  <ul> <li>description: If STATIC_1D_VERTICAL_PROFILE, this is an optional arg to point to a file with the source pressure levels defined.     Default is to look for p_levs in the first nudging_filenames_patterns file  </li> <li>type: string  </li> </ul> </li> <li>nudging::nudging_refine_remap_mapfile:  <ul> <li>description: Refine-remapping mapfile from the source nudging dataset to the physics grid  </li> <li>type: string  </li> </ul> </li> <li>nudging::nudging_refine_remap_vert_cutoff:  <ul> <li>description: A vertical cutoff to go with refine-remap logic (in units of p_mid) where the nudging is turned off above it (closer to the surface)  </li> <li>type: real  </li> </ul> </li> <li>nudging::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>nudging::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>nudging::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>nudging::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>nudging::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>nudging::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#mlcorrection","title":"mlcorrection","text":"<ul> <li>mlcorrection::ML_model_path_tq:  <ul> <li>description: Path to pre-trained ML model for temperature and specific humidity  </li> <li>type: string  </li> </ul> </li> <li>mlcorrection::ML_model_path_uv:  <ul> <li>description: Path to pre-trained ML model for wind fields  </li> <li>type: string  </li> </ul> </li> <li>mlcorrection::ML_model_path_sfc_fluxes:  <ul> <li>description: Path to pre-trained ML model for surface fluxes  </li> <li>type: string  </li> </ul> </li> <li>mlcorrection::ML_output_fields:  <ul> <li>description: ML correction output variables, the following variables are supported: T_mid,qv,u,v  </li> <li>type: array(string)  </li> </ul> </li> <li>mlcorrection::ML_correction_unit_test:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>mlcorrection::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>mlcorrection::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>mlcorrection::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>mlcorrection::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>mlcorrection::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>mlcorrection::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#testonly","title":"testOnly","text":"<ul> <li>testOnly::my_param:  <ul> <li>description: MISSING </li> <li>type: array(integer)  </li> </ul> </li> <li>testOnly::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>testOnly::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>testOnly::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>testOnly::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>testOnly::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>testOnly::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#spa","title":"spa","text":"<ul> <li>spa::spa_remap_file:  <ul> <li>description: File containing mapping data from the grid of spa_data_file to the model grid. Unused if the grid is the same.  </li> <li>type: file  </li> </ul> </li> <li>spa::spa_data_file:  <ul> <li>description: File containing aerosol data. Must be on same grid as the atm, or a coarser one  </li> <li>type: file  </li> </ul> </li> <li>spa::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>spa::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>spa::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>spa::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>spa::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>spa::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#rrtmgp","title":"rrtmgp","text":"<ul> <li>rrtmgp::rrtmgp_coefficients_file_sw:  <ul> <li>description: MISSING </li> <li>type: file  </li> </ul> </li> <li>rrtmgp::rrtmgp_coefficients_file_lw:  <ul> <li>description: MISSING </li> <li>type: file  </li> </ul> </li> <li>rrtmgp::rrtmgp_cloud_optics_file_sw:  <ul> <li>description: MISSING </li> <li>type: file  </li> </ul> </li> <li>rrtmgp::rrtmgp_cloud_optics_file_lw:  <ul> <li>description: MISSING </li> <li>type: file  </li> </ul> </li> <li>rrtmgp::column_chunk_size:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::active_gases:  <ul> <li>description: MISSING </li> <li>type: array(string)  </li> </ul> </li> <li>rrtmgp::ch4vmr:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::co2vmr:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::n2ovmr:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::f11vmr:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::f12vmr:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::n2vmr:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::covmr:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::orbital_year:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::orbital_eccentricity:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::orbital_obliquity:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::orbital_mvelp:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::rad_frequency:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>rrtmgp::do_aerosol_rad:  <ul> <li>description: Flag to turn on/off considering aerosols in radiation calculations  </li> <li>type: logical  </li> </ul> </li> <li>rrtmgp::enable_column_conservation_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>rrtmgp::extra_clnclrsky_diag:  <ul> <li>description: Flag to turn on/off an extra clean-clear-sky (with neither clouds nor aerosols) radiation call  </li> <li>type: logical  </li> </ul> </li> <li>rrtmgp::extra_clnsky_diag:  <ul> <li>description: Flag to turn on/off an extra clean-sky (with no aerosols) radiation call  </li> <li>type: logical  </li> </ul> </li> <li>rrtmgp::do_subcol_sampling:  <ul> <li>description: Flag to turn on/off subcolumn sampling of optical properties; if false treat cells as either completely clear or cloudy  </li> <li>type: logical  </li> </ul> </li> <li>rrtmgp::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>rrtmgp::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>rrtmgp::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>rrtmgp::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>rrtmgp::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>rrtmgp::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#mac_aero_mic","title":"mac_aero_mic","text":"<ul> <li>mac_aero_mic::atm_procs_list:  <ul> <li>description: List of atm processes in this atm process group  </li> <li>type: array(string)  </li> </ul> </li> <li>mac_aero_mic::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> </ul> </li> <li>mac_aero_mic::Type:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>mac_aero_mic::schedule_type:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> <li>valid values: Sequential  </li> </ul> </li> <li>mac_aero_mic::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>mac_aero_mic::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>mac_aero_mic::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>mac_aero_mic::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>mac_aero_mic::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#cosp","title":"cosp","text":"<ul> <li>cosp::cosp_subcolumns:  <ul> <li>description: Number of subcolumns to use for COSP simulators; cosp_subcolumns=1 implies no subcolumn sampling  </li> <li>type: MISSING </li> </ul> </li> <li>cosp::cosp_frequency:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>cosp::cosp_frequency_units:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> <li>valid values: steps,hours  </li> </ul> </li> <li>cosp::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>cosp::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>cosp::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>cosp::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>cosp::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>cosp::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#tms","title":"tms","text":"<ul> <li>tms::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>tms::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>tms::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>tms::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>tms::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>tms::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#physics","title":"physics","text":"<ul> <li>physics::atm_procs_list:  <ul> <li>description: List of atm processes in this atm process group  </li> <li>type: array(string)  </li> </ul> </li> <li>physics::Type:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>physics::schedule_type:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> <li>valid values: Sequential  </li> </ul> </li> <li>physics::number_of_subcycles:  <ul> <li>description: how many times to subcycle this atm process  </li> <li>type: MISSING </li> <li>constraints: gt 0  </li> </ul> </li> <li>physics::enable_precondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>physics::enable_postcondition_checks:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>physics::repair_log_level:  <ul> <li>description: MISSING </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn  </li> </ul> </li> <li>physics::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>physics::compute_tendencies:  <ul> <li>description: list of computed fields for which this process will back out tendencies  </li> <li>type: array(string)  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#initial-conditions-parameters","title":"Initial Conditions Parameters","text":"<ul> <li>initial_conditions::Filename:  <ul> <li>description: MISSING </li> <li>type: file  </li> </ul> </li> <li>initial_conditions::topography_filename:  <ul> <li>description: MISSING </li> <li>type: file  </li> </ul> </li> <li>initial_conditions::phis:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::restart_casename:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::surf_evap:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::precip_liq_surf_mass:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::precip_ice_surf_mass:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::cldfrac_liq:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::sgs_buoy_flux:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::eddy_diff_mom:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::T_prev_micro_step:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::qv_prev_micro_step:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::qr:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::nr:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::qm:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::bm:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::ni_activated:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::nc_nuceat_tend:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::tke:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::sfc_alb_dir_vis:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::sfc_alb_dir_nir:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::sfc_alb_dif_vis:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::sfc_alb_dif_nir:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::surf_sens_flux:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::surf_lw_flux_up:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::surf_mom_flux:  <ul> <li>description: MISSING </li> <li>type: array(real)  </li> </ul> </li> <li>initial_conditions::qc:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::qi:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::nc:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::ni:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::o3_volume_mix_ratio:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>initial_conditions::perturbed_fields:  <ul> <li>description: IC fields (with level dimension) to apply a random perturbation to based on the parameters below.  </li> <li>type: array(string)  </li> </ul> </li> <li>initial_conditions::generate_perturbation_random_seed:  <ul> <li>description: Whether or not to generate a random seed for perturbation.  </li> <li>type: logical  </li> </ul> </li> <li>initial_conditions::perturbation_random_seed:  <ul> <li>description: Random seed used for perturbation. Will be overridded by generate_perturbation_random_seed=true.  </li> <li>type: integer  </li> </ul> </li> <li>initial_conditions::perturbation_limit:  <ul> <li>description: Defines a range [1-x, 1+x] which perturbation will be taken from.  </li> <li>type: real  </li> </ul> </li> <li>initial_conditions::perturbation_minimum_pressure:  <ul> <li>description: Minimum pressure (relative to a reference level pressure profile) for which perturbation will be applied.  </li> <li>type: real  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#atmosphere-driver-parameters","title":"Atmosphere Driver Parameters","text":"<ul> <li>driver_options::atmosphere_dag_verbosity_level:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>driver_options::atm_log_level:  <ul> <li>description: Verbosity level for the atm logger  </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn,error  </li> </ul> </li> <li>driver_options::atm_flush_level:  <ul> <li>description: Verbosity level that triggers automatic flush of the atm logger  </li> <li>type: string  </li> <li>valid values: trace,debug,info,warn,error  </li> </ul> </li> <li>driver_options::output_to_screen:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>driver_options::mass_column_conservation_error_tolerance:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>driver_options::energy_column_conservation_error_tolerance:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>driver_options::column_conservation_checks_fail_handling_type:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>driver_options::check_all_computed_fields_for_nans:  <ul> <li>description: MISSING </li> <li>type: logical  </li> </ul> </li> <li>driver_options::property_check_data_fields:  <ul> <li>description: list of additional data fields to output in property checks (only for physics grid)  </li> <li>type: array(string)  </li> </ul> </li> <li>driver_options::enable_iop:  <ul> <li>description: Enable intensive observation period. Currently the only use case is DP-EAMxx  </li> <li>type: logical  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#scorpio-parameters","title":"Scorpio Parameters","text":"<ul> <li>Scorpio::output_yaml_files:  <ul> <li>description: MISSING </li> <li>type: array(string)  </li> </ul> </li> <li>Scorpio::model_restart::filename_prefix:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> </ul>"},{"location":"EAMxx/common/eamxx_params/#homme-namelist","title":"Homme namelist","text":"<ul> <li>ctl_nl::cubed_sphere_map:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::disable_diagnostics:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::dt_remap_factor:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> <li>constraints: ge 1  </li> </ul> </li> <li>ctl_nl::dt_tracer_factor:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> <li>constraints: ge 1  </li> </ul> </li> <li>ctl_nl::hv_ref_profiles:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::hypervis_order:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::hypervis_scaling:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::hypervis_subcycle:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::hypervis_subcycle_tom:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::hypervis_subcycle_q:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::nu:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::nu_top:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::pgrad_correction:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_ftype:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> <li>valid values: 0,2  </li> </ul> </li> <li>ctl_nl::se_geometry:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_limiter_option:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_ne:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_ne_x:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_ne_y:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_lx:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_ly:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_nsplit:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_partmethod:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_topology:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::se_tstep:  <ul> <li>description: MISSING </li> <li>type: real  </li> </ul> </li> <li>ctl_nl::statefreq:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::theta_advect_form:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::theta_hydrostatic_mode:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::tstep_type:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::vert_remap_q_alg:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::transport_alg:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::vtheta_thresh:  <ul> <li>description: MISSING </li> <li>type: MISSING </li> </ul> </li> <li>ctl_nl::internal_diagnostics_level:  <ul> <li>description: MISSING </li> <li>type: integer  </li> </ul> </li> <li>ctl_nl::mesh_file:  <ul> <li>description: MISSING </li> <li>type: file  </li> </ul> </li> </ul>"},{"location":"EAMxx/common/installation/","title":"Installation","text":"<p>Follow these simple instructions to build and test EAMxx's standalone configuration for yourself. This document makes use of the following paths:</p> <ul> <li><code>${RUN_ROOT_DIR}</code>: the root directory where EAMxx is built and run</li> <li><code>${EAMXX_SRC_DIR}</code>: the directory into which you've cloned the <code>scream</code> repo</li> </ul> <p>EAMxx's configuration and build system is based on CMake. CMake has been around a while and has gained a lot of traction in recent years, especially in the HPC community. It has good reference documentation, but it can be tricky to use if you've never encountered it. Ask a EAMxx team member for help if you're stuck on something CMake-related.</p> <p>If you see a <code>CMakeLists.txt</code> files or a file with a <code>.cmake</code> suffix, that's just part of the build system. You might also see files with <code>CTest</code> as part of their name. These files are related to CTest, CMake's testing tool.</p>"},{"location":"EAMxx/common/installation/#prerequisites","title":"Prerequisites","text":"<p>First, make sure you're on one of the machines supported by EAMxx, or that you have the following software installed:</p> <ul> <li>A working MPI installation (typically MPICH or Open-MPI)</li> <li>CMake and GNU Make</li> <li>A working set of C, C++, and Fortran compilers</li> <li>A recent version of Git</li> <li>A working installation of NetCDF,   including both C and   Fortran libraries.</li> </ul>"},{"location":"EAMxx/common/installation/#setting-up-your-environment","title":"Setting Up Your Environment","text":""},{"location":"EAMxx/common/installation/#configuring-and-building-scream","title":"Configuring and Building Scream","text":""},{"location":"EAMxx/common/installation/#1-start-from-a-trustworthy-commit","title":"1. Start From a Trustworthy Commit","text":"<p>First, make sure you've cloned the EAMxx repo (including all submodules) to <code>EAMXX_SRC_DIR</code> using the following command:</p> <pre><code>git clone --recurse-submodules https://github.com/E3SM-Project/scream\n</code></pre> <p>If you have already cloned the project and forgot to type <code>--recurse-submodules</code>, you can change to <code>$EAMXX_SRC_DIR</code> and using the following command to initialize, fetch and checkout all submodules:</p> <pre><code>git submodule update --init --recursive\n</code></pre> <p>If you're running a branch that's not <code>master</code>, check out this branch with</p> <pre><code>git checkout &lt;branch&gt;\n</code></pre>"},{"location":"EAMxx/common/installation/#2-configure-your-eamxx-build","title":"2. Configure Your EAMxx Build","text":"<p>Change to your <code>$RUN_ROOT_DIR</code> directory and use CMake to configure your build.</p> <p>If you're building SCREAM on one of our supported platforms, you can tell CMake to use the appropriate machine file using the <code>-C</code> flag. Machine files are located in <code>$EAMXX_SRC_DIR/components/eamxx/cmake/machine-files</code>. Take a look and see whether your favorite machine has one.</p> <p>For example, to configure SCREAM on the Quartz machine at LLNL:</p> <pre><code>cd $RUN_ROOT_DIR\ncmake \\\n    -DCMAKE_CXX_COMPILER=$(which mpicxx) \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -C ${EAMXX_SRC_DIR}/components/eamxx/cmake/machine-files/quartz.cmake \\\n    ${EAMXX_SRC_DIR}/components/eamxx\n</code></pre> <p>If you're building on a machine that doesn't have a ready-made machine file, you can try configuring your build by manually passing options to CMake. This usually looks something like the following, which configures EAMxx to compile CPU code using Kokkos's OpenMP backend: <pre><code>cd $RUN_ROOT_DIR\ncmake \\\n    -D CMAKE_BUILD_TYPE=Debug \\\n    -D CMAKE_C_COMPILER=mpicc \\\n    -D CMAKE_CXX_COMPILER=mpicxx \\\n    -D CMAKE_Fortran_COMPILER=mpif90 \\\n    -D MPIEXEC_EXECUTABLE=`which mpiexec` \\\n    -D EKAT_MPI_NP_FLAG:STRING=-n \\\n    -D SCREAM_DYNAMICS_DYCORE=HOMME \\\n    -D SCREAM_DOUBLE_PRECISION:BOOL=ON \\\n    -D SCREAM_INPUT_ROOT:PATH=/path/to/scream-input \\\n    -D Kokkos_ENABLE_DEBUG=TRUE \\\n    -D Kokkos_ENABLE_AGGRESSIVE_VECTORIZATION=OFF \\\n    -D Kokkos_ENABLE_SERIAL=ON \\\n    -D Kokkos_ENABLE_OPENMP=ON \\\n    -D Kokkos_ENABLE_LIBDL=OFF \\\n    -D Kokkos_ENABLE_PROFILING=OFF \\\n    -D Kokkos_ENABLE_DEPRECATED_CODE=OFF \\\n    -D KOKKOS_ENABLE_ETI:BOOL=OFF \\\n    -D NetCDF_C_PATHS=/path/to/netcdf-c-dir \\\n    -D NetCDF_Fortran_PATHS=/path/to/netcdf-f90-dir \\\n    -D PnetCDF_C_PATHS=/path/to/pnetcdf-dir \\\n    -D PnetCDF_Fortran_PATHS=/path/to/pnetcdf-f90-dir \\\n    ${EAMXX_SRC_DIR}/components/eamxx\n</code></pre></p> <p>In either case, EAMxx requires MPI-aware compilers. Let's examine these options (only some of which are required on any given machine) to make sure we know what they do:</p> <ul> <li><code>CMAKE_BUILD_TYPE</code>: specifies whether you are building EAMxx in a   developer-friendly configuration (<code>Debug</code>), for a production run (<code>Release</code>)   or for performance profiling or some other specialized purpose. Typically,   you'll set this option to <code>Debug</code> or <code>Release</code>.</li> <li><code>CMAKE_{C,CXX,Fortran}_COMPILER</code>: the name of the command used to invoke an   MPI-enabled C, C++, or Fortran compiler to build EAMxx</li> <li><code>MPIEXEC_EXECUTABLE</code>: the name of the command used to run EAMxx using MPI,   typically <code>mpiexec</code> or <code>mpirun</code>, but possibly different depending on your   desired machine</li> <li><code>EKAT_MPI_NP_FLAG</code>: the flag passed to <code>MPIEXEC_EXECUTABLE</code> that you use to   specify the number of desired MPI processes. This is typically <code>-n</code> for   <code>mpiexec</code> and <code>-np</code> for <code>mpirun</code>.</li> <li><code>SCREAM_DYNAMICS_DYCORE</code>: specifies the dycore used for configuring EAMxx,   which is <code>NONE</code> if you are not configuring EAMxx to run its dycore-related   tests, or <code>HOMME</code> if you want to use HOMMExx</li> <li><code>SCREAM_DOUBLE_PRECISION</code>: indicates whether EAMxx's <code>Real</code> type is a   double-precision (<code>ON</code>) or single-precision (<code>OFF</code>) floating point type</li> <li><code>SCREAM_INPUT_ROOT</code>: specifies the location of the top-level folder that   stores input data files for EAMxx. This folder is populated with input files   which are downloaded automatically during EAMxx's build process.</li> <li>The Kokkos-related build options (most of which begin with <code>Kokkos_</code>) are   described in the Kokkos Wiki</li> <li><code>NetCDF_C_PATHS</code>: specifies one or more folders in which the NetCDF C library   and headers are installed. In the simplest configuration, the headers should   be located in <code>${NetCDF_C_PATHS}/include</code> and the library should live in   <code>${NetCDF_C_PATHS}/lib</code>.</li> <li><code>NetCDF_Fortran_PATHS</code>: specifies one or more folders in which the NetCDF   Fortran library and modules are installed. Analogous to <code>${NetCDF_C_PATHS}</code>,   <code>.mod</code> files should be in <code>${NetCDF_Fortran_PATHS}/include</code>, and the library   should be installed in <code>${NetCDF_Fortran_PATHS}/lib</code>.</li> <li><code>PnetCDF_C_PATHS</code>: specifies one or more folders in which the pNetCDF C   library and headers are installed, analogous to <code>NetCDF_C_PATHS</code>.</li> <li><code>PnetCDF_Fortran_PATHS</code>: specifies one or more folders in which the pNetCDF   Fortran library and modules are installed, analogous to   <code>NetCDF_Fortran_PATHS</code>.</li> </ul> <p>Above, we've configured <code>Debug</code> builds to make it easier to find and fix errors. For performance testing, you should configure a <code>Release</code> build and make use of other options, depending on your architecture.</p>"},{"location":"EAMxx/common/installation/#3-build-scream","title":"3. Build SCREAM","text":"<p>Now you can build SCREAM from that same directory:</p> <pre><code>make -j\n</code></pre> <p>The <code>-j</code> flag tells Make to use threads to compile in parallel. If you like, you can set the number of threads by passing it as an argument to <code>-j</code> (e.g. <code>make -j8</code>).</p>"},{"location":"EAMxx/common/installation/#running-tests","title":"Running Tests","text":"<p>You can run EAMxx's tests to make sure your build works by following the instructions here.</p>"},{"location":"EAMxx/developer/","title":"SCREAM Developer Guide","text":""},{"location":"EAMxx/developer/ci_nightly/","title":"Continuous Integration and Nightly Testing","text":"<ul> <li>Autotester quick overview</li> <li>Nightly overview, CDash</li> </ul>"},{"location":"EAMxx/developer/cime_testing/","title":"Full Model Testing","text":"<p>Quickly review CIME test infrastructure and how EAMxx uses it</p> <ul> <li>test types, specifiers (<code>_LnX</code>,<code>_D</code>,<code>_PMxN</code>,..), grids, compsets, test-mods</li> <li>available grids/compsets for EAMxx, and where to find them</li> <li>how to add atmchange in <code>shell_commands</code> test mods</li> </ul>"},{"location":"EAMxx/developer/field/","title":"Fields","text":""},{"location":"EAMxx/developer/field/#field","title":"Field","text":"<p>In EAMxx, a <code>Field</code> is a data structure holding two things: pointers to the data and pointers to metadata. Both the data and metadata are stored in <code>std::shared_ptr</code> instances, to ensure consistency across all copies of the field. This allows for fast shallow copy semantic for this class.</p> <p>The data is stored on both CPU and device memory (these may be the same, depending on the Kokkos backend). In EAMxx, we always assume and guarantee that the device data is up to date. That implies that the data be explicitly synced to host before using it on host, and explicitly synced to device after host manipulation, in order to ensure correctness. In order to access the data, users must use the <code>get_view</code> method, which takes two template arguments: the data type, and an enum specifying whether CPU or device data is needed. The data type is used to reinterpret the generic pointer stored inside to a view of the correct scalar type and layout. It is a possibly const-qualified type, and if the field was marked as \"read-only\", the method ensures that the provided data type is const. A read-only field can be created via the <code>getConst</code> method, which returns an identical copy of the field, but marked as read-only. The enum specifying host or device data is optional, with device being the default.</p> <p>The metadata is a collection of information on the field, such as name, layout, units, allocation size, and more. Part of the metadata is immutable after creation (e.g., name, units, or layout), while some metadata can be partially or completely modified. The metadata is contained in the <code>FieldHeader</code> data structure, which contains four parts:</p> <ul> <li><code>FieldIdentifier</code>: stores the field's name, layout, units, data type, and name of the grid where it's defined.   These information are condensed in a single string, that can be used to uniquely identify a field,   allowing to distinguish between different version of the same field. The layout is stored in the <code>FieldLayout</code>   data structure, which includes:<ul> <li>the field tags: stored as a <code>std::vector&lt;FieldTag&gt;</code>, they give context to the field's extents.</li> <li>the field dims: stored both as a <code>std::vector&lt;int&gt;</code>, as well as a 1d <code>Kokkos::View</code>.</li> </ul> </li> <li><code>FieldTracking</code>: stores information on the usage of the field, as well as its possible connections to other   fields. In particular, the tracked items are:<ul> <li>the field time stamp: the time stamp when the field was last updated.</li> <li>the field accumulation start time: used for fields that are accumulated over several time steps   (or time step subcycles). For instance, it allows to reconstruct fluxes from raw accumulations.</li> <li>the providers/customers: lists of atmosphere processes (see below) that respectively require/compute   the field in their calculations.</li> <li>the field groups: a list of field groups that this field belongs too. Field groups are used to access   a group of fields without explicit prior knowledge about the number and/or names of the fields.</li> </ul> </li> <li><code>FieldAllocProp</code>: stores information about the allocation. While the field is not yet allocated, users can   request special allocations for the field, for instance to accommodate packing (for SIMD), which may   require padding. Upon allocation, this information is then used by the Field structure to extract the   actual data, wrapped in a properly shaped <code>Kokkos::View</code>. The alloc props are also responsible of tracking   additional information in case the field is a \"slice\" of a higher-dimensional one, a fact that can affect   how the data is accessed.</li> <li>Extra data: stored as a <code>std::map&lt;std::string,ekat::any&gt;</code>, allows to catch any metadata that does not fit   in the above structures. This is a last resort structure, intended to accommodate the most peculiar   corner cases, and should be used sparingly.</li> </ul>"},{"location":"EAMxx/developer/grid/","title":"Grids and Remappers","text":""},{"location":"EAMxx/developer/grid/#grids-and-remappers","title":"Grids and Remappers","text":"<p>In EAMxx, the <code>AbstractGrid</code> is an interface used to access information regarding the horizontal and vertical discretization. The most important information that the grid stores is:</p> <ul> <li>the number of local/global DOFs: these are the degrees of freedom of the horizontal grid only. Here,   local/global refers to the MPI partitioning.</li> <li>the DOFs global IDs (GIDs): a list of GIDs of the DOFs on the current MPI rank, stored as a Field</li> <li>the local IDs (LIDs) to index list: this list maps the LID of a DOF (that is, the position of the DOF   in the GID list) to a \"native\" indexing system for that DOF. For instance, a <code>PointGrid</code> (a class derived from   <code>AbstractGrid</code>) is a simple collection of points, so the \"native\" indexing system coincides with the LIDs.   However, for a <code>SEGrid</code> (a derived class, for spectral element grids), the \"native\" indexing is a triplet   <code>(ielem,igp,jgp)</code>, specifying the element index, and the two indices of the Gauss point within the element.</li> <li>geometry data: stored as a <code>std::map&lt;std::string,Field&gt;</code>, this represent any data that is intrinsically   linked to the grid (either along the horizontal or vertical direction), such as lat/lon coordinates,   vertical coordinates, area associated with the DOF.</li> </ul> <p>Grids can also be used to retrieve the layout of a 2d/3d scalar/vector field, which allows certain downstream classes to perform certain operations without assuming anything on the horizontal grid.</p> <p>In general, grid objects are passed around the different parts of EAMxx as const objects (read-only). The internal data can only be modified during construction, which usually is handled by a <code>GridsManager</code> object.</p>"},{"location":"EAMxx/developer/io/","title":"Input-Output","text":"<p>In EAMxx, I/O is handled through the SCORPIO library, currently a submodule of E3SM. The <code>scream_io</code> library within eamxx allows to interface the EAMxx infrastructure classes with the SCORPIO library.</p>"},{"location":"EAMxx/developer/kokkos_ekat/","title":"Building Blocks","text":"<p>Here we can discuss EKAT, Kokkos, and all of the highly-technical non-scientific stuff that makes our heads hurt.</p>"},{"location":"EAMxx/developer/kokkos_ekat/#kokkos-views","title":"Kokkos Views","text":""},{"location":"EAMxx/developer/kokkos_ekat/#vectorization-packs","title":"Vectorization: Packs","text":""},{"location":"EAMxx/developer/kokkos_ekat/#fields-and-the-field-manager","title":"Fields and the Field Manager","text":""},{"location":"EAMxx/developer/kokkos_ekat/#preconditions-postconditions-and-invariants","title":"Preconditions, Postconditions, and Invariants","text":""},{"location":"EAMxx/developer/managers/","title":"Managers","text":""},{"location":"EAMxx/developer/managers/#fieldmanager-and-gridsmanager","title":"FieldManager and GridsManager","text":""},{"location":"EAMxx/developer/processes/","title":"Atmospheric Processes","text":"<p>In EAMxx, the <code>AtmosphereProcess</code> (AP) is a class representing a portion of the atmosphere timestep algorithm. In simple terms, an AP is an object that given certain input fields performs some calculations to compute some output fields.</p> <p>TODO: describe init sequcene (e.g., the process of requesting fields), base class main       interfaces/capabilities (e.g., subcycling), class expectations (e.g., must update fields on physics grid)</p> <p>Here is a list of currently implemented atmosphere processes. TODO: add links to papers/github-repos, and a SMALL description * p3: Microphysics, blah blah * SHOC: Macrophysics/Turbulence, blah * rrtmgp: Radiation, blah * spa: prescribed aerosols, blah blah * surface coupling: blah * mam: prognostic aerosols, blah blah * nudging: This process is responsible for nudging the model simulation given a set of files with a target nudged state.</p>"},{"location":"EAMxx/developer/source_tree/","title":"EAMxx's Source Tree","text":"<p>All EAMxx-specific code can be found in <code>components/eamxx</code> within the EAMxx repo. Here's how things are organized:</p> <ul> <li><code>cime_config</code>: Tools and XML files for integrating EAMxx with E3SM via the   CIME framework.</li> <li><code>cmake</code>: CMake functions and macros used by the configuration/build system.</li> <li><code>data</code>: Data files used by our tests.</li> <li><code>docs</code>: Documentation for the EAMxx project, including design documents,   instructions for building and testing EAMxx, and this document.</li> <li><code>scripts</code>: Miscellaneous scripts that implement workflows for running tests   and analyzing performance.</li> <li><code>src</code>: All C++ source code (and any bridges to Fortran) for EAMxx are stored   here. We describe the contents of this directory in greater detail below.</li> <li><code>tests</code>: Implements standalone, end-to-end tests for various EAMxx   components (RRTMG, HOMME, P3, SHOC, etc).</li> </ul> <p>In addition, you'll notice the following files in <code>components/eamxx</code>:</p> <ul> <li><code>CMakeLists.txt</code>: The CMake file that defines EAMxx's configuration/build   system.</li> <li><code>CTestConfig.cmake</code>: This CTest file contains parameters that determine how   our test results are reported to the E3SM CDash Site.</li> <li><code>README.md</code>: EAMxx's top-level README file, which describes the project and   its purpose.</li> <li><code>mkdocs.yml</code>: The configuration file for mkdocs,   the tool we currently use to build and publish our documentation.</li> </ul>"},{"location":"EAMxx/developer/source_tree/#the-src-directory","title":"The <code>src</code> Directory","text":"<p>Herein l\u0456es the source code for EAMxx. Broadly, here's where things are:</p> <ul> <li><code>control</code>: Contains the atmosphere driver and basic tests for it.</li> <li><code>dynamics</code>: Here's where HOMME lives within EAMxx, along with code for   interfacing with it using EAMxx's data structures.</li> <li><code>mct_coupling</code>: Glue code for embedding EAMxx within E3SM as an atmosphere   component using the MCT coupler.</li> <li><code>physics</code>: Source code for physics-related atmospheric processes, including</li> <li><code>p3</code>: The C++/Kokkos implementation of P3 microphysics within EAMxx.</li> <li><code>shoc</code>: The C++/Kokkos implementation of SHOC macrophysics within EAMxx.</li> <li><code>rrtmgp</code>: A stub for the radiation processes as represented in EAMxx.</li> <li><code>share</code>: Utilities and data structures common to these processes.</li> <li><code>share</code>: Utilities used by various components within EAMxx. Of note:</li> <li><code>io</code>: EAMxx's interface to the SCORPIO     library.</li> <li><code>diagnostics</code>: A collection of simple classes used to compute diagnostic   quantities.</li> </ul> <p>Each of these directories contains a <code>CMakeLists.txt</code> file for defining how things are build, and a <code>tests/</code> subdirectory that houses relevant unit and verification tests.</p> <p>You'll also see some other files in the <code>src/</code> directory itself, such as</p> <ul> <li><code>scream_config.h.in</code>: A template for generating a C++ header file with   EAMxx configuration information.</li> </ul>"},{"location":"EAMxx/developer/standalone_testing/","title":"Standalone EAMxx Testing","text":"<p>In this section we describe our testing methodology for standalone EAMxx configurations. We use several types of tests</p> <ul> <li>Unit tests are individual test programs that demonstrate that a small set   of code performs a single function or a set of related functions. We use   a C++ unit testing framework called Catch2   to implement unit tests.</li> <li>Property (verification) tests are test programs that configure code that   demonstrates that a part of EAMxx (for example, an atmospheric physics   parameterization or the dynamical core) is able to produce an answer that   satisfies some physical constraint or matches a known solution under specific   circumstances.</li> <li>Fortran-C++ \"bit-for-bit\" (BFB) tests are test programs, often implemented   as unit tests, that demonstrate that a set of C++ code ported from Fortran   produces bit-for-bit identical results to its Fortran counterpart, provided   certain compiler options are enabled (such as \"strict\" floating-point   arithmetic).</li> <li>Test Suites are named collections of tests that can be run on demand using   the ctest command.</li> </ul> <p>We also support a <code>test-all-scream</code> configuration that runs all of the standalone tests for an EAMxx configuration.</p>"},{"location":"EAMxx/developer/standalone_testing/#running-eamxxs-tests-with-ctest","title":"Running EAMxx's Tests with CTest","text":"<p>Before running the tests, generate a baseline file:</p> <pre><code>cd $RUN_ROOT_DIR\nmake baseline\n</code></pre> <p>The tests will run, automatically using the baseline file, which is located in the CMake-configurable path <code>${SCREAM_BASELINES_DIR}</code>. By default, this path is set to an invalid string. If baselines tests are enabled, we check that a valid path has been provided.</p> <p>To run all of SCREAM's tests, make sure you're in <code>$RUN_ROOT_DIR</code> and type</p> <pre><code>ctest -VV\n</code></pre> <p>This runs everything and reports results in an extra-verbose (<code>-VV</code>) manner.</p> <p>You can also run subsets of the SCREAM tests. For example, to run only the P3 regression tests (again, from the <code>$RUN_ROOT_DIR</code> directory), use</p> <pre><code>ctest -R p3_regression\n</code></pre>"},{"location":"EAMxx/developer/standalone_testing/#grouping-tests-with-labels","title":"Grouping Tests with Labels","text":"<p>We can create groupings of tests by using labels. For example, we have a <code>driver</code> label that runs tests for SCREAM's standalone driver. You can see a list of available labels by typing</p> <pre><code>ctest --print-labels\n</code></pre> <p>To see which tests are associated with a given label (e.g. <code>driver</code>), use</p> <pre><code>ctest -L driver -N\n</code></pre>"},{"location":"EAMxx/developer/standalone_testing/#eamxx-test-suites","title":"EAMxx Test Suites","text":""},{"location":"EAMxx/developer/standalone_testing/#the-p3_regression-suite","title":"The <code>p3_regression</code> Suite","text":"<p><code>p3_regression</code> uses a baseline file to compare any new or altered implementations with our P3 Fortran reference implementation. If you're working on the C++/Kokkos implementation, you can invoke any new tests to the function <code>Baseline::run_and_cmp</code> in <code>${SCREAM_SRC_DIR}/components/eamxx/p3/tests/p3_run_and_cmp.cpp</code>.</p> <p>If the reference Fortran implementation changes enough that a new baseline file is required, make sure to let other SCREAM team members know, in order to minimize disruptions.</p>"},{"location":"EAMxx/developer/style_guide/","title":"SCREAM C++ Style Guide","text":"<p>Here's our style guide. Let the holy wars begin!</p>"},{"location":"EAMxx/developer/style_guide/#types","title":"Types","text":""},{"location":"EAMxx/developer/style_guide/#functions-and-methods","title":"Functions and Methods","text":""},{"location":"EAMxx/developer/style_guide/#variables","title":"Variables","text":""},{"location":"EAMxx/technical/","title":"SCREAM Technical Guide","text":"<p>SCREAM contributors and maintainers will add detailed technical information about SCREAM here.</p>"},{"location":"EAMxx/technical/aerocom_cldtop/","title":"The AeroCOM algorithm","text":"<p>The goal of the AeroCOM algorithm is to calculate properties at cloud top based on the AeroCOM recommendation. There are two main parts of the algorithm: probabilistically determining \"cloud top\" and then \"calculating properties\" at said cloud top.</p> <p>We treat model columns independently, so we loop over all columns in parallel. We then loop over all layers in serial (due to needing an accumulative product), starting at 2 (second highest) layer because the highest is assumed to have no clouds. Let's take a photonic approach from above the model top. Let's say that \\(p_{k}\\) is the probability of a photon passing through the layer \\(k\\). We follow the maximum-random overlap assumption. In all cases, we assume the cloudiness (or cloudy fraction) is completely opaque.</p> <p>We assume the highest layer has no clouds, thus the \\(p_{k} = 1\\) for the highest layer. Note that \\(p_{k}\\) is initialized as 1 for all layers. We also clip the cloudy fraction \\(C_{i,k}\\) to ensure that \\(C_{i,k} \\in [0+\\epsilon, 1-\\epsilon]\\), where \\(\\epsilon = 0.001\\). Starting at the second highest layer, \\(k+1\\), we check if some \"cloudy\" conditions are met. These conditions are now arbitrarily defined by a cloudiness threshold of \\(\\epsilon\\) (i.e., \\(C_{i,k}&gt;\\epsilon\\)) and a non-zero threshold on the total (both liquid and ice) droplet number concentration (i.e., \\(cQ_{i,k} + iQ_{i,k} &gt; 0\\)). If the conditions are met, we estimate the cloud-top cloud fraction using an accumulative product following the maximum-random overlap assumption.</p> \\[c_{i} = 1 - \\prod_{k=2}^{K} p_{k} = 1 - \\prod_{k=2}^{K} \\frac{1 - \\max(C_{i,k}, C_{i,k-1})}{1-C_{i,k-1}}\\] <p>In order to estimate cloud-top properties, we weight by the probability of \"remaining cloudiness\" or \\(p_{k-1} - p_{k}\\).</p> Type Equation cloud property \\(x_{i} = \\sum_{k=2}^{K} X_{i,k} \\Phi_{i,k} (p_{k-1} - p_{k})\\) cloud content \\(x_{i} = \\sum_{k=2}^{K} \\Phi_{i,k} (p_{k-1} - p_{k})\\) other property \\(x_{i} = \\sum_{k=2}^{K} X_{i,k} (p_{k-1} - p_{k})\\) <p>In the above, \\(\\Phi_{i,k}\\) is the thermodynamic phase defined by the cloud droplet number concentration ratios.</p> \\[i\\Phi_{i,k} = \\frac{iQ_{i,k}}{iQ_{i,k} + cQ_{i,k}}\\] \\[c\\Phi_{i,k} = \\frac{cQ_{i,k}}{iQ_{i,k} + cQ_{i,k}}\\] <p>The thermodynamic phase is used only for cloud properties (e.g., cloud-top cloud droplet number concentration) or cloud content (e.g., cloud liquid content). Further, \\(X_{i,k}\\) is the three-dimensional cloud property of interest which is needed if we are converting a property from three-dimensional (\\(X\\)) to its two-dimensional counterpart (\\(x\\)). \"Other\" properties here include temperature and pressure which are not dependent on the thermodynamic phase.</p> <p>A helpful references: R\u00e4is\u00e4nen, P., Barker, H. W., Khairoutdinov, M. F., Li, J., &amp; Randall, D. A. (2004). Stochastic generation of subgrid\u2010scale cloudy columns for large\u2010scale models. Quarterly Journal of the Royal Meteorological Society: A journal of the atmospheric sciences, applied meteorology and physical oceanography, 130(601), 2047-2067.</p>"},{"location":"EAMxx/technical/clean_clear_sky/","title":"Clean- and clean-clear-sky diagnostics","text":"<p>In order to decompose the aerosol effective radiative forcing, additional diagnostic radiation calls are needed. These extra diagnostics are optionally added to the main radiation call. The extra diagnostics are:</p> <ul> <li>Clean-clear-sky fluxes: the fluxes that would be present if there were neither aerosols nor clouds, and are calculated by adding an additional radiation call at the very beginning of the logic before the optics class is endowed with aerosol and cloud properties.</li> <li>Clean-sky fluxes: the fluxes that would be present if there were no aerosols, and are calculated by adding an additional radiation call after substantiating an additional optics class, but not endowing it with aerosol properties.</li> </ul> <p>It was necessary to add an additional optics class because the original optics class is endowed with aerosols before clouds (in order to calculate the clear-sky fluxes). The extra calls are controlled by runtime flags <code>extra_clnclrsky_diag</code> and <code>extra_clnsky_diag</code> (they take either <code>true</code> or <code>false</code> as their values).</p>"},{"location":"EAMxx/user/","title":"SCREAM User Guide","text":"<p>For the time being, see our public confluence EAMxx user guide</p>"},{"location":"EAMxx/user/coarse_nudging/","title":"Nudging from coarse data","text":"<p>Because EAMxx is designed to support ultra-high resolutions (in fact, that was the initial reason for its inception), it is not feasible to produce nudging data at the same resolution. Instead, in EAMxx, it is possible to nudge from coarse data. This is done by remapping the coarse data provided by the user to the runtime physics grid of EAMxx. In order to enable nudging from coarse data, the user must provide nudging data at the coarse resolution desired and an appropriate     ncremap-compatible mapping file.</p>"},{"location":"EAMxx/user/coarse_nudging/#example-setup","title":"Example setup","text":"<p>A user can produce coarse nudging data from running EAMxx or EAM at a ne30pg2 or any other applicable resolution. Additionally, several users in the E3SM projects have produced nudging data at the ne30pg2 resolution from the MERRA2 and ERA5 datasets. A limitation for now is that the nudging data must be provided explicitly, either as one file or as a list of files. This can be problematic for long list of files, but we are working on a solution to this problem.</p> <p>Let's say that the nudging data is provided as one file in the following path: <code>/path/to/nudging_data_ne4pg2_L72.nc</code>. Then, a mapping file is provided as <code>/another/path/to/mapping_file_ne4pg2_to_ne120pg2.nc</code>. Then if the physics grid is ne120pg2, the user must enable the nudging process, specify the nudging files, and provide the specifies the nudging data and a remap file. In other words, the following options are needed:</p> <pre><code>./atmchange atm_procs_list=(sc_import,nudging,homme,physics,sc_export)\n./atmchange nudging_fields=U,V\n./atmchange nudging_filenames_patterns=/path/to/nudging_data_ne4pg2_L72.nc\n./atmchange nudging_refine_remap_mapfile=/another/path/to/mapping_file_ne4pg2_to_ne120pg2.nc\n</code></pre>"},{"location":"EAMxx/user/model_input/","title":"Model input","text":"<p>TODO: explain how defaults XML, atmchange/atmquery, buildml, and input.yaml work.</p> <p>Here is a list of the currently configurable runtime parameters for EAMxx.</p>"},{"location":"EAMxx/user/model_output/","title":"Model output","text":"<p>EAMxx allows the user to configure the desired model output via YAML files, with each YAML file associated to a different output file.</p>"},{"location":"EAMxx/user/model_output/#basic-output-yaml-file-syntax","title":"Basic output YAML file syntax","text":"<p>The following is an example of a simple output request.</p> <pre><code>%YAML 1.1\n---\nfilename_prefix: my_output\nAveraging Type: Average\nMax Snapshots Per File: 10\nFields:\n  Physics:\n    Field Names:\n      - T_mid\n      - qv\n  Dynamics:\n    Field Names:\n      - dp3d_dyn\n      - omega_dyn\noutput_control:\n  Frequency: 6\n  frequency_units: nhours\n</code></pre> <p>Notice that lists can be equivalently specified in YAML as <code>Field Names: [f1, f2, f3]</code>. The user can specify fields to be outputted from any of the grids used in the simulation. In the example above, we requested fields from both the Physics and Dynamics grid. The other parameters are</p> <ul> <li> <p><code>Averaging Type</code>: how the fields are integrated in time before being saved. Valid   options are</p> <ul> <li>Instant: no integration, each time frame saved corresponds to instantaneous values   of the fields</li> <li>Average/Max/Min: the fields undergo the corresponding operation over the time   interval specified in the <code>output_control</code> section. In the case above, each snapshot   saved to file corresponds to an average of the output fields over 6h windows.</li> </ul> </li> <li> <p><code>filename_prefix</code>: the prefix of the output file, which will be created in the run   directory. The full filename will be <code>$prefix.$avgtype.$frequnits_x$freq.$timestamp.nc</code>,   where $timestamp corresponds to the first snapshot saved in the file for Instant output,   or the beginning of the first averaging window for the other averaging types</p> </li> <li><code>Max Snapshots Per File</code>: specifies how many time snapshots can be put in a file. Once   this number is reached, EAMxx will close the file and open a new one.</li> <li><code>Frequency</code>: how many units of time are between two consecutive writes to file. For   Instant output the fields are \"sampled\" at this frequency, while for other averaging   types the fields are \"integrated\" in time over this window</li> <li><code>frequency_units</code>: units of the output frequency. Valid options are <code>nsteps</code> (the   number of atmosphere time steps), <code>nsecs</code>, <code>nmins</code>, <code>nhours</code>, <code>ndays</code>, <code>nmonths</code>,   <code>nyears</code>.</li> </ul>"},{"location":"EAMxx/user/model_output/#diagnostic-output","title":"Diagnostic output","text":"<p>In addition to the fields computed by EAMxx as part of the timestep, the user can request to output derived quantities, which will be computed on the fly by the I/O interface of EAMxx. There are two types of diagnostic outputs:</p> <ul> <li> <p>quantities computed as a function of EAMxx fields. These are simply physical quantities   that EAMxx does not keep in persistent storage. As of August 2023, the available   derived quantities are (case sensitive):</p> <ul> <li><code>PotentialTemperature</code></li> <li><code>AtmosphereDensity</code></li> <li><code>Exner</code></li> <li><code>VirtualTemperature</code></li> <li><code>z_int</code></li> <li><code>z_mid</code></li> <li><code>geopotential_int</code></li> <li><code>geopotential_mid</code></li> <li><code>dz</code></li> <li><code>DryStaticEnergy</code></li> <li><code>SeaLevelPressure</code></li> <li><code>LiqWaterPath</code></li> <li><code>IceWaterPath</code></li> <li><code>VapWaterPath</code></li> <li><code>RainWaterPath</code></li> <li><code>RimeWaterPath</code></li> <li><code>ShortwaveCloudForcing</code></li> <li><code>LongwaveCloudForcing</code></li> <li><code>RelativeHumidity</code></li> <li><code>ZonalVapFlux</code></li> <li><code>MeridionalVapFlux</code></li> <li><code>precip_liq_surf_mass_flux</code></li> <li><code>precip_ice_surf_mass_flux</code></li> <li><code>precip_total_surf_mass_flux</code></li> <li><code>surface_upward_latent_heat_flux</code></li> </ul> </li> <li> <p>lower-dimensional slices of a field. These are hyperslices of an existing field or of   another diagnostic output. As of August 2023, given a field X, the available options   are:</p> <ul> <li><code>X_at_lev_N</code>: slice the field <code>X</code> at the N-th vertical level index. Recall that   in EAMxx N=0 corresponds to the model top.</li> <li><code>X_at_model_bot</code>, <code>X_at_model_top</code>: special case for top and bottom of the model.</li> <li><code>X_at_Ymb</code>, <code>X_at_YPa</code>, <code>X_at_YhPa</code>: interpolates the field <code>X</code> at a vertical position   specified by the give pressure <code>Y</code>. Available units are <code>mb</code> (millibar), <code>Pa</code>, and <code>hPa</code>.</li> <li><code>X_at_Ym</code>: interpolates the field <code>X</code> at a vertical height of <code>Y</code> meters.</li> </ul> </li> </ul>"},{"location":"EAMxx/user/model_output/#remapped-output","title":"Remapped output","text":"<p>The following options can be used to to save fields on a different grid from the one they are computed on.</p> <ul> <li><code>horiz_remap_file</code>: a path to a map file (as produced by <code>ncremap</code>) between the grid   where the fields are defined and a coarser grid. EAMxx will use this to remap fields   on the fly, allowing to reduce the size of the output file. Note: with this feature,   the user can only specify fields from a single grid.</li> <li><code>vertical_remap_file</code>: similar to the previous option, this map file is used to   refine/coarsen fields in the vertical direction.</li> <li><code>IOGrid</code>: this parameter can be specified inside one of the grids sections, and will   denote the grid (which must exist in the simulation) where the fields must be remapped   before being saved to file. This feature is really only used to save fields on the   dynamics grid without saving twice the DOFs at the interface of two spectral elements.   In fact, native output from the Dynamics grid would produce <code>6*num_elems*ngp*ngp</code>,   where <code>ngp</code> is the number of Gauss points along each axis in the 2d spectral element.   Note: this feature cannot be used along with the horizontal/vertical remapper.</li> </ul>"},{"location":"EAMxx/user/model_output/#add-output-stream-to-a-cime-case","title":"Add output stream to a CIME case","text":"<p>In order to tell EAMxx that a new output stream is needed, one must add the name of the yaml file to be used to the list of yaml files that EAMxx will process. From the case folder, after <code>case.setup</code> has run, one can do</p> <pre><code>./atmchange output_yaml_files=/path/to/my/yaml/file\n</code></pre> <p>to specify a single yaml file, or</p> <pre><code>./atmchange output_yaml_files+=/path/to/my/yaml/file\n</code></pre> <p>to append to the list of yaml files.</p>"},{"location":"EAMxx/user/model_output/#important-notes","title":"Important notes","text":"<ul> <li>The user should not specify a path to a file in <code>$RUNDIR/data</code>. EAMxx will put a copy of the specified yaml files in that directory, pruning any existing copy of that file. This happens every time that <code>buildnml</code> runs; in particular, it happens during <code>case.submit</code>.</li> <li>As a consequence of the above, the user should not modify the generated yaml files   that are in <code>$RUNDIR/data</code>, since any modification will be lost on the next run   of <code>buildnml</code>. To modify output parmeters, the user should modify the yaml file   that was specified with the <code>atmchange</code> command.</li> <li>EAMxx will parse the yaml file and expand any string of the form $VAR, by looking   for the value of the variable VAR in the CIME case. If VAR is not a valid CIME   variable, an error will be raised.</li> </ul>"},{"location":"ELM/","title":"The E3SM Land Model (ELM)","text":"<p>Some introductory text here</p> <ul> <li>The ELM User's Guide explains how to control ELM when its running within E3SM and how to run in Coupler-bypass mode</li> <li>The ELM Developer's Guide explains ELM data structures and how to develop new code.</li> <li>The ELM Techincal Guide explains the science behind ELM's code</li> </ul>"},{"location":"ELM/dev-guide/","title":"Developers's Guide","text":"<p>This guide contains information for developing ELM and MOSART.</p>"},{"location":"ELM/dev-guide/#_1","title":"Developers's Guide","text":"<ul> <li>Testing development branches: Generating baselines and comparing new development against baselines</li> </ul>"},{"location":"ELM/dev-guide/testing/","title":"Testing","text":"<p>When a developer is ready to issue a PR to integrate their new developments into E3SM's <code>master</code> branch, they need to test their code development to ensure the new development does not introduce unexpected bugs. A land developer needs to atleast run the <code>e3sm_land_developer</code> test suite that involves following two steps: </p> <ul> <li>Step-1: Generate the baselines using the hash on <code>master</code> that was the starting point of the    development branch, and</li> <li>Step-2: Switch to the development branch and re-run the test suite to compare against    the baselines generated in Step-1.</li> </ul> <p>For the purpose of these document, let's assume the developer branch is <code>bishtgautam/lnd/emi-example</code>.</p>"},{"location":"ELM/dev-guide/testing/#step-1-generate-baselines","title":"Step-1: Generate Baselines","text":"<p>Find the starting hash on <code>master</code> by switching to the developer branch and looking at the Git graph.</p> <pre><code>cd &lt;e3sm-dir&gt;\n\n# Switch to your branch\ngit checkout bishtgautam/lnd/emi-example\n\n# Let's look at the graph\ngit log --oneline --decorate --graph\n* 9a2cd8459 (HEAD -&gt; bishtgautam/lnd/emi-example, origin/bishtgautam/lnd/emi-example) Updates the Stub EM code\n* d11fb8c52 Adds a readme and makefile for EMI Demo code\n* 15a0e4b8d Minor update to the EMI demo code\n* 63e2f6dcd Minor fix to ELM configure script\n* 551fc79cc Updates ELM stub and demo code to use CNCarbonStateType\n* 8c9d41f87 Adds code to exchange CNCarbonStateType\n* 0000ded51 Minor fix\n* 2baa4ebec Adds fixes to cmake\n* f77ae2cea Rename few cmake files\n* b48b66dd6 Adds a demo for a Stub EM\n* fa94aea0d Fixes length of variable to store name of EMI data\n* cca0e0be1 Adds capability to print all EMI Data in a list\n* beb1fe9ee Adds .gitignore files for EMI\n* 301acfe7a Renames ExternalModelInterfaceDataMod.F90\n* f0eb5b40b Renames ExternalModelInterfaceDataDimensionMod.F90\n* 076100882 Restructures ELM's EMI directory\n*   cfb7fc2b2 Merge branch 'qzhu-lbl/lnd/ch4_inundation_bugfix' (PR #2814)\n|\\\n| * ec99b1cb4 (origin/qzhu-lbl/lnd/ch4_inundation_bugfix)  - fix ch4 inundatation parameter read in bug\n* |   c59c98116 Merge branch 'darincomeau/mpaso/enable_eddystats' (PR #2821)\n|\\ \\\n| * | c21bb46a4 Turn on eddy stats for oEC60to30v3 and oEC60to30v3wLI ocn grids by default\n* | |   a2dd2fce5 Merge pull request #2811 from E3SM-Project/jayeshkrishna/pio2_cime_changes\n</code></pre> <p>The above Git graph tells us that <code>bishtgautam/lnd/emi-example</code> started with the <code>cfb7fc2b2</code> hash on the <code>master</code>. So, we will generate the baselines using <code>cfb7fc2b2</code>. Checkout <code>cfb7fc2b2</code> and update the submodels via:</p> <pre><code>git checkout cfb7fc2b2\nNote: checking out 'cfb7fc2b2'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b &lt;new-branch-name&gt;\n\nHEAD is now at cfb7fc2b2... Merge branch 'qzhu-lbl/lnd/ch4_inundation_bugfix' (PR #2814)\n\ngit submodule update --init\n</code></pre> <p>Now we will use <code>cime/scripts/create_test</code> to generate baseline for the <code>e3sm_land_developer</code> test suite.</p> <pre><code>cd cime/scripts\n</code></pre> <p>A few things that you need to decide at this stage include the directory location where the baselines will be saved, the name and ID for the baselines, the project allocation that you will use for running the simulation, if you would like to receive email notifications about tests, etc.</p> <pre><code># Define the directory to hold the baseline \nexport MY_BASELINE_DIR=/global/cscratch1/sd/gbisht/e3sm_baselines\n\n# Do you want to use a name for the baseline? \n# One choice could be the git hash that is being used to generate the baselines.\nexport BASELINE_NAME=cfb7fc2b2\n\n# Let's set TEST_ID to be same as BASELINE_NAME\nexport TEST_ID=${BASELINE_NAME}\n\n# If you are a member of E3SM, you could use 'e3sm' project allocation\nexport PROJECT=e3sm\n\n# Set your email\nexport MAIL_USER=&lt;your-mail@something&gt;\n</code></pre> <p>Use <code>./create_test --help</code> to get a complete list of arguments. Below are some additional useful arguments for <code>./create_test</code>:</p> <pre><code># Other arguments\n# -v         : Verbose option\n# -g         : Generate the baseline\n# -q         : If you want to use a particular job queue (e.g. 'debug' queue on NERSC)\n# --walltime : Specify the wall time for jobs (e.g. 30 min is max allowable for 'debug' queue on NERSC)\n# --mail-user: If you want to receive emails about your jobs\n# --mail-type: When to receive emails. Options are: never, all, begin, end, fail.\n# -j         : Number of parallel jobs\n</code></pre> <p>Now run the <code>e3sm_land_developer</code></p> <pre><code>./create_test e3sm_land_developer  \\\n--baseline-root ${MY_BASELINE_DIR} \\\n-b ${BASELINE_NAME}                \\\n-t ${TEST_ID}                      \\\n-q regular                         \\\n-p ${PROJECT}                      \\\n--walltime 00:30:00                \\\n--mail-user $MAIL_USER             \\\n--mail-type all                    \\\n-g                                 \\\n-v                                 \\\n-j 4\n</code></pre> <p>The cases would be named <code>*.G.*</code> to denote one is generating the baselines. It will take a while to compile all the cases and submit the code. It can take a long time (&gt;30mins) for the test suite to run. To avoid interrupting the test suite in the middle, one can run the test suite within a <code>screen</code> command. After the cases have been successfully compiled and submitted, you can check that  status of test by running the <code>cs.status.${TEST_ID}</code> file that was created in the scratch directory.</p>"},{"location":"ELM/dev-guide/testing/#step-2-compare-against-previously-generated-baselines","title":"Step-2: Compare against previously generated baselines","text":"<p>Now, switch to the development branch and be sure to update submodules.</p> <pre><code>cd &lt;e3sm-dir&gt;\ngit checkout bishtgautam/lnd/emi-example\nPrevious HEAD position was cfb7fc2b2... Merge branch 'qzhu-lbl/lnd/ch4_inundation_bugfix' (PR #2814)\nSwitched to branch 'bishtgautam/lnd/emi-example'\nYour branch is up-to-date with 'origin/bishtgautam/lnd/emi-example'.\n\n# Checkout the appropriate submodules\ngit submodule update --init\n</code></pre> <p>Again initialize few settings.</p> <pre><code>cd cime/scripts\n\n# Let's use the settings as the last time\nexport MY_BASELINE_DIR=/global/cscratch1/sd/gbisht/e3sm_baselines\n\n# IMPORTANT: One needs to use the same BASELINE_NAME as in Step-1 because one wants\n#            to compare against the baselines previously generated in Step-1.\nexport BASELINE_NAME=cfb7fc2b2\n\n# You can use the hash at the tip of your branch as the ID\nexport TEST_ID=9a2cd8459\n</code></pre> <p>Run the test suite and compare (via <code>-c</code>) against previously generated baselines.</p> <pre><code>./create_test e3sm_land_developer  \\\n--baseline-root ${MY_BASELINE_DIR} \\\n-b ${BASELINE_NAME}                \\\n-t ${TEST_ID}                      \\\n-q debug                           \\\n--walltime 00:30:00                \\\n--mail-user $MAIL_USER             \\\n--mail-type all                    \\\n-c                                 \\\n-v                                 \\\n-j 4\n</code></pre> <p>The cases would be named <code>*.C.*</code> to denote one is comparing against previously generated baselines. Similar to the last time, a new <code>cs.status.${TEST_ID}</code> would be created and you can check the status of test by running it.</p>"},{"location":"ELM/tech-guide/","title":"Technical Guide","text":"<p>This Technical Guide describes the physics of ELM.</p> <ul> <li>TOP Parameterization: Parameterization of sub-grid topographical effects on solar radiation.</li> </ul>"},{"location":"ELM/tech-guide/top_solar_parameterization/","title":"Top solar parameterization","text":"<p>The TOP solar radiation parameterization in ELM accounts for the effects of sub-grid topography on solar radiation flux, including the shadow effects and multi-scattering between adjacent terrain<sup>1</sup>.</p>"},{"location":"ELM/tech-guide/top_solar_parameterization/#overview","title":"Overview","text":"<p>The incoming solar radiation for a flat surface is composed of direct radiation (\\(F_{dir}^{PP}\\)) from sun, diffuse radiation (\\(F_{dif}^{PP}\\)) from sky, and coupled radiation (\\(F_{couple}^{PP}\\)) that represents surface reflected radiation that is further reflected or scattered by atmospheric particles. ELM v1.0 and ELM v2.0 assume flat surfaces and accounts for \\(F_{dir}^{PP}\\) and \\(F_{dif}^{PP}\\), while neglecting \\(F_{couple}^{PP}\\). The solar radiation scheme of ELM v1.0 and  ELM v2.0 uses the two-stream approximations<sup>2</sup>. In contrast, the incoming solar radiation parametrization of Lee et al. (2011)<sup>3</sup> over mountainous regions includes five components (illustrated in Fig. 1): </p> <ol> <li>direct flux (\\(F_{dir}^{TOP}\\)) represents photons that are transmitted from the sun to the ground surface without encountering any reflection or scattering, </li> <li>the direct-reflected flux (\\(F_{rdir}^{TOP}\\)) represents photons that are not scattered photons reflected by surrounding terrain, </li> <li>diffuse flux (\\(F_{dif}^{TOP}\\)) represents photons that are scattered by atmospheric particles but are not reflected by the ground surface, </li> <li>diffuse-reflected flux (\\(F_{rdif}^{TOP}\\)) represents scattered photons reflected by surrounding terrain, and </li> <li>coupled flux (\\(F_{couple}^{TOP}\\)) represents remaining photons that are reflected multiple times or scattered by ground surface and atmospheric particles.</li> </ol> <p> </p>    Fig 1.: A schematic diagram of the five components of incoming solar radiation over mountains adapted from Lee et al. (2011)[^3]. The components of incoming solar radiation included are (1) direct flux, (2) diffuse flux, (3) direct-reflected flux, (4) diffuse-reflected flux, and (5) coupled flux. Local solar zenith angle (\u03b8), sky view factor (V<sub>d</sub>), and terrain configuration factor (C<sub>T</sub>) are also marked.    <p>\\(F_{dir}^{TOP}\\) is different from \\(F_{dir}^{PP}\\) because of the adjustment of solar illumination geometry and shadowing effects. \\(F_{dif}^{PP}\\) is different from \\(F_{dif}^{TOP}\\) because the sky hemisphere is occluded by adjacent terrain. Lee et al. (2011)<sup>3</sup> used the radiation fluxes over flat surfaces (i.e., \\(F_{dir}^{PP}\\) and \\(F_{dif}^{PP}\\)) to calculate the radiation fluxes over mountainous terrain based on sub-grid topographic factors. The relative deviation (\\(f_{dir}\\)) of direct flux between flat surfaces and mountains under the same atmospheric condition is defined as follows</p> \\[ \\label{eqn_fdir} f_{dir} = \\frac{F_{dir}^{TOP} - F_{dir}^{PP}}{F_{dir}^{PP}} \\] <p>The relative deviation (\\(f_{rdir}\\)) of direct-reflected flux over mountains to direct flux over flat surfaces is defined as follows:</p> \\[ \\label{eqn_frdir} f_{rdir} = \\frac{F_{rdir}^{TOP}}{F_{dir}^{PP}} \\] <p>Similarly, the relative deviations (\\(f_{dif}\\) and \\(f_{rdif}\\)) of diffuse and diffuse-reflected fluxes are expressed as follows:</p> \\[ \\label{eqn_fdif} f_{dif} = \\frac{F_{dif}^{TOP} - F_{dif}^{PP}}{F_{dir}^{PP}} \\] \\[ \\label{eqn_frdif} f_{rdif} = \\frac{F_{rdif}^{TOP}}{F_{dif}^{PP}} \\]"},{"location":"ELM/tech-guide/top_solar_parameterization/#multiple-linear-regression-model-of-lee-et-al-2011","title":"Multiple Linear Regression Model of Lee et al. (2011)","text":"<p>In theory, these four relative deviations (i.e., \\(f_{dir}\\), \\(f_{rdir}\\), \\(f_{dif}\\) and \\(f_{rdif}\\)) depend on solar illumination geometry and sub-grid topographic distribution. Based on a series of 3D Monte Carlo photon tracing simulations, Lee et al. (2011)<sup>3</sup> built a multiple linear regression parameterization to predict these four relative deviations well. The parameterization of Lee et al. (2011)<sup>3</sup> uses four variables that include the standard deviation of elevation (\\(\\sigma_h\\)) within a grid cell, grid-averaged values of cosine of the local solar incident angle (\\(\\mu\\)), sky view factor (\\(\\overline{V_d}\\)), and terrain configuration factor (\\(\\overline{C_T}\\)). Lee et al. (2011)<sup>3</sup> parameterization is given as follows:</p> \\[\\begin{bmatrix} f_{dir} \\\\ f_{dif} \\\\ f_{rdir} \\\\ f_{rdif} \\end{bmatrix} = \\mathbf{A} \\cdot  \\begin{bmatrix} \\overline{\\mu} \\\\ \\sigma_h \\\\ \\overline{V_d} \\\\ \\overline{C_T} \\\\ 1 \\end{bmatrix} \\] <p>where \\(\\mathbf{A}\\) represents the fitted parameter matrix, which was obtained based on the data generated by the 3D Monte Carlo simulations. The sky view factor (\\(V_d\\)) represents the portion of visible sky limited by surrounding terrain<sup>4</sup>, while the terrain configuration factor (\\(C_T\\)), the counterpart of the sky view factor, represents the portion of surrounding terrain which is visible to the ground target<sup>5</sup>. For an unobstructed infinite slope with the slope of \\(\\alpha\\) and aspect of \\(\\beta\\) and a given solar illumination geometry (i.e., solar zenith angle, \\(SZA\\), and solar azimuth angle, \\(SAA\\)), the cosine of the local solar incident angle (\\(\\mu\\)) can be calculated by</p> \\[ \\mu = \\cos(SZA) \\cos(\\alpha) + \\sin(SZA) \\sin(\\alpha) \\cos(SAA-\\beta) \\] <p>The \\(SZA\\) and \\(SAA\\) are assumed to be constant within a grid cell, but \\(\\alpha\\) and \\(\\beta\\) vary within a grid cell. The grid cell average solar incident angle, , can be expressed as follows:</p> \\[ \\begin{eqnarray} \\overline{\\mu} &amp;=&amp; \\overline{\\cos(SZA) \\cos(\\alpha)} + \\overline{\\sin(SZA) \\sin(\\alpha) \\cos(SAA-\\beta)} \\nonumber \\\\ &amp;=&amp; \\cos(SZA)  \\overline{\\cos(\\alpha)} +  \\sin(SZA) \\cos(SAA) + \\overline{\\sin(\\alpha) \\cos(\\beta)} + \\nonumber \\\\ &amp; &amp; \\sin(SZA) \\sin(SAA) + \\overline{\\sin(\\alpha) \\sin(\\beta)} \\end{eqnarray} \\] <p>where overlines represent grid-averaged values. To further improve the regression parameterization, \\(\\mu\\), \\(V_d\\), and \\(C_T\\) are normalized by \\(\\cos(\\alpha)\\). The land surface albedo is adjusted, instead of modifying incoming solar radiation, to maintain the surface energy conservation and the consistency between the surface and the first levels of atmosphere above the surface (Lee et al., 2015). Specifically, to keep the absorbed solar radiation of the ground surface unchanged, Lee et al. (2015) built the relationship between direct (\\(\\alpha_{dir}^{TOP}\\)) and diffuse (\\(\\alpha_{dif}^{TOP}\\)) albedo over mountains and those (\\(\\alpha_{dir}^{PP}\\) and \\(\\alpha_{dif}^PP\\)) over flat surfaces as follows:</p> \\[ \\begin{eqnarray} F_{dir}^{PP} (1 - \\alpha_{dir}^{TOP}) &amp;=&amp; (F_{dir}^{TOP} + F_{rdir}^{TOP})(1 - \\alpha_{dir}^{PP}) \\label{eqn_fdir_pp} \\\\ F_{dif}^{PP} (1 - \\alpha_{dif}^{TOP}) &amp;=&amp; (F_{dif}^{TOP} + F_{rdif}^{TOP})(1 - \\alpha_{dif}^{PP}) \\label{eqn_fdif_pp} \\end{eqnarray} \\] <p>Substituting Eqns \\eqref{eqn_fdir}-\\eqref{eqn_frdif} into Eqs \\eqref{eqn_fdir_pp}-\\eqref{eqn_fdif_pp} leads to</p> \\[ \\begin{eqnarray} \\alpha_{dir}^{TOP} &amp;=&amp; 1 - (1 + f_{dir} + f_{rdir}) (1 - \\alpha_{dir}^{PP}) \\label{eqn_alb_dir_top} \\\\ \\alpha_{dif}^{TOP} &amp;=&amp; 1 - (1 + f_{dif} + f_{rdif}) (1 - \\alpha_{dif}^{PP}) \\label{eqn_alb_dif_top} \\end{eqnarray} \\] <p>The parameterizations represented by Eqs. \\eqref{eqn_linear_reg}, \\eqref{eqn_alb_dir_top}, and \\eqref{eqn_alb_dif_top} are implemented in ELM to account for the sub-grid topographic effects on solar radiation fluxes.</p> <ol> <li> <p>Dalei Hao, Gautam Bisht, Yu Gu, Wei-Liang Lee, Kuo-Nan Liou, and L Ruby Leung. A parameterization of sub-grid topographical effects on solar radiation in the e3sm land model (version 1.0): implementation and evaluation over the tibetan plateau. Geoscientific Model Development, 14(10):6273\u20136289, 2021. doi:https://doi.org/10.5194/gmd-14-6273-2021.\u00a0\u21a9</p> </li> <li> <p>K. Oleson, D. Lawrence, G. Bonan, B. Drewniak, M. Huang, C. Koven, Z. M. Subin, and S. C. Swenson. Technical description of version 4.5 of the community land model (clm), ncar technical note. Technical Report NCAR/TN-503+ STR, National Center for Atmospheric Research (NCAR), Boulder, CO, USA, 2013. doi:https://doi.org/10.5065/D6RR1W7M.\u00a0\u21a9</p> </li> <li> <p>Wei-Liang Lee, KN Liou, and Alex Hall. Parameterization of solar fluxes over mountain surfaces for application to climate models. Journal of Geophysical Research: Atmospheres, 2011. doi:https://doi.org/10.1029/2010JD014722.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Klemen Zak\u0161ek, Kristof O\u0161tir, and \u017diga Kokalj. Sky-view factor as a relief visualization technique. Remote sensing, 3(2):398\u2013415, 2011. doi:https://doi.org/10.3390/rs3020398.\u00a0\u21a9</p> </li> <li> <p>Jeff Dozier and James Frew. Rapid calculation of terrain parameters for radiation modeling from digital elevation data. IEEE Transactions on geoscience and remote sensing, 28(5):963\u2013969, 1990. doi:https://doi.org/10.1109/36.58986.\u00a0\u21a9</p> </li> </ol>"},{"location":"ELM/user-guide/","title":"Users's Guide","text":"<p>start of the ELM User's Guide</p>"},{"location":"MOSART/","title":"Model for Scale Adaptive River Transport (MOSART)","text":"<p>Some introductory text here</p> <ul> <li>The MOSART User's Guide explains how to control MOSART when its running within E3SM</li> <li>The MOSART Developer's Guide explains MOSART data structures and how to develop new code.</li> <li>The MOSART Techincal Guide explains the science behind MOSART's code</li> </ul>"},{"location":"MOSART/dev-guide/","title":"Developers's Guide","text":"<p>Please refer to the ELM's Developer Guide for MOSART development.</p>"},{"location":"MOSART/tech-guide/","title":"Technical Guide","text":"<p>start of the MOSART Technical Guide</p>"},{"location":"MOSART/user-guide/","title":"Users's Guide","text":"<p>start of the MOSART User's Guide</p>"},{"location":"MPAS-seaice/","title":"The E3SM Sea Ice Model (MPAS-seaice)","text":"<p>MPAS-seaice is an unstructured-mesh sea-ice model that uses the Modeling for Prediction Across Scales (MPAS) framework, allowing enhanced horizontal resolution in regions of interest. MPAS-seaice incorporates many of the methods used in the Los Alamos CICE sea-ice model, but adapted to the Spherical Centroidal Vornoi Tesselation (SCVT) meshes used by the MPAS framework.</p> <ul> <li>The MPAS-seaice User's Guide outlines the MPAS Framework, on which MPAS-seaice is built, and Icepack, the column physics submodule in MPAS-seaice, and it provides guidance for controlling MPAS-seaice within E3SM.</li> <li>The MPAS-seaice Technical Guide describes the mesh and major physics components underlying MPAS-seaice code and its coupling to E3SM.</li> <li>The MPAS-seaice Developer's Guide provides additional information relevant for model development, including the Icepack interface and development/testing scripts.</li> </ul>"},{"location":"MPAS-seaice/#icepack","title":"Icepack","text":"<p>MPAS-seaice incorporates the Icepack software package for sea ice column physics, developed by the CICE Consortium, as a submodule. Icepack documentation. provides a complete description of the column physics and instructions for using Icepack as a standalone model. The source code for this documentation is maintained in E3SM's Icepack fork (navigate to the desired branch, then to doc/source/, etc).  This is the documentation associated with the latest Icepack version that has been merged into E3SM, plus any documentation changes made within E3SM itself. This documentation is fully rendered in E3SM's Icepack readthedocs.</p> <p>Guidance for developing Icepack documentation includes instructions for building the readthedocs documentation yourself.</p>"},{"location":"MPAS-seaice/#mpas-seaice-code-structure","title":"MPAS-seaice code structure","text":"<p>Some MPAS-seaice functionality is sourced from the MPAS Framework: <code>E3SM/components/mpas-framework</code>.  In particular, see <code>E3SM/components/mpas-framework/core_seaice</code>.</p> <p>Code structure within the <code>mpas-seaice/</code>component-level directory:</p> Directories Function <code>bld</code> namelist configuration files <code>cime_config</code> build and configuration scripts <code>docs</code> this documentation <code>driver</code> coupling modules <code>src</code> source code for the model physics and output <code>src/analysis_members</code> source code for model output <code>src/column</code> source code for the (original) <code>column_package</code> <code>src/icepack</code> link to the icepack submodule <code>src/model_forward</code> top-level mpas-seaice modules <code>src/shared</code> dynamics and general-purpose modules (e.g. mesh, constants) <code>testing</code> testing scripts"},{"location":"MPAS-seaice/references/","title":"References","text":"<p>Bitz, C. M., and W. H. Lipscomb (1999). An energy-conserving thermodynamic model of sea ice, Journal of Geophysical Research: Oceans, 104(C7), 15,669\u201315,677, doi: 10.1029/1999JC900100.</p> <p>Briegleb, B. P., and B. Light (2007). A Delta-Eddington multiple scattering parameterization for solar radiation in the sea ice component of the Community Climate Sys- tem Model, Tech. Rep. NCAR/TN-472+STR, National Center for Atmospheric Research, Boulder, Colorado USA.</p> <p>Dang, C., C. S. Zender, and M. G. Flanner (2019). Intercomparison and improvement of two-stream shortwave radiative transfer schemes in earth system models for a unified treatment of cryospheric surfaces. The Cryosphere, 13:2325\u20132343. doi:10.5194/tc-13-2325-2019.</p> <p>Dasgupta, G. (2003). Interpolants within convex polygons: Wachpress' shape functions. Journal of Aerospace Engineering, 16, 1\u20138. https://doi.org/10.1061/(ASCE)0893-1321(2003)16:1(1)</p> <p>Dukowicz, J. K., &amp; Baumgardner, J. R. (2000). Incremental remapping as a transport/advection algorithm. Journal of Computational Physics, 160(1), 318\u2013335. https://doi.org/10.1006/jcph.2000.6465</p> <p>Dunavant, D. A. (1985). High degree efficient symmetrical Gaussian quadrature rules for the triangle. International Journal for Numerical Methods in Engineering, 21(6), 1129\u20131148. https://doi.org/10.1002/nme.1620210612</p> <p>Flocco, D., D. L. Feltham, and A. K. Turner (2010). Incorporation of a physically based melt pond scheme into the sea ice component of a climate model, Journal of Geophysi- cal Research: Oceans, 115(C8), doi:10.1029/2009JC005568, C08012.</p> <p>Golaz, J.-C., Caldwell, P. M.,\u2028Van Roekel, L. P., Petersen, M. R., Tang, Q., Wolfe, J. D., et al. (2019). The DOE E3SM coupled model version 1: Overview and evaluation at\u2028standard resolution. Journal of Advances in Modeling Earth\u2028Systems, 11, 2089\u20132129. https://doi.org/10.1029/2018MS001603</p> <p>Golaz, J.-C., Van Roekel, L. P., Zheng, X., Roberts, A. F., Wolfe, J. D., Lin, W., et al. (2022). The DOE E3SM Model version 2: Overview of the physical model and initial model evaluation. Journal of Advances in Modeling Earth Systems, 14, e2022MS003156. https://doi.org/10.1029/2022MS003156</p> <p>Hibler, W. D. III (1979). A dynamic thermodynamic sea ice model. Journal of Physical Oceanography, 9(4), 815\u2013846. https://doi.org/10.1175/1520-0485(1979)009&lt;0815:ADTSIM&gt;2.0.CO;2</p> <p>Holland, M. M., D. A. Bailey, B. P. Briegleb, B. Light, and E. Hunke (2012). Improved sea ice shortwave radiation physics in CCSM4: The impact of melt ponds and aerosols on arctic sea ice, Journal of Climate, 25(5), 1413\u20131430, doi:10.1175/JCLI-D-11-00078.1.</p> <p>Hunke, E., et al. (2018). CICE-Consortium/Icepack. Zenodo. https://doi.org/10.5281/zenodo.1213462</p> <p>Hunke, E. C., &amp; Dukowicz, J. K. (1997). An elastic-viscous-plastic model for sea ice dynamics. Journal of Physical Oceanography, 27(9), 1849\u20131867. https://doi.org/10.1175/1520-0485(1997)027&lt;1849:AEVPMF&gt;2.0.CO;2</p> <p>Hunke, E. C., &amp; Dukowicz, J. K. (2002). The elastic-viscous-plastic sea ice dynamics model in general orthogonal curvilinear coordinates on a sphere\u2014Incorporation of metric terms. Monthly Weather Review, 130(7), 1848\u20131865.</p> <p>Hunke, E. C., Hebert, D. A., &amp; Lecomte, O. (2013). Level-ice melt ponds in the Los Alamos sea ice model, CICE. Ocean Modelling, 71, 26\u201342. https://doi.org/10.1016/j.ocemod.2012.11.008</p> <p>Lipscomb, W. H. (2001). Remapping the thickness distribution in sea ice models, Journal of Geophysical Research: Oceans, 106(C7), 13,989\u201314,000, doi:10.1029/2000JC000518.</p> <p>Lipscomb, W. H., &amp; Hunke, E. C. (2004). Modeling sea ice transport using incremental remapping. Monthly Weather Review, 132(6), 1341\u20131354.</p> <p>Lipscomb, W. H., Hunke, E. C., Maslowski, W., &amp; Jakacki, J. (2007). Ridging, strength, and stability in high-resolution sea ice models. Journal of Geophysical Research, 112. C03S91. https://doi.org/10.1029/2005JC003355</p> <p>Lipscomb, W. H., &amp; Ringler, T. D. (2005). An incremental remapping transport scheme on a spherical geodesic grid. Monthly Weather Review, 133(8), 2335\u20132350. https://doi.org/10.1175/MWR2983.1</p> <p>Turner, A. K., and E. C. Hunke (2015). Impacts of a mushy-layer thermodynamic ap- proach in global sea-ice simulations using the CICE sea-ice model, Journal of Geophys- ical Research: Oceans, 120(2), 1253\u20131275, doi:10.1002/2014JC010358.</p> <p>Turner, A. K., E. C. Hunke, and C. M. Bitz (2013). Two modes of sea-ice gravity drainage: A parameterization for large-scale modeling, Journal of Geophysical Research: Oceans, 118(5), 2279\u20132294, doi:10.1002/jgrc.20171.</p> <p>Turner, A. K., Lipscomb, W. H., Hunke, E. C., Jacobsen, D. W., Jeffery, N., Engwirda, D., Ringer, T. D., Wolfe, J. D. (2021). MPAS-seaice (v1.0.0): Sea-ice dynamics on unstructured Voronoi meshes. Geoscientific Model Development Discussions, 1\u201346. https://doi.org/10.5194/gmd-2021-355</p>"},{"location":"MPAS-seaice/dev-guide/","title":"Developer's Guide","text":"<p>Development of the MPAS-seaice component should follow the general procedures outlined by the E3SM project.</p> <p>Development Guide for E3SM Code Development Guide for E3SM Documentation</p>"},{"location":"MPAS-seaice/dev-guide/#configuration-controls","title":"Configuration Controls","text":"<p>MPAS-seaice is controlled using namelist options.  Namelist files for E3SM runs are found in <code>E3SM/components/mpas-seaice/bld/namelist_files/</code>.  However, the values in these files are drawn from the Registry, following the convention of all MPAS components. Registry files are used directly for stand-alone MPAS-seaice runs, and E3SM scripts pass information from them into E3SM's namelist files when a PR is merged.  E3SM's namelist files need to be changed for development purposes.  It's easiest to change all of them when needed, to keep them consistent, taking care not to unintentionally change standalone MPAS-seaice configurations.</p>"},{"location":"MPAS-seaice/dev-guide/#mpas-framework","title":"MPAS Framework","text":"<p>MPAS-seaice is built on the MPAS Framework.</p> <p>The MPAS Framework provides the foundation for a generalized geophysical fluid dynamics model on unstructured spherical and planar meshes. On top of the framework, implementations specific to the modeling of a particular physical system (e.g., sea ice, ocean) are created as MPAS cores. The MPAS design philosophy is to leverage the efforts of developers from the various MPAS cores to provide common framework functionality with minimal effort, allowing MPAS core developers to focus on development of the physics and features relevant to their application.</p> <p>The framework code includes shared modules for fundamental model operation. Significant capabilities include:</p> <ul> <li>Description of model data types. MPAS uses a handful of fundamental Fortran derived types for basic model functionality. Core-specific model variables are handled through custom groupings of model fields called pools, for which custom access routines exist. Core-specific variables are defined in XML syntax in a Registry, and the framework parses the Registry, defines variables, and allocates memory as needed.</li> <li>Mesh specification. MPAS requires 36 fields to fully describe the mesh used in a simulation. These include the position, area, orientation, and connectivity of all cells, edges, and vertices in the mesh. The mesh specification can flexibly describe both spherical and planar meshes. For more information about the meshes, see the Users Guide.</li> <li>Distributed memory parallelization and domain decomposition. The MPAS Framework provides needed routines for exchanging information between processors in a parallel environment using Message Passing Interface (MPI). This includes halo updates, global reductions, and global broadcasts. MPAS also supports decomposing multiple domain blocks on each processor to optimize model performance by minimizing transfer of data from disk to memory. Shared memory parallelization through OpenMP is also supported, but the implementation is left up to each core.</li> <li>Parallel input and output capabilities. MPAS performs parallel input and output of data from and to disk through the commonly used libraries of NetCDF, Parallel NetCDF (pnetcdf), and Parallel Input/Output (PIO). The Registry definitions control which fields can be input and/or output, and a framework \"streams\" functionality provides run-time configuration of what fields are to be written to what file name and at what frequency through an XML streams file. The MPAS framework includes additional functionality specific to providing a flexible model restart capability.</li> <li>Advanced timekeeping. MPAS uses a customized version of the timekeeping functionality of the Earth System Modeling Framework (ESMF), which includes a robust set of time and calendar tools used by many Earth System Models (ESMs). This allows explicit definition of model epochs in terms of years, months, days, hours, minutes, seconds, and fractional seconds and can be set to three different calendar types: Gregorian, Gregorian no leap, and 360 day. This flexibility helps enable multi-scale physics and simplifies coupling to ESMs. To manage the complex date/time types that ensue, MPAS framework provides routines for arithmetic of time intervals and the definition of alarm objects for handling events (e.g., when to write output, when the simulation should end).</li> <li>Run-time configurable control of model options. Model options are configured through namelist files that use standard Fortran namelist file format, and input/output are configured through streams files that use XML format. Both are completely adjustable at run time.</li> <li>Online, run-time analysis framework. A system for defining analysis of model states during run time, reducing the need for post-processing and model output.</li> </ul> <p>Additionally, a number of shared operators exist to perform common operations on model data. These include geometric operations (e.g., length, area, and angle operations on the sphere or the plane), interpolation (linear, barycentric, Wachspress, radial basis functions, spline), vector and tensor operations (e.g., cross products, divergence), and vector reconstruction (e.g., interpolating from cell edges to cell centers). Most operators work on both spherical and planar meshes.</p>"},{"location":"MPAS-seaice/dev-guide/#icepack","title":"Icepack","text":"<p>For changes to Icepack, please consult the CICE Consortium's recommendations for code contributions.</p> <p>To access the column physics in Icepack, MPAS-seaice uses methods defined in <code>icepack_intfc.F90</code>. The 'init' and 'query' methods are used to set and retrieve Icepack values. A 'write' method is also available for documenting these values. MPAS-seaice follows the 'icepack_warnings' methodology where <code>icepack_warnings_aborted</code> is checked and <code>icepack_warnings_flush</code> is called after every call to an Icepack method. It does not directly \u201cuse\u201d Icepack data, accessing Icepack data only through these interfaces.</p> <p>Basic Icepack development can be done in standalone mode using Icepack's testing scripts, directly in the submodule branch in MPAS-seaice. We recommend that Icepack developments be thoroughly tested within E3SM's coupled framework throughout the development process, including fully coupled simulations.</p>"},{"location":"MPAS-seaice/dev-guide/#e3sm-polar-developer-script","title":"E3SM-Polar-Developer Script","text":"<p>To accelerate early development stages, a script is available for configuring and testing MPAS-seaice (including the Icepack submodule) in D compsets, which have the sea ice component active and data models for the other components.</p>"},{"location":"MPAS-seaice/dev-guide/#view-helpful-information-including-default-values-for-duration-configuration-etc","title":"View helpful information, including default values for duration, configuration, etc.","text":"<pre><code>git clone git@github.com:E3SM-Project/SimulationScripts.git\ncd SimulationScripts/archive/PolarGroup\n./E3SM-Polar-Developer.sh -h\n</code></pre> <p>For debugging E3SM, search the script for 'debug' and follow the instructions.</p> <p>The following examples describe how to use the script for development in Icepack.  Similar procedures could be used for any MPAS-SI physics development.</p>"},{"location":"MPAS-seaice/dev-guide/#set-up-and-run-baselines","title":"Set up and run baselines","text":"<p>Create a file containing modified namelist options. The file <code>nset01.nlk</code> in this example creates baselines for two types of column physics and turns off the <code>snicar_ad</code> radiation scheme.</p> <pre><code>$ less nset01.nlk\n[mpassi]\nconfig_column_physics_type = {'column_package','icepack'}\nconfig_use_snicar_ad = {.false.}\n</code></pre> <p>Notes:</p> <ul> <li>A .nlk file without any config settings will create a baseline using default settings.</li> <li>The <code>column_package</code> option is still available but is no longer being supported in MPAS-seaice.</li> </ul> <p>Fetch E3SM (choose any name for the directory baselines01):</p> <pre><code>./E3SM-Polar-Developer.sh -s baselines01 -f git@github.com:E3SM-Project/E3SM\n</code></pre> <p>Set up a new case and build it:</p> <pre><code>./E3SM-Polar-Developer.sh -s baselines01 -k nset01.nlk -e -n -b\n</code></pre> <p>Submit:</p> <pre><code>./E3SM-Polar-Developer.sh -s baselines01 -k nset01.nlk -e -q\n</code></pre> <p>Examine the diagnostic output (compares the icepack run with the column_package run in this example):</p> <pre><code>./E3SM-Polar-Developer.sh -s baselines01 -k nset01.nlk -e -a -v\n</code></pre>"},{"location":"MPAS-seaice/dev-guide/#set-up-a-sandbox-for-model-development-to-be-compared-with-the-baselines","title":"Set up a sandbox for model development, to be compared with the baselines","text":"<p>Fetch E3SM (choose any name for the directory newdev01):</p> <pre><code>./E3SM-Polar-Developer.sh -s newdev01 -f git@github.com:E3SM-Project/E3SM\n</code></pre> <p>Create a new development branch:</p> <pre><code>cd ~/E3SM-Polar/code/newdev01\ngit branch newbranch\ngit checkout newbranch\n</code></pre> <p>Set up a new case and build it:</p> <pre><code>./E3SM-Polar-Developer.sh -s newdev01 -k nset01.nlk -e -n -b\n</code></pre> <p>Develop and test... Build/compile:</p> <pre><code>./E3SM-Polar-Developer.sh -s newdev01 -k nset01.nlk -e -b\n</code></pre> <p>Submit:</p> <pre><code>./E3SM-Polar-Developer.sh -s newdev01 -k nset01.nlk -e -q\n</code></pre> <p>Examine the diagnostic output:</p> <pre><code>./E3SM-Polar-Developer.sh -s newdev01 -k nset01.nlk -e -a -v\n</code></pre> <p>Compare with the baselines case directory (use your D3 baselines directory):</p> <pre><code>./E3SM-Polar-Developer.sh -s newdev01 -k nset01.nlk -a D3.nset01.baselines01.master.E3SM-Project.anvil -v\n</code></pre>"},{"location":"MPAS-seaice/dev-guide/#make-changes-in-icepack-and-pr-to-the-consortium","title":"Make changes in Icepack and PR to the Consortium","text":"<p>We recommend PR\u2019ing Icepack changes first to the Consortium then to E3SM\u2019s icepack fork, in order to keep the repositories in sync and to ensure the changes are robust outside of E3SM.  Some changes to Icepack require extensive changes to the driver code (e.g. MPAS-seaice or CICE), making this process challenging.  Contact the CICE Consortium to discuss and identify a collaborative path forward.</p> <p>First, create a baseline (standalone) Icepack test suite using the E3SM icepack fork or, if the Consortium code is different, using Consortium icepack main (see Consortium documentation.)</p> <p>Similarly test your branch of Icepack within E3SM and compare with the baseline. When satisfied with E3SM testing, PR to Consortium icepack main:</p> <pre><code>git remote add consortium git@github.com:cice-consortium/icepack.git\ngit pull consortium main\n</code></pre> <p>Fix conflicts if needed, then</p> <pre><code>git add ...\ngit commit -m \"update from cice-consortium main\"\n</code></pre> <p>Continue testing. When satisfied,</p> <pre><code>git push origin branch\n</code></pre> <p>Create a PR from branch to cice-consortium/icepack -b main.</p> <p>Once the PR has been tested and merged into the main Icepack codebase, a new PR is submitted to E3SM.</p> <p>More extensive documentation of this workflow tool used for the Icepack merge project is available here.</p>"},{"location":"MPAS-seaice/dev-guide/#cice-qc-quality-control-testing","title":"CICE-QC Quality Control Testing","text":"<p>Example to run a CICE-QC comparison between two E3SM simulations with changes to the sea ice component.</p>"},{"location":"MPAS-seaice/dev-guide/#set-up-and-run-simulations-to-be-compared","title":"Set up and run simulations to be compared","text":"<pre><code>cd ~/SimulationScripts/archive/PolarGroup/\n</code></pre> <p>Create a <code>.nlk</code> file with namelist changes to include the thickness analysis member. Include changes to namelist values needed in both the baseline and the test here, if desired (append the last 3 lines here to the end of your standard D-case test .nlk).</p> <pre><code>$ less qcbase.nlk\n[mpassi]\nconfig_AM_thicknesses_enable = {.true.}\nconfig_AM_thicknesses_compute_on_startup = {.true.}\nconfig_AM_thicknesses_write_on_startup = {.true.}\n</code></pre> <p>Use test script to clone E3SM, and create a sandbox</p> <pre><code>./E3SM-Polar-Developer.sh -s qcbaseline -f git@github.com:E3SM-Project/E3SM\n</code></pre> <p>Edit <code>~/E3SM-Polar/code/qcbaseline/components/mpas-seaice/cime_config/buildnml</code> to change:</p> <pre><code>lines.append('        output_interval=\"none\"&gt;')\n</code></pre> <p>to</p> <pre><code>lines.append('        output_interval=\"00-00-01_00:00:00\"&gt;')\n</code></pre> <p>for <code>stream name=\u201coutput\u201d</code> and add</p> <pre><code>lines.append('    &lt;var name=\"iceThicknessCell\"/&gt;')\n</code></pre> <p>a few lines below that:</p> <pre><code>            lines.append('&lt;stream name=\"output\"')\n            lines.append('        type=\"output\"')\n            lines.append('        io_type=\"{}\"'.format(ice_pio_typename))\n            lines.append('        filename_template=\"{}.mpassi{}.hist.$Y-$M-$D_$\nS.nc\"'.format(casename, inst_string))\n            lines.append('        filename_interval=\"00-01-00_00:00:00\"')\n            lines.append('        clobber_mode=\"truncate\"')\n            lines.append('        reference_time=\"01-01-01_00:00:00\"')\n-           lines.append('        output_interval=\"none\"&gt;')\n+           lines.append('        output_interval=\"00-00-01_00:00:00\"&gt;')\n            lines.append('')\n            lines.append('    &lt;stream name=\"mesh\"/&gt;')\n            lines.append('    &lt;var name=\"xtime\"/&gt;')\n            lines.append('    &lt;var name=\"daysSinceStartOfSim\"/&gt;')\n            lines.append('    &lt;var name=\"iceAreaCell\"/&gt;')\n            lines.append('    &lt;var name=\"iceVolumeCell\"/&gt;')\n            lines.append('    &lt;var name=\"snowVolumeCell\"/&gt;')\n+           lines.append('    &lt;var name=\"iceThicknessCell\"/&gt;')\n            lines.append('    &lt;var name=\"uVelocityGeo\"/&gt;')\n            lines.append('    &lt;var name=\"vVelocityGeo\"/&gt;')\n            lines.append('')\n            lines.append('&lt;/stream&gt;')\n</code></pre> <p>Build and run baseline case for 5 years (60 months):</p> <pre><code>./E3SM-Polar-Developer.sh -s qcbaseline -k qcbase.nlk -e -d60 -nb\n./E3SM-Polar-Developer.sh -s qcbaseline -k qcbase.nlk -e -d60 -q\n</code></pre> <p>Copy the thickness analysis member changes into your development directory:</p> <pre><code>cd ~/E3SM-Polar/code/newdev01/components/mpas-seaice/cime_config/\ncp ~/E3SM-Polar/code/qcbaseline/components/mpas-seaice/cime_config/buildnml .\n</code></pre> <p>If your development case adds namelist parameters, add the thickness analysis member to your .nlk file as above. This example uses the default configuration.</p> <p>Build and run the development case:</p> <pre><code>cd ~/SimulationScripts/archive/PolarGroup/\n./E3SM-Polar-Developer.sh -s newdev01 -k qcbase.nlk -e -d60 -nb\n./E3SM-Polar-Developer.sh -s newdev01 -k qcbase.nlk -e -d60 -q\n</code></pre>"},{"location":"MPAS-seaice/dev-guide/#run-qc-comparison","title":"Run QC comparison","text":"<pre><code>cd ~/E3SM-Polar/code/newdev01/components/mpas-seaice/testing/cice-qc\n</code></pre> <p>See README.md.  This example is for anvil.</p> <p>Edit <code>job_script.cice-qc.anvil</code> to export (insert your username)</p> <pre><code>BASE = /lcrc/group/e3sm/[username]/E3SM-Polar/D12.qcbase.emc.qcbaseline.master.E3SM-Project.anvil/run.k000/\nTEST = /lcrc/group/e3sm/[username]/E3SM-Polar/D12.qcbase.emc.newdev01.branch.E3SM-Project.anvil/run.k000\n</code></pre> <p>Submit QC test. Test results will be in the file <code>qc_log.txt</code>.</p> <pre><code>sbatch job_script.qc-testing-mpassi.anvil\nless qc_log.txt\n</code></pre> <p>Example of desired result:</p> <pre><code>Running QC test on the following directories:\n  /lcrc/group/e3sm/ac.eclare/E3SM-Polar/D12.qcbase.emc.qcbaseline.master.E3SM-Project.anvil/run.k000/\n  /lcrc/group/e3sm/ac.eclare/E3SM-Polar/D12.qcbase.emc.newdev01.branch.E3SM-Project.anvil/run.k000\nNumber of files: 61\n2 Stage Test Passed\nQuadratic Skill Test Passed for Northern Hemisphere\nQuadratic Skill Test Passed for Southern Hemisphere\n</code></pre>"},{"location":"MPAS-seaice/dev-guide/#generate-statistics-from-the-cice-qc-runs","title":"Generate statistics from the CICE-QC runs","text":"<p>This only works if the .nlk filename is the same for both cases.  If comparing only namelist changes within MPAS-seaice, use the <code>./E3SM-Polar-Developer.sh</code> script with a single .nlk file that includes each option.</p> <pre><code>cd ~/SimulationScripts/archive/PolarGroup/\n$ ./E3SM-Polar-Developer.sh -s qcbaseline -k qcbase.nlk -e -d60 -a D12.qcbase.emc.newdev01.branch.E3SM-Project.anvil -v\n</code></pre>"},{"location":"MPAS-seaice/dev-guide/#create-comparison-plots","title":"Create comparison plots","text":"<p>To generate MPAS-Analysis plots from the CICE-QC runs and compare:</p> <p>Copy the scripts in the file above to anvil or chrysalis - PROVIDE FILE</p> <p>Edit each script for your run names, directories, etc (search for 'echmod' to find settings used for the qcPR19 comparison above)</p> <p>Edit and submit (on chrysalis) the job script 3 times, once for icepack, once for column, and finally for the comparison.</p> <p>Browse the html output, e.g. navigate to <code>https://web.lcrc.anl.gov/public/e3sm/diagnostic_output/ac.eclare/icepack-testing/D12.qcPR19.emc.qcPR19.snicar_active.eclare108213.anvil/mpas_analysis_output/</code></p>"},{"location":"MPAS-seaice/tech-guide/","title":"Technical Guide","text":""},{"location":"MPAS-seaice/tech-guide/#primary-documentation-for-mpas-seaice","title":"Primary documentation for MPAS-seaice","text":"<p>See complete citations in References.</p> <p>E3SM v1 Overview: Golaz et al., JAMES 2019</p> <p>MPAS-seaice v1: Turner et al., GMD Discussions, 2021.</p> <p>E3SM v2 Overview: Golaz et al., JAMES 2022</p> <p>Icepack: Full documentation for E3SM's version of Icepack can be found in E3SM's Icepack readthedocs.  The most up-to-date documentation from the CICE Consortium's main Icepack repository is here.</p> <p>A comprehensive paper describing MPAS-seaice is in preparation.</p>"},{"location":"MPAS-seaice/tech-guide/#meshes","title":"Meshes","text":"<p>MPAS-Seaice is the sea ice component of E3SMv1. MPAS-Seaice and MPAS-Ocean share identical meshes, but MPAS-Seaice uses B-grid discretizations (Arakawa &amp; Lamb, 1977) with sea ice concentration, volume, and tracers defined at cell centers and velocity defined at cell vertices.</p> <p>The MPAS mesh system requires the definition of seven elements.  These seven elements are composed of two types of cells, two types of lines, and three types of points.  These elements can be defined on either the plane or the surface of the sphere.  The two types of cells form two meshes, a primal mesh composed of Voronoi regions and a dual mesh composed of Delaunay triangles.  Each corner of a primal mesh cell is uniquely associated with the \"center\" of a dual mesh cell and vice versa. The boundary of a given primal mesh cell is composed of the set of lines that connect the centers of the dual mesh cells.  Similarly, the boundary of a given dual mesh cell is composed of the set of lines that connect the center points of the associated primal mesh cells. A line segment that connects two primal mesh cell centers is uniquely associated with a line seqment that connects two dual mesh cell centers.  We assume that these two line seqments cross and are orthogonal.  Since the two line seqments crossing are othogonal, they form a convenient local coordinate system for each edge.  Figure: Sample from an MPAS mesh showing the primal mesh (solid lines), the dual mesh (dashed), and velocity components aligned with a locally Cartesian coordinate system (east/north).</p>"},{"location":"MPAS-seaice/tech-guide/#velocity-and-stresses","title":"Velocity and Stresses","text":"<p>Velocity components at cell vertices are not aligned with the mesh, as in sea ice models with structured meshes and quadrilateral cells. Instead, the velocity components are aligned with a spherical coordinate system that is locally Cartesian, eastwards (u) and northwards (v), irrespective of the orientation of edges joining that vertex. Such a definition, however, would result in a convergence of v components at the geographic North Pole and strong metric terms in the velocity solution. Consequently, in addition, these definitions of u and v are rotated so that their pole lies on the geographical equator at 0 deg longitude.</p> <p>Velocities are determined by solving the sea ice momentum equation (Hibler, 1979; Hunke &amp; Dukowicz, 1997). During coupled simulations the ocean model provides the ocean surface tilt term; the only other term that depends on the properties of the horizontal grid is the divergence of internal stress.  Therefore only this stress term must be adapted for use on MPAS meshes.  Otherwise the velocity solver is identical to that in CICE\u2019s standard EVP approach. Determination of the divergence of the internal stress can be broken down into three stages:</p> <ol> <li> <p>The strain rate tensor is determined from the velocity field.</p> </li> <li> <p>The stress tensor at a point is determined, through a constitutive relation, from the strain rate tensor at that point.</p> </li> <li> <p>The divergence of this stress tensor is calculated.</p> </li> </ol> <p>Two schemes to calculate the strain rate tensor and the divergence of internal stress on MPAS meshes are implemented in MPAS-Seaice, a variational scheme based on that used in CICE (Hunke and Dukowicz, 2002), and a weak scheme that uses the line integral forms of the symmetric gradient and divergence operators. The variational scheme is based on the fact that over the entire domain, \u03a9, and ignoring boundary effects, the total work done by the internal stress is equal to the dissipation of mechanical energy. Instead of the bilinear basis functions used by CICE, MPAS-Seaice uses Wachspress basis functions (Dasgupta, 2003), which are integrated with the quadrature rules of Dunavant (1985).</p>"},{"location":"MPAS-seaice/tech-guide/#horizontal-transport-of-ice-area-fraction-and-tracers","title":"Horizontal Transport of Ice Area Fraction and Tracers","text":"<p>Horizontal transport of ice concentration, volume, and tracers is achieved with an incremental remapping (IR) scheme similar to that described in Dukowicz and Baumgardner (2000), Lipscomb and Hunke (2004), and Lipscomb and Ringler (2005).  For MPAS-Seaice the IR scheme was generalized to work on either the standard MPAS mesh (hexagons and other n-gons of varying sizes, with a vertex degree of 3, or a quadrilateral mesh with a vertex degree of 4 as in CICE. Since MPAS meshes are unstructured, the IR scheme had to be rewritten from scratch. Most of the code is mesh-agnostic, but a small amount of code is specific to quad meshes. The transport equations describe conservation of quantities such as volume and energy.  Fractional ice area (also known as sea ice concentration) is a mass-like quantity whose transport equation forms the basis for all other transported quantities in the model.  In particular, ice volume is the product of ice area and thickness; therefore thickness is treated as a tracer on ice area, transported with the continuity equation for conservation of volume. Likewise, snow depth is carried as a tracer on ice area via a conservation of snow volume equation.  Ice thickness and snow depth are referred to as \u201ctype 1\u201d tracers (carried directly on ice area). Ice and snow enthalpy in each vertical layer are type 2 tracers, carried on ice and snow volume. When run with advanced options (e.g., active melt ponds and biogeochemistry), MPAS-Seaice advects tracers up to type 3. Thus, the mass-like field (area) is the \u201cparent field\u201d for type 1 tracers; type 1 tracers are parents of type 2; and type 2 tracers are parents of type 3.  Sources and sinks of mass and tracers (e.g., ice growth and melting) are treated separately from transport.</p> <p>The transport time step is limited by the requirement that trajectories projected backward from vertices are confined to the cells sharing the vertex (i.e., 3 cells for the standard MPAS mesh and 4 for the quad mesh). This is what is meant by incremental as opposed to general remapping. For highly divergent velocity fields, the maximum time step may have to be reduced by a factor of 2 to ensure that trajectories do not cross. The incremental remapping algorithm consists of the following steps:</p> <ol> <li>Given mean values of the ice area and tracer fields in each grid cell and thickness category, construct linear approximations of these fields. Limit the field gradients to preserve mono- tonicity.</li> <li>Given ice velocities at grid cell vertices, identify departure regions for the transport across each cell edge. Divide these departure regions into triangles and compute the coordinates of the triangle vertices.</li> <li>Integrate the area and tracer fields over the departure triangles to obtain the area, volume, and other conserved quantities transported across each cell edge.</li> <li>Given these transports, update the area and tracers.</li> </ol> <p>Since all fields are transported by the same velocity field, the second step is done only once per time step. The other steps are repeated for each field.</p> <p>With advanced physics and biogeochemistry (BGC) options, MPAS-Seaice can be configured to include numerous tracer fields, each of which is advected in every thickness category, and many of which are defined in each vertical ice or snow layer. In order to accommodate different tracer combinations and make it easy to add new tracers, the tracer fields are organized in a linked list that depends on which physics and BGC packages are active. The list is arranged with fractional ice area first, followed by the type 1 tracers, type 2 tracers, and finally type 3 tracers. In this way, values computed for parent tracers are always available when needed for computations involving child tracers.</p>"},{"location":"MPAS-seaice/tech-guide/#column-physics","title":"Column Physics","text":"<p>The Icepack software has replaced the original <code>colpkg</code> column physics code in MPAS-seaice. The <code>config_column_physics_type = 'column_package'</code> option is still available but is no longer being supported in MPAS-seaice.</p> <p>Because of the strong thermal gradients between the (cold) atmosphere and (relatively warm) oceans in polar regions, a large portion of the physics in sea ice models can be described in a vertical column, without reference to neighboring grid cells. MPAS-Seaice shares the same column physics code as CICE through the Icepack library (Hunke et al., 2018), which is maintained by the CICE Consortium. This code includes several options for simulating sea ice thermodynamics, mechanical redistribution (ridging) and associated area and thickness changes. In addition, the model supports a number of tracers, including thickness, enthalpy, ice age, first-year ice area, deformed ice area and volume, melt ponds, snow properties and biogeochemistry.</p> <p>Icepack is implemented in MPAS-seaice as a git submodule. Icepack consists of three independent parts, the column physics code, the Icepack driver that supports stand-alone testing of the column physics code, and the Icepack scripts that build and test the Icepack model.  E3SM uses only the column physics code, which is called for each ocean grid cell.  Icepack\u2019s own driver and testing scripts are used when preparing new developments to be merged back to the CICE Consortium\u2019s Icepack repository.</p> <p>Icepack includes sophisticated vertical physics and biogeochemical schemes, which include vertical thermodynamics schemes (Bitz and Lipscomb, 1999; Turner et al., 2013; Turner and Hunke, 2015), melt-pond parameterizations (Flocco et al., 2010; Hunke et al., 2013), a delta-Eddington radiation scheme (Briegleb and Light, 2007; Holland et al., 2012a), schemes for transport in thickness space (Lipscomb, 2001), and representations of mechanical redistribution (Lipscomb et al., 2007).</p> <p>Full documentation for E3SM's version of Icepack can be found in E3SM's Icepack readthedocs.  The most up-to-date documentation from the CICE Consortium's main Icepack repository is here.</p>"},{"location":"MPAS-seaice/tech-guide/#thermodynamics","title":"Thermodynamics","text":"<p>In its default configuration, MPAS-Seaice uses the \u201cmushy layer\u201d vertical thermodynamics scheme of Turner et al. (2013) and Turner and Hunke (2015).  The mushy layer formulation describes the sea ice as a two-phase system of crystalline, fresh ice and liquid brine. Enthalpy depends on temperature and salinity, all of which are prognostic variables.  The mushy layer equations are derived from conservation of energy, conservation of salt, an ice-brine liquidus relation that determines the temperature- and salinity-dependent phase, and Darcy flow through a porous medium to describe the vertical movement of brine within the ice.  When or where the ice is cold, brine pockets are isolated from each other, but warmer temperatures cause the brine pockets to expand and connect into vertical channels in which meltwater, seawater, biology and nutrients may move through the ice.</p>"},{"location":"MPAS-seaice/tech-guide/#melt-ponds","title":"Melt Ponds","text":"<p>MPAS-seaice uses the level-ice melt pond scheme of Hunke et al. (2013). The ponds are carried as tracers on the level (undeformed) ice area of each thickness category, thus limiting their spatial extent based on the simulated sea ice topography. This limiting is meant to approximate the horizontal drainage of melt water into depressions in ice floes. The ponds evolve according to physically based process descriptions, assuming a thickness-area ratio for changes in pond volume. Melt pond processes include addition of liquid water from rain, melting snow and melting surface ice, drainage of pond water when its weight pushes the ice surface below sea level or when the ice interior becomes permeable, and refreezing of the pond water. If snow falls after a layer of ice has formed on the ponds, the snow may block sunlight from reaching the ponds below. When melt water forms with snow still on the ice, the water is assumed to infiltrate the snow. If there is enough water to fill the air spaces within the snowpack, then the pond becomes visible above the snow, thus decreasing the albedo and ultimately causing the snow to melt faster. The albedo also decreases as snow depth decreases, and thus a thin layer of snow remaining above a pond-saturated layer of snow will have a lower albedo than if the melt water were not present. Level-ice melt ponds are \u201cvirtual\u201d in the sense that rain and meltwater is sent to the ocean immediately, and the tracers are only used thereafter to adjust the radiative calculations as if the ponds were present.  The delta-Eddington radiative transfer scheme must be active for this purpose.</p>"},{"location":"MPAS-seaice/tech-guide/#radiation","title":"Radiation","text":"<p>The Delta-Eddington radiation scheme of Briegleb &amp; Light (2007) has been updated to the Dang et al. (2019) SNICAR-AD model, to ensure radiative consistency across all snow surfaces in E3SM, including on land, ice sheets and sea ice. The SNICAR-AD radiative transfer code includes five-band snow single-scattering properties, two-stream Delta-Eddington approximation with the adding\u2013doubling technique, and parameterization for correcting the near-infrared (NIR) snow albedo biases when solar zenith angle exceeds 75 degrees (Dang et al., 2019).</p>"},{"location":"MPAS-seaice/tech-guide/#snow","title":"Snow","text":"<p>A new snow-on-sea-ice morphology has been added to E3SMv2 that includes the effects of wind redistribution: losses to leads and meltponds, and the piling of snow against ridges. Snow grain radius, now a prognosed tracer field on sea ice, evolves according to temperature gradient and wet snow metamorphism and feeds back to the SNICAR-AD radiative model up to a dry maximum of 2800 \u03bcm. Fresh snow falls at a grain radius of 54.5 \u03bcm, and five vertical snow layers replace the previous single snow layer atop each of the five sea ice thickness categories retained from E3SMv1.</p> <p>A paper describing the advanced snow physics is in preparation.</p>"},{"location":"MPAS-seaice/tech-guide/#biogeochemistry","title":"Biogeochemistry","text":"<p>This section is under construction, pending the full merge of BGC codes in Icepack and the older column physics package.</p>"},{"location":"MPAS-seaice/tech-guide/#coupling-of-mpas-seaice-within-e3sm","title":"Coupling of MPAS-seaice within E3SM","text":"<p>This section is under construction.  Current text is quoted from the v1 and v2 overview papers.</p> <p>v1: Coupling of the sea ice component to the ocean takes advantage of z star ocean coordinates as described by Campin et al. (2008) and is a departure from the coupling of CICE and POP (Parallel Ocean Program) in CESM1. The weight of sea ice contributes to the ocean's barotropic mode, notably affecting the free surface over continental shelves. In shallow water depths at or less than the floating ice draft, the weight passed to the ocean model is limited to prevent evacuation of the underlying liquid column. When frazil ice forms in the ocean model, the volume of newly formed crystals is passed to the sea ice model with a fixed salinity of 4 PSU, rather than exchanging a freezing potential as in other models. Future versions of E3SM will permit progressive brine drainage to the ocean from the mushy layer physics used in MPAS-Seaice (Turner &amp; Hunke, 2015). For E3SMv1, brine drainage occurs internally in MPAS-Seaice for thermodynamic calculations, but for the sake of freshwater coupling, the ocean model only receives mass fluxes back from melted sea ice at the fixed salinity that it originally passed to its cryospheric counterpart (4 PSU). The ocean temperature immediately under the ice is the same as the liquid phase in the lowest layer of the sea ice model and is not fixed at \u22121.8 \u25e6C as is typical of previous generation coupled models (Naughten et al., 2017). For the current version, we have addressed these long-standing ocean-ice coupling issues identified by the modeling community: explicit sea ice mass and salt exchange, a pressure force of the ice on the ocean, a basal sea ice temperature consistent with the ocean model's equation of state, and resolved inertial oscillations (Hibler et al., 2006; Lique et al., 2016; Schmidt et al., 2004).</p> <p>v2: The most significant improvement to the sea ice climate since E3SMv1 was achieved with coupling changes associated with mushy-layer thermodynamics. Whereas the basal temperature of the ice was held fixed at -1.8\u25e6C in E3SMv1, the new version of the model assumes the mushy liquidus basal temperature from the sea ice as described by Turner\u00a0&amp; Hunke (2015). Conversion of frazil ice from MPAS-Ocean with a fixed reference salinity of 4 PSU to the mushy layer now conserves to computational accuracy over a 500-year control integration. This was achieved by exchanging additional mass between the upper ocean and sea ice model to accommodate an assumed 25% mushy liquid content \u00a0assumed from heat and mass transferred adiabatically from the MPAS-Ocean frazil scheme active from a depth of 100 m. In addition to achieving perfect heat and mass conserva\u00a0tion between sea ice and ocean models, this improvement greatly reduces a negative sea \u00a0ice thickness bias in the summer Arctic reported by Golaz et al. (2019) for E3SMv1; it only minimally impacts Southern Ocean sea ice mass that was better simulated as compared to northern hemisphere sea ice in E3SMv1. Note that E3SM does not use virtual ice-ocean fluxes, but instead full mass and heat flux exchange consistent with a Boussinesq ocean model as described by Campin et al. (2008). \u2028Radiative coupling with the atmosphere still integrates across just two bands (visible and NIR) separated at 700nm, which does not fully exploit the five-band capability available in the delta-Eddington scheme.</p>"},{"location":"MPAS-seaice/tech-guide/#prescribed-ice-mode","title":"Prescribed Ice Mode","text":"<p>E3SM also includes a prescribed-extent ice mode for MPAS-SeaIce based the CESM implementation. This mode is needed for Atmospheric Model Intercomparison Project (AMIP) style simulations where a full prognostic sea ice model is not desired but sea ice surface fluxes, albedos, snow depth, and surface temperature are needed by the atmosphere model. These fields are calculated by the vertical thermodynamics module of the sea ice component. The prescribed-ice mode is intended for atmosphere sensitivity experiments and does not conserve energy or mass. In this mode, sea ice thermodynamics is active but sea ice dynamics are disabled, and at each time step ice area and thickness are reset to specified values. Ice area is interpolated in time and space from an input data set, while ice thickness in grid cells containing sea ice is set to 2 m in the Northern hemisphere and 1 m in the Southern hemisphere. During each area and thickness adjustment, snow volume preserves the snow thickness prognosed in the previous time step. Snow temperatures are reset to the surface temperature, as prognosed in the previous time step, while ice temperatures are set so that the ice temperature gradient is linear, with the ice temperature at the top equal to the prognosed surface temperature, and equal to the sea freezing temperature at the base of the ice. The vertical ice salinity profile is reset to the profile from Bitz &amp; Lipscomb (1999). The prescribed-ice mode implemented in MPAS-SeaIce can now replace that in CICE in such configurations, but CICE continues to be used for those requiring exceptional computational efficiency.</p>"},{"location":"MPAS-seaice/user-guide/","title":"User's Guide","text":"<p>Guidance for using E3SM is available from E3SM's public web site.</p>"},{"location":"MPAS-seaice/user-guide/#configuring-mpas-seaice","title":"Configuring MPAS-seaice","text":"<p>MPAS-seaice is controlled using namelist options.</p> <ul> <li>Default namelist values are found in <code>E3SM/components/mpas-seaice/bld/namelist_files/namelist_defaults_mpassi.xml</code>.</li> <li>Namelist options are defined in <code>E3SM/components/mpas-seaice/bld/namelist_files/namelist_definitions_mpassi.xml</code>, including type, category (<code>seaice_model</code>), group, valid values and a brief description. Each namelist variable is defined in an <code>entry</code> element.  The content of the element is the documentation of how the variable is used.  Other aspects of the variable's definition are expressed as attributes of the <code>entry</code> element.</li> <li>Some namelist values or combinations are not allowed and will generate warnings and often abort the code.  The consistency checks for using MPAS-seaice within E3SM are in <code>mpas_seaice_initialize</code> (subroutines <code>seaice_check_configs_coupled</code>, <code>seaice_check_constants_coupled</code>), and those specific to Icepack can be found in subroutine <code>check_column_package_configs</code> in <code>mpas_seaice_icepack.F</code>.</li> </ul> <p>Related namelist variables are grouped according to their application.</p> Namelist Groups Relevant application <code>seaice_model</code> general options <code>io</code> input/output <code>decomposition</code> mesh parallelization <code>restart</code> restarting the code <code>dimensions</code> column physics dimensions (layers, categories) <code>initialize</code> initialization <code>use_sections</code> turn entire parameterizations on and off <code>forcing</code> forcing for standalone configurations <code>velocity_solver</code> algorithms for solving the dynamics (velocity and stress) equations <code>advection</code> advection <code>column_package</code> general column package software configurations <code>biogeochemistry</code> biogeochemistry <code>shortwave</code> radiation <code>snow</code> advanced snow physics <code>meltponds</code> melt pond parameterization flags and parameters <code>thermodynamics</code> basic thermodynamics <code>itd</code> ice thickness distribution <code>floesize</code> floe size distribution <code>ridging</code> mechanical redistribution <code>atmosphere</code> atmospheric boundary layer and coupling <code>ocean</code> oceanic boundary layer and coupling <code>diagnostics</code> diagnostic output <code>prescribed_ice</code> for testing atmosphere simulations"},{"location":"MPAS-seaice/user-guide/#icepack","title":"Icepack","text":"<p>The Icepack software has replaced the original <code>colpkg</code> column physics code in MPAS-seaice. The <code>column_package</code> option is still available but is no longer being supported in MPAS-seaice.</p> <p>Full documentation for E3SM's version of Icepack can be found in E3SM's Icepack readthedocs.  The most up-to-date documentation from the CICE Consortium's main Icepack repository is here.</p> <p>The MPAS-seaice driver for Icepack is</p> <p><code>E3SM/components/mpas-seaice/src/shared/mpas_seaice_icepack.f</code></p> <p>and the mapping between the names of Icepack's namelist options and those in MPAS-seaice can be found in subroutine <code>init_icepack_package_configs</code> (see the argument list for <code>call subroutine icepack_init_parameters</code> and comments at the end of <code>init_icepack_package_configs</code>.</p>"},{"location":"MPAS-seaice/user-guide/#configuring-model-input-and-output","title":"Configuring Model Input and Output","text":"<p>The reading and writing of model fields in MPAS is handled by user-configurable streams. A stream represents a fixed set of model fields, together with dimensions and attributes, that are all written or read together to or from the same file or set of files. Each MPAS model core may define its own set of default streams that it typically uses for reading initial conditions, for writing and reading restart fields, and for writing additional model history fields. Besides these default streams, users may define new streams to, e.g., write certain diagnostic fields at a higher temporal frequency than the usual model history fields.</p> <p>Streams are defined in XML configuration files that are created at build time for each model core. The name of this XML file is simply \u2018streams.\u2019 suffixed with the name of the core. For example, the streams for the sw (shallow-water) core are defined in a file named \u2018streams.sw\u2019. An XML stream file may further reference other text files that contain lists of the model fields that are read or written in each of the streams defined in the XML stream file.</p> <p>Changes to the XML stream configuration file will take effect the next time an MPAS core is run; there is no need to re-compile after making modifications to the XML files. As described in the next section, it is therefore possible, e.g., to change the interval at which a stream is written, the template for the filenames associated with a stream, or the set of fields that are written to a stream, without the need to re-compile any code.</p> <p>Two classes of streams exist in MPAS: immutable streams and mutable streams. Immutable streams are those for which the set of fields that belong to the stream may not be modified at model run-time; however, it is possible to modify the interval at which the stream is read or written, the filename template describing the files containing the stream on disk, and several other parameters of the stream. In contrast, all aspects of mutable streams, including the set of fields that belong to the stream, may be modified at run-time. The motivation for the creation of two stream classes is the idea that an MPAS core may not function correctly if certain fields are not read in upon model start-up or written to restart files, and it is therefore not reasonable for users to modify this set of required fields at run-time. An MPAS core developer may choose to implement such streams as immutable streams. Since fields may not be added to an immutable stream at run-time, new immutable streams may not be defined at run-time, and the only type of new stream that may be defined at run-time is the mutable stream type.</p>"}]}