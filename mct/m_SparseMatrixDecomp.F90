!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Math and Computer Science Division, Argonne National Laboratory   !
!BOP -------------------------------------------------------------------
!
! !MODULE: m_SparseMatrixDecomp -- Parallel sparse matrix decomposition.
!
! !DESCRIPTION:
! The {\tt SparseMatrix} datatype provides sparse matrix storage for 
! the parallel matrix-vector multiplication ${\bf y} = {\bf M} {\bf x}$.
! This module provides services to create decompositions for the 
! {\tt SparseMatrix}.  The matrix decompositions available are row 
! and column decompositions.  They are generated by invoking the 
! appropriate routine in this module, and passing the corresponding 
! {\em vector} decomposition.  For a row (column) decomposition, one 
! invokes the routine {\tt ByRow()} ({\tt ByColumn()}), passing the 
! domain decomposition for the vector {\bf y} ({\bf x}).
!
! !INTERFACE:

 module m_SparseMatrixDecomp

      private   ! except

! !PUBLIC MEMBER FUNCTIONS:
!
      public :: ByColumn
      public :: ByRow


    interface ByColumn ; module procedure &
         ByColumnGSMap_
    end interface

    interface ByRow ; module procedure &
         ByRowGSMap_
    end interface

! !REVISION HISTORY:
!       13Apr01 - J.W. Larson <larson@mcs.anl.gov> - initial prototype
!                 and API specifications.
!EOP ___________________________________________________________________

  character(len=*),parameter :: myname='m_SparseMatrixDecomp'

 contains

!-------------------------------------------------------------------------
!     Math + Computer Science Division / Argonne National Laboratory     !
!-------------------------------------------------------------------------
!BOP
!
! !ROUTINE:  ByColumnGSMap_()--Generate Row-based GlobalSegMap for SparseMatrix
! 
! !INTERFACE:

 subroutine ByColumnGSMap_(xGSMap, sMat, sMGSMap)
!
! !USES:
!
   use m_List, only: List
   use m_List, only: List_init => init
   use m_List, only: List_clean => clean

   use m_GlobalSegMap, only: GlobalSegMap
   use m_GlobalSegMap, only: GlobalSegMap_comp_id => comp_id
   use m_GlobalSegMap, only: GlobalSegMap_gsize => gsize
   use m_GlobalSegMap, only: GlobalSegMap_ngseg => ngseg

   use m_SparseMatrix, only: SparseMatrix

   use m_SparseMatrix, only: SparseMatrix_lsize => lsize
   use m_SparseMatrix, only: SparseMatrix_indexIA => indexIA
   use m_SparseMatrix, only: SparseMatrix_SortPermute => SortPermute

   implicit none

! !INPUT PARAMETERS: 
!
   type(GlobalSegMap), intent(in)    :: xGSMap
   type(SparseMatrix), intent(inout) :: sMat

! !OUTPUT PARAMETERS:
!
   type(GlobalSegMap), intent(out)   :: sMGSMap

! !DESCRIPTION: This routine is invoked from the root to compare 
! the global row index entries of an input {\tt SparseMatrix} argument 
! {\tt sMat} with the {\bf x}-vector decomposition stored in the 
! {\tt GlobalSegMap} argument {\tt xGSMap}, and compute the appropriate
! output {\tt GlobalSegMap} variable {\tt sMGSMap} that can be used to
! decompose the matrix {\tt sMat} by column.
!
! {\bf N.B.}:  The argument {\tt sMat} is returned sorted in lexicographic 
! order by column and row.
!
! !REVISION HISTORY: 
!
!       13Apr01 - J.W. Larson <larson@mcs.anl.gov> - initial API spec.

!EOP
!-------------------------------------------------------------------------

  character(len=*),parameter :: myname_=myname//'ByColumnGSMap_'

  integer :: gsize, comp_id, ngseg
! Temporary array for identifying each matrix element column and 
! process ID destination
  integer, dimension(:), allocatable :: gCol, element_pe_locs 
! Index to identify the gcol attribute in sMat:
  integer :: igCol
! Temporary arrays for matrix GlobalSegMap attributes
  integer, dimension(:), allocatable :: starts, lengths, pe_locs
! List storage for sorting keys
  type(List) :: sort_keys
! Error flag
  integer :: ierr
! Loop index
  integer :: i

       ! The global size of matrix GlobalSegMap is the number nonzero
       ! elements in sMat.  

  gsize = SparseMatrix_lsize(sMat)

       ! The matrix GlobalSegMap inherits the component ID from xGSMap:

  comp_id = GlobalSegMap_comp_id(xGSMap)
   
       ! Sort the matrix entries in sMat by column, then row.  First,
       ! create the key list...

  call List_init(sort_keys,'gcol:grow')

       ! Now perform the sort/permute...

  call SparseMatrix_SortPermute(sMat, sort_keys)

       ! Allocate storage space for matrix element column indices and
       ! process ID destinations

  allocate(gCol(gsize), element_pe_locs(gsize), stat=ierr)

  if(ierr /= 0) then
     call MP_perr_die(myname_,'allocate(gCol...',ierr)
  endif

       ! Extract global column information and place in array gCol

  igCol = SparseMatrix_indexIA(sMat,'gcol')

  do i=1, gsize
     gCol(i) = sMat%data%iAttr(igCol,i)
  end do

       ! Compute process ID destination for each matrix element,
       ! and store in the array element_pe_locs

  call GlobalSegMap_peLocs(xGSMap, gCol, element_pe_locs)

       ! Using the entries of gCol and element_pe_locs, build the
       ! output GlobalSegMap attribute arrays starts(:), lengths(:),
       ! and pe_locs(:)

  call ComputeSegments(element_pe_locs, gCol, gsize, ngseg, starts, &
                       lengths, pe_locs)

       ! Using this local data, create the SparseMatrix GlobalSegMap sMGSMap:

  call GlobalSegMap_init(sMGSMap, comp_id, ngseg, gsize, starts, &
                         lengths, pe_locs)

       ! Clean up

  deallocate(starts, lengths, pe_locs, stat=ierr)

  if(ierr /= 0) then
     call MP_perr_die(myname_,'deallocate(starts...',ierr)
  endif

 end subroutine ByColumnGSMap_

!-------------------------------------------------------------------------
!     Math + Computer Science Division / Argonne National Laboratory     !
!-------------------------------------------------------------------------
!BOP
!
! !ROUTINE:  ByRowGSMap_()--Generate Row-based GlobalSegMap for SparseMatrix
! 
! !INTERFACE:

 subroutine ByRowGSMap_(yGSMap, sMat, sMGSMap)
!
! !USES:
!

   use m_die,  only: MP_perr_die

   use m_List, only: List
   use m_List, only: List_init => init
   use m_List, only: List_clean => clean

   use m_GlobalSegMap, only: GlobalSegMap
   use m_GlobalSegMap, only: GlobalSegMap_comp_id => comp_id
   use m_GlobalSegMap, only: GlobalSegMap_gsize => gsize
   use m_GlobalSegMap, only: GlobalSegMap_ngseg => ngseg

   use m_SparseMatrix, only: SparseMatrix

   use m_SparseMatrix, only: SparseMatrix_lsize => lsize
   use m_SparseMatrix, only: SparseMatrix_indexIA => indexIA
   use m_SparseMatrix, only: SparseMatrix_SortPermute => SortPermute

   implicit none

! !INPUT PARAMETERS: 
!
   type(GlobalSegMap), intent(in)    :: yGSMap
   type(SparseMatrix), intent(inout) :: sMat

! !OUTPUT PARAMETERS:
!
   type(GlobalSegMap), intent(out) :: sMGSMap

! !DESCRIPTION: This routine is invoked from the root to compare 
! the global row index entries of an input {\tt SparseMatrix} argument 
! {\tt sMat} with the {\bf y}-vector decomposition stored in the 
! {\tt GlobalSegMap} argument {\tt yGSMap}, and compute the appropriate
! output {\tt GlobalSegMap} variable {\tt sMGSMap} that can be used to
! decompose the matrix {\tt sMat} by row.
!
! {\bf N.B.}:  The argument {\tt sMat} is returned sorted in lexicographic 
! order by row and column.
!
! !REVISION HISTORY: 
!
!       13Apr01 - J.W. Larson <larson@mcs.anl.gov> - initial API spec.

!EOP
!-------------------------------------------------------------------------

  character(len=*),parameter :: myname_=myname//'ByRowGSMap_'

  integer :: gsize, comp_id, ngseg
! Temporary array for identifying each matrix element row and 
! process ID destination
  integer, dimension(:), allocatable :: gRow, element_pe_locs 
! Index to identify the grow attribute in sMat:
  integer :: igRow
! Temporary arrays for matrix GlobalSegMap attributes
  integer, dimension(:), allocatable :: starts, lengths, pe_locs
! List storage for sorting keys
  type(List) :: sort_keys
! Error flag
  integer :: ierr
! Loop index
  integer :: i

       ! The global size of matrix GlobalSegMap is the number of rows.  

  gsize = SparseMatrix_lsize(sMat)

       ! The matrix GlobalSegMap inherits the component ID from yGSMap:

  comp_id = GlobalSegMap_comp_id(yGSMap)
   
       ! Sort the matrix entries in sMat by row, then column.  First,
       ! create the key list...

  call List_init(sort_keys,'grow:gcol')

       ! Now perform the sort/permute...

  call SparseMatrix_SortPermute(sMat, sort_keys)

       ! Allocate storage space for matrix element row indices and
       ! process ID destinations

  allocate(gRow(gsize), element_pe_locs(gsize), stat=ierr)

  if(ierr /= 0) then
     call MP_perr_die(myname_,'allocate(gRow...',ierr)
  endif

       ! Extract global row information and place in array gRow

  igRow = SparseMatrix_indexIA(sMat,'grow')

  do i=1, gsize
     gRow(i) = sMat%data%iAttr(igRow,i)
  end do

       ! Compute process ID destination for each matrix element,
       ! and store in the array element_pe_locs

  call GlobalSegMap_peLocs(yGSMap, gRow, element_pe_locs)

       ! Using the entries of gRow and element_pe_locs, build the
       ! output GlobalSegMap attribute arrays starts(:), lengths(:),
       ! and pe_locs(:)

  call ComputeSegments(element_pe_locs, gRow, gsize, ngseg, starts, &
                       lengths, pe_locs)

       ! Using this local data, create the SparseMatrix GlobalSegMap sMGSMap:

  call GlobalSegMap_init(sMGSMap, comp_id, ngseg, gsize, starts, lengths, pe_locs)

       ! Clean up

  deallocate(starts, lengths, pe_locs, stat=ierr)

  if(ierr /= 0) then
     call MP_perr_die(myname_,'deallocate(starts...',ierr)
  endif

 end subroutine ByRowGSMap_

!-------------------------------------------------------------------------
!     Math + Computer Science Division / Argonne National Laboratory     !
!-------------------------------------------------------------------------
!BOP
!
! !ROUTINE:  ComputeSegments_()--Create segments from list data.
! 
! !INTERFACE:

 subroutine ComputeSegments_(element_pe_locs, elements, num_elements, &
                             nsegs, seg_starts, seg_lengths, seg_pe_locs)
!
! !USES:
!

   use m_die,  only: MP_perr_die

   implicit none

! !INPUT PARAMETERS: 
!
   integer, dimension(:), intent(in)  :: element_pe_locs
   integer, dimension(:), intent(in)  :: elements
   integer,               intent(in)  :: num_elements

! !OUTPUT PARAMETERS:
!
   integer,               intent(out) :: nsegs
   integer, dimension(:), pointer     :: seg_starts
   integer, dimension(:), pointer     :: seg_lengths
   integer, dimension(:), pointer     :: seg_pe_locs

! !DESCRIPTION: This routine examins an input list of {\tt num\_elements} 
! process ID locations stored in the array {\tt element\_pe\_locs}, counts
! the number of contiguous segments {\tt nsegs}, and returns the segment 
! start index, length, and process ID location in the arrays {\tt seg\_starts(:)},
! {\tt seg\_lengths(:)}, and {\tt seg\_pe\_locs(:)}, respectively.
!
! {\bf N.B.}:  The argument {\tt sMat} is returned sorted in lexicographic 
! order by row and column.
!
! !REVISION HISTORY: 
!
!       18Apr01 - J.W. Larson <larson@mcs.anl.gov> - initial version.

!EOP
!-------------------------------------------------------------------------
  character(len=*),parameter :: myname_=myname//'ComputeSegments_'

  integer :: i, ierr, iseg

       ! Input argument sanity checks:

  if(size(elements) < num_elements) then
     call MP_perr_die(myname_,'input argument array element_pe_locs too small', &
	  num_elements-size(element_pe_locs))
  endif

  if(size(elements) < num_elements) then
     call MP_perr_die(myname_,'input argument array elements too small', &
	  num_elements-size(elements))
  endif

       ! First pass:  how many segments?

  do i=1,num_elements

     if(i == 1) then ! bootstrap segment count

	nsegs = 1

     else ! usual point/segment processing

       ! New segment?  If so, increment nsegs.

	if((elements(i) > elements(i-1) + 1) .or. &
	     (element_pe_locs(i) /= element_pe_locs(i-1))) then ! new segment
	   nsegs = nsegs + 1
	endif

     endif ! if(i == 1) block

  end do  ! do i=1,num_elements

  allocate(seg_starts(nsegs), seg_lengths(nsegs), seg_pe_locs(nsegs), &
           stat=ierr)

  if(ierr /= 0) then
     call MP_perr_die(myname_,'allocate(seg_starts...',ierr)
  endif

       ! Second pass:  fill in segment data.

  do i=1,num_elements

     if(i == 1) then  ! bootstrap first segment info.

	iseg = 1
	seg_starts(iseg) = 1
	seg_lengths(iseg) = 1
	seg_pe_locs(iseg) = element_pe_locs(iseg)

     else ! do usual point/segment processing

       ! New segment?  This happens if 1) elements(i) > elements(i-1) + 1, or
       ! 2) element_pe_locs(i) /= element_pe_locs(i-1).

	if((elements(i) > elements(i-1) + 1) .or. &
	     (element_pe_locs(i) /= element_pe_locs(i-1))) then ! new segment

       ! Initialize new segment

	   iseg = iseg + 1
	   seg_starts(iseg) = i
	   seg_lengths(iseg) = 1
	   seg_pe_locs(iseg) = element_pe_locs(i)

	else

       ! Increment current segment length

	   seg_lengths(iseg) = seg_lengths(iseg) + 1

	endif ! If new segment block

     endif ! if(i == 1) block

  end do ! do i=1,num_elements

  if(iseg /= nsegs) then
     call MP_perr_die(myname_,'segment number difference',iseg-nsegs)
  endif

 end subroutine ComputeSegments_

 end module m_SparseMatrixDecomp
