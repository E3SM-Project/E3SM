<chapter id="running_ccsm">
<title>Running CESM</title>

<para> To run a &cesm; case, you must submit the batch script
<filename>$CASE.run</filename>. In addition, you also need to
modify &env_run.xml; for your particular needs. </para>

<para> The <ulink url="../modelnl/env_run.html">&env_run.xml;
file</ulink> contains variables which may be modified at the
initialization of a model run and during the course of that model run.
These variables comprise coupler namelist settings for the model stop
time, model restart frequency, coupler history frequency and a flag to
determine if the run should be flagged as a continuation run. In
general, you only need to set the variables
$<envar>STOP_OPTION</envar> and $<envar>STOP_N</envar>. The other
coupler settings will then be given consistent and reasonable default
values. These default settings guarantee that restart files are
produced at the end of the model run. </para>

<!-- ======================================================================= -->
<sect1 id="running_ccsm_runtime">
<title>Customizing runtime settings</title>

<para>
In the following, we focus on the handling of run control
(e.g. length of run, continuing a run) and output
data. We also give a more detailed description of &cesm; restarts.
</para>

<!-- ======================================================================= -->
<sect2 id="run_start_stop">
<title>Controlling starting, stopping and restarting a run</title>

<para> The case initialization type is set in &env_run.xml;. A &cesm;
run can be initialized in one of three ways; startup, branch, or
hybrid.
</para>

<variablelist>

<varlistentry><term>startup</term>
<listitem> <para> In a startup run (the default), all components are
initialized using baseline states. These baseline states are set
independently by each component and can include the use of restart
files, initial files, external observed data files, or internal
initialization (i.e., a "cold start"). In a startup run, the coupler
sends the start date to the components at initialization. In addition,
the coupler does not need an input data file.  In a startup initialization, the
ocean model does not start until the second ocean coupling (normally
the second day).
</para>
</listitem>
</varlistentry>

<varlistentry><term>branch</term>
<listitem>
<para>
In a branch run, all components are initialized using a
consistent set of restart files from a previous run (determined by
the $<envar>RUN_REFCASE</envar> and $<envar>RUN_REFDATE</envar> variables in &env_run.xml;).
The case name is generally changed for a branch run, although it does
not have to be. In a branch run, setting $<envar>RUN_STARTDATE</envar>
is ignored because the model components obtain the
start date from their restart datasets. Therefore, the start date
cannot be changed for a branch run. This is the same mechanism that is
used for performing a restart run (where $<envar>CONTINUE_RUN</envar>
is set to TRUE in the &env_run.xml; file).</para>
<para>
Branch runs are typically used when sensitivity or parameter
studies are required, or when settings for history file output streams
need to be modified while still maintaining bit-for-bit
reproducibility. Under this scenario, the new case is able to produce
an exact bit-for-bit restart in the same manner as a continuation run
<emphasis>if</emphasis> no source code or component namelist inputs
are modified. All models use restart files to perform this type of
run. $<envar>RUN_REFCASE</envar> and $<envar>RUN_REFDATE</envar> are
required for branch runs.</para>
<para>
To set up a branch run, locate the restart tar file or restart
directory for $<envar>RUN_REFCASE</envar> and $<envar>RUN_REFDATE</envar>
from a previous run, then place those
files in the $<envar>RUNDIR</envar> directory. See <link
linkend="use_case_branch">setting up a branch run</link> for an
example.</para>
</listitem>
</varlistentry>

<varlistentry><term>hybrid</term>
<listitem>
<para> A hybrid run indicates that &cesm; is initialized more like
a startup, but uses initialization datasets <emphasis>from a previous
case</emphasis>. This is somewhat analogous to a branch run with relaxed
restart constraints.  A hybrid run allows users to bring together
combinations of initial/restart files from a previous case
(specified by $<envar>RUN_REFCASE</envar>) at a given model output
date (specified by $<envar>RUN_REFDATE</envar>). Unlike a branch
run, the starting date of a hybrid run (specified by
$<envar>RUN_STARTDATE</envar>) can be modified relative to the
reference case. In a hybrid run, the model does not continue in a
bit-for-bit fashion with respect to the reference case. The resulting
climate, however, should be continuous provided that no model source
code or namelists are changed in the hybrid run.
In a hybrid initialization, the
ocean model does not start until the second ocean coupling (normally
the second day), and the coupler does a "cold start" without a restart file.
</para>
</listitem>
</varlistentry>

</variablelist>

<para>
The variable <envar>$RUN_TYPE</envar> determines the initialization
type. This setting is only important for the initial run of a
production run when the <envar>$CONTINUE_RUN</envar> variable is set
to FALSE.  After the initial run, the <envar>$CONTINUE_RUN</envar>
variable is set to TRUE, and the model restarts exactly using input
files in a case, date, and bit-for-bit continuous fashion.  The
variable <envar>$RUN_TYPE</envar> is the start date (in yyyy-mm-dd
format) either a startup or hybrid run.  If the run is targeted to be a
hybrid or branch run, you must also specify values for
<envar>$RUN_REFCASE</envar> and <envar>$RUN_REFDATE</envar>. All run
startup variables are discussed in <ulink
url="../modelnl/env_run.html#run_start"> run start control
variables</ulink>.
</para>

<para>
Before a job is submitted to the batch system, you need to first
check that the batch submission lines in
<filename>$CASE.run</filename> are appropriate. These lines
should be checked and modified accordingly for appropriate account
numbers, time limits, and stdout/stderr file names.  You should
then modify &env_run.xml; to determine the key run-time settings.  See
<ulink url="../modelnl/env_run.html#run_stop">controlling run termination</ulink>,
<ulink url="../modelnl/env_run.html#run_rest">controlling run restarts</ulink>, and
<link linkend="running_ccsm_restarts">performing model restarts </link> for more details.
A brief note on restarting runs. When you first begin a branch, hybrid
or startup run, CONTINUE_RUN must be set to FALSE. When you
successfully run and get a restart file, you will need to change
CONTINUE_RUN to TRUE for the remainder of your
run. See <link linkend="running_ccsm_restarts"> performing model
restarts </link> for more details.
</para>

<para>
By default,
<screen>
STOP_OPTION = ndays
STOP_N = 5
STOP_DATE = -999
</screen>
</para>

<para>
The default setting is only appropriate for initial testing. Before a
longer run is started, update the stop times based on the case
throughput and batch queue limits.  For  example, if the model runs 5
model years/day, set <envar>RESUBMIT</envar>=30, <envar>STOP_OPTION</envar>= nyears,
and <envar>STOP_N</envar>= 5.
The model will then run in five year increments, and stop after 30
submissions.
</para>

</sect2>

<!-- ======================================================================= -->
<sect2 id="customizing_components">
<title>Customizing component-specific namelist settings </title>

<para> In your $&CASEROOT; directory, the subdirectory
<filename>$CASEROOT/Buildconf</filename> contains files to create the
component namelists, build the component libraries and create the
model executable.
<filename>Buildconf/$component.buildexe.csh</filename> creates the
component libraries and
<filename>Buildconf/$component.buildnml.csh</filename> creates the
component namelists.  A new feature in the CESM1.1 and CESM1.2 release
series is that <emphasis>ALL</emphasis> CESM components now use a
component-specific <command>build-namelist</command> utility (similar
to that of CAM, CLM and CICE in the CESM1.0 series) to generate their
respective model namelists. In addition, CAM, CLM and CICE have an
associated <command>configure</command> utility that sets up compile
time configuration options and is also called from the corresponding
Buildconf/*.buildnml.csh (e.g. Buildconf/cam.buildnml.csh).</para>

<para>
<command>In the CESM1.2 series, user specific component namelist
changes should only be made only by editing the
<filename>$CASEROOT/user_nl_xxx</filename> files OR by
changing xml variables in <ulink
url="../modelnl/env_run.html">env_run.xml</ulink> or <ulink
url="../modelnl/env_build.html">env_build.xml</ulink></command>.  A full
discussion of how to change the namelist variables for each component
is provided below.  You can preview the case component namelists by
running <filename>preview_namelists</filename> in your $&CASEROOT;.
Calling <filename>preview_namelists</filename> results in the creation
of component namelists (e.g. atm_in, lnd_in, .etc) in
<filename>$CASEROOT/CaseDocs/</filename>. A complete documentation of
all <ulink url="../modelnl/modelnl.html">model component namelists
</ulink> for CESM1.2 releases is now available.  The namelist files
created in the <filename>CaseDocs/</filename> are there only for user
reference and <emphasis>SHOULD NOT BE EDITED</emphasis> since they are
overwritten every time <filename>preview_namelists</filename>,
<filename>$CASE.run</filename> and <filename>$CASE.build</filename>
are called. In CESM1.2, (like CESM1.1 but unlike CESM1.0) the only
files that you should modify are in $&CASEROOT;. No files in
Buildconf/ should be changed. The following represents a summary of
controlling and modifying component-specific run-time settings:
</para>

<variablelist>

<varlistentry>
<term>DRV</term>
<listitem>
<para>
In CESM1.2, <ulink url="../modelnl/nl_drv.html">driver
namelist</ulink> are in two groups - those that are set directly from
xml variables in <ulink
url="../modelnl/env_case.html">env_case.xml</ulink>, <ulink
url="../modelnl/env_mach_pes.html">env_mach_pes.xml</ulink> and <ulink
url="../modelnl/env_run.html">env_run.xml</ulink>, and those that are
set by the driver build-namelist utility
(<filename>$CIMEROOT/driver_cpl/bld/build-namelist</filename>) for the
target compset and resolution.  Except for the following driver
namelist variables (see below), driver namelist variables that are in
<filename>env_run.xml</filename> can be changed either by changing the
xml variable OR by adding the correct key-word value pair at the end
of <filename>user_nl_cpl</filename>, where any changes in
<filename>user_nl_cpl</filename> <emphasis> will take
precedence</emphasis> over values set in the xml file.  For example,
to change eps_frac to 1.0e-15, add the following line to the end of
the <filename>user_nl_cpl</filename>, "eps_frac = 1.0e-15".  To see
the result of this modification to <filename>user_nl_cpl</filename>
call <filename>preview_namelists</filename> and verify that this new
value appears in <filename>CaseDocs/drv_in</filename>. </para>
<screen>
The following namelist variables MAY NOT be changed in user_nl_cpl -
but must be changed in the appropriate $CASEROOT xml file.
XXX  refers to ATM,LND,ICE,OCN,ROF,GLC,WAV
======================================
drv namelist   => xml variable
variable
======================================
case_name      => CASE
username       => CCSMUSER
hostname       => MACH
model_version  => CCSM_REPOTAG
start_type     => RUN_TYPE
start_ymd      => RUN_STARTDATE
start_tod      => START_TOD
XXX_cpl_dt     => XXX_NCPL
XXX_ntasks     => NTASKS_XXX
XXX_nthreads   => NTHRDS_XXX
XXX_rootpe     => ROOTPE_XXX
XXX_pestride   => PSTRID_XXX
XXX_layout     => NINST_XXX_LAYOUT
</screen>
<para></para>
</listitem>
</varlistentry>

<varlistentry>
<term>CAM</term>
<listitem>
<para>
CAM's <ulink
url="http://www.cesm.ucar.edu/models/cesm1.1/cam/docs/ug5_2/book1.html">configure
</ulink> and <ulink
url="http://www.cesm.ucar.edu/models/cesm1.1/cam/docs/ug5_2/book1.html">build-namelist
</ulink> utilities are called by
<filename>Buildconf/cam.buildnml.csh</filename>.  <ulink
url="../modelnl/env_build.html#build_cam">CAM_CONFIG_OPTS</ulink>,
<ulink url="../modelnl/env_run.html#run_cam">CAM_NAMELIST_OPTS</ulink>
and <ulink
url="../modelnl/env_run.html#run_cam">CAM_NML_USECASE</ulink> are
used to set compset variables (e.g., "-phys cam5" for CAM_CONFIG_OPTS)
and in general should not be modified for supported compsets.  For a
complete documentation of namelist settings, see <ulink
url="../modelnl/nl_cam.html">CAM namelist variables</ulink>.  To
modify CAM namelist settings, you should add the appropriate
keyword/value pair at the end of the
<filename>$CASEROOT/user_nl_cam</filename> file (see the documentation
for each file at the top of that file).  For example, to change the
solar constant to 1363.27, modify the user_nl_cam file to contain the
following line at the end "solar_const=1363.27".  To see the result of
adding this, call <command>preview_namelists</command> and verify
that this new value appears in <filename>CaseDocs/atm_in</filename>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>CLM</term>
<listitem>
<para>
CLM's <ulink
url="http://www.cesm.ucar.edu/models/cesm1.0/clm/models/lnd/clm/doc/UsersGuide/book1.html">
configure</ulink> and <ulink
url="http://www.cesm.ucar.edu/models/cesm1.0/clm/models/lnd/clm/doc/UsersGuide/book1.html">
build-namelist</ulink> utilities are called by
<filename>Buildconf/clm.buildnml.csh</filename>.  <ulink
url="../modelnl/env_build.html#build_clm">CLM_CONFIG_OPTS</ulink> and
<ulink url="../modelnl/env_run.html#run_clm">CLM_NML_USE_CASE</ulink>
are used to set compset specific variables and in general should not
be modified for supported compsets.  For a complete documentation of
namelist settings, see <ulink url="../modelnl/nl_clm.html">CLM
namelist variables</ulink>.  To modify CLM namelist settings, you
should add the appropriate keyword/value pair at the end of the
<filename>$CASEROOT/user_nl_clm</filename> file (see the documentation
for each file at the top of that file).  To see the result of your
change, call <command>preview_namelists</command> and verify that the
changes appear correctly in <filename>CaseDocs/lnd_in</filename>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>RTM</term>
<listitem>
<para>
RTM's <command>build-namelist</command> utility is called by
<filename>Buildconf/rtm.buildnml.csh</filename>.
For a complete documentation of namelist
settings, see <ulink url="../modelnl/nl_rtm.html">RTM namelist
variables</ulink>.  To modify RTM namelist settings, you should add
the appropriate keyword/value pair at the end of the
<filename>$CASEROOT/user_nl_rtm</filename> file (see the documentation for each
file at the top of that file).  To see the result of your change, call
<command>preview_namelists</command> and verify that the changes
appear correctly in <filename>CaseDocs/rof_in</filename>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>CICE</term>
<listitem>
<para>
CICE's <ulink
url="http://www.cesm.ucar.edu/models/cesm1.1/cice/doc/index.html">
configure</ulink> and
<ulink url="http://www.cesm.ucar.edu/models/cesm1.1/cice/doc/index.html">
build-namelist</ulink> utilities are now called by
<filename>Buildconf/cice.buildnml.csh</filename>.  Note that <ulink
url="../modelnl/env_build.html#build_cice">CICE_CONFIG_OPTS</ulink>,
and <ulink
url="../modelnl/env_run.html#run_cice">CICE_NAMELIST_OPTS</ulink> are
used to set compset specific variables and in
general should not be modified for supported compsets.
For a complete documentation of namelist
settings, see <ulink url="../modelnl/nl_cice.html">CICE namelist
variables</ulink>.  To modify CICE namelist settings, you should add
the appropriate keyword/value pair at the end of the
<filename>$CASEROOT/user_nl_cice</filename> file (see the documentation for each
file at the top of that file).  To see the result of your change, call
<command>preview_namelists</command> and verify that the changes appear
correctly in <filename>CaseDocs/ice_in</filename>.
</para>
<para>
In addition, <command>cesm_setup</command> creates CICE's compile time
<ulink url="../modelnl/env_build.html#build_cice">block decomposition variables</ulink>
in &env_build.xml; as follows:
<screen>
  ./cesm_setup
     &dArr;
  Buildconf/cice.buildnml.csh and $NTASKS_ICE and $NTHRDS_ICE
     &dArr;
  env_build.xml variables CICE_BLCKX, CICE_BLCKY, CICE_MXBLCKS, CICE_DECOMPTYPE
  CPP variables in cice.buildexe.csh
</screen>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>POP2</term>
<listitem>
<para>
See <ulink url="../modelnl/nl_pop2.html">POP2 namelist
variables</ulink> for a complete description of the POP2 run-time
namelist variables.  Note that <ulink
url="../modelnl/env_run.html#run_pop">OCN_COUPLING, OCN_ICE_FORCING,
OCN_TRANSIENT</ulink> are normally utilized ONLY to set compset
specific variables and should not be edited.  For a complete
documentation of namelist settings, see <ulink
url="../modelnl/nl_cice.html">CICE namelist variables</ulink>.  To
modify POP2 namelist settings, you should add the appropriate
keyword/value pair at the end of the
<filename>$CASEROOT/user_nl_pop2</filename> file (see the
documentation for each file at the top of that file).  To see the
result of your change, call <command>preview_namelists</command> and
verify that the changes appear correctly in
<filename>CaseDocs/ocn_in</filename>.
</para>
<para>
In addition, <command>cesm_setup</command>
also generates POP2's compile time compile time <ulink
url="../modelnl/env_build.html#build_pop2">block decomposition
variables</ulink> in &env_build.xml; as follows:
<screen>
  ./cesm_setup
     &dArr;
  Buildconf/pop2.buildnml.csh and $NTASKS_OCN and $NTHRDS_OCN
     &dArr;
  env_build.xml variables POP2_BLCKX, POP2_BLCKY, POP2_MXBLCKS, POP2_DECOMPTYPE
  CPP variables in pop2.buildexe.csh
</screen>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>CISM</term>
<listitem>
<para>
See <ulink url="../modelnl/nl_cism.html">CISM namelist
variables</ulink> for a complete description of the CISM run-time
namelist variables. This includes variables that appear both in
<filename>cism_in</filename> and in
<filename>cism.config</filename>. To modify any of these settings, you
should add the appropriate keyword/value pair at the end of the
<filename>user_nl_cism</filename> file (see the documentation for each
file at the top of that file). To see the result of your change, call
<command>preview_namelists</command> and verify that the changes
appear correctly in <filename>CaseDocs/cism_in</filename> and
<filename>CaseDocs/cism.config</filename>.
</para>
<para>
There are also some run-time settings set via
<filename>env_run.xml</filename>, as documented in <ulink
url="../modelnl/env_run.html#run_cism">CISM run time variables</ulink>
- in particular, the model resolution, set via
<envar>CISM_GRID</envar>. The value of <envar>CISM_GRID</envar>
determines the default value of a number of other namelist parameters.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>DATM </term>
<listitem>
<para>
DATM is discussed in detail in <ulink
url="http://www.cesm.ucar.edu/models/cesm1.1/data8/doc/book1.html">Data
Model's User's Guide</ulink>. DATM is normally used to provide
observational forcing data (or forcing data produced by a previous run
using active components) to drive CLM (I compset), POP2 (C compset),
and POP2/CICE (G compset). As a result, DATM variable settings are
specific to the compset that will be targeted.  </para>
<para>
DATM can be user
configured in three different ways.
</para>
<para>
You can set <ulink url="../modelnl/env_run.html#run_datm">DATM
run-time variables</ulink> my modifying control settings for CLM and
CPLHIST forcing.
</para>
<para> You can edit <filename>user_nl_datm</filename> to change
namelist settings namelists settings by adding all user specific
namelist changes in the form of "namelist_var =
new_namelist_value". Note that any namelist variable from
shr_strdata_nml and datm_nml can be modified below using the this
syntax. Use <command>preview_namelists</command> to view (not modify)
the output namelist in <filename>CaseDocs</filename>.
</para>
<para>
You can modify the contents of a DATM stream txt file. To do this:
<itemizedlist>
<listitem><para>
use <command>preview_namelists</command> to obtain the contents of the
stream txt files in <filename>CaseDocs</filename>
</para></listitem>
<listitem><para>
place a <emphasis>copy</emphasis> of this file in $CASEROOT
with the string <emphasis>"user_"</emphasis> prepended
</para></listitem>
<listitem><para>
<command>Make sure you change the permissions of the file to be
writeable</command> (chmod 644)
</para></listitem>
<listitem><para>
Modify the <filename>user_datm.streams.txt.*</filename> file.
</para></listitem>
</itemizedlist>
As an example, if the stream txt file in <filename>CaseDocs/</filename>
is <filename>datm.streams.txt.CORE2_NYF.GISS</filename>, the modified
copy in $&CASEROOT; should be
<filename>user_datm.streams.txt.CORE2_NYF.GISS</filename>. After
calling <command>preview_namelists</command> again, you should see your new
modifications appear in
<filename>CaseDocs/datm.streams.txt.CORE2_NYF.GISS</filename>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>DOCN</term>
<listitem>
<para> DOCN is discussed in detail in
<ulink url="http://www.cesm.ucar.edu/models/cesm1.1/data8/doc/book1.html">Data
Model's User's Guide</ulink>. </para>
<para>
DOCN running in prescribed mode assumes that the only field in the
input stream is SST and also that SST is in Celsius and must be
converted to Kelvin.  All other fields are set to zero except for
ocean salinity, which is set to a constant reference salinity value.
Normally the ice fraction data (used for prescribed CICE) is found in
the same data files that provide SST data to the data ocean model
since SST and ice fraction data are derived from the same
observational data sets and are consistent with each other.  For DOCN
prescribed mode, default yearly climatological datasets are provided
for various model resolutions. For multi-year runs requiring AMIP
datasets of sst/ice_cov fields, you need to set the variables for
<ulink
url="../modelnl/env_run.html#run_sstice"><envar>DOCN_SSTDATA_FILENAME</envar>,
<envar>DOCN_SSTDATA_YEAR_START</envar>, and
<envar>DOCN_SSTDATA_YEAR_END</envar></ulink>. CICE in prescribed mode
also uses these values.
</para>
<para>
DOCN running as a slab ocean model is used (in conjunction with CICE
running in prognostic mode) in all <link
linkend="ccsm_component_sets">E compsets</link>.  SOM ("slab ocean
model") mode is a prognostic mode.  This mode computes a prognostic
sea surface temperature and a freeze/melt potential (surface Q-flux)
used by the sea ice model.  This calculation requires an external SOM
forcing data file that includes ocean mixed layer depths and
bottom-of-the-slab Q-fluxes.  Scientifically appropriate
bottom-of-the-slab Q-fluxes are normally ocean resolution dependent
and are derived from the ocean model output of a fully coupled run.
Note that while this mode runs out of the box, the default SOM forcing
file is not scientifically appropriate and is provided for testing and
development purposes only.  Users must create scientifically
appropriate data for their particular application.  A tool is
available to derive valid SOM forcing.
</para>
<para>
DOCN can be user-customized in three ways.
</para>
<para>
You can set <ulink url="../modelnl/env_run.html#run_docn">DOCN
run-time variables</ulink>.
</para>
<para> You can edit <filename>user_nl_docn</filename> to change
namelist settings by adding all user specific
namelist changes in the form of "namelist_var =
new_namelist_value". Note that any namelist variable from
shr_strdata_nml and datm_nml can be modified below using the this
syntax. Use <command>preview_namelists</command> to view (not modify)
the output namelist in <filename>CaseDocs</filename>.
</para>
<para>
You can modify the contents of a DOCN stream txt file. To do this:
<itemizedlist>
<listitem><para>
use <command>preview_namelists</command> to obtain the contents of the
stream txt files in <filename>CaseDocs/</filename>
</para></listitem>
<listitem><para>
place a <emphasis>copy</emphasis> of this file in $CASEROOT
with the string <emphasis>"user_"</emphasis> prepended
</para></listitem>
<listitem><para>
<command>Make sure you change the permissions of the file to be
writeable</command> (chmod 644)
</para></listitem>
<listitem><para>
Modify the <filename>user_docn.streams.txt.*</filename> file.
</para></listitem>
</itemizedlist>
As an example, if the stream text file in
<filename>CaseDocs/</filename> is <filename>
doc.stream.txt.prescribed</filename>, the modified copy in $&CASEROOT;
should be <filename>user_docn.streams.txt.prescribed</filename>. After
changing this file and calling <command>preview_namelists</command>
again, you should see your new modifications appear in
<filename>CaseDocs/docn.streams.txt.prescribed</filename>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>DICE </term>
<listitem>
<para> DICE is discussed in detail in
<ulink url="http://www.cesm.ucar.edu/models/cesm1.1/data8/doc/book1.html">Data Model's User's Guide</ulink>. </para>
<para>
DICE can be user-customized in three ways.
</para>
<para>
You can set <ulink url="../modelnl/env_run.html#run_dice">DICE
run-time variables</ulink>.
</para>
<para> You can edit <filename>user_nl_dice</filename> to change
namelist settings by adding all user specific
namelist changes in the form of "namelist_var = new_namelist_value".
Note that any namelist variable from shr_strdata_nml and datm_nml can be modified below using the this
syntax. Use <command>preview_namelists</command> to view (not modify)
the output namelist in <filename>CaseDocs/</filename>.
</para>
<para>
You can modify the contents of a DICE stream txt file. To do this:
<itemizedlist>
<listitem><para>
use <command>preview_namelists</command> to obtain the contents of the
stream txt files in <filename>CaseDocs/</filename>
</para></listitem>
<listitem><para>
place a <emphasis>copy</emphasis> of this file in $CASEROOT
with the string <emphasis>"user_"</emphasis> prepended
</para></listitem>
<listitem><para>
<command>Make sure you change the permissions of the file to be
writeable</command> (chmod 644)
</para></listitem>
<listitem><para>
Modify the <filename>user_dice.streams.txt.*</filename> file.
</para></listitem>
</itemizedlist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>DLND</term>
<listitem>
<para> DLND is discussed in detail in <ulink
url="http://www.cesm.ucar.edu/models/cesm1.1/data8/doc/book1.html">Data
Model's User's Guide</ulink>. The data land model is different from
the other data models because it can run
as a purely data-land model (reading
in coupler history data for atm/land fluxes and land albedos produced
by a previous run), or to read in model output from CLM to send to CISM. </para>
<para>DLND can be user-customized in three ways:</para>
<para>
You can set <ulink url="../modelnl/env_run.html#run_dlnd">DLND
run-time variables</ulink>.
</para>
<para>
You can edit <filename>user_nl_dlnd</filename> OR
<filename>user_nl_dsno</filename> depending on the component set, to
change namelist settings namelists settings by adding all user
specific namelist changes in the form of "namelist_var =
new_namelist_value". Note that any namelist variable from
shr_strdata_nml and dlnd_nml or dsno_nml can be modified below using
the this syntax. Use <command>preview_namelists</command> to view (not
modify) the output namelist in <filename>CaseDocs/</filename>.
</para>
<para>
You can modify the contents of a DLND stream txt file. To do this:
<itemizedlist>
<listitem><para>
use <command>preview_namelists</command> to obtain the contents of the
stream txt files in <filename>CaseDocs/</filename>
</para></listitem>
<listitem><para>
place a <emphasis>copy</emphasis> of this file in $CASEROOT
with the string <emphasis>"user_"</emphasis> prepended
</para></listitem>
<listitem><para>
<command>Make sure you change the permissions of the file to be
writeable</command> (chmod 644)
</para></listitem>
<listitem><para>
Modify the <filename>user_dlnd.streams.txt.*</filename> file.
</para></listitem>
</itemizedlist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>DROF </term>
<listitem>
<para> DROF is discussed in  <ulink
url="http://www.cesm.ucar.edu/models/cesm1.1/data8/doc/book1.html">Data
Model's User's Guide</ulink>. The data river runoff model reads in runoff data
and sends it back to the coupler. In general, the data river runoff model is only
used to provide runoff forcing data to POP2 when running C or G
compsets</para>
<para>DROF can be user-customized in three ways:</para>
<para>
You can set <ulink url="../modelnl/env_run.html#run_drof">DROF
run-time variables</ulink>.
</para>
<para>
You can edit <filename>user_nl_drof</filename>
to change namelist settings namelists settings by adding all user
specific namelist changes in the form of "namelist_var =
new_namelist_value". Note that any namelist variable from
shr_strdata_nml and drof_nml can be modified using
the this syntax. Use <command>preview_namelists</command> to view (not
modify) the output namelist in <filename>CaseDocs/</filename>.
</para>
<para>
You can modify the contents of a DROF stream txt file. To do this:
<itemizedlist>
<listitem><para>
use <command>preview_namelists</command> to obtain the contents of the
stream txt files in <filename>CaseDocs/</filename>
</para></listitem>
<listitem><para>
place a <emphasis>copy</emphasis> of this file in $CASEROOT
with the string <emphasis>"user_"</emphasis> prepended
</para></listitem>
<listitem><para>
<command>Make sure you change the permissions of the file to be
writeable</command> (chmod 644)
</para></listitem>
<listitem><para>
Modify the <filename>user_drof.streams.txt.*</filename> file.
</para></listitem>
</itemizedlist>
</para>
</listitem>
</varlistentry>

</variablelist>

</sect2>

<!-- ======================================================================= -->
<sect2 id="running_ccsm_env_output">
<title>Controlling output data</title>

<para>
During a model run, each &cesm; component produces its own output
datasets consisting of history, restart and output log
files. Component history files and restart files are in netCDF format.
Restart files are used to either exactly restart the model or to serve
as initial conditions for other model cases.
</para>

<para>
Archiving is a phase of a &cesm; model run where the generated output
data is moved from $RUNDIR to a local disk area (short-term archiving)
and subsequently to a long-term storage system (long-term
archiving). It has no impact on the production run except to clean up
disk space and help manage user quotas.  Although short-term and
long-term archiving are implemented independently in the scripts,
there is a dependence between the two since the short-term archiver
must be turned on in order for the long-term archiver to be activated.
In &env_run.xml;, several variables control the behavior of short and
long-term archiving. See <ulink
url="../modelnl/env_run.html#run_datout"> short and long term
archiving</ulink> for a description of output data control variables.
Several important points need to be made about both short and long
term archiving:
</para>

<itemizedlist>
<listitem><para>
By default, short-term archiving is enabled and long-term archiving is
disabled.
</para></listitem>
<listitem><para>
All output data is initially written to $RUNDIR.
</para></listitem>
<listitem><para>
Unless a user explicitly turns off short-term archiving, files will be
moved to $DOUT_S_ROOT at the end of a successful model run.
</para></listitem>
<listitem><para> If long-term archiving is enabled, files will be
moved to <envar>$DOUT_L_MSROOT</envar> by
<command>$CASE.l_archive</command>, which is run as a
separate batch job after the successful completion of a model run.
</para></listitem>
<listitem><para>
Users should generally turn off short term-archiving when developing
new &cesm; code.
</para></listitem>
<listitem><para>
If long-term archiving is not enabled, users must monitor quotas and
usage in the $<envar>DOUT_S_ROOT/</envar> directory and should
manually clean up these areas on a frequent basis.
</para></listitem>
</itemizedlist>

<para>
Standard output generated from each &cesm; component is saved in a
"log file" for each component in <envar>$RUNDIR</envar>.  Each time
the model is run, a single coordinated datestamp is incorporated in
the filenames of all output log files associated with that run. This
common datestamp is generated by the run script and is of the form
YYMMDD-hhmmss, where YYMMDD are the Year, Month, Day and hhmmss are
the hour, minute and second that the run began
(e.g. ocn.log.040526-082714). Log files are also copied to a user
specified directory using the variable $LOGDIR in &env_run.xml;. The
default is a 'logs' subdirectory beneath the case directory.
</para>

<para>
By default, each component also periodically writes history files
(usually monthly) in netCDF format and also writes netCDF or binary
restart files in the <envar>$RUNDIR</envar> directory. The history and
log files are controlled independently by each component. History
output control (i.e. output fields and frequency) is set in the
<envar>Buildconf/$component.buildnml.csh</envar> files.
</para>

<para>
The raw history data does not lend itself well to easy time-series
analysis. For example, CAM writes one or more large netCDF history
file(s) at each requested output period.  While this behavior is
optimal for model execution, it makes it difficult to analyze time
series of individual variables without having to access the entire
data volume. Thus, the raw data from major model integrations is
usually postprocessed into more user-friendly configurations, such as
single files containing long time-series of each output fields, and
made available to the community.
</para>

<para>
As an example, for the  following example settings
</para>

<screen>
DOUT_S = TRUE
DOUT_S_ROOT = /ptmp/$user/archive
DOUT_L_MS = TRUE
DOUT_L_MSROOT /USER/csm/$CASE
</screen>

<para>
the run will automatically submit the
<command>$CASE.l_archive</command> to the queue upon its
completion to archive the data.  The system is not bulletproof, and
you will want to verify at regular intervals that the archived
data is complete, particularly during long running jobs.
</para>

</sect2>

</sect1>

<!-- ======================================================================= -->
<sect1 id="running_ccsm_loadbalance">
<title>Load balancing a case</title>

<para>
Load balancing refers to the optimization of the processor layout for
a given model configuration (compset, grid, etc) such that the cost
and throughput will be optimal. Optimal is a somewhat subjective
thing. For a fixed total number of processors, it means achieving the
maximum throughput. For a given configuration across varied processor
counts, it means finding several "sweet spots" where the model is
minimally idle, the cost is relatively low, and the throughput is
relatively high. As with most models, increasing total processors
normally results in both increased throughput and increased cost. If
models scaled linearly, the cost would remain constant across
different processor counts, but generally, models don't scale linearly
and cost increases with increasing processor count. This is certainly
true for CESM. It is strongly recommended that a user perform a
load-balancing exercise on their proposed model run before undertaking
a long production run.
</para>

<para>
CESM has significant flexibility with respect to the layout of
components across different hardware processors. In general, there are
seven unique models (atm, lnd, rof, ocn, ice, glc, cpl) that are managed
independently in CESM, each with a unique MPI communicator. In
addition, the driver runs on the union of all processors and controls
the sequencing and hardware partitioning.
</para>

<para>
Please see the section on <link linkend="case_conf_setting_pes">
setting the case PE layout </link> for a detailed discussion of how to
set processor layouts and the example on <link linkend="use_case_pelayout">
changing the PE layout </link>.
</para>

<!-- ======================================================================= -->
<sect2 id="timing_info">
<title>Model timing data </title>

<para>
In order to perform a load balancing exercise, you must first be
aware of the different types of timing information produced by every
&cesm; run. How this information is used is described in detail in
<link linkend="using_timing_info"> using model timing data. </link>
</para>

<para>
A summary timing output file is produced after every &cesm; run. This
file is placed in
<filename>$CASEROOT/timing/ccsm_timing.$CASE.$date</filename>, where
$date is a datestamp set by &cesm; at runtime, and contains a summary of
various information. The following provides a description of the most
important parts of a timing file.
</para>

<para>
The first section in the timing output, CCSM TIMING PROFILE,
summarizes general timing information for the run. The total run time
and cost is given in several metrics including pe-hrs per simulated
year (cost), simulated years per wall day (thoughput), seconds, and
seconds per model day. This provides general summary information
quickly in several units for analysis and comparison with other
runs. The total run time for each component is also provided, as is the
time for initialization of the model. These times are the aggregate
over the total run and do not take into account any temporal or
processor load imbalances.
</para>

<para>
The second section in the timing output, "DRIVER TIMING FLOWCHART",
provides timing information for the driver in sequential order and
indicates which processors are involved in the cost. Finally, the
timings for the coupler are broken out at the bottom of the timing
output file.
</para>

<para>
Separately, there is another file in the timing directory,
ccsm_timing_stats.$date that accompanies the above timing
summary. This second file provides a summary of the minimum and
maximum of all the model timers.
</para>

<para>
There is one other stream of useful timing information in the
cpl.log.$date file that is produced for every run. The cpl.log file
contains the run time for each model day during the model run. This
diagnostic is output as the model runs. You can search for tStamp in
the cpl.log file to see this information. This timing information is
useful for tracking down temporal variability in model cost either due
to inherent model variability cost (I/O, spin-up, seasonal, etc) or
possibly due to variability due to hardware. The model daily
cost is generally pretty constant unless I/O is written intermittently
such as at the end of the month.
</para>

</sect2>

<!-- ======================================================================= -->
<sect2 id="using_timing_info">
<title>Using model timing data </title>

<para>
In practice, load-balancing requires a number of considerations
such as which components are run, their absolute and relative
resolution; cost, scaling and processor count sweet-spots for each
component; and internal load imbalance within a component. It is often
best to load balance the system with all significant run-time I/O
turned off because this occurs very infrequently, typically one
timestep per month, and is best treated as a separate cost as it
can bias interpretation of the overall model load balance. Also, the
use of OpenMP threading in some or all of the components is dependent
on the hardware/OS support as well as whether the system supports
running all MPI and mixed MPI/OpenMP on overlapping processors for
different components. A final point is deciding whether components
should run sequentially, concurrently, or some combination of the two
with each other. Typically, a series of short test runs is done with
the desired production configuration to establish a reasonable load
balance setup for the production job. The timing output can be
used to compare test runs to help determine the optimal load balance.
</para>

<para>
Changing the pe layout of the model has NO IMPACT on the scientific
results.  The basic order of operations and calling sequence is hardwired
into the driver and that doesn't change when the pe layout is changed.
There are some constraints on the ability of CESM to run fully concurrent.
In particular, the atmosphere model always run sequentially with the ice
and land for scientific reasons.  As a result, running the atmosphere
concurrently with the ice and land will result in idle processors
in these components at some point in the timestepping sequence.  For
more information about how the driver is implemented, see
(Craig, A.P., Vertenstein, M., Jacob, R.,  2012: A new flexible coupler for
earth system modeling developed for CCSM4 and CESM1.0. International Journal of
High Performance Computing Applications, 26, 31-42, 10.1177/1094342011428141).
As of CESM1.1.1, there is a new separate rof component.  That component is implemented
in the driver just like the land model.  It can run concurrently with the
land model but not concurrently with the atmosphere model.
</para>

<para>
In general, we normally carry out 20-day model runs with restarts
and history turned off in order to find the layout that has the best
load balance for the targeted number of processors.  This provides a
reasonable performance estimate for the production run for most of the
runtime. The end of month history and end of run restart I/O is
treated as a separate cost from the load balance perspective. To set up
this test configuration, create your production case, and then edit
env_run.xml and set STOP_OPTION to ndays, STOP_N to 20, and
RESTART_OPTION to never. Seasonal variation and spin-up costs can
change performance over time, so even after a production run has
started, it's worthwhile to occasionally review the timing output to see
whether any changes might be made to the layout to improve throughput
or decrease cost.
</para>

<para>
In determining an optimal load balance for a specific
configuration, two pieces of information are useful.
</para>

<itemizedlist>
<listitem><para>
Determine which component or components are most expensive.
</para></listitem>

<listitem><para> Understand the scaling of the individual components,
whether they run faster with all MPI or mixed MPI/OpenMP decomposition
strategies, and their optimal decompositions at each processor
count. If the cost and scaling of the components are unknown, several
short tests can be carried out with arbitrary component pe counts just to
establish component scaling and sweet spots.  </para></listitem>
</itemizedlist>

<para>
One method for determining an optimal load balance is as follows
</para>

<itemizedlist>
<listitem><para>
start with the most expensive component and a fixed optimal
processor count and decomposition for that component
</para></listitem>

<listitem><para>
test the systems, varying the sequencing/concurrency of
the components and the pe counts of the other components
</para></listitem>

<listitem><para>
identify a few best potential load balance configurations and
then run each a few times to establish run-to-run variability and to
try to statistically establish the faster layout
</para></listitem>
</itemizedlist>

<para>
In all cases, the component run times in the timing output file can be
reviewed for both overall throughput and independent component
timings. Using the timing output, idle processors can be identified by
considering the component concurrency in conjunction with the
component timing.
</para>

<para>
In general, there are only a few reasonable component layout options for CESM.
</para>

<itemizedlist>
<listitem><para>fully sequential </para></listitem>
<listitem><para>fully sequential except the ocean running concurrently </para></listitem>
<listitem><para>fully concurrent except the atmosphere run sequentially with the ice,
rof, and land components </para></listitem>
<listitem><para>finally, it makes best sense for the coupler to run on a
subset of the atmosphere processors and that can be sequentially or
concurrently run with the land and ice </para></listitem>
</itemizedlist>

<para>
The concurrency is limited in part by the hardwired sequencing in the
driver. This sequencing is set by scientific constraints, although
there may be some addition flexibility with respect to concurrency
when running with mixed active and data models.
</para>

<para>
There are some general rules for finding optimal configurations:
</para>

<itemizedlist>
<listitem><para>
 Make sure you have set a processor layout where each hardware
 processor is assigned to at least one component. There is rarely a
 reason to have completely idle processors in your layout.
</para></listitem>

<listitem><para>
Make sure your cheapest components keep up with your most expensive
components. In other words, a component that runs on 1024 processors
should not be waiting on a component running on 16 processors.
</para></listitem>

<listitem><para>
Before running the job, make sure the batch queue settings in the
<filename>$CASE.run</filename> script are set correctly for the specific run being
targetted.  The account numbers, queue names, time limits should be
reviewed.  The ideal time limit, queues, and run length are all
dependent on each other and on the current model throughput.
</para></listitem>

<listitem><para>
Make sure you are taking full advantage of the hardware resources. If
you are charged by the 32-way node, you might as well target a total
processor count that is a multiple of 32.
</para></listitem>

<listitem><para>
If possible, keep a single component on a single node. That usually
minimizes internal component communication cost. That's obviously not
possible if running on more processors than the size of a node.
</para></listitem>

<listitem><para>
And always assume the hardware performance could have variations due
to contention on the interconnect, file systems, or other areas. If
unsure of a timing result, run cases multiple times.
</para></listitem>

</itemizedlist>

</sect2>

</sect1>

<!-- ======================================================================= -->
<sect1 id="running_ccsm_running">
<title>How do I run a case?</title>

<!-- ======================================================================= -->
<sect2 id="running_ccsm_running_timelimit">
<title>Setting the time limits</title>

<para>
Before you can run the job, you need to make sure the batch queue
variables are set correctly for the specific run being targeted. This
is done currently by manually editing
<filename>$CASE.run</filename>. You should carefully check
the batch queue submission lines and make sure that you have
appropriate account numbers, time limits, and stdout file names. In
looking at the ccsm_timing.$CASE.$datestamp files for "Model
Throughput", output like the following will be found:
</para>

<screen>
Overall Metrics:
Model Cost: 327.14 pe-hrs/simulated_year (scale= 0.50)
Model Throughput: 4.70 simulated_years/day
</screen>

<para>
The model throughput is the estimated number of model years that you
can run in a wallclock day. Based on this, you can maximize
$CASE.run queue limit and change $STOP_OPTION and $STOP_N in
&env_run.xml;. For example, say a model's throughput is 4.7
simulated_years/day.  On yellowstone(??), the maximum runtime limit is 6
hours. 4.7 model years/24 hours * 6 hours = 1.17 years. On the
massively parallel computers, there is always some variability in how
long it will take a job to run. On some machines, you may need to
leave as much as 20% buffer time in your run to guarantee that jobs
finish reliably before the time limit. For that reason we will set our
model to run only one model year/job. Continuing to assume that the run is
on yellowstone, in <filename>$CASE.yellowstone.run</filename> set
</para>

<screen>
#BSUB -W 6:00
</screen>

<para>
and <filename>xmlchange</filename> should be invoked as follows in &CASEROOT;:
</para>

<screen>
./xmlchange STOP_OPTION=nyears
./xmlchange STOP_N=1
./xmlchange REST_OPTION=nyears
./xmlchange REST_N=1
</screen>

</sect2>

<!-- ======================================================================= -->
<sect2 id="running_ccsm_running_submit">
<title>Submitting the run</title>

<para>
Once you have configured and built the model, submit
<filename>$CASE.run</filename> to your machine's batch queue
system using the <filename>$CASE.submit</filename> command.
</para>

<screen>
> $CASE.submit
</screen>

<para>
You can see a complete example of how to run a case in <link
linkend="use_case_basic">the basic example</link>.
</para>

<para>
When executed, the run script, <filename>$CASE.run</filename>:
</para>

<itemizedlist>

<listitem>
<para> Will not execute the build script. Building &cesm; is now done
only via an interactive call to the build script, <command>$CASE.build</command>.</para>
</listitem>
<listitem>
<para> Will check that locked files are consistent with the current
xml files, run the buildnml script for each component and verify that
required input data is present on local disk (in $&DIN_LOC_ROOT;).</para>
</listitem>
<listitem>
<para> Will run the &cesm; model. </para>
</listitem>
<listitem>
<para>Upon completion, will put timing information in
<envar>$LOGDIR/timing</envar> and copy log files back to
<envar>$LOGDIR</envar></para>
</listitem>
<listitem>
<para> If <envar>$DOUT_S</envar> is TRUE, component history, log, diagnostic, and restart files will be moved from
<envar>$RUNDIR</envar> to the short-term archive directory, <envar>$DOUT_S_ROOT</envar>.</para>
</listitem>
<listitem>
<para> If $<envar>DOUT_L_MS</envar> is TRUE, the long-term archiver,
<command>$CASE.l_archive</command>, will be submitted to the
batch queue upon successful completion of the run.</para>
</listitem>
<listitem>
<para> If $<envar>RESUBMIT</envar> >0, resubmit <command>$CASE.run</command></para>
</listitem>
</itemizedlist>

<para>
If the job runs to completion, you should have "SUCCESSFUL TERMINATION
OF CPL7-CCSM" near the end of your STDOUT file. New data should be in
the subdirectories under $DOUT_S_ROOT, or if you have long-term
archiving turned on, it should be automatically moved to
subdirectories under $DOUT_L_MSROOT.
</para>

<para>
If the job failed, there are several places where you should look for
information. Start with the STDOUT and STDERR file(s) in $CASEROOT. If
you don't find an obvious error message there, the
$RUNDIR/$model.log.$datestamp files will probably give you a
hint. First check cpl.log.$datestamp, because it will often tell you
when the model failed. Then check the rest of the component log
files. Please see <link
linkend="troubleshooting_run_time">troubleshooting runtime
errors</link> for more information.
</para>

<para>
REMINDER: Once you have a successful first run, you must set
CONTINUE_RUN to TRUE in &env_run.xml; before resubmitting, otherwise
the job will not progress. You may also need to modify the <ulink
url="../modelnl/env_run.html#run_stop">STOP_OPTION, STOP_N and/or
STOP_DATE</ulink>, <ulink
url="../modelnl/env_run.html#run_rest">REST_OPTION, REST_N and/or
REST_DATE</ulink>, and <ulink
url="../modelnl/env_run.html#run_rest">RESUBMIT</ulink> variables in
&env_run.xml; before resubmitting.
</para>

</sect2>

<!-- ======================================================================= -->
<sect2 id="running_ccsm_restarts">
<title>Restarting a run</title>

<para>
Restart files are written by each active component (and some data
components) at intervals dictated by the driver via the setting of the
&env_run.xml; variables, $<envar>REST_OPTION</envar> and
$<envar>REST_N</envar>. Restart files allow the model to stop and then
start again with bit-for-bit exact capability (i.e. the model output
is exactly the same as if it had never been stopped). The driver
coordinates the writing of restart files as well as the time evolution
of the model.  All components receive restart and stop information
from the driver and write restarts or stop as specified by the driver.
</para>

<para>
It is important to note that runs that are initialized as branch or
hybrid runs, will require restart/initial files from previous model
runs (as specified by the variables,
$<envar>RUN_REFCASE</envar> and $<envar>RUN_REFDATE</envar>).  These
required files must be prestaged <emphasis>by the user</emphasis> to
the case $<envar>RUNDIR</envar> (normally
<filename>$EXEROOT/run</filename>) before the model run starts. This
is normally done by just copying the contents of the relevant
<filename>$RUN_REFCASE/rest/$RUN_REFDATE.00000</filename> directory.
</para>

<para>
Whenever a component writes a restart file, it also writes a restart
pointer file of the form, <filename>rpointer.$component</filename>.
The restart pointer file contains the restart filename that was just
written by the component.  Upon a restart, each component reads its
restart pointer file to determine the filename(s) to read in order to
continue the model run. As examples, the following pointer files will
be created for a component set using full active model components.
</para>

<itemizedlist>
<listitem><para>rpointer.atm </para></listitem>
<listitem><para>rpointer.drv </para></listitem>
<listitem><para>rpointer.ice </para></listitem>
<listitem><para>rpointer.lnd </para></listitem>
<listitem><para>rpointer.rof </para></listitem>
<listitem><para>rpointer.cism</para></listitem>
<listitem><para>rpointer.ocn.ovf </para></listitem>
<listitem><para>rpointer.ocn.restart </para></listitem>
</itemizedlist>

<para>
If short-term archiving is turned on, then the model archives the
component restart datasets and pointer files into
<filename>$DOUT_S_ROOT/rest/yyyy-mm-dd-sssss</filename>, where
yyyy-mm-dd-sssss is the model date at the time of the restart (<link
linkend="running_ccsm_starch">see below for more details</link>).
If long-term archiving these restart then
archived in
<filename>$DOUT_L_MSROOT/rest</filename>. <envar>DOUT_S_ROOT</envar>
and <envar>DOUT_L_MSROOT</envar> are set in &env_run.xml;, and can be
changed at any time during the run.
</para>

<sect3 id="running_ccsm_restart_back">
<title>Backing up to a previous restart</title>

<para> If a run encounters problems and crashes, you will normally have
to back up to a previous restart.  Assuming that short-term archiving
is enabled, you will need to find the latest
<filename>$DOUT_S_ROOT/rest/yyyy-mm-dd-ssss/</filename> directory that
was created and copy the contents of that directory into your run
directory ($<envar>RUNDIR</envar>). You can then continue the run
and these restarts will be used.  It is important to make sure the new
rpointer.* files overwrite the rpointer.* files that were in
$<envar>RUNDIR</envar>, or the job may not restart in the correct
place. </para>

<para> Occasionally, when a run has problems restarting, it is
because the rpointer files are out of sync with the restart files. The
rpointer files are text files and can easily be edited to match the
correct dates of the restart and history files. All the restart files
should have the same date. </para>

</sect3>

</sect2>

<!-- ======================================================================= -->
<sect2 id="running_ccsm_data_flow">
<title>Data flow during a model run</title>

<para> All component log files are copied to the directory specified
by the &env_run.xml; variable $<envar>LOGDIR</envar> which by default
is set to <filename>$CASEROOT/logs</filename>. This location is
where log files are copied when the job completes successfully.  If the
job aborts, the log files will NOT be copied out of the <filename>$RUNDIR</filename> directory.
</para>

<para> Once a model run has completed successfully, the output data
flow will depend on whether or not short-term archiving is enabled (as
set by the &env_run.xml; variable, $<envar>DOUT_S</envar>). By
default, short-term archiving will be done.</para>

<sect3 id="running_ccsm_noarch">
<title>No archiving</title>

<para> If no short-term archiving is performed, then all model output
data will remain in the run directory, as specified by the
&env_run.xml; variable, $<envar>RUNDIR</envar>. Furthermore, if
short-term archiving is disabled, then long-term archiving will not be
allowed. </para>

</sect3>

<sect3 id="running_ccsm_starch">
<title>Short-term archiving</title>

<para> If short-term archiving is enabled, the component output files will be
moved to the short term archiving area on local disk, as specified by
$<envar>DOUT_S_ROOT</envar>.  The directory DOUT_S_ROOT is normally
set to <envar>$EXEROOT/../archive/$CASE</envar>.
and will
contain the following directory structure: </para>

<screen>
atm/
    hist/ logs/
cpl/
    hist/ logs/
glc/
    logs/
ice/
    hist/ logs/
lnd/
    hist/ logs/
ocn/
    hist/ logs/
rest/
    yyyy-mm-dd-sssss/
    ....
    yyyy-mm-dd-sssss/
</screen>

<para><filename>hist/</filename> contains component history output for
the run.</para>

<para><filename>logs/</filename> contains component log files
created during the run. In addition to $<envar>LOGDIR</envar>, log
files are also copied to the short-term archiving directory and
therefore are available for long-term archiving.</para>

<para>
<filename>rest/</filename> contains a subset of directories that each
contain a <emphasis>consistent</emphasis> set of restart files,
initial files and rpointer files. Each sub-directory has a unique name
corresponding to the model year, month, day and seconds into the day
where the files were created
(e.g. <filename>1852-01-01-00000/</filename>). The contents of any
restart directory can be used to <link linkend="use_case_branch">create a
branch run or a hybrid run</link> or back up to a previous restart
date.
</para>

</sect3>

<sect3 id="running_ccsm_ltarch">
<title>Long-term archiving</title>

<para> For long production runs that generate many giga-bytes of data,
you will normally want to move the output data from local disk to a
long-term archival location.  Long-term archiving can be activated by
setting $<envar>DOUT_L_MS</envar> to TRUE in
<filename>env_run.xml</filename>. By default, the value of this
variable is FALSE, and long-term archiving is disabled. If the value
is set to TRUE, then the following additional variables are:
$<envar>DOUT_L_MSROOT</envar>, $<envar>DOUT_S_ROOT</envar>
<envar>DOUT_S</envar> (see <link linkend="running_ccsm_env_output">
variables for output data management</link> ). </para>

<para> As was mentioned above, if long-term archiving is enabled,
files will be moved out of $<envar>DOUT_S_ROOT</envar> to
$<envar>DOUT_L_ROOT</envar> by
<filename>$CASE.l_archive</filename>,, which is run as a
separate batch job after the successful completion of a model run.</para>

</sect3>

</sect2>

</sect1>

<!-- ======================================================================= -->
<sect1 id="running_ccsm_testing">
<title>Testing a case</title>

<para>
After the case has built and has demonstrated the ability to run via a
short test, it is important to formally test exact
restart capability before a production run is started.
See <xref linkend="create_production_test"/> for
more information about how to use create_production_test.</para>

</sect1>

</chapter>
