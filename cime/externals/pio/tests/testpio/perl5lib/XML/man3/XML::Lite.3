.\" Automatically generated by Pod::Man version 1.02
.\" Tue Mar 18 09:37:35 2003
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Lite 3"
.TH Lite 3 "perl v5.6.0" "2003-03-17" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1XML:\s0:Lite \- A lightweight \s-1XML\s0 parser for simple files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use \s-1XML:\s0:Lite;
my \f(CW$xml\fR = new \s-1XML:\s0:Lite( xml => 'a_file.xml' );
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1XML:\s0:Lite is a lightweight \s-1XML\s0 parser, with basic element traversing 
methods. It is entirely self-contained, pure Perl (i.e. \fInot\fR based on 
expat). It provides useful methods for reading most \s-1XML\s0 files, including 
traversing and finding elements, reading attributes and such. It is 
designed to take advantage of Perl-isms (Attribute lists are returned as 
hashes, rather than, say, lists of objects). It provides only methods 
for reading a file, currently.
.SH "METHODS"
.IX Header "METHODS"
The following methods are available:
.Ip "my \f(CW$xml\fR = new \s-1XML:\s0:Lite( xml => \f(CW$source\fR[, ...] );" 4
.IX Item "my $xml = new XML::Lite( xml => $source[, ...] );"
Creates a new \s-1XML:\s0:Lite object. The \s-1XML:\s0:Lite object acts as the document
object for the \f(CW$source\fR that is sent to it to parse. This means that you 
create a new object for each document (or document sub-section). As the 
objects are lightweight this should not be a performance consideration.
.Sp
The object constructor can take several named parameters. Parameter names
may begin with a '\-' (as in the example above) but are not required to. The 
following parameters are recognized.
.Sp
.Vb 2
\&  xml      The source XML to parse. This can be a filename, a scalar that 
\&           contains the document (or document fragment), or an IO handle.
.Ve
As a convenince, if only on parameter is given, it is assumed to be the source.
So you can use this, if you wish:
.Sp
.Vb 1
\&        my $xml = new XML::Lite( 'file.xml' );
.Ve
.Ip "my \f(CW$elm\fR = \f(CW$xml\fR->\fIroot_element()\fR" 4
.IX Item "my $elm = $xml->root_element()"
Returns a reference to an \s-1XML:\s0:Lite::Element object that represents
the root element of the document.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR on errors.
.Ip "@list = \f(CW$xml\fR->elements_by_name( \f(CW$name\fR )" 4
.IX Item "@list = $xml->elements_by_name( $name )"
Returns a list of all elements that match \f(CW\*(C`$name\*(C'\fR.
\&\f(CW\*(C`@list\*(C'\fR is a list of the XML::Lite::Element manpage objects
If called in a scalar context, this will return the
first element found that matches (it's more efficient 
to call in a scalar context than assign the results 
to a list of one scalar).
.Sp
If no matching elements are found then returns \f(CW\*(C`undef\*(C'\fR
in scalar context or an empty list in array context.
.SH "BUGS"
.IX Header "BUGS"
Lots. This 'parser' (Matt Sergeant takes umbrance to my us of that word) will handle some \s-1XML\s0
documents, but not all. 
.SH "VERSION"
.IX Header "VERSION"
0.14
.SH "AUTHOR"
.IX Header "AUTHOR"
Jeremy Wadsack for Wadsack-Allen Digital Group (dgsupport@wadsack-allen.com)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001\-2003 Wadsack-Allen. All rights reserved.
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
