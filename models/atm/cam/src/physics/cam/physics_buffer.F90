#include "dtypes.h"
!===================================================
! DO NOT EDIT THIS FILE, it was generated using ../../../../../../tools/cprnc/genf90/genf90.pl 
! Any changes you make to this file may be lost
!===================================================
!#define DEBUG 1
module physics_buffer

  !----------------------------------------------------------------------- 
  ! 
  ! Purpose: 
  !    Buffer managment for persistant variables 
  !
  ! Author: J. Edwards
  !
  ! This file is used with genf90.pl to generate buffer.F90  
  ! 
  !-----------------------------------------------------------------------

  use shr_kind_mod, only: r8 => shr_kind_r8, r4=> shr_kind_r4, i4=> shr_kind_i4
  use constituents, only: pcnst
  use ppgrid, only: pcols, pver, begchunk, endchunk, psubcols
  use cam_logfile,     only: iulog
  use pio, only : var_desc_t
  use dyn_grid, only : ptimelevels
  use abortutils, only : endrun
  use buffer, only : buffer_field_allocate, buffer_field_deallocate, buffer_get_field_ptr, buffer_set_field, &
       dtype_i4, dtype_r4, dtype_r8, buffer_field_default_type, buffer_field_is_alloc

  implicit none
  private

  ! 
  ! physics_buffer_hdr carries the description info for each buffer, only one header 
  ! is allocated for each field and each chunk of the field points to it. 
  ! It is carried as a linkedlist for initialization only.
  !


  type physics_buffer_hdr
     character(len=16) :: name
     integer :: dtype
     integer :: persistance
     integer :: dimsizes(6)   
     integer :: dimsizes_sc(6)   
     type(var_desc_t) :: vardesc  ! var id for restart files
     type(physics_buffer_hdr), pointer :: nexthdr => null()

  end type physics_buffer_hdr

  !
  ! The default type for a buffer field is buffer_field_double (r8) since that is the 
# 48 "physics_buffer.F90.in"
  ! type most often used in the model.   The F90 transfer function is used to move
  ! data of other types into and out of the pbuf2d
  ! 

  type physics_buffer_desc
     private
     type(physics_buffer_hdr), pointer :: hdr => null()
     type(buffer_field_default_type) :: bfg
     type(buffer_field_default_type) :: bfg_sc
  end type physics_buffer_desc

# 59 "physics_buffer.F90.in"
  interface pbuf_get_field
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_1d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_2d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_3d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_4d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_5d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_6d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_1d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_2d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_3d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_4d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_5d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_6d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_1d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_2d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_3d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_4d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_5d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf1d_field_by_index_6d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_1d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_2d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_3d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_4d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_5d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_6d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_1d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_2d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_3d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_4d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_5d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_6d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_1d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_2d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_3d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_4d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_5d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure get_pbuf2d_field_by_index_6d_real
  end interface


# 69 "physics_buffer.F90.in"
  interface pbuf_set_field
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_1d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_2d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_3d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_4d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_5d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_6d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_1d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_2d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_3d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_4d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_5d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_6d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_1d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_2d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_3d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_4d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_5d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf2d_field_by_index_6d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_1d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_2d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_3d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_4d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_5d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_6d_int
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_1d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_2d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_3d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_4d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_5d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_6d_double
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_1d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_2d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_3d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_4d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_5d_real
     ! TYPE int,double,real 
     ! DIMS 1,2,3,4,5,6
     module procedure  set_pbuf1d_field_by_index_6d_real
     ! TYPE int,double,real 
     module procedure  set_pbuf1d_field_const_by_index_int
     ! TYPE int,double,real 
     module procedure  set_pbuf1d_field_const_by_index_double
     ! TYPE int,double,real 
     module procedure  set_pbuf1d_field_const_by_index_real
     ! TYPE int,double,real 
     module procedure  set_pbuf2d_field_const_by_index_int
     ! TYPE int,double,real 
     module procedure  set_pbuf2d_field_const_by_index_double
     ! TYPE int,double,real 
     module procedure  set_pbuf2d_field_const_by_index_real
  end interface

# 82 "physics_buffer.F90.in"
  interface pbuf_add_field
     ! TYPE int,double,real 
     module procedure pbuf_add_field_int
     ! TYPE int,double,real 
     module procedure pbuf_add_field_double
     ! TYPE int,double,real 
     module procedure pbuf_add_field_real
  end interface

  public :: pbuf_initialize, &
            pbuf_defaultopts,   &! set namelist defaults
            pbuf_setopts,       &! set user specified namelist values
            pbuf_init_time,     &! Initialize pbuf_times
            pbuf_old_tim_idx,   &! return the index for the oldest time
            pbuf_update_tim_idx,&! update the index for the oldest time
            pbuf_get_field_name, &
            pbuf_get_field, &
            pbuf_add_field, &
            physics_buffer_desc, &
            pbuf_get_index, &
            pbuf_get_chunk, &
            pbuf_allocate, &
            pbuf_deallocate, &
            pbuf_set_field, &
            pbuf_init_restart, &
            pbuf_write_restart, &
            pbuf_read_restart, &
            dtype_r8, dtype_r4, dtype_i4, &
            pbuf_set_test_field, pbuf_check_test_field

   integer, public :: pbuf_times  ! number of time levels in physics buffer (dycore dependent)


  !
  !  Currentpbufflds is incremented in calls to pbuf_add_field and determines the size
  !  of the allocated pbuf2d
  !

  integer :: currentpbufflds=0
  type(physics_buffer_hdr), pointer :: hdrbuffertop => null()

  ! The API has strings 'GLOBAL' and 'PHYSPKG' which correspond to these integer constants
  ! if global_allocate_all is false fields allocated with PHYSPKG persistance are deallocated
  ! at the end of each physics time step and reallocated at the beginning of the next.   If 
  ! global_allocate_all is true then all fields are allocated at model start and persist until model
  ! completion.

  integer :: old_time_idx = 1
  integer, parameter :: persistance_global=1,persistance_physpkg=2
  logical :: global_allocate_all=.true.   ! can be used to make all persistance global


  ! 
  ! Insures that we do not attempt to allocate physics_buffer more than once
  !

  logical :: buffer_initialized=.false.

  !
  ! private pio descriptor for time
  !

  type(var_desc_t) :: timeidx_desc



# 144 "physics_buffer.F90.in"
CONTAINS

  !
  ! Purpose: Return default runtime options
  !

# 150 "physics_buffer.F90.in"
  subroutine pbuf_defaultopts(pbuf_global_allocate_out)
     logical, intent(out), optional :: pbuf_global_allocate_out
     if ( present(pbuf_global_allocate_out) ) then
        pbuf_global_allocate_out = global_allocate_all
     endif
  end subroutine pbuf_defaultopts


  !
  ! Purpose: Set runtime options
  !

# 162 "physics_buffer.F90.in"
  subroutine pbuf_setopts(pbuf_global_allocate_in)
     logical, intent(in), optional :: pbuf_global_allocate_in
     if ( present(pbuf_global_allocate_in) ) then
        global_allocate_all = pbuf_global_allocate_in
     endif
  end subroutine pbuf_setopts

  !
  ! Initialize pbuf_times
  !
# 172 "physics_buffer.F90.in"
  subroutine pbuf_init_time()
     pbuf_times = ptimelevels - 1
  end subroutine pbuf_init_time

  !
  ! Return index of oldest time sample in the physics buffer.
  !

# 180 "physics_buffer.F90.in"
  function pbuf_old_tim_idx()
     integer :: pbuf_old_tim_idx
     pbuf_old_tim_idx = old_time_idx
  end function pbuf_old_tim_idx

  !
  ! Update index of old time sample in the physics buffer.
  !

# 189 "physics_buffer.F90.in"
  subroutine pbuf_update_tim_idx()
     old_time_idx = mod(old_time_idx, pbuf_times) + 1
  end subroutine pbuf_update_tim_idx

  ! 
  !  Return a pointer to the current chunks physics_buffer.
  !

# 197 "physics_buffer.F90.in"
  function pbuf_get_field_name(index)
    integer, intent(in) :: index
    character(len=16) :: pbuf_get_field_name
    integer :: i
    type(physics_buffer_hdr), pointer :: hdrbuffer

    hdrbuffer => hdrbuffertop
    do i=1,index
       hdrbuffer=>hdrbuffer%nexthdr
    end do
    pbuf_get_field_name = hdrbuffer%name

  end function pbuf_get_field_name


# 212 "physics_buffer.F90.in"
  function pbuf_get_chunk(pbuf2d, lchnk)
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk

    type(physics_buffer_desc), pointer :: pbuf_get_chunk(:)

    pbuf_get_chunk => pbuf2d(:,lchnk)


  end function pbuf_get_chunk

  !
  !  Initialize the buffer, should be called after all pbuf_add_field calls 
  !  have been completed and should only be called once in a run
  !
# 227 "physics_buffer.F90.in"
  subroutine pbuf_initialize(pbuf2d)
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    
    integer :: i, c
    type(physics_buffer_hdr), pointer :: hdrbuffer

    !
    ! Allocate memory
    !
    if(buffer_initialized) return
    ! Allocate at least 1 to avoid unallocated error in ideal physics
    allocate(pbuf2d(max(1,currentpbufflds),begchunk:endchunk)) 
    if(currentpbufflds<1) return

    do c=begchunk,endchunk
       hdrbuffer => hdrbuffertop
       do i=1,currentpbufflds
          pbuf2d(i,c)%hdr => hdrbuffer
          hdrbuffer=>hdrbuffer%nexthdr
       end do
    end do
    
    buffer_initialized=.true.
    call pbuf_allocate(pbuf2d, 'global')
#ifdef DEBUG
    call pbuf2d_print(pbuf2d)
#endif
    return
  end subroutine pbuf_initialize

# 257 "physics_buffer.F90.in"
  subroutine pbuf_set_test_field (pbuf2d, index)
    use phys_grid, only: get_gcol_all_p

    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index

    integer :: c, colid(pcols,31,2), k, t
    integer :: dimsizes(6)


    dimsizes = pbuf2d(index,begchunk)%hdr%dimsizes
    call pbuf_set_field(pbuf2d, index,0)

    do c=begchunk,endchunk
       call get_gcol_all_p(c, pcols, colid(:,1,1))
       do t=1,2
       do k=1,dimsizes(2)
          colid(:,k,t) = colid(:,1,1)+(k-1)*1000+(t-1)*100000
       end do
    end do
       call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,colid)

    end do
    

  end subroutine pbuf_set_test_field

# 284 "physics_buffer.F90.in"
  subroutine pbuf_check_test_field (lchnk, fld, it)
    use phys_grid, only: get_gcol_all_p
    
    integer, intent(in) :: lchnk, it
    integer, intent(in) :: fld(:,:)
    integer :: colid(pcols,31), k, i, t


    call get_gcol_all_p(lchnk, pcols, colid(:,1))
    do k=1,31
       colid(:,k) = colid(:,1)+(k-1)*1000+(it-1)*100000
    end do

    do k=1,31
       do i=1,pcols
          if(fld(i,k)/=colid(i,k)) then
             print *,__FILE__,__LINE__,lchnk,i,k,it,fld(i,k),colid(i,k)
          end if
       end do
    end do


  end subroutine pbuf_check_test_field







# 314 "physics_buffer.F90.in"
  subroutine pbuf_allocate(pbuf2d, persistance)
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    character(len=*), intent(in) :: persistance
    integer :: i
    logical :: allocate_all

    ! allocate_all is used to force allocation of all fields at same time as allocation
    ! for global scope.
    allocate_all = .false.
    if ( global_allocate_all ) then
       if ( persistance == 'global' ) then
          allocate_all = .true.
       else
          return
       end if
    end if

    if(allocate_all) then
       do i=1,currentpbufflds
          select case(pbuf2d(i,begchunk)%hdr%dtype)
          case(TYPEDOUBLE)
             call pbuf_allocate_field_double(pbuf2d, i, dtype_r8)
          case(TYPEREAL)
             call pbuf_allocate_field_real(pbuf2d, i, dtype_r4)
!          case(i8)
!             call pbuf_allocate_field_long(pbuf2d, i)
          case(TYPEINT)
             call pbuf_allocate_field_int(pbuf2d, i, dtype_i4)
          end select
       end do
    else if(persistance .eq. 'physpkg') then
       do i=1,currentpbufflds
          if(pbuf2d(i,begchunk)%hdr%persistance==persistance_physpkg) then
             select case(pbuf2d(i,begchunk)%hdr%dtype)
             case(TYPEDOUBLE)
                call pbuf_allocate_field_double(pbuf2d, i, dtype_r8)
             case(TYPEREAL)
                call pbuf_allocate_field_real(pbuf2d, i, dtype_r4)
!             case(i8)
!                call pbuf_allocate_field_long(pbuf2d, i)
             case(TYPEINT)
                call pbuf_allocate_field_int(pbuf2d, i, dtype_i4)
             end select
          end if
       end do
    else if(persistance .eq. 'global') then
       do i=1,currentpbufflds
          if(pbuf2d(i,begchunk)%hdr%persistance==persistance_global) then

             select case(pbuf2d(i,begchunk)%hdr%dtype)
             case(TYPEDOUBLE)
                call pbuf_allocate_field_double(pbuf2d, i, dtype_r8)
             case(TYPEREAL)
                call pbuf_allocate_field_real(pbuf2d, i, dtype_r4)
!             case(i8)
!                call pbuf_allocate_field_long(pbuf2d, i)
             case(TYPEINT)
                call pbuf_allocate_field_int(pbuf2d, i, dtype_i4)
             end select
          end if
       end do
    end if
  end subroutine pbuf_allocate

  ! TYPE int,double,real 
# 379 "physics_buffer.F90.in"
  subroutine pbuf_allocate_field_int(pbuf2d, index, dtype)
    integer(i4), intent(in) :: dtype
    type(physics_buffer_desc),pointer :: pbuf2d(:,:)
    integer, intent(in) :: index

    integer, pointer :: dimsizes(:)
    integer, pointer :: dimsizes_sc(:)
    integer :: c

    ! Note - dimsizes(:)=0 is special case to indicate "do not allocate" and is not fatal
    dimsizes=>pbuf2d(index,begchunk)%hdr%dimsizes
    dimsizes_sc=>pbuf2d(index,begchunk)%hdr%dimsizes_sc

    if (any(dimsizes(:) < 0)) &
       call endrun('pbuf_allocate_field: dimsizes must be greater than 0 for pbuf field with index '&
                     //trim(pbuf2d(index,begchunk)%hdr%name))

    if (any(dimsizes_sc(:) < 0)) &
       call endrun('pbuf_allocate_field: dimsizes_sc must be greater than 0 for pbuf field with index '&
                     //trim(pbuf2d(index,begchunk)%hdr%name))

    if (all(dimsizes(:) /= 0)) then
       do c=begchunk,endchunk
          call buffer_field_allocate(pbuf2d(index,c)%bfg,   dimsizes,   dtype)
       end do
    end if
    
    if (all(dimsizes_sc(:) /= 0)) then
       do c=begchunk,endchunk
          call buffer_field_allocate(pbuf2d(index,c)%bfg_sc,dimsizes_sc,dtype)
       end do
    end if

  end subroutine pbuf_allocate_field_int

  ! TYPE int,double,real 
# 379 "physics_buffer.F90.in"
  subroutine pbuf_allocate_field_double(pbuf2d, index, dtype)
    real(r8), intent(in) :: dtype
    type(physics_buffer_desc),pointer :: pbuf2d(:,:)
    integer, intent(in) :: index

    integer, pointer :: dimsizes(:)
    integer, pointer :: dimsizes_sc(:)
    integer :: c

    ! Note - dimsizes(:)=0 is special case to indicate "do not allocate" and is not fatal
    dimsizes=>pbuf2d(index,begchunk)%hdr%dimsizes
    dimsizes_sc=>pbuf2d(index,begchunk)%hdr%dimsizes_sc

    if (any(dimsizes(:) < 0)) &
       call endrun('pbuf_allocate_field: dimsizes must be greater than 0 for pbuf field with index '&
                     //trim(pbuf2d(index,begchunk)%hdr%name))

    if (any(dimsizes_sc(:) < 0)) &
       call endrun('pbuf_allocate_field: dimsizes_sc must be greater than 0 for pbuf field with index '&
                     //trim(pbuf2d(index,begchunk)%hdr%name))

    if (all(dimsizes(:) /= 0)) then
       do c=begchunk,endchunk
          call buffer_field_allocate(pbuf2d(index,c)%bfg,   dimsizes,   dtype)
       end do
    end if
    
    if (all(dimsizes_sc(:) /= 0)) then
       do c=begchunk,endchunk
          call buffer_field_allocate(pbuf2d(index,c)%bfg_sc,dimsizes_sc,dtype)
       end do
    end if

  end subroutine pbuf_allocate_field_double

  ! TYPE int,double,real 
# 379 "physics_buffer.F90.in"
  subroutine pbuf_allocate_field_real(pbuf2d, index, dtype)
    real(r4), intent(in) :: dtype
    type(physics_buffer_desc),pointer :: pbuf2d(:,:)
    integer, intent(in) :: index

    integer, pointer :: dimsizes(:)
    integer, pointer :: dimsizes_sc(:)
    integer :: c

    ! Note - dimsizes(:)=0 is special case to indicate "do not allocate" and is not fatal
    dimsizes=>pbuf2d(index,begchunk)%hdr%dimsizes
    dimsizes_sc=>pbuf2d(index,begchunk)%hdr%dimsizes_sc

    if (any(dimsizes(:) < 0)) &
       call endrun('pbuf_allocate_field: dimsizes must be greater than 0 for pbuf field with index '&
                     //trim(pbuf2d(index,begchunk)%hdr%name))

    if (any(dimsizes_sc(:) < 0)) &
       call endrun('pbuf_allocate_field: dimsizes_sc must be greater than 0 for pbuf field with index '&
                     //trim(pbuf2d(index,begchunk)%hdr%name))

    if (all(dimsizes(:) /= 0)) then
       do c=begchunk,endchunk
          call buffer_field_allocate(pbuf2d(index,c)%bfg,   dimsizes,   dtype)
       end do
    end if
    
    if (all(dimsizes_sc(:) /= 0)) then
       do c=begchunk,endchunk
          call buffer_field_allocate(pbuf2d(index,c)%bfg_sc,dimsizes_sc,dtype)
       end do
    end if

  end subroutine pbuf_allocate_field_real





# 418 "physics_buffer.F90.in"
  subroutine pbuf_deallocate(pbuf2d, persistance)
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    character(len=*) :: persistance

    integer :: i, c

    if( global_allocate_all .and. persistance .eq. 'physpkg') return

    if(persistance .eq. 'physpkg') then
       do i=1,currentpbufflds
          if(pbuf2d(i,begchunk)%hdr%persistance==persistance_physpkg) then
             do c=begchunk,endchunk
                select case(pbuf2d(i,begchunk)%hdr%dtype)
                case(TYPEDOUBLE)
                   call buffer_field_deallocate(pbuf2d(i,c)%bfg, dtype_r8)
                case(TYPEREAL)
                   call buffer_field_deallocate(pbuf2d(i,c)%bfg, dtype_r4)
                case(TYPEINT)
                   call buffer_field_deallocate(pbuf2d(i,c)%bfg, dtype_i4)
                end select
             end do
          end if
       end do
    else          
       do i=1,currentpbufflds
          do c=begchunk,endchunk
             select case(pbuf2d(i,begchunk)%hdr%dtype)
             case(TYPEDOUBLE)
                call buffer_field_deallocate(pbuf2d(i,c)%bfg, dtype_r8)
             case(TYPEREAL)
                call buffer_field_deallocate(pbuf2d(i,c)%bfg, dtype_r4)
             case(TYPEINT)
                call buffer_field_deallocate(pbuf2d(i,c)%bfg, dtype_i4)
             end select
          end do
       end do
    end if
  end subroutine pbuf_deallocate

  !
  !  Add a field to the pbuf, this should be called from physics register routines
  !  name is required to be unique, 
  !  persistance must be 'global' or 'physpkg' 
  !  dtype can be any of r8, r4, i4 as defined in shr_kinds_mod.F90

  ! TYPE int,double,real 
# 464 "physics_buffer.F90.in"
  subroutine pbuf_add_field_int(name, persistance, dtype, dimsizes, index, grid_types_flag)
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind
    character(len=*), intent(in) :: name, persistance
    integer(i4), intent(in) :: dtype   ! used only to differentiate specific calls
    integer, intent(in) :: dimsizes(:) ! dimension sizes of grid field
    integer(bit_field_kind), intent(in), optional :: grid_types_flag 


    integer, intent(out) :: index

    type(physics_buffer_hdr), pointer :: bufptr
    integer :: dimcnt


    if(buffer_initialized) then
       call endrun('Attempt to add pbuf field after buffer initialized')
    end if
    if(.not. associated(hdrbuffertop)) then
       allocate(hdrbuffertop)
    end if
    
    dimcnt=1
    bufptr=>hdrbuffertop

    ! If neither grid nor sub-columns specified, write out error message and return
    if (present(grid_types_flag)) then
       if (.not. (is_col_type_set(grid_types_flag,flag_gridcol) .or. (is_col_type_set(grid_types_flag,flag_subcol)))) then
           write(iulog, *) 'Warning -- Trying to add field ',trim(name),&
                           ' but grid_types_flag is not set for either grid or sub-columns -- Field not added'
           return
       end if
    end if

    do while(associated(bufptr%nexthdr))
       if((bufptr%name) .eq. name) then
          call endrun('Attempt to redefine pbuf field in use: '//trim(name))
       end if
       bufptr=>bufptr%nexthdr
    end do
    

    currentpbufflds=currentpbufflds+1
    index=currentpbufflds
    bufptr%name=name

    if(persistance .eq. "global") then
       bufptr%persistance=persistance_global
    else
       bufptr%persistance=persistance_physpkg
    endif

    bufptr%dtype=103

    dimcnt=size(dimsizes)

    bufptr%dimsizes=1
    bufptr%dimsizes(1:dimcnt) = dimsizes

    ! If not using grid columns, then grid dimensions are all set to 0
    if (present(grid_types_flag)) then
      if (.not. is_col_type_set(grid_types_flag,flag_gridcol)) then
         bufptr%dimsizes=0
      end if
    end if


    ! Set the sub-column dimensions if requested
    bufptr%dimsizes_sc=0
    if (present(grid_types_flag)) then
       if (is_col_type_set(grid_types_flag,flag_subcol)) then
          if (dimsizes(1) /= pcols) call endrun('First dimension of field to be sub-columnized must be pcols '//trim(name))
          bufptr%dimsizes_sc=1
          bufptr%dimsizes_sc(1) = pcols*psubcols
          bufptr%dimsizes_sc(2:dimcnt) = dimsizes(2:dimcnt)
       end if
    end if

    allocate(bufptr%nexthdr)


  end subroutine pbuf_add_field_int

  !
  !  Add a field to the pbuf, this should be called from physics register routines
  !  name is required to be unique, 
  !  persistance must be 'global' or 'physpkg' 
  !  dtype can be any of r8, r4, i4 as defined in shr_kinds_mod.F90

  ! TYPE int,double,real 
# 464 "physics_buffer.F90.in"
  subroutine pbuf_add_field_double(name, persistance, dtype, dimsizes, index, grid_types_flag)
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind
    character(len=*), intent(in) :: name, persistance
    real(r8), intent(in) :: dtype   ! used only to differentiate specific calls
    integer, intent(in) :: dimsizes(:) ! dimension sizes of grid field
    integer(bit_field_kind), intent(in), optional :: grid_types_flag 


    integer, intent(out) :: index

    type(physics_buffer_hdr), pointer :: bufptr
    integer :: dimcnt


    if(buffer_initialized) then
       call endrun('Attempt to add pbuf field after buffer initialized')
    end if
    if(.not. associated(hdrbuffertop)) then
       allocate(hdrbuffertop)
    end if
    
    dimcnt=1
    bufptr=>hdrbuffertop

    ! If neither grid nor sub-columns specified, write out error message and return
    if (present(grid_types_flag)) then
       if (.not. (is_col_type_set(grid_types_flag,flag_gridcol) .or. (is_col_type_set(grid_types_flag,flag_subcol)))) then
           write(iulog, *) 'Warning -- Trying to add field ',trim(name),&
                           ' but grid_types_flag is not set for either grid or sub-columns -- Field not added'
           return
       end if
    end if

    do while(associated(bufptr%nexthdr))
       if((bufptr%name) .eq. name) then
          call endrun('Attempt to redefine pbuf field in use: '//trim(name))
       end if
       bufptr=>bufptr%nexthdr
    end do
    

    currentpbufflds=currentpbufflds+1
    index=currentpbufflds
    bufptr%name=name

    if(persistance .eq. "global") then
       bufptr%persistance=persistance_global
    else
       bufptr%persistance=persistance_physpkg
    endif

    bufptr%dtype=102

    dimcnt=size(dimsizes)

    bufptr%dimsizes=1
    bufptr%dimsizes(1:dimcnt) = dimsizes

    ! If not using grid columns, then grid dimensions are all set to 0
    if (present(grid_types_flag)) then
      if (.not. is_col_type_set(grid_types_flag,flag_gridcol)) then
         bufptr%dimsizes=0
      end if
    end if


    ! Set the sub-column dimensions if requested
    bufptr%dimsizes_sc=0
    if (present(grid_types_flag)) then
       if (is_col_type_set(grid_types_flag,flag_subcol)) then
          if (dimsizes(1) /= pcols) call endrun('First dimension of field to be sub-columnized must be pcols '//trim(name))
          bufptr%dimsizes_sc=1
          bufptr%dimsizes_sc(1) = pcols*psubcols
          bufptr%dimsizes_sc(2:dimcnt) = dimsizes(2:dimcnt)
       end if
    end if

    allocate(bufptr%nexthdr)


  end subroutine pbuf_add_field_double

  !
  !  Add a field to the pbuf, this should be called from physics register routines
  !  name is required to be unique, 
  !  persistance must be 'global' or 'physpkg' 
  !  dtype can be any of r8, r4, i4 as defined in shr_kinds_mod.F90

  ! TYPE int,double,real 
# 464 "physics_buffer.F90.in"
  subroutine pbuf_add_field_real(name, persistance, dtype, dimsizes, index, grid_types_flag)
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind
    character(len=*), intent(in) :: name, persistance
    real(r4), intent(in) :: dtype   ! used only to differentiate specific calls
    integer, intent(in) :: dimsizes(:) ! dimension sizes of grid field
    integer(bit_field_kind), intent(in), optional :: grid_types_flag 


    integer, intent(out) :: index

    type(physics_buffer_hdr), pointer :: bufptr
    integer :: dimcnt


    if(buffer_initialized) then
       call endrun('Attempt to add pbuf field after buffer initialized')
    end if
    if(.not. associated(hdrbuffertop)) then
       allocate(hdrbuffertop)
    end if
    
    dimcnt=1
    bufptr=>hdrbuffertop

    ! If neither grid nor sub-columns specified, write out error message and return
    if (present(grid_types_flag)) then
       if (.not. (is_col_type_set(grid_types_flag,flag_gridcol) .or. (is_col_type_set(grid_types_flag,flag_subcol)))) then
           write(iulog, *) 'Warning -- Trying to add field ',trim(name),&
                           ' but grid_types_flag is not set for either grid or sub-columns -- Field not added'
           return
       end if
    end if

    do while(associated(bufptr%nexthdr))
       if((bufptr%name) .eq. name) then
          call endrun('Attempt to redefine pbuf field in use: '//trim(name))
       end if
       bufptr=>bufptr%nexthdr
    end do
    

    currentpbufflds=currentpbufflds+1
    index=currentpbufflds
    bufptr%name=name

    if(persistance .eq. "global") then
       bufptr%persistance=persistance_global
    else
       bufptr%persistance=persistance_physpkg
    endif

    bufptr%dtype=101

    dimcnt=size(dimsizes)

    bufptr%dimsizes=1
    bufptr%dimsizes(1:dimcnt) = dimsizes

    ! If not using grid columns, then grid dimensions are all set to 0
    if (present(grid_types_flag)) then
      if (.not. is_col_type_set(grid_types_flag,flag_gridcol)) then
         bufptr%dimsizes=0
      end if
    end if


    ! Set the sub-column dimensions if requested
    bufptr%dimsizes_sc=0
    if (present(grid_types_flag)) then
       if (is_col_type_set(grid_types_flag,flag_subcol)) then
          if (dimsizes(1) /= pcols) call endrun('First dimension of field to be sub-columnized must be pcols '//trim(name))
          bufptr%dimsizes_sc=1
          bufptr%dimsizes_sc(1) = pcols*psubcols
          bufptr%dimsizes_sc(2:dimcnt) = dimsizes(2:dimcnt)
       end if
    end if

    allocate(bufptr%nexthdr)


  end subroutine pbuf_add_field_real

# 546 "physics_buffer.F90.in"
  subroutine pbuf2d_print(pbuf2d)
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)

    call pbuf1d_print(pbuf_get_chunk(pbuf2d,begchunk))


  end subroutine pbuf2d_print

# 554 "physics_buffer.F90.in"
  subroutine pbuf1d_print(pbuf)
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer :: i
    type(physics_buffer_desc), pointer :: pbufPtr

    print *,__FILE__,__LINE__,currentpbufflds,size(pbuf)
    do i=1,currentpbufflds
       pbufPtr => pbuf(i)
       print *,__FILE__,__LINE__,i,trim(pbufPtr%hdr%name),pbufPtr%hdr%dtype,pbufPtr%hdr%persistance,pbufPtr%hdr%dimsizes
    end do

  end subroutine pbuf1d_print
  !
  ! Given a pbuf field name return an integer index to the field.  
  ! This index can be used to retrieve the field and is much faster
  ! than using the name in most cases  
  ! 

# 572 "physics_buffer.F90.in"
  function pbuf_get_index(name, errcode) result(index)
    character(len=*), intent(in)     :: name
    integer, intent(inout), optional :: errcode
    integer :: index
    integer :: i
    type(physics_buffer_hdr), pointer :: bufptr


    bufptr=>hdrbuffertop
    index = -1
    do i=1,currentpbufflds
       if(bufptr%name .eq. name) then
          index=i
          exit
       end if
       bufptr=>bufptr%nexthdr
    end do

    if (present(errcode)) then
        errcode = index 
    else if(index<0) then
       call endrun('Attempt to find undefined name in pbuf '//trim(name))
    end if


  end function pbuf_get_index

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_1d_int(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    integer(i4), pointer :: field(:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_1d_int

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_2d_int(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    integer(i4), pointer :: field(:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_2d_int

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_3d_int(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    integer(i4), pointer :: field(:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_3d_int

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_4d_int(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    integer(i4), pointer :: field(:,:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_4d_int

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_5d_int(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    integer(i4), pointer :: field(:,:,:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_5d_int

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_6d_int(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    integer(i4), pointer :: field(:,:,:,:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_6d_int

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_1d_double(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r8), pointer :: field(:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_1d_double

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_2d_double(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r8), pointer :: field(:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_2d_double

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_3d_double(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r8), pointer :: field(:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_3d_double

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_4d_double(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r8), pointer :: field(:,:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_4d_double

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_5d_double(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r8), pointer :: field(:,:,:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_5d_double

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_6d_double(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r8), pointer :: field(:,:,:,:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_6d_double

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_1d_real(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r4), pointer :: field(:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_1d_real

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_2d_real(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r4), pointer :: field(:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_2d_real

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_3d_real(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r4), pointer :: field(:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_3d_real

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_4d_real(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r4), pointer :: field(:,:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_4d_real

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_5d_real(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r4), pointer :: field(:,:,:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_5d_real

  !=========================================================================================

  ! 
  ! Given a pbuf2d chunk and an index return a pointer to a field chunk 
  ! 
  !


  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 609 "physics_buffer.F90.in"
  subroutine get_pbuf1d_field_by_index_6d_real(pbuf, index, field, start,kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    use grid_flag_utils, only : flag_gridcol, flag_subcol
    type(physics_buffer_desc), pointer:: pbuf(:)
    integer, intent(in) :: index
    real(r4), pointer :: field(:,:,:,:,:,:)
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type

    integer :: col_type_use
    logical :: subset

    ! Copy the generic type to one compatable with the request
    if(index<1 .or. index>size(pbuf)) then
       print *,__FILE__,__LINE__,index
       call endrun('index out of range')
    end if

    ! Default col_type is grid columns
    col_type_use = flag_gridcol
    if (present(col_type)) col_type_use = col_type

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    
    if(subset) then
       select case(col_type_use)
          case(flag_subcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field,start,kount )
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg,   field,start,kount )
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
       end select

    else 
       select case(col_type_use)
          case(flag_subcol) 
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                    call endrun('pbuf_get_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg_sc,field)
          case(flag_gridcol)
             if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                    call endrun('pbuf_get_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
             call buffer_get_field_ptr(pbuf(index)%bfg   ,field)
          case default
             call endrun('pbuf_get_field: Invalid col_type ')
          end select
    end if
       
  end subroutine get_pbuf1d_field_by_index_6d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_1d_int(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    integer(i4), pointer :: field(:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_1d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_2d_int(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    integer(i4), pointer :: field(:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_2d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_3d_int(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    integer(i4), pointer :: field(:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_3d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_4d_int(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    integer(i4), pointer :: field(:,:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_4d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_5d_int(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    integer(i4), pointer :: field(:,:,:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_5d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_6d_int(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    integer(i4), pointer :: field(:,:,:,:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_6d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_1d_double(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r8), pointer :: field(:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_1d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_2d_double(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r8), pointer :: field(:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_2d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_3d_double(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r8), pointer :: field(:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_3d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_4d_double(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r8), pointer :: field(:,:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_4d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_5d_double(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r8), pointer :: field(:,:,:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_5d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_6d_double(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r8), pointer :: field(:,:,:,:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_6d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_1d_real(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r4), pointer :: field(:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_1d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_2d_real(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r4), pointer :: field(:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_2d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_3d_real(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r4), pointer :: field(:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_3d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_4d_real(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r4), pointer :: field(:,:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_4d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_5d_real(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r4), pointer :: field(:,:,:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_5d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 676 "physics_buffer.F90.in"
  subroutine get_pbuf2d_field_by_index_6d_real(pbuf2d, lchnk, index, field, start, kount, col_type)

    ! Get the data based on the col_type which is specified.  If no col_type, then grid field is returned
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: lchnk
    integer, intent(in) :: index
    integer, intent(in), optional :: start(:),kount(:)
    integer, intent(in), optional :: col_type
 
    logical :: subset

    real(r4), pointer :: field(:,:,:,:,:,:)

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_get_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if
    
    if(subset .and. present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount, col_type)
    else if(subset) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, start,kount)
    else if(present(col_type)) then
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field, col_type=col_type)
    else
       call pbuf_get_field(pbuf_get_chunk(pbuf2d,lchnk), index, field)
    end if
  end subroutine get_pbuf2d_field_by_index_6d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 712 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_const_by_index_int(pbuf2d,index,const, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer(i4),intent(in) :: const
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer :: c
    
    do c=begchunk,endchunk
       if(present(grid_types_flag)) then
          call set_pbuf1d_field_const_by_index_int(pbuf_get_chunk(pbuf2d,c),index,const, grid_types_flag=grid_types_flag)
       else
          call set_pbuf1d_field_const_by_index_int(pbuf_get_chunk(pbuf2d,c),index,const)
       end if
    enddo

  end subroutine set_pbuf2d_field_const_by_index_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 712 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_const_by_index_double(pbuf2d,index,const, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    real(r8),intent(in) :: const
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer :: c
    
    do c=begchunk,endchunk
       if(present(grid_types_flag)) then
          call set_pbuf1d_field_const_by_index_double(pbuf_get_chunk(pbuf2d,c),index,const, grid_types_flag=grid_types_flag)
       else
          call set_pbuf1d_field_const_by_index_double(pbuf_get_chunk(pbuf2d,c),index,const)
       end if
    enddo

  end subroutine set_pbuf2d_field_const_by_index_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 712 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_const_by_index_real(pbuf2d,index,const, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    real(r4),intent(in) :: const
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer :: c
    
    do c=begchunk,endchunk
       if(present(grid_types_flag)) then
          call set_pbuf1d_field_const_by_index_real(pbuf_get_chunk(pbuf2d,c),index,const, grid_types_flag=grid_types_flag)
       else
          call set_pbuf1d_field_const_by_index_real(pbuf_get_chunk(pbuf2d,c),index,const)
       end if
    enddo

  end subroutine set_pbuf2d_field_const_by_index_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 735 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_const_by_index_int(pbuf,index,const,start,kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    integer(i4),intent(in) :: const
    integer, intent(in), optional :: start(:),kount(:)
    integer(bit_field_kind), intent(in), optional :: grid_types_flag
   
    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset


    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if
    
    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                     ' but grid_types_flag not set correctly')
    end if

    ! Set the appropriate grid and/or sub-column fields.  Check that the fields have been allocated.
    if(subset) then 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                 call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,const,start,kount)
        end if

       
       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,const,start,kount)
       end if 

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                 call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,const)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,const)
       end if

    end if

  end subroutine set_pbuf1d_field_const_by_index_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 735 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_const_by_index_double(pbuf,index,const,start,kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r8),intent(in) :: const
    integer, intent(in), optional :: start(:),kount(:)
    integer(bit_field_kind), intent(in), optional :: grid_types_flag
   
    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset


    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if
    
    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                     ' but grid_types_flag not set correctly')
    end if

    ! Set the appropriate grid and/or sub-column fields.  Check that the fields have been allocated.
    if(subset) then 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                 call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,const,start,kount)
        end if

       
       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,const,start,kount)
       end if 

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                 call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,const)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,const)
       end if

    end if

  end subroutine set_pbuf1d_field_const_by_index_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 735 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_const_by_index_real(pbuf,index,const,start,kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r4),intent(in) :: const
    integer, intent(in), optional :: start(:),kount(:)
    integer(bit_field_kind), intent(in), optional :: grid_types_flag
   
    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset


    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if
    
    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                     ' but grid_types_flag not set correctly')
    end if

    ! Set the appropriate grid and/or sub-column fields.  Check that the fields have been allocated.
    if(subset) then 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                 call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,const,start,kount)
        end if

       
       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,const,start,kount)
       end if 

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
                 call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,const)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,const)
       end if

    end if

  end subroutine set_pbuf1d_field_const_by_index_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_1d_int(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    integer(i4), pointer :: fld(:)


#if (1==1)
    integer(i4),pointer :: field(:,:)
#elif (1==2)
    integer(i4),pointer :: field(:,:,:)
#elif (1==3)
    integer(i4),pointer :: field(:,:,:,:)
#elif (1==4)
    integer(i4),pointer :: field(:,:,:,:,:)
#elif (1==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
#elif (1==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_1d_int(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_1d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_2d_int(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    integer(i4), pointer :: fld(:,:)


#if (2==1)
    integer(i4),pointer :: field(:,:)
#elif (2==2)
    integer(i4),pointer :: field(:,:,:)
#elif (2==3)
    integer(i4),pointer :: field(:,:,:,:)
#elif (2==4)
    integer(i4),pointer :: field(:,:,:,:,:)
#elif (2==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
#elif (2==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_2d_int(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_2d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_3d_int(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    integer(i4), pointer :: fld(:,:,:)


#if (3==1)
    integer(i4),pointer :: field(:,:)
#elif (3==2)
    integer(i4),pointer :: field(:,:,:)
#elif (3==3)
    integer(i4),pointer :: field(:,:,:,:)
#elif (3==4)
    integer(i4),pointer :: field(:,:,:,:,:)
#elif (3==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
#elif (3==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_3d_int(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_3d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_4d_int(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    integer(i4), pointer :: fld(:,:,:,:)


#if (4==1)
    integer(i4),pointer :: field(:,:)
#elif (4==2)
    integer(i4),pointer :: field(:,:,:)
#elif (4==3)
    integer(i4),pointer :: field(:,:,:,:)
#elif (4==4)
    integer(i4),pointer :: field(:,:,:,:,:)
#elif (4==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
#elif (4==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_4d_int(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_4d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_5d_int(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    integer(i4), pointer :: fld(:,:,:,:,:)


#if (5==1)
    integer(i4),pointer :: field(:,:)
#elif (5==2)
    integer(i4),pointer :: field(:,:,:)
#elif (5==3)
    integer(i4),pointer :: field(:,:,:,:)
#elif (5==4)
    integer(i4),pointer :: field(:,:,:,:,:)
#elif (5==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
#elif (5==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_5d_int(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_5d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_6d_int(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    integer(i4), pointer :: fld(:,:,:,:,:,:)


#if (6==1)
    integer(i4),pointer :: field(:,:)
#elif (6==2)
    integer(i4),pointer :: field(:,:,:)
#elif (6==3)
    integer(i4),pointer :: field(:,:,:,:)
#elif (6==4)
    integer(i4),pointer :: field(:,:,:,:,:)
#elif (6==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
#elif (6==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_6d_int(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_6d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_1d_double(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r8), pointer :: fld(:)


#if (1==1)
    real(r8),pointer :: field(:,:)
#elif (1==2)
    real(r8),pointer :: field(:,:,:)
#elif (1==3)
    real(r8),pointer :: field(:,:,:,:)
#elif (1==4)
    real(r8),pointer :: field(:,:,:,:,:)
#elif (1==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
#elif (1==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_1d_double(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_1d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_2d_double(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r8), pointer :: fld(:,:)


#if (2==1)
    real(r8),pointer :: field(:,:)
#elif (2==2)
    real(r8),pointer :: field(:,:,:)
#elif (2==3)
    real(r8),pointer :: field(:,:,:,:)
#elif (2==4)
    real(r8),pointer :: field(:,:,:,:,:)
#elif (2==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
#elif (2==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_2d_double(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_2d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_3d_double(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r8), pointer :: fld(:,:,:)


#if (3==1)
    real(r8),pointer :: field(:,:)
#elif (3==2)
    real(r8),pointer :: field(:,:,:)
#elif (3==3)
    real(r8),pointer :: field(:,:,:,:)
#elif (3==4)
    real(r8),pointer :: field(:,:,:,:,:)
#elif (3==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
#elif (3==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_3d_double(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_3d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_4d_double(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r8), pointer :: fld(:,:,:,:)


#if (4==1)
    real(r8),pointer :: field(:,:)
#elif (4==2)
    real(r8),pointer :: field(:,:,:)
#elif (4==3)
    real(r8),pointer :: field(:,:,:,:)
#elif (4==4)
    real(r8),pointer :: field(:,:,:,:,:)
#elif (4==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
#elif (4==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_4d_double(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_4d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_5d_double(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r8), pointer :: fld(:,:,:,:,:)


#if (5==1)
    real(r8),pointer :: field(:,:)
#elif (5==2)
    real(r8),pointer :: field(:,:,:)
#elif (5==3)
    real(r8),pointer :: field(:,:,:,:)
#elif (5==4)
    real(r8),pointer :: field(:,:,:,:,:)
#elif (5==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
#elif (5==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_5d_double(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_5d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_6d_double(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r8), pointer :: fld(:,:,:,:,:,:)


#if (6==1)
    real(r8),pointer :: field(:,:)
#elif (6==2)
    real(r8),pointer :: field(:,:,:)
#elif (6==3)
    real(r8),pointer :: field(:,:,:,:)
#elif (6==4)
    real(r8),pointer :: field(:,:,:,:,:)
#elif (6==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
#elif (6==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_6d_double(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_6d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_1d_real(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r4), pointer :: fld(:)


#if (1==1)
    real(r4),pointer :: field(:,:)
#elif (1==2)
    real(r4),pointer :: field(:,:,:)
#elif (1==3)
    real(r4),pointer :: field(:,:,:,:)
#elif (1==4)
    real(r4),pointer :: field(:,:,:,:,:)
#elif (1==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
#elif (1==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_1d_real(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_1d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_2d_real(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r4), pointer :: fld(:,:)


#if (2==1)
    real(r4),pointer :: field(:,:)
#elif (2==2)
    real(r4),pointer :: field(:,:,:)
#elif (2==3)
    real(r4),pointer :: field(:,:,:,:)
#elif (2==4)
    real(r4),pointer :: field(:,:,:,:,:)
#elif (2==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
#elif (2==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_2d_real(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_2d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_3d_real(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r4), pointer :: fld(:,:,:)


#if (3==1)
    real(r4),pointer :: field(:,:)
#elif (3==2)
    real(r4),pointer :: field(:,:,:)
#elif (3==3)
    real(r4),pointer :: field(:,:,:,:)
#elif (3==4)
    real(r4),pointer :: field(:,:,:,:,:)
#elif (3==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
#elif (3==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_3d_real(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_3d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_4d_real(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r4), pointer :: fld(:,:,:,:)


#if (4==1)
    real(r4),pointer :: field(:,:)
#elif (4==2)
    real(r4),pointer :: field(:,:,:)
#elif (4==3)
    real(r4),pointer :: field(:,:,:,:)
#elif (4==4)
    real(r4),pointer :: field(:,:,:,:,:)
#elif (4==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
#elif (4==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_4d_real(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_4d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_5d_real(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r4), pointer :: fld(:,:,:,:,:)


#if (5==1)
    real(r4),pointer :: field(:,:)
#elif (5==2)
    real(r4),pointer :: field(:,:,:)
#elif (5==3)
    real(r4),pointer :: field(:,:,:,:)
#elif (5==4)
    real(r4),pointer :: field(:,:,:,:,:)
#elif (5==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
#elif (5==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_5d_real(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_5d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 809 "physics_buffer.F90.in"
  subroutine set_pbuf2d_field_by_index_6d_real(pbuf2d,index,field, start, kount, grid_types_flag)

    use grid_flag_utils, only : bit_field_kind
    ! Set the field(s) specified by the grid_types_flag
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    logical :: subset

    integer :: c
    real(r4), pointer :: fld(:,:,:,:,:,:)


#if (6==1)
    real(r4),pointer :: field(:,:)
#elif (6==2)
    real(r4),pointer :: field(:,:,:)
#elif (6==3)
    real(r4),pointer :: field(:,:,:,:)
#elif (6==4)
    real(r4),pointer :: field(:,:,:,:,:)
#elif (6==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
#elif (6==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
#endif

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf2d(index,begchunk)%hdr%name))
    end if

    do c=begchunk,endchunk
       fld => get_field_chunk_6d_real(field,c)
       if(subset .and. present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount, grid_types_flag)
       else if(subset) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,start,kount)
       else if(present(grid_types_flag)) then
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld,grid_types_flag=grid_types_flag)
       else
          call pbuf_set_field(pbuf_get_chunk(pbuf2d,c),index,fld)
       end if
    enddo
  end subroutine set_pbuf2d_field_by_index_6d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_1d_int(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    integer(i4), pointer :: fld(:)
    integer, intent(in) :: c

#if (1==1)
    integer(i4),pointer :: field(:,:)
    fld => field(:,c)
#elif (1==2)
    integer(i4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (1==3)
    integer(i4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (1==4)
    integer(i4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (1==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (1==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_1d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_2d_int(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    integer(i4), pointer :: fld(:,:)
    integer, intent(in) :: c

#if (2==1)
    integer(i4),pointer :: field(:,:)
    fld => field(:,c)
#elif (2==2)
    integer(i4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (2==3)
    integer(i4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (2==4)
    integer(i4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (2==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (2==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_2d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_3d_int(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    integer(i4), pointer :: fld(:,:,:)
    integer, intent(in) :: c

#if (3==1)
    integer(i4),pointer :: field(:,:)
    fld => field(:,c)
#elif (3==2)
    integer(i4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (3==3)
    integer(i4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (3==4)
    integer(i4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (3==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (3==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_3d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_4d_int(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    integer(i4), pointer :: fld(:,:,:,:)
    integer, intent(in) :: c

#if (4==1)
    integer(i4),pointer :: field(:,:)
    fld => field(:,c)
#elif (4==2)
    integer(i4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (4==3)
    integer(i4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (4==4)
    integer(i4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (4==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (4==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_4d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_5d_int(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    integer(i4), pointer :: fld(:,:,:,:,:)
    integer, intent(in) :: c

#if (5==1)
    integer(i4),pointer :: field(:,:)
    fld => field(:,c)
#elif (5==2)
    integer(i4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (5==3)
    integer(i4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (5==4)
    integer(i4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (5==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (5==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_5d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_6d_int(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    integer(i4), pointer :: fld(:,:,:,:,:,:)
    integer, intent(in) :: c

#if (6==1)
    integer(i4),pointer :: field(:,:)
    fld => field(:,c)
#elif (6==2)
    integer(i4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (6==3)
    integer(i4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (6==4)
    integer(i4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (6==5)
    integer(i4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (6==6)
    integer(i4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_6d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_1d_double(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r8), pointer :: fld(:)
    integer, intent(in) :: c

#if (1==1)
    real(r8),pointer :: field(:,:)
    fld => field(:,c)
#elif (1==2)
    real(r8),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (1==3)
    real(r8),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (1==4)
    real(r8),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (1==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (1==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_1d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_2d_double(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r8), pointer :: fld(:,:)
    integer, intent(in) :: c

#if (2==1)
    real(r8),pointer :: field(:,:)
    fld => field(:,c)
#elif (2==2)
    real(r8),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (2==3)
    real(r8),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (2==4)
    real(r8),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (2==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (2==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_2d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_3d_double(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r8), pointer :: fld(:,:,:)
    integer, intent(in) :: c

#if (3==1)
    real(r8),pointer :: field(:,:)
    fld => field(:,c)
#elif (3==2)
    real(r8),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (3==3)
    real(r8),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (3==4)
    real(r8),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (3==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (3==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_3d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_4d_double(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r8), pointer :: fld(:,:,:,:)
    integer, intent(in) :: c

#if (4==1)
    real(r8),pointer :: field(:,:)
    fld => field(:,c)
#elif (4==2)
    real(r8),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (4==3)
    real(r8),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (4==4)
    real(r8),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (4==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (4==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_4d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_5d_double(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r8), pointer :: fld(:,:,:,:,:)
    integer, intent(in) :: c

#if (5==1)
    real(r8),pointer :: field(:,:)
    fld => field(:,c)
#elif (5==2)
    real(r8),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (5==3)
    real(r8),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (5==4)
    real(r8),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (5==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (5==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_5d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_6d_double(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r8), pointer :: fld(:,:,:,:,:,:)
    integer, intent(in) :: c

#if (6==1)
    real(r8),pointer :: field(:,:)
    fld => field(:,c)
#elif (6==2)
    real(r8),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (6==3)
    real(r8),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (6==4)
    real(r8),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (6==5)
    real(r8),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (6==6)
    real(r8),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_6d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_1d_real(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r4), pointer :: fld(:)
    integer, intent(in) :: c

#if (1==1)
    real(r4),pointer :: field(:,:)
    fld => field(:,c)
#elif (1==2)
    real(r4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (1==3)
    real(r4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (1==4)
    real(r4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (1==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (1==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_1d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_2d_real(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r4), pointer :: fld(:,:)
    integer, intent(in) :: c

#if (2==1)
    real(r4),pointer :: field(:,:)
    fld => field(:,c)
#elif (2==2)
    real(r4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (2==3)
    real(r4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (2==4)
    real(r4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (2==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (2==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_2d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_3d_real(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r4), pointer :: fld(:,:,:)
    integer, intent(in) :: c

#if (3==1)
    real(r4),pointer :: field(:,:)
    fld => field(:,c)
#elif (3==2)
    real(r4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (3==3)
    real(r4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (3==4)
    real(r4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (3==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (3==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_3d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_4d_real(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r4), pointer :: fld(:,:,:,:)
    integer, intent(in) :: c

#if (4==1)
    real(r4),pointer :: field(:,:)
    fld => field(:,c)
#elif (4==2)
    real(r4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (4==3)
    real(r4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (4==4)
    real(r4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (4==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (4==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_4d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_5d_real(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r4), pointer :: fld(:,:,:,:,:)
    integer, intent(in) :: c

#if (5==1)
    real(r4),pointer :: field(:,:)
    fld => field(:,c)
#elif (5==2)
    real(r4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (5==3)
    real(r4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (5==4)
    real(r4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (5==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (5==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_5d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 864 "physics_buffer.F90.in"
  function get_field_chunk_6d_real(field, c) result(fld) 
# 865 "physics_buffer.F90.in"
    ! module private helper function
    real(r4), pointer :: fld(:,:,:,:,:,:)
    integer, intent(in) :: c

#if (6==1)
    real(r4),pointer :: field(:,:)
    fld => field(:,c)
#elif (6==2)
    real(r4),pointer :: field(:,:,:)
    fld => field(:,:,c)
#elif (6==3)
    real(r4),pointer :: field(:,:,:,:)
    fld => field(:,:,:,c)
#elif (6==4)
    real(r4),pointer :: field(:,:,:,:,:)
    fld => field(:,:,:,:,c)
#elif (6==5)
    real(r4),pointer :: field(:,:,:,:,:,:)
    fld => field(:,:,:,:,:,c)
#elif (6==6)
    real(r4),pointer :: field(:,:,:,:,:,:,:)
    fld => field(:,:,:,:,:,:,c)
#endif    

  end function get_field_chunk_6d_real



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_1d_int(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    integer(i4), intent(in) :: field(:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_1d_int



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_2d_int(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    integer(i4), intent(in) :: field(:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_2d_int



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_3d_int(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    integer(i4), intent(in) :: field(:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_3d_int



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_4d_int(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    integer(i4), intent(in) :: field(:,:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_4d_int



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_5d_int(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    integer(i4), intent(in) :: field(:,:,:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_5d_int



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_6d_int(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    integer(i4), intent(in) :: field(:,:,:,:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_6d_int



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_1d_double(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r8), intent(in) :: field(:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_1d_double



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_2d_double(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r8), intent(in) :: field(:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_2d_double



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_3d_double(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r8), intent(in) :: field(:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_3d_double



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_4d_double(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r8), intent(in) :: field(:,:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_4d_double



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_5d_double(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r8), intent(in) :: field(:,:,:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_5d_double



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_6d_double(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r8), intent(in) :: field(:,:,:,:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_6d_double



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_1d_real(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r4), intent(in) :: field(:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_1d_real



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_2d_real(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r4), intent(in) :: field(:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_2d_real



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_3d_real(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r4), intent(in) :: field(:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_3d_real



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_4d_real(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r4), intent(in) :: field(:,:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_4d_real



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_5d_real(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r4), intent(in) :: field(:,:,:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_5d_real



  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 895 "physics_buffer.F90.in"
  subroutine set_pbuf1d_field_by_index_6d_real(pbuf,index,field, start, kount, grid_types_flag)

    ! Set the field(s) specified by the grid_types_flag
    use grid_flag_utils, only : flag_gridcol, flag_subcol, is_col_type_set, bit_field_kind, set_col_type
    type(physics_buffer_desc), pointer :: pbuf(:)
    integer, intent(in) :: index
    real(r4), intent(in) :: field(:,:,:,:,:,:)
    integer,intent(in),optional :: start(:), kount(:)
    integer(bit_field_kind),intent(in),optional :: grid_types_flag

    integer(bit_field_kind) :: grid_types_flag_use
    logical :: subset

    ! Default grid_types_flag is grid only
    grid_types_flag_use = set_col_type(flag_gridcol)
    if (present(grid_types_flag)) grid_types_flag_use = grid_types_flag

    ! Check whether subset of data requested (default is false)
    subset = .false.
    if (present(start) .and. present(kount)) subset = .true.

    ! Check for ill-formed request
    if ( (present(start) .and. .not. present(kount)) .or.&
         (.not. present(start) .and. present(kount)) ) then
       call endrun('pbuf_set_field: Both start and kount must be present for '//trim(pbuf(index)%hdr%name))
    end if

    ! Check for invalid grid_types_flag
    if (.not. (is_col_type_set(grid_types_flag_use,flag_gridcol) .or. (is_col_type_set(grid_types_flag_use,flag_subcol)))) then
         call endrun('pbuf_set_field: Trying to set '//trim(pbuf(index)%hdr%name)//&
                    ' but grid_types_flag not set correctly')
    end if

    if(subset) then

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field,start,kount)      
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field,start,kount)
       end if

    else 

       ! Set sub-column field
       if (is_col_type_set(grid_types_flag_use,flag_subcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg_sc)) &
              call endrun('pbuf_set_field: sub-column field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg_sc,field)
       end if

       ! Set grid field
       if (is_col_type_set(grid_types_flag_use,flag_gridcol)) then
          if (.not. buffer_field_is_alloc(pbuf(index)%bfg)) &
                 call endrun('pbuf_set_field: grid field not allocated for '//trim(pbuf(index)%hdr%name))
          call buffer_set_field(pbuf(index)%bfg   ,field)
       end if

    endif
  end subroutine set_pbuf1d_field_by_index_6d_real


!
! Initialize a restart file to write - all additional dims in a field are bundled into a 
! single dimension for output and a dim pbuf_xxxxx is declared in the file if it 
! does not already exist.   
!
# 969 "physics_buffer.F90.in"
  subroutine pbuf_init_restart(File, pbuf2d)
    use pio, only : file_desc_t, pio_seterrorhandling, pio_bcast_error, pio_internal_error, &
         pio_inq_dimid, pio_def_dim, pio_def_var, pio_noerr, pio_int
    type(file_desc_t), intent(inout) :: file
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)

    type(physics_buffer_desc), pointer :: pbuf
    integer :: ierr
    integer :: adimid(3), hdimcnt, dimcnt

    character(len=10) dimname
    integer :: i, mdimsize

    call pio_seterrorhandling(File, pio_bcast_error)
    ierr = pio_inq_dimid(File, 'lon', adimid(1))
    if(ierr==PIO_NOERR) then
       ierr = pio_inq_dimid(File, 'lat', adimid(2))
       hdimcnt=2
    else
       ierr = pio_inq_dimid(File, 'ncol', adimid(1))
       hdimcnt=1
    endif
    call pio_seterrorhandling(File, pio_internal_error)

    do i=1,currentpbufflds
       pbuf => pbuf2d(i,begchunk)

       if(pbuf%hdr%persistance == persistance_physpkg) cycle
       mdimsize=product(pbuf%hdr%dimsizes(2:))

       if(mdimsize>1) then
          call pio_seterrorhandling(File, pio_bcast_error)
          write(dimname,'(a,i5.5)') 'pbuf_',mdimsize
          ierr = pio_inq_dimid(File,dimname, adimid(hdimcnt+1))
          call pio_seterrorhandling(File, pio_internal_error)
          if(ierr /= PIO_NOERR) then
             ierr = pio_def_dim(File, dimname, mdimsize, adimid(hdimcnt+1))
          end if
          dimcnt=hdimcnt+1
       else
          dimcnt=hdimcnt
       end if
       ierr = pio_def_var(File, trim(pbuf%hdr%name), pbuftype2piotype(pbuf%hdr%dtype), &
            adimid(1:dimcnt),pbuf%hdr%vardesc)
    end do

    ierr = pio_def_var(File, 'pbuf_time_idx', pio_int, timeidx_desc)

  end subroutine pbuf_init_restart

# 1019 "physics_buffer.F90.in"
  function pbuftype2piotype(pbuftype) result(piotype)
    use pio, only : pio_double, pio_int, pio_real

    integer, intent(in) :: pbuftype
    integer :: piotype

    select case(pbuftype)
    case (TYPEDOUBLE)
       piotype = pio_double
    case(TYPEINT)
       piotype = pio_int
    case(TYPEREAL)
       piotype = pio_real
!    case(TYPELONG)
!       piotype = pio_int
    case default
       write(iulog, *) 'Dtype = ', pbuftype
       call endrun('No restart support for dtype')
    end select
  end function pbuftype2piotype



# 1042 "physics_buffer.F90.in"
  subroutine pbuf_write_restart(File, pbuf2d)
    use pio, only : file_desc_t, pio_put_var
    type(file_desc_t), intent(inout) :: file
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)

    type(physics_buffer_desc), pointer :: pbuf(:)

    integer :: i,ierr

    pbuf => pbuf_get_chunk(pbuf2d,begchunk)


    do i=1,currentpbufflds
       if(pbuf(i)%hdr%persistance == persistance_global) then
          call pbuf_write_field(File, pbuf2d, i)
       end if
    end do
    ierr = pio_put_var(File, timeidx_desc, (/old_time_idx/))



  end subroutine pbuf_write_restart


# 1066 "physics_buffer.F90.in"
  subroutine pbuf_write_field(File, pbuf2d, index)
    use pio, only : file_desc_t, io_desc_t, pio_write_darray
    use cam_pio_utils, only : get_phys_decomp

    use spmd_utils, only : iam

    type(File_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    type(physics_buffer_desc), pointer :: pbuf
    integer, intent(in) :: index
    type(io_desc_t), pointer                :: iodesc=> null()
    integer :: piodtype, mdimsize, lchnk

    integer, allocatable ::  fldi(:,:,:)
    real(r8), allocatable :: fldd(:,:,:)
    real(r4), allocatable :: fldr(:,:,:)
    integer, pointer ::  bufi(:,:,:,:)
    real(r8), pointer :: bufd(:,:,:,:)
    real(r4), pointer :: bufr(:,:,:,:)

    integer :: ierr



    pbuf=> pbuf2d(index,begchunk)
    piodtype = pbuftype2piotype(pbuf%hdr%dtype)

    mdimsize=product(pbuf%hdr%dimsizes(2:))

    call get_phys_decomp(iodesc, 1, mdimsize, 1, piodtype)

    select case(pbuf%hdr%dtype)
    case(TYPEDOUBLE)
       allocate(fldd(pcols,mdimsize,begchunk:endchunk))
       fldd = 0_r8
       do lchnk=begchunk,endchunk
          call pbuf_get_field(pbuf2d, lchnk, index, bufd)
          fldd(:,:,lchnk) = reshape(bufd,(/pcols,mdimsize/))
       end do
       call pio_write_darray(File, pbuf%hdr%vardesc, iodesc, fldd, ierr)
       deallocate(fldd)
    case(TYPEREAL)
       allocate(fldr(pcols,mdimsize,begchunk:endchunk))
       fldr = 0_r4
       do lchnk=begchunk,endchunk
          call pbuf_get_field(pbuf2d, lchnk, index, bufr)
          fldr(:,:,lchnk) = reshape(bufr,(/pcols,mdimsize/))
       end do
       call pio_write_darray(File, pbuf%hdr%vardesc, iodesc, fldr, ierr)
       deallocate(fldr)
    case(TYPEINT)
       allocate(fldi(pcols,mdimsize,begchunk:endchunk))
       fldi=0_i4
       do lchnk=begchunk,endchunk
          call pbuf_get_field(pbuf2d, lchnk, index, bufi)
        
          fldi(:,:,lchnk) = reshape(bufi,(/pcols,mdimsize/))
       end do
       call pio_write_darray(File, pbuf%hdr%vardesc, iodesc, fldi, ierr)
       deallocate(fldi)

    case default
    end select

  end subroutine pbuf_write_field


# 1133 "physics_buffer.F90.in"
  subroutine pbuf_read_restart(File, pbuf2d)
    use pio, only : file_desc_t, pio_inq_varid, io_desc_t, pio_internal_error, &
         pio_bcast_error, pio_noerr, pio_inq_dimid, pio_seterrorhandling, pio_get_var
    use cam_pio_utils, only : get_phys_decomp

    type(File_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    type(physics_buffer_desc), pointer :: pbufhdr(:)

    integer :: mdimsize
    integer :: index
    integer :: dtype


    type(io_desc_t), pointer                :: iodesc=>null()
    integer :: ierr, lchnk, c
    integer :: dimsizes(6)
    integer :: ndims, k

    call pbuf_initialize(pbuf2d)
    
    pbufhdr=> pbuf_get_chunk(pbuf2d,begchunk)

    ierr = pio_inq_varid(File, 'pbuf_time_idx', timeidx_desc)
    ierr = pio_get_var(File, timeidx_desc, old_time_idx)

    do index=1,currentpbufflds

       if(pbufhdr(index)%hdr%persistance == persistance_physpkg) cycle
       dimsizes=pbufhdr(index)%hdr%dimsizes

       ierr = pio_inq_varid(File, trim(pbufhdr(index)%hdr%name), pbufhdr(index)%hdr%vardesc)
       ndims=0
       do k=1,6
          if(dimsizes(k)==1) then
             exit
          end if
          ndims=ndims+1
       end do
       mdimsize=product(dimsizes(2:))

       dtype = pbufhdr(index)%hdr%dtype

       call get_phys_decomp(iodesc, 1, mdimsize, 1, pbuftype2piotype(dtype))


       select case(dtype)
       case(TYPEDOUBLE)
          select case(ndims)
          case(1)
             call pio_read_restart_field_1d_double(File, pbuf2d, index, iodesc, dimsizes)
          case(2)
             call pio_read_restart_field_2d_double(File, pbuf2d, index, iodesc, dimsizes)
          case(3)
             call pio_read_restart_field_3d_double(File, pbuf2d, index, iodesc, dimsizes)
          case(4)
             call pio_read_restart_field_4d_double(File, pbuf2d, index, iodesc, dimsizes)
          case(5)
             call pio_read_restart_field_5d_double(File, pbuf2d, index, iodesc, dimsizes)
          case(6)
             call pio_read_restart_field_6d_double(File, pbuf2d, index, iodesc, dimsizes)
          end select
       case(TYPEREAL)
          select case(ndims)
          case(1)
             call pio_read_restart_field_1d_real(File, pbuf2d, index, iodesc, dimsizes)
          case(2)
             call pio_read_restart_field_2d_real(File, pbuf2d, index, iodesc, dimsizes)
          case(3)
             call pio_read_restart_field_3d_real(File, pbuf2d, index, iodesc, dimsizes)
          case(4)
             call pio_read_restart_field_4d_real(File, pbuf2d, index, iodesc, dimsizes)
          case(5)
             call pio_read_restart_field_5d_real(File, pbuf2d, index, iodesc, dimsizes)
          case(6)
             call pio_read_restart_field_6d_real(File, pbuf2d, index, iodesc, dimsizes)
          end select
       case(TYPEINT)
          select case(ndims)
          case(1)
             call pio_read_restart_field_1d_int(File, pbuf2d, index, iodesc, dimsizes)
          case(2)
             call pio_read_restart_field_2d_int(File, pbuf2d, index, iodesc, dimsizes)
          case(3)
             call pio_read_restart_field_3d_int(File, pbuf2d, index, iodesc, dimsizes)
          case(4)
             call pio_read_restart_field_4d_int(File, pbuf2d, index, iodesc, dimsizes)
          case(5)
             call pio_read_restart_field_5d_int(File, pbuf2d, index, iodesc, dimsizes)
          case(6)
             call pio_read_restart_field_6d_int(File, pbuf2d, index, iodesc, dimsizes)
          end select
       case default
       end select

    end do

  end subroutine pbuf_read_restart

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_1d_int (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    integer(i4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_1d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_2d_int (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    integer(i4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_2d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_3d_int (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    integer(i4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_3d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_4d_int (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    integer(i4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_4d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_5d_int (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    integer(i4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_5d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_6d_int (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    integer(i4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_6d_int

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_1d_double (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r8), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_1d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_2d_double (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r8), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_2d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_3d_double (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r8), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_3d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_4d_double (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r8), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_4d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_5d_double (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r8), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_5d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_6d_double (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r8), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_6d_double

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_1d_real (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_1d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_2d_real (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_2d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_3d_real (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_3d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_4d_real (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_4d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_5d_real (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_5d_real

  ! TYPE int,double,real 
  ! DIMS 1,2,3,4,5,6
# 1234 "physics_buffer.F90.in"
  subroutine pio_read_restart_field_6d_real (File, pbuf2d, index, iodesc, dimsizes)
    use pio, only : file_desc_t, pio_read_darray,  io_desc_t
    type(file_desc_t) :: File
    type(physics_buffer_desc), pointer :: pbuf2d(:,:)
    integer, intent(in) :: index
    integer, intent(in) :: dimsizes(:)
    type(io_desc_t) :: iodesc
    integer :: ierr, c
    real(r4), pointer :: fld7(:,:,:,:,:,:,:)

    allocate(fld7(dimsizes(1),dimsizes(2),dimsizes(3),dimsizes(4),dimsizes(5),dimsizes(6),begchunk:endchunk))
    call pio_read_darray(File, pbuf2d(index,begchunk)%hdr%vardesc, iodesc, fld7, ierr)
    do c=begchunk,endchunk
       call buffer_set_field(pbuf2d(index,c)%bfg, fld7(:,:,:,:,:,:,c))
    end do

    deallocate(fld7)

  end subroutine pio_read_restart_field_6d_real





end module physics_buffer
