module EDCLMLinkMod

  ! ============================================================================
  ! Modules to control the passing of infomation generated by ED into CLM to be used for either 
  ! diagnostics, or as input to the land surface components. 
  ! ============================================================================

  use shr_kind_mod     , only : r8 => shr_kind_r8;
  use decompMod        , only : bounds_type
  use clm_varpar       , only : nclmax, nlevcan_ed, numpft, numcft, mxpft
  use clm_varctl       , only : iulog 

  use EDtypesMod       , only : ed_site_type, ed_cohort_type, ed_patch_type
  use EDtypesMod       , only : sclass_ed,nlevsclass_ed,AREA
  use EDParamsMod      , only : ED_val_ag_biomass
  use EDtypesMod       , only : ncwd
  use CanopyStateType  , only : canopystate_type
  use clm_varctl       , only : use_vertsoilc

  !
  implicit none
  private
  !
  logical :: DEBUG = .false.  ! for debugging this module (EDCLMLinkMod.F90)
  
  ! !PUBLIC DATA MEMBERS 
  real(r8), public :: cwd_fcel_ed  
  real(r8), public :: cwd_flig_ed

  type, public :: ed_clm_type

     real(r8), pointer, private  :: trimming_patch             (:) 
     real(r8), pointer, private  :: area_plant_patch           (:) 
     real(r8), pointer, private  :: area_trees_patch           (:) 
     real(r8), pointer, private  :: canopy_spread_patch        (:) 
     real(r8), pointer, private  :: PFTbiomass_patch           (:,:) ! total biomass of each patch
     real(r8), pointer, private  :: PFTleafbiomass_patch       (:,:) ! total biomass of each patch   
     real(r8), pointer, private  :: PFTstorebiomass_patch      (:,:) ! total biomass of each patch   
     real(r8), pointer, private  :: PFTnindivs_patch           (:,:) ! total biomass of each patch 

     real(r8), pointer, private  :: nesterov_fire_danger_patch (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: spitfire_ROS_patch         (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: effect_wspeed_patch        (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: TFC_ROS_patch              (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: fire_intensity_patch       (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: fire_area_patch            (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: scorch_height_patch        (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: fire_fuel_bulkd_patch      (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: fire_fuel_eff_moist_patch  (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: fire_fuel_sav_patch        (:)   ! total biomass of each patch       
     real(r8), pointer, private  :: fire_fuel_mef_patch        (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: sum_fuel_patch             (:)   ! total biomass of each patch 

     real(r8), pointer, private  :: litter_in_patch            (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: litter_out_patch           (:)   ! total biomass of each patch    
     real(r8), pointer, private  :: efpot_patch                (:)   ! potential transpiration
     real(r8), pointer, private  :: rb_patch                   (:)   ! boundary layer conductance

     real(r8), pointer, private  :: daily_temp_patch           (:)   ! daily temperature for fire and phenology models
     real(r8), pointer, private  :: daily_rh_patch             (:)   ! daily RH for fire model
     real(r8), pointer, private  :: daily_prec_patch           (:)   ! daily rain for fire and phenology models. 

     !seed model. Aggregated to gridcell for now. 

     real(r8), pointer, private  :: seed_bank_patch            (:)   ! kGC/m2      Mass of seeds.                 
     real(r8), pointer, private  :: seeds_in_patch             (:)   ! kGC/m2/year Production of seed mass.       
     real(r8), pointer, private  :: seed_decay_patch           (:)   ! kGC/m2/year Decay of seed mass.            
     real(r8), pointer, private  :: seed_germination_patch     (:)   ! kGC/m2/year Germiantion rate of seed mass. 

     real(r8), pointer, private  :: ED_bstore_patch            (:)   ! kGC/m2 Total stored biomass. 
     real(r8), pointer, private  :: ED_bdead_patch             (:)   ! kGC/m2 Total dead biomass.   
     real(r8), pointer, private  :: ED_balive_patch            (:)   ! kGC/m2 Total alive biomass.  
     real(r8), pointer, private  :: ED_bleaf_patch             (:)   ! kGC/m2 Total leaf biomass.   
     real(r8), pointer, private  :: ED_biomass_patch           (:)   ! kGC/m2 Total biomass.        

     real(r8), pointer, private  :: storvegc_patch             (:)   ! (gC/m2) stored vegetation carbon, excluding cpool
     real(r8), pointer, private  :: dispvegc_patch             (:)   ! (gC/m2) displayed veg carbon, excluding storage and cpool
     real(r8), pointer, private  :: leafc_patch                (:)   ! (gC/m2) leaf C
     real(r8), pointer, private  :: livestemc_patch            (:)   ! (gC/m2) live stem C
     real(r8), pointer, private  :: deadstemc_patch            (:)   ! (gC/m2) dead stem C
     real(r8), pointer, private  :: livestemn_patch            (:)   ! (gN/m2) live stem N
     real(r8), pointer, private  :: npp_patch                  (:)   ! (gC/m2/s) patch net primary production
     real(r8), pointer, private  :: gpp_patch                  (:)   ! (gC/m2/s) patch gross primary production 

     ! ED currently does not differentiate stems of any size in regards to tracking biomass or fluxes
     ! within a cohort
     ! ED currently does not include stems in the seasonal litter cycling of live trees (only leaves)
     ! coarse roots should be calculated as the sum of non-fine belowground terms: bswd and bdwd
     
     ! Carbon Flux Variables - dimensions: (grid cell, pft x size)
     ! Note that npp fluxes account only from carbon that is available following gpp and respiration
     ! these fluxes do not account for cross-pool transfers, such as using storage or alive biomass
     ! to help with maintenance demand
     ! =============================================================================================
 
     real(r8), pointer :: ed_gpp_gd_scpf          (:,:)   ! [kg/m2/yr] gross primary production
     real(r8), pointer :: ed_npp_totl_gd_scpf     (:,:)   ! [kg/m2/yr] net primary production (npp)
     real(r8), pointer :: ed_npp_leaf_gd_scpf     (:,:)   ! [kg/m2/yr] npp flux into leaf pool
     real(r8), pointer :: ed_npp_seed_gd_scpf     (:,:)   ! [kg/m2/yr] npp flux into flower,fruit,nut,seed
     real(r8), pointer :: ed_npp_fnrt_gd_scpf     (:,:)   ! [kg/m2/yr] npp flux into fine roots
     real(r8), pointer :: ed_npp_bgsw_gd_scpf     (:,:)   ! [kg/m2/yr] npp flux into below ground sapwood
     real(r8), pointer :: ed_npp_bgdw_gd_scpf     (:,:)   ! [kg/m2/yr] npp flux into below ground structural (dead) wood
     real(r8), pointer :: ed_npp_agsw_gd_scpf     (:,:)   ! [kg/m2/yr] npp flux into above ground sapwood
     real(r8), pointer :: ed_npp_agdw_gd_scpf     (:,:)   ! [kg/m2/yr] npp flux into below ground structural (dead) wood
     real(r8), pointer :: ed_npp_stor_gd_scpf     (:,:)   ! [kg/m2/yr] npp flux through the storage pool
     real(r8), pointer :: ed_litt_leaf_gd_scpf    (:,:)   ! [kg/m2/yr] carbon flux of live leaves to litter
     real(r8), pointer :: ed_litt_fnrt_gd_scpf    (:,:)   ! [kg/m2/yr] carbon flux of fine roots to litter
     real(r8), pointer :: ed_litt_sawd_gd_scpf    (:,:)   ! [kg/m2/yr] carbon flux of sapwood to litter (above+below)
     real(r8), pointer :: ed_litt_ddwd_gd_scpf    (:,:)   ! [kg/m2/yr] carbon flux of dead wood (above+below) to litter
     real(r8), pointer :: ed_r_leaf_gd_scpf       (:,:)   ! [kg/m2/yr] total leaf respiration 
     real(r8), pointer :: ed_r_stem_gd_scpf       (:,:)   ! [kg/m2/yr] total above ground live wood (stem) respiration
     real(r8), pointer :: ed_r_root_gd_scpf       (:,:)   ! [kg/m2/yr] total below ground live wood (root) respiration
     real(r8), pointer :: ed_r_stor_gd_scpf       (:,:)   ! [kg/m2/yr] total storage respiration
     
     ! Carbon State Variables for direct comparison to inventory - dimensions: (disturbance patch, pft x size)
     
     real(r8), pointer :: ed_ddbh_gd_scpf               (:,:) ! [cm/yr] diameter increment
     real(r8), pointer :: ed_ba_gd_scpf                 (:,:) ! [m2/ha] basal area
     real(r8), pointer :: ed_np_gd_scpf                 (:,:) ! [/m2] number of plants
     real(r8), pointer :: ed_m1_gd_scpf                 (:,:) ! [Stems/ha/yr] Mean Background Mortality
     real(r8), pointer :: ed_m2_gd_scpf                 (:,:) ! [Stems/ha/yr] Mean Hydraulic Mortaliry rate
     real(r8), pointer :: ed_m3_gd_scpf                 (:,:) ! [Stems/ha/yr] Mean Carbon Starvation Mortality rate
     real(r8), pointer :: ed_m4_gd_scpf                 (:,:) ! [Stems/ha/yr] Mean Impact Mortality Rate
     real(r8), pointer :: ed_m5_gd_scpf                 (:,:) ! [Stems/ha/yr] Mean Fire Mortality Rate     

     ! litterfall fluxes of C from ED patches to BGC columns

     real(r8), pointer,  public :: ED_c_to_litr_lab_c_col(:,:)      !total labile    litter coming from ED. gC/m3/s
     real(r8), pointer,  public :: ED_c_to_litr_cel_c_col(:,:)      !total cellulose litter coming from ED. gC/m3/s
     real(r8), pointer,  public :: ED_c_to_litr_lig_c_col(:,:)      !total lignin    litter coming from ED. gC/m3/s
     real(r8), pointer, private :: leaf_prof_col(:,:)               !(1/m) profile of leaves                         
     real(r8), pointer, private :: froot_prof_col(:,:,:)            !(1/m) profile of fine roots                     
     real(r8), pointer, private :: croot_prof_col(:,:)              !(1/m) profile of coarse roots                         
     real(r8), pointer, private :: stem_prof_col(:,:)               !(1/m) profile of leaves                         


   contains

     ! Public routines
     procedure , public  :: Init   
     procedure , public  :: Restart
     procedure , public  :: SetValues
     procedure , public  :: ed_clm_link

     ! Private routines
     procedure , private :: ed_clm_leaf_area_profile
     procedure , private :: ed_update_history_variables
     procedure , private :: InitAllocate 
     procedure , private :: InitHistory
     procedure , private :: InitCold    
     procedure , private :: flux_into_litter_pools

  end type ed_clm_type

  ! 10/30/09: Created by Rosie Fisher
  !-----------------------------------------------------------------------

contains

  !------------------------------------------------------------------------
  subroutine Init(this, bounds)
    !
    ! !DESCRIPTION:
    ! Initialize module data structure instance
    !
    ! !ARGUMENTS:
    class(ed_clm_type) :: this
    type(bounds_type), intent(in) :: bounds  
    !-----------------------------------------------------------------------

    call this%InitAllocate(bounds)
    call this%InitHistory(bounds)
    call this%InitCold(bounds)

  end subroutine Init

  !------------------------------------------------------------------------
  subroutine InitAllocate(this, bounds)
    !
    ! !USES: 
    use shr_infnan_mod , only : nan => shr_infnan_nan, assignment(=)
    use clm_varpar     , only : nlevgrnd, nlevdecomp_full
    use EDtypesMod     , only : numpft_ed
    !
    ! !ARGUMENTS:
    class (ed_clm_type) :: this 
    type(bounds_type), intent(in)    :: bounds 
    !
    ! !LOCAL VARIABLES:
    integer           :: begp,endp
    integer           :: begg,endg
    integer           :: begc,endc                                    !bounds 

    !------------------------------------------------------------------------

    begp = bounds%begp; endp = bounds%endp
    begc = bounds%begc; endc = bounds%endc
    begg = bounds%begg; endg = bounds%endg

    allocate(this%trimming_patch             (begp:endp))            ; this%trimming_patch             (:) = 0.0_r8    
    allocate(this%canopy_spread_patch        (begp:endp))            ; this%canopy_spread_patch        (:) = 0.0_r8    
    allocate(this%area_plant_patch           (begp:endp))            ; this%area_plant_patch           (:) = 0.0_r8    
    allocate(this%area_trees_patch           (begp:endp))            ; this%area_trees_patch           (:) = 0.0_r8    
    allocate(this%PFTbiomass_patch           (begp:endp,1:nlevgrnd)) ; this%PFTbiomass_patch           (:,:) = 0.0_r8    
    allocate(this%PFTleafbiomass_patch       (begp:endp,1:nlevgrnd)) ; this%PFTleafbiomass_patch       (:,:) = 0.0_r8    
    allocate(this%PFTstorebiomass_patch      (begp:endp,1:nlevgrnd)) ; this%PFTstorebiomass_patch      (:,:) = 0.0_r8    
    allocate(this%PFTnindivs_patch           (begp:endp,1:nlevgrnd)) ; this%PFTnindivs_patch           (:,:) = 0.0_r8    
    allocate(this%nesterov_fire_danger_patch (begp:endp))            ; this%nesterov_fire_danger_patch (:) = 0.0_r8    
    allocate(this%spitfire_ROS_patch         (begp:endp))            ; this%spitfire_ROS_patch         (:) = 0.0_r8    
    allocate(this%effect_wspeed_patch        (begp:endp))            ; this%effect_wspeed_patch        (:) = 0.0_r8    
    allocate(this%TFC_ROS_patch              (begp:endp))            ; this%TFC_ROS_patch              (:) = 0.0_r8    
    allocate(this%fire_intensity_patch       (begp:endp))            ; this%fire_intensity_patch       (:) = 0.0_r8    
    allocate(this%fire_area_patch            (begp:endp))            ; this%fire_area_patch            (:) = 0.0_r8    
    allocate(this%scorch_height_patch        (begp:endp))            ; this%scorch_height_patch        (:) = 0.0_r8    
    allocate(this%fire_fuel_bulkd_patch      (begp:endp))            ; this%fire_fuel_bulkd_patch      (:) = 0.0_r8    
    allocate(this%fire_fuel_eff_moist_patch  (begp:endp))            ; this%fire_fuel_eff_moist_patch  (:) = 0.0_r8    
    allocate(this%fire_fuel_sav_patch        (begp:endp))            ; this%fire_fuel_sav_patch        (:) = 0.0_r8    
    allocate(this%fire_fuel_mef_patch        (begp:endp))            ; this%fire_fuel_mef_patch        (:) = 0.0_r8    
    allocate(this%sum_fuel_patch             (begp:endp))            ; this%sum_fuel_patch             (:) = 0.0_r8    
    allocate(this%litter_in_patch            (begp:endp))            ; this%litter_in_patch            (:) = 0.0_r8    
    allocate(this%litter_out_patch           (begp:endp))            ; this%litter_out_patch           (:) = 0.0_r8    
    allocate(this%efpot_patch                (begp:endp))            ; this%efpot_patch                (:) = 0.0_r8    
    allocate(this%rb_patch                   (begp:endp))            ; this%rb_patch                   (:) = 0.0_r8    
    allocate(this%seed_bank_patch            (begp:endp))            ; this%seed_bank_patch            (:) = 0.0_r8    
    allocate(this%seed_decay_patch           (begp:endp))            ; this%seed_decay_patch           (:) = 0.0_r8    
    allocate(this%seeds_in_patch             (begp:endp))            ; this%seeds_in_patch             (:) = 0.0_r8    
    allocate(this%seed_germination_patch     (begp:endp))            ; this%seed_germination_patch     (:) = 0.0_r8    
    allocate(this%ED_bstore_patch            (begp:endp))            ; this%ED_bstore_patch            (:) = 0.0_r8    
    allocate(this%ED_bdead_patch             (begp:endp))            ; this%ED_bdead_patch             (:) = 0.0_r8    
    allocate(this%ED_balive_patch            (begp:endp))            ; this%ED_balive_patch            (:) = 0.0_r8    
    allocate(this%ED_bleaf_patch             (begp:endp))            ; this%ED_bleaf_patch             (:) = 0.0_r8    
    allocate(this%ED_biomass_patch           (begp:endp))            ; this%ED_biomass_patch           (:) = 0.0_r8    

    allocate(this%storvegc_patch             (begp:endp))            ; this%storvegc_patch             (:) = nan
    allocate(this%dispvegc_patch             (begp:endp))            ; this%dispvegc_patch             (:) = nan
    allocate(this%leafc_patch                (begp:endp))            ; this%leafc_patch                (:) = nan
    allocate(this%livestemc_patch            (begp:endp))            ; this%livestemc_patch            (:) = nan
    allocate(this%deadstemc_patch            (begp:endp))            ; this%deadstemc_patch            (:) = nan
    allocate(this%livestemn_patch            (begp:endp))            ; this%livestemn_patch            (:) = nan

    allocate(this%gpp_patch                  (begp:endp))            ; this%gpp_patch                  (:) = nan
    allocate(this%npp_patch                  (begp:endp))            ; this%npp_patch                  (:) = nan

    allocate(this%ed_gpp_gd_scpf       (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_gpp_gd_scpf        (:,:) = 0.0_r8
    allocate(this%ed_npp_totl_gd_scpf  (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_npp_totl_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_npp_leaf_gd_scpf  (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_npp_leaf_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_npp_seed_gd_scpf  (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_npp_seed_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_npp_fnrt_gd_scpf  (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_npp_fnrt_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_npp_bgsw_gd_scpf  (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_npp_bgsw_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_npp_bgdw_gd_scpf  (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_npp_bgdw_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_npp_agsw_gd_scpf  (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_npp_agsw_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_npp_agdw_gd_scpf  (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_npp_agdw_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_npp_stor_gd_scpf  (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_npp_stor_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_litt_leaf_gd_scpf (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_litt_leaf_gd_scpf  (:,:) = 0.0_r8
    allocate(this%ed_litt_fnrt_gd_scpf (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_litt_fnrt_gd_scpf  (:,:) = 0.0_r8
    allocate(this%ed_litt_sawd_gd_scpf (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_litt_sawd_gd_scpf  (:,:) = 0.0_r8 
    allocate(this%ed_litt_ddwd_gd_scpf (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_litt_ddwd_gd_scpf  (:,:) = 0.0_r8
    allocate(this%ed_r_leaf_gd_scpf    (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_r_leaf_gd_scpf     (:,:) = 0.0_r8
    allocate(this%ed_r_stem_gd_scpf    (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_r_stem_gd_scpf     (:,:) = 0.0_r8
    allocate(this%ed_r_root_gd_scpf    (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_r_root_gd_scpf     (:,:) = 0.0_r8
    allocate(this%ed_r_stor_gd_scpf    (begg:endg,1:nlevsclass_ed*mxpft));  this%ed_r_stor_gd_scpf     (:,:) = 0.0_r8
    
    ! Carbon State Variables for direct comparison to inventory - dimensions: (disturbance patch, pft x size)
    allocate(this%ed_ddbh_gd_scpf (begg:endg,1:nlevsclass_ed*mxpft)) ; this%ed_ddbh_gd_scpf (:,:) = 0.0_r8
    allocate(this%ed_ba_gd_scpf   (begg:endg,1:nlevsclass_ed*mxpft)) ; this%ed_ba_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_np_gd_scpf   (begg:endg,1:nlevsclass_ed*mxpft)) ; this%ed_np_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_m1_gd_scpf   (begg:endg,1:nlevsclass_ed*mxpft)) ; this%ed_m1_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_m2_gd_scpf   (begg:endg,1:nlevsclass_ed*mxpft)) ; this%ed_m2_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_m3_gd_scpf   (begg:endg,1:nlevsclass_ed*mxpft)) ; this%ed_m3_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_m4_gd_scpf   (begg:endg,1:nlevsclass_ed*mxpft)) ; this%ed_m4_gd_scpf   (:,:) = 0.0_r8
    allocate(this%ed_m5_gd_scpf   (begg:endg,1:nlevsclass_ed*mxpft)) ; this%ed_m5_gd_scpf   (:,:) = 0.0_r8

    allocate(this%ED_c_to_litr_lab_c_col     (begc:endc,1:nlevdecomp_full))            ; this%ED_c_to_litr_lab_c_col     (:,:) = nan
    allocate(this%ED_c_to_litr_cel_c_col     (begc:endc,1:nlevdecomp_full))            ; this%ED_c_to_litr_cel_c_col     (:,:) = nan
    allocate(this%ED_c_to_litr_lig_c_col     (begc:endc,1:nlevdecomp_full))            ; this%ED_c_to_litr_lig_c_col     (:,:) = nan

    allocate(this%leaf_prof_col              (begc:endc,1:nlevdecomp_full))            ; this%leaf_prof_col              (:,:) = nan
    allocate(this%froot_prof_col             (begc:endc,1:numpft_ed,1:nlevdecomp_full)); this%froot_prof_col             (:,:,:) = nan
    allocate(this%croot_prof_col             (begc:endc,1:nlevdecomp_full))            ; this%croot_prof_col             (:,:) = nan
    allocate(this%stem_prof_col              (begc:endc,1:nlevdecomp_full))            ; this%stem_prof_col              (:,:) = nan


  end subroutine InitAllocate

  !------------------------------------------------------------------------
  subroutine InitHistory(this, bounds)
    !
    ! !DESCRIPTION:
    ! add history fields for all variables, always set as default='inactive'
    !
    ! !USES:
    use clm_varpar , only : ndecomp_cascade_transitions, ndecomp_pools
    use clm_varpar , only : nlevdecomp, nlevdecomp_full, crop_prog
    use clm_varcon , only : spval
    use histFileMod, only : hist_addfld1d, hist_addfld2d, hist_addfld_decomp 
    !
    ! !ARGUMENTS:
    class(ed_clm_type) :: this    
    type(bounds_type)         , intent(in) :: bounds 
    !
    ! !LOCAL VARIABLES:
    integer           :: k,l,ii,jj 
    character(8)      :: vr_suffix
    character(10)     :: active
    integer           :: begp,endp
    integer           :: begc,endc
    character(24)     :: fieldname
    character(100)    :: longname
    real(r8), pointer :: data1dptr(:)   ! temp. pointer for slicing larger arrays
    !---------------------------------------------------------------------

    begp = bounds%begp; endp = bounds%endp
    begc = bounds%begc; endc = bounds%endc

    call hist_addfld1d (fname='TRIMMING', units='none',  &
         avgflag='A', long_name='Degree to which canopy expansion is limited by leaf economics', &
         ptr_patch=this%trimming_patch, set_lake=0._r8, set_urb=0._r8)  

    call hist_addfld1d (fname='AREA_PLANT', units='m2',  &
         avgflag='A', long_name='area occupied by all plants', &
         ptr_patch=this%area_plant_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='AREA_TREES', units='m2',  &
         avgflag='A', long_name='area occupied by woody plants', &
         ptr_patch=this%area_trees_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='CANOPY_SPREAD', units='none',  &   
         avgflag='A', long_name='Scaling factor between tree basal area and canopy area', &
         ptr_patch=this%canopy_spread_patch, set_lake=0._r8, set_urb=0._r8)   

    call hist_addfld2d (fname='PFTbiomass',  units='kgC/m2', type2d='levgrnd', &
         avgflag='A', long_name='total PFT level biomass', &
         ptr_patch=this%PFTbiomass_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld2d (fname='PFTleafbiomass',  units='kgC/m2', type2d='levgrnd', &
         avgflag='A', long_name='total PFT level biomass', &
         ptr_patch=this%PFTleafbiomass_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld2d (fname='PFTstorebiomass',  units='kgC/m2', type2d='levgrnd', &
         avgflag='A', long_name='total PFT level biomass', &
         ptr_patch=this%PFTstorebiomass_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld2d (fname='PFTnindivs',  units='kgC/m2', type2d='levgrnd', &
         avgflag='A', long_name='total PFT level biomass', &
         ptr_patch=this%PFTnindivs_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='FIRE_NESTEROV_INDEX', units='none',  &
         avgflag='A', long_name='nesterov_fire_danger index', &
         ptr_patch=this%nesterov_fire_danger_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='FIRE_ROS', units='m/min',  &
         avgflag='A', long_name='fire rate of spread m/min', &
         ptr_patch=this%spitfire_ROS_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='EFFECT_WSPEED', units='none',  &
         avgflag='A', long_name='effective windspeed for fire spread', &
         ptr_patch=this%effect_wspeed_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='FIRE_TFC_ROS', units='none',  &
         avgflag='A', long_name='total fuel consumed', &
         ptr_patch=this%TFC_ROS_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='FIRE_INTENSITY', units='kJ/m/s',  &
         avgflag='A', long_name='spitfire fire intensity: kJ/m/s', &
         ptr_patch=this%fire_intensity_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='FIRE_AREA', units='fraction',  &
         avgflag='A', long_name='spitfire fire area:m2', &
         ptr_patch=this%fire_area_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SCORCH_HEIGHT', units='m',  &
         avgflag='A', long_name='spitfire fire area:m2', &
         ptr_patch=this%scorch_height_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='fire_fuel_mef', units='m',  &
         avgflag='A', long_name='spitfire fuel moisture', &
         ptr_patch=this%fire_fuel_mef_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='fire_fuel_bulkd', units='m',  &
         avgflag='A', long_name='spitfire fuel bulk density', &
         ptr_patch=this%fire_fuel_bulkd_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='fire_fuel_eff_moist', units='m',  &
         avgflag='A', long_name='spitfire fuel moisture', &
         ptr_patch=this%fire_fuel_eff_moist_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='fire_fuel_sav', units='m',  &
         avgflag='A', long_name='spitfire fuel surface/volume ', &
         ptr_patch=this%fire_fuel_sav_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='TFC_ROS', units='m',  &
         avgflag='A', long_name='spitfire fuel surface/volume ', &
         ptr_patch=this%TFC_ROS_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SUM_FUEL', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Litter flux in leaves', &
         ptr_patch=this%sum_fuel_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='LITTER_IN', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Litter flux in leaves', &
         ptr_patch=this%litter_in_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='LITTER_OUT', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Litter flux out leaves', &
         ptr_patch=this%litter_out_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SEED_BANK', units=' KgC m-2',  &
         avgflag='A', long_name='Total Seed Mass of all PFTs', &
         ptr_patch=this%seed_bank_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SEEDS_IN', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Seed Production Rate', &
         ptr_patch=this%seeds_in_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SEED_GERMINATION', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Seed mass converted into new cohorts', &
         ptr_patch=this%seed_germination_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SEED_DECAY', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Seed mass decay', &
         ptr_patch=this%seed_decay_patch, set_lake=0._r8, set_urb=0._r8)              

    call hist_addfld1d (fname='ED_bstore', units=' KgC m-2',  &
         avgflag='A', long_name='ED stored biomass', &
         ptr_patch=this%ED_bstore_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='ED_bdead', units=' KgC m-2',  &
         avgflag='A', long_name='ED dead biomass', &
         ptr_patch=this%ED_bdead_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='ED_balive', units=' KgC m-2',  &
         avgflag='A', long_name='ED live biomass', &
         ptr_patch=this%ED_balive_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='ED_bleaf', units=' KgC m-2',  &
         avgflag='A', long_name='ED leaf biomass', &
         ptr_patch=this%ED_bleaf_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='ED_biomass', units=' KgC m-2',  &
         avgflag='A', long_name='ED total biomass', &
         ptr_patch=this%ED_biomass_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='RB', units=' s m-1',  &
         avgflag='A', long_name='leaf boundary resistance', &
         ptr_patch=this%rb_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='EFPOT', units='',  &
         avgflag='A', long_name='potential evap', &
         ptr_patch=this%efpot_patch, set_lake=0._r8, set_urb=0._r8)

    this%dispvegc_patch(begp:endp) = spval
    call hist_addfld1d (fname='DISPVEGC', units='gC/m^2', &
         avgflag='A', long_name='displayed veg carbon, excluding storage and cpool', &
         ptr_patch=this%dispvegc_patch)

    this%storvegc_patch(begp:endp) = spval
    call hist_addfld1d (fname='STORVEGC', units='gC/m^2', &
         avgflag='A', long_name='stored vegetation carbon, excluding cpool', &
         ptr_patch=this%storvegc_patch)

    this%leafc_patch(begp:endp) = spval
    call hist_addfld1d (fname='LEAFC', units='gC/m^2', &
         avgflag='A', long_name='leaf C', &
         ptr_patch=this%leafc_patch)

    this%livestemc_patch(begp:endp) = spval
    call hist_addfld1d (fname='LIVESTEMC', units='gC/m^2', &
         avgflag='A', long_name='live stem C', &
         ptr_patch=this%livestemc_patch)

    this%deadstemc_patch(begp:endp) = spval
    call hist_addfld1d (fname='DEADSTEMC', units='gC/m^2', &
         avgflag='A', long_name='dead stem C', &
         ptr_patch=this%deadstemc_patch)

    this%livestemn_patch(begp:endp) = spval
    call hist_addfld1d (fname='LIVESTEMN', units='gN/m^2', &
         avgflag='A', long_name='live stem N', &
         ptr_patch=this%livestemn_patch)

    this%gpp_patch(begp:endp) = spval
    call hist_addfld1d (fname='GPP', units='gC/m^2/s', &
         avgflag='A', long_name='gross primary production', &
         ptr_patch=this%gpp_patch)

    this%npp_patch(begp:endp) = spval
    call hist_addfld1d (fname='NPP', units='gC/m^2/s', &
         avgflag='A', long_name='net primary production', &
         ptr_patch=this%npp_patch)

    ! Carbon Flux (grid dimension x scpf)
    ! ==============================================================
    
    call hist_addfld2d (fname='ED_GPP_GD_SCPF',units='kgC/m2/yr',type2d='levscpf',&
          avgflag='A', long_name='gross primary production',     &
          ptr_gcell=this%ed_gpp_gd_scpf,default='inactive')
    
    call hist_addfld2d (fname='ED_NPP_LEAF_GD_SCPF',units='kgC/m2/yr',type2d='levscpf',&
          avgflag='A', long_name='NPP flux into leaves',               &  
          ptr_gcell=this%ed_npp_leaf_gd_scpf,default='inactive')
    
    call hist_addfld2d (fname='ED_NPP_SEED_GD_SCPF',units='kgC/m2/yr',type2d='levscpf',&
          avgflag='A', long_name='NPP flux into seeds',                &
          ptr_gcell=this%ed_npp_seed_gd_scpf,default='inactive')
    
    call hist_addfld2d (fname='ED_NPP_FNRT_GD_SCPF',units='kgC/m2/yr',type2d='levscpf',&
          avgflag='A', long_name='NPP flux into fine roots',           &
          ptr_gcell=this%ed_npp_fnrt_gd_scpf,default='inactive')
    
    call hist_addfld2d (fname='ED_NPP_BGSW_GD_SCPF',units='kgC/m2/yr',type2d='levscpf',&
          avgflag='A', long_name='NPP flux into below-ground sapwood', &
          ptr_gcell=this%ed_npp_bgsw_gd_scpf,default='inactive')
    
    call hist_addfld2d (fname='ED_NPP_BGDW_GD_SCPF',units='kgC/m2/yr',type2d='levscpf',&
          avgflag='A', long_name='NPP flux into below-ground deadwood', &
          ptr_gcell=this%ed_npp_bgdw_gd_scpf,default='inactive')
    
    call hist_addfld2d (fname='ED_NPP_AGSW_GD_SCPF',units='kgC/m2/yr',type2d='levscpf',&
          avgflag='A', long_name='NPP flux into above-ground sapwood',  &
          ptr_gcell=this%ed_npp_agsw_gd_scpf,default='inactive')
    
    call hist_addfld2d ( fname = 'ED_NPP_AGDW_GD_SCPF', units='kgC/m2/yr',type2d='levscpf',&
          avgflag='A', long_name='NPP flux into above-ground deadwood', &
          ptr_gcell=this%ed_npp_agdw_gd_scpf,default='inactive')
    
    call hist_addfld2d ( fname = 'ED_NPP_STOR_GD_SCPF', units='kgC/m2/yr',type2d='levscpf',&
          avgflag='A', long_name='NPP flux into storage',          &
          ptr_gcell=this%ed_npp_stor_gd_scpf,default='inactive')

    call hist_addfld2d (fname='ED_DDBH_GD_SCPF', units = 'cm/yr/ha', type2d = 'levscpf', &
          avgflag='A', long_name='diameter growth increment and pft/size', &
          ptr_gcell=this%ed_ddbh_gd_scpf, default='inactive')

    call hist_addfld2d (fname='ED_BA_GD_SCPF',units = 'm2/ha', type2d = 'levscpf', &
          avgflag='A', long_name='basal area by patch and pft/size', &
          ptr_gcell=this%ed_ba_gd_scpf, default='inactive')
    
    call hist_addfld2d (fname='ED_NPLANT_GD_SCPF',units = 'N/ha', type2d = 'levscpf', &
          avgflag='A', long_name='stem number density by patch and pft/size', &
          ptr_gcell=this%ed_np_gd_scpf, default='inactive')
    
    call hist_addfld2d (fname='ED_M1_GD_SCPF',units = 'N/ha/yr', type2d = 'levscpf', &
          avgflag='A', long_name='background mortality rate by patch and pft/size', &
          ptr_gcell=this%ed_m1_gd_scpf, default='inactive')
    
    call hist_addfld2d (fname='ED_M2_GD_SCPF',units = 'N/ha/yr', type2d = 'levscpf', &
          avgflag='A', long_name='hydraulic mortality rate by patch and pft/size', &
          ptr_gcell=this%ed_m2_gd_scpf, default='inactive')
    
    call hist_addfld2d (fname='ED_M3_GD_SCPF',units = 'N/ha/yr', type2d = 'levscpf', &
          avgflag='A', long_name='carbon starvation mortality rate by patch and pft/size', &
          ptr_gcell=this%ed_m3_gd_scpf, default='inactive')
    
    call hist_addfld2d (fname='ED_M4_GD_SCPF',units = 'N/ha/yr', type2d = 'levscpf', &
          avgflag='A', long_name='impact mortality rate by patch and pft/size', &
          ptr_gcell=this%ed_m4_gd_scpf, default='inactive')
    
    call hist_addfld2d (fname='ED_M5_GD_SCPF',units = 'N/ha/yr', type2d = 'levscpf', &
          avgflag='A', long_name='fire mortality rate by patch and pft/size', &
          ptr_gcell=this%ed_m5_gd_scpf, default='inactive')

    call hist_addfld_decomp (fname='ED_c_to_litr_lab_c',  units='gC/m^2/s', type2d='levdcmp', &
         avgflag='A', long_name='ED_c_to_litr_lab_c', &
         ptr_col=this%ED_c_to_litr_lab_c_col)

    call hist_addfld_decomp (fname='ED_c_to_litr_cel_c',  units='gC/m^2/s', type2d='levdcmp', &
         avgflag='A', long_name='ED_c_to_litr_cel_c', &
         ptr_col=this%ED_c_to_litr_cel_c_col)

    call hist_addfld_decomp (fname='ED_c_to_litr_lig_c',  units='gC/m^2/s', type2d='levdcmp', &
         avgflag='A', long_name='ED_c_to_litr_lig_c', &
         ptr_col=this%ED_c_to_litr_lig_c_col)

    call hist_addfld_decomp (fname='leaf_prof',  units='1/m', type2d='levdcmp', &
         avgflag='A', long_name='leaf_prof', &
         ptr_col=this%leaf_prof_col)

    call hist_addfld_decomp (fname='croot_prof',  units='1/m', type2d='levdcmp', &
         avgflag='A', long_name='croot_prof', &
         ptr_col=this%croot_prof_col)

    call hist_addfld_decomp (fname='stem_prof',  units='1/m', type2d='levdcmp', &
         avgflag='A', long_name='stem_prof', &
         ptr_col=this%stem_prof_col)


  end subroutine InitHistory

  !-----------------------------------------------------------------------
  subroutine InitCold(this, bounds)
    !
    ! !DESCRIPTION:
    ! Initialize relevant time varying variables
    !
    ! !ARGUMENTS:
    class (ed_clm_type) :: this
    type(bounds_type), intent(in) :: bounds  
    !
    ! !LOCAL VARIABLES:
    integer :: p
    !-----------------------------------------------------------------------

    do p = bounds%begp,bounds%endp
       this%dispvegc_patch(p) = 0._r8 
       this%storvegc_patch(p) = 0._r8 
    end do

  end subroutine InitCold

  !-----------------------------------------------------------------------
  subroutine Restart ( this,  bounds, ncid, flag )
    !
    ! !DESCRIPTION: 
    ! Read/write restart data 
    !
    ! !USES:
    use restUtilMod
    use ncdio_pio
    !
    ! !ARGUMENTS:
    class (ed_clm_type) :: this
    type(bounds_type) , intent(in)    :: bounds 
    type(file_desc_t) , intent(inout) :: ncid   
    character(len=*)  , intent(in)    :: flag   !'read' or 'write' or 'define'
    !
    ! !LOCAL VARIABLES:
    logical            :: readvar
    !------------------------------------------------------------------------

    call restartvar(ncid=ncid, flag=flag, varname='leafc', xtype=ncd_double,  &
         dim1name='pft', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=this%leafc_patch) 

    call restartvar(ncid=ncid, flag=flag, varname='livestemc', xtype=ncd_double,  &
         dim1name='pft', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=this%livestemc_patch) 

    call restartvar(ncid=ncid, flag=flag, varname='deadstemc', xtype=ncd_double,  &
         dim1name='pft', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=this%deadstemc_patch) 

    call restartvar(ncid=ncid, flag=flag, varname='livestemn', xtype=ncd_double,  &
         dim1name='pft', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=this%livestemn_patch) 

  end subroutine Restart

  !-----------------------------------------------------------------------
  subroutine SetValues( this, bounds, val)
    !
    ! !ARGUMENTS:
    class (ed_clm_type)            :: this
    type(bounds_type) , intent(in) :: bounds 
    real(r8)          , intent(in) :: val
    !
    ! !LOCAL VARIABLES:
    integer :: fi,i,j,k,l     ! loop index
    !-----------------------------------------------------------------------

    !
    ! FIX(SPM,082714) - commenting these lines out while merging ED branch to CLM
    ! trunk.  Commented out by RF to work out science issues
    !
    !this%trimming_patch        (:) = val
    !this%canopy_spread_patch   (:) = val
    !this%PFTbiomass_patch      (:,:) = val
    !this%PFTleafbiomass_patch  (:,:) = val
    !this%PFTstorebiomass_patch (:,:) = val
    !this%PFTnindivs_patch      (:,:) = val
    this%efpot_patch            (:) = val
    this%rb_patch               (:) = val

  end subroutine SetValues

  !-----------------------------------------------------------------------
  subroutine ed_clm_link( this, bounds, ed_allsites_inst, ed_phenology_inst, &
       waterstate_inst, canopystate_inst)
    !
    ! !USES: 
    use landunit_varcon      , only : istsoil
    use EDGrowthFunctionsMod , only : tree_lai, c_area
    use EDEcophysConType     , only : EDecophyscon
    use EDPhenologyType      , only : ed_phenology_type
    use EDtypesMod           , only : area
    use PatchType            , only : clmpatch => patch
    use ColumnType           , only : col
    use LandunitType         , only : lun
    use pftconMod            , only : pftcon
    use CanopyStateType      , only : canopystate_type
    use WaterStateType       , only : waterstate_type
    !
    ! !ARGUMENTS    
    class(ed_clm_type)                              :: this
    type(bounds_type)       , intent(in)            :: bounds  
    type(ed_site_type)      , intent(inout), target :: ed_allsites_inst( bounds%begg: )
    type(ed_phenology_type) , intent(inout)         :: ed_phenology_inst
    type(waterstate_type)   , intent(inout)         :: waterstate_inst
    type(canopystate_type)  , intent(inout)         :: canopystate_inst
    !
    ! !LOCAL VARIABLES:
    type (ed_patch_type)  , pointer :: currentPatch
    type (ed_cohort_type) , pointer :: currentCohort
    integer  :: g,l,p,c
    integer  :: ft                                      ! plant functional type
    integer  :: patchn                                  ! identification number for each patch. 
    integer  :: firstsoilpatch(bounds%begg:bounds%endg) ! the first patch in this gridcell that is soil and thus bare... 
    real(r8) :: total_bare_ground                       ! sum of the bare fraction in all pfts.
    real(r8) :: total_patch_area                               
    real(r8) :: coarse_wood_frac  
    real(r8) :: canopy_leaf_area                        ! total amount of leaf area in the vegetated area. m2.  
    integer  :: sitecolumn(bounds%begg:bounds%endg)
    logical  :: istheresoil(bounds%begg:bounds%endg) 
    !----------------------------------------------------------------------

    if (DEBUG) then
       write(iulog,*) 'in ed_clm_link'
    endif

    associate(                                 & 
         tlai => canopystate_inst%tlai_patch , &
         elai => canopystate_inst%elai_patch , &
         tsai => canopystate_inst%tsai_patch , &
         esai => canopystate_inst%esai_patch , &
         htop => canopystate_inst%htop_patch , &
         hbot => canopystate_inst%hbot_patch , & 
         begg => bounds%begg                 , &
         endg => bounds%endg                 , &
         begc => bounds%begc                 , &
         endc => bounds%endc                 , &
         begp => bounds%begp                 , &
         endp => bounds%endp                   &
         )

      ! determine if gridcell is soil 

      istheresoil(begg:endg) = .false.
      do c = begc,endc
         g = col%gridcell(c)   
         l = col%landunit(c)

         if (lun%itype(l) == istsoil .and. col%itype(c) == istsoil) then  
            istheresoil(g) = .true.
         endif
         ed_allsites_inst(g)%istheresoil = istheresoil(g)
      enddo

      ! retrieve the first soil patch associated with each gridcell. 
      ! make sure we only get the first patch value for places which have soil. 

      firstsoilpatch(begg:endg) = -999
      do c = begc,endc
         g = col%gridcell(c)
         l = col%landunit(c)

         if (lun%itype(l) == istsoil .and. col%itype(c) == istsoil) then 
            firstsoilpatch(g) = col%patchi(c)
            sitecolumn(g) = c
         endif
      enddo

      ! ============================================================================
      ! Zero the whole variable so we dont have ghost values when patch number declines.
      ! ============================================================================

      clmpatch%is_veg(begp:endp)        = .false. 
      clmpatch%is_bareground(begp:endp) = .false. 
      tlai(begp:endp)                   = 0.0_r8    
      elai(firstsoilpatch(g))           = 0.0_r8
      tsai(firstsoilpatch(g))           = 0.0_r8
      esai(firstsoilpatch(g))           = 0.0_r8
      htop(begp:endp)                   = 0.0_r8      
      hbot(begp:endp)                   = 0.0_r8   

      do g = begg,endg

         if(firstsoilpatch(g) >= 0.and.ed_allsites_inst(g)%istheresoil)then 
            ed_allsites_inst(g)%clmcolumn = sitecolumn(g)

            ! ============================================================================
            ! Zero the bare ground tile BGC variables.
            ! ============================================================================

            tlai(firstsoilpatch(g)) = 0.0_r8    
            htop(firstsoilpatch(g)) = 0.0_r8      
            hbot(firstsoilpatch(g)) = 0.0_r8      

            patchn = 0
            total_bare_ground = 0.0_r8
            total_patch_area = 0._r8 

            currentPatch => ed_allsites_inst(g)%oldest_patch
            do while(associated(currentPatch))
               patchn = patchn + 1
               currentPatch%patchno = patchn

               if (patchn <= numpft - numcft)then !don't expand into crop patches.   

                  currentPatch%clm_pno = firstsoilpatch(g) + patchn !the first 'soil' patch is unvegetated...      
                  p = currentPatch%clm_pno
                  c = clmpatch%column(p)
                  clmpatch%is_veg(p) = .true. !this .is. a tile filled with vegetation... 
                  
                  call currentPatch%set_root_fraction()

                  !zero cohort-summed variables. 
                  currentPatch%total_canopy_area = 0.0_r8
                  currentPatch%total_tree_area = 0.0_r8
                  currentPatch%lai = 0.0_r8
                  canopy_leaf_area = 0.0_r8

                  !update cohort quantitie s                                  
                  currentCohort => currentPatch%shortest
                  do while(associated(currentCohort))
     
                     ft = currentCohort%pft
                     currentCohort%livestemn = currentCohort%bsw  / pftcon%leafcn(currentCohort%pft)

                     if (pftcon%woody(ft) == 1) then
                        coarse_wood_frac = 0.5_r8
                     else
                        coarse_wood_frac = 0.0_r8
                     end if

                     currentCohort%livecrootn = currentCohort%br * coarse_wood_frac / pftcon%leafcn(ft)
                     currentCohort%b = currentCohort%balive+currentCohort%bdead+currentCohort%bstore
                     currentCohort%treelai = tree_lai(currentCohort)
                     ! Why is currentCohort%c_area used and then reset in the
                     ! following line?
                     canopy_leaf_area = canopy_leaf_area + currentCohort%treelai *currentCohort%c_area
                     currentCohort%c_area = c_area(currentCohort)

                     if(currentCohort%canopy_layer==1)then
                        currentPatch%total_canopy_area = currentPatch%total_canopy_area + currentCohort%c_area
                        if(pftcon%woody(ft)==1)then
                           currentPatch%total_tree_area = currentPatch%total_tree_area + currentCohort%c_area
                        endif
                     endif

                     ! Check for erroneous zero values. 
                     if(currentCohort%dbh <= 0._r8 .or. currentCohort%n == 0._r8)then
                        write(iulog,*) 'ED: dbh or n is zero in clmedlink', currentCohort%dbh,currentCohort%n
                     endif
                     if(currentCohort%pft == 0.or.currentCohort%canopy_trim <= 0._r8)then
                        write(iulog,*) 'ED: PFT or trim is zero in clmedlink',currentCohort%pft,currentCohort%canopy_trim
                     endif
                     if(currentCohort%balive <= 0._r8)then
                        write(iulog,*) 'ED: balive is zero in clmedlink',currentCohort%balive
                     endif

                     currentCohort => currentCohort%taller

                  enddo ! ends 'do while(associated(currentCohort))

                  if ( currentPatch%total_canopy_area-currentPatch%area > 0.000001_r8 ) then
                     write(iulog,*) 'canopy area bigger than area',currentPatch%total_canopy_area ,currentPatch%area
                     currentPatch%total_canopy_area = currentPatch%area
                  endif

                  ! PASS BACK PATCH-LEVEL QUANTITIES THAT ARE NEEDED BY THE CLM CODE
                  if (associated(currentPatch%tallest)) then
                     htop(p) = currentPatch%tallest%hite
                  else
                     ! FIX(RF,040113) - should this be a parameter for the minimum possible vegetation height?
                     htop(p) = 0.1_r8
                  endif

                  hbot(p) = max(0._r8, min(0.2_r8, htop(p)- 1.0_r8))

                  ! leaf area index: of .only. the areas with some vegetation on them, as the non-vegetated areas 
                  ! are merged into the bare ground fraction. This introduces a degree of unrealism, 
                  ! which could be fixed if the surface albedo routine took account of the possibiltiy of bare 
                  ! ground mixed with trees. 

                  if(currentPatch%total_canopy_area > 0)then;
                     tlai(p) = canopy_leaf_area/currentPatch%total_canopy_area 
                  else
                     tlai(p) = 0.0_r8
                  endif

                  !write(iulog,*) 'tlai',tlai(p)
                  !write(iulog,*) 'htop',htop(p)

                  ! We are assuming here that grass is all located underneath tree canopies. 
                  ! The alternative is to assume it is all spatial distinct from tree canopies.
                  ! In which case, the bare area would have to be reduced by the grass area...
                  ! currentPatch%total_canopy_area/currentPatch%area is fraction of this patch cover by plants 
                  ! currentPatch%area/AREA is the fraction of the soil covered by this patch. 

                  clmpatch%wt_ed(p) = min(1.0_r8,(currentPatch%total_canopy_area/currentPatch%area)) * &
                       (currentPatch%area/AREA)
                  currentPatch%bare_frac_area = (1.0_r8 - min(1.0_r8,currentPatch%total_canopy_area/currentPatch%area)) * &
                       (currentPatch%area/AREA)                 

                  ! write(iulog,*) 'bare frac',currentPatch%bare_frac_area
                  total_patch_area = total_patch_area + clmpatch%wt_ed(p) + currentPatch%bare_frac_area
                  total_bare_ground = total_bare_ground + currentPatch%bare_frac_area
                  currentCohort=> currentPatch%tallest

               else
                  write(iulog,*) 'ED: too many patches' 
               end if ! patchn<15

               currentPatch => currentPatch%younger
            end do !patch loop

            if((total_patch_area-1.0_r8)>1e-9)then
               write(iulog,*) 'total area is wrong in CLMEDLINK',total_patch_area
            endif

            !loop round all and zero the remaining empty vegetation patches 
            do p = firstsoilpatch(g)+patchn+1,firstsoilpatch(g)+numpft   
               clmpatch%wt_ed(p) = 0.0_r8
            enddo

            !set the area of the bare ground patch. 
            p = firstsoilpatch(g) 
            clmpatch%wt_ed(p) = total_bare_ground
            clmpatch%is_bareground = .true.
         endif ! are there any soil patches?    

         call this%ed_clm_leaf_area_profile(ed_allsites_inst(g), waterstate_inst, canopystate_inst ) 

      end do !grid loop

      call this%flux_into_litter_pools(bounds, ed_allsites_inst(begg:endg), firstsoilpatch, &
           canopystate_inst)

      call this%ed_update_history_variables(bounds, ed_allsites_inst(begg:endg), &
           firstsoilpatch, ed_Phenology_inst, canopystate_inst)

    end associate

  end subroutine ed_clm_link

  !-----------------------------------------------------------------------
  subroutine ed_update_history_variables( this, bounds, ed_allsites_inst, &
       firstsoilpatch, ed_Phenology_inst, canopystate_inst)
    !
    ! !USES: 
    use EDPhenologyType  , only : ed_phenology_type
    use CanopyStateType  , only : canopystate_type
    use PatchType        , only : clmpatch => patch
    use pftconMod        , only : pftcon
    
    ! !ARGUMENTS:
    class(ed_clm_type)                              ::  this
    type(bounds_type)       , intent(in)            :: bounds  ! clump bounds
    type(ed_site_type)      , intent(inout), target :: ed_allsites_inst( bounds%begg: )
    type(ed_patch_type)     , pointer               :: currentPatch
    type(ed_cohort_type)    , pointer               :: currentCohort
    type(ed_phenology_type) , intent(inout)         :: ed_phenology_inst
    type(canopystate_type)  , intent(inout)         :: canopystate_inst
    !
    ! !LOCAL VARIABLES:
    integer  :: G,p,ft
    integer  :: firstsoilpatch(bounds%begg:bounds%endg)
    real(r8) :: n_density   ! individual of cohort per m2 per patch
    real(r8) :: n_perm2     ! individuals per m2 for the whole grid cell
    real(r8) :: dbh         ! actual dbh used to identify relevant size class
    integer  :: scpf        ! size class x pft index
    integer  :: sc

    !-----------------------------------------------------------------------

    associate(                                                           &
         trimming             => this%trimming_patch             , & ! Output:
         canopy_spread        => this%canopy_spread_patch        , & ! Output:
         PFTbiomass           => this%PFTbiomass_patch           , & ! Output:
         PFTleafbiomass       => this%PFTleafbiomass_patch       , & ! Output:
         PFTstorebiomass      => this%PFTstorebiomass_patch      , & ! Output:
         PFTnindivs           => this%PFTnindivs_patch           , & ! Output:
         area_plant           => this%area_plant_patch           , & ! Output:
         area_trees           => this%area_trees_patch           , & ! Output:
         nesterov_fire_danger => this%nesterov_fire_danger_patch , & ! Output:
         spitfire_ROS         => this%spitfire_ROS_patch         , & ! Output:
         effect_wspeed        => this%effect_wspeed_patch        , & ! Output:
         TFC_ROS              => this%TFC_ROS_patch              , & ! Output:
         sum_fuel             => this%sum_fuel_patch             , & ! Output:
         fire_intensity       => this%fire_intensity_patch       , & ! Output:
         fire_area            => this%fire_area_patch            , & ! Output:
         scorch_height        => this%scorch_height_patch        , & ! Output:
         fire_fuel_bulkd      => this%fire_fuel_bulkd_patch      , & ! Output:
         fire_fuel_eff_moist  => this%fire_fuel_eff_moist_patch  , & ! Output:
         fire_fuel_sav        => this%fire_fuel_sav_patch        , & ! Output:
         fire_fuel_mef        => this%fire_fuel_mef_patch        , & ! Output:
         litter_in            => this%litter_in_patch            , & ! Output:
         litter_out           => this%litter_out_patch           , & ! Output:
         seed_bank            => this%seed_bank_patch            , & ! Output:
         seeds_in             => this%seeds_in_patch             , & ! Output:
         seed_decay           => this%seed_decay_patch           , & ! Output:
         seed_germination     => this%seed_germination_patch     , & ! Output:
         
         ED_biomass           => this%ED_biomass_patch           , & ! InOut:
         ED_bdead             => this%ED_bdead_patch             , & ! InOut:
         ED_bleaf             => this%ED_bleaf_patch             , & ! InOut:
         ED_balive            => this%ED_balive_patch            , & ! InOut:
         ED_bstore            => this%ED_bstore_patch            , & ! InOut:
         
         phen_cd_status       => ed_phenology_inst%phen_cd_status_patch , & ! InOut:
         
         gpp                  => this%gpp_patch                  , & ! Output: 
         npp                  => this%npp_patch                  , & ! Output:

         ed_gpp_scpf          => this%ed_gpp_gd_scpf             , &
         ed_npp_totl_scpf     => this%ed_npp_totl_gd_scpf        , &
         ed_npp_leaf_scpf     => this%ed_npp_leaf_gd_scpf        , &
         ed_npp_seed_scpf     => this%ed_npp_seed_gd_scpf        , &
         ed_npp_fnrt_scpf     => this%ed_npp_fnrt_gd_scpf        , &
         ed_npp_bgsw_scpf     => this%ed_npp_bgsw_gd_scpf        , &
         ed_npp_bgdw_scpf     => this%ed_npp_bgdw_gd_scpf        , &
         ed_npp_agsw_scpf     => this%ed_npp_agsw_gd_scpf        , &
         ed_npp_agdw_scpf     => this%ed_npp_agdw_gd_scpf        , &
         ed_npp_stor_scpf     => this%ed_npp_stor_gd_scpf        , &
         
         ed_ddbh_gd_scpf        => this%ed_ddbh_gd_scpf          , &
         ed_ba_gd_scpf          => this%ed_ba_gd_scpf            , &
         ed_np_gd_scpf          => this%ed_np_gd_scpf            , &
         ed_m1_gd_scpf          => this%ed_m1_gd_scpf            , &
         ed_m2_gd_scpf          => this%ed_m2_gd_scpf            , &
         ed_m3_gd_scpf          => this%ed_m3_gd_scpf            , &
         ed_m4_gd_scpf          => this%ed_m4_gd_scpf            , &
         ed_m5_gd_scpf          => this%ed_m5_gd_scpf            , &

 

         
         tlai                 => canopystate_inst%tlai_patch     , & ! InOut:
         elai                 => canopystate_inst%elai_patch     , & ! InOut:
         tsai                 => canopystate_inst%tsai_patch     , & ! InOut:
         esai                 => canopystate_inst%esai_patch     , & ! InOut:

         begp                 => bounds%begp                     , &
         endp                 => bounds%endp                       &
         )

      ! ============================================================================
      ! Zero the whole variable so we dont have ghost values when patch number declines.
      ! ============================================================================
      
      trimming(:)             = 1.0_r8 !the default value of this is 1.0, making it 0.0 means that the output is confusing. 
      canopy_spread(:)        = 0.0_r8 
      PFTbiomass(:,:)         = 0.0_r8
      PFTleafbiomass(:,:)     = 0.0_r8 
      PFTstorebiomass(:,:)    = 0.0_r8
      PFTnindivs(:,:)         = 0.0_r8
      gpp(:)                  = 0.0_r8
      npp(:)                  = 0.0_r8  
      area_plant(:)           = 0.0_r8       
      area_trees(:)           = 0.0_r8        
      nesterov_fire_danger(:) = 0.0_r8
      spitfire_ROS(:)         = 0.0_r8
      effect_wspeed           = 0.0_r8
      TFC_ROS(:)              = 0.0_r8
      fire_intensity(:)       = 0.0_r8
      fire_area(:)            = 0.0_r8
      scorch_height(:)        = 0.0_r8
      fire_fuel_bulkd(:)      = 0.0_r8
      fire_fuel_eff_moist(:)  = 0.0_r8
      fire_fuel_sav(:)        = 0.0_r8
      fire_fuel_mef(:)        = 0.0_r8
      litter_in(:)            = 0.0_r8
      litter_out(:)           = 0.0_r8
      seed_bank(:)            = 0.0_r8          
      seeds_in(:)             = 0.0_r8
      seed_decay(:)           = 0.0_r8
      seed_germination(:)     = 0.0_r8
      ED_biomass(:)           = 0.0_r8
      ED_bdead(:)             = 0.0_r8
      ED_bleaf(:)             = 0.0_r8
      ED_bstore(:)            = 0.0_r8
      ED_balive(:)            = 0.0_r8
      phen_cd_status(:)       = 2

      ed_gpp_scpf(:,:)      = 0.0_r8
      ed_npp_totl_scpf(:,:) = 0.0_r8
      ed_npp_leaf_scpf(:,:) = 0.0_r8
      ed_npp_seed_scpf(:,:) = 0.0_r8
      ed_npp_fnrt_scpf(:,:) = 0.0_r8
      ed_npp_bgsw_scpf(:,:) = 0.0_r8
      ed_npp_bgdw_scpf(:,:) = 0.0_r8
      ed_npp_agsw_scpf(:,:) = 0.0_r8
      ed_npp_agdw_scpf(:,:) = 0.0_r8
      ed_npp_stor_scpf(:,:) = 0.0_r8
      
      ed_ddbh_gd_scpf(:,:) = 0.0_r8
      ed_ba_gd_scpf(:,:)   = 0.0_r8
      ed_np_gd_scpf(:,:)   = 0.0_r8
      ed_m1_gd_scpf(:,:)   = 0.0_r8
      ed_m2_gd_scpf(:,:)   = 0.0_r8
      ed_m3_gd_scpf(:,:)   = 0.0_r8
      ed_m4_gd_scpf(:,:)   = 0.0_r8
      ed_m5_gd_scpf(:,:)   = 0.0_r8

      do g = bounds%begg,bounds%endg

         if (firstsoilpatch(g) >= 0 .and. ed_allsites_inst(g)%istheresoil) then 

            ! ============================================================================
            ! Zero the bare ground tile BGC variables.
            ! ============================================================================

            trimming(firstsoilpatch(g))             = 1.0_r8 
            canopy_spread(firstsoilpatch(g))        = 0.0_r8 
            PFTbiomass(firstsoilpatch(g),:)         = 0.0_r8
            PFTleafbiomass(firstsoilpatch(g),:)     = 0.0_r8 
            PFTstorebiomass(firstsoilpatch(g),:)    = 0.0_r8
            PFTnindivs(firstsoilpatch(g),:)         = 0.0_r8
            gpp(firstsoilpatch(g))                  = 0.0_r8
            npp(firstsoilpatch(g))                  = 0.0_r8  
            area_plant(firstsoilpatch(g))           = 0.0_r8       
            area_trees(firstsoilpatch(g))           = 0.0_r8        
            nesterov_fire_danger(firstsoilpatch(g)) = 0.0_r8
            spitfire_ROS(firstsoilpatch(g))         = 0.0_r8
            TFC_ROS(firstsoilpatch(g))              = 0.0_r8
            effect_wspeed(firstsoilpatch(g))        = 0.0_r8
            fire_intensity(firstsoilpatch(g))       = 0.0_r8
            fire_area(firstsoilpatch(g))            = 0.0_r8
            scorch_height(firstsoilpatch(g))        = 0.0_r8
            fire_fuel_bulkd(firstsoilpatch(g))      = 0.0_r8
            fire_fuel_eff_moist(firstsoilpatch(g))  = 0.0_r8
            fire_fuel_sav(firstsoilpatch(g))        = 0.0_r8
            fire_fuel_mef(firstsoilpatch(g))        = 0.0_r8
            litter_in(firstsoilpatch(g))            = 0.0_r8
            litter_out(firstsoilpatch(g))           = 0.0_r8
            seed_bank(firstsoilpatch(g))            = 0.0_r8          
            seeds_in(firstsoilpatch(g))             = 0.0_r8
            seed_decay(firstsoilpatch(g))           = 0.0_r8
            seed_germination(firstsoilpatch(g))     = 0.0_r8
            ED_biomass(firstsoilpatch(g))           = 0.0_r8
            ED_balive(firstsoilpatch(g))            = 0.0_r8
            ED_bdead(firstsoilpatch(g))             = 0.0_r8
            ED_bstore(firstsoilpatch(g))            = 0.0_r8
            ED_bleaf(firstsoilpatch(g))             = 0.0_r8
            elai(firstsoilpatch(g))                 = 0.0_r8
            tlai(firstsoilpatch(g))                 = 0.0_r8
            tsai(firstsoilpatch(g))                 = 0.0_r8
            esai(firstsoilpatch(g))                 = 0.0_r8
            ED_bleaf(firstsoilpatch(g))             = 0.0_r8
            sum_fuel(firstsoilpatch(g))             = 0.0_r8
            !this should probably be site level. 
            phen_cd_status(firstsoilpatch(g))       = ed_allsites_inst(g)%status

            currentPatch => ed_allsites_inst(g)%oldest_patch
            do while(associated(currentPatch))

               if(currentPatch%patchno  <= numpft - numcft)then !don't expand into crop patches.   
                  p = currentPatch%clm_pno

                  currentCohort => currentPatch%shortest
                  do while(associated(currentCohort))
                     !accumulate into history variables. 
                     ft = currentCohort%pft
                     if(currentPatch%area>0._r8)then
                        n_density             = currentCohort%n/currentPatch%area
                        n_perm2               = currentCohort%n/AREA   ! plant density using whole area (for grid cell averages)
                     else
                        n_density             = 0.0_r8
                        n_perm2               = 0.0_r8
                     endif
                     ED_bleaf(p)           = ED_bleaf(p)           + n_density * currentCohort%bl 
                     ED_bstore(p)          = ED_bstore(p)          + n_density * currentCohort%bstore 
                     ED_biomass(p)         = ED_biomass(p)         + n_density * currentCohort%b 
                     ED_bdead(p)           = ED_bdead(p)           + n_density * currentCohort%bdead 
                     ED_balive(p)          = ED_balive(p)          + n_density * currentCohort%balive
                     npp(p)                = npp(p)                + n_density * currentCohort%npp 
                     gpp(p)                = gpp(p)                + n_density * currentCohort%gpp   
                     PFTbiomass(p,ft)      = PFTbiomass(p,ft)      + n_density * currentCohort%b
                     PFTleafbiomass(p,ft)  = PFTleafbiomass(p,ft)  + n_density * currentCohort%bl
                     PFTstorebiomass(p,ft) = PFTstorebiomass(p,ft) + n_density * currentCohort%bstore
                     PFTnindivs(p,ft)      = PFTnindivs(p,ft)      + currentCohort%n 

                     dbh = currentCohort%dbh !-0.5*(1./365.25)*currentCohort%ddbhdt
                     sc  = count(dbh-sclass_ed.ge.0.0) 
                     scpf = (ft-1)*nlevsclass_ed+sc
                     
                     ! Flux Variables (must pass a NaN check on growth increment and not be recruits)
                     if(currentCohort%ddbhdt == currentCohort%ddbhdt .and. .not.(currentCohort%isnew)) then
                        ed_gpp_scpf(g,scpf)      = ed_gpp_scpf(g,scpf) + n_perm2*currentCohort%gpp ! [kgC/m2/yr]
                        ed_npp_totl_scpf(g,scpf) = ed_npp_totl_scpf(g,scpf) + currentcohort%npp*n_perm2
                        ed_npp_leaf_scpf(g,scpf) = ed_npp_leaf_scpf(g,scpf) + currentcohort%npp_leaf*n_perm2
                        ed_npp_fnrt_scpf(g,scpf) = ed_npp_fnrt_scpf(g,scpf) + currentcohort%npp_froot*n_perm2
                        ed_npp_bgsw_scpf(g,scpf) = ed_npp_bgsw_scpf(g,scpf) + currentcohort%npp_bsw*(1._r8-ED_val_ag_biomass)*n_perm2
                        ed_npp_agsw_scpf(g,scpf) = ed_npp_agsw_scpf(g,scpf) + currentcohort%npp_bsw*ED_val_ag_biomass*n_perm2
                        ed_npp_bgdw_scpf(g,scpf) = ed_npp_bgdw_scpf(g,scpf) + currentcohort%npp_bdead*(1._r8-ED_val_ag_biomass)*n_perm2
                        ed_npp_agdw_scpf(g,scpf) = ed_npp_agdw_scpf(g,scpf) + currentcohort%npp_bdead*ED_val_ag_biomass*n_perm2
                        ed_npp_seed_scpf(g,scpf) = ed_npp_seed_scpf(g,scpf) + currentcohort%npp_bseed*n_perm2
                        ed_npp_stor_scpf(g,scpf) = ed_npp_stor_scpf(g,scpf) + currentcohort%npp_store*n_perm2
                        if( abs(currentcohort%npp-(currentcohort%npp_leaf+currentcohort%npp_froot+ &
                                                   currentcohort%npp_bsw+currentcohort%npp_bdead+ &
                                                   currentcohort%npp_bseed+currentcohort%npp_store))>1.e-9) then
                           write(iulog,*) 'NPP Partitions are not balancing'
                           write(iulog,*) 'Fractional Error: ',abs(currentcohort%npp-(currentcohort%npp_leaf+currentcohort%npp_froot+ &
                                 currentcohort%npp_bsw+currentcohort%npp_bdead+ &
                                 currentcohort%npp_bseed+currentcohort%npp_store))/currentcohort%npp
                           write(iulog,*) 'Terms: ',currentcohort%npp,currentcohort%npp_leaf,currentcohort%npp_froot, &
                                                    currentcohort%npp_bsw,currentcohort%npp_bdead,                    &
                                                    currentcohort%npp_bseed,currentcohort%npp_store
                           stop
                        end if
                        ! Woody State Variables (basal area and number density and mortality)
                        if (pftcon%woody(ft) == 1) then

                           ed_m1_gd_scpf(g,scpf) = ed_m1_gd_scpf(g,scpf) + currentcohort%bmort*n_perm2*AREA
                           ed_m2_gd_scpf(g,scpf) = ed_m2_gd_scpf(g,scpf) + currentcohort%hmort*n_perm2*AREA
                           ed_m3_gd_scpf(g,scpf) = ed_m3_gd_scpf(g,scpf) + currentcohort%cmort*n_perm2*AREA
                           ed_m4_gd_scpf(g,scpf) = ed_m4_gd_scpf(g,scpf) + currentcohort%imort*n_perm2*AREA
                           ed_m5_gd_scpf(g,scpf) = ed_m5_gd_scpf(g,scpf) + currentcohort%fmort*n_perm2*AREA

                           ! basal area  [m2/ha]
                           ed_ba_gd_scpf(g,scpf) = ed_ba_gd_scpf(g,scpf) + &
                                 0.25*3.14159*((dbh/100.0)**2.0)*n_perm2*AREA
                           
                           ! number density [/ha]
                           ed_np_gd_scpf(g,scpf) = ed_np_gd_scpf(g,scpf) + AREA*n_perm2
                           
                           ! Growth Incrments must have NaN check and woody check
                           if(currentCohort%ddbhdt == currentCohort%ddbhdt) then
                              ed_ddbh_gd_scpf(g,scpf) = ed_ddbh_gd_scpf(g,scpf) + &
                                    currentCohort%ddbhdt*n_perm2*AREA 
                           else
                              ed_ddbh_gd_scpf(g,scpf) = -999.9
                           end if
                        end if

                     end if

                     currentCohort         => currentCohort%taller
                  enddo ! cohort loop

                  !Patch specific variables that are already calculated

                  !These things are all duplicated. Should they all be converted to LL or array structures RF? 
                  nesterov_fire_danger(p) = ed_allsites_inst(g)%acc_NI 
                  spitfire_ROS(p)         = currentPatch%ROS_front 
                  TFC_ROS(p)              = currentPatch%TFC_ROS
                  effect_wspeed(p)        = currentPatch%effect_wspeed
                  fire_intensity(p)       = currentPatch%FI
                  fire_area(p)            = currentPatch%frac_burnt
                  scorch_height(p)        = currentPatch%SH
                  fire_fuel_bulkd(p)      = currentPatch%fuel_bulkd
                  fire_fuel_eff_moist(p)  = currentPatch%fuel_eff_moist
                  fire_fuel_sav(p)        = currentPatch%fuel_sav
                  fire_fuel_mef(p)        = currentPatch%fuel_mef                          
                  sum_fuel(p)             = currentPatch%sum_fuel                         
                  litter_in(p)            = sum(currentPatch%CWD_AG_in) +sum(currentPatch%leaf_litter_in)
                  litter_out(p)           = sum(currentPatch%CWD_AG_out)+sum(currentPatch%leaf_litter_out)
                  seed_bank(p)            = sum(currentPatch%seed_bank)
                  seeds_in(p)             = sum(currentPatch%seeds_in)
                  seed_decay(p)           = sum(currentPatch%seed_decay)
                  seed_germination(p)     = sum(currentPatch%seed_germination)
                  canopy_spread(p)        = currentPatch%spread(1) 
                  area_plant(p)           = currentPatch%total_canopy_area /currentPatch%area
                  area_trees(p)           = currentPatch%total_tree_area   /currentPatch%area
                  phen_cd_status(p)       = ed_allsites_inst(g)%status
                  if(associated(currentPatch%tallest))then
                     trimming(p)          = currentPatch%tallest%canopy_trim                
                  else
                     trimming(p)          = 0.0_r8
                  endif

               else
                  write(iulog,*) 'ED: too many patches' 
               end if ! patchn<15

               currentPatch => currentPatch%younger
            end do !patch loop

         endif ! are there any soil patches?    
      enddo !gridcell loop

    end associate

  end subroutine ed_update_history_variables

  !------------------------------------------------------------------------
  subroutine ed_clm_leaf_area_profile( this, currentSite, waterstate_inst, canopystate_inst )
    !
    ! !DESCRIPTION:
    ! Load LAI in each layer into array to send to CLM
    !
    ! !USES: 
    use EDGrowthFunctionsMod , only : tree_lai, tree_sai, c_area 
    use EDtypesMod           , only : area, dinc_ed, hitemax, numpft_ed, n_hite_bins
    use EDEcophysConType     , only : EDecophyscon
    use CanopyStateType      , only : canopystate_type
    use WaterStateType       , only : waterstate_type
    use PatchType            , only : clmpatch => patch
    !
    ! !ARGUMENTS    
    class(ed_clm_type)                     :: this  
    type(ed_site_type)     , intent(inout) :: currentSite
    type(waterstate_type)  , intent(inout) :: waterstate_inst
    type(canopystate_type) , intent(inout) :: canopystate_inst
    !
    ! !LOCAL VARIABLES:
    type (ed_patch_type)  , pointer :: currentPatch
    type (ed_cohort_type) , pointer :: currentCohort
    real(r8) :: remainder                !Thickness of layer at bottom of canopy. 
    real(r8) :: fleaf                    ! fraction of cohort incepting area that is leaves.  
    integer  :: ft                       ! Plant functional type index. 
    integer  :: iv                       ! Vertical leaf layer index   
    integer  :: L                        ! Canopy layer index
    integer  :: P                        ! clm patch index  
    integer  :: C                        ! column index
    real(r8) :: tlai_temp                ! calculation of tlai to check this method
    real(r8) :: elai_temp                ! make a new elai based on the layer-by-layer snow coverage.
    real(r8) :: tsai_temp                !
    real(r8) :: esai_temp                !  
    real(r8) :: fraction_exposed         ! how much of this layer is not covered by snow?
    real(r8) :: layer_top_hite           ! notional top height of this canopy layer (m)
    real(r8) :: layer_bottom_hite        ! notional bottom height of this canopy layer (m)
    integer  :: smooth_leaf_distribution ! is the leaf distribution this option (1) or not (0)
    real(r8) :: frac_canopy(N_HITE_BINS) ! amount of canopy in each height class
    real(r8) :: minh(N_HITE_BINS)        ! minimum height in height class (m)
    real(r8) :: maxh(N_HITE_BINS)        ! maximum height in height class (m)
    real(r8) :: dh                       ! vertical detph of height class (m)
    real(r8) :: min_chite                ! bottom of cohort canopy  (m)
    real(r8) :: max_chite                ! top of cohort canopy      (m)
    real(r8) :: lai                      ! summed lai for checking m2 m-2
    integer  :: NC                       ! number of cohorts, for bug fixing. 
    !----------------------------------------------------------------------

    smooth_leaf_distribution = 0

    associate(                                                             & 
         snow_depth         => waterstate_inst%snow_depth_col            , & !Input:
         frac_sno_eff       => waterstate_inst%frac_sno_eff_col          , & !Input: 
         snowdp             => waterstate_inst%snowdp_col                , & !Output:
         
         frac_veg_nosno_alb => canopystate_inst%frac_veg_nosno_alb_patch , & !Output:
         tlai               => canopystate_inst%tlai_patch               , & !Output
         elai               => canopystate_inst%elai_patch               , & !Output
         tsai               => canopystate_inst%tsai_patch               , & !Output
         esai               => canopystate_inst%esai_patch                 & !Output
         )

      ! Here we are trying to generate a profile of leaf area, indexed by 'z' and by pft
      ! We assume that each point in the canopy recieved the light attenuated by the average
      ! leaf area index above it, irrespective of PFT identity... 
      ! Each leaf is defined by how deep in the canopy it is, in terms of LAI units.  (FIX(RF,032414), GB)

      if (currentSite%istheresoil)then
         
         currentPatch => currentSite%oldest_patch   ! ed patch
         p = currentPatch%clm_pno                   ! index for clm patch

         do while(associated(currentPatch))

            !Calculate tree and canopy areas. 
            currentPatch%canopy_area = 0._r8
            currentPatch%canopy_layer_lai(:) = 0._r8
            NC = 0
            currentCohort => currentPatch%shortest
            do while(associated(currentCohort))       
               currentCohort%c_area = c_area(currentCohort)
               currentPatch%canopy_area = currentPatch%canopy_area + currentCohort%c_area
               NC = NC+1
               currentCohort => currentCohort%taller    
            enddo
            ! if plants take up all the tile, then so does the canopy.  
            currentPatch%canopy_area = min(currentPatch%canopy_area,currentPatch%area) 

            !calculate tree lai and sai.
            currentPatch%ncan(:,:) = 0 
            currentPatch%nrad(:,:) = 0 
            currentPatch%lai = 0._r8
            currentCohort => currentPatch%shortest
            do while(associated(currentCohort)) 
               currentCohort%treelai = tree_lai(currentCohort)    
               currentCohort%treesai = tree_sai(currentCohort)
               currentCohort%lai =  currentCohort%treelai *currentCohort%c_area/currentPatch%canopy_area 
               currentCohort%sai =  currentCohort%treesai *currentCohort%c_area/currentPatch%canopy_area  
               !Calculate the LAI plus SAI in each canopy storey. 
               currentCohort%NV =  CEILING((currentCohort%treelai+currentCohort%treesai)/dinc_ed)  

               currentPatch%ncan(currentCohort%canopy_layer,currentCohort%pft) = &
                    max(currentPatch%ncan(currentCohort%canopy_layer,currentCohort%pft),currentCohort%NV)
               currentPatch%lai = currentPatch%lai +currentCohort%lai

               do L = 1,nclmax-1
                  if(currentCohort%canopy_layer == L)then
                     currentPatch%canopy_layer_lai(L) = currentPatch%canopy_layer_lai(L) + currentCohort%lai + &
                          currentCohort%sai
                  endif
               enddo

               currentCohort => currentCohort%taller 

            enddo !currentCohort
            currentPatch%nrad = currentPatch%ncan

            if(smooth_leaf_distribution == 1)then
               ! we are going to ignore the concept of canopy layers, and put all of the leaf area into height banded bins. 
               ! using the same domains as we had before, except that CL always = 1
               currentPatch%tlai_profile = 0._r8
               currentPatch%tsai_profile = 0._r8  
               currentPatch%elai_profile = 0._r8
               currentPatch%esai_profile = 0._r8  

               ! this is a crude way of dividing up the bins. Should it be a function of actual maximum height? 
               dh = 1.0_r8*(HITEMAX/N_HITE_BINS) 
               do iv = 1,N_HITE_BINS  
                  if (iv == 1) then
                     minh(iv) = 0.0_r8
                     maxh(iv) = dh
                  else 
                     minh(iv) = (iv-1)*dh
                     maxh(iv) = (iv)*dh
                  endif
               enddo
               c = clmpatch%column(currentPatch%clm_pno)
               currentCohort => currentPatch%shortest
               do while(associated(currentCohort))  
                  ft = currentCohort%pft
                  min_chite = currentCohort%hite - currentCohort%hite * EDecophyscon%crown(ft)
                  max_chite = currentCohort%hite  
                  do iv = 1,N_HITE_BINS  
                     frac_canopy(iv) = 0.0_r8
                     ! this layer is in the middle of the canopy
                     if(max_chite > maxh(iv).and.min_chite < minh(iv))then 
                        frac_canopy(iv)= min(1.0_r8,dh / (currentCohort%hite*EDecophyscon%crown(ft)))
                        ! this is the layer with the bottom of the canopy in it. 
                     elseif(min_chite < maxh(iv).and.min_chite > minh(iv).and.max_chite > maxh(iv))then 
                        frac_canopy(iv) = (maxh(iv) -min_chite ) / (currentCohort%hite*EDecophyscon%crown(ft))
                        ! this is the layer with the top of the canopy in it. 
                     elseif(max_chite > minh(iv).and.max_chite < maxh(iv).and.min_chite < minh(iv))then 
                        frac_canopy(iv) = (max_chite - minh(iv)) / (currentCohort%hite*EDecophyscon%crown(ft))
                     elseif(max_chite < maxh(iv).and.min_chite > minh(iv))then !the whole cohort is within this layer. 
                        frac_canopy(iv) = 1.0_r8
                     endif

                     ! no m2 of leaf per m2 of ground in each height class
                     currentPatch%tlai_profile(1,ft,iv) = currentPatch%tlai_profile(1,ft,iv) + frac_canopy(iv) * &
                          currentCohort%lai
                     currentPatch%tsai_profile(1,ft,iv) = currentPatch%tsai_profile(1,ft,iv) + frac_canopy(iv) * &
                          currentCohort%sai

                     !snow burial
                     fraction_exposed = 1.0_r8 !default. 

                     snowdp(c) = snow_depth(c) * frac_sno_eff(c)
                     if(snowdp(c) > maxh(iv))then
                        fraction_exposed = 0._r8
                     endif
                     if(snowdp(c) < minh(iv))then
                        fraction_exposed = 1._r8
                     endif
                     if(snowdp(c) >= minh(iv).and.snowdp(c) <= maxh(iv))then !only partly hidden... 
                        fraction_exposed =  max(0._r8,(min(1.0_r8,(snowdp(c)-minh(iv))/dh)))
                     endif

                     ! no m2 of leaf per m2 of ground in each height class
                     ! FIX(SPM,032414) these should be uncommented this and double check
                     !currentPatch%elai_profile(1,ft,iv) = currentPatch%tlai_profile(1,ft,iv) * fraction_exposed
                     !currentPatch%esai_profile(1,ft,iv) = currentPatch%tsai_profile(1,ft,iv) * fraction_exposed

                  enddo ! (iv) hite bins

                  currentCohort => currentCohort%taller

               enddo !currentCohort 

               !check
               currentPatch%lai = 0._r8
               currentCohort => currentPatch%shortest
               do while(associated(currentCohort)) 
                  currentPatch%lai = currentPatch%lai +currentCohort%lai
                  currentCohort => currentCohort%taller   
               enddo !currentCohort
               lai = 0.0_r8
               do ft = 1,numpft_ed
                  lai = lai+ sum(currentPatch%tlai_profile(1,ft,:))
               enddo

               if(lai > currentPatch%lai)then
                  write(iulog,*) 'problem with lai assignments'
               endif


            else ! smooth leaf distribution  
               !Go through all cohorts and add their leaf area and canopy area to the accumulators. 
               currentPatch%tlai_profile = 0._r8
               currentPatch%tsai_profile = 0._r8  
               currentPatch%elai_profile = 0._r8
               currentPatch%esai_profile = 0._r8  
               currentPatch%canopy_area_profile(:,:,:) = 0._r8       
               currentPatch%ncan(:,:) = 0 
               currentPatch%nrad(:,:) = 0 
               currentCohort => currentPatch%shortest

               do while(associated(currentCohort))   
                  L = currentCohort%canopy_layer
                  ft = currentCohort%pft 
                  !Calculate the number of layers of thickness dlai, including the last one. 
                  currentCohort%NV =  CEILING((currentCohort%treelai+currentCohort%treesai)/dinc_ed)
                  !how much of each tree is stem area index? Assuming that there is 
                  if(currentCohort%treelai+currentCohort%treesai > 0._r8)then    
                     fleaf = currentCohort%lai / (currentCohort%lai + currentCohort%sai) 
                  else
                     fleaf = 0._r8
                     write(iulog,*) 'no stem or leaf area' ,currentCohort%pft,currentCohort%bl, &
                          currentCohort%balive,currentCohort%treelai,currentCohort%treesai,currentCohort%dbh, &
                          currentCohort%n,currentCohort%status_coh
                  endif
                  currentPatch%ncan(L,ft) = max(currentPatch%ncan(L,ft),currentCohort%NV)  
                  currentPatch%nrad(L,ft) = currentPatch%ncan(L,ft)  !fudge - this needs to be altered for snow burial
                  if(currentCohort%NV > currentPatch%nrad(L,ft))then
                     write(iulog,*) 'CF: issue with NV',currentCohort%NV,currentCohort%pft,currentCohort%canopy_layer
                  endif
                  c = clmpatch%column(currentPatch%clm_pno)

                  !Whole layers.  Make a weighted average of the leaf area in each layer before dividing it by the total area. 
                  !fill up layer for whole layers.  FIX(RF,032414)- for debugging jan 2012
                  do iv = 1,currentCohort%NV-1 

                     currentPatch%tlai_profile(L,ft,iv) = currentPatch%tlai_profile(L,ft,iv)+ dinc_ed * fleaf * &
                          currentCohort%c_area/currentPatch%total_canopy_area
                     currentPatch%tsai_profile(L,ft,iv) = currentPatch%tsai_profile(L,ft,iv)+ dinc_ed * (1._r8 - fleaf) * &
                          currentCohort%c_area/currentPatch%total_canopy_area
                     currentPatch%canopy_area_profile(L,ft,iv) =  min(1.0_r8,currentPatch%canopy_area_profile(L,ft,iv) + &
                          currentCohort%c_area/currentPatch%total_canopy_area)

                     ! what is the height of this layer? (for snow burial purposes...)  
                     ! pftcon%vertical_canopy_frac(ft))! fudge - this should be pft specific but i cant get it to compile. 
                     layer_top_hite = currentCohort%hite-((iv/currentCohort%NV) * currentCohort%hite * &
                          EDecophyscon%crown(currentCohort%pft) )
                     layer_bottom_hite = currentCohort%hite-(((iv+1)/currentCohort%NV) * currentCohort%hite * &
                          EDecophyscon%crown(currentCohort%pft)) ! pftcon%vertical_canopy_frac(ft))
                     fraction_exposed = 1.0_r8 !default. 
                     snowdp(c) = snow_depth(c) * frac_sno_eff(c)
                     if(snowdp(c) > layer_top_hite)then
                        fraction_exposed = 0._r8
                     endif
                     if(snowdp(c) <= layer_bottom_hite)then
                        fraction_exposed = 1._r8
                     endif
                     if(snowdp(c) > layer_bottom_hite.and.snowdp(c) <= layer_top_hite)then !only partly hidden... 
                        fraction_exposed =  max(0._r8,(min(1.0_r8,(snowdp(c)-layer_bottom_hite)/ &
                             (layer_top_hite-layer_bottom_hite ))))
                     endif

                     currentPatch%elai_profile(L,ft,iv) =  currentPatch%tlai_profile(L,ft,iv) *fraction_exposed
                     !here we are assuming that the stem and leaf area indices have the same profile... 
                     currentPatch%esai_profile(L,ft,iv) =  currentPatch%tsai_profile(L,ft,iv) *fraction_exposed 
                  end do

                  !Bottom layer
                  iv = currentCohort%NV
                  ! pftcon%vertical_canopy_frac(ft))! fudge - this should be pft specific but i cant get it to compile.
                  layer_top_hite = currentCohort%hite-((iv/currentCohort%NV) * currentCohort%hite * &
                       EDecophyscon%crown(currentCohort%pft) )
                  ! pftcon%vertical_canopy_frac(ft))
                  layer_bottom_hite = currentCohort%hite-(((iv+1)/currentCohort%NV) * currentCohort%hite * &
                       EDecophyscon%crown(currentCohort%pft))
                  fraction_exposed = 1.0_r8 !default. 

                  fraction_exposed = 1.0_r8 !default. 
                  if(snowdp(c) > layer_top_hite)then
                     fraction_exposed = 0._r8
                  endif
                  if(snowdp(c) <= layer_bottom_hite)then
                     fraction_exposed = 1._r8
                  endif
                  if(snowdp(c) > layer_bottom_hite.and.snowdp(c) <= layer_top_hite)then !only partly hidden... 
                     fraction_exposed =  max(0._r8,(min(1.0_r8,(snowdp(c)-layer_bottom_hite) / &
                          (layer_top_hite-layer_bottom_hite ))))
                  endif

                  remainder = (currentCohort%treelai + currentCohort%treesai) - (dinc_ed*(currentCohort%NV-1))
                  if(remainder > 1.0_r8)then
                     write(iulog,*)'issue with remainder',currentCohort%treelai,currentCohort%treesai,dinc_ed, & 
                          currentCohort%NV
                  endif
                  !assumes that fleaf is unchanging FIX(RF,032414)

                  currentPatch%tlai_profile(L,ft,iv) =  currentPatch%tlai_profile(L,ft,iv)+ remainder * fleaf * &
                       currentCohort%c_area/currentPatch%total_canopy_area

                  !assumes that fleaf is unchanging FIX(RF,032414)

                  currentPatch%tsai_profile(L,ft,iv) =  currentPatch%tsai_profile(L,ft,iv)+  remainder * &
                       (1.0_r8-fleaf) * currentCohort%c_area/currentPatch%total_canopy_area
                  currentPatch%elai_profile(L,ft,iv) =  currentPatch%tlai_profile(L,ft,iv) *fraction_exposed
                  currentPatch%esai_profile(L,ft,iv) =  currentPatch%tsai_profile(L,ft,iv) *fraction_exposed
                  currentPatch%canopy_area_profile(L,ft,iv) = min(1.0_r8,currentPatch%canopy_area_profile(L,ft,iv) + &
                       currentCohort%c_area/currentPatch%total_canopy_area)

                  if(currentCohort%dbh <= 0._r8.or.currentCohort%n == 0._r8)then
                     write(iulog,*) 'ED: dbh or n is zero in clmedlink', currentCohort%dbh,currentCohort%n
                  endif
                  if(currentCohort%pft == 0.or.currentCohort%canopy_trim <= 0._r8)then
                     write(iulog,*) 'ED: PFT or trim is zero in clmedlink',currentCohort%pft,currentCohort%canopy_trim
                  endif
                  if(currentCohort%balive <= 0._r8.or.currentCohort%bl < 0._r8)then
                     write(iulog,*) 'ED: balive is zero in clmedlink',currentCohort%balive,currentCohort%bl
                  endif

                  currentCohort => currentCohort%taller

               enddo !cohort

               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed
                     do iv = 1,currentPatch%nrad(L,ft)
                        !account for total canopy area
                        currentPatch%tlai_profile(L,ft,iv) = currentPatch%tlai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                        currentPatch%tsai_profile(L,ft,iv) = currentPatch%tsai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                        currentPatch%elai_profile(L,ft,iv) = currentPatch%elai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                        currentPatch%esai_profile(L,ft,iv) = currentPatch%esai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                     enddo

                     currentPatch%tlai_profile(L,ft,currentPatch%nrad(L,ft)+1: nlevcan_ed) = 0._r8
                     currentPatch%tsai_profile(L,ft,currentPatch%nrad(L,ft)+1: nlevcan_ed) = 0._r8
                     currentPatch%elai_profile(L,ft,currentPatch%nrad(L,ft)+1: nlevcan_ed) = 0._r8 
                     currentPatch%esai_profile(L,ft,currentPatch%nrad(L,ft)+1: nlevcan_ed) = 0._r8

                  enddo
               enddo

               !what is the resultant leaf area? 

               tlai_temp = 0._r8
               elai_temp = 0._r8
               tsai_temp = 0._r8
               esai_temp = 0._r8

               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed

                     tlai_temp = tlai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
                          currentPatch%tlai_profile(L,ft,1:currentPatch%nrad(L,ft)))
                     elai_temp = elai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
                          currentPatch%elai_profile(L,ft,1:currentPatch%nrad(L,ft)))
                     tsai_temp = tsai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
                          currentPatch%tsai_profile(L,ft,1:currentPatch%nrad(L,ft)))
                     esai_temp = esai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
                          currentPatch%esai_profile(L,ft,1:currentPatch%nrad(L,ft)))
                  enddo
               enddo

               p = currentPatch%clm_pno
               if(abs(tlai(p)-tlai_temp) > 0.0001_r8) then

                  write(iulog,*) 'error with tlai calcs',&
                       NC,currentSite%clmgcell, abs(tlai(p)-tlai_temp), tlai_temp,tlai(p)

                  do L = 1,currentPatch%NCL_p
                     write(iulog,*) 'carea profile',L,currentPatch%canopy_area_profile(L,1,1:currentPatch%nrad(L,1))
                     write(iulog,*) 'tlai profile',L,currentPatch%tlai_profile(L,1,1:currentPatch%nrad(L,1))
                  end do

               endif

               elai(p) = max(0.1_r8,elai_temp)
               tlai(p) = max(0.1_r8,tlai_temp)
               esai(p) = max(0.1_r8,esai_temp)
               tsai(p) = max(0.1_r8,tsai_temp)

               ! write(iulog,*) 'elai',elai(p),tlai(p),tlai_temp,elai_temp
               ! write(iulog,*) 'esai',esai(p),tsai(p)
               !            write(iulog,*) 'TLAI_prof',currentPatch%tlai_profile(1,:,:)

               ! Fraction of vegetation free of snow. What does this do? Is it right? 
               if ((elai(p) + esai(p)) > 0._r8) then
                  frac_veg_nosno_alb(p) = 1_r8
               else
                  frac_veg_nosno_alb(p) = 0_r8
               end if
               ! write(iulog,*) 'frac nosno',frac_veg_nosno_alb(p)

               currentPatch%nrad = currentPatch%ncan
               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed
                     if(currentPatch%nrad(L,ft) > 30)then
                        write(iulog,*) 'ED: issue w/ nrad'
                     endif
                     currentPatch%present(L,ft) = 0
                     do  iv = 1, currentPatch%nrad(L,ft);
                        if(currentPatch%canopy_area_profile(L,ft,iv) > 0._r8)then
                           currentPatch%present(L,ft) = 1     
                        endif
                     end do !iv
                  enddo !ft

                  if ( L == 1 .and. abs(sum(currentPatch%canopy_area_profile(1,1:numpft_ed,1))) < 0.99999  &
                       .and. currentPatch%NCL_p > 1 ) then
                     write(iulog,*) 'canopy area too small',sum(currentPatch%canopy_area_profile(1,1:numpft_ed,1))
                     write(iulog,*) 'cohort areas', currentPatch%canopy_area_profile(1,1:numpft_ed,:)
                  endif

                  if (L == 1 .and. currentPatch%NCL_p > 1 .and.  &
                       abs(sum(currentPatch%canopy_area_profile(1,1:numpft_ed,1))) < 0.99999) then
                     write(iulog,*) 'not enough area in the top canopy', &
                          sum(currentPatch%canopy_area_profile(L,1:numpft_ed,1)), &
                          currentPatch%canopy_area_profile(L,1:numpft_ed,1)
                  endif

                  if(abs(sum(currentPatch%canopy_area_profile(L,1:numpft_ed,1))) > 1.00001)then
                     write(iulog,*) 'canopy-area-profile wrong',sum(currentPatch%canopy_area_profile(L,1:numpft_ed,1)), &
                          currentSite%clmgcell,currentPatch%patchno,L
                     write(iulog,*) 'areas',currentPatch%canopy_area_profile(L,1:2,1),currentPatch%patchno

                     currentCohort => currentPatch%shortest

                     do while(associated(currentCohort))

                        if(currentCohort%canopy_layer==1)then
                           write(iulog,*) 'cohorts',currentCohort%dbh,currentCohort%c_area, &
                                currentPatch%total_canopy_area,currentPatch%area,currentPatch%canopy_area
                           write(iulog,*) 'fracarea',currentCohort%pft, currentCohort%c_area/currentPatch%total_canopy_area
                        endif

                        currentCohort => currentCohort%taller  

                     enddo !currentCohort
                  endif
               enddo ! loop over L

               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed
                     if(currentPatch%present(L,FT) > 1)then
                        write(iulog,*) 'present issue',currentPatch%clm_pno,L,ft,currentPatch%present(L,FT)
                        currentPatch%present(L,ft) = 1
                     endif
                  enddo
               enddo

            endif !leaf distribution

            currentPatch => currentPatch%younger 

         enddo !patch       

      endif !is there soil? 

    end associate

  end subroutine ed_clm_leaf_area_profile


  subroutine flux_into_litter_pools(this, bounds, ed_allsites_inst, firstsoilpatch, canopystate_inst)
    ! Created by Charlie Koven and Rosie Fisher, 2014-2015
    ! take the flux out of the fragmenting litter pools and port into the decomposing litter pools. 
    ! in this implementation, decomposing pools are assumed to be humus and non-flammable, whereas fragmenting pools
    ! are assumed to be physically fragmenting but not respiring. This is a simplification, but allows us to 
    ! a) reconcile the need to track both chemical fractions (lignin, cellulose, labile) and size fractions (trunk, branch, etc.)
    ! b) to impose a realistic delay on the surge of nutrients into the litter pools when large CWD is added to the system via mortality
    
    ! because of the different subgrid structure, this subroutine includes the functionality that in the big-leaf BGC model, is calculated in SoilBiogeochemVerticalProfileMod
    
    ! The ED code is resolved at a daily timestep, but all of the CN-BGC fluxes are passed in as derivatives per second, 
    ! and then accumulated in the CNStateUpdate routines. One way of doing this is to pass back the CN fluxes per second, 
    ! and keep them constant for the whole day (making sure they are not overwritten.
    ! This means that the carbon gets passed back and forth between the photosynthesis code (fast timestepping) to the ED code (slow timestepping), back to the BGC code (fast timestepping).
    ! This means that the state update for the litter pools and for the CWD pools occurs at different timescales. 
    
    use SFParamsMod, only: SF_val_max_decomp
    use clm_varpar, only : mxpft,nlevdecomp, nlevdecomp_full
    use EDTypesMod, only : AREA, numpft_ed
    use SoilBiogeochemVerticalProfileMod, only: exponential_rooting_profile, pftspecific_rootingprofile, rootprof_exp, surfprof_exp
    use pftconMod, only : pftcon
    use shr_const_mod, only: SHR_CONST_CDAY
    use clm_varcon, only : zisoi, dzsoi_decomp, zsoi
    use ColumnType  , only : col
    use abortutils  , only : endrun
    use shr_log_mod , only : errMsg => shr_log_errMsg    
    use EDParamsMod, only : ED_val_ag_biomass
    !
    implicit none   
    !
    ! !ARGUMENTS    
    class(ed_clm_type)                              :: this  
    type(bounds_type)       , intent(in)            :: bounds  
    type(ed_site_type)      , intent(inout), target :: ed_allsites_inst( bounds%begg: )
    integer  :: firstsoilpatch(bounds%begg:bounds%endg) ! the first patch in this gridcell that is soil and thus bare... 
    type(canopystate_type)  , intent(inout)         :: canopystate_inst
    !
    ! !LOCAL VARIABLES:
    type (ed_patch_type)  , pointer :: currentPatch
    type (ed_cohort_type) , pointer :: currentCohort
    type(ed_site_type), pointer :: cs
    integer c,p,cc,j,g
    real(r8) time_convert    ! from year to seconds
    real(r8) mass_convert    ! ED uses kg, CLM uses g
    integer           :: begp,endp
    integer           :: begc,endc                                    !bounds 
    !------------------------------------------------------------------------
    real(r8) :: cinput_rootfr(bounds%begc:bounds%endc, 1:numpft_ed, 1:nlevdecomp_full)      ! column by pft root fraction used for calculating inputs
    real(r8) :: croot_prof_perpatch(1:nlevdecomp_full)
    real(r8) :: surface_prof(1:nlevdecomp_full)
    integer  :: ft, lev
    real(r8) :: rootfr_tot(1:numpft_ed), biomass_bg_ft(1:numpft_ed)
    real(r8) :: surface_prof_tot, leaf_prof_sum, stem_prof_sum, froot_prof_sum, biomass_bg_tot
    real(r8) :: delta
    
    begp = bounds%begp; endp = bounds%endp
    begc = bounds%begc; endc = bounds%endc
    
    !no of seconds in a year. 
    time_convert =  365.0_r8*SHR_CONST_CDAY

    ! number of grams in a kilogram
    mass_convert = 1000._r8
    
    associate(                                                                                     & 
         ED_c_to_litr_lab_c        => this%ED_c_to_litr_lab_c_col                             , & ! Output: total labile    litter coming from ED. gC/m3/s
         ED_c_to_litr_cel_c        => this%ED_c_to_litr_cel_c_col                             , & ! Output: total cellulose litter coming from ED. gC/m3/s
         ED_c_to_litr_lig_c        => this%ED_c_to_litr_lig_c_col                             , & ! Output: total lignin    litter coming from ED. gC/m3/s
         leaf_prof                 => this%leaf_prof_col                                      , & ! Output: (1/m) profile of leaves                         
         froot_prof                => this%froot_prof_col                                     , & ! Output: (1/m) profile of fine roots                     
         croot_prof                => this%croot_prof_col                                     , & ! Output: (1/m) profile of coarse roots                         
         stem_prof                 => this%stem_prof_col                                      , & ! Output: (1/m) profile of leaves                         
         altmax_lastyear_indx      => canopystate_inst%altmax_lastyear_indx_col                 & ! Input:  [integer   (:)   ]frost table depth (m)       
         )
      
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ! first calculate vertical profiles
      ! define two types of profiles: 
      ! (1) a surface profile, for leaves and stem inputs, which is the same for each pft but differs from one column to the next to avoid inputting any C into permafrost
      ! (2) a fine root profile, which is indexed by both column and pft, differs for each pft and also from one column to the next to avoid inputting any C into permafrost
      ! (3) a coarse root profile, which is the root-biomass=weighted average of the fine root profiles
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (use_vertsoilc) then
         
         ! define a single shallow surface profile for surface additions (leaves, stems, and N deposition)
         surface_prof(:) = 0._r8
         do j = 1, nlevdecomp
            surface_prof(j) = exp(-surfprof_exp * zsoi(j)) / dzsoi_decomp(j)
         end do
         
         ! initialize profiles to zero
         leaf_prof(begc:endc, :)      = 0._r8
         froot_prof(begc:endc, 1:numpft_ed, :)     = 0._r8
         croot_prof(begc:endc, :)     = 0._r8
         stem_prof(begc:endc, :)      = 0._r8
         
         cinput_rootfr(begc:endc, 1:numpft_ed, :)     = 0._r8
         
         do c = bounds%begc,bounds%endc
            
            ! calculate pft-specific rooting profiles in the absence of permafrost limitations
            if ( exponential_rooting_profile ) then
               if ( .not. pftspecific_rootingprofile ) then
                  ! define rooting profile from exponential parameters
                  do ft = 1, numpft_ed
                     do j = 1, nlevdecomp
                        cinput_rootfr(c,ft,j) = exp(-rootprof_exp * zsoi(j)) / dzsoi_decomp(j)
                     end do
                  end do
               else
                  ! use beta distribution parameter from Jackson et al., 1996
                  do ft = 1, numpft_ed
                     do j = 1, nlevdecomp
                        cinput_rootfr(c,ft,j) = ( pftcon%rootprof_beta(ft) ** (zisoi(j-1)*100._r8) - &
                             pftcon%rootprof_beta(ft) ** (zisoi(j)*100._r8) ) &
                             / dzsoi_decomp(j)
                     end do
                  end do
               endif
            else
               do ft = 1,numpft_ed 
                  do j = 1, nlevdecomp
                     ! use standard CLM root fraction profiles;
                     cinput_rootfr(c,ft,j) =  ( .5_r8*( &
                          exp(-pftcon%roota_par(ft) * col%zi(c,lev-1))  &
                          + exp(-pftcon%rootb_par(ft) * col%zi(c,lev-1))  &
                          - exp(-pftcon%roota_par(ft) * col%zi(c,lev))    &
                          - exp(-pftcon%rootb_par(ft) * col%zi(c,lev))))  / dzsoi_decomp(j)
                  end do
               end do
            endif
            !
            !
            ! now add permafrost constraint: integrate rootfr over active layer of soil column,
            ! truncate below permafrost table where present, and rescale so that integral = 1
            do ft = 1,numpft_ed 
               rootfr_tot(ft) = 0._r8
            end do
            surface_prof_tot = 0._r8
            !
            do j = 1, min(max(altmax_lastyear_indx(c), 1), nlevdecomp)
               surface_prof_tot = surface_prof_tot + surface_prof(j)  * dzsoi_decomp(j)
            end do
            do ft = 1,numpft_ed 
               do j = 1, min(max(altmax_lastyear_indx(c), 1), nlevdecomp)
                  rootfr_tot(ft) = rootfr_tot(ft) + cinput_rootfr(c,ft,j) * dzsoi_decomp(j)
               end do
            end do
            !
            ! rescale the fine root profile
            do ft = 1,numpft_ed 
               if ( (altmax_lastyear_indx(c) > 0) .and. (rootfr_tot(ft) > 0._r8) ) then
                  ! where there is not permafrost extending to the surface, integrate the profiles over the active layer
                  ! this is equivalent to integrating over all soil layers outside of permafrost regions
                  do j = 1, min(max(altmax_lastyear_indx(c), 1), nlevdecomp)
                     froot_prof(c,ft,j) = cinput_rootfr(c,ft,j) / rootfr_tot(ft)
                  end do
               else
                  ! if fully frozen, or no roots, put everything in the top layer
                  froot_prof(c,ft,1) = 1./dzsoi_decomp(1)
               endif
            end do
            !
            ! rescale the shallow profiles
            if ( (altmax_lastyear_indx(c) > 0) .and. (surface_prof_tot > 0._r8) ) then
               ! where there is not permafrost extending to the surface, integrate the profiles over the active layer
               ! this is equivalent to integrating over all soil layers outside of permafrost regions
               do j = 1, min(max(altmax_lastyear_indx(c), 1), nlevdecomp)
                  ! set all surface processes to shallower profile
                  leaf_prof(c,j) = surface_prof(j)/ surface_prof_tot
                  stem_prof(c,j) = surface_prof(j)/ surface_prof_tot
               end do
            else
               ! if fully frozen, or no roots, put everything in the top layer
               leaf_prof(c,1) = 1./dzsoi_decomp(1)
               stem_prof(c,1) = 1./dzsoi_decomp(1)
            endif
         end do
         
      else
         
         ! for one layer decomposition model, set profiles to unity
         leaf_prof(bounds%begc:bounds%endc, :) = 1._r8
         froot_prof(bounds%begc:bounds%endc, 1:numpft_ed, :) = 1._r8
         stem_prof(bounds%begc:bounds%endc, :) = 1._r8
         
      end if
      
      ! sanity check to ensure they integrate to 1
      do c = bounds%begc,bounds%endc
         ! check the leaf and stem profiles
         leaf_prof_sum = 0._r8
         stem_prof_sum = 0._r8
         do j = 1, nlevdecomp
            leaf_prof_sum = leaf_prof_sum + leaf_prof(c,j) *  dzsoi_decomp(j)
            stem_prof_sum = stem_prof_sum + stem_prof(c,j) *  dzsoi_decomp(j)
         end do
         if ( ( abs(stem_prof_sum - 1._r8) > delta ) .or.  ( abs(leaf_prof_sum - 1._r8) > delta ) ) then
            write(iulog, *) 'profile sums: ',  leaf_prof_sum, stem_prof_sum
            write(iulog, *) 'surface_prof: ', surface_prof
            write(iulog, *) 'surface_prof_tot: ', surface_prof_tot
            write(iulog, *) 'leaf_prof: ',  leaf_prof(c,:)
            write(iulog, *) 'stem_prof: ',  stem_prof(c,:)
            write(iulog, *) 'altmax_lastyear_indx: ', altmax_lastyear_indx(c)
            write(iulog, *) 'dzsoi_decomp: ',  dzsoi_decomp            
            call endrun(msg=' ERROR: sum-1 > delta'//errMsg(__FILE__, __LINE__))
         endif
         ! now check each fine root profile
         do ft = 1,numpft_ed 
            froot_prof_sum = 0._r8
            do j = 1, nlevdecomp
               froot_prof_sum = froot_prof_sum + froot_prof(c,ft,j) *  dzsoi_decomp(j)
            end do
            if ( ( abs(froot_prof_sum - 1._r8) > delta ) ) then
               write(iulog, *) 'profile sums: ', froot_prof_sum
               call endrun(msg=' ERROR: sum-1 > delta'//errMsg(__FILE__, __LINE__))
            endif
         end do
      end do
      
      ! zero the column-level C input variables
      do c = bounds%begc,bounds%endc
         do j = 1, nlevdecomp
            ED_c_to_litr_lab_c(c,j) = 0._r8
            ED_c_to_litr_cel_c(c,j) = 0._r8
            ED_c_to_litr_lig_c(c,j) = 0._r8
         end do
      end do

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ! now disaggregate the inputs vertically, using the vertical profiles
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            
      do g = bounds%begg,bounds%endg
         if (firstsoilpatch(g) >= 0 .and. ed_allsites_inst(g)%istheresoil) then 
            currentPatch => ed_allsites_inst(g)%oldest_patch
            
           do while(associated(currentPatch))
              
              cs => currentpatch%siteptr
              cc = cs%clmcolumn
              
              ! the CWD pools lose information about which PFT they came from; for the stems this doesn't matter as they all have the same profile, 
              ! however for the coarse roots they may have different profiles.  to approximately recover this information, loop over all cohorts in patch 
              ! to calculate the total root biomass in that patch of each pft, and then rescale the croot_prof as the weighted average of the froot_prof
              biomass_bg_ft(1:numpft_ed) = 0._r8
              currentCohort => currentPatch%tallest
              do while(associated(currentCohort))      
                 biomass_bg_ft(currentCohort%pft) = biomass_bg_ft(currentCohort%pft) + currentCohort%b * (currentCohort%n / currentPatch%area) * (1.0_r8-ED_val_ag_biomass)
                 currentCohort => currentCohort%shorter
              enddo !currentCohort
              ! 
              biomass_bg_tot = 0._r8
              do ft = 1,numpft_ed 
                 biomass_bg_tot = biomass_bg_tot + biomass_bg_ft(ft)
              end do
              !         
              do j = 1, nlevdecomp
                 ! zero this for each patch
                 croot_prof_perpatch(j) = 0._r8
              end do
              !
              if ( biomass_bg_tot .gt. 0._r8) then
                 do ft = 1,numpft_ed 
                    do j = 1, nlevdecomp
                       croot_prof_perpatch(j) = croot_prof_perpatch(j) + froot_prof(cc,ft,j) * biomass_bg_ft(ft) / biomass_bg_tot
                    end do
                 end do
              else ! no biomass
                 croot_prof_perpatch(1) = 1./dzsoi_decomp(1)
              end if
              !
              ! add croot_prof as weighted average (weighted by patch area) of croot_prof_perpatch
              do j = 1, nlevdecomp
                 croot_prof(cc, j) = croot_prof(cc, j) + croot_prof_perpatch(j) * currentPatch%area / AREA
              end do
              !
              ! now disaggregate, vertically and by decomposition substrate type, the actual fluxes from CWD and litter pools
              !
              ! do c = 1, ncwd
              !    write(iulog,*)'cdk CWD_AG_out', c, currentpatch%CWD_AG_out(c), cwd_fcel_ed, currentpatch%area/AREA
              !    write(iulog,*)'cdk CWD_BG_out', c, currentpatch%CWD_BG_out(c), cwd_fcel_ed, currentpatch%area/AREA
              ! end do
              ! do ft = 1,numpft_ed
              !    write(iulog,*)'cdk leaf_litter_out', ft, currentpatch%leaf_litter_out(ft), cwd_fcel_ed, currentpatch%area/AREA
              !    write(iulog,*)'cdk root_litter_out', ft, currentpatch%root_litter_out(ft), cwd_fcel_ed, currentpatch%area/AREA
              ! end do
              ! !
              ! CWD pools fragmenting into decomposing litter pools. 
              do c = 1, ncwd
                 do j = 1, nlevdecomp                    
                    ED_c_to_litr_cel_c(cc,j) = ED_c_to_litr_cel_c(cc,j) + currentpatch%CWD_AG_out(c) * cwd_fcel_ed * currentpatch%area/AREA * stem_prof(cc,j)  
                    ED_c_to_litr_lig_c(cc,j) = ED_c_to_litr_lig_c(cc,j) + currentpatch%CWD_AG_out(c) * cwd_flig_ed * currentpatch%area/AREA * stem_prof(cc,j)
                    !
                    ED_c_to_litr_cel_c(cc,j) = ED_c_to_litr_cel_c(cc,j) + currentpatch%CWD_BG_out(c) * cwd_fcel_ed * currentpatch%area/AREA * croot_prof_perpatch(j)
                    ED_c_to_litr_lig_c(cc,j) = ED_c_to_litr_lig_c(cc,j) + currentpatch%CWD_BG_out(c) * cwd_flig_ed * currentpatch%area/AREA * croot_prof_perpatch(j)
                 end do
              end do
              
              ! leaf and fine root pools. 
              do ft = 1,numpft_ed
                 do j = 1, nlevdecomp
                    ED_c_to_litr_lab_c(cc,j) = ED_c_to_litr_lab_c(cc,j) + currentpatch%leaf_litter_out(ft) * pftcon%lf_flab(ft) * currentpatch%area/AREA * leaf_prof(cc,j)
                    ED_c_to_litr_cel_c(cc,j) = ED_c_to_litr_cel_c(cc,j) + currentpatch%leaf_litter_out(ft) * pftcon%lf_fcel(ft) * currentpatch%area/AREA * leaf_prof(cc,j)
                    ED_c_to_litr_lig_c(cc,j) = ED_c_to_litr_lig_c(cc,j) + currentpatch%leaf_litter_out(ft) * pftcon%lf_flig(ft) * currentpatch%area/AREA * leaf_prof(cc,j)
                    !
                    ED_c_to_litr_lab_c(cc,j) = ED_c_to_litr_lab_c(cc,j) + currentpatch%root_litter_out(ft) * pftcon%fr_flab(ft) * currentpatch%area/AREA * froot_prof(cc,ft,j)
                    ED_c_to_litr_cel_c(cc,j) = ED_c_to_litr_cel_c(cc,j) + currentpatch%root_litter_out(ft) * pftcon%fr_fcel(ft) * currentpatch%area/AREA * froot_prof(cc,ft,j)
                    ED_c_to_litr_lig_c(cc,j) = ED_c_to_litr_lig_c(cc,j) + currentpatch%root_litter_out(ft) * pftcon%fr_flig(ft) * currentpatch%area/AREA * froot_prof(cc,ft,j)
                 enddo
              end do
              
              currentPatch => currentPatch%younger
           end do !currentPatch
        end if
     end do
     
     do cc = bounds%begc,bounds%endc
        do j = 1, nlevdecomp                    
           ! time unit conversion
           ED_c_to_litr_lab_c(cc,j)=ED_c_to_litr_lab_c(cc,j) * mass_convert / time_convert
           ED_c_to_litr_cel_c(cc,j)=ED_c_to_litr_cel_c(cc,j) * mass_convert / time_convert
           ED_c_to_litr_lig_c(cc,j)=ED_c_to_litr_lig_c(cc,j) * mass_convert / time_convert
           
        end do
     end do

     ! write(iulog,*)'cdk ED_c_to_litr_lab_c: ', ED_c_to_litr_lab_c
     ! write(iulog,*)'cdk ED_c_to_litr_cel_c: ', ED_c_to_litr_cel_c    
     ! write(iulog,*)'cdk ED_c_to_litr_lig_c: ', ED_c_to_litr_lig_c

   end associate
 end subroutine flux_into_litter_pools
     

     
end module EDCLMLinkMod
