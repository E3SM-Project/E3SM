module EDCLMLinkMod

  ! ============================================================================
  ! Modules to control the passing of infomation generated by ED into CLM to be used for either 
  ! diagnostics, or as input to the land surface components. 
  ! ============================================================================

  use shr_kind_mod     , only : r8 => shr_kind_r8;
  use decompMod        , only : bounds_type
  use clm_varpar       , only : nclmax, nlevcan_ed, numpft, numcft
  use clm_varctl       , only : iulog 
  use EDtypesMod       , only : ed_site_type, ed_cohort_type, ed_patch_type
  !
  implicit none
  private
  !
  logical :: DEBUG = .false.  ! for debugging this module (EDCLMLinkMod.F90)

  type, public :: ed_clm_type

     real(r8), pointer, private  :: trimming_patch             (:) 
     real(r8), pointer, private  :: area_plant_patch           (:) 
     real(r8), pointer, private  :: area_trees_patch           (:) 
     real(r8), pointer, private  :: canopy_spread_patch        (:) 
     real(r8), pointer, private  :: PFTbiomass_patch           (:,:) ! total biomass of each patch
     real(r8), pointer, private  :: PFTleafbiomass_patch       (:,:) ! total biomass of each patch   
     real(r8), pointer, private  :: PFTstorebiomass_patch      (:,:) ! total biomass of each patch   
     real(r8), pointer, private  :: PFTnindivs_patch           (:,:) ! total biomass of each patch 

     real(r8), pointer, private  :: nesterov_fire_danger_patch (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: spitfire_ROS_patch         (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: effect_wspeed_patch        (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: TFC_ROS_patch              (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: fire_intensity_patch       (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: fire_area_patch            (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: scorch_height_patch        (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: fire_fuel_bulkd_patch      (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: fire_fuel_eff_moist_patch  (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: fire_fuel_sav_patch        (:)   ! total biomass of each patch       
     real(r8), pointer, private  :: fire_fuel_mef_patch        (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: sum_fuel_patch             (:)   ! total biomass of each patch 

     real(r8), pointer, private  :: litter_in_patch            (:)   ! total biomass of each patch 
     real(r8), pointer, private  :: litter_out_patch           (:)   ! total biomass of each patch    
     real(r8), pointer, private  :: efpot_patch                (:)   ! potential transpiration
     real(r8), pointer, private  :: rb_patch                   (:)   ! boundary layer conductance

     real(r8), pointer, private  :: daily_temp_patch           (:)   ! daily temperature for fire and phenology models
     real(r8), pointer, private  :: daily_rh_patch             (:)   ! daily RH for fire model
     real(r8), pointer, private  :: daily_prec_patch           (:)   ! daily rain for fire and phenology models. 

     !seed model. Aggregated to gridcell for now. 

     real(r8), pointer, private  :: seed_bank_patch            (:)   ! kGC/m2      Mass of seeds.                 
     real(r8), pointer, private  :: seeds_in_patch             (:)   ! kGC/m2/year Production of seed mass.       
     real(r8), pointer, private  :: seed_decay_patch           (:)   ! kGC/m2/year Decay of seed mass.            
     real(r8), pointer, private  :: seed_germination_patch     (:)   ! kGC/m2/year Germiantion rate of seed mass. 

     real(r8), pointer, private  :: ED_bstore_patch            (:)   ! kGC/m2 Total stored biomass. 
     real(r8), pointer, private  :: ED_bdead_patch             (:)   ! kGC/m2 Total dead biomass.   
     real(r8), pointer, private  :: ED_balive_patch            (:)   ! kGC/m2 Total alive biomass.  
     real(r8), pointer, private  :: ED_bleaf_patch             (:)   ! kGC/m2 Total leaf biomass.   
     real(r8), pointer, private  :: ED_biomass_patch           (:)   ! kGC/m2 Total biomass.        

     real(r8), pointer, private  :: storvegc_patch             (:)   ! (gC/m2) stored vegetation carbon, excluding cpool
     real(r8), pointer, private  :: dispvegc_patch             (:)   ! (gC/m2) displayed veg carbon, excluding storage and cpool
     real(r8), pointer, private  :: leafc_patch                (:)   ! (gC/m2) leaf C
     real(r8), pointer, private  :: livestemc_patch            (:)   ! (gC/m2) live stem C
     real(r8), pointer, private  :: deadstemc_patch            (:)   ! (gC/m2) dead stem C
     real(r8), pointer, private  :: livestemn_patch            (:)   ! (gN/m2) live stem N
     real(r8), pointer, private  :: npp_patch                  (:)   ! (gC/m2/s) patch net primary production
     real(r8), pointer, private  :: gpp_patch                  (:)   ! (gC/m2/s) patch gross primary production 

   contains

     ! Public routines
     procedure , public  :: Init   
     procedure , public  :: Restart
     procedure , public  :: SetValues
     procedure , public  :: ed_clm_link

     ! Private routines
     procedure , private :: ed_clm_leaf_area_profile
     procedure , private :: ed_update_history_variables
     procedure , private :: InitAllocate 
     procedure , private :: InitHistory
     procedure , private :: InitCold     

  end type ed_clm_type

  ! 10/30/09: Created by Rosie Fisher
  !-----------------------------------------------------------------------

contains

  !------------------------------------------------------------------------
  subroutine Init(this, bounds)
    !
    ! !DESCRIPTION:
    ! Initialize module data structure instance
    !
    ! !ARGUMENTS:
    class(ed_clm_type) :: this
    type(bounds_type), intent(in) :: bounds  
    !-----------------------------------------------------------------------

    call this%InitAllocate(bounds)
    call this%InitHistory(bounds)
    call this%InitCold(bounds)

  end subroutine Init

  !------------------------------------------------------------------------
  subroutine InitAllocate(this, bounds)
    !
    ! !USES: 
    use shr_infnan_mod , only : nan => shr_infnan_nan, assignment(=)
    use clm_varpar     , only : nlevgrnd
    !
    ! !ARGUMENTS:
    class (ed_clm_type) :: this 
    type(bounds_type), intent(in)    :: bounds 
    !
    ! !LOCAL VARIABLES:
    integer           :: begp,endp
    !------------------------------------------------------------------------

    begp = bounds%begp; endp = bounds%endp

    allocate(this%trimming_patch             (begp:endp))            ; this%trimming_patch             (:) = 0.0_r8    
    allocate(this%canopy_spread_patch        (begp:endp))            ; this%canopy_spread_patch        (:) = 0.0_r8    
    allocate(this%area_plant_patch           (begp:endp))            ; this%area_plant_patch           (:) = 0.0_r8    
    allocate(this%area_trees_patch           (begp:endp))            ; this%area_trees_patch           (:) = 0.0_r8    
    allocate(this%PFTbiomass_patch           (begp:endp,1:nlevgrnd)) ; this%PFTbiomass_patch           (:,:) = 0.0_r8    
    allocate(this%PFTleafbiomass_patch       (begp:endp,1:nlevgrnd)) ; this%PFTleafbiomass_patch       (:,:) = 0.0_r8    
    allocate(this%PFTstorebiomass_patch      (begp:endp,1:nlevgrnd)) ; this%PFTstorebiomass_patch      (:,:) = 0.0_r8    
    allocate(this%PFTnindivs_patch           (begp:endp,1:nlevgrnd)) ; this%PFTnindivs_patch           (:,:) = 0.0_r8    
    allocate(this%nesterov_fire_danger_patch (begp:endp))            ; this%nesterov_fire_danger_patch (:) = 0.0_r8    
    allocate(this%spitfire_ROS_patch         (begp:endp))            ; this%spitfire_ROS_patch         (:) = 0.0_r8    
    allocate(this%effect_wspeed_patch        (begp:endp))            ; this%effect_wspeed_patch        (:) = 0.0_r8    
    allocate(this%TFC_ROS_patch              (begp:endp))            ; this%TFC_ROS_patch              (:) = 0.0_r8    
    allocate(this%fire_intensity_patch       (begp:endp))            ; this%fire_intensity_patch       (:) = 0.0_r8    
    allocate(this%fire_area_patch            (begp:endp))            ; this%fire_area_patch            (:) = 0.0_r8    
    allocate(this%scorch_height_patch        (begp:endp))            ; this%scorch_height_patch        (:) = 0.0_r8    
    allocate(this%fire_fuel_bulkd_patch      (begp:endp))            ; this%fire_fuel_bulkd_patch      (:) = 0.0_r8    
    allocate(this%fire_fuel_eff_moist_patch  (begp:endp))            ; this%fire_fuel_eff_moist_patch  (:) = 0.0_r8    
    allocate(this%fire_fuel_sav_patch        (begp:endp))            ; this%fire_fuel_sav_patch        (:) = 0.0_r8    
    allocate(this%fire_fuel_mef_patch        (begp:endp))            ; this%fire_fuel_mef_patch        (:) = 0.0_r8    
    allocate(this%sum_fuel_patch             (begp:endp))            ; this%sum_fuel_patch             (:) = 0.0_r8    
    allocate(this%litter_in_patch            (begp:endp))            ; this%litter_in_patch            (:) = 0.0_r8    
    allocate(this%litter_out_patch           (begp:endp))            ; this%litter_out_patch           (:) = 0.0_r8    
    allocate(this%efpot_patch                (begp:endp))            ; this%efpot_patch                (:) = 0.0_r8    
    allocate(this%rb_patch                   (begp:endp))            ; this%rb_patch                   (:) = 0.0_r8    
    allocate(this%seed_bank_patch            (begp:endp))            ; this%seed_bank_patch            (:) = 0.0_r8    
    allocate(this%seed_decay_patch           (begp:endp))            ; this%seed_decay_patch           (:) = 0.0_r8    
    allocate(this%seeds_in_patch             (begp:endp))            ; this%seeds_in_patch             (:) = 0.0_r8    
    allocate(this%seed_germination_patch     (begp:endp))            ; this%seed_germination_patch     (:) = 0.0_r8    
    allocate(this%ED_bstore_patch            (begp:endp))            ; this%ED_bstore_patch            (:) = 0.0_r8    
    allocate(this%ED_bdead_patch             (begp:endp))            ; this%ED_bdead_patch             (:) = 0.0_r8    
    allocate(this%ED_balive_patch            (begp:endp))            ; this%ED_balive_patch            (:) = 0.0_r8    
    allocate(this%ED_bleaf_patch             (begp:endp))            ; this%ED_bleaf_patch             (:) = 0.0_r8    
    allocate(this%ED_biomass_patch           (begp:endp))            ; this%ED_biomass_patch           (:) = 0.0_r8    

    allocate(this%storvegc_patch             (begp:endp))            ; this%storvegc_patch             (:) = nan
    allocate(this%dispvegc_patch             (begp:endp))            ; this%dispvegc_patch             (:) = nan
    allocate(this%leafc_patch                (begp:endp))            ; this%leafc_patch                (:) = nan
    allocate(this%livestemc_patch            (begp:endp))            ; this%livestemc_patch            (:) = nan
    allocate(this%deadstemc_patch            (begp:endp))            ; this%deadstemc_patch            (:) = nan
    allocate(this%livestemn_patch            (begp:endp))            ; this%livestemn_patch            (:) = nan

    allocate(this%gpp_patch                  (begp:endp))            ; this%gpp_patch                  (:) = nan
    allocate(this%npp_patch                  (begp:endp))            ; this%npp_patch                  (:) = nan

  end subroutine InitAllocate

  !------------------------------------------------------------------------
  subroutine InitHistory(this, bounds)
    !
    ! !DESCRIPTION:
    ! add history fields for all variables, always set as default='inactive'
    !
    ! !USES:
    use clm_varpar , only : ndecomp_cascade_transitions, ndecomp_pools
    use clm_varpar , only : nlevdecomp, nlevdecomp_full, crop_prog
    use clm_varcon , only : spval
    use histFileMod, only : hist_addfld1d, hist_addfld2d, hist_addfld_decomp 
    !
    ! !ARGUMENTS:
    class(ed_clm_type) :: this    
    type(bounds_type)         , intent(in) :: bounds 
    !
    ! !LOCAL VARIABLES:
    integer           :: k,l,ii,jj 
    character(8)      :: vr_suffix
    character(10)     :: active
    integer           :: begp,endp
    integer           :: begc,endc
    character(24)     :: fieldname
    character(100)    :: longname
    real(r8), pointer :: data1dptr(:)   ! temp. pointer for slicing larger arrays
    !---------------------------------------------------------------------

    begp = bounds%begp; endp = bounds%endp
    begc = bounds%begc; endc = bounds%endc

    call hist_addfld1d (fname='TRIMMING', units='none',  &
         avgflag='A', long_name='Degree to which canopy expansion is limited by leaf economics', &
         ptr_patch=this%trimming_patch, set_lake=0._r8, set_urb=0._r8)  

    call hist_addfld1d (fname='AREA_PLANT', units='m2',  &
         avgflag='A', long_name='area occupied by all plants', &
         ptr_patch=this%area_plant_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='AREA_TREES', units='m2',  &
         avgflag='A', long_name='area occupied by woody plants', &
         ptr_patch=this%area_trees_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='CANOPY_SPREAD', units='none',  &   
         avgflag='A', long_name='Scaling factor between tree basal area and canopy area', &
         ptr_patch=this%canopy_spread_patch, set_lake=0._r8, set_urb=0._r8)   

    call hist_addfld2d (fname='PFTbiomass',  units='kgC/m2', type2d='levgrnd', &
         avgflag='A', long_name='total PFT level biomass', &
         ptr_patch=this%PFTbiomass_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld2d (fname='PFTleafbiomass',  units='kgC/m2', type2d='levgrnd', &
         avgflag='A', long_name='total PFT level biomass', &
         ptr_patch=this%PFTleafbiomass_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld2d (fname='PFTstorebiomass',  units='kgC/m2', type2d='levgrnd', &
         avgflag='A', long_name='total PFT level biomass', &
         ptr_patch=this%PFTstorebiomass_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld2d (fname='PFTnindivs',  units='kgC/m2', type2d='levgrnd', &
         avgflag='A', long_name='total PFT level biomass', &
         ptr_patch=this%PFTnindivs_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='FIRE_NESTEROV_INDEX', units='none',  &
         avgflag='A', long_name='nesterov_fire_danger index', &
         ptr_patch=this%nesterov_fire_danger_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='FIRE_ROS', units='m/min',  &
         avgflag='A', long_name='fire rate of spread m/min', &
         ptr_patch=this%spitfire_ROS_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='EFFECT_WSPEED', units='none',  &
         avgflag='A', long_name='effective windspeed for fire spread', &
         ptr_patch=this%effect_wspeed_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='FIRE_TFC_ROS', units='none',  &
         avgflag='A', long_name='total fuel consumed', &
         ptr_patch=this%TFC_ROS_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='FIRE_INTENSITY', units='kJ/m/s',  &
         avgflag='A', long_name='spitfire fire intensity: kJ/m/s', &
         ptr_patch=this%fire_intensity_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='FIRE_AREA', units='fraction',  &
         avgflag='A', long_name='spitfire fire area:m2', &
         ptr_patch=this%fire_area_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SCORCH_HEIGHT', units='m',  &
         avgflag='A', long_name='spitfire fire area:m2', &
         ptr_patch=this%scorch_height_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='fire_fuel_mef', units='m',  &
         avgflag='A', long_name='spitfire fuel moisture', &
         ptr_patch=this%fire_fuel_mef_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='fire_fuel_bulkd', units='m',  &
         avgflag='A', long_name='spitfire fuel bulk density', &
         ptr_patch=this%fire_fuel_bulkd_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='fire_fuel_eff_moist', units='m',  &
         avgflag='A', long_name='spitfire fuel moisture', &
         ptr_patch=this%fire_fuel_eff_moist_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='fire_fuel_sav', units='m',  &
         avgflag='A', long_name='spitfire fuel surface/volume ', &
         ptr_patch=this%fire_fuel_sav_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='TFC_ROS', units='m',  &
         avgflag='A', long_name='spitfire fuel surface/volume ', &
         ptr_patch=this%TFC_ROS_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SUM_FUEL', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Litter flux in leaves', &
         ptr_patch=this%sum_fuel_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='LITTER_IN', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Litter flux in leaves', &
         ptr_patch=this%litter_in_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='LITTER_OUT', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Litter flux out leaves', &
         ptr_patch=this%litter_out_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SEED_BANK', units=' KgC m-2',  &
         avgflag='A', long_name='Total Seed Mass of all PFTs', &
         ptr_patch=this%seed_bank_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SEEDS_IN', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Seed Production Rate', &
         ptr_patch=this%seeds_in_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SEED_GERMINATION', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Seed mass converted into new cohorts', &
         ptr_patch=this%seed_germination_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='SEED_DECAY', units=' KgC m-2 y-1',  &
         avgflag='A', long_name='Seed mass decay', &
         ptr_patch=this%seed_decay_patch, set_lake=0._r8, set_urb=0._r8)              

    call hist_addfld1d (fname='ED_bstore', units=' KgC m-2',  &
         avgflag='A', long_name='ED stored biomass', &
         ptr_patch=this%ED_bstore_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='ED_bdead', units=' KgC m-2',  &
         avgflag='A', long_name='ED dead biomass', &
         ptr_patch=this%ED_bdead_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='ED_balive', units=' KgC m-2',  &
         avgflag='A', long_name='ED live biomass', &
         ptr_patch=this%ED_balive_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='ED_bleaf', units=' KgC m-2',  &
         avgflag='A', long_name='ED leaf biomass', &
         ptr_patch=this%ED_bleaf_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='ED_biomass', units=' KgC m-2',  &
         avgflag='A', long_name='ED total biomass', &
         ptr_patch=this%ED_biomass_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='RB', units=' s m-1',  &
         avgflag='A', long_name='leaf boundary resistance', &
         ptr_patch=this%rb_patch, set_lake=0._r8, set_urb=0._r8)

    call hist_addfld1d (fname='EFPOT', units='',  &
         avgflag='A', long_name='potential evap', &
         ptr_patch=this%efpot_patch, set_lake=0._r8, set_urb=0._r8)

    this%dispvegc_patch(begp:endp) = spval
    call hist_addfld1d (fname='DISPVEGC', units='gC/m^2', &
         avgflag='A', long_name='displayed veg carbon, excluding storage and cpool', &
         ptr_patch=this%dispvegc_patch)

    this%storvegc_patch(begp:endp) = spval
    call hist_addfld1d (fname='STORVEGC', units='gC/m^2', &
         avgflag='A', long_name='stored vegetation carbon, excluding cpool', &
         ptr_patch=this%storvegc_patch)

    this%leafc_patch(begp:endp) = spval
    call hist_addfld1d (fname='LEAFC', units='gC/m^2', &
         avgflag='A', long_name='leaf C', &
         ptr_patch=this%leafc_patch)

    this%livestemc_patch(begp:endp) = spval
    call hist_addfld1d (fname='LIVESTEMC', units='gC/m^2', &
         avgflag='A', long_name='live stem C', &
         ptr_patch=this%livestemc_patch)

    this%deadstemc_patch(begp:endp) = spval
    call hist_addfld1d (fname='DEADSTEMC', units='gC/m^2', &
         avgflag='A', long_name='dead stem C', &
         ptr_patch=this%deadstemc_patch)

    this%livestemn_patch(begp:endp) = spval
    call hist_addfld1d (fname='LIVESTEMN', units='gN/m^2', &
         avgflag='A', long_name='live stem N', &
         ptr_patch=this%livestemn_patch)

    this%gpp_patch(begp:endp) = spval
    call hist_addfld1d (fname='GPP', units='gC/m^2/s', &
         avgflag='A', long_name='gross primary production', &
         ptr_patch=this%gpp_patch)

    this%npp_patch(begp:endp) = spval
    call hist_addfld1d (fname='NPP', units='gC/m^2/s', &
         avgflag='A', long_name='net primary production', &
         ptr_patch=this%npp_patch)

  end subroutine InitHistory

  !-----------------------------------------------------------------------
  subroutine InitCold(this, bounds)
    !
    ! !DESCRIPTION:
    ! Initialize relevant time varying variables
    !
    ! !ARGUMENTS:
    class (ed_clm_type) :: this
    type(bounds_type), intent(in) :: bounds  
    !
    ! !LOCAL VARIABLES:
    integer :: p
    !-----------------------------------------------------------------------

    do p = bounds%begp,bounds%endp
       this%dispvegc_patch(p) = 0._r8 
       this%storvegc_patch(p) = 0._r8 
    end do

  end subroutine InitCold

  !-----------------------------------------------------------------------
  subroutine Restart ( this,  bounds, ncid, flag )
    !
    ! !DESCRIPTION: 
    ! Read/write restart data 
    !
    ! !USES:
    use restUtilMod
    use ncdio_pio
    !
    ! !ARGUMENTS:
    class (ed_clm_type) :: this
    type(bounds_type) , intent(in)    :: bounds 
    type(file_desc_t) , intent(inout) :: ncid   
    character(len=*)  , intent(in)    :: flag   !'read' or 'write' or 'define'
    !
    ! !LOCAL VARIABLES:
    logical            :: readvar
    !------------------------------------------------------------------------

    call restartvar(ncid=ncid, flag=flag, varname='leafc', xtype=ncd_double,  &
         dim1name='pft', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=this%leafc_patch) 

    call restartvar(ncid=ncid, flag=flag, varname='livestemc', xtype=ncd_double,  &
         dim1name='pft', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=this%livestemc_patch) 

    call restartvar(ncid=ncid, flag=flag, varname='deadstemc', xtype=ncd_double,  &
         dim1name='pft', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=this%deadstemc_patch) 

    call restartvar(ncid=ncid, flag=flag, varname='livestemn', xtype=ncd_double,  &
         dim1name='pft', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=this%livestemn_patch) 

  end subroutine Restart

  !-----------------------------------------------------------------------
  subroutine SetValues( this, bounds, val)
    !
    ! !ARGUMENTS:
    class (ed_clm_type)            :: this
    type(bounds_type) , intent(in) :: bounds 
    real(r8)          , intent(in) :: val
    !
    ! !LOCAL VARIABLES:
    integer :: fi,i,j,k,l     ! loop index
    !-----------------------------------------------------------------------

    !
    ! FIX(SPM,082714) - commenting these lines out while merging ED branch to CLM
    ! trunk.  Commented out by RF to work out science issues
    !
    !this%trimming_patch        (:) = val
    !this%canopy_spread_patch   (:) = val
    !this%PFTbiomass_patch      (:,:) = val
    !this%PFTleafbiomass_patch  (:,:) = val
    !this%PFTstorebiomass_patch (:,:) = val
    !this%PFTnindivs_patch      (:,:) = val
    this%efpot_patch            (:) = val
    this%rb_patch               (:) = val

  end subroutine SetValues

  !-----------------------------------------------------------------------
  subroutine ed_clm_link( this, bounds, ed_allsites_inst, ed_phenology_inst, &
       waterstate_inst, canopystate_inst)
    !
    ! !USES: 
    use landunit_varcon      , only : istsoil
    use EDGrowthFunctionsMod , only : tree_lai, c_area
    use EDEcophysConType     , only : EDecophyscon
    use EDPhenologyType      , only : ed_phenology_type
    use EDtypesMod           , only : area
    use PatchType            , only : clmpatch => patch
    use ColumnType           , only : col
    use LandunitType         , only : lun
    use pftconMod            , only : pftcon
    use CanopyStateType      , only : canopystate_type
    use WaterStateType       , only : waterstate_type
    !
    ! !ARGUMENTS    
    class(ed_clm_type)                              :: this
    type(bounds_type)       , intent(in)            :: bounds  
    type(ed_site_type)      , intent(inout), target :: ed_allsites_inst( bounds%begg: )
    type(ed_phenology_type) , intent(inout)         :: ed_phenology_inst
    type(waterstate_type)   , intent(inout)         :: waterstate_inst
    type(canopystate_type)  , intent(inout)         :: canopystate_inst
    !
    ! !LOCAL VARIABLES:
    type (ed_patch_type)  , pointer :: currentPatch
    type (ed_cohort_type) , pointer :: currentCohort
    integer  :: g,l,p,c
    integer  :: ft                                      ! plant functional type
    integer  :: patchn                                  ! identification number for each patch. 
    integer  :: firstsoilpatch(bounds%begg:bounds%endg) ! the first patch in this gridcell that is soil and thus bare... 
    real(r8) :: total_bare_ground                       ! sum of the bare fraction in all pfts.
    real(r8) :: total_patch_area                               
    real(r8) :: coarse_wood_frac  
    real(r8) :: canopy_leaf_area                        ! total amount of leaf area in the vegetated area. m2.  
    integer  :: sitecolumn(bounds%begg:bounds%endg)
    logical  :: istheresoil(bounds%begg:bounds%endg) 
    !----------------------------------------------------------------------

    if (DEBUG) then
       write(iulog,*) 'in ed_clm_link'
    endif

    associate(                                 & 
         tlai => canopystate_inst%tlai_patch , &
         elai => canopystate_inst%elai_patch , &
         tsai => canopystate_inst%tsai_patch , &
         esai => canopystate_inst%esai_patch , &
         htop => canopystate_inst%htop_patch , &
         hbot => canopystate_inst%hbot_patch , & 
         begg => bounds%begg                 , &
         endg => bounds%endg                 , &
         begc => bounds%begc                 , &
         endc => bounds%endc                 , &
         begp => bounds%begp                 , &
         endp => bounds%endp                   &
         )

      ! determine if gridcell is soil 

      istheresoil(begg:endg) = .false.
      do c = begc,endc
         g = col%gridcell(c)   
         l = col%landunit(c)

         if (lun%itype(l) == istsoil .and. col%itype(c) == istsoil) then  
            istheresoil(g) = .true.
         endif
         ed_allsites_inst(g)%istheresoil = istheresoil(g)
      enddo

      ! retrieve the first soil patch associated with each gridcell. 
      ! make sure we only get the first patch value for places which have soil. 

      firstsoilpatch(begg:endg) = -999
      do c = begc,endc
         g = col%gridcell(c)
         l = col%landunit(c)

         if (lun%itype(l) == istsoil .and. col%itype(c) == istsoil) then 
            firstsoilpatch(g) = col%patchi(c)
            sitecolumn(g) = c
         endif
      enddo

      ! ============================================================================
      ! Zero the whole variable so we dont have ghost values when patch number declines.
      ! ============================================================================

      clmpatch%is_veg(begp:endp)        = .false. 
      clmpatch%is_bareground(begp:endp) = .false. 
      tlai(begp:endp)                   = 0.0_r8    
      elai(firstsoilpatch(g))           = 0.0_r8
      tsai(firstsoilpatch(g))           = 0.0_r8
      esai(firstsoilpatch(g))           = 0.0_r8
      htop(begp:endp)                   = 0.0_r8      
      hbot(begp:endp)                   = 0.0_r8   

      do g = begg,endg

         if(firstsoilpatch(g) >= 0.and.ed_allsites_inst(g)%istheresoil)then 
            ed_allsites_inst(g)%clmcolumn = sitecolumn(g)

            ! ============================================================================
            ! Zero the bare ground tile BGC variables.
            ! ============================================================================

            tlai(firstsoilpatch(g)) = 0.0_r8    
            htop(firstsoilpatch(g)) = 0.0_r8      
            hbot(firstsoilpatch(g)) = 0.0_r8      

            patchn = 0
            total_bare_ground = 0.0_r8
            total_patch_area = 0._r8 

            currentPatch => ed_allsites_inst(g)%oldest_patch
            do while(associated(currentPatch))
               patchn = patchn + 1
               currentPatch%patchno = patchn

               if (patchn <= numpft - numcft)then !don't expand into crop patches.   

                  currentPatch%clm_pno = firstsoilpatch(g) + patchn !the first 'soil' patch is unvegetated...      
                  p = currentPatch%clm_pno
                  c = clmpatch%column(p)
                  clmpatch%is_veg(p) = .true. !this .is. a tile filled with vegetation... 
                  
                  call currentPatch%set_root_fraction()

                  !zero cohort-summed variables. 
                  currentPatch%total_canopy_area = 0.0_r8
                  currentPatch%total_tree_area = 0.0_r8
                  currentPatch%lai = 0.0_r8
                  canopy_leaf_area = 0.0_r8

                  !update cohort quantitie s                                  
                  currentCohort => currentPatch%shortest
                  do while(associated(currentCohort))
                     ft = currentCohort%pft
                     currentCohort%livestemn = currentCohort%bsw  / pftcon%leafcn(currentCohort%pft)

                     if (pftcon%woody(ft) == 1) then
                        coarse_wood_frac = 0.5_r8
                     else
                        coarse_wood_frac = 0.0_r8
                     end if

                     currentCohort%livecrootn = currentCohort%br * coarse_wood_frac / pftcon%leafcn(ft)
                     currentCohort%b = currentCohort%balive+currentCohort%bdead+currentCohort%bstore
                     currentCohort%treelai = tree_lai(currentCohort)
                     ! Why is currentCohort%c_area used and then reset in the
                     ! following line?
                     canopy_leaf_area = canopy_leaf_area + currentCohort%treelai *currentCohort%c_area
                     currentCohort%c_area = c_area(currentCohort)

                     if(currentCohort%canopy_layer==1)then
                        currentPatch%total_canopy_area = currentPatch%total_canopy_area + currentCohort%c_area
                        if(pftcon%woody(ft)==1)then
                           currentPatch%total_tree_area = currentPatch%total_tree_area + currentCohort%c_area
                        endif
                     endif

                     ! Check for erroneous zero values. 
                     if(currentCohort%dbh <= 0._r8 .or. currentCohort%n == 0._r8)then
                        write(iulog,*) 'ED: dbh or n is zero in clmedlink', currentCohort%dbh,currentCohort%n
                     endif
                     if(currentCohort%pft == 0.or.currentCohort%canopy_trim <= 0._r8)then
                        write(iulog,*) 'ED: PFT or trim is zero in clmedlink',currentCohort%pft,currentCohort%canopy_trim
                     endif
                     if(currentCohort%balive <= 0._r8)then
                        write(iulog,*) 'ED: balive is zero in clmedlink',currentCohort%balive
                     endif

                     currentCohort => currentCohort%taller

                  enddo ! ends 'do while(associated(currentCohort))

                  if ( currentPatch%total_canopy_area-currentPatch%area > 0.000001_r8 ) then
                     write(iulog,*) 'canopy area bigger than area',currentPatch%total_canopy_area ,currentPatch%area
                     currentPatch%total_canopy_area = currentPatch%area
                  endif

                  ! PASS BACK PATCH-LEVEL QUANTITIES THAT ARE NEEDED BY THE CLM CODE
                  if (associated(currentPatch%tallest)) then
                     htop(p) = currentPatch%tallest%hite
                  else
                     ! FIX(RF,040113) - should this be a parameter for the minimum possible vegetation height?
                     htop(p) = 0.1_r8
                  endif

                  hbot(p) = max(0._r8, min(0.2_r8, htop(p)- 1.0_r8))

                  ! leaf area index: of .only. the areas with some vegetation on them, as the non-vegetated areas 
                  ! are merged into the bare ground fraction. This introduces a degree of unrealism, 
                  ! which could be fixed if the surface albedo routine took account of the possibiltiy of bare 
                  ! ground mixed with trees. 

                  if(currentPatch%total_canopy_area > 0)then;
                     tlai(p) = canopy_leaf_area/currentPatch%total_canopy_area 
                  else
                     tlai(p) = 0.0_r8
                  endif

                  !write(iulog,*) 'tlai',tlai(p)
                  !write(iulog,*) 'htop',htop(p)

                  ! We are assuming here that grass is all located underneath tree canopies. 
                  ! The alternative is to assume it is all spatial distinct from tree canopies.
                  ! In which case, the bare area would have to be reduced by the grass area...
                  ! currentPatch%total_canopy_area/currentPatch%area is fraction of this patch cover by plants 
                  ! currentPatch%area/AREA is the fraction of the soil covered by this patch. 

                  clmpatch%wt_ed(p) = min(1.0_r8,(currentPatch%total_canopy_area/currentPatch%area)) * (currentPatch%area/AREA)
                  currentPatch%bare_frac_area = (1.0_r8 - min(1.0_r8,currentPatch%total_canopy_area/currentPatch%area)) * &
                       (currentPatch%area/AREA)                 
                  ! write(iulog,*) 'bare frac',currentPatch%bare_frac_area
                  total_patch_area = total_patch_area + clmpatch%wt_ed(p) + currentPatch%bare_frac_area
                  total_bare_ground = total_bare_ground + currentPatch%bare_frac_area
                  currentCohort=> currentPatch%tallest

               else
                  write(iulog,*) 'ED: too many patches' 
               end if ! patchn<15

               currentPatch => currentPatch%younger
            end do !patch loop

            if((total_patch_area-1.0_r8)>1e-9)then
               write(iulog,*) 'total area is wrong in CLMEDLINK',total_patch_area
            endif

            !loop round all and zero the remaining empty vegetation patches 
            do p = firstsoilpatch(g)+patchn+1,firstsoilpatch(g)+numpft   
               clmpatch%wt_ed(p) = 0.0_r8
            enddo

            !set the area of the bare ground patch. 
            p = firstsoilpatch(g) 
            clmpatch%wt_ed(p) = total_bare_ground
            clmpatch%is_bareground = .true.
         endif ! are there any soil patches?    

         call this%ed_clm_leaf_area_profile(ed_allsites_inst(g), waterstate_inst, canopystate_inst ) 

      end do !grid loop

      call this%ed_update_history_variables( bounds, ed_allsites_inst(begg:endg), &
           firstsoilpatch, ed_Phenology_inst, canopystate_inst)

    end associate

  end subroutine ed_clm_link

  !-----------------------------------------------------------------------
  subroutine ed_update_history_variables( this, bounds, ed_allsites_inst, &
       firstsoilpatch, ed_Phenology_inst, canopystate_inst)
    !
    ! !USES: 
    use EDPhenologyType  , only : ed_phenology_type
    use CanopyStateType  , only : canopystate_type
    use PatchType        , only : clmpatch => patch
    !
    ! !ARGUMENTS:
    class(ed_clm_type)                              ::  this
    type(bounds_type)       , intent(in)            :: bounds  ! clump bounds
    type(ed_site_type)      , intent(inout), target :: ed_allsites_inst( bounds%begg: )
    type(ed_patch_type)     , pointer               :: currentPatch
    type(ed_cohort_type)    , pointer               :: currentCohort
    type(ed_phenology_type) , intent(inout)         :: ed_phenology_inst
    type(canopystate_type)  , intent(inout)         :: canopystate_inst
    !
    ! !LOCAL VARIABLES:
    integer  :: G,p,ft
    integer  :: firstsoilpatch(bounds%begg:bounds%endg)
    real(r8) :: n_density   ! individual of cohort per m2.
    !-----------------------------------------------------------------------

    associate(                                                           &
         trimming             => this%trimming_patch             , & ! Output:
         canopy_spread        => this%canopy_spread_patch        , & ! Output:
         PFTbiomass           => this%PFTbiomass_patch           , & ! Output:
         PFTleafbiomass       => this%PFTleafbiomass_patch       , & ! Output:
         PFTstorebiomass      => this%PFTstorebiomass_patch      , & ! Output:
         PFTnindivs           => this%PFTnindivs_patch           , & ! Output:
         area_plant           => this%area_plant_patch           , & ! Output:
         area_trees           => this%area_trees_patch           , & ! Output:
         nesterov_fire_danger => this%nesterov_fire_danger_patch , & ! Output:
         spitfire_ROS         => this%spitfire_ROS_patch         , & ! Output:
         effect_wspeed        => this%effect_wspeed_patch        , & ! Output:
         TFC_ROS              => this%TFC_ROS_patch              , & ! Output:
         sum_fuel             => this%sum_fuel_patch             , & ! Output:
         fire_intensity       => this%fire_intensity_patch       , & ! Output:
         fire_area            => this%fire_area_patch            , & ! Output:
         scorch_height        => this%scorch_height_patch        , & ! Output:
         fire_fuel_bulkd      => this%fire_fuel_bulkd_patch      , & ! Output:
         fire_fuel_eff_moist  => this%fire_fuel_eff_moist_patch  , & ! Output:
         fire_fuel_sav        => this%fire_fuel_sav_patch        , & ! Output:
         fire_fuel_mef        => this%fire_fuel_mef_patch        , & ! Output:
         litter_in            => this%litter_in_patch            , & ! Output:
         litter_out           => this%litter_out_patch           , & ! Output:
         seed_bank            => this%seed_bank_patch            , & ! Output:
         seeds_in             => this%seeds_in_patch             , & ! Output:
         seed_decay           => this%seed_decay_patch           , & ! Output:
         seed_germination     => this%seed_germination_patch     , & ! Output:
         
         ED_biomass           => this%ED_biomass_patch           , & ! InOut:
         ED_bdead             => this%ED_bdead_patch             , & ! InOut:
         ED_bleaf             => this%ED_bleaf_patch             , & ! InOut:
         ED_balive            => this%ED_balive_patch            , & ! InOut:
         ED_bstore            => this%ED_bstore_patch            , & ! InOut:
         
         phen_cd_status       => ed_phenology_inst%phen_cd_status_patch , & ! InOut:
         
         gpp                  => this%gpp_patch                  , & ! Output: 
         npp                  => this%npp_patch                  , & ! Output:
         
         tlai                 => canopystate_inst%tlai_patch     , & ! InOut:
         elai                 => canopystate_inst%elai_patch     , & ! InOut:
         tsai                 => canopystate_inst%tsai_patch     , & ! InOut:
         esai                 => canopystate_inst%esai_patch     , & ! InOut:

         begp                 => bounds%begp                     , &
         endp                 => bounds%endp                       &

         )

      ! ============================================================================
      ! Zero the whole variable so we dont have ghost values when patch number declines.
      ! ============================================================================
      
      trimming(:)             = 1.0_r8 !the default value of this is 1.0, making it 0.0 means that the output is confusing. 
      canopy_spread(:)        = 0.0_r8 
      PFTbiomass(:,:)         = 0.0_r8
      PFTleafbiomass(:,:)     = 0.0_r8 
      PFTstorebiomass(:,:)    = 0.0_r8
      PFTnindivs(:,:)         = 0.0_r8
      gpp(:)                  = 0.0_r8
      npp(:)                  = 0.0_r8  
      area_plant(:)           = 0.0_r8       
      area_trees(:)           = 0.0_r8        
      nesterov_fire_danger(:) = 0.0_r8
      spitfire_ROS(:)         = 0.0_r8
      effect_wspeed           = 0.0_r8
      TFC_ROS(:)              = 0.0_r8
      fire_intensity(:)       = 0.0_r8
      fire_area(:)            = 0.0_r8
      scorch_height(:)        = 0.0_r8
      fire_fuel_bulkd(:)      = 0.0_r8
      fire_fuel_eff_moist(:)  = 0.0_r8
      fire_fuel_sav(:)        = 0.0_r8
      fire_fuel_mef(:)        = 0.0_r8
      litter_in(:)            = 0.0_r8
      litter_out(:)           = 0.0_r8
      seed_bank(:)            = 0.0_r8          
      seeds_in(:)             = 0.0_r8
      seed_decay(:)           = 0.0_r8
      seed_germination(:)     = 0.0_r8
      ED_biomass(:)           = 0.0_r8
      ED_bdead(:)             = 0.0_r8
      ED_bleaf(:)             = 0.0_r8
      ED_bstore(:)            = 0.0_r8
      ED_balive(:)            = 0.0_r8
      phen_cd_status(:)       = 2

      do g = bounds%begg,bounds%endg

         if (firstsoilpatch(g) >= 0 .and. ed_allsites_inst(g)%istheresoil) then 

            ! ============================================================================
            ! Zero the bare ground tile BGC variables.
            ! ============================================================================

            trimming(firstsoilpatch(g))             = 1.0_r8 
            canopy_spread(firstsoilpatch(g))        = 0.0_r8 
            PFTbiomass(firstsoilpatch(g),:)         = 0.0_r8
            PFTleafbiomass(firstsoilpatch(g),:)     = 0.0_r8 
            PFTstorebiomass(firstsoilpatch(g),:)    = 0.0_r8
            PFTnindivs(firstsoilpatch(g),:)         = 0.0_r8
            gpp(firstsoilpatch(g))                  = 0.0_r8
            npp(firstsoilpatch(g))                  = 0.0_r8  
            area_plant(firstsoilpatch(g))           = 0.0_r8       
            area_trees(firstsoilpatch(g))           = 0.0_r8        
            nesterov_fire_danger(firstsoilpatch(g)) = 0.0_r8
            spitfire_ROS(firstsoilpatch(g))         = 0.0_r8
            TFC_ROS(firstsoilpatch(g))              = 0.0_r8
            effect_wspeed(firstsoilpatch(g))        = 0.0_r8
            fire_intensity(firstsoilpatch(g))       = 0.0_r8
            fire_area(firstsoilpatch(g))            = 0.0_r8
            scorch_height(firstsoilpatch(g))        = 0.0_r8
            fire_fuel_bulkd(firstsoilpatch(g))      = 0.0_r8
            fire_fuel_eff_moist(firstsoilpatch(g))  = 0.0_r8
            fire_fuel_sav(firstsoilpatch(g))        = 0.0_r8
            fire_fuel_mef(firstsoilpatch(g))        = 0.0_r8
            litter_in(firstsoilpatch(g))            = 0.0_r8
            litter_out(firstsoilpatch(g))           = 0.0_r8
            seed_bank(firstsoilpatch(g))            = 0.0_r8          
            seeds_in(firstsoilpatch(g))             = 0.0_r8
            seed_decay(firstsoilpatch(g))           = 0.0_r8
            seed_germination(firstsoilpatch(g))     = 0.0_r8
            ED_biomass(firstsoilpatch(g))           = 0.0_r8
            ED_balive(firstsoilpatch(g))            = 0.0_r8
            ED_bdead(firstsoilpatch(g))             = 0.0_r8
            ED_bstore(firstsoilpatch(g))            = 0.0_r8
            ED_bleaf(firstsoilpatch(g))             = 0.0_r8
            elai(firstsoilpatch(g))                 = 0.0_r8
            tlai(firstsoilpatch(g))                 = 0.0_r8
            tsai(firstsoilpatch(g))                 = 0.0_r8
            esai(firstsoilpatch(g))                 = 0.0_r8
            ED_bleaf(firstsoilpatch(g))             = 0.0_r8
            sum_fuel(firstsoilpatch(g))             = 0.0_r8
            !this should probably be site level. 
            phen_cd_status(firstsoilpatch(g))       = ed_allsites_inst(g)%status

            currentPatch => ed_allsites_inst(g)%oldest_patch
            do while(associated(currentPatch))

               if(currentPatch%patchno  <= numpft - numcft)then !don't expand into crop patches.   
                  p = currentPatch%clm_pno

                  currentCohort => currentPatch%shortest
                  do while(associated(currentCohort))
                     !accumulate into history variables. 
                     ft = currentCohort%pft
                     if(currentPatch%area>0._r8)then
                        n_density = currentCohort%n/currentPatch%area
                     else
                        n_density = 0.0_r8
                     endif
                     ED_bleaf(p)           = ED_bleaf(p)           + n_density * currentCohort%bl 
                     ED_bstore(p)          = ED_bstore(p)          + n_density * currentCohort%bstore 
                     ED_biomass(p)         = ED_biomass(p)         + n_density * currentCohort%b 
                     ED_bdead(p)           = ED_bdead(p)           + n_density * currentCohort%bdead 
                     ED_balive(p)          = ED_balive(p)          + n_density * currentCohort%balive
                     npp(p)                = npp(p)                + n_density * currentCohort%npp 
                     gpp(p)                = gpp(p)                + n_density * currentCohort%gpp   
                     PFTbiomass(p,ft)      = PFTbiomass(p,ft)      + n_density * currentCohort%b
                     PFTleafbiomass(p,ft)  = PFTleafbiomass(p,ft)  + n_density * currentCohort%bl
                     PFTstorebiomass(p,ft) = PFTstorebiomass(p,ft) + n_density * currentCohort%bstore
                     PFTnindivs(p,ft)      = PFTnindivs(p,ft)      + currentCohort%n 
                     currentCohort         => currentCohort%taller
                  enddo ! cohort loop

                  !Patch specific variables that are already calculated

                  !These things are all duplicated. Should they all be converted to LL or array structures RF? 
                  nesterov_fire_danger(p) = ed_allsites_inst(g)%acc_NI 
                  spitfire_ROS(p)         = currentPatch%ROS_front 
                  TFC_ROS(p)              = currentPatch%TFC_ROS
                  effect_wspeed(p)        = currentPatch%effect_wspeed
                  fire_intensity(p)       = currentPatch%FI
                  fire_area(p)            = currentPatch%frac_burnt
                  scorch_height(p)        = currentPatch%SH
                  fire_fuel_bulkd(p)      = currentPatch%fuel_bulkd
                  fire_fuel_eff_moist(p)  = currentPatch%fuel_eff_moist
                  fire_fuel_sav(p)        = currentPatch%fuel_sav
                  fire_fuel_mef(p)        = currentPatch%fuel_mef                          
                  sum_fuel(p)             = currentPatch%sum_fuel                         
                  litter_in(p)            = sum(currentPatch%CWD_AG_in) +sum(currentPatch%leaf_litter_in)
                  litter_out(p)           = sum(currentPatch%CWD_AG_out)+sum(currentPatch%leaf_litter_out)
                  seed_bank(p)            = sum(currentPatch%seed_bank)
                  seeds_in(p)             = sum(currentPatch%seeds_in)
                  seed_decay(p)           = sum(currentPatch%seed_decay)
                  seed_germination(p)     = sum(currentPatch%seed_germination)
                  canopy_spread(p)        = currentPatch%spread(1) 
                  area_plant(p)           = currentPatch%total_canopy_area /currentPatch%area
                  area_trees(p)           = currentPatch%total_tree_area   /currentPatch%area
                  phen_cd_status(p)       = ed_allsites_inst(g)%status
                  if(associated(currentPatch%tallest))then
                     trimming(p)          = currentPatch%tallest%canopy_trim                
                  else
                     trimming(p)          = 0.0_r8
                  endif

               else
                  write(iulog,*) 'ED: too many patches' 
               end if ! patchn<15

               currentPatch => currentPatch%younger
            end do !patch loop

         endif ! are there any soil patches?    
      enddo !gridcell loop

    end associate

  end subroutine ed_update_history_variables

  !------------------------------------------------------------------------
  subroutine ed_clm_leaf_area_profile( this, currentSite, waterstate_inst, canopystate_inst )
    !
    ! !DESCRIPTION:
    ! Load LAI in each layer into array to send to CLM
    !
    ! !USES: 
    use EDGrowthFunctionsMod , only : tree_lai, tree_sai, c_area 
    use EDtypesMod           , only : area, dinc_ed, hitemax, numpft_ed, n_hite_bins
    use EDEcophysConType     , only : EDecophyscon
    use CanopyStateType      , only : canopystate_type
    use WaterStateType       , only : waterstate_type
    use PatchType            , only : clmpatch => patch
    !
    ! !ARGUMENTS    
    class(ed_clm_type)                     :: this  
    type(ed_site_type)     , intent(inout) :: currentSite
    type(waterstate_type)  , intent(inout) :: waterstate_inst
    type(canopystate_type) , intent(inout) :: canopystate_inst
    !
    ! !LOCAL VARIABLES:
    type (ed_patch_type)  , pointer :: currentPatch
    type (ed_cohort_type) , pointer :: currentCohort
    real(r8) :: remainder                !Thickness of layer at bottom of canopy. 
    real(r8) :: fleaf                    ! fraction of cohort incepting area that is leaves.  
    integer  :: ft                       ! Plant functional type index. 
    integer  :: iv                       ! Vertical leaf layer index   
    integer  :: L                        ! Canopy layer index
    integer  :: P                        ! clm patch index  
    integer  :: C                        ! column index
    real(r8) :: tlai_temp                ! calculation of tlai to check this method
    real(r8) :: elai_temp                ! make a new elai based on the layer-by-layer snow coverage.
    real(r8) :: tsai_temp                !
    real(r8) :: esai_temp                !  
    real(r8) :: fraction_exposed         ! how much of this layer is not covered by snow?
    real(r8) :: layer_top_hite           ! notional top height of this canopy layer (m)
    real(r8) :: layer_bottom_hite        ! notional bottom height of this canopy layer (m)
    integer  :: smooth_leaf_distribution ! is the leaf distribution this option (1) or not (0)
    real(r8) :: frac_canopy(N_HITE_BINS) ! amount of canopy in each height class
    real(r8) :: minh(N_HITE_BINS)        ! minimum height in height class (m)
    real(r8) :: maxh(N_HITE_BINS)        ! maximum height in height class (m)
    real(r8) :: dh                       ! vertical detph of height class (m)
    real(r8) :: min_chite                ! bottom of cohort canopy  (m)
    real(r8) :: max_chite                ! top of cohort canopy      (m)
    real(r8) :: lai                      ! summed lai for checking m2 m-2
    integer  :: NC                       ! number of cohorts, for bug fixing. 
    !----------------------------------------------------------------------

    smooth_leaf_distribution = 0

    associate(                                                             & 
         snow_depth         => waterstate_inst%snow_depth_col            , & !Input:
         frac_sno_eff       => waterstate_inst%frac_sno_eff_col          , & !Input: 
         snowdp             => waterstate_inst%snowdp_col                , & !Output:
         
         frac_veg_nosno_alb => canopystate_inst%frac_veg_nosno_alb_patch , & !Output:
         tlai               => canopystate_inst%tlai_patch               , & !Output
         elai               => canopystate_inst%elai_patch               , & !Output
         tsai               => canopystate_inst%tsai_patch               , & !Output
         esai               => canopystate_inst%esai_patch                 & !Output
         )

      ! Here we are trying to generate a profile of leaf area, indexed by 'z' and by pft
      ! We assume that each point in the canopy recieved the light attenuated by the average
      ! leaf area index above it, irrespective of PFT identity... 
      ! Each leaf is defined by how deep in the canopy it is, in terms of LAI units.  (FIX(RF,032414), GB)

      if (currentSite%istheresoil)then
         
         currentPatch => currentSite%oldest_patch   ! ed patch
         p = currentPatch%clm_pno                   ! index for clm patch

         do while(associated(currentPatch))

            !Calculate tree and canopy areas. 
            currentPatch%canopy_area = 0._r8
            currentPatch%canopy_layer_lai(:) = 0._r8
            NC = 0
            currentCohort => currentPatch%shortest
            do while(associated(currentCohort))       
               currentCohort%c_area = c_area(currentCohort)
               currentPatch%canopy_area = currentPatch%canopy_area + currentCohort%c_area
               NC = NC+1
               currentCohort => currentCohort%taller    
            enddo
            ! if plants take up all the tile, then so does the canopy.  
            currentPatch%canopy_area = min(currentPatch%canopy_area,currentPatch%area) 

            !calculate tree lai and sai.
            currentPatch%ncan(:,:) = 0 
            currentPatch%nrad(:,:) = 0 
            currentPatch%lai = 0._r8
            currentCohort => currentPatch%shortest
            do while(associated(currentCohort)) 
               currentCohort%treelai = tree_lai(currentCohort)    
               currentCohort%treesai = tree_sai(currentCohort)
               currentCohort%lai =  currentCohort%treelai *currentCohort%c_area/currentPatch%canopy_area 
               currentCohort%sai =  currentCohort%treesai *currentCohort%c_area/currentPatch%canopy_area  
               !Calculate the LAI plus SAI in each canopy storey. 
               currentCohort%NV =  CEILING((currentCohort%treelai+currentCohort%treesai)/dinc_ed)  

               currentPatch%ncan(currentCohort%canopy_layer,currentCohort%pft) = &
                    max(currentPatch%ncan(currentCohort%canopy_layer,currentCohort%pft),currentCohort%NV)
               currentPatch%lai = currentPatch%lai +currentCohort%lai

               do L = 1,nclmax-1
                  if(currentCohort%canopy_layer == L)then
                     currentPatch%canopy_layer_lai(L) = currentPatch%canopy_layer_lai(L) + currentCohort%lai + &
                          currentCohort%sai
                  endif
               enddo

               currentCohort => currentCohort%taller 

            enddo !currentCohort
            currentPatch%nrad = currentPatch%ncan

            if(smooth_leaf_distribution == 1)then
               ! we are going to ignore the concept of canopy layers, and put all of the leaf area into height banded bins. 
               ! using the same domains as we had before, except that CL always = 1
               currentPatch%tlai_profile = 0._r8
               currentPatch%tsai_profile = 0._r8  
               currentPatch%elai_profile = 0._r8
               currentPatch%esai_profile = 0._r8  

               ! this is a crude way of dividing up the bins. Should it be a function of actual maximum height? 
               dh = 1.0_r8*(HITEMAX/N_HITE_BINS) 
               do iv = 1,N_HITE_BINS  
                  if (iv == 1) then
                     minh(iv) = 0.0_r8
                     maxh(iv) = dh
                  else 
                     minh(iv) = (iv-1)*dh
                     maxh(iv) = (iv)*dh
                  endif
               enddo
               c = clmpatch%column(currentPatch%clm_pno)
               currentCohort => currentPatch%shortest
               do while(associated(currentCohort))  
                  ft = currentCohort%pft
                  min_chite = currentCohort%hite - currentCohort%hite * EDecophyscon%crown(ft)
                  max_chite = currentCohort%hite  
                  do iv = 1,N_HITE_BINS  
                     frac_canopy(iv) = 0.0_r8
                     ! this layer is in the middle of the canopy
                     if(max_chite > maxh(iv).and.min_chite < minh(iv))then 
                        frac_canopy(iv)= min(1.0_r8,dh / (currentCohort%hite*EDecophyscon%crown(ft)))
                        ! this is the layer with the bottom of the canopy in it. 
                     elseif(min_chite < maxh(iv).and.min_chite > minh(iv).and.max_chite > maxh(iv))then 
                        frac_canopy(iv) = (maxh(iv) -min_chite ) / (currentCohort%hite*EDecophyscon%crown(ft))
                        ! this is the layer with the top of the canopy in it. 
                     elseif(max_chite > minh(iv).and.max_chite < maxh(iv).and.min_chite < minh(iv))then 
                        frac_canopy(iv) = (max_chite - minh(iv)) / (currentCohort%hite*EDecophyscon%crown(ft))
                     elseif(max_chite < maxh(iv).and.min_chite > minh(iv))then !the whole cohort is within this layer. 
                        frac_canopy(iv) = 1.0_r8
                     endif

                     ! no m2 of leaf per m2 of ground in each height class
                     currentPatch%tlai_profile(1,ft,iv) = currentPatch%tlai_profile(1,ft,iv) + frac_canopy(iv) * &
                          currentCohort%lai
                     currentPatch%tsai_profile(1,ft,iv) = currentPatch%tsai_profile(1,ft,iv) + frac_canopy(iv) * &
                          currentCohort%sai

                     !snow burial
                     fraction_exposed = 1.0_r8 !default. 

                     snowdp(c) = snow_depth(c) * frac_sno_eff(c)
                     if(snowdp(c) > maxh(iv))then
                        fraction_exposed = 0._r8
                     endif
                     if(snowdp(c) < minh(iv))then
                        fraction_exposed = 1._r8
                     endif
                     if(snowdp(c) >= minh(iv).and.snowdp(c) <= maxh(iv))then !only partly hidden... 
                        fraction_exposed =  max(0._r8,(min(1.0_r8,(snowdp(c)-minh(iv))/dh)))
                     endif

                     ! no m2 of leaf per m2 of ground in each height class
                     ! FIX(SPM,032414) these should be uncommented this and double check
                     !currentPatch%elai_profile(1,ft,iv) = currentPatch%tlai_profile(1,ft,iv) * fraction_exposed
                     !currentPatch%esai_profile(1,ft,iv) = currentPatch%tsai_profile(1,ft,iv) * fraction_exposed

                  enddo ! (iv) hite bins

                  currentCohort => currentCohort%taller

               enddo !currentCohort 

               !check
               currentPatch%lai = 0._r8
               currentCohort => currentPatch%shortest
               do while(associated(currentCohort)) 
                  currentPatch%lai = currentPatch%lai +currentCohort%lai
                  currentCohort => currentCohort%taller   
               enddo !currentCohort
               lai = 0.0_r8
               do ft = 1,numpft_ed
                  lai = lai+ sum(currentPatch%tlai_profile(1,ft,:))
               enddo

               if(lai > currentPatch%lai)then
                  write(iulog,*) 'problem with lai assignments'
               endif


            else ! smooth leaf distribution  
               !Go through all cohorts and add their leaf area and canopy area to the accumulators. 
               currentPatch%tlai_profile = 0._r8
               currentPatch%tsai_profile = 0._r8  
               currentPatch%elai_profile = 0._r8
               currentPatch%esai_profile = 0._r8  
               currentPatch%canopy_area_profile(:,:,:) = 0._r8       
               currentPatch%ncan(:,:) = 0 
               currentPatch%nrad(:,:) = 0 
               currentCohort => currentPatch%shortest

               do while(associated(currentCohort))   
                  L = currentCohort%canopy_layer
                  ft = currentCohort%pft 
                  !Calculate the number of layers of thickness dlai, including the last one. 
                  currentCohort%NV =  CEILING((currentCohort%treelai+currentCohort%treesai)/dinc_ed)
                  !how much of each tree is stem area index? Assuming that there is 
                  if(currentCohort%treelai+currentCohort%treesai > 0._r8)then    
                     fleaf = currentCohort%lai / (currentCohort%lai + currentCohort%sai) 
                  else
                     fleaf = 0._r8
                     write(iulog,*) 'no stem or leaf area' ,currentCohort%pft,currentCohort%bl, &
                          currentCohort%balive,currentCohort%treelai,currentCohort%treesai,currentCohort%dbh, &
                          currentCohort%n,currentCohort%status_coh
                  endif
                  currentPatch%ncan(L,ft) = max(currentPatch%ncan(L,ft),currentCohort%NV)  
                  currentPatch%nrad(L,ft) = currentPatch%ncan(L,ft)  !fudge - this needs to be altered for snow burial
                  if(currentCohort%NV > currentPatch%nrad(L,ft))then
                     write(iulog,*) 'CF: issue with NV',currentCohort%NV,currentCohort%pft,currentCohort%canopy_layer
                  endif
                  c = clmpatch%column(currentPatch%clm_pno)

                  !Whole layers.  Make a weighted average of the leaf area in each layer before dividing it by the total area. 
                  !fill up layer for whole layers.  FIX(RF,032414)- for debugging jan 2012
                  do iv = 1,currentCohort%NV-1 

                     currentPatch%tlai_profile(L,ft,iv) = currentPatch%tlai_profile(L,ft,iv)+ dinc_ed * fleaf * &
                          currentCohort%c_area/currentPatch%total_canopy_area
                     currentPatch%tsai_profile(L,ft,iv) = currentPatch%tsai_profile(L,ft,iv)+ dinc_ed * (1._r8 - fleaf) * &
                          currentCohort%c_area/currentPatch%total_canopy_area
                     currentPatch%canopy_area_profile(L,ft,iv) =  min(1.0_r8,currentPatch%canopy_area_profile(L,ft,iv) + &
                          currentCohort%c_area/currentPatch%total_canopy_area)

                     ! what is the height of this layer? (for snow burial purposes...)  
                     ! pftcon%vertical_canopy_frac(ft))! fudge - this should be pft specific but i cant get it to compile. 
                     layer_top_hite = currentCohort%hite-((iv/currentCohort%NV) * currentCohort%hite * &
                          EDecophyscon%crown(currentCohort%pft) )
                     layer_bottom_hite = currentCohort%hite-(((iv+1)/currentCohort%NV) * currentCohort%hite * &
                          EDecophyscon%crown(currentCohort%pft)) ! pftcon%vertical_canopy_frac(ft))
                     fraction_exposed = 1.0_r8 !default. 
                     snowdp(c) = snow_depth(c) * frac_sno_eff(c)
                     if(snowdp(c) > layer_top_hite)then
                        fraction_exposed = 0._r8
                     endif
                     if(snowdp(c) <= layer_bottom_hite)then
                        fraction_exposed = 1._r8
                     endif
                     if(snowdp(c) > layer_bottom_hite.and.snowdp(c) <= layer_top_hite)then !only partly hidden... 
                        fraction_exposed =  max(0._r8,(min(1.0_r8,(snowdp(c)-layer_bottom_hite)/ &
                             (layer_top_hite-layer_bottom_hite ))))
                     endif

                     currentPatch%elai_profile(L,ft,iv) =  currentPatch%tlai_profile(L,ft,iv) *fraction_exposed
                     !here we are assuming that the stem and leaf area indices have the same profile... 
                     currentPatch%esai_profile(L,ft,iv) =  currentPatch%tsai_profile(L,ft,iv) *fraction_exposed 
                  end do

                  !Bottom layer
                  iv = currentCohort%NV
                  ! pftcon%vertical_canopy_frac(ft))! fudge - this should be pft specific but i cant get it to compile.
                  layer_top_hite = currentCohort%hite-((iv/currentCohort%NV) * currentCohort%hite * &
                       EDecophyscon%crown(currentCohort%pft) )
                  ! pftcon%vertical_canopy_frac(ft))
                  layer_bottom_hite = currentCohort%hite-(((iv+1)/currentCohort%NV) * currentCohort%hite * &
                       EDecophyscon%crown(currentCohort%pft))
                  fraction_exposed = 1.0_r8 !default. 

                  fraction_exposed = 1.0_r8 !default. 
                  if(snowdp(c) > layer_top_hite)then
                     fraction_exposed = 0._r8
                  endif
                  if(snowdp(c) <= layer_bottom_hite)then
                     fraction_exposed = 1._r8
                  endif
                  if(snowdp(c) > layer_bottom_hite.and.snowdp(c) <= layer_top_hite)then !only partly hidden... 
                     fraction_exposed =  max(0._r8,(min(1.0_r8,(snowdp(c)-layer_bottom_hite) / &
                          (layer_top_hite-layer_bottom_hite ))))
                  endif

                  remainder = (currentCohort%treelai + currentCohort%treesai) - (dinc_ed*(currentCohort%NV-1))
                  if(remainder > 1.0_r8)then
                     write(iulog,*)'issue with remainder',currentCohort%treelai,currentCohort%treesai,dinc_ed, & 
                          currentCohort%NV
                  endif
                  !assumes that fleaf is unchanging FIX(RF,032414)

                  currentPatch%tlai_profile(L,ft,iv) =  currentPatch%tlai_profile(L,ft,iv)+ remainder * fleaf * &
                       currentCohort%c_area/currentPatch%total_canopy_area

                  !assumes that fleaf is unchanging FIX(RF,032414)

                  currentPatch%tsai_profile(L,ft,iv) =  currentPatch%tsai_profile(L,ft,iv)+  remainder * &
                       (1.0_r8-fleaf) * currentCohort%c_area/currentPatch%total_canopy_area
                  currentPatch%elai_profile(L,ft,iv) =  currentPatch%tlai_profile(L,ft,iv) *fraction_exposed
                  currentPatch%esai_profile(L,ft,iv) =  currentPatch%tsai_profile(L,ft,iv) *fraction_exposed
                  currentPatch%canopy_area_profile(L,ft,iv) = min(1.0_r8,currentPatch%canopy_area_profile(L,ft,iv) + &
                       currentCohort%c_area/currentPatch%total_canopy_area)

                  if(currentCohort%dbh <= 0._r8.or.currentCohort%n == 0._r8)then
                     write(iulog,*) 'ED: dbh or n is zero in clmedlink', currentCohort%dbh,currentCohort%n
                  endif
                  if(currentCohort%pft == 0.or.currentCohort%canopy_trim <= 0._r8)then
                     write(iulog,*) 'ED: PFT or trim is zero in clmedlink',currentCohort%pft,currentCohort%canopy_trim
                  endif
                  if(currentCohort%balive <= 0._r8.or.currentCohort%bl < 0._r8)then
                     write(iulog,*) 'ED: balive is zero in clmedlink',currentCohort%balive,currentCohort%bl
                  endif

                  currentCohort => currentCohort%taller

               enddo !cohort

               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed
                     do iv = 1,currentPatch%nrad(L,ft)
                        !account for total canopy area
                        currentPatch%tlai_profile(L,ft,iv) = currentPatch%tlai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                        currentPatch%tsai_profile(L,ft,iv) = currentPatch%tsai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                        currentPatch%elai_profile(L,ft,iv) = currentPatch%elai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                        currentPatch%esai_profile(L,ft,iv) = currentPatch%esai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                     enddo

                     currentPatch%tlai_profile(L,ft,currentPatch%nrad(L,ft)+1: nlevcan_ed) = 0._r8
                     currentPatch%tsai_profile(L,ft,currentPatch%nrad(L,ft)+1: nlevcan_ed) = 0._r8
                     currentPatch%elai_profile(L,ft,currentPatch%nrad(L,ft)+1: nlevcan_ed) = 0._r8 
                     currentPatch%esai_profile(L,ft,currentPatch%nrad(L,ft)+1: nlevcan_ed) = 0._r8

                  enddo
               enddo

               !what is the resultant leaf area? 

               tlai_temp = 0._r8
               elai_temp = 0._r8
               tsai_temp = 0._r8
               esai_temp = 0._r8

               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed

                     tlai_temp = tlai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
                          currentPatch%tlai_profile(L,ft,1:currentPatch%nrad(L,ft)))
                     elai_temp = elai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
                          currentPatch%elai_profile(L,ft,1:currentPatch%nrad(L,ft)))
                     tsai_temp = tsai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
                          currentPatch%tsai_profile(L,ft,1:currentPatch%nrad(L,ft)))
                     esai_temp = esai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
                          currentPatch%esai_profile(L,ft,1:currentPatch%nrad(L,ft)))
                  enddo
               enddo

               p = currentPatch%clm_pno
               if(abs(tlai(p)-tlai_temp) > 0.0001_r8) then

                  write(iulog,*) 'error with tlai calcs',&
                       NC,currentSite%clmgcell, abs(tlai(p)-tlai_temp), tlai_temp,tlai(p)

                  do L = 1,currentPatch%NCL_p
                     write(iulog,*) 'carea profile',L,currentPatch%canopy_area_profile(L,1,1:currentPatch%nrad(L,1))
                     write(iulog,*) 'tlai profile',L,currentPatch%tlai_profile(L,1,1:currentPatch%nrad(L,1))
                  end do

               endif

               elai(p) = max(0.1_r8,elai_temp)
               tlai(p) = max(0.1_r8,tlai_temp)
               esai(p) = max(0.1_r8,esai_temp)
               tsai(p) = max(0.1_r8,tsai_temp)

               ! write(iulog,*) 'elai',elai(p),tlai(p),tlai_temp,elai_temp
               ! write(iulog,*) 'esai',esai(p),tsai(p)
               !            write(iulog,*) 'TLAI_prof',currentPatch%tlai_profile(1,:,:)

               ! Fraction of vegetation free of snow. What does this do? Is it right? 
               if ((elai(p) + esai(p)) > 0._r8) then
                  frac_veg_nosno_alb(p) = 1_r8
               else
                  frac_veg_nosno_alb(p) = 0_r8
               end if
               ! write(iulog,*) 'frac nosno',frac_veg_nosno_alb(p)

               currentPatch%nrad = currentPatch%ncan
               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed
                     if(currentPatch%nrad(L,ft) > 30)then
                        write(iulog,*) 'ED: issue w/ nrad'
                     endif
                     currentPatch%present(L,ft) = 0
                     do  iv = 1, currentPatch%nrad(L,ft);
                        if(currentPatch%canopy_area_profile(L,ft,iv) > 0._r8)then
                           currentPatch%present(L,ft) = 1     
                        endif
                     end do !iv
                  enddo !ft

                  if ( L == 1 .and. abs(sum(currentPatch%canopy_area_profile(1,1:numpft_ed,1))) < 0.99999  &
                       .and. currentPatch%NCL_p > 1 ) then
                     write(iulog,*) 'canopy area too small',sum(currentPatch%canopy_area_profile(1,1:numpft_ed,1))
                     write(iulog,*) 'cohort areas', currentPatch%canopy_area_profile(1,1:numpft_ed,:)
                  endif

                  if (L == 1 .and. currentPatch%NCL_p > 1 .and.  &
                       abs(sum(currentPatch%canopy_area_profile(1,1:numpft_ed,1))) < 0.99999) then
                     write(iulog,*) 'not enough area in the top canopy', &
                          sum(currentPatch%canopy_area_profile(L,1:numpft_ed,1)), &
                          currentPatch%canopy_area_profile(L,1:numpft_ed,1)
                  endif

                  if(abs(sum(currentPatch%canopy_area_profile(L,1:numpft_ed,1))) > 1.00001)then
                     write(iulog,*) 'canopy-area-profile wrong',sum(currentPatch%canopy_area_profile(L,1:numpft_ed,1)), &
                          currentSite%clmgcell,currentPatch%patchno,L
                     write(iulog,*) 'areas',currentPatch%canopy_area_profile(L,1:2,1),currentPatch%patchno

                     currentCohort => currentPatch%shortest

                     do while(associated(currentCohort))

                        if(currentCohort%canopy_layer==1)then
                           write(iulog,*) 'cohorts',currentCohort%dbh,currentCohort%c_area, &
                                currentPatch%total_canopy_area,currentPatch%area,currentPatch%canopy_area
                           write(iulog,*) 'fracarea',currentCohort%pft, currentCohort%c_area/currentPatch%total_canopy_area
                        endif

                        currentCohort => currentCohort%taller  

                     enddo !currentCohort
                  endif
               enddo ! loop over L

               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed
                     if(currentPatch%present(L,FT) > 1)then
                        write(iulog,*) 'present issue',currentPatch%clm_pno,L,ft,currentPatch%present(L,FT)
                        currentPatch%present(L,ft) = 1
                     endif
                  enddo
               enddo

            endif !leaf distribution

            currentPatch => currentPatch%younger 

         enddo !patch       

      endif !is there soil? 

    end associate

  end subroutine ed_clm_leaf_area_profile

end module EDCLMLinkMod
