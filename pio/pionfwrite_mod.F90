!===================================================
! DO NOT EDIT THIS FILE, it was generated using ./genf90.pl 
! Any changes you make to this file may be lost
!===================================================
module pionfwrite_mod
  implicit none
  private
!>
!! @private
!<
  public :: write_nf
# 8 "pionfwrite_mod.F90.in"
  interface write_nf
     ! TYPE real,int,double
     module procedure write_nfdarray_real
     ! TYPE real,int,double
     module procedure write_nfdarray_int
     ! TYPE real,int,double
     module procedure write_nfdarray_double
  end interface

  character(len=*), parameter :: modName='pionfwrite_mod'
# 14 "pionfwrite_mod.F90.in"
contains
  ! note: IOBUF may actually point to the original data
  ! array, and cannot be modified (which is why it is intent(in))

  ! TYPE real,int,double
!>
!! @private
!<
# 22 "pionfwrite_mod.F90.in"
  integer function write_nfdarray_real (File,IOBUF,varDesc,iodesc,start,count) result(ierr)
    use nf_mod
    use pio_types
    use pio_kinds
    use pio_utils, only : check_netcdf, bad_iotype
    use alloc_mod, only: alloc_check
    use pio_support, only : Debug, DebugIO, piodie, checkmpireturn 

#ifdef _NETCDF
    use netcdf, only : nf90_put_var  !_EXTERNAL
#endif
#ifdef TIMING
    use perf_mod, only : t_startf, t_stopf  !_EXTERNAL
#endif
    include 'mpif.h'   !_EXTERNAL
#ifdef _PNETCDF
#   include <pnetcdf.inc>   /* _EXTERNAL */
#endif

    type (File_desc_t), intent(inout) :: File
    real(r4) , intent(in), target      :: IOBUF(:)
    type (var_desc_t), intent(in)     :: varDesc
    type (IO_desc_t), intent(in)      :: IODesc


    integer(pio_offset), intent(in) :: start(:), count(:)

    character(len=*), parameter :: subName=modName//'::write_nfdarray_real'

    integer(i4) :: iotype, mpierr
    integer :: status(MPI_STATUS_SIZE)
    integer iobuf_size, max_iobuf_size
    real(r4) , pointer :: temp_iobuf(:)
    integer, pointer :: temp_start(:), temp_count(:)
    integer start_size, count_size
    integer i
    integer :: fh, vid, oldval

#ifdef TIMING
    call t_startf("pio_write_nfdarray_real")
#endif
    iotype = File%iotype
    ierr=PIO_noerr

    if(file%iosystem%ioproc) then
       select case (iotype) 

#ifdef _PNETCDF
       case(iotype_pnetcdf)
#ifdef DEBUG
          if(size(iobuf)<=0) then
             call piodie(subname,__LINE__,'empty iobuf')
          end if
#endif
          ierr=nfmpi_put_vara_all( File%fh,varDesc%varid,start, &
               count,IOBUF, &
               int(iodesc%Write%n_ElemTYPE,kind=pio_offset), &
               iodesc%Write%ElemTYPE)

          if(Debug.or.ierr/=PIO_noerr) print *,subname,__LINE__, &
               '  IAM: ',File%iosystem%io_rank,' start: ',start,' count: ',count,&
               ' size :',iodesc%Write%n_ElemTYPE, ' error: ',ierr, &
               iodesc%Write%ElemTYPE
          if(Debug.or.ierr/=PIO_noerr) print *,subname,__LINE__, &
               '  IAM: ',File%iosystem%io_rank,'minval: ',minval(IOBUF),'maxval: ',maxval(IOBUF)
#endif

#ifdef _NETCDF
       case(iotype_netcdf)
          ! allocate space on root for copy of iobuf etc.
          iobuf_size=size(IOBUF)
          if(File%iosystem%num_iotasks>1) then
             call MPI_ALLREDUCE(iobuf_size,max_iobuf_size, &
                  1,MPI_INTEGER,MPI_MAX,File%iosystem%IO_comm,mpierr)
             call CheckMPIReturn(subName, mpierr)

             if (File%iosystem%io_rank==0) then
                   call alloc_check(temp_iobuf,max_iobuf_size)
             else
                if(max_iobuf_size>iobuf_size) then
                   call alloc_check(temp_iobuf,max_iobuf_size)
                   temp_iobuf(1:iobuf_size) = iobuf
                else
                   temp_iobuf => iobuf
                end if
             end if
          endif

          start_size=size(start)
          call alloc_check(temp_start,start_size)
          temp_start=start

          count_size=size(count)
          call alloc_check(temp_count,count_size)
          temp_count=count

          ! Every i/o proc send data to root

          if (File%iosystem%io_rank>0) then
             ! Wait for io_rank 0 to indicate that its ready before sending
             ! this handshaking is nessasary for jaguar
             call MPI_RECV( i, 1, MPI_INTEGER, 0, file%iosystem%io_rank, &
                  file%iosystem%io_comm, status, mpierr)
             call CheckMPIReturn(subName, mpierr)

             if (Debug) print *, subName,': File%iosystem%comp_rank:',File%iosystem%comp_rank, &
                  ': relaying IOBUF for write size=',size(IOBUF), temp_start,temp_count, start_size, count_size, i


             call MPI_SEND( temp_IOBUF,max_iobuf_size, &
                  MPI_REAL4, &
                  0,File%iosystem%io_rank,File%iosystem%IO_comm,mpierr )
             call CheckMPIReturn(subName, mpierr)

             call MPI_SEND( temp_start,size(start),MPI_INTEGER, &
                  0,File%iosystem%num_iotasks+File%iosystem%io_rank,File%iosystem%IO_comm,mpierr )
             call CheckMPIReturn(subName, mpierr)

             call MPI_SEND( temp_count,size(count),MPI_INTEGER, &
                  0,2*File%iosystem%num_iotasks+File%iosystem%io_rank,File%iosystem%IO_comm,mpierr )
             call CheckMPIReturn(subName, mpierr)

          endif

          if (File%iosystem%io_rank==0) then 
             if (Debug) print *, subName,': 0: writing netcdf for self ', &
                  'fh=',File%fh,' varid=',varDesc%varid, temp_start, temp_count, size(iobuf)
             fh = file%fh
             vid = vardesc%varid
             ierr=nf90_put_var( fh, vid,IOBUF,temp_start,temp_count)
             if(Debug) print *, subname,__LINE__,fh,vid, ierr
             if(ierr==pio_noerr) then
                if (Debug) print *, subName,': 0: done writing for self',start_size

                do i=1,File%iosystem%num_iotasks-1

                   ! Send a signal indicating ready to recv
                   call MPI_SEND( i, 1, MPI_INTEGER, i, i, &
                        file%iosystem%io_comm, mpierr)
                   call CheckMPIReturn(subName,mpierr)
                   ! receive IOBUF, temp_start, temp_count from io_rank i
                   if(Debug) print *,subName, ' 1 receiving from ',i, max_iobuf_size

                   call MPI_RECV( temp_iobuf, max_iobuf_size,  &
                        MPI_REAL4, &
                        i,i,File%iosystem%IO_comm,status,mpierr)
                   call CheckMPIReturn(subName,mpierr)
                   if(Debug) print *,subName, ' 2 receiving from ',i, start_size

                   call MPI_RECV( temp_start, &
                        start_size, MPI_INTEGER,  &
                        i,File%iosystem%num_iotasks+i,File%iosystem%IO_comm,status,mpierr)
                   call CheckMPIReturn(subName,mpierr)
                   if(Debug) print *,subName, ' 3 receiving from ',i, count_size

                   call MPI_RECV( temp_count, &
                        count_size, MPI_INTEGER,  &
                        i,2*File%iosystem%num_iotasks+i,File%iosystem%IO_comm,status,mpierr)
                   call CheckMPIReturn(subName,mpierr)

                   if (Debug) print *, subName,': 0: writing netcdf for ',i, temp_start,temp_count
	           if(sum(temp_count)>0) then

#ifdef TIMING
                      call t_startf("nc_put_var2")
#endif
                      ierr=nf90_put_var( fh,vid,	&
                           temp_iobuf,temp_start,temp_count)
                      if(Debug) print *, subname,__LINE__,i,fh,vid, ierr
#ifdef TIMING
                      call t_stopf("nc_put_var2")
#endif
                      if (Debug) print *, subName,': 0: done writing for ',i
                   else
                      ierr = PIO_NOERR
                   end if


                end do ! i=1,File%iosystem%num_iotasks-1
             end if ! ierr==pio_noerr
          endif  ! File%iosystem%io_rank==0

          deallocate(temp_start)
          deallocate(temp_count)

          if (File%iosystem%num_iotasks>1) then
             if(File%iosystem%io_rank==0 .or. iobuf_size<max_iobuf_size) then
                deallocate(temp_iobuf)
             end if
          endif

#endif

       case default
          call bad_iotype(iotype,subname,__LINE__)

       end select
    endif  ! if (File%iosystem%IOproc)

    call check_netcdf(File, ierr,subname,__LINE__)
#ifdef TIMING
    call t_stopf("pio_write_nfdarray_real")
#endif
  call mpi_barrier(file%iosystem%comp_comm, mpierr)
  call CheckMPIReturn(subName,mpierr)

  end function WRITE_NFDARRAY_real
  ! note: IOBUF may actually point to the original data
  ! array, and cannot be modified (which is why it is intent(in))

  ! TYPE real,int,double
!>
!! @private
!<
# 22 "pionfwrite_mod.F90.in"
  integer function write_nfdarray_int (File,IOBUF,varDesc,iodesc,start,count) result(ierr)
    use nf_mod
    use pio_types
    use pio_kinds
    use pio_utils, only : check_netcdf, bad_iotype
    use alloc_mod, only: alloc_check
    use pio_support, only : Debug, DebugIO, piodie, checkmpireturn 

#ifdef _NETCDF
    use netcdf, only : nf90_put_var  !_EXTERNAL
#endif
#ifdef TIMING
    use perf_mod, only : t_startf, t_stopf  !_EXTERNAL
#endif
    include 'mpif.h'   !_EXTERNAL
#ifdef _PNETCDF
#   include <pnetcdf.inc>   /* _EXTERNAL */
#endif

    type (File_desc_t), intent(inout) :: File
    integer(i4) , intent(in), target      :: IOBUF(:)
    type (var_desc_t), intent(in)     :: varDesc
    type (IO_desc_t), intent(in)      :: IODesc


    integer(pio_offset), intent(in) :: start(:), count(:)

    character(len=*), parameter :: subName=modName//'::write_nfdarray_int'

    integer(i4) :: iotype, mpierr
    integer :: status(MPI_STATUS_SIZE)
    integer iobuf_size, max_iobuf_size
    integer(i4) , pointer :: temp_iobuf(:)
    integer, pointer :: temp_start(:), temp_count(:)
    integer start_size, count_size
    integer i
    integer :: fh, vid, oldval

#ifdef TIMING
    call t_startf("pio_write_nfdarray_int")
#endif
    iotype = File%iotype
    ierr=PIO_noerr

    if(file%iosystem%ioproc) then
       select case (iotype) 

#ifdef _PNETCDF
       case(iotype_pnetcdf)
#ifdef DEBUG
          if(size(iobuf)<=0) then
             call piodie(subname,__LINE__,'empty iobuf')
          end if
#endif
          ierr=nfmpi_put_vara_all( File%fh,varDesc%varid,start, &
               count,IOBUF, &
               int(iodesc%Write%n_ElemTYPE,kind=pio_offset), &
               iodesc%Write%ElemTYPE)

          if(Debug.or.ierr/=PIO_noerr) print *,subname,__LINE__, &
               '  IAM: ',File%iosystem%io_rank,' start: ',start,' count: ',count,&
               ' size :',iodesc%Write%n_ElemTYPE, ' error: ',ierr, &
               iodesc%Write%ElemTYPE
          if(Debug.or.ierr/=PIO_noerr) print *,subname,__LINE__, &
               '  IAM: ',File%iosystem%io_rank,'minval: ',minval(IOBUF),'maxval: ',maxval(IOBUF)
#endif

#ifdef _NETCDF
       case(iotype_netcdf)
          ! allocate space on root for copy of iobuf etc.
          iobuf_size=size(IOBUF)
          if(File%iosystem%num_iotasks>1) then
             call MPI_ALLREDUCE(iobuf_size,max_iobuf_size, &
                  1,MPI_INTEGER,MPI_MAX,File%iosystem%IO_comm,mpierr)
             call CheckMPIReturn(subName, mpierr)

             if (File%iosystem%io_rank==0) then
                   call alloc_check(temp_iobuf,max_iobuf_size)
             else
                if(max_iobuf_size>iobuf_size) then
                   call alloc_check(temp_iobuf,max_iobuf_size)
                   temp_iobuf(1:iobuf_size) = iobuf
                else
                   temp_iobuf => iobuf
                end if
             end if
          endif

          start_size=size(start)
          call alloc_check(temp_start,start_size)
          temp_start=start

          count_size=size(count)
          call alloc_check(temp_count,count_size)
          temp_count=count

          ! Every i/o proc send data to root

          if (File%iosystem%io_rank>0) then
             ! Wait for io_rank 0 to indicate that its ready before sending
             ! this handshaking is nessasary for jaguar
             call MPI_RECV( i, 1, MPI_INTEGER, 0, file%iosystem%io_rank, &
                  file%iosystem%io_comm, status, mpierr)
             call CheckMPIReturn(subName, mpierr)

             if (Debug) print *, subName,': File%iosystem%comp_rank:',File%iosystem%comp_rank, &
                  ': relaying IOBUF for write size=',size(IOBUF), temp_start,temp_count, start_size, count_size, i


             call MPI_SEND( temp_IOBUF,max_iobuf_size, &
                  MPI_INTEGER, &
                  0,File%iosystem%io_rank,File%iosystem%IO_comm,mpierr )
             call CheckMPIReturn(subName, mpierr)

             call MPI_SEND( temp_start,size(start),MPI_INTEGER, &
                  0,File%iosystem%num_iotasks+File%iosystem%io_rank,File%iosystem%IO_comm,mpierr )
             call CheckMPIReturn(subName, mpierr)

             call MPI_SEND( temp_count,size(count),MPI_INTEGER, &
                  0,2*File%iosystem%num_iotasks+File%iosystem%io_rank,File%iosystem%IO_comm,mpierr )
             call CheckMPIReturn(subName, mpierr)

          endif

          if (File%iosystem%io_rank==0) then 
             if (Debug) print *, subName,': 0: writing netcdf for self ', &
                  'fh=',File%fh,' varid=',varDesc%varid, temp_start, temp_count, size(iobuf)
             fh = file%fh
             vid = vardesc%varid
             ierr=nf90_put_var( fh, vid,IOBUF,temp_start,temp_count)
             if(Debug) print *, subname,__LINE__,fh,vid, ierr
             if(ierr==pio_noerr) then
                if (Debug) print *, subName,': 0: done writing for self',start_size

                do i=1,File%iosystem%num_iotasks-1

                   ! Send a signal indicating ready to recv
                   call MPI_SEND( i, 1, MPI_INTEGER, i, i, &
                        file%iosystem%io_comm, mpierr)
                   call CheckMPIReturn(subName,mpierr)
                   ! receive IOBUF, temp_start, temp_count from io_rank i
                   if(Debug) print *,subName, ' 1 receiving from ',i, max_iobuf_size

                   call MPI_RECV( temp_iobuf, max_iobuf_size,  &
                        MPI_INTEGER, &
                        i,i,File%iosystem%IO_comm,status,mpierr)
                   call CheckMPIReturn(subName,mpierr)
                   if(Debug) print *,subName, ' 2 receiving from ',i, start_size

                   call MPI_RECV( temp_start, &
                        start_size, MPI_INTEGER,  &
                        i,File%iosystem%num_iotasks+i,File%iosystem%IO_comm,status,mpierr)
                   call CheckMPIReturn(subName,mpierr)
                   if(Debug) print *,subName, ' 3 receiving from ',i, count_size

                   call MPI_RECV( temp_count, &
                        count_size, MPI_INTEGER,  &
                        i,2*File%iosystem%num_iotasks+i,File%iosystem%IO_comm,status,mpierr)
                   call CheckMPIReturn(subName,mpierr)

                   if (Debug) print *, subName,': 0: writing netcdf for ',i, temp_start,temp_count
	           if(sum(temp_count)>0) then

#ifdef TIMING
                      call t_startf("nc_put_var2")
#endif
                      ierr=nf90_put_var( fh,vid,	&
                           temp_iobuf,temp_start,temp_count)
                      if(Debug) print *, subname,__LINE__,i,fh,vid, ierr
#ifdef TIMING
                      call t_stopf("nc_put_var2")
#endif
                      if (Debug) print *, subName,': 0: done writing for ',i
                   else
                      ierr = PIO_NOERR
                   end if


                end do ! i=1,File%iosystem%num_iotasks-1
             end if ! ierr==pio_noerr
          endif  ! File%iosystem%io_rank==0

          deallocate(temp_start)
          deallocate(temp_count)

          if (File%iosystem%num_iotasks>1) then
             if(File%iosystem%io_rank==0 .or. iobuf_size<max_iobuf_size) then
                deallocate(temp_iobuf)
             end if
          endif

#endif

       case default
          call bad_iotype(iotype,subname,__LINE__)

       end select
    endif  ! if (File%iosystem%IOproc)

    call check_netcdf(File, ierr,subname,__LINE__)
#ifdef TIMING
    call t_stopf("pio_write_nfdarray_int")
#endif
  call mpi_barrier(file%iosystem%comp_comm, mpierr)
  call CheckMPIReturn(subName,mpierr)

  end function WRITE_NFDARRAY_int
  ! note: IOBUF may actually point to the original data
  ! array, and cannot be modified (which is why it is intent(in))

  ! TYPE real,int,double
!>
!! @private
!<
# 22 "pionfwrite_mod.F90.in"
  integer function write_nfdarray_double (File,IOBUF,varDesc,iodesc,start,count) result(ierr)
    use nf_mod
    use pio_types
    use pio_kinds
    use pio_utils, only : check_netcdf, bad_iotype
    use alloc_mod, only: alloc_check
    use pio_support, only : Debug, DebugIO, piodie, checkmpireturn 

#ifdef _NETCDF
    use netcdf, only : nf90_put_var  !_EXTERNAL
#endif
#ifdef TIMING
    use perf_mod, only : t_startf, t_stopf  !_EXTERNAL
#endif
    include 'mpif.h'   !_EXTERNAL
#ifdef _PNETCDF
#   include <pnetcdf.inc>   /* _EXTERNAL */
#endif

    type (File_desc_t), intent(inout) :: File
    real(r8) , intent(in), target      :: IOBUF(:)
    type (var_desc_t), intent(in)     :: varDesc
    type (IO_desc_t), intent(in)      :: IODesc


    integer(pio_offset), intent(in) :: start(:), count(:)

    character(len=*), parameter :: subName=modName//'::write_nfdarray_double'

    integer(i4) :: iotype, mpierr
    integer :: status(MPI_STATUS_SIZE)
    integer iobuf_size, max_iobuf_size
    real(r8) , pointer :: temp_iobuf(:)
    integer, pointer :: temp_start(:), temp_count(:)
    integer start_size, count_size
    integer i
    integer :: fh, vid, oldval

#ifdef TIMING
    call t_startf("pio_write_nfdarray_double")
#endif
    iotype = File%iotype
    ierr=PIO_noerr

    if(file%iosystem%ioproc) then
       select case (iotype) 

#ifdef _PNETCDF
       case(iotype_pnetcdf)
#ifdef DEBUG
          if(size(iobuf)<=0) then
             call piodie(subname,__LINE__,'empty iobuf')
          end if
#endif
          ierr=nfmpi_put_vara_all( File%fh,varDesc%varid,start, &
               count,IOBUF, &
               int(iodesc%Write%n_ElemTYPE,kind=pio_offset), &
               iodesc%Write%ElemTYPE)

          if(Debug.or.ierr/=PIO_noerr) print *,subname,__LINE__, &
               '  IAM: ',File%iosystem%io_rank,' start: ',start,' count: ',count,&
               ' size :',iodesc%Write%n_ElemTYPE, ' error: ',ierr, &
               iodesc%Write%ElemTYPE
          if(Debug.or.ierr/=PIO_noerr) print *,subname,__LINE__, &
               '  IAM: ',File%iosystem%io_rank,'minval: ',minval(IOBUF),'maxval: ',maxval(IOBUF)
#endif

#ifdef _NETCDF
       case(iotype_netcdf)
          ! allocate space on root for copy of iobuf etc.
          iobuf_size=size(IOBUF)
          if(File%iosystem%num_iotasks>1) then
             call MPI_ALLREDUCE(iobuf_size,max_iobuf_size, &
                  1,MPI_INTEGER,MPI_MAX,File%iosystem%IO_comm,mpierr)
             call CheckMPIReturn(subName, mpierr)

             if (File%iosystem%io_rank==0) then
                   call alloc_check(temp_iobuf,max_iobuf_size)
             else
                if(max_iobuf_size>iobuf_size) then
                   call alloc_check(temp_iobuf,max_iobuf_size)
                   temp_iobuf(1:iobuf_size) = iobuf
                else
                   temp_iobuf => iobuf
                end if
             end if
          endif

          start_size=size(start)
          call alloc_check(temp_start,start_size)
          temp_start=start

          count_size=size(count)
          call alloc_check(temp_count,count_size)
          temp_count=count

          ! Every i/o proc send data to root

          if (File%iosystem%io_rank>0) then
             ! Wait for io_rank 0 to indicate that its ready before sending
             ! this handshaking is nessasary for jaguar
             call MPI_RECV( i, 1, MPI_INTEGER, 0, file%iosystem%io_rank, &
                  file%iosystem%io_comm, status, mpierr)
             call CheckMPIReturn(subName, mpierr)

             if (Debug) print *, subName,': File%iosystem%comp_rank:',File%iosystem%comp_rank, &
                  ': relaying IOBUF for write size=',size(IOBUF), temp_start,temp_count, start_size, count_size, i


             call MPI_SEND( temp_IOBUF,max_iobuf_size, &
                  MPI_REAL8, &
                  0,File%iosystem%io_rank,File%iosystem%IO_comm,mpierr )
             call CheckMPIReturn(subName, mpierr)

             call MPI_SEND( temp_start,size(start),MPI_INTEGER, &
                  0,File%iosystem%num_iotasks+File%iosystem%io_rank,File%iosystem%IO_comm,mpierr )
             call CheckMPIReturn(subName, mpierr)

             call MPI_SEND( temp_count,size(count),MPI_INTEGER, &
                  0,2*File%iosystem%num_iotasks+File%iosystem%io_rank,File%iosystem%IO_comm,mpierr )
             call CheckMPIReturn(subName, mpierr)

          endif

          if (File%iosystem%io_rank==0) then 
             if (Debug) print *, subName,': 0: writing netcdf for self ', &
                  'fh=',File%fh,' varid=',varDesc%varid, temp_start, temp_count, size(iobuf)
             fh = file%fh
             vid = vardesc%varid
             ierr=nf90_put_var( fh, vid,IOBUF,temp_start,temp_count)
             if(Debug) print *, subname,__LINE__,fh,vid, ierr
             if(ierr==pio_noerr) then
                if (Debug) print *, subName,': 0: done writing for self',start_size

                do i=1,File%iosystem%num_iotasks-1

                   ! Send a signal indicating ready to recv
                   call MPI_SEND( i, 1, MPI_INTEGER, i, i, &
                        file%iosystem%io_comm, mpierr)
                   call CheckMPIReturn(subName,mpierr)
                   ! receive IOBUF, temp_start, temp_count from io_rank i
                   if(Debug) print *,subName, ' 1 receiving from ',i, max_iobuf_size

                   call MPI_RECV( temp_iobuf, max_iobuf_size,  &
                        MPI_REAL8, &
                        i,i,File%iosystem%IO_comm,status,mpierr)
                   call CheckMPIReturn(subName,mpierr)
                   if(Debug) print *,subName, ' 2 receiving from ',i, start_size

                   call MPI_RECV( temp_start, &
                        start_size, MPI_INTEGER,  &
                        i,File%iosystem%num_iotasks+i,File%iosystem%IO_comm,status,mpierr)
                   call CheckMPIReturn(subName,mpierr)
                   if(Debug) print *,subName, ' 3 receiving from ',i, count_size

                   call MPI_RECV( temp_count, &
                        count_size, MPI_INTEGER,  &
                        i,2*File%iosystem%num_iotasks+i,File%iosystem%IO_comm,status,mpierr)
                   call CheckMPIReturn(subName,mpierr)

                   if (Debug) print *, subName,': 0: writing netcdf for ',i, temp_start,temp_count
	           if(sum(temp_count)>0) then

#ifdef TIMING
                      call t_startf("nc_put_var2")
#endif
                      ierr=nf90_put_var( fh,vid,	&
                           temp_iobuf,temp_start,temp_count)
                      if(Debug) print *, subname,__LINE__,i,fh,vid, ierr
#ifdef TIMING
                      call t_stopf("nc_put_var2")
#endif
                      if (Debug) print *, subName,': 0: done writing for ',i
                   else
                      ierr = PIO_NOERR
                   end if


                end do ! i=1,File%iosystem%num_iotasks-1
             end if ! ierr==pio_noerr
          endif  ! File%iosystem%io_rank==0

          deallocate(temp_start)
          deallocate(temp_count)

          if (File%iosystem%num_iotasks>1) then
             if(File%iosystem%io_rank==0 .or. iobuf_size<max_iobuf_size) then
                deallocate(temp_iobuf)
             end if
          endif

#endif

       case default
          call bad_iotype(iotype,subname,__LINE__)

       end select
    endif  ! if (File%iosystem%IOproc)

    call check_netcdf(File, ierr,subname,__LINE__)
#ifdef TIMING
    call t_stopf("pio_write_nfdarray_double")
#endif
  call mpi_barrier(file%iosystem%comp_comm, mpierr)
  call CheckMPIReturn(subName,mpierr)

  end function WRITE_NFDARRAY_double

end module pionfwrite_mod
