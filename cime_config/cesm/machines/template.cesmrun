#! /usr/bin/env perl 
#------------------------------------------------------------------------------
# Batch system directives
#------------------------------------------------------------------------------
{{ batchdirectives }}
use strict;
use warnings;
use POSIX qw(strftime);
use File::Path;
use File::Copy;
use File::Spec;
use File::Basename;
use XML::LibXML;
use Data::Dumper;
use Cwd;
use Getopt::Long;
my $scriptname = $0;
my $caseroot = "{{ caseroot }}";
my $cimeroot = "{{ cimeroot }}";
my %opts;
chdir $caseroot;
my $toolsdir = "$caseroot/Tools";
push(@INC, $toolsdir);
my $perl5lib = "$cimeroot/utils/perl5lib";
push(@INC, $perl5lib, "$perl5lib/Config");

require SetupTools;
require Run::RunChecks;
require Depends::Checks;
require Module::ModuleLoader;
require Batch::BatchUtils;


#------------------------------------------------------------------------------
# PE Layout Documentation:
#------------------------------------------------------------------------------
{{ pedocumentation }}
# -------------------------------------------------------------------------
# global data needed by the script, stuff like the max number of threads, 
# -------------------------------------------------------------------------
my $banner = "*" x 65;
my %config;
my $case;
my $compiler;
my $machine; 
my $machroot;
my $mpilib;
my $scriptsroot;
my $maxthreads = 2;
my $LID;
# -------------------------------------------------------------------------
# Set up the run, run the model, do the postrun steps
# -------------------------------------------------------------------------
sub main
{
    getOptions();
    for(my $cycle=0;$cycle<$config{DATA_ASSIMILATION_CYCLES};$cycle++){
	doPreRunChecks();
	checkInputData();
	runModel();
	postRun();
	DoDataAssimilation($config{RUNDIR},$config{CASEROOT},$config{DATA_ASSIMILATION},
	    $config{DATA_ASSIMILATION_SCRIPT},$LID,$config{LOGDIR});
    }
    resubmitCheck();
    exit(0);
}
main(@ARGV) unless caller();

# -------------------------------------------------------------------------
# Get options
# -------------------------------------------------------------------------
sub getOptions()
{
    %opts = (
	debug => undef,
	#sta_ok => undef,
	);
    
    GetOptions(
	"debug" => \$opts{'debug'},
	#"sta_ok" => \$opts{'sta_ok'},
	);

    # First, get the configuration from xml . 
    %config = SetupTools::getAllResolved();
    $case        = $config{'CASE'};
    $caseroot    = $config{'CASEROOT'};
    $compiler    = $config{'COMPILER'};
    $machine     = $config{'MACH'};
    $machroot    = $config{'MACHDIR'};
    $mpilib      = $config{'MPILIB'};
    if($config{'RUN_WITH_SUBMIT'} eq 'FALSE' )
    {
	    print "You are not calling the run script via the submit script. \n";
	    print "As a result, short-term archiving will not be called automatically. \n";
	    print "Please submit your run by running the submit script like so:   \n";
	    print "./$case.submit\n";
	    exit(1);
    }
    else
    {
        `./xmlchange RUN_WITH_SUBMIT=TRUE`;
    }
    
}

# -------------------------------------------------------------------------
# Pre run initialization code..
# -------------------------------------------------------------------------
sub doPreRunChecks()
{
    # Change to the case root
    chdir($config{'CASEROOT'});
	
    # Update the configuration from xml . 
    %config = SetupTools::getAllResolved();
    $case        = $config{'CASE'};
    $caseroot    = $config{'CASEROOT'};
    $compiler    = $config{'COMPILER'};
    $machine     = $config{'MACH'};
    $machroot    = $config{'MACHDIR'};
    $mpilib      = $config{'MPILIB'};

    # Now, check for locked files. 
    Run::RunChecks->checkLockedFiles();
    
    # Now, load the module environment... 
    # ModuleLoader for module-based systems.  
    
    my $moduleloader = new Module::ModuleLoader(machine  => $config{'MACH'}, 
						compiler => $config{'COMPILER'},
						mpilib   => $config{'MPILIB'}, 
						debug    => $config{'DEBUG'}, 
						caseroot => $config{'CASEROOT'},
						cimeroot => $config{'CIMEROOT'},
	                                        model    => $config{'MODEL'});
    
    $moduleloader->moduleInit();
    $moduleloader->findModulesForCase();
    $moduleloader->loadModules();
    
    my $mpilib = `./xmlquery -value MPILIB`;
    if($mpilib =~ /mpi-serial/)
    {
        delete $ENV{'MP_MPILIB'};
    }
    else
    {
        $ENV{'MP_MPILIB'} = $mpilib;
    }
        $config{'MPILIB'} = $mpilib;
	
	print "build complete? $config{'BUILD_COMPLETE'}\n";
	if($config{'BUILD_COMPLETE'} ne 'TRUE')
	{
		print "BUILD_COMPLETE is not true\n";
		print "Please rebuild the model interactively\n";
		exit(-2);
	}
	
	$ENV{'LBQUERY'} = "TRUE";
	if( ! defined $config{'BATCHSUBMIT'} || length $config{'BATCHSUBMIT'} == 0)
	{
		$ENV{'LBQUERY'} = "FALSE";
		$ENV{'BATCHQUERY'} = "undefined";
	}
	
	elsif ( $config{'BATCHSUBMIT'} eq 'UNSET')
	{
		$ENV{'LBSUBMIT'} = "FALSE";
		$ENV{'BATCHSUBMIT'} = "undefined";
	}
	
	## Create the timing directories, optionally cleaning them if needed. 
	if(! -d $config{'RUNDIR'})
	{
		mkpath($config{'RUNDIR'}) or die "could not crate $config{'RUNDIR'}, exiting\n";
	}
	if(-d "$config{'RUNDIR'}/timing")
	{
		rmtree("$config{'RUNDIR'}/timing");
	}
	# Now make the timing and timing/checkpoints directories..
	mkpath("$config{'RUNDIR'}/timing/checkpoints");
	
	# Now set up the LID and sdate? strings
	$LID = strftime("%y%m%d-%H%M%S", localtime);
	my $sdate = strftime("%Y-%m-%d %H:%M:%S", localtime);
	$ENV{'LID'} = $LID;
	$ENV{'sdate'} = $sdate;
	
	open my $CS, ">>", "./CaseStatus" or die "Could not open CaseStatus file for writing!";
	print $CS "run started $sdate\n";
	close $CS;
	
	print "-------------------------------------------------------------------------\n";
	print " BUILDNML SCRIPT STARTING\n";
	print " - To prestage restarts, untar a restart.tar file into $config{'RUNDIR'}\n";
	
	# Run preview namelists.. should turn this into a module at some point..
	my @previewoutput = qx("./preview_namelists");
	map { print $_ } @previewoutput;
	
	if($?)
	{
		print "ERROR from preview namelist - EXITING\n";
		exit(-1);
	}
	
	print " BUILDNML SCRIPT HAS FINISHED SUCCESSFULLY\n";
	print "-------------------------------------------------------------------------\n\n";
	print "-------------------------------------------------------------------------\n";
	print " PRESTAGE SCRIPT STARTING\n";
	print " - Case input data directory, DIN_LOC_ROOT, is $config{'DIN_LOC_ROOT'}\n";
	print " - Checking the existence of input datasets in DIN_LOC_ROOT\n";

}

# -------------------------------------------------------------------------
# we've done the preview namelists check, now we'll check on the inputdata..
# -------------------------------------------------------------------------
sub checkInputData()
{
    chdir($config{'CASEROOT'}) or die "cannot change directory to $config{'CASEROOT'}, $!";
    if(! -d $config{'DIN_LOC_ROOT'})
    {
	print "ERROR, the input data directory $config{'DIN_LOC_ROOT'} cannot be found!\n";
	exit(-20);
    }
    
    my @inputdatacheck = qx(./check_input_data -inputdata $config{'DIN_LOC_ROOT'} -check );
    my @unknown = grep { /unknown/ } @inputdatacheck;
    my @missing = grep { /missing/ } @inputdatacheck;
    
    if(@unknown)
    {
	#my $unknownmsg = <<MSG;
        print "Any files with \"status unknown\" below were not found in the\n";
        print "expected location, and are not from the input data repository.\n";
        print "This is informational only.\n";
	
	qx(./check_input_data -inputdata $config{'DIN_LOC_ROOT'} -check);
    }
    
    if(@missing)
    {
	print "Attempting to download missing data:\n";
	qx(./check_input_data -inputdata $config{'DIN_LOC_ROOT'} -export);
    }
    
    my @potmissing  = qx(./check_input_data -inputdata $config{'DIN_LOC_ROOT'} -check );
    @missing = grep { /missing/ } @potmissing;
    if(@missing)
    {
	my @notfound = qx(./check_input_data -inputdata $config{'DIN_LOC_ROOT'} -check);
	
	print "The following files were not found, they are required\n";
	map { print $_ } @notfound;
	print "Invoke the following command to obtain them:\n";
	print" ./check_input_data -inputdata $config{'DIN_LOC_ROOT'} -export ";
	print "\n";
	exit(-30);
    }
    
    # Prestage our reference case if required..
    if( ($config{'GET_REFCASE'} eq 'TRUE') && ($config{'RUN_TYPE'} ne 'startup') && ($config{'CONTINUE_RUN'} eq 'FALSE'))
    {
	my $refdir = "$config{'RUN_REFCASE'}/$config{'RUN_REFDATE'}";
	my $fullrefdirpath = "$config{'DIN_LOC_ROOT'}/ccsm4_init/$refdir";
	if(! -d $fullrefdirpath)
	{
            print "$banner\n";
            print "ccsm_prestage ERROR: $refdir is not on local disk!\n";
            print "Obtain this data from the svn input data repository\n";
            print "> mkdir -p $refdir\n";
            print "> cd $refdir\n";
            print "> cd ..\n";
            print "> svn export --force https://svn-ccsm-inputdata.cgd.ucar.edu/trunk/inputdata/$refdir\n";
            print "or set GET_REFCASE to FALSE in env_run.xml\n";
            print "and prestage the restart data to $config{'RUNDIR'} manually\n";
            print "$banner\n";
	    exit(-1);
	}
	
	print " - Prestaging REFCASE ($refdir) to $config{'RUNDIR'}\n";
	
	# prestage the reference case's files.  
	mkpath $config{'RUNDIR'} if (! -d $config{'RUNDIR'});
	my @refcasefiles = glob("$fullrefdirpath/*$config{'RUN_REFCASE'}*");
	foreach my $rcfile(@refcasefiles)
	{
	    my $rcbasename = basename($rcfile);
	    if(! -f "$config{'RUNDIR'}/$rcbasename")
	    {
		symlink($rcfile, "$config{'RUNDIR'}/$rcbasename") or warn "could not symlink $rcfile to $config{'RUNDIR'}/$rcbasename, $!";
	    }
	}

	# find the *rpointer* files, copy them to the rundir. 
	my @rpointerfiles = glob("$fullrefdirpath/*rpointer*");
	foreach my $rpointerfile(@rpointerfiles)
	{
	    copy($rpointerfile, $config{'RUNDIR'});
	}
	
	chdir($config{'RUNDIR'});
	
	my @cam2_list = glob("*.cam2.*");
	foreach my $cam2file(@cam2_list)
	{
	    my $camfile = $cam2file;
	    $camfile =~ s/cam2/cam/g;
	    symlink($cam2file, $camfile);
	}
	
	my @allrundirfiles = glob("$config{'RUNDIR'}/*");
	foreach my $runfile(@allrundirfiles)
	{
	    chmod 0755, $runfile;
	}
	print "prestaging has finished successfully!\n";
    }
}

# -------------------------------------------------------------------------
# Run the model system
# -------------------------------------------------------------------------
sub runModel()
{
    chdir $config{'RUNDIR'};
    
    system("sleep 10");
    my $localtime = localtime;
    # Set OMP_NUM_THREADS
    $ENV{'OMP_NUM_THREADS'} = {{ thread_count }};

    print "$localtime MODEL EXECUTION BEGINS HERE\n";
    # Run the model
    {{ mpirun }}
    $localtime = localtime;
    print "$localtime MODEL EXECUTION HAS FINISHED\n";
}

sub disposeLog
{
    my($rundir,$caseroot,$component,$lid,$logdir) = @_;

    my $logfile = "$component.log.$lid";

    my $dir = getcwd;
    chdir $rundir unless($dir eq $rundir);

    if(-e $logfile){
	qx(gzip $logfile);
	$logfile .= ".gz";
	if(-e $logfile){
            copy($logfile, $logdir );
	}
    }

}	    





# -------------------------------------------------------------------------
# Post-processing
# -------------------------------------------------------------------------
sub postRun()
{
    # Go back to the caseroot, pull in the configuration in case a user changed 
    # of the variables  
    chdir $config{'CASEROOT'};
    %config = SetupTools::getAllResolved();
    my $rundir = $config{RUNDIR};
    my $sdate = strftime("%Y-%m-%d %H:%M:%S", localtime);

    my $workingdir = getcwd;

    # find the last $model.log and cpl.log
    my $logfile = "$rundir/cesm.log.$LID";
    my $cpllogfile = "$rundir/cpl.log.$LID";

    if( -z $logfile) 
    {
        print "Model did not complete, no cesm.log file present\n";
    }

    if(! -e $cpllogfile)
    {
        my $msg = "Model did not complete - no cpl.log file corresponding to most recent model log: $logfile";
        print("$msg\n");
        appendCaseStatus($msg);
        exit(-1);
    }

    if(-z $cpllogfile)
    {
        print "Model did not complete, see $logfile\n";
        open (my $CS, ">>", "$config{'CASEROOT'}/CaseStatus") or warn "cannot open $config{'CASEROOT'}/CaseStatus, error was $!";
        print $CS "Run FAILED $sdate\n";
        exit(-1);
    }
    elsif( -e  $cpllogfile)
    {
        open my $CPLLOG, "<", "$cpllogfile" or warn "could not open $cpllogfile, $!";
        my @cpllines = <$CPLLOG>;
        close $CPLLOG;
        if(@cpllines)
        {
            my @success = grep(/SUCCESSFUL TERMINATION/, @cpllines);
            if(@success)
            {
                appendCaseStatus("run SUCCESSFUL $sdate");
            }
            else
            {
                appendCaseStatus("Model did not complete - see $logfile");
                exit(-1);
            }

        }
        else
        {
            appendCaseStatus("Model did not complete - no cpl.log file corresponding to most recent model log: $logfile");
            exit(-1);
        }
    }

    chdir($rundir) or die "could not cd to $rundir";

    if(defined $config{'LOGDIR'} && (length($config{'LOGDIR'}) > 0))
    {
        if(! -e $config{'LOGDIR'})
        {
            mkpath($config{'LOGDIR'}) or warn "Cannot make log directory $config{'LOGDIR'}, $!";
        }

        Debug("lid: $LID");
	foreach my $comp (qw(atm cpl ocn wav glc ice rof lnd)){
	    disposeLog($config{RUNDIR},$config{CASEROOT}, $comp ,$LID,$config{LOGDIR});
	}
    }

    # Run the getTiming script if desired
    my $owd = getcwd();
    chdir $config{'CASEROOT'};
    if($config{'CHECK_TIMING'} eq 'TRUE')
    {
        my $timingDir = $config{'CASEROOT'} . "/timing";
        mkpath $timingDir if(! -e $timingDir);
        print "running timing script..\n";
        qx( $config{'CASETOOLS'}/getTiming -lid $LID );
        print "gzipping timing stats..\n";
        qx( gzip timing/cesm_timing_stats.$LID );
    }
    chdir $owd;

    # Save the timing files if desired
    if($config{'SAVE_TIMING'} eq 'TRUE')
    {
        move( "$config{'RUNDIR'}/timing",  "$config{'RUNDIR'}/timing.$LID");
    }
}

sub appendCaseStatus
{
    my $msg = shift;
    open (my $CS, ">>", "$config{'CASEROOT'}/CaseStatus") or warn "cannot open $config{'CASEROOT'}/CaseStatus, $!";
    print $CS "$msg\n";
    close $CS;
}

# check to see if we need to do resubmission from this particular job,
sub resubmitCheck()
{
    my $submitscript = "$config{'CASEROOT'}/$config{'CASE'}.submit";
    
    my $cwd = getcwd;
    chdir $config{'CASEROOT'};
    my $resubmitcommand = "$submitscript -resubmit -scriptname $config{'CASE'}.run";
    print "running resubmit check $resubmitcommand\n";
    qx($resubmitcommand) or warn "could not run CESM submit script, $! $?";
    chdir $cwd;
}

sub DoDataAssimilation
{
    my ($rundir, $caseroot, $da, $da_script, $lid, $logdir) = @_;

    return unless($da eq "TRUE");

    qx( $da_script 1> da.log.$lid 2>&1);
    sleep(1);
    die "$da_script failed" unless ($? == 0);
    chdir $rundir;
    disposeLog($rundir,$caseroot, 'da' ,$lid,$logdir);
    chdir $caseroot;
}


sub Debug
{
    my $debugmsg = shift;
    chomp $debugmsg; 
    if($opts{'debug'})
    {
	print "DEBUG: $debugmsg\n";
    }
}

