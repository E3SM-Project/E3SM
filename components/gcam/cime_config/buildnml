#!/usr/bin/env python

"""
Namelist creator for E3SM's GCAM component
"""

import os, sys
import shutil
import filecmp
import re
import glob

_CIMEROOT = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..","..","..","cime")
sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))

from standard_script_setup import *
from CIME.case import Case
from CIME.utils import expect, run_cmd_no_fail, safe_copy
from CIME.buildnml import create_namelist_infile, parse_input

logger = logging.getLogger(__name__)

###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################
    expect(compname == "gcam", compname)

    os.chdir(caseroot)

    casebuild            = case.get_value("CASEBUILD")
    caseroot             = case.get_value("CASEROOT")
    srcroot              = case.get_value("SRCROOT")
    din_loc_root         = case.get_value("DIN_LOC_ROOT")
    ninst_iac            = case.get_value("NINST_IAC")
    get_refcase          = case.get_value("GET_REFCASE")
    iac_grid             = case.get_value("IAC_GRID")
    gcam_bldnml_opts   = case.get_value("GCAM_BLDNML_OPTS")
    gcam_nml_use_case = case.get_value("GCAM_NML_USE_CASE")
    gcam_namelist_opts = case.get_value("GCAM_NAMELIST_OPTS")
    rundir               = case.get_value("RUNDIR")
    run_type             = case.get_value("RUN_TYPE")
    run_refcase          = case.get_value("RUN_REFCASE")
    run_refdate          = case.get_value("RUN_REFDATE")
    run_refdir           = case.get_value("RUN_REFDIR")
    run_reftod           = case.get_value("RUN_REFTOD")
    scriptsroot          = case.get_value("SCRIPTSROOT")
    mach                 = case.get_value("MACH")

    # Optional: dynamic surface dataset name; if unset we'll parse gcam_in for gcam_grid
    def _case_get(key):
        try:
            return case.get_value(key)
        except Exception:
            return None

    # Will derive from gcam_in (namelist) later; initialize as None
    iesm_dyn_source = None

    iacconf_dir = os.path.join(casebuild, "gcamconf")

    if not os.path.isdir(iacconf_dir): os.mkdir(iacconf_dir)

    # Null string defaults
    if not gcam_bldnml_opts: gcam_bldnml_opts=""
    if not gcam_namelist_opts: gcam_namelist_opts=""

    #--------------------------------------------------------------------
    # Verify iac grid is supported
    #--------------------------------------------------------------------

    # Have to update this when we build grids more
    iac_grid_supported = ("r0125", "r05","0.9x1.25", "1.9x2.5", "null")
    expect(iac_grid in iac_grid_supported, "IAC_GRID '{}' is not supported in GCAM. Choose from: {}".format(iac_grid,iac_grid_supported))

    #--------------------------------------------------------------------
    # There is no configure script!
    # So for now make a simple one that just sets hgrid in config_cache.xml
    # - remove the creation of config_cache.xml from build-namelist
    #--------------------------------------------------------------------
    
    sysmod = os.path.join(srcroot, "components/gcam/bld/configure")
    sysmod += " -hgrid {}".format(iac_grid)
    sysmod += " -usr_src {}".format(caseroot)
    run_cmd_no_fail(sysmod, from_dir=iacconf_dir)    

    #--------------------------------------------------------------------
    # Invoke gcam build-namelist - output will go in $CASEBUILD/gcamconf
    #--------------------------------------------------------------------

    inst_string = ""
    for inst_counter in range(1, ninst_iac + 1):

        # -----------------------------------------------------
        # determine instance string
        # This is moot because gcam runs with only ninst=1
        # But we'll keep it anyway just in case that changes
        # -----------------------------------------------------

        inst_string = ""
        if ninst_iac > 1:
            inst_string = "_{0:04d}".format(inst_counter)

            # If multi-instance case does not have restart file, use single-case restart
            # for each instance
            if not os.path.exists(os.path.join(rundir, "rpointer.iac{}".format(inst_string))) and \
                   os.path.exists(os.path.join(rundir, "rpointer.iac")):
                safe_copy(os.path.join(rundir, "rpointer.iac"),
                          os.path.join(rundir, "rpointer.iac{}".format(inst_string)))





        # -----------------------------------------------------
        # create gcamconf/namelist
        # -----------------------------------------------------

        if os.path.exists(os.path.join(casebuild, "gcam.input_data_list")):
            os.remove(os.path.join(casebuild, "gcam.input_data_list"))

        gcamicfile = ""
        gcam_startfile = ""

#### iac/gcam restart isn't controlled by this type of file
#### there are several pieces to restart and they are not working yet
#### to get a proper starting date with hybrid we need to override this
#### this is because the iac is notrestarted at 2015, it is run for the first time
#### to do: check this later

#        if run_type == "hybrid" or run_type == "branch":
#            gcam_startfile = "{}.gcam{}.r.{}-{}.nc".format(run_refcase, inst_string, run_refdate, run_reftod)
#            if not os.path.exists(os.path.join(rundir, gcam_startfile)):
#                gcam_startfile = "{}.gcam.r.{}-{}.nc".format(run_refcase, run_refdate, run_reftod)

#            gcamicfile = " {} = '{}'".format(startfiletype, gcam_startfile)

        infile_text = ""
        if gcamicfile: infile_text = "{} = '{}' \n".format(startfiletype, gcam_startfile)

        create_namelist_infile(case,
                               "{}/user_nl_gcam{}".format(caseroot, inst_string),
                               "{}/namelist".format(iacconf_dir),
                               infile_text=infile_text)

        # -----------------------------------------------------
        # call build-namelist
        # -----------------------------------------------------

        usecase = (gcam_nml_use_case) if gcam_nml_use_case not in [None, "UNSET"] else " "
        sysmod  = os.path.join(srcroot, "components/gcam/bld/build-namelist")
        sysmod += " -infile {}/namelist".format(iacconf_dir)
        sysmod += " -caseroot {}".format(caseroot)
        sysmod += " -scriptsroot {}".format(scriptsroot)
        sysmod += ' -namelist " &gcamexp {} /" '.format(gcam_namelist_opts)
        sysmod += " -use_case {}".format(usecase)
        sysmod += ' -inst_string "{}" {}'.format(inst_string, gcam_bldnml_opts)
        
        run_cmd_no_fail(sysmod, from_dir=iacconf_dir)

        # -----------------------------------------------------
        # move gcam_in to $RUNDIR
        # -----------------------------------------------------
        if os.path.exists(rundir):
            safe_copy(os.path.join(iacconf_dir, "gcam_in"), os.path.join(rundir, "gcam_in{}".format(inst_string)))

    # -------------------------------------------------------------------------
    # GCAM/GLM run-setup previously done in shell run script
    #   - create symlinks for config, restarts, and static files
    #   - refresh three copies needed at run time
    # No-clobber by default; enable overwrite with GCAM_OVERWRITE=1|true|yes
    # Control whether to COPY or SYMLINK the dynamic surfdata target
    # --- S. Feng, 2025-08-19
    # -------------------------------------------------------------------------

    _OVERWRITE = str(os.environ.get("GCAM_OVERWRITE", "")).lower() in ("1", "true", "yes")

    def _ensure_symlink(src, dst):
        """Create symlink dst -> src without clobbering by default.
        If dst exists and matches, do nothing. If differs, require _OVERWRITE.
        """
        expect(os.path.exists(src), "Missing source for symlink: {}".format(src))
        os.makedirs(os.path.dirname(dst) or ".", exist_ok=True)
        if os.path.lexists(dst):
            if os.path.islink(dst):
                cur = os.readlink(dst)
                if os.path.abspath(cur) == os.path.abspath(src):
                    logger.info("Symlink exists and matches: {} -> {}".format(dst, src))
                    return
            if not _OVERWRITE:
                expect(False, "Refusing to overwrite existing path: {} (set GCAM_OVERWRITE=1 to override)".format(dst))
            if os.path.isdir(dst) and not os.path.islink(dst):
                shutil.rmtree(dst)
            else:
                os.remove(dst)
        os.symlink(src, dst)
        logger.info("Created symlink: {} -> {}".format(dst, src))

    def _ensure_copy(src, dst):
        """Copy src -> dst without clobbering by default; skip if identical."""
        expect(os.path.isfile(src), "Missing source file to copy: {}".format(src))
        os.makedirs(os.path.dirname(dst) or ".", exist_ok=True)
        if os.path.exists(dst):
            try:
                if filecmp.cmp(src, dst, shallow=False):
                    logger.info("Copy target exists and is identical; skipping: {}".format(dst))
                    return
            except Exception:
                pass
            if not _OVERWRITE:
                expect(False, "Refusing to overwrite existing file: {} (set GCAM_OVERWRITE=1 to override)".format(dst))
            os.remove(dst)
        shutil.copy2(src, dst)
        logger.info("Copied file to: {}".format(dst))

    # Derive standard directories from DIN_LOC_ROOT (input_data_dir in the run script)
    input_data_dir = din_loc_root
    expect(os.path.isdir(input_data_dir), "DIN_LOC_ROOT does not exist: {}".format(input_data_dir))
    expect(os.path.isdir(rundir),         "RUNDIR does not exist: {}".format(rundir))
    expect(mach,                         "MACH is not set in the case")

    gcam_idir   = os.path.join(input_data_dir, "iac", "giac", "gcam", "gcam_6_0")
    glm_idir    = os.path.join(input_data_dir, "iac", "giac", "glm")
    glm2iacdir  = os.path.join(input_data_dir, "iac", "giac", "glm2iac")
    gcam_rdir   = os.path.join(gcam_idir, "restart", "ssp2rcp45", mach)
    ldir        = os.path.join(input_data_dir, "lnd", "clm2", "rawdata", "LUT_input_files_current")

    for pth, label in ((gcam_idir, "gcam_idir"), (glm_idir, "glm_idir"), (glm2iacdir, "glm2iacdir"), (gcam_rdir, "gcam_rdir"), (ldir, "ldir")):
        expect(os.path.exists(pth), "Required path missing ({}): {}".format(label, pth))

    # If iesm_dyn_source is not provided, try to parse it from gcam_in as gcam_gridfile or gcam_grid
    def _extract_gcam_grid_from_gcam_in(rundir_path):
        pat = re.compile(r"^\s*(gcam_gridfile|gcam_grid)\s*=\s*['\"]([^'\"]+)['\"]", re.IGNORECASE)
        candidates = [os.path.join(rundir_path, "gcam_in")] + sorted(glob.glob(os.path.join(rundir_path, "gcam_in*")))
        for fn in candidates:
            if not os.path.isfile(fn):
                continue
            try:
                with open(fn, 'r') as fh:
                    for line in fh:
                        m = pat.match(line)
                        if m:
                            return m.group(2)
            except Exception:
                pass
        return None

    if not iesm_dyn_source:
        guessed = _extract_gcam_grid_from_gcam_in(rundir)
        if guessed:
            iesm_dyn_source = guessed
            logger.info("Derived dynamic surface dataset from gcam_in (gcam_gridfile/gcam_grid): {}".format(iesm_dyn_source))
        else:
            logger.warning("IESM_DYN_SOURCE not set and could not be derived from gcam_in; dynamic file link may be skipped.")

    # === Symlinks formerly created by the run script ===
    _ensure_symlink(os.path.join(gcam_idir, "input"),
                    os.path.join(os.path.dirname(caseroot), "input"))
    _ensure_symlink(os.path.join(gcam_idir, "configuration", "log_conf.xml"),
                    os.path.join(rundir, "log_conf.xml"))
    _ensure_symlink(os.path.join(glm_idir, "glm.fut.conf.{}".format(mach)),
                    os.path.join(rundir, "glm.fut.conf"))

    # Link all restart.* files from gcam_rdir into rundir
    for src in glob.glob(os.path.join(gcam_rdir, "restart.*")):
        fname = os.path.basename(src)
        dst = os.path.join(rundir, fname)
        _ensure_symlink(src, dst)

    # Static files into run dir (with target names)
    _ensure_symlink(os.path.join(ldir, "iESM_Ref_CropPast2015_c10142019.nc"),
                    os.path.join(rundir, "iESM_Init_CropPast.nc"))
    _ensure_symlink(os.path.join(ldir, "surfdata_360x720_mcrop2015_c07082020.nc"),
                    os.path.join(rundir, "surfdata_360x720_mcrop_init.nc"))

    _ensure_symlink(os.path.join(ldir, "iESM_Ref_CropPast2015_c10142019.nc"),
                os.path.join(rundir, "iESM_Dyn_CropPast.nc"))
    _ensure_symlink(os.path.join(ldir, "surfdata_360x720_mcrop2015_c07082020.nc"),
                os.path.join(rundir, "surfdata_360x720_mcrop_dyn.nc"))

    # Dynamic source: absolute path or relative to glm2iacdir
    dyn_src_path = None
    if iesm_dyn_source:
        dyn_src_path = iesm_dyn_source if os.path.isabs(iesm_dyn_source) else os.path.join(glm2iacdir, iesm_dyn_source)
        expect(os.path.isfile(dyn_src_path), "iesm_dyn_source not found: {}".format(dyn_src_path))
        _ensure_symlink(dyn_src_path, os.path.join(rundir, os.path.basename(iesm_dyn_source)))
    else:
        logger.warning("Skipping dynamic source symlink because iesm_dyn_source was not determined.")

    for fname in ("surfdata_360x720_potveg.nc", "mksurf_landuse_iESM_720x360.nc"):
        src = os.path.join(glm2iacdir, fname)
        expect(os.path.isfile(src), "Missing GLM2IAC file: {}".format(src))
        _ensure_symlink(src, os.path.join(rundir, fname))

    # === Refresh dynamic run-time datasets ===
    # Keep copies for CropPast and mcrop (model may write to these).
    # For surfdata_iESM_dyn.nc: create a symlink by default; set GCAM_COPY_DYN=1 to copy instead.
    init_crop_past = os.path.join(rundir, "iESM_Init_CropPast.nc")
    mcrop_init     = os.path.join(rundir, "surfdata_360x720_mcrop_init.nc")
    dyn_crop_past = os.path.join(rundir, "iESM_Dyn_CropPast.nc")
    mcrop_dyn     = os.path.join(rundir, "surfdata_360x720_mcrop_dyn.nc")
    if dyn_src_path is None and iesm_dyn_source:
        # In unlikely case symlink creation was skipped but we still have a path
        dyn_src_path = iesm_dyn_source if os.path.isabs(iesm_dyn_source) else os.path.join(glm2iacdir, iesm_dyn_source)
    dyn_src_in_rundir = os.path.join(rundir, os.path.basename(iesm_dyn_source)) if iesm_dyn_source else None

    expect(os.path.exists(init_crop_past), "Expected iESM_Init_CropPast.nc in RUNDIR")
    expect(os.path.exists(mcrop_init),     "Expected surfdata_360x720_mcrop_init.nc in RUNDIR")
    expect(os.path.exists(dyn_crop_past), "Expected iESM_Dyn_CropPast.nc in RUNDIR")
    expect(os.path.exists(mcrop_dyn),     "Expected surfdata_360x720_mcrop_dyn.nc in RUNDIR")
    if iesm_dyn_source:
        expect(os.path.exists(dyn_src_in_rundir), "Expected dynamic source in RUNDIR: {}".format(dyn_src_in_rundir))

    if iesm_dyn_source:
        dyn_target = os.path.join(rundir, "surfdata_iESM_dyn.nc")
        _ensure_symlink(dyn_src_in_rundir, dyn_target)

###############################################################################
def _main_func():
###############################################################################
    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "gcam")

if __name__ == "__main__":
    _main_func()