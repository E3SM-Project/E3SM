! Copyright (c) 2013,  Los Alamos National Security, LLC (LANS)
! and the University Corporation for Atmospheric Research (UCAR).
!
! Unless noted otherwise source code is licensed under the BSD license.
! Additional copyright and license information can be found in the LICENSE file
! distributed with this code, or at http://mpas-dev.github.com/license.html
!
!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
!
!  ocn_time_integration_si
!
!> \brief MPAS ocean split-implicit time integration scheme
!> \author Mark Petersen, Doug Jacobsen, Todd Ringler
!> \date   September 2011 (split explicit base code)
!
!> \author Hyun-Gyu Kang (Oak Ridge National Laboratory)
!> \date   September 2019 (split-implicit code)
!> \details
!>  This module contains the routines for the split-implicit
!>  time integration scheme based on the split-explicit code.
!>  Only stage 2 (barotropic mode) is changed from the explicit
!>  subcycling scheme to the split-implicit scheme.
!
!-----------------------------------------------------------------------

module ocn_time_integration_si

   use mpas_derived_types
   use mpas_pool_routines
   use mpas_constants
   use mpas_dmpar
   use mpas_vector_reconstruction
   use mpas_spline_interpolation
   use mpas_timer
   use mpas_threading
   use mpas_timekeeping
   use mpas_log

   use ocn_config
   use ocn_mesh
   use ocn_tendency
   use ocn_diagnostics_variables
   use ocn_diagnostics
   use ocn_gm

   use ocn_equation_of_state
   use ocn_vmix
   use ocn_time_average_coupled

   use ocn_effective_density_in_land_ice

   implicit none
   private
   save

   !--------------------------------------------------------------------
   !
   ! Public parameters
   !
   !--------------------------------------------------------------------

   !--------------------------------------------------------------------
   !
   ! Public member functions
   !
   !--------------------------------------------------------------------

   public :: ocn_time_integrator_si, &
             ocn_time_integration_si_init, &
             ocn_time_integrator_si_preconditioner

   !--------------------------------------------------------------------
   !
   ! Private module variables
   !
   !--------------------------------------------------------------------

   character (len=*), parameter :: &
      iterGroupName     = 'iterFields',   &! group name for halos
      finalBtrGroupName = 'finalBtrFields' ! group name for halos

   integer, dimension(:), allocatable :: &
      numClinicIterations  ! number of baroclinic iterations for each
                           ! outer timestep iteration

   integer :: &
      numTSIterations ! number of outer timestep iterations

   real (kind=RKIND) :: &
      useVelocityCorrection ! mask for velocity correction

   ! Global variables for the split-implicit time stepper ---------------
   real (kind=RKIND), allocatable,dimension(:)   :: &
      prec_ivmat    ! an inversed preconditioning matrix
   real (kind=RKIND) :: &
      R1_alpha1s_g_dts, &! pre-computed coefficients
      R1_alpha1s_g_dt,  &! pre-computed coefficients
      R1_alpha1_g,      &! pre-computed coefficients
      alpha1,           &! implicitness parameter (=alpha)
      alpha2,           &! implicitness parameter (=1-alpha)
      tolerance_outer,  &! tolerance for the outer solver iterations
      tolerance_inner,  &! tolerance for the main solver iterations
      total_num_cells,  &! total number of surface cells
      mean_num_cells,   &! mean #cells for each core
      dt_si              ! dt for the SI btr mode solver
   integer :: &
      nPrecVec,         &! vector lenghts for preconditioner
      si_ismf,          &! SI solver linearization for ISMF cases
      ncpus,            &! Total number of cores
      nSiLargeIter       ! #iteration for the barotropic system

!***********************************************************************

!***********************************************************************

   contains

!***********************************************************************
!
!  ocn_time_integration_si
!
!> \brief MPAS ocean split-implicit time integration scheme
!> \author Mark Petersen, Doug Jacobsen, Todd Ringler
!> \date   September 2011 (split explicit base code)
!> \author Hyun-Gyu Kang (Oak Ridge National Laboratory)
!> \date   JAN 2019 (split-implicit code)
!> \details
!>  This routine integrates a master time step (dt) using a
!>  split-implicit time integrator.
!
!-----------------------------------------------------------------------

   subroutine ocn_time_integrator_si(domain, dt)!{{{

      !-----------------------------------------------------------------
      ! Input variables
      !-----------------------------------------------------------------

      real (kind=RKIND), intent(in) :: &
         dt              !< [in] time step (sec) to move forward

      !-----------------------------------------------------------------
      ! Input/output variables
      !-----------------------------------------------------------------

      type (domain_type), intent(inout) :: &
         domain  !< [inout] model state to advance forward

      !-----------------------------------------------------------------
      ! Local variables
      !-----------------------------------------------------------------

      type (block_type), pointer :: &
         block ! structure with subdomain data

      type (mpas_pool_type), pointer :: &
         statePool,         &! structure holding state variables
         tracersPool,       &! structure holding tracers
         meshPool,          &! structure holding mesh variables
         verticalMeshPool,  &! structure holding vertical mesh variables
         tendPool,          &! structure holding tendencies
         tracersTendPool,   &! structure holding tracer tendencies
         forcingPool,       &! structure holding forcing variables
         scratchPool,       &! structure holding temporary variables
         swForcingPool,     &! structure holding short-wave forcing vars
         tracersIdealAgeFieldsPool     ! structure holding idealAge-related fields

      logical :: &
         activeTracersOnly   ! only compute tendencies for active tracers

      logical, pointer :: &
         config_use_tracerGroup  ! flag for using each tracer group

      integer :: &
         iCell, iEdge, k, &! loop iterators for cell, edge, vert loops
         nCells, nEdges,  &! number of cells or edges (incl halos)
         i,j,             &! generic loop iterators
         cell1, cell2,    &! neighbor cell addresses
         eoe,             &! index for edge on edge
         err,             &! local error flag
         splitImplicitStep, &! loop index for outer timestep loop
         oldBtrSubcycleTime,&! time index for old barotropic value
         newBtrSubcycleTime,&! time index for new barotropic value
         uPerpTime,       &! time index to use for uPerp calculation
         BtrCorIter,      &! loop index for barotropic coriolis cycle
         stage1_tend_time,&! time index for stage 1 tendencies
         edgeHaloComputeCounter, &! halo counters to reduce
         cellHaloComputeCounter   ! halo updates during cycling

      real (kind=RKIND) :: &
         normalThicknessFluxSum, &! sum of thickness flux in column
         thicknessSum,     &! sum of thicknesses in column
         thicknessSumCur,  &
         thicknessSumMid,  &
         thicknessSumLag,  &
         flux,             &! temp for computing flux for barotropic
         sshEdge,          &! sea surface height at edge
         sshEdgeCur,       &! 
         sshEdgeMid,       &! 
         sshEdgeLag,       &! 
         sshDiffCur,       &! sea surface height difference
         sshDiffLag,       & 
         CoriolisTerm,     &! temp for computing coriolis term (fuperp)
         normalVelocityCorrection, &! velocity correction
         temp,             &! temp for holding vars at new time
         temp_h,           &! temporary for phi
         temp_mask,        &! temporary mask (edgeMask)
         lat,              &! cell latitude
         sshCell1,         &! sea sfc height in neighboring cells
         sshCell2,         &
         sshCurArea,       &! temp for iterative solver
         sshLagArea,       &
         sshTendb1,        &
         sshTendb2,        &
         sshTendAx,        &
         fluxb1,           &
         fluxb2,           &
         fluxAx

      real (kind=RKIND), dimension(:), allocatable:: &
         uTemp

      real (kind=RKIND), dimension(:), allocatable :: &
         btrvel_temp

      ! State Array Pointers
      real (kind=RKIND), dimension(:), pointer :: &
         sshSubcycleCur,              &! subcycl ssh    at current time
         sshSubcycleNew,              &! subcycl ssh    at new     time
         sshSubcycleCurWithTides,     &! subcycl ssh    at current time
         sshSubcycleNewWithTides,     &! subcycl ssh    at new     time
         normalBarotropicVelocitySubcycleCur,&! barotropic vel subcyc
         normalBarotropicVelocitySubcycleNew,&! at current, new times
         sshCur,                      &! sea sfc height at current time
         sshNew,                      &! sea sfc height at new     time
         normalBarotropicVelocityCur, &! barotropic vel at current time
         normalBarotropicVelocityNew   ! barotropic vel at new     time

      real (kind=RKIND), dimension(:,:), pointer :: &
         normalBaroclinicVelocityCur, &! baroclinic vel at current time
         normalBaroclinicVelocityNew, &! baroclinic vel at new     time
         normalVelocityCur,           &! full velocity  at current time
         normalVelocityNew,           &! full velocity  at new     time
         layerThicknessCur,           &! layer thick    at current time
         layerThicknessNew,           &! layer thick    at new     time
         highFreqThicknessCur,        &! high frq thick at current time
         highFreqThicknessNew,        &! high frq thick at new     time
         lowFreqDivergenceCur,        &! low frq div    at current time
         lowFreqDivergenceNew,        &! low frq div    at new     time
         tracerGroupIdealAgeMask       ! mask for resetting surface ideal age

      type (field1DReal), pointer :: &
         effectiveDensityField         ! field pointer for halo update

      ! State/Tracer arrays, info
      real (kind=RKIND), dimension(:,:,:), pointer ::      &!
         tracersGroupCur,      &! old, new tracer arrays
         tracersGroupNew

      integer, pointer :: &
         startIndex, endIndex, &! start, end index for tracer groups
         indexSalinity          ! tracer index for salinity

      type (mpas_pool_iterator_type) :: &
         groupItr               ! iterator for tracer groups

      character (len=StrKIND) :: &
         modifiedGroupName,    &! constructed tracer group names
         configName             ! constructed config names for tracers

      ! Tendency Array Pointers

      real (kind=RKIND), dimension(:), pointer :: &
         sshTend                ! sea-surface height tendency

      real (kind=RKIND), dimension(:,:), pointer :: &
         normalVelocityTend,    &! normal velocity tendency
         highFreqThicknessTend, &! thickness tendency for high-freq iter
         lowFreqDivergenceTend, &! thickness tendency for low freq
         layerThicknessTend      ! main thickness tendency

      real (kind=RKIND), dimension(:,:,:), pointer :: &
         tracersGroupTend,      &! tendencies for tracer groups
         activeTracersTend       ! active tracer tendencies

      ! Forcing pool
      real (kind=RKIND), dimension(:), pointer :: tidalPotentialEta

      ! Semi-implicit variables
      real (kind=RKIND), dimension(2) :: &
         SIcst_allreduce_local2, &! array for local  summations
         SIcst_allreduce_global2  ! array for global summations
      real (kind=RKIND), dimension(9) :: &
         SIcst_allreduce_local9, &! array for local  summations
         SIcst_allreduce_global9,&! array for global summations
         SIcst_allreduce_temp9    !  temp for global summations
      integer          , dimension(9) :: &
         SIcst_allreduce_itemp9   !  temp for partition match mode
      real (kind=RKIND) ::  &
                                  !  temp scalars for the SI method
         SIcst_q0y0        , SIcst_y0y0        , SIcst_q0q0        , &
         SIcst_q0y0_global , SIcst_y0y0_global , SIcst_q0q0_global , &
         SIcst_r00r0       , SIcst_r00w0       , SIcst_r00w1       , &
         SIcst_r00r0_global, SIcst_r00w0_global, SIcst_r00w1_global, &
         SIcst_r00q0       , SIcst_r00t0       , SIcst_r00v0       , &
         SIcst_r00q0_global, SIcst_r00t0_global, SIcst_r00v0_global, &
         SIcst_r00y0       , SIcst_r00s0       , SIcst_r00z0       , &
         SIcst_r00y0_global, SIcst_r00s0_global, SIcst_r00z0_global, &
         SIcst_alpha0      , SIcst_beta0       , &
         SIcst_omega0      , SIcst_rho0        , SIcst_rho1        , &
         SIcst_gamma1,       resid

      integer ::     &
         iter,       &! Number of solver iterations
         siLargeIter  ! Index of the large btr system iteration

      ! These are public variables used from the diagnostics module
      ! indexSurfaceVelocityZonal, indexSurfaceVelocityMeridional
      ! indexSSHGradientZonal, indexSSHGradientMeridional
      ! barotropicForcing, barotropicThicknessFlux
      ! layerThickEdge, normalTransportVelocity, normalGMBolusVelocity
      ! vertAleTransportTop
      ! velocityX, velocityY, velocityZ
      ! velocityZonal, velocityMeridional
      ! gradSSH, gradSSHX, gradSSHY, gradSSHZ
      ! gradSSHZonal, gradSSHMeridional
      ! surfaceVelocity, SSHGradient
      ! temperatureShortWaveTendency
      ! activeTracerHorizontalAdvectionTendency
      ! activeTracerVerticalAdvectionTendency
      ! activeTracerSurfaceFluxTendency
      ! activeTracerNonLocalTendency
      ! activeTracerHorMixTendency
      ! activeTracerHorizontalAdvectionEdgeFlux

      ! End preamble
      !-----------------------------------------------------------------
      ! Begin code

      call mpas_timer_start("si timestep")

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      !  Prep variables before first iteration
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      call mpas_timer_start("si prep")

      !*** Retrieve model state, pools
      !*** No longer support sub-blocks so this retrieves the only block

      block => domain%blocklist
      call mpas_pool_get_subpool(block%structs, 'mesh', meshPool)
      call mpas_pool_get_subpool(block%structs, 'verticalMesh', &
                                                 verticalMeshPool)
      call mpas_pool_get_subpool(block%structs, 'state', &
                                                 statePool)
      call mpas_pool_get_subpool(block%structs, 'forcing', &
                                                 forcingPool)
      call mpas_pool_get_subpool(block%structs, 'shortwave', &
                                                 swForcingPool)
      call mpas_pool_get_subpool(block%structs, 'tend', &
                                                 tendPool)
      call mpas_pool_get_subpool(block%structs, 'scratch', &
                                                 scratchPool)
      call mpas_pool_get_subpool(statePool, 'tracers', &
                                             tracersPool)
      call mpas_pool_get_subpool(tendPool,  'tracersTend', &
                                             tracersTendPool)

      !*** Retrieve state variables at two time levels

      call mpas_pool_get_array(statePool, 'normalBaroclinicVelocity', &
                                           normalBaroclinicVelocityCur, 1)
      call mpas_pool_get_array(statePool, 'normalBarotropicVelocity', &
                                           normalBarotropicVelocityCur, 1)
      call mpas_pool_get_array(statePool, 'normalBarotropicVelocitySubcycle', &
                                           normalBarotropicVelocitySubcycleCur, 1)
      call mpas_pool_get_array(statePool, 'normalVelocity', &
                                           normalVelocityCur, 1)

      call mpas_pool_get_array(statePool, 'normalBaroclinicVelocity', &
                                           normalBaroclinicVelocityNew, 2)
      call mpas_pool_get_array(statePool, 'normalBarotropicVelocity', &
                                           normalBarotropicVelocityNew, 2)
      call mpas_pool_get_array(statePool, 'normalBarotropicVelocitySubcycle', &
                                           normalBarotropicVelocitySubcycleNew, 2)
      call mpas_pool_get_array(statePool, 'normalVelocity', &
                                           normalVelocityNew, 2)

      call mpas_pool_get_array(statePool, 'ssh', sshCur, 1)
      call mpas_pool_get_array(statePool, 'ssh', sshNew, 2)

      call mpas_pool_get_array(statePool, 'sshSubcycle', sshSubcycleCur, 1)
      call mpas_pool_get_array(statePool, 'sshSubcycle', sshSubcycleNew, 2)

      call mpas_pool_get_array(statePool, 'layerThickness', &
                                           layerThicknessCur, 1)
      call mpas_pool_get_array(statePool, 'layerThickness', &
                                           layerThicknessNew, 2)

      call mpas_pool_get_array(statePool, 'highFreqThickness', &
                                           highFreqThicknessCur, 1)
      call mpas_pool_get_array(statePool, 'highFreqThickness', &
                                           highFreqThicknessNew, 2)

      call mpas_pool_get_array(statePool, 'lowFreqDivergence', &
                                           lowFreqDivergenceCur, 1)
      call mpas_pool_get_array(statePool, 'lowFreqDivergence', &
                                           lowFreqDivergenceNew, 2)

      call mpas_pool_get_dimension(tracersPool, 'index_salinity', &
                                                 indexSalinity)

      !*** Retrieve tendency variables

      call mpas_pool_get_array(tendPool, 'highFreqThickness', &
                                          highFreqThicknessTend)
      call mpas_pool_get_array(tendPool, 'normalVelocity', &
                                          normalVelocityTend)
      call mpas_pool_get_array(tendPool, 'ssh', &
                                          sshTend)
      call mpas_pool_get_array(tendPool, 'layerThickness', &
                                          layerThicknessTend)
      call mpas_pool_get_array(tendPool, 'normalVelocity', &
                                          normalVelocityTend)
      call mpas_pool_get_array(tendPool, 'highFreqThickness', &
                                          highFreqThicknessTend)
      call mpas_pool_get_array(tendPool, 'lowFreqDivergence', &
                                          lowFreqDivergenceTend)

      ! Initialize * variables that are used to compute baroclinic
      ! tendencies below.

      ! The baroclinic velocity needs be recomputed at the beginning
      ! of a timestep because the implicit vertical mixing is
      ! conducted on the total u.  We keep normalBarotropicVelocity
      ! from the previous timestep.
      ! Note that normalBaroclinicVelocity may now include a
      ! barotropic component, because the weights layerThickness
      ! have changed.  That is OK, because the barotropicForcing
      ! variable subtracts out the barotropic component from the
      ! baroclinic.

      !$omp parallel
      !$omp do schedule(runtime) private(k)
      do iEdge = 1,nEdgesAll
      do k = 1,nVertLevels

         normalBaroclinicVelocityCur(k,iEdge) = &
                                 normalVelocityCur(k,iEdge) - &
                         normalBarotropicVelocityCur(iEdge)

         normalVelocityNew(k,iEdge) = normalVelocityCur(k,iEdge)

         normalBaroclinicVelocityNew(k,iEdge) = &
         normalBaroclinicVelocityCur(k,iEdge)
      end do
      end do
      !$omp end do

      !$omp do schedule(runtime) private(k)
      do iCell = 1, nCellsAll
         sshNew(iCell)         = sshCur(iCell)
         sshSubcycleCur(iCell) = sshCur(iCell)
         sshSubcycleNew(iCell) = sshCur(iCell)
         do k = minLevelCell(iCell), maxLevelCell(iCell)
            layerThicknessNew(k,iCell) = layerThicknessCur(k,iCell)
         end do
      end do
      !$omp end do
      !$omp end parallel

      call mpas_pool_begin_iteration(tracersPool)
      do while ( mpas_pool_get_next_member(tracersPool, groupItr))
         if ( groupItr % memberType == MPAS_POOL_FIELD ) then
            call mpas_pool_get_array(tracersPool, groupItr%memberName,&
                                     tracersGroupCur, 1)
            call mpas_pool_get_array(tracersPool, groupItr%memberName,&
                                     tracersGroupNew, 2)

            if ( associated(tracersGroupCur) .and. &
                 associated(tracersGroupNew) ) then

               !$omp parallel
               !$omp do schedule(runtime) private(k)
               do iCell = 1, nCellsAll
               do k = minLevelCell(iCell), maxLevelCell(iCell)
                  tracersGroupNew(:,k,iCell) = &
                  tracersGroupCur(:,k,iCell)
               end do
               end do
               !$omp end do
               !$omp end parallel
            end if
         end if
      end do

      if (associated(highFreqThicknessNew)) then
         !$omp parallel
         !$omp do schedule(runtime) private(k)
         do iCell = 1, nCellsAll
         do k = 1,nVertLevels
            highFreqThicknessNew(k,iCell) = &
            highFreqThicknessCur(k,iCell)
         end do
         end do
         !$omp end do
         !$omp end parallel
      end if

      if (associated(lowFreqDivergenceNew)) then
         !$omp parallel
         !$omp do schedule(runtime) private(k)
         do iCell = 1, nCellsAll
         do k = 1,nVertLevels
            lowFreqDivergenceNew(k,iCell) = &
            lowFreqDivergenceCur(k,iCell)
         end do
         end do
         !$omp end do
         !$omp end parallel
      endif

      call mpas_timer_stop("si prep")

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ! BEGIN large outer timestep iteration loop
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      do splitImplicitStep = 1, numTSIterations

         if (config_disable_thick_all_tend .and. &
             config_disable_vel_all_tend .and. &
             config_disable_tr_all_tend) then
            exit ! don't compute in loop meant to update velocity,
                 ! thickness, and tracers
         end if

         call mpas_timer_start('si loop')

         stage1_tend_time = min(splitImplicitStep,2)

         ! ---  update halos for diagnostic ocean boundary layer depth
         if (config_use_cvmix_kpp) then
            call mpas_timer_start("si halo diag obd")
            call mpas_dmpar_field_halo_exch(domain, 'boundaryLayerDepth')
            call mpas_timer_stop("si halo diag obd")
         end if

         ! ---  update halos for diagnostic variables
         call mpas_timer_start("si halo diag")

         call mpas_dmpar_field_halo_exch(domain, &
                                 'normalizedRelativeVorticityEdge')

         if (config_mom_del4 > 0.0_RKIND) then
           call mpas_dmpar_field_halo_exch(domain, 'divergence')
           call mpas_dmpar_field_halo_exch(domain, 'relativeVorticity')
         end if
         call mpas_timer_stop("si halo diag")

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !  Stage 1: Baroclinic velocity (3D) prediction, explicit with
         !           long timestep
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         if (config_use_freq_filtered_thickness) then

            call mpas_timer_start("si freq-filtered-thick computations")

            call ocn_tend_freq_filtered_thickness(tendPool, statePool, &
                                                  stage1_tend_time)

            call mpas_timer_stop("si freq-filtered-thick computations")

            call mpas_timer_start("si freq-filtered-thick halo update")

            call mpas_dmpar_field_halo_exch(domain,'tendHighFreqThickness')
            call mpas_dmpar_field_halo_exch(domain,'tendLowFreqDivergence')

            call mpas_timer_stop("si freq-filtered-thick halo update")

            !$omp parallel
            !$omp do schedule(runtime) private(k)
            do iCell = 1, nCellsAll
            do k = minLevelCell(iCell), maxLevelCell(iCell)
               ! this is h^{hf}_{n+1}
               highFreqThicknessNew(k,iCell) = &
               highFreqThicknessCur(k,iCell) + dt* &
               highFreqThicknessTend(k,iCell)
            end do
            end do
            !$omp end do
            !$omp end parallel

         endif ! freq filtered thickness

         ! compute velocity tendencies, T(u*,w*,p*)
         call mpas_timer_start("si bcl vel")
         call mpas_timer_start('si bcl vel tend')

         call mpas_pool_get_array(statePool, 'normalVelocity', &
                           normalVelocityCur, stage1_tend_time)

         ! compute vertAleTransportTop.  Use u (rather than &
         ! normalTransportVelocity) for momentum advection.
         ! Use the most recent time level available.

#ifdef MPAS_OPENACC
         !$acc enter data copyin(layerThicknessCur, normalVelocityCur, sshCur)
         !$acc update device(layerThickEdge)
#endif
         if (associated(highFreqThicknessNew)) then
#ifdef MPAS_OPENACC
            !$acc enter data copyin(highFreqThicknessNew)
#endif
            call ocn_vert_transport_velocity_top(meshPool, &
                 verticalMeshPool, layerThicknessCur, &
                 layerThickEdge, normalVelocityCur, sshCur, dt, &
                 vertAleTransportTop, err, highFreqThicknessNew)
#ifdef MPAS_OPENACC
            !$acc exit data delete(highFreqThicknessNew)
#endif
         else
            call ocn_vert_transport_velocity_top(meshPool, &
                 verticalMeshPool, layerThicknessCur, &
                 layerThickEdge, normalVelocityCur, sshCur, dt, &
                 vertAleTransportTop, err)
         endif
#ifdef MPAS_OPENACC
         !$acc exit data delete(layerThicknessCur, normalVelocityCur, sshCur)
         !$acc update host(vertAleTransportTop)
#endif

         call ocn_tend_vel(tendPool, statePool, forcingPool, &
                           stage1_tend_time, dt)

         call mpas_timer_stop('si bcl vel tend')

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! BEGIN baroclinic iterations on linear Coriolis term
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         do j=1,numClinicIterations(splitImplicitStep)

            call mpas_timer_start('bcl iters on linear Coriolis')

            ! Put f*normalBaroclinicVelocity^{perp} in
            ! normalVelocityNew as a work variable
            call ocn_fuperp(statePool, meshPool, 2)

            !TODO: look at loop optimizations here
            ! Only need to loop over owned cells, since there is a halo
            ! exchange immediately after this computation.

            allocate(uTemp(nVertLevels))

            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(k, cell1, cell2, uTemp, &
            !$omp         normalThicknessFluxSum, thicknessSum)
            do iEdge = 1, nEdgesOwned
               cell1 = cellsOnEdge(1,iEdge)
               cell2 = cellsOnEdge(2,iEdge)
               ! could put this after with 
               ! uTemp(maxleveledgetop+1:nvertlevels)=0
               uTemp = 0.0_RKIND
               do k = minLevelEdgeBot(iEdge), maxLevelEdgeTop(iEdge)

                  ! normalBaroclinicVelocityNew =
                  ! normalBaroclinicVelocityOld +
                  !                dt*(-f*normalBaroclinicVelocityPerp
                  !                    + T(u*,w*,p*) + g*grad(SSH*) )
                  ! Here uNew is a work variable containing
                  !  -fEdge(iEdge)*normalBaroclinicVelocityPerp(k,iEdge)
                  uTemp(k) = normalBaroclinicVelocityCur(k,iEdge) &
                           + dt * (normalVelocityTend(k,iEdge) &
                           + normalVelocityNew(k,iEdge) &
                           + gravity * &
                             (sshNew(cell2) - sshNew(cell1)) &
                             /dcEdge(iEdge) )
               enddo ! vertical

               ! thicknessSum is initialized outside the loop because
               ! on land boundaries maxLevelEdgeTop=0, but we want to
               ! initialize thicknessSum with a nonzero value to avoid
               ! a NaN.
               normalThicknessFluxSum =                          &
                    layerThickEdge(minLevelEdgeBot(iEdge),iEdge) &
                  * uTemp(minLevelEdgeBot(iEdge))
               thicknessSum = &
                    layerThickEdge(minLevelEdgeBot(iEdge),iEdge)

               do k = minLevelEdgeBot(iEdge)+1, maxLevelEdgeTop(iEdge)
                  normalThicknessFluxSum = normalThicknessFluxSum + &
                                 layerThickEdge(k,iEdge)*uTemp(k)
                  thicknessSum = thicknessSum + &
                                 layerThickEdge(k,iEdge)
               enddo
               barotropicForcing(iEdge) = &
                              normalThicknessFluxSum/thicknessSum/dt

               do k = minLevelEdgeBot(iEdge), maxLevelEdgeTop(iEdge)
                  ! These two steps are together here:
                  !{\bf u}'_{k,n+1} =
                  !    {\bf u}'_{k,n} - \Delta t {\overline {\bf G}}
                  !{\bf u}'_{k,n+1/2} = \frac{1}{2}\left(
                  !        {\bf u}^{'}_{k,n} +{\bf u}'_{k,n+1}\right)
                  ! so that normalBaroclinicVelocityNew is at time n+1/2
                  normalBaroclinicVelocityNew(k,iEdge) = 0.5_RKIND*( &
                  normalBaroclinicVelocityCur(k,iEdge) + uTemp(k) - &
                         dt * barotropicForcing(iEdge))
               enddo

            enddo ! iEdge
            !$omp end do
            !$omp end parallel

            deallocate(uTemp)

            call mpas_timer_start("si halo normalBaroclinicVelocity")
            call mpas_dmpar_field_halo_exch(domain, &
                              'normalBaroclinicVelocity', timeLevel=2)
            call mpas_timer_stop("si halo normalBaroclinicVelocity")

            call mpas_timer_stop('bcl iters on linear Coriolis')

         end do  ! do j=1,config_n_bcl_iter

         call mpas_timer_start('si halo barotropicForcing')
         call mpas_dmpar_field_halo_exch(domain, 'barotropicForcing')
         call mpas_timer_stop('si halo barotropicForcing')

         call mpas_timer_stop("si bcl vel")
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! END baroclinic iterations on linear Coriolis term
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! Stage 2: Barotropic velocity (2D) prediction, split-implicit
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !
         ! The split-implicit barotropic mode solver
         !    - uses the preconditioned communication-avoiding
         !      (single-global synchronization) BiCGStab method 
         !      as a linear iterative solver
         !      (Kang et al., in preparation)
         !                    
         !    - solves the nonlinear barotropic system but deals with
         !      it as the linear system by introducing the outer and                     
         !      inner solver iteration (the solver matrix is updated                    
         !      for every time step and inner solver iteration.)                    
         !                    
         !    - works with 'ras', 'block_jacobi', 'jacobi', 'none'
         !      preconditioners
         !                    
         !    - consists of seven substages                    
         !         :Stage 2.1. Initialization and preparation of vars
         !                     before outer iterations
         !          Stage 2.2. Computation of the initial residual
         !          Stage 2.3. The outer solver iteration
         !          Stage 2.4. The barotropic velocity update
         !          Stage 2.5. Re-computation of the initial residual
         !                     using lagged values
         !          Stage 2.6. Main (inner) solver iterations to 
         !                     obtain SSH at time (n+1) 
         !          Stage 2.7. The barotropic velocity update
         !
         !    - recommends to set 'config_n_ts_iter=2'
         !         :Time line of variables
         !
         !          Start of large outer time step iteration loop
         !             splitImplicitStep=1
         !             |  SSH and BtrVel at time (n)
         !             |  |  -> Advancing the barotropic system
         !             |  |     -> SSH and BtrVel at time (n+1)
         !             |  |        -> Averaging between time (n) 
         !             |  |                         and time (n+1)
         !             |  SSH and BtrVel at time (n+1/2)
         !             |
         !             splitImplicitStep=2
         !                SSH and BtrVel at time (n+1/2)
         !                |  -> Advancing the barotropic system
         !                |     -> SSH and BtrVel at time (n+3/2)
         !                |        -> Averaging between time (n+1/2)
         !                |                         and time (n+3/2)
         !                SSH and BtrVel at time (n+1)
         !
         !
         ! Reference: Kang et al. (2021): A scalable semi-implicit 
         !            barotropic mode solver for the MPAS-Ocean, JAMES
         !
         !
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! Stage 2.1 : Preparation of variables before outer iterations
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         call mpas_timer_start("si btr vel")

         cellHaloComputeCounter = config_num_halos
         edgeHaloComputeCounter = config_num_halos + 1

         nCells = nCellsHalo(cellHaloComputeCounter-1)
         nEdges = nEdgesHalo(edgeHaloComputeCounter-1)

         if (config_filter_btr_mode) then
            !$omp parallel
            !$omp do schedule(runtime)
            do iEdge = 1, nEdges
               barotropicForcing(iEdge) = 0.0_RKIND
            end do
            !$omp end do
            !$omp end parallel
         endif

         !-------------------------------------------------------------!
         ! BEGIN Large barotropic system iteration loop
         !-------------------------------------------------------------!
         do siLargeIter = 1, nSiLargeIter
         !-------------------------------------------------------------!

            ! Initialize variables for barotropic subcycling
            call mpas_timer_start('btr vel si init')
   
            if ( splitImplicitStep == 2 .or. siLargeIter > 1 ) then
               ! Here sshSubcycleNew and normalBarotropicVelocityCur
               ! are at time n+1/2.
   
               !$omp parallel
               !$omp do schedule(runtime)
               do iCell = 1,nCellsAll
                  sshSubcycleNew(iCell) = &
                     0.5_RKIND*( sshSubcycleNew(iCell) &
                                +sshCur(iCell) )
                  sshSubcycleCur(iCell) = sshSubcycleNew(iCell)
               end do
               !$omp end do
   
               !$omp do schedule(runtime)
               do iEdge = 1,nEdgesAll
                  normalBarotropicVelocityCur(iEdge) = &
                     normalBarotropicVelocitySubcycleCur(iEdge)
               end do
               !$omp end do
               !$omp end parallel
            endif ! splitImplicitStep
   
            !$omp parallel
            !$omp do schedule(runtime) private(CoriolisTerm, i, eoe)
            do iEdge = 1, nEdgesAll
               ! Compute the barotropic Coriolis term, -f*uPerp
               CoriolisTerm = 0.d0
               do i = 1, nEdgesOnEdge(iEdge)
                  eoe = edgesOnEdge(i,iEdge)
                  CoriolisTerm = CoriolisTerm + weightsOnEdge(i,iEdge) &
                               * normalBarotropicVelocityCur(eoe)      &
                               * fEdge(eoe)
               end do ! i
                  barotropicCoriolisTerm(iEdge) = CoriolisTerm
            end do ! iEdge
            !$omp end do
            !$omp end parallel
   
            ! Subtract tidal potential from ssh, if needed
            ! Subtract the tidal potential from the current
            !    subcycle ssh and store and a work array.
            ! Then point sshSubcycleCur to the work array so the
            ! tidal potential terms are included in the grad
            ! operator inside the edge loop.
            if (config_use_tidal_potential_forcing) then
   
               call mpas_pool_get_array(forcingPool,            &
                                     'sshSubcycleCurWithTides', &
                                      sshSubcycleCurWithTides)
               call mpas_pool_get_array(forcingPool,        &
                                       'tidalPotentialEta', &
                                        tidalPotentialEta)
   
               !$omp parallel
               !$omp do schedule(runtime)
               do iCell = 1, nCellsAll
                 sshSubcycleCurWithTides(iCell) = sshSubcycleCur(iCell) &
                            - tidalPotentialEta(iCell)                  &
                            - config_self_attraction_and_loading_beta   &
                            * sshSubcycleCur(iCell)
               end do
               !$omp end do
               !$omp end parallel
   
               call mpas_pool_get_array(forcingPool,            &
                                     'sshSubcycleCurWithTides', &
                                      sshSubcycleNew)
   
               !$omp parallel
               !$omp do schedule(runtime)
               do iCell = 1,nCellsAll
                  sshSubcycleCur(iCell) = sshSubcycleNew(iCell)
               end do
               !$omp end do
               !$omp end parallel
   
            endif !config_use_tidal_potential_forcing
   
            call mpas_timer_stop('btr vel si init')
   
   
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Stage 2.2 : Compution of the initial residual
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   
            call mpas_timer_start("si btr residual")
   
            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(sshTendb1,sshTendb2,sshTendAx,iEdge, &
            !$omp         cell1,cell2,sshEdgeCur,thicknessSumCur, &
            !$omp         sshDiffCur,fluxb1,fluxb2,fluxAx,sshCurArea)
            do iCell = 1, nPrecVec
               sshTendb1 = 0.0_RKIND
               sshTendb2 = 0.0_RKIND
               sshTendAx = 0.0_RKIND
   
               do i = 1, nEdgesOnCell(iCell)
                  iEdge = edgesOnCell(i, iCell)
   
                  cell1 = cellsOnEdge(1, iEdge)
                  cell2 = cellsOnEdge(2, iEdge)
   
                  ! Interpolation sshEdge
                  sshEdgeCur = 0.5_RKIND * ( sshSubcycleCur(cell1)  &
                                           + sshSubcycleCur(cell2) )
   
                  ! method 1, matches method 0 without pbcs, 
                  ! works with pbcs.
                  thicknessSumCur = si_ismf * sshEdgeCur    &
                                  + min(bottomDepth(cell1), &
                                        bottomDepth(cell2))
   
                  ! nabla (ssh^0)
                  sshDiffCur = (  sshSubcycleCur(cell2)   &
                                - sshSubcycleCur(cell1) ) &
                               /  dcEdge(iEdge)
   
                  fluxb1 = thicknessSumCur &
                         * normalBarotropicVelocityCur(iEdge)
                  fluxb2 = thicknessSumCur                    &
                         * (alpha2*gravity*sshDiffCur         &
                         + (-barotropicCoriolisTerm(iEdge)    &
                            -barotropicForcing(iEdge)))
                  fluxAx = thicknessSumCur * sshDiffCur
   
                  sshTendb1 = sshTendb1 + edgeSignOnCell(i, iCell) &
                                        * fluxb1 * dvEdge(iEdge)
                  sshTendb2 = sshTendb2 + edgeSignOnCell(i, iCell) &
                                        * fluxb2 * dvEdge(iEdge)
                  sshTendAx = sshTendAx + edgeSignOnCell(i, iCell) &
                                        * fluxAx * dvEdge(iEdge)
               end do ! i
   
               sshTendb1  = R1_alpha1s_g_dt  * sshTendb1
               sshTendb2  = R1_alpha1_g      * sshTendb2
               sshCurArea = R1_alpha1s_g_dts * sshSubcycleCur(iCell) &
                                             * areaCell(iCell)
   
               SIvec_r0(iCell) = (-sshCurArea - sshTendb1 + sshTendb2) &
                                -(-sshCurArea - sshTendAx)
               SIvec_r00(iCell) = SIvec_r0(iCell)
   
            end do ! iCell
            !$omp end do
            !$omp end parallel
   
            ! Preconditioning --------------------------------------------!
   
            if ( trim(config_btr_si_preconditioner) == 'ras' ) then
               ! RAS preconditioning: Use BLAS for the symmetric 
               !                      matrix-vector multiplication
#ifdef USE_LAPACK
               call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                          SIvec_r0(1:nPrecVec) , 1, 0.0_RKIND,  &
                          SIvec_rh0(1:nPrecVec), 1)
#endif
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                              'block_jacobi' ) then
               ! Block-Jacobi preconditioning: Use BLAS for the symmetric 
               !                               matrix-vector multiplication
#ifdef USE_LAPACK
               call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                          SIvec_r0(1:nPrecVec) , 1, 0.0_RKIND,  &
                          SIvec_rh0(1:nPrecVec), 1)
#endif
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                                    'jacobi' ) then
               ! Jacobi preconditioning
               SIvec_rh0(1:nPrecVec) = SIvec_r0(1:nPrecVec) &
                                     * prec_ivmat(1:nPrecVec)
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                                      'none' ) then
               ! No preconditioning
               SIvec_rh0(1:nPrecVec) = SIvec_r0(1:nPrecVec)
            end if
   
            call mpas_timer_start("si halo r0")
            call mpas_dmpar_field_halo_exch(domain, 'SIvec_rh0')
            call mpas_timer_stop("si halo r0")
   
            ! SpMV -------------------------------------------------------!
   
            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(sshTendAx,iEdge,cell1,cell2,sshEdgeCur, &
            !$omp         thicknessSumCur,sshDiffCur,fluxAx,sshCurArea )
            do iCell = 1, nPrecVec
   
               sshTendAx = 0.0_RKIND
   
               do i = 1, nEdgesOnCell(iCell)
                  iEdge = edgesOnCell(i, iCell)
   
                  cell1 = cellsOnEdge(1, iEdge)
                  cell2 = cellsOnEdge(2, iEdge)
   
                  ! Interpolation sshEdge
                  sshEdgeCur = 0.5_RKIND * (  sshSubcycleCur(cell1) &
                                            + sshSubcycleCur(cell2))
   
                  ! method 1, matches method 0 without pbcs,
                  ! works with pbcs.
                  thicknessSumCur = si_ismf * sshEdgeCur    &
                                  + min(bottomDepth(cell1), &
                                        bottomDepth(cell2))
   
                  ! nabla (ssh^0)
                  sshDiffCur = (SIvec_rh0(cell2)- SIvec_rh0(cell1)) &
                             / dcEdge(iEdge)
                      fluxAx = thicknessSumCur * sshDiffCur
                   sshTendAx = sshTendAx + edgeSignOnCell(i, iCell) &
                             * fluxAx * dvEdge(iEdge)
               end do ! i
   
               sshCurArea = (1.0_RKIND/(gravity*dt_si**2.0*alpha1**2.0)) &
                          * SIvec_rh0(iCell) * areaCell(iCell)
   
               SIvec_w0(iCell) = -sshCurArea - sshTendAx
   
            end do ! iCell
            !$omp end do
            !$omp end parallel
   
            ! Preconditioning --------------------------------------------!
   
            if ( trim(config_btr_si_preconditioner) == 'ras' ) then
               ! RAS preconditioning: Use BLAS
               ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
               call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                          SIvec_w0(1:nPrecVec) , 1, 0.0_RKIND,  &
                          SIvec_wh0(1:nPrecVec), 1)
#endif
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                              'block_jacobi' ) then
               ! Block-Jacobi preconditioning: Use BLAS 
               ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
               call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                          SIvec_w0(1:nPrecVec), 1, 0.0_RKIND,   &
                          SIvec_wh0(1:nPrecVec),1)
#endif
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                                    'jacobi' ) then
               ! Jacobi preconditioning
               SIvec_wh0(1:nPrecVec) = SIvec_w0(1:nPrecVec) &
                                     * prec_ivmat(1:nPrecVec)
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                                      'none' ) then
               ! No preconditioning
               SIvec_wh0(1:nPrecVec) = SIvec_w0(1:nPrecVec)
            end if
   
            call mpas_timer_start("si halo r0")
            call mpas_dmpar_field_halo_exch(domain, 'SIvec_wh0')
            call mpas_timer_stop("si halo r0")
   
            ! SpMV -------------------------------------------------------!
   
            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(sshTendAx,iEdge,cell1,cell2,sshEdgeCur, &
            !$omp         thicknessSumCur,sshDiffCur,fluxAx,sshCurArea )
            do iCell = 1, nPrecVec
   
               sshTendAx = 0.0_RKIND
   
               do i = 1, nEdgesOnCell(iCell)
   
                  iEdge = edgesOnCell(i, iCell)
   
                  cell1 = cellsOnEdge(1, iEdge)
                  cell2 = cellsOnEdge(2, iEdge)
   
                  ! Interpolation sshEdge
                  sshEdgeCur = 0.5_RKIND * (  sshSubcycleCur(cell1) &
                                            + sshSubcycleCur(cell2))
   
                  ! method 1, matches method 0 without pbcs,
                  ! works with pbcs.
                  thicknessSumCur = si_ismf * sshEdgeCur    &
                                  + min(bottomDepth(cell1), &
                                        bottomDepth(cell2))
   
                  ! nabla (ssh^0)
                  sshDiffCur = (SIvec_wh0(cell2)- SIvec_wh0(cell1)) &
                             / dcEdge(iEdge)
   
                  fluxAx = thicknessSumCur * sshDiffCur
   
                  sshTendAx = sshTendAx + edgeSignOnCell(i, iCell) &
                            * fluxAx * dvEdge(iEdge)
               end do ! i
   
               sshCurArea = R1_alpha1s_g_dts * SIvec_wh0(iCell) &
                          * areaCell(iCell)
   
               SIvec_t0(iCell) = -sshCurArea - sshTendAx
   
               SIvec_ph0(iCell) = 0.0_RKIND
               SIvec_sh0(iCell) = 0.0_RKIND
               SIvec_z0(iCell)  = 0.0_RKIND
               SIvec_zh0(iCell) = 0.0_RKIND
               SIvec_v0(iCell)  = 0.0_RKIND
               SIvec_s0(iCell)  = 0.0_RKIND
   
            end do ! iCell
            !$omp end do
            !$omp end parallel
   
            ! Reduction --------------------------------------------------!
            SIcst_r00r0 = 0.0_RKIND
            SIcst_r00w0 = 0.0_RKIND
   
            do iCell = 1, nCellsOwned
               SIcst_r00r0 = SIcst_r00r0 + SIvec_r00(iCell) &
                                         * SIvec_r0(iCell)
               SIcst_r00w0 = SIcst_r00w0 + SIvec_r00(iCell) &
                                         * SIvec_w0(iCell)
            end do ! iCell
   
            SIcst_allreduce_local2(1) = SIcst_r00r0
            SIcst_allreduce_local2(2) = SIcst_r00w0
   
            ! Global sum across CPUs
            call mpas_timer_start("si reduction r0")
            call mpas_dmpar_sum_real_array(domain % dminfo, 2,      &
                                           SIcst_allreduce_local2,  &
                                           SIcst_allreduce_global2)
            call mpas_timer_stop ("si reduction r0")
   
            if ( config_btr_si_partition_match_mode .and. ncpus > 1) then
               SIcst_allreduce_temp9(:)    = 0.0_RKIND
               SIcst_allreduce_itemp9(:)   = 0.0_RKIND
   
               SIcst_allreduce_itemp9(1:2) = &
                                    exponent(SIcst_allreduce_global2(:))
               SIcst_allreduce_temp9(1:2)  = &
                                    fraction(SIcst_allreduce_global2(:))
               SIcst_allreduce_temp9(1:2)  = &
                                    anint(SIcst_allreduce_temp9(1:2) &
                                           * 1.0e+4_RKIND  ) &
                                           / 1.0e+4_RKIND
   
               SIcst_allreduce_global2(:) =          &
                          SIcst_allreduce_temp9(1:2) &
                        * 2.0_RKIND ** (SIcst_allreduce_itemp9(1:2))
            endif
   
            SIcst_r00r0_global = SIcst_allreduce_global2(1)
            SIcst_r00w0_global = SIcst_allreduce_global2(2)
   
            SIcst_rho0   = SIcst_r00r0_global
            SIcst_alpha0 = SIcst_rho0 / SIcst_r00w0_global
            SIcst_beta0  = 0.0_RKIND
            SIcst_omega0 = 0.0_RKIND
   
            call mpas_timer_stop("si btr residual")
   
   
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Stage 2.3 : Outer iterations 
            !             - lagged values are sufficiently up to date
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   
            call mpas_timer_start("si btr iteration")
   
            iter = 0
            resid = (tolerance_outer+100.0)**2.0
   
            !-------------------------------------------------------------!
            do while ( dsqrt(resid) > tolerance_outer )
            !-------------------------------------------------------------!
   
               iter = iter + 1
   
               !$omp parallel
               !$omp do schedule(runtime)
               do iCell = 1, nPrecVec
                  SIvec_ph1(iCell) =  SIvec_rh0(iCell) + SIcst_beta0      &
                                   * (SIvec_ph0(iCell) - SIcst_omega0     &
                                                       * SIvec_sh0(iCell))
   
                  SIvec_s1(iCell)  =  SIvec_w0(iCell)  + SIcst_beta0      &
                                   * (SIvec_s0(iCell)  - SIcst_omega0     &
                                                       * SIvec_z0(iCell))
   
                  SIvec_sh1(iCell) =  SIvec_wh0(iCell) + SIcst_beta0      &
                                   * (SIvec_sh0(iCell) - SIcst_omega0     &
                                                       * SIvec_zh0(iCell))
   
                  SIvec_z1(iCell)  =  SIvec_t0(iCell)  + SIcst_beta0      &
                                   * (SIvec_z0(iCell)  - SIcst_omega0     &
                                                       * SIvec_v0(iCell))
   
                  SIvec_q0(iCell)  =  SIvec_r0(iCell)  - SIcst_alpha0     &
                                                       * SIvec_s1(iCell)
   
                  SIvec_qh0(iCell) =  SIvec_rh0(iCell) - SIcst_alpha0     &
                                                       * SIvec_sh1(iCell)
   
                  SIvec_y0(iCell)  =  SIvec_w0(iCell)  - SIcst_alpha0     &
                                                       * SIvec_z1(iCell)
               end do ! iCell
               !$omp end do
               !$omp end parallel
   
               ! Preconditioning -----------------------------------------!
   
               if ( trim(config_btr_si_preconditioner) == 'ras' ) then
                  ! RAS preconditioning: Use BLAS 
                  ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
                  call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                             SIvec_z1(1:nPrecVec), 1, 0.0_RKIND,   &
                             SIvec_zh1(1:nPrecVec),1)
#endif
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                 'block_jacobi' ) then
                  ! Block-Jacobi preconditioning: Use BLAS 
                  ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
                  call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                             SIvec_z1(1:nPrecVec), 1, 0.0_RKIND,   &
                             SIvec_zh1(1:nPrecVec),1)
#endif
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                       'jacobi' ) then
                  ! Jacobi preconditioning
                  SIvec_zh1(1:nPrecVec) = SIvec_z1(1:nPrecVec) &
                                        * prec_ivmat(1:nPrecVec)
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                         'none' ) then
                  ! No preconditioning
                  SIvec_zh1(1:nPrecVec) = SIvec_z1(1:nPrecVec)
               end if
   
               call mpas_timer_start("si halo iter")
               call mpas_dmpar_field_halo_exch(domain, 'SIvec_zh1')
               call mpas_timer_stop("si halo iter")
   
   
               ! SpMV ----------------------------------------------------!
   
               !$omp parallel
               !$omp do schedule(runtime) &
               !$omp private(sshTendAx,iEdge,cell1,cell2,sshEdgeLag, &
               !$omp         thicknessSumLag,sshDiffLag,fluxAx,sshLagArea )
               do iCell = 1, nPrecVec
                  sshTendAx = 0.0_RKIND
   
                  do i = 1, nEdgesOnCell(iCell)
                     iEdge = edgesOnCell(i, iCell)
   
                     cell1 = cellsOnEdge(1, iEdge)
                     cell2 = cellsOnEdge(2, iEdge)
   
                     ! Interpolation sshEdge
                     sshEdgeLag = 0.5_RKIND * (  sshSubcycleCur(cell1)   &
                                               + sshSubcycleCur(cell2) )
   
                     ! method 1, matches method 0 without pbcs,
                     ! works with pbcs.
                     thicknessSumLag = si_ismf * sshEdgeLag    &
                                     + min(bottomDepth(cell1), &
                                           bottomDepth(cell2))
   
                     ! nabla (ssh^0)
                     sshDiffLag = (SIvec_zh1(cell2)-SIvec_zh1(cell1)) &
                                / dcEdge(iEdge)
   
                     fluxAx = thicknessSumLag * sshDiffLag
   
                     sshTendAx = sshTendAx + edgeSignOnCell(i, iCell) &
                               * fluxAx * dvEdge(iEdge)
                  end do ! i
   
                  sshLagArea = R1_alpha1s_g_dts * SIvec_zh1(iCell) &
                             * areaCell(iCell)
   
                  SIvec_v0(iCell) = -sshLagArea - sshTendAx
   
               end do ! iCell
               !$omp end do
               !$omp end parallel
   
               ! Reduction -----------------------------------------------!
               SIcst_r00s0 = 0.0_RKIND
               SIcst_r00z0 = 0.0_RKIND
               SIcst_q0y0  = 0.0_RKIND
               SIcst_y0y0  = 0.0_RKIND
               SIcst_r00q0 = 0.0_RKIND
               SIcst_r00y0 = 0.0_RKIND
               SIcst_r00t0 = 0.0_RKIND
               SIcst_r00v0 = 0.0_RKIND
               SIcst_q0q0  = 0.0_RKIND
   
               do iCell = 1,nCellsOwned
                  SIcst_r00s0 = SIcst_r00s0 + SIvec_r00(iCell) &
                                            * SIvec_s1(iCell) ! s1
   
                  SIcst_r00z0 = SIcst_r00z0 + SIvec_r00(iCell) &
                                            * SIvec_z1(iCell) ! z1
   
                  SIcst_q0y0  = SIcst_q0y0  + SIvec_q0(iCell)  &
                                            * SIvec_y0(iCell)
   
                  SIcst_y0y0  = SIcst_y0y0  + SIvec_y0(iCell)  &
                                            * SIvec_y0(iCell)
   
                  SIcst_r00q0 = SIcst_r00q0 + SIvec_r00(iCell) &
                                            * SIvec_q0(iCell)
   
                  SIcst_r00y0 = SIcst_r00y0 + SIvec_r00(iCell) &
                                            * SIvec_y0(iCell)
   
                  SIcst_r00t0 = SIcst_r00t0 + SIvec_r00(iCell) &
                                            * SIvec_t0(iCell)
   
                  SIcst_r00v0 = SIcst_r00v0 + SIvec_r00(iCell) &
                                            * SIvec_v0(iCell)
   
                  SIcst_q0q0 = SIcst_q0q0   + SIvec_q0(iCell) &
                                            * SIvec_q0(iCell)
               end do

               SIcst_allreduce_local9(1) = SIcst_r00s0
               SIcst_allreduce_local9(2) = SIcst_r00z0
               SIcst_allreduce_local9(3) = SIcst_q0y0 
               SIcst_allreduce_local9(4) = SIcst_y0y0 
               SIcst_allreduce_local9(5) = SIcst_r00q0
               SIcst_allreduce_local9(6) = SIcst_r00y0
               SIcst_allreduce_local9(7) = SIcst_r00t0
               SIcst_allreduce_local9(8) = SIcst_r00v0
               SIcst_allreduce_local9(9) = SIcst_q0q0
   
               ! Global sum across CPUs
               call mpas_timer_start("si reduction iter")
               call mpas_dmpar_sum_real_array(domain % dminfo, 9,      &
                                              SIcst_allreduce_local9,  &
                                              SIcst_allreduce_global9)
               call mpas_timer_stop("si reduction iter")
   
               if ( config_btr_si_partition_match_mode .and. ncpus>1) then
                  SIcst_allreduce_temp9(:)    = 0.0_RKIND
                  SIcst_allreduce_itemp9(:)   = 0.0_RKIND
   
                  SIcst_allreduce_itemp9(:) = &
                                     exponent(SIcst_allreduce_global9(:))
                  SIcst_allreduce_temp9(:)  = &
                                     fraction(SIcst_allreduce_global9(:))
                  SIcst_allreduce_temp9(:)  = &
                                     anint( SIcst_allreduce_temp9(:)  &
                                           * 1.0e+4_RKIND  ) &
                                           / 1.0e+4_RKIND
   
                  SIcst_allreduce_global9(:)  =                        &
                              SIcst_allreduce_temp9(:)                 &
                            * 2.0_RKIND ** (SIcst_allreduce_itemp9(:))
               endif
   
               SIcst_r00s0_global = SIcst_allreduce_global9(1) 
               SIcst_r00z0_global = SIcst_allreduce_global9(2)
               SIcst_q0y0_global  = SIcst_allreduce_global9(3)
               SIcst_y0y0_global  = SIcst_allreduce_global9(4)
               SIcst_r00q0_global = SIcst_allreduce_global9(5)
               SIcst_r00y0_global = SIcst_allreduce_global9(6)
               SIcst_r00t0_global = SIcst_allreduce_global9(7)
               SIcst_r00v0_global = SIcst_allreduce_global9(8)
               SIcst_q0q0_global  = SIcst_allreduce_global9(9)
   
               ! Omega0
               SIcst_omega0 = SIcst_q0y0_global / SIcst_y0y0_global
   
               ! Residual
               ! = (r1,r1) = (q0,q0) - 2*Omega*(q0,y0) + Omega**2*(y0,y0)
               resid = SIcst_q0q0_global &
                     - 2.0_RKIND * SIcst_omega0 * SIcst_q0y0_global  &
                     + SIcst_omega0**2.0_RKIND  * SIcst_y0y0_global
   
               !$omp parallel
               !$omp do schedule(runtime)
               do iCell = 1,nPrecVec
                  sshSubcycleNew(iCell) = sshSubcycleNew(iCell)           &
                                        + SIcst_alpha0 * SIvec_ph1(iCell) &
                                        + SIcst_omega0 * SIvec_qh0(iCell)
   
                  SIvec_r1(iCell)  = SIvec_q0(iCell) - SIcst_omega0       &
                                   * SIvec_y0(iCell)
   
                  SIvec_rh1(iCell) =  SIvec_qh0(iCell) - SIcst_omega0     &
                                   * (SIvec_wh0(iCell) - SIcst_alpha0     &
                                                       * SIvec_zh1(iCell))
   
                  SIvec_w1(iCell)  =   SIvec_y0(iCell) - SIcst_omega0     &
                                   * ( SIvec_t0(iCell) - SIcst_alpha0     &
                                                       * SIvec_v0(iCell))
               end do
               !$omp end do
               !$omp end parallel
   
               ! Preconditioning -----------------------------------------!
   
               if ( trim(config_btr_si_preconditioner) == 'ras' ) then
                  ! RAS preconditioning: Use BLAS 
                  ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
                  call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                             SIvec_w1(1:nPrecVec), 1, 0.0_RKIND,   &
                             SIvec_wh1(1:nPrecVec),1)
#endif
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                 'block_jacobi' ) then
                  ! Block-Jacobi preconditioning: Use BLAS 
                  ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
                  call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                             SIvec_w1(1:nPrecVec), 1, 0.0_RKIND,   &
                             SIvec_wh1(1:nPrecVec),1)
#endif
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                       'jacobi' ) then
                  ! Jacobi preconditioning
                  SIvec_wh1(1:nPrecVec) = SIvec_w1(1:nPrecVec)  &
                                        * prec_ivmat(1:nPrecVec)
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                         'none' ) then
                  ! No preconditioning
                  SIvec_wh1(1:nPrecVec) = SIvec_w1(1:nPrecVec)
               end if
   
               call mpas_timer_start("si halo iter")
               call mpas_dmpar_field_halo_exch(domain, 'SIvec_wh1')
               call mpas_timer_stop("si halo iter")
   
   
               ! SpMV ----------------------------------------------------!
   
               !$omp parallel
               !$omp do schedule(runtime) &
               !$omp private(sshTendAx,iEdge,cell1,cell2,sshEdgeLag, &
               !$omp         thicknessSumLag,sshDiffLag,fluxAx,sshLagArea )
               do iCell = 1, nPrecVec
                  sshTendAx = 0.0_RKIND
   
                  do i = 1, nEdgesOnCell(iCell)
                     iEdge = edgesOnCell(i, iCell)
   
                     cell1 = cellsOnEdge(1, iEdge)
                     cell2 = cellsOnEdge(2, iEdge)
   
                     ! Interpolation sshEdge
                     sshEdgeLag = 0.5_RKIND * (  sshSubcycleCur(cell1)   &
                                               + sshSubcycleCur(cell2) )
   
                     ! method 1, matches method 0 without pbcs,
                     ! works with pbcs.
                     thicknessSumLag = si_ismf * sshEdgeLag    &
                                     + min(bottomDepth(cell1), &
                                           bottomDepth(cell2))
   
                     ! nabla (ssh^0)
                     sshDiffLag = (SIvec_wh1(cell2)-SIvec_wh1(cell1)) &
                                / dcEdge(iEdge)
   
                     fluxAx = thicknessSumLag * sshDiffLag
   
                     sshTendAx = sshTendAx + edgeSignOnCell(i, iCell) &
                               * fluxAx * dvEdge(iEdge)
                  end do ! i
   
                  sshLagArea = R1_alpha1s_g_dts * SIvec_wh1(iCell) &
                             * areaCell(iCell)
   
                  SIvec_t1(iCell) = -sshLagArea - sshTendAx
               end do ! iCell
               !$omp end do
               !$omp end parallel

               SIcst_rho1 = SIcst_r00q0_global - SIcst_omega0 * SIcst_r00y0_global 
   
               SIcst_gamma1 = SIcst_r00y0_global - SIcst_omega0 * SIcst_r00t0_global  &
                                          + SIcst_omega0 * SIcst_alpha0 &
                                                         * SIcst_r00v0_global
    
               SIcst_beta0 = (SIcst_alpha0/SIcst_omega0) &
                           * (SIcst_rho1 / SIcst_rho0)
   
               SIcst_alpha0 = SIcst_rho1 &
                            / ( SIcst_gamma1 + SIcst_beta0 * SIcst_r00s0_global   &
                                             - SIcst_beta0 * SIcst_omega0  &
                                                           * SIcst_r00z0_global )
               SIcst_rho0         = SIcst_rho1

               !$omp parallel
               !$omp do schedule(runtime)
               do iCell = 1,nPrecVec
                  SIvec_r0(iCell) = SIvec_r1(iCell)
                  SIvec_s0(iCell) = SIvec_s1(iCell)
                  SIvec_z0(iCell) = SIvec_z1(iCell)
                  SIvec_w0(iCell) = SIvec_w1(iCell)
                  SIvec_t0(iCell) = SIvec_t1(iCell)
   
                  SIvec_rh0(iCell) = SIvec_rh1(iCell)
                  SIvec_sh0(iCell) = SIvec_sh1(iCell)
                  SIvec_ph0(iCell) = SIvec_ph1(iCell)
                  SIvec_wh0(iCell) = SIvec_wh1(iCell)
                  SIvec_zh0(iCell) = SIvec_zh1(iCell)
               end do ! iCell
               !$omp end do
               !$omp end parallel
   
            !-------------------------------------------------------------!
            end do ! do iter
            !-------------------------------------------------------------!
   
            !   boundary update on sshNew
            call mpas_timer_start("si halo iter")
            call mpas_dmpar_field_halo_exch(domain, 'sshSubcycle', &
                                            timeLevel=2)
            call mpas_timer_stop("si halo iter")
   
            call mpas_timer_stop("si btr iteration")
   
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Stage 2.4 : The barotropic velocity update
            !             using the lagged SSH
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   
            call mpas_timer_start("si btr vel update")

            !$omp parallel
            !$omp do schedule(runtime)
            do iCell = 1,nCellsAll
               ! Use of sshNew to save the lagged SSH
               sshNew(iCell) = sshSubcycleNew(iCell)
            end do
            !$omp end do
            !$omp end parallel
   
            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(temp_mask,cell1,cell2)
            do iEdge = 1,nEdgesHalo( edgeHaloComputeCounter-1 )
               temp_mask = edgeMask(1, iEdge)
   
               cell1 = cellsOnEdge(1,iEdge)
               cell2 = cellsOnEdge(2,iEdge)
                      
               ! Use of normBtrVelNew as a temp array for sshEdge
               normalBarotropicVelocityNew(iEdge) =       &
                          ( 0.5*sshNew(cell2)          &
                           +0.5*sshSubcycleCur(cell2)) &
                         -( 0.5*sshNew(cell1)          &
                           +0.5*sshSubcycleCur(cell1)) 
    
               normalBarotropicVelocitySubcycleNew(iEdge)              &
                  = temp_mask                                          &
                  * (normalBarotropicVelocityCur(iEdge)                &
                  - dt_si * (-barotropicCoriolisTerm(iEdge) + gravity     &
                          *normalBarotropicVelocityNew(iEdge)          &
                          /dcEdge(iEdge) - barotropicForcing(iEdge)))
            end do ! iEdge
            !$omp end do
            !$omp end parallel
   
            !$omp parallel
            !$omp do schedule(runtime) private(CoriolisTerm, i, eoe)
            do iEdge = 1,nEdgesHalo(2)
               ! Compute the barotropic Coriolis term, -f*uPerp
               CoriolisTerm = 0.0_RKIND
               do i = 1, nEdgesOnEdge(iEdge)
                  eoe = edgesOnEdge(i,iEdge)
                  CoriolisTerm = CoriolisTerm + weightsOnEdge(i,iEdge)       &
                               * 0.5_RKIND                                   &
                               * ( normalBarotropicVelocitySubcycleNew(eoe)  &
                                  +normalBarotropicVelocityCur(eoe)        ) &
                               * fEdge(eoe)
               end do
               barotropicCoriolisTerm(iEdge) = CoriolisTerm
            end do
            !$omp end do
            !$omp end parallel

            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(temp_mask,cell1,cell2)
            do iEdge = 1,nEdgesHalo(2)
               temp_mask = edgeMask(1, iEdge)
   
               cell1 = cellsOnEdge(1,iEdge)
               cell2 = cellsOnEdge(2,iEdge)
               normalBarotropicVelocitySubcycleNew(iEdge)            &
                  = temp_mask                                        &
                  * (normalBarotropicVelocityCur(iEdge)              &
                  - dt_si * (-barotropicCoriolisTerm(iEdge) + gravity   &
                          *normalBarotropicVelocityNew(iEdge)        &
                          /dcEdge(iEdge) - barotropicForcing(iEdge)))
            end do ! iEdge
            !$omp end do
            !$omp end parallel
   
            !$omp parallel
            !$omp do schedule(runtime) private(CoriolisTerm, i, eoe)
            do iEdge = 1,nEdgesOwned
               ! Compute the barotropic Coriolis term, -f*uPerp
               CoriolisTerm = 0.0_RKIND
               do i = 1, nEdgesOnEdge(iEdge)
                  eoe = edgesOnEdge(i,iEdge)
                  CoriolisTerm = CoriolisTerm + weightsOnEdge(i,iEdge)      &
                               * 0.5_RKIND                                  &
                               * ( normalBarotropicVelocitySubcycleNew(eoe) &
                                  +normalBarotropicVelocityCur(eoe) )       &
                               * fEdge(eoe)
               end do
               barotropicCoriolisTerm(iEdge) = CoriolisTerm
            end do
            !$omp end do
            !$omp end parallel
   
            call mpas_timer_start("si halo btr coriolis")
            call mpas_dmpar_field_halo_exch(domain, 'barotropicCoriolisTerm')
            call mpas_timer_stop("si halo btr coriolis")
   
            call mpas_timer_stop ("si btr vel update")
   
   
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Stage 2.5 : Recompution of the initial residual
            !             with lagged values
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   
            call mpas_timer_start("si btr residual")
   
            ! SpMV -------------------------------------------------------!
   
            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(sshTendb1,sshTendb2,sshTendAx,iEdge, &
            !$omp         cell1,cell2,sshEdgeCur,sshEdgeLag,sshEdgeMid, &
            !$omp         thicknessSumCur,thicknessSumMid, &
            !$omp         thicknessSumLag,sshDiffCur,sshDiffLag, &
            !$omp         fluxb1,fluxb2,fluxAx,sshCurArea,sshLagArea)
            do iCell = 1, nPrecVec
               sshTendb1 = 0.0_RKIND
               sshTendb2 = 0.0_RKIND
               sshTendAx = 0.0_RKIND
   
               do i = 1, nEdgesOnCell(iCell)
                  iEdge = edgesOnCell(i, iCell)
   
                  cell1 = cellsOnEdge(1, iEdge)
                  cell2 = cellsOnEdge(2, iEdge)
   
                  ! Interpolation sshEdge
                  sshEdgeCur = 0.5_RKIND * (  sshSubcycleCur(cell1)   &
                                            + sshSubcycleCur(cell2) )
                  sshEdgeLag = 0.5_RKIND * (sshNew(cell1) + sshNew(cell2))
                  sshEdgeMid = alpha1 * sshEdgeLag + alpha2 * sshEdgeCur
   
                  ! method 1, matches method 0 without pbcs,
                  ! works with pbcs.
                  thicknessSumCur = si_ismf * sshEdgeCur    &
                                  + min(bottomDepth(cell1), &
                                        bottomDepth(cell2))
                  thicknessSumLag = si_ismf * sshEdgeLag    &
                                  + min(bottomDepth(cell1), &
                                        bottomDepth(cell2))
                  thicknessSumMid = si_ismf * sshEdgeMid    &
                                  + min(bottomDepth(cell1), &
                                        bottomDepth(cell2))
   
                  ! nabla (ssh^0)
                  sshDiffCur = ( sshSubcycleCur(cell2)   &
                                -sshSubcycleCur(cell1) ) &
                               / dcEdge(iEdge)
                  sshDiffLag = (sshNew(cell2)-sshNew(cell1)) &
                               / dcEdge(iEdge)
   
                  fluxb1 = thicknessSumMid &
                         * normalBarotropicVelocityCur(iEdge)
                  fluxb2 = thicknessSumLag &
                         * ( alpha2*gravity*sshDiffCur &
                            + (-barotropicCoriolisTerm(iEdge) &
                               -barotropicForcing(iEdge)) )
                  fluxAx = thicknessSumLag * sshDiffLag
   
                  sshTendb1 = sshTendb1 + edgeSignOnCell(i, iCell) &
                                        * fluxb1 * dvEdge(iEdge)
                  sshTendb2 = sshTendb2 + edgeSignOnCell(i, iCell) &
                                        * fluxb2 * dvEdge(iEdge)
                  sshTendAx = sshTendAx + edgeSignOnCell(i, iCell) &
                                        * fluxAx * dvEdge(iEdge)
               end do ! i
   
               sshTendb1  = R1_alpha1s_g_dt  * sshTendb1
               sshTendb2  = R1_alpha1_g      * sshTendb2
               sshCurArea = R1_alpha1s_g_dts * sshSubcycleCur(iCell) &
                                             * areaCell(iCell)
               sshLagArea = R1_alpha1s_g_dts * sshNew(iCell) &
                                             * areaCell(iCell)
   
               SIvec_r0(iCell) = (-sshCurArea - sshTendb1 + sshTendb2) &
                                -(-sshLagArea - sshTendAx)
               SIvec_r00(iCell) = SIvec_r0(iCell)
            end do ! iCell
            !$omp end do
            !$omp end parallel
   
            ! Preconditioning --------------------------------------------!
   
            if ( trim(config_btr_si_preconditioner) == 'ras' ) then
               ! RAS preconditioning: Use BLAS
               ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
               call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                          SIvec_r0(1:nPrecVec), 1, 0.0_RKIND,   &
                          SIvec_rh0(1:nPrecVec),1)
#endif
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                              'block_jacobi' ) then
               ! Block-Jacobi preconditioning: Use BLAS 
               ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
               call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                          SIvec_r0(1:nPrecVec), 1, 0.0_RKIND,   &
                          SIvec_rh0(1:nPrecVec),1)
#endif
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                                    'jacobi' ) then
               ! Jacobi preconditioning
               SIvec_rh0(1:nPrecVec) = SIvec_r0(1:nPrecVec) &
                                     * prec_ivmat(1:nPrecVec)
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                                      'none' ) then
               ! No preconditioning
               SIvec_rh0(1:nPrecVec) = SIvec_r0(1:nPrecVec)
            end if
   
            call mpas_timer_start("si halo r0")
            call mpas_dmpar_field_halo_exch(domain, 'SIvec_rh0')
            call mpas_timer_stop("si halo r0")
   
   
            ! SpMV -------------------------------------------------------!
   
            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(sshTendAx,iEdge,cell1,cell2,sshEdgeLag, &
            !$omp         thicknessSumLag,sshDiffLag,fluxAx,sshLagArea )
            do iCell = 1, nPrecVec
   
               sshTendAx = 0.0_RKIND
   
               do i = 1, nEdgesOnCell(iCell)
                  iEdge = edgesOnCell(i, iCell)
   
                  cell1 = cellsOnEdge(1, iEdge)
                  cell2 = cellsOnEdge(2, iEdge)
   
                  ! Interpolation sshEdge
                  sshEdgeLag = 0.5_RKIND * (sshNew(cell1) + sshNew(cell2))
   
                  ! method 1, matches method 0 without pbcs,
                  ! works with pbcs.
                  thicknessSumLag = si_ismf * sshEdgeLag    &
                                  + min(bottomDepth(cell1), &
                                        bottomDepth(cell2))
   
                  ! nabla (ssh^0)
                  sshDiffLag = (SIvec_rh0(cell2)- SIvec_rh0(cell1)) &
                             / dcEdge(iEdge)
   
                  fluxAx = thicknessSumLag * sshDiffLag
   
                  sshTendAx = sshTendAx + edgeSignOnCell(i, iCell) &
                            * fluxAx * dvEdge(iEdge)
               end do ! i
   
               sshLagArea = R1_alpha1s_g_dts * SIvec_rh0(iCell) &
                                             * areaCell(iCell)
   
               SIvec_w0(iCell) = -sshLagArea - sshTendAx
   
            end do ! iCell
            !$omp end do
            !$omp end parallel
   
            ! Preconditioning --------------------------------------------!
   
            if ( trim(config_btr_si_preconditioner) == 'ras' ) then
               ! RAS preconditioning: Use BLAS
               ! the for symmetric matrix-vector multiplication
#ifdef USE_LAPACK
               call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                          SIvec_w0(1:nPrecVec), 1, 0.0_RKIND,   &
                          SIvec_wh0(1:nPrecVec),1)
#endif
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                              'block_jacobi' ) then
               ! Block-Jacobi preconditioning: Use BLAS
               ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
               call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                          SIvec_w0(1:nPrecVec), 1, 0.0_RKIND,   &
                          SIvec_wh0(1:nPrecVec),1)
#endif
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                                    'jacobi' ) then
               ! Jacobi preconditioning
               SIvec_wh0(1:nPrecVec) = SIvec_w0(1:nPrecVec) &
                                     * prec_ivmat(1:nPrecVec)
   
            elseif ( trim(config_btr_si_preconditioner) == &
                                                      'none' ) then
               ! No preconditioning
               SIvec_wh0(1:nPrecVec) = SIvec_w0(1:nPrecVec)
            end if
   
            call mpas_timer_start("si halo r0")
            call mpas_dmpar_field_halo_exch(domain, 'SIvec_wh0')
            call mpas_timer_stop("si halo r0")
   
   
            ! SpMV -------------------------------------------------------!
            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(sshTendAx,iEdge,cell1,cell2,sshEdgeLag, &
            !$omp         thicknessSumLag,sshDiffLag,fluxAx,sshLagArea )
            do iCell = 1, nPrecVec
   
               sshTendAx = 0.0_RKIND
   
               do i = 1, nEdgesOnCell(iCell)
                  iEdge = edgesOnCell(i, iCell)
   
                  cell1 = cellsOnEdge(1, iEdge)
                  cell2 = cellsOnEdge(2, iEdge)
   
                  ! Interpolation sshEdge
                  sshEdgeLag = 0.5_RKIND * (  sshNew(cell1)   &
                                            + sshNew(cell2) )
   
                  ! method 1, matches method 0 without pbcs,
                  ! works with pbcs.
                  thicknessSumLag = si_ismf * sshEdgeLag    &
                                  + min(bottomDepth(cell1), &
                                        bottomDepth(cell2))
   
                  ! nabla (ssh^0)
                  sshDiffLag = (SIvec_wh0(cell2) - SIvec_wh0(cell1)) &
                             / dcEdge(iEdge)
   
                  fluxAx = thicknessSumLag * sshDiffLag
   
                  sshTendAx = sshTendAx + edgeSignOnCell(i, iCell) &
                            * fluxAx * dvEdge(iEdge)
               end do ! i
   
               sshLagArea = R1_alpha1s_g_dts * SIvec_wh0(iCell) &
                          * areaCell(iCell)
   
               SIvec_t0(iCell) = -sshLagArea - sshTendAx
   
               SIvec_ph0(iCell) = 0.0_RKIND
               SIvec_sh0(iCell) = 0.0_RKIND
               SIvec_z0(iCell)  = 0.0_RKIND
               SIvec_zh0(iCell) = 0.0_RKIND
               SIvec_v0(iCell)  = 0.0_RKIND
               SIvec_s0(iCell)  = 0.0_RKIND
   
            end do ! iCell
            !$omp end do
            !$omp end parallel
   
   
            ! Reduction -----------------------------------------------!
            SIcst_r00r0 = 0.0_RKIND
            SIcst_r00w0 = 0.0_RKIND
   
            do iCell = 1, nCellsOwned
               SIcst_r00r0 = SIcst_r00r0 + SIvec_r00(iCell) &
                                         * SIvec_r0(iCell)
               SIcst_r00w0 = SIcst_r00w0 + SIvec_r00(iCell) &
                                         * SIvec_w0(iCell)
            end do ! iCell
   
            SIcst_allreduce_local2(1) = SIcst_r00r0
            SIcst_allreduce_local2(2) = SIcst_r00w0
   
            ! Global sum across CPUs
            call mpas_timer_start("si reduction r0")
            call mpas_dmpar_sum_real_array(domain % dminfo, 2,      &
                                           SIcst_allreduce_local2,  &
                                           SIcst_allreduce_global2)
            call mpas_timer_stop ("si reduction r0")
   
   
            if ( config_btr_si_partition_match_mode .and. ncpus > 1) then
               SIcst_allreduce_temp9(:)    = 0.0_RKIND
               SIcst_allreduce_itemp9(:)   = 0.0_RKIND
   
               SIcst_allreduce_itemp9(1:2) = &
                                    exponent(SIcst_allreduce_global2(:))
               SIcst_allreduce_temp9(1:2)  = &
                                    fraction(SIcst_allreduce_global2(:))
               SIcst_allreduce_temp9(1:2)  = &
                                    anint(SIcst_allreduce_temp9(1:2) &
                                           * 1.0e+4_RKIND  ) &
                                           / 1.0e+4_RKIND
   
               SIcst_allreduce_global2(:) =          &
                          SIcst_allreduce_temp9(1:2) &
                        * 2.0_RKIND ** (SIcst_allreduce_itemp9(1:2))
            endif
   
   
            SIcst_r00r0_global = SIcst_allreduce_global2(1)
            SIcst_r00w0_global = SIcst_allreduce_global2(2)
   
            SIcst_rho0   = SIcst_r00r0_global
            SIcst_alpha0 = SIcst_rho0 / SIcst_r00w0_global
            SIcst_beta0  = 0.0_RKIND
            SIcst_omega0 = 0.0_RKIND
   
            call mpas_timer_stop("si btr residual")
   
   
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Stage 2.6 : Main (inner) solver iterations
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   
            call mpas_timer_start("si btr iteration")
   
            iter = 0
            resid = SIcst_r00r0_global
   
            !-------------------------------------------------------------!
            do while ( dsqrt(resid) > tolerance_inner )
            !-------------------------------------------------------------!
   
               iter = iter + 1
   
               !$omp parallel
               !$omp do schedule(runtime)
               do iCell = 1, nPrecVec
                  SIvec_ph1(iCell) =  SIvec_rh0(iCell) + SIcst_beta0      &
                                   * (SIvec_ph0(iCell) - SIcst_omega0     &
                                                       * SIvec_sh0(iCell))
   
                  SIvec_s1(iCell)  =  SIvec_w0(iCell)  + SIcst_beta0      &
                                   * (SIvec_s0(iCell)  - SIcst_omega0     &
                                                       * SIvec_z0(iCell))
   
                  SIvec_sh1(iCell) =  SIvec_wh0(iCell) + SIcst_beta0      &
                                   * (SIvec_sh0(iCell) - SIcst_omega0     &
                                                       * SIvec_zh0(iCell))
   
                  SIvec_z1(iCell)  =  SIvec_t0(iCell)  + SIcst_beta0      &
                                   * (SIvec_z0(iCell)  - SIcst_omega0     &
                                                       * SIvec_v0(iCell))
   
                  SIvec_q0(iCell)  =  SIvec_r0(iCell)  - SIcst_alpha0     &
                                                       * SIvec_s1(iCell)
   
                  SIvec_qh0(iCell) =  SIvec_rh0(iCell) - SIcst_alpha0     &
                                                       * SIvec_sh1(iCell)
   
                  SIvec_y0(iCell)  =  SIvec_w0(iCell)  - SIcst_alpha0     &
                                                       * SIvec_z1(iCell)
               end do ! iCell
               !$omp end do
               !$omp end parallel
   
               ! Preconditioning -----------------------------------------!
               if ( trim(config_btr_si_preconditioner) == 'ras' ) then
                  ! RAS preconditioning: Use BLAS
                  ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
                  call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                             SIvec_z1(1:nPrecVec), 1, 0.0_RKIND,   &
                             SIvec_zh1(1:nPrecVec),1)
#endif
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                 'block_jacobi' ) then
                  ! Block-Jacobi preconditioning: Use BLAS 
                  ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
                  call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                             SIvec_z1(1:nPrecVec), 1, 0.0_RKIND,   &
                             SIvec_zh1(1:nPrecVec),1)
#endif
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                       'jacobi' ) then
                  ! Jacobi preconditioning
                  SIvec_zh1(1:nPrecVec) = SIvec_z1(1:nPrecVec) &
                                        * prec_ivmat(1:nPrecVec)
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                         'none' ) then
                  ! No preconditioning
                  SIvec_zh1(1:nPrecVec) = SIvec_z1(1:nPrecVec)
               end if
   
               call mpas_timer_start("si halo iter")
               call mpas_dmpar_field_halo_exch(domain, 'SIvec_zh1')
               call mpas_timer_stop("si halo iter")
   
   
               ! SpMV ----------------------------------------------------!
   
               !$omp parallel
               !$omp do schedule(runtime) &
               !$omp private(sshTendAx,iEdge,cell1,cell2,sshEdgeLag, &
               !$omp         thicknessSumLag,sshDiffLag,fluxAx,sshLagArea )
               do iCell = 1, nPrecVec
                  sshTendAx = 0.0_RKIND
   
                  do i = 1, nEdgesOnCell(iCell)
                     iEdge = edgesOnCell(i, iCell)
   
                     cell1 = cellsOnEdge(1, iEdge)
                     cell2 = cellsOnEdge(2, iEdge)
   
                     ! Interpolation sshEdge
                     sshEdgeLag = 0.5_RKIND * (  sshNew(cell1)   &
                                               + sshNew(cell2) )
   
                     ! method 1, matches method 0 without pbcs,
                     ! works with pbcs.
                     thicknessSumLag = si_ismf * sshEdgeLag    &
                                     + min(bottomDepth(cell1), &
                                           bottomDepth(cell2))
   
                     ! nabla (ssh^0)
                     sshDiffLag = (SIvec_zh1(cell2)-SIvec_zh1(cell1)) &
                                / dcEdge(iEdge)
   
                     fluxAx = thicknessSumLag * sshDiffLag
   
                     sshTendAx = sshTendAx + edgeSignOnCell(i, iCell) &
                               * fluxAx * dvEdge(iEdge)
                  end do ! i
   
                  sshLagArea = R1_alpha1s_g_dts * SIvec_zh1(iCell) &
                             * areaCell(iCell)
   
                  SIvec_v0(iCell) = -sshLagArea - sshTendAx
   
               end do ! iCell
               !$omp end do
               !$omp end parallel
   
               ! Reduction -----------------------------------------------!
               SIcst_r00s0 = 0.0_RKIND
               SIcst_r00z0 = 0.0_RKIND
               SIcst_q0y0  = 0.0_RKIND
               SIcst_y0y0  = 0.0_RKIND
               SIcst_r00q0 = 0.0_RKIND
               SIcst_r00y0 = 0.0_RKIND
               SIcst_r00t0 = 0.0_RKIND
               SIcst_r00v0 = 0.0_RKIND
               SIcst_q0q0  = 0.0_RKIND
   
               do iCell = 1,nCellsOwned
                  SIcst_r00s0 = SIcst_r00s0 + SIvec_r00(iCell) &
                                            * SIvec_s1(iCell) ! s1
   
                  SIcst_r00z0 = SIcst_r00z0 + SIvec_r00(iCell) &
                                            * SIvec_z1(iCell) ! z1
   
                  SIcst_q0y0  = SIcst_q0y0  + SIvec_q0(iCell)  &
                                            * SIvec_y0(iCell)
   
                  SIcst_y0y0  = SIcst_y0y0  + SIvec_y0(iCell)  &
                                            * SIvec_y0(iCell)
   
                  SIcst_r00q0 = SIcst_r00q0 + SIvec_r00(iCell) &
                                            * SIvec_q0(iCell)
   
                  SIcst_r00y0 = SIcst_r00y0 + SIvec_r00(iCell) &
                                            * SIvec_y0(iCell)
   
                  SIcst_r00t0 = SIcst_r00t0 + SIvec_r00(iCell) &
                                            * SIvec_t0(iCell)
   
                  SIcst_r00v0 = SIcst_r00v0 + SIvec_r00(iCell) &
                                            * SIvec_v0(iCell)
   
                  SIcst_q0q0 = SIcst_q0q0   + SIvec_q0(iCell) &
                                            * SIvec_q0(iCell)
               end do
   
               SIcst_allreduce_local9(1) = SIcst_r00s0
               SIcst_allreduce_local9(2) = SIcst_r00z0
               SIcst_allreduce_local9(3) = SIcst_q0y0 
               SIcst_allreduce_local9(4) = SIcst_y0y0 
               SIcst_allreduce_local9(5) = SIcst_r00q0
               SIcst_allreduce_local9(6) = SIcst_r00y0
               SIcst_allreduce_local9(7) = SIcst_r00t0
               SIcst_allreduce_local9(8) = SIcst_r00v0
               SIcst_allreduce_local9(9) = SIcst_q0q0
   
               ! Global sum across CPUs
               call mpas_timer_start("si reduction iter")
               call mpas_dmpar_sum_real_array(domain % dminfo, 9,      &
                                              SIcst_allreduce_local9,  &
                                              SIcst_allreduce_global9)
               call mpas_timer_stop("si reduction iter")
   
               if ( config_btr_si_partition_match_mode .and. ncpus>1) then
                  SIcst_allreduce_temp9(:)    = 0.0_RKIND
                  SIcst_allreduce_itemp9(:)   = 0.0_RKIND
   
                  SIcst_allreduce_itemp9(:) = &
                                     exponent(SIcst_allreduce_global9(:))
                  SIcst_allreduce_temp9(:)  = &
                                     fraction(SIcst_allreduce_global9(:))
                  SIcst_allreduce_temp9(:)  = &
                                     anint( SIcst_allreduce_temp9(:)  &
                                           * 1.0e+4_RKIND  ) &
                                           / 1.0e+4_RKIND
   
                  SIcst_allreduce_global9(:)  =                        &
                              SIcst_allreduce_temp9(:)                 &
                            * 2.0_RKIND ** (SIcst_allreduce_itemp9(:))
               endif
   
               SIcst_r00s0_global = SIcst_allreduce_global9(1) 
               SIcst_r00z0_global = SIcst_allreduce_global9(2)
               SIcst_q0y0_global  = SIcst_allreduce_global9(3)
               SIcst_y0y0_global  = SIcst_allreduce_global9(4)
               SIcst_r00q0_global = SIcst_allreduce_global9(5)
               SIcst_r00y0_global = SIcst_allreduce_global9(6)
               SIcst_r00t0_global = SIcst_allreduce_global9(7)
               SIcst_r00v0_global = SIcst_allreduce_global9(8)
               SIcst_q0q0_global  = SIcst_allreduce_global9(9)
   
               ! Omega0
               SIcst_omega0 = SIcst_q0y0_global / SIcst_y0y0_global
   
               ! Residual
               resid = SIcst_q0q0_global &
                     - 2.0_RKIND * SIcst_omega0 * SIcst_q0y0_global  &
                     + SIcst_omega0**2.0_RKIND  * SIcst_y0y0_global
   
               !$omp parallel
               !$omp do schedule(runtime)
               do iCell = 1,nPrecVec
                  sshSubcycleNew(iCell) = sshSubcycleNew(iCell)           &
                                        + SIcst_alpha0 * SIvec_ph1(iCell) &
                                        + SIcst_omega0 * SIvec_qh0(iCell)
   
                  SIvec_r1(iCell)  = SIvec_q0(iCell) - SIcst_omega0       &
                                   * SIvec_y0(iCell)
   
                  SIvec_rh1(iCell) =  SIvec_qh0(iCell) - SIcst_omega0     &
                                   * (SIvec_wh0(iCell) - SIcst_alpha0     &
                                                       * SIvec_zh1(iCell))
   
                  SIvec_w1(iCell)  =   SIvec_y0(iCell) - SIcst_omega0     &
                                   * ( SIvec_t0(iCell) - SIcst_alpha0     &
                                                       * SIvec_v0(iCell))
               end do
               !$omp end do
               !$omp end parallel
   
               ! Preconditioning -----------------------------------------!
               if ( trim(config_btr_si_preconditioner) == 'ras' ) then
                  ! RAS preconditioning: Use BLAS 
                  ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
                  call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                             SIvec_w1(1:nPrecVec), 1, 0.0_RKIND,   &
                             SIvec_wh1(1:nPrecVec),1)
#endif
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                 'block_jacobi' ) then
                  ! Block-Jacobi preconditioning: Use BLAS
                  ! for the symmetric matrix-vector multiplication
#ifdef USE_LAPACK
                  call DSPMV('U', nPrecVec, 1.0_RKIND, prec_ivmat, &
                             SIvec_w1(1:nPrecVec), 1, 0.0_RKIND,   &
                             SIvec_wh1(1:nPrecVec),1)
#endif
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                       'jacobi' ) then
                  ! Jacobi preconditioning
                  SIvec_wh1(1:nPrecVec) = SIvec_w1(1:nPrecVec) &
                                        * prec_ivmat(1:nPrecVec)
   
               elseif ( trim(config_btr_si_preconditioner) == &
                                                         'none' ) then
                  ! No preconditioning
                  SIvec_wh1(1:nPrecVec) = SIvec_w1(1:nPrecVec)
               end if
   
               call mpas_timer_start("si halo iter")
               call mpas_dmpar_field_halo_exch(domain, 'SIvec_wh1')
               call mpas_timer_stop("si halo iter")
   
               ! SpMV ----------------------------------------------------!
   
               !$omp parallel
               !$omp do schedule(runtime) &
               !$omp private(sshTendAx,iEdge,cell1,cell2,sshEdgeLag, &
               !$omp         thicknessSumLag,sshDiffLag,fluxAx,sshLagArea )
               do iCell = 1, nPrecVec
                  sshTendAx = 0.0_RKIND
   
                  do i = 1, nEdgesOnCell(iCell)
                     iEdge = edgesOnCell(i, iCell)
   
                     cell1 = cellsOnEdge(1, iEdge)
                     cell2 = cellsOnEdge(2, iEdge)
   
                     ! Interpolation sshEdge
                     sshEdgeLag = 0.5_RKIND * (  sshNew(cell1)   &
                                               + sshNew(cell2) )
   
                     ! method 1, matches method 0 without pbcs, 
                     ! works with pbcs.
                     thicknessSumLag = si_ismf * sshEdgeLag    &
                                     + min(bottomDepth(cell1), &
                                           bottomDepth(cell2))
   
                     ! nabla (ssh^0)
                     sshDiffLag = (SIvec_wh1(cell2)-SIvec_wh1(cell1)) &
                                / dcEdge(iEdge)
   
                     fluxAx = thicknessSumLag * sshDiffLag
   
                     sshTendAx = sshTendAx + edgeSignOnCell(i, iCell) &
                               * fluxAx * dvEdge(iEdge)
                  end do ! i
   
                  sshLagArea = R1_alpha1s_g_dts * SIvec_wh1(iCell) &
                             * areaCell(iCell)
   
                  SIvec_t1(iCell) = -sshLagArea - sshTendAx
               end do ! iCell
               !$omp end do
               !$omp end parallel
   
               SIcst_rho1 = SIcst_r00q0_global - SIcst_omega0 * SIcst_r00y0_global 
   
               SIcst_gamma1 = SIcst_r00y0_global - SIcst_omega0 * SIcst_r00t0_global  &
                                          + SIcst_omega0 * SIcst_alpha0 &
                                                         * SIcst_r00v0_global
    
               SIcst_beta0 = (SIcst_alpha0/SIcst_omega0) &
                           * (SIcst_rho1 / SIcst_rho0)
   
               SIcst_alpha0 = SIcst_rho1 &
                            / ( SIcst_gamma1 + SIcst_beta0 * SIcst_r00s0_global   &
                                             - SIcst_beta0 * SIcst_omega0  &
                                                           * SIcst_r00z0_global )
               SIcst_rho0 = SIcst_rho1

               !$omp parallel
               !$omp do schedule(runtime)
               do iCell = 1,nPrecVec
                  SIvec_r0(iCell) = SIvec_r1(iCell)
                  SIvec_s0(iCell) = SIvec_s1(iCell)
                  SIvec_z0(iCell) = SIvec_z1(iCell)
                  SIvec_w0(iCell) = SIvec_w1(iCell)
                  SIvec_t0(iCell) = SIvec_t1(iCell)
   
                  SIvec_rh0(iCell) = SIvec_rh1(iCell)
                  SIvec_sh0(iCell) = SIvec_sh1(iCell)
                  SIvec_ph0(iCell) = SIvec_ph1(iCell)
                  SIvec_wh0(iCell) = SIvec_wh1(iCell)
                  SIvec_zh0(iCell) = SIvec_zh1(iCell)
               end do ! iCell
               !$omp end do
               !$omp end parallel
   
               if ( iter > int(mean_num_cells*5) ) then
                  call mpas_log_write(&
                  '******************************************************')
                  call mpas_log_write(&
                  'Iteration number exceeds Max. #iteration: PROGRAM STOP')
                  call mpas_log_write(&
                  'Current #Iteration = $i ', intArgs=(/ iter /) )
                  call mpas_log_write(&
                  'Max.    #Iteration = $i ', &
                  intArgs=(/ int(mean_num_cells*5) /) )
                  call mpas_log_write(&
                  '******************************************************')
                  call mpas_log_write('',MPAS_LOG_CRIT)
               endif
   
            !-------------------------------------------------------------!
            end do ! do iter
            !-------------------------------------------------------------!
   
            ! boundary update on SSHnew
            call mpas_timer_start("si halo iter")
            call mpas_dmpar_field_halo_exch(domain, 'sshSubcycle', timeLevel=2)
            call mpas_timer_stop("si halo iter")
   
            call mpas_timer_stop("si btr iteration")
   
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            ! Stage 2.7 : The barotropic velocity update
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   
            call mpas_timer_start("si btr vel update")
   
            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(temp_mask,cell1,cell2)
            do iEdge = 1, nEdgesHalo(2)
               temp_mask = edgeMask(1, iEdge)
   
               cell1 = cellsOnEdge(1,iEdge)
               cell2 = cellsOnEdge(2,iEdge)
   
               ! Use of normBtrVelNew as a temp array for sshEdge
               normalBarotropicVelocityNew(iEdge) =    &
                          ( 0.5*sshSubcycleNew(cell2)  &
                           +0.5*sshSubcycleCur(cell2)) &
                         -( 0.5*sshSubcycleNew(cell1)  &
                           +0.5*sshSubcycleCur(cell1)) 
   
               normalBarotropicVelocitySubcycleNew(iEdge)              &
                  = temp_mask                                          &
                  * (normalBarotropicVelocityCur(iEdge)                &
                  - dt_si * (-barotropicCoriolisTerm(iEdge) + gravity     &
                          *normalBarotropicVelocityNew(iEdge)          &
                          /dcEdge(iEdge) - barotropicForcing(iEdge)))
            end do ! iEdge
            !$omp end do
            !$omp end parallel
   
            !$omp parallel
            !$omp do schedule(runtime) private(CoriolisTerm, i, eoe)
            do iEdge = 1,nEdgesHalo(1)
               ! Compute the barotropic Coriolis term, -f*uPerp
               CoriolisTerm = 0.0_RKIND
               do i = 1, nEdgesOnEdge(iEdge)
                  eoe = edgesOnEdge(i,iEdge)
                  CoriolisTerm =  CoriolisTerm + weightsOnEdge(i,iEdge)   &
                               * 0.5_RKIND                                  &
                               * ( normalBarotropicVelocitySubcycleNew(eoe) &
                                  +normalBarotropicVelocityCur(eoe) )       &
                               * fEdge(eoe)
               end do
               barotropicCoriolisTerm(iEdge) = CoriolisTerm
            end do
            !$omp end do
            !$omp end parallel
   
            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(temp_mask,cell1,cell2)
            do iEdge = 1, nEdgesOwned
               temp_mask = edgeMask(1, iEdge)
   
               cell1 = cellsOnEdge(1,iEdge)
               cell2 = cellsOnEdge(2,iEdge)
   
               normalBarotropicVelocitySubcycleNew(iEdge)              &
                  = temp_mask                                          &
                  * (normalBarotropicVelocityCur(iEdge)                &
                  - dt_si * (-barotropicCoriolisTerm(iEdge) + gravity     &
                          *normalBarotropicVelocityNew(iEdge)          &
                          /dcEdge(iEdge) - barotropicForcing(iEdge)))
            end do ! iEdge
            !$omp end do
            !$omp end parallel
   
            !$omp parallel
            !$omp do schedule(runtime) &
            !$omp private(cell1,cell2,sshEdge,thicknessSum)
            do iEdge = 1, nEdgesOwned
               cell1 = cellsOnEdge(1,iEdge)
               cell2 = cellsOnEdge(2,iEdge)
   
               ! normBtrVelSubCur is at time n+0.5 if splitImplicitStep=1
               !                     at time n+1.0 if splitImplicitStep=2
               normalBarotropicVelocitySubcycleCur(iEdge)                &
                  = 0.5_RKIND*normalBarotropicVelocitySubcycleNew(iEdge) &
                  + 0.5_RKIND*normalBarotropicVelocityCur(iEdge)
   
                         ! 0.25 = 0.5 * 0.5
               sshEdge = 0.25_RKIND * (  sshSubcycleCur(cell1)   &
                                       + sshSubcycleCur(cell2) ) &
                       + 0.25_RKIND * (  sshSubcycleNew(cell1)   &
                                       + sshSubcycleNew(cell2) )
   
               thicknessSum = sshEdge + min(bottomDepth(cell1), &
                                            bottomDepth(cell2))
   
               barotropicThicknessFlux(iEdge) &
                  = 0.5*(  normalBarotropicVelocitySubcycleNew(iEdge) &
                         + normalBarotropicVelocityCur(iEdge) )       &
                         * thicknessSum
            end do ! iEdge
            !$omp end do
            !$omp end parallel
   
   
            ! boundary update on F
            call mpas_timer_start("si halo btr vel")
            call mpas_dmpar_exch_group_create(domain, finalBtrGroupName)
            call mpas_dmpar_exch_group_add_field(domain, &
                      finalBtrGroupName, 'barotropicThicknessFlux')
            call mpas_dmpar_exch_group_add_field(domain,             &
                      finalBtrGroupName,                             &
                                 'normalBarotropicVelocitySubcycle', &
                                                       timeLevel=1)
            call mpas_dmpar_exch_group_full_halo_exch(domain, &
                      finalBtrGroupName)
            call mpas_dmpar_exch_group_destroy(domain, finalBtrGroupName)
            call mpas_timer_stop("si halo btr vel")
   
            !$omp parallel
            !$omp do schedule(runtime)
            do iEdge = 1, nEdgesAll
               normalBarotropicVelocityNew(iEdge)              &
                  = normalBarotropicVelocitySubcycleCur(iEdge) 
            end do ! iEdge
            !$omp end do
            !$omp end parallel

            call mpas_timer_stop("si btr vel update")

         !-------------------------------------------------------------!
         end do ! siLargeIter
         !-------------------------------------------------------------!
         ! END   Large barotropic system iteration loop
         !-------------------------------------------------------------!

         ! Check that you can compute SSH using the total sum or the
         ! individual increments over the barotropic subcycles.
         ! efficiency: This next block of code is really a check for
         ! debugging, and can be removed later.
         call mpas_timer_start('btr si ssh verif')

         ! Correction velocity
         !   normalVelocityCorrection = (Flux - Sum(h u*))/H
         ! or, for the full latex version:
         !{\bf u}^{corr} = \left( {\overline {\bf F}}
         !  - \sum_{k=1}^{N^{edge}} h_{k,*}^{edge}
         ! {\bf u}_k^{avg} \right)
         ! \left/ \sum_{k=1}^{N^{edge}} h_{k,*}^{edge}   \right.

         allocate(uTemp(nVertLevels))
         nEdges = nEdgesHalo(config_num_halos-1 )

         !$omp parallel
         !$omp do schedule(runtime) &
         !$omp private(k, uTemp, normalThicknessFluxSum, &
         !$omp         thicknessSum, normalVelocityCorrection)
         do iEdge = 1, nEdges

            ! velocity for normalVelocityCorrectionection is
            ! normalBarotropicVelocity +
            ! normalBaroclinicVelocity + uBolus
            uTemp(:) = normalBarotropicVelocityNew(iEdge) &
                   + normalBaroclinicVelocityNew(:,iEdge) &
                   +       normalGMBolusVelocity(:,iEdge)

            ! thicknessSum is initialized outside the loop because
            ! on land boundaries maxLevelEdgeTop=0, but I want to
            ! initialize thicknessSum with a nonzero value to avoid
            ! a NaN.
            normalThicknessFluxSum  &
               = layerThickEdge(minLevelEdgeBot(iEdge),iEdge) &
               * uTemp(minLevelEdgeBot(iEdge))
            thicknessSum &
               = layerThickEdge(minLevelEdgeBot(iEdge),iEdge)

            do k = minLevelEdgeBot(iEdge)+1, maxLevelEdgeTop(iEdge)
               normalThicknessFluxSum = normalThicknessFluxSum + &
                                        layerThickEdge(k,iEdge)* &
                                        uTemp(k)
               thicknessSum = thicknessSum + &
                              layerThickEdge(k,iEdge)
            enddo

            normalVelocityCorrection = useVelocityCorrection* &
                          ((barotropicThicknessFlux(iEdge) -  &
                            normalThicknessFluxSum)/thicknessSum)

            do k = 1, nVertLevels

               ! normalTransportVelocity = normalBarotropicVelocity
               !                         + normalBaroclinicVelocity
               !                         + normalGMBolusVelocity
               !                         + normalVelocityCorrection
               ! This is u used in advective terms for layerThickness
               ! and tracers in tendency calls in stage 3.
               !mrp note: in QC version, there is an if
               !    (config_use_GM) on adding normalGMBolusVelocity
               !    I think it is not needed because
               !    normalGMBolusVelocity=0 when GM not on.
               normalTransportVelocity(k,iEdge) = edgeMask(k,iEdge) &
                        *(normalBarotropicVelocityNew(iEdge)   + &
                          normalBaroclinicVelocityNew(k,iEdge) + &
                          normalGMBolusVelocity(k,iEdge) + &
                          normalVelocityCorrection )
            enddo

         end do ! iEdge
         !$omp end do
         !$omp end parallel

         deallocate(uTemp)

         call mpas_timer_stop('btr si ssh verif')

         call mpas_timer_stop("si btr vel")


         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !  Stage 3: Tracer, density, pressure, vertical velocity prediction
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! only compute tendencies for active tracers on last large iteration
         if (splitImplicitStep < numTSIterations) then
            activeTracersOnly = .true.
         else
            activeTracersOnly = .false.
         endif

         ! Thickness tendency computations and thickness halo updates
         ! are completed before tracer tendency computations to allow
         ! monotonic advection.

         call mpas_timer_start('si thick tend')

         ! compute vertAleTransportTop.  Use normalTransportVelocity
         ! for advection of layerThickness and tracers.
         ! Use time level 1 values of layerThickness and
         ! layerThickEdge because layerThickness has not yet
         ! been computed for time level 2.
         call mpas_timer_start('thick vert trans vel top')
#ifdef MPAS_OPENACC
         !$acc enter data copyin(layerThicknessCur, sshCur)
         !$acc update device(layerThickEdge, normalTransportVelocity)
#endif
         if (associated(highFreqThicknessNew)) then
#ifdef MPAS_OPENACC
            !$acc enter data copyin(highFreqThicknessNew)
#endif
            call ocn_vert_transport_velocity_top(meshPool, &
                 verticalMeshPool, layerThicknessCur, &
                 layerThickEdge, normalTransportVelocity, sshCur, &
                 dt, vertAleTransportTop, err, highFreqThicknessNew)
#ifdef MPAS_OPENACC
            !$acc exit data delete(highFreqThicknessNew)
#endif
         else
            call ocn_vert_transport_velocity_top(meshPool, &
                 verticalMeshPool, layerThicknessCur, &
                 layerThickEdge, normalTransportVelocity, sshCur, &
                 dt, vertAleTransportTop, err)
         endif
#ifdef MPAS_OPENACC
         !$acc exit data delete(layerThicknessCur, sshCur)
         !$acc update host(vertAleTransportTop, normalTransportVelocity)
#endif
         call mpas_timer_stop('thick vert trans vel top')

         call ocn_tend_thick(tendPool, forcingPool, meshPool)

         call mpas_timer_stop('si thick tend')

         ! update halo for thickness tendencies
         call mpas_timer_start("si halo thickness")

         call mpas_dmpar_field_halo_exch(domain, 'tendLayerThickness')

         call mpas_timer_stop("si halo thickness")

         call mpas_timer_start('si tracer tend', .false.)

         call ocn_tend_tracer(tendPool, statePool, forcingPool, &
                              meshPool, swForcingPool, &
                              dt, activeTracersOnly, 2)

         call mpas_timer_stop('si tracer tend')

         ! update halo for tracer tendencies
         call mpas_timer_start("si halo tracers")

         call mpas_pool_begin_iteration(tracersTendPool)
         do while (mpas_pool_get_next_member(tracersTendPool, &
                                             groupItr) )
            if (groupItr%memberType == MPAS_POOL_FIELD ) then
               ! Only compute tendencies for active tracers if
               ! activeTracersOnly flag is true.
               if (.not. activeTracersOnly .or. &
                   trim(groupItr%memberName)=='activeTracersTend') then
                  call mpas_dmpar_field_halo_exch(domain, &
                                                  groupItr%memberName)
               end if
            end if
         end do

         call mpas_timer_stop("si halo tracers")

         call mpas_timer_start('si loop fini')
         call mpas_pool_get_array(tracersPool, 'activeTracers', &
                                                tracersGroupCur, 1)
         call mpas_pool_get_array(tracersPool, 'activeTracers', &
                                                tracersGroupNew, 2)
         call mpas_pool_get_array(statePool,   'normalVelocity', &
                                                normalVelocityCur, 1)
         call mpas_pool_get_array(tracersTendPool,'activeTracersTend', &
                                                   activeTracersTend)

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !  If iterating, reset variables for next iteration
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         if (splitImplicitStep < numTSIterations) then

            ! Get indices for dynamic tracers (Includes T&S).
            call mpas_pool_get_dimension(tracersPool,'activeGRP_start',&
                                                      startIndex)
            call mpas_pool_get_dimension(tracersPool,'activeGRP_end', &
                                                      endIndex)

            ! Only need T & S for earlier iterations,
            ! then all the tracers needed the last time through.

            !$omp parallel
            !$omp do schedule(runtime) private(i, k, temp_h, temp)
            do iCell = 1, nCellsAll
            do k = minLevelCell(iCell), maxLevelCell(iCell)

               ! this is h_{n+1}
               temp_h = layerThicknessCur(k,iCell) + dt* &
               layerThicknessTend(k,iCell)

               ! this is h_{n+1/2}
               layerThicknessNew(k,iCell) = 0.5* &
               (layerThicknessCur(k,iCell) + temp_h)

               do i = startIndex, endIndex
                  ! This is Phi at n+1
                  temp = (tracersGroupCur(i,k,iCell)* &
                          layerThicknessCur(k,iCell) + dt* &
                          activeTracersTend(i,k,iCell))/temp_h

                  ! This is Phi at n+1/2
                  tracersGroupNew(i,k,iCell) = 0.5_RKIND* &
                            (tracersGroupCur(i,k,iCell) + temp)
               end do ! tracer index
            end do ! vertical
            end do ! iCell
            !$omp end do
            !$omp end parallel

            if (config_use_freq_filtered_thickness) then

               !$omp parallel
               !$omp do schedule(runtime) private(k, temp)
               do iCell = 1, nCellsAll
               do k = minLevelCell(iCell), maxLevelCell(iCell)

                  ! h^{hf}_{n+1} was computed in Stage 1

                  ! this is h^{hf}_{n+1/2}
                  highFreqThicknessNew(k,iCell) = 0.5_RKIND* &
                             (highFreqThicknessCur(k,iCell) + &
                              highFreqThicknessNew(k,iCell))

                  ! this is D^{lf}_{n+1}
                  temp = lowFreqDivergenceCur(k,iCell) + dt* &
                         lowFreqDivergenceTend(k,iCell)

                  ! this is D^{lf}_{n+1/2}
                  lowFreqDivergenceNew(k,iCell) = 0.5_RKIND* &
                           (lowFreqDivergenceCur(k,iCell) + temp)
               end do
               end do
               !$omp end do
               !$omp end parallel
            end if

            !$omp parallel
            !$omp do schedule(runtime) private(k)
            do iEdge = 1, nEdgesAll
            do k = 1, nVertLevels

               ! u = normalBarotropicVelocity + normalBaroclinicVelocity
               ! here normalBaroclinicVelocity is at time n+1/2
               ! This is u used in next iteration or step
               normalVelocityNew(k,iEdge) = edgeMask(k,iEdge)* &
                         ( normalBarotropicVelocityNew(iEdge) + &
                           normalBaroclinicVelocityNew(k,iEdge) )

            enddo
            end do ! iEdge
            !$omp end do
            !$omp end parallel

            ! Efficiency note: We really only need this to compute
            ! layerThickEdge, density, pressure, and SSH
            ! in this diagnostics solve.
            call ocn_diagnostic_solve(dt, statePool, forcingPool, &
                                      meshPool, scratchPool, &
                                      tracersPool, 2, full=.false.)

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! If large iteration complete, compute all variables at
         ! time n+1
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         elseif (splitImplicitStep == numTSIterations) then

            !$omp parallel
            !$omp do schedule(runtime) private(k)
            do iCell = 1, nCellsAll
            do k = minLevelCell(iCell), maxLevelCell(iCell)
               ! this is h_{n+1}
               layerThicknessNew(k,iCell) = &
                                     layerThicknessCur(k,iCell) + &
                                  dt*layerThicknessTend(k,iCell)
            end do
            end do
            !$omp end do
            !$omp end parallel

            if (config_compute_active_tracer_budgets) then

               !$omp parallel
               !$omp do schedule(runtime) private(k)
               do iEdge = 1, nEdgesAll
               do k= minLevelEdgeBot(iEdge), maxLevelEdgeTop(iEdge)
                  activeTracerHorizontalAdvectionEdgeFlux(:,k,iEdge) = &
                  activeTracerHorizontalAdvectionEdgeFlux(:,k,iEdge) / &
                       layerThickEdge(k,iEdge)
               enddo
               enddo
               !$omp end do

               !$omp do schedule(runtime) private(k)
               do iCell = 1, nCellsAll
               do k= minLevelCell(iCell), maxLevelCell(iCell)
                  activeTracerHorizontalAdvectionTendency(:,k,iCell) = &
                  activeTracerHorizontalAdvectionTendency(:,k,iCell) / &
                            layerThicknessNew(k,iCell)

                  activeTracerVerticalAdvectionTendency(:,k,iCell) = &
                  activeTracerVerticalAdvectionTendency(:,k,iCell) / &
                            layerThicknessNew(k,iCell)

                  activeTracerHorMixTendency(:,k,iCell) = &
                  activeTracerHorMixTendency(:,k,iCell) / &
                             layerThicknessNew(k,iCell)

                  activeTracerSurfaceFluxTendency(:,k,iCell) = &
                  activeTracerSurfaceFluxTendency(:,k,iCell) / &
                             layerThicknessNew(k,iCell)

                  temperatureShortWaveTendency(k,iCell) = &
                  temperatureShortWaveTendency(k,iCell) / &
                             layerThicknessNew(k,iCell)

                  activeTracerNonLocalTendency(:,k,iCell) = &
                  activeTracerNonLocalTendency(:,k,iCell) / &
                             layerThicknessNew(k,iCell)
               end do
               end do
               !$omp end do
               !$omp end parallel
            endif

            call mpas_pool_begin_iteration(tracersPool)
            do while (mpas_pool_get_next_member(tracersPool, &
                                                groupItr) )
               if (groupItr%memberType == MPAS_POOL_FIELD) then
                  configName = 'config_use_'//trim(groupItr%memberName)
                  call mpas_pool_get_config(domain%configs, &
                                configName, config_use_tracerGroup)

                  if ( config_use_tracerGroup ) then
                     call mpas_pool_get_array(tracersPool, &
                                              groupItr%memberName, &
                                              tracersGroupCur, 1)
                     call mpas_pool_get_array(tracersPool, &
                                              groupItr%memberName, &
                                              tracersGroupNew, 2)

                     modifiedGroupName = &
                             trim(groupItr % memberName) // 'Tend'
                     call mpas_pool_get_array(tracersTendPool, &
                                              modifiedGroupName, &
                                              tracersGroupTend)

                     !$omp parallel
                     !$omp do schedule(runtime) private(k)
                     do iCell = 1, nCellsAll
                     do k = minLevelCell(iCell), maxLevelCell(iCell)
                        tracersGroupNew(:,k,iCell) = &
                       (tracersGroupCur(:,k,iCell) * &
                        layerThicknessCur(k,iCell) + dt* &
                       tracersGroupTend(:,k,iCell))/ &
                        layerThicknessNew(k,iCell)
                     end do
                     end do
                     !$omp end do
                     !$omp end parallel

                     ! limit salinity in separate loop
                     if (trim(groupItr%memberName) == &
                         'activeTracers' ) then
                        !$omp parallel
                        !$omp do schedule(runtime) private(k)
                        do iCell = 1, nCellsAll
                        do k = minLevelCell(iCell), maxLevelCell(iCell)
                           tracersGroupNew(indexSalinity,k,iCell) = &
                           max(0.001_RKIND,  &
                           tracersGroupNew(indexSalinity,k,iCell))
                        end do
                        end do
                        !$omp end do
                        !$omp end parallel
                     end if

                     ! Reset debugTracers to fixed value at the surface
                     if (trim(groupItr % memberName) == &
                         'debugTracers' .and. &
                         config_reset_debugTracers_near_surface) then

                        !$omp parallel
                        !$omp do schedule(runtime) private(k, lat)
                        do iCell = 1, nCellsAll

                           ! Reset tracer1 to 2 in top n layers
                           do k = minLevelCell(iCell), minLevelCell(iCell)+config_reset_debugTracers_top_nLayers-1
                                tracersGroupNew(1,k,iCell) = 2.0_RKIND
                           end do

                           ! Reset tracer2 to 2 in top n layers
                           ! in zonal bands, and 1 outside
                           lat = latCell(iCell)*180./3.1415
                           if (     lat>-60.0.and.lat<-55.0 &
                                .or.lat>-40.0.and.lat<-35.0 &
                                .or.lat>- 2.5.and.lat<  2.5 &
                                .or.lat> 35.0.and.lat< 40.0 &
                                .or.lat> 55.0.and.lat< 60.0 ) then
                              do k = minLevelCell(iCell), minLevelCell(iCell)+config_reset_debugTracers_top_nLayers-1
                                 tracersGroupNew(2,k,iCell) = 2.0_RKIND
                              end do
                           else
                              do k = minLevelCell(iCell), minLevelCell(iCell)+config_reset_debugTracers_top_nLayers-1
                                 tracersGroupNew(2,k,iCell) = 1.0_RKIND
                              end do
                           end if

                           ! Reset tracer3 to 2 in top n layers
                           ! in zonal bands, and 1 outside
                           lat = latCell(iCell)*180./3.1415
                           if (     lat>-55.0.and.lat<-50.0 &
                                .or.lat>-35.0.and.lat<-30.0 &
                                .or.lat>-15.0.and.lat<-10.0 &
                                .or.lat> 10.0.and.lat< 15.0 &
                                .or.lat> 30.0.and.lat< 35.0 &
                                .or.lat> 50.0.and.lat< 55.0 ) then
                              do k = minLevelCell(iCell), minLevelCell(iCell)+config_reset_debugTracers_top_nLayers-1
                                 tracersGroupNew(3,k,iCell) = 2.0_RKIND
                              end do
                           else
                              do k = minLevelCell(iCell), minLevelCell(iCell)+config_reset_debugTracers_top_nLayers-1
                                 tracersGroupNew(3,k,iCell) = 1.0_RKIND
                              end do
                           end if
                        end do ! cells
                        !$omp end do
                        !$omp end parallel
                     end if ! debug tracers
                  end if ! use tracer group
               end if ! tracer
            end do ! tracer group

            if (config_use_freq_filtered_thickness) then
               !$omp parallel
               !$omp do schedule(runtime) private(k)
               do iCell = 1, nCellsAll
               do k = minLevelCell(iCell), maxLevelCell(iCell)

                  ! h^{hf}_{n+1} was computed in Stage 1

                  ! this is D^{lf}_{n+1}
                  lowFreqDivergenceNew(k,iCell) = &
                  lowFreqDivergenceCur(k,iCell) + dt* &
                  lowFreqDivergenceTend(k,iCell)
               end do
               end do
               !$omp end do
               !$omp end parallel
            end if

            ! Recompute final u to go on to next step.
            ! u_{n+1} = normalBarotropicVelocity_{n+1} +
            !           normalBaroclinicVelocity_{n+1}
            ! Right now normalBaroclinicVelocityNew is at time n+1/2,
            ! so back compute to get normalBaroclinicVelocity at
            ! time n+1 using normalBaroclinicVelocity_{n+1/2} =
            !            1/2*(normalBaroclinicVelocity_n + u_Bcl_{n+1})
            ! so the following lines are
            ! u_{n+1} = normalBarotropicVelocity_{n+1} +
            !         2*normalBaroclinicVelocity_{n+1/2} -
            !         normalBaroclinicVelocity_n
            ! note that normalBaroclinicVelocity is recomputed at the
            ! beginning of the next timestep due to Imp Vert mixing,
            ! so normalBaroclinicVelocity does not have to be
            ! recomputed here.

            !$omp parallel
            !$omp do schedule(runtime) private(k)
            do iEdge = 1, nEdgesAll
            do k = minLevelEdgeBot(iEdge), maxLevelEdgeTop(iEdge)
               normalVelocityNew(k,iEdge) = &
                               normalBarotropicVelocityNew(iEdge) + &
                             2*normalBaroclinicVelocityNew(k,iEdge) - &
                               normalBaroclinicVelocityCur(k,iEdge)
            end do
            end do ! iEdges
            !$omp end do
            !$omp end parallel

            endif ! splitImplicitStep

         call mpas_timer_stop('si loop fini')
         call mpas_timer_stop('si loop')

      end do  ! splitImplicitStep = 1, config_n_ts_iter
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ! END large iteration loop
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      call mpas_timer_start("si implicit vert mix")

      ! Call ocean diagnostic solve in preparation for vertical mixing.
      ! Note it is called again after vertical mixing, because u and
      ! tracers change. For Richardson vertical mixing, only density,
      ! layerThickEdge, and kineticEnergyCell need to be computed.
      ! For kpp, more variables may be needed.  Either way, this could
      ! be made more efficient by only computing what is needed for the
      ! implicit vmix routine that follows.
      call ocn_diagnostic_solve(dt, statePool, forcingPool, meshPool, &
                                scratchPool, tracersPool, 2)

      call mpas_dmpar_field_halo_exch(domain, 'surfaceFrictionVelocity')

      ! Compute normalGMBolusVelocity; it will be added to the
      ! baroclinic modes in Stage 2 above.
      !if (config_use_GM.or.config_use_Redi) then
      !   call ocn_gm_compute_Bolus_velocity(statePool, &
      !             meshPool, scratchPool, timeLevelIn=2)
      !end if
      call ocn_vmix_implicit(dt, meshPool, statePool, forcingPool, &
                             scratchPool, err, 2)

      ! Update halo on u and tracers, which were just updated for
      ! implicit vertical mixing.  If not done, this leads to lack of
      ! volume conservation.  It is required because halo updates in
      ! stage 3 are only conducted on tendencies, not on the velocity
      ! and tracer fields.  So this update is required to communicate
      ! the change due to implicit vertical mixing across the boundary.

      call mpas_timer_start('si vmix halos')

      call mpas_timer_start('si vmix halos normalVelFld')
      call mpas_dmpar_field_halo_exch(domain, 'normalVelocity', &
                                      timeLevel=2)
      call mpas_timer_stop('si vmix halos normalVelFld')

      call mpas_pool_begin_iteration(tracersPool)
      do while ( mpas_pool_get_next_member(tracersPool, groupItr) )
         if (groupItr%memberType == MPAS_POOL_FIELD) then

            ! Reset iAge to zero where mask == 0
            if (config_use_idealAgeTracers.and.trim(groupItr%memberName) == 'idealAgeTracers') then
                call mpas_pool_get_array(tracersPool, &
                                         groupItr%memberName, &
                                         tracersGroupNew, 2)
                call mpas_pool_get_subpool(forcingPool, &
                                           'tracersIdealAgeFields', &
                                            tracersIdealAgeFieldsPool)
                call mpas_pool_get_array(tracersIdealAgeFieldsPool, &
                                         'idealAgeTracersIdealAgeMask', &
                                          tracerGroupIdealAgeMask)

                !$omp parallel
                !$omp do schedule(runtime)
                do iCell = 1, nCellsOwned
                   tracersGroupNew(1,1,iCell) = tracerGroupIdealAgeMask(1,iCell)*tracersGroupNew(1,1,iCell)
                end do ! cells
                !$omp end do
                !$omp end parallel
             endif

            ! Halo update on all tracer groups
            call mpas_dmpar_field_halo_exch(domain, groupItr%memberName, timeLevel=2)

         end if
      end do

      call mpas_timer_stop('si vmix halos')

      call mpas_timer_stop("si implicit vert mix")

      call mpas_timer_start('si fini')

      if (config_prescribe_velocity) then
         !$omp parallel
         !$omp do schedule(runtime) private(k)
         do iEdge = 1, nEdgesAll
         do k=1,nVertLevels
            normalVelocityNew(k,iEdge) = normalVelocityCur(k,iEdge)
         end do
         end do
         !$omp end do
         !$omp end parallel
      end if

      if (config_prescribe_thickness) then
         !$omp parallel
         !$omp do schedule(runtime) private(k)
         do iCell = 1, nCellsAll
         do k=1,nVertLevels
            layerThicknessNew(k,iCell) = layerThicknessCur(k,iCell)
         end do
         end do
         !$omp end do
         !$omp end parallel
      end if

      call ocn_diagnostic_solve(dt, statePool, forcingPool, meshPool, &
                                scratchPool, tracersPool, 2)

      ! Update the effective desnity in land ice if we're coupling to
      ! land ice
      call ocn_effective_density_in_land_ice_update(meshPool, &
                                       forcingPool, statePool, err)

      !! Compute normalGMBolusVelocity; it will be added to
      !! normalVelocity in Stage 2 of the next cycle.
      !if (config_use_GM.or.config_use_Redi) then
      !   call ocn_gm_compute_Bolus_velocity(statePool, diagnosticsPool,&
      !                           meshPool, scratchPool, timeLevelIn=2)
      !end if

      call mpas_timer_start('si final mpas reconstruct', .false.)

      call mpas_reconstruct(meshPool, normalVelocityNew,  &
                            velocityX, velocityY, velocityZ,   &
                            velocityZonal, velocityMeridional, &
                            includeHalos = .true.)

      call mpas_reconstruct(meshPool, gradSSH,               &
                            gradSSHX, gradSSHY, gradSSHZ,    &
                            gradSSHZonal, gradSSHMeridional, &
                            includeHalos = .true.)

      call mpas_timer_stop('si final mpas reconstruct')

      !$omp parallel
      !$omp do schedule(runtime)
      do iCell = 1, nCellsAll
         surfaceVelocity(indexSurfaceVelocityZonal,iCell) = &
                                   velocityZonal(minLevelCell(iCell),iCell)
         surfaceVelocity(indexSurfaceVelocityMeridional,iCell) = &
                                   velocityMeridional(minLevelCell(iCell),iCell)

         SSHGradient(indexSSHGradientZonal,iCell) = gradSSHZonal(iCell)
         SSHGradient(indexSSHGradientMeridional,iCell) = &
                                               gradSSHMeridional(iCell)
      end do
      !$omp end do
      !$omp end parallel

      call ocn_time_average_coupled_accumulate(statePool,forcingPool,2)

      if (config_use_GM) then
         call ocn_reconstruct_gm_vectors(meshPool)
      end if

      if (trim(config_land_ice_flux_mode) == 'coupled') then
         call mpas_timer_start("si effective density halo")
         call mpas_pool_get_field(statePool, &
                                 'effectiveDensityInLandIce', &
                                  effectiveDensityField, 2)
         call mpas_dmpar_exch_halo_field(effectiveDensityField)
         call mpas_timer_stop("si effective density halo")
      end if

      call mpas_timer_stop('si fini')
      call mpas_timer_stop("si timestep")

   end subroutine ocn_time_integrator_si!}}}

!***********************************************************************
!
!  routine ocn_time_integration_si_init
!
!> \brief   Initialize split-implicit time stepping within MPAS-Ocean
!> \author  Mark Petersen
!> \date    September 2011
!
!> \author  Hyun-Gyu Kang (ORNL, for the split-implicit code)
!> \date    September 2019
!> \details
!>  This routine initializes variables required for the split-implicit
!>  method of integrating the ocean model forward in time
!
!-----------------------------------------------------------------------

   subroutine ocn_time_integration_si_init(domain, dt)!{{{

      !-----------------------------------------------------------------
      ! Input/output variables
      !-----------------------------------------------------------------

      real (kind=RKIND), intent(in) :: dt !< [in] time step (sec)

      type (domain_type), intent(inout) :: domain

      !-----------------------------------------------------------------
      ! Local variables
      !-----------------------------------------------------------------

      type (block_type), pointer :: &
         block ! structure with subdomain data

      type (mpas_pool_type), pointer :: &
         statePool,         &! structure holding state variables
         meshPool            ! structure holding mesh variables

      integer, pointer :: nVertLevels

      integer ::         &
         iCell, iEdge, k,&! loop indices for cell, edge and vertical
         kmax,           &! index of deepest active edge
         ierr,           &! local error flag
         cell1, cell2     ! neighbor cell indices across edge

      integer :: nCells, nEdges, ihh, imm, iss

      integer, dimension(:), pointer :: nCellsArray, nEdgesArray,     &
         minLevelEdgeBot, maxLevelEdgeTop, minLevelCell, maxLevelCell

      integer, dimension(:,:), pointer :: cellsOnEdge

      real (kind=RKIND) ::       &
         normalThicknessFluxSum, &! vertical sum of thick flux
         layerThicknessSum,      &! vertical sum of layer thickness
         layerThicknessEdge1,    &! layer thickness on edge
         area_mean,              &! RMS of areaCell
         local_num_cells,        &! number of cells for each core
         local_area_sum,         &! local sum of area
         total_area_sum,         &! total sum of area
         tmp1,tmp2

      real (kind=RKIND), dimension(:), pointer :: &
         areaCell,               &! area of each cell
         bottomDepth,            &! bottom depth
         refBottomDepth,         &! reference bottom depth
         normalBarotropicVelocity ! normal barotropic velocity

      real (kind=RKIND), dimension(:,:), pointer :: &
         layerThickness,           &! layer thickness cell center
         normalBaroclinicVelocity, &! normal baroclinic velocity
         normalVelocity             ! normal velocity (total)

      real (kind=RKIND), dimension(:), pointer :: ssh

#ifndef USE_LAPACK
      call mpas_log_write( &
      'MPAS was not compiled with LAPACK/BLAS. LAPACK required for SI' &
      , MPAS_LOG_CRIT)
#endif

      !*** Set mask for using velocity correction
      if (config_vel_correction) then
         useVelocityCorrection = 1.0_RKIND
      else
         useVelocityCorrection = 0.0_RKIND
      endif

      !*** Determine the time integration type and set associated masks

      select case (trim(config_time_integrator))

      case ('split_implicit')

         call mpas_log_write( &
         '***********************************************************')
         call mpas_log_write( &
         'The split-implicit time integration is configured')
         call mpas_log_write( &
         '***********************************************************')

      case default
         call mpas_log_write('Incorrect choice config_time_integrator',&
                             MPAS_LOG_CRIT)

      end select

      !*** set number of baroclinic iterations on each outer
      !*** time step iteration (number can be different on the
      !*** first and last time step iteration)

      numTSIterations = config_n_ts_iter

      allocate(numClinicIterations(numTSIterations))

      numClinicIterations    = config_n_bcl_iter_mid ! most iterations
      numClinicIterations(1) = config_n_bcl_iter_beg ! first iteration
      numClinicIterations(numTSIterations)=config_n_bcl_iter_end !last

      block => domain % blocklist

      call mpas_pool_get_subpool(block % structs, 'mesh', meshPool)
      call mpas_pool_get_subpool(block % structs, 'state', statePool)

      call mpas_pool_get_dimension(block % dimensions, 'nVertLevels', &
                                                        nVertLevels)

      call mpas_pool_get_dimension(block % dimensions, 'nCellsArray', &
                                                        nCellsArray)
      call mpas_pool_get_dimension(block % dimensions, 'nEdgesArray', &
                                                        nEdgesArray)

      call mpas_pool_get_array(statePool, 'layerThickness', &
                                           layerThickness, 1)
      call mpas_pool_get_array(statePool, 'normalVelocity', &
                                           normalVelocity, 1)
      call mpas_pool_get_array(statePool, 'normalBarotropicVelocity', &
                                           normalBarotropicVelocity, 1)
      call mpas_pool_get_array(statePool, 'normalBaroclinicVelocity', &
                                           normalBaroclinicVelocity, 1)

      call mpas_pool_get_array(meshPool, 'refBottomDepth', &
                                          refBottomDepth)
      call mpas_pool_get_array(meshPool, 'cellsOnEdge', &
                                          cellsOnEdge)
      call mpas_pool_get_array(meshPool, 'minLevelEdgeBot', &
                                          minLevelEdgeBot)
      call mpas_pool_get_array(meshPool, 'maxLevelEdgeTop', &
                                          maxLevelEdgeTop)
      call mpas_pool_get_array(meshPool, 'minLevelCell', minLevelCell)
      call mpas_pool_get_array(meshPool, 'maxLevelCell', maxLevelCell)
      call mpas_pool_get_array(meshPool, 'bottomDepth', bottomDepth)
      call mpas_pool_get_array(meshPool, 'areaCell', areaCell)

      call mpas_pool_get_array(statePool, 'ssh', ssh, 2)

      nCells = nCellsArray(config_num_halos)
      nEdges = nEdgesArray(config_num_halos+1)

      if ( .not. config_do_restart ) then

      ! Compute barotropic velocity at first timestep
      ! This is only done upon start-up.
         if (config_filter_btr_mode) then
            do iCell = 1, nCells
               layerThickness(minLevelCell(iCell),iCell) = &
                  refBottomDepth(minLevelCell(iCell))
            enddo
         endif

         do iEdge = 1, nEdges
            cell1 = cellsOnEdge(1,iEdge)
            cell2 = cellsOnEdge(2,iEdge)
            kmax  = maxLevelEdgeTop(iEdge)

            ! normalBarotropicVelocity = sum(h*u)/sum(h) on each edge
            ! ocn_diagnostic_solve has not yet been called, so
            ! compute hEdge just for this edge.

            ! thicknessSum is initialized outside the loop because on
            ! land boundaries maxLevelEdgeTop=0, but we want to
            ! initialize thicknessSum with a nonzero value to avoid
            ! a NaN.
            layerThicknessEdge1 = 0.5_RKIND* &
               (layerThickness(minLevelCell(cell1),cell1) + &
                layerThickness(minLevelCell(cell2),cell2) )

            normalThicknessFluxSum = layerThicknessEdge1* &
               normalVelocity(minLevelEdgeBot(iEdge),iEdge)

            layerThicknessSum = layerThicknessEdge1

            do k=minLevelEdgeBot(iEdge)+1, kmax
               layerThicknessEdge1 = 0.5_RKIND* &
                                    (layerThickness(k,cell1) + &
                                     layerThickness(k,cell2))

               normalThicknessFluxSum = normalThicknessFluxSum + &
                                        layerThicknessEdge1* &
                                        normalVelocity(k,iEdge)
               layerThicknessSum = layerThicknessSum + &
                                   layerThicknessEdge1

            enddo
            normalBarotropicVelocity(iEdge) = &
                  normalThicknessFluxSum/layerThicknessSum

            ! normalBaroclinicVelocity = normalVelocity -
            !     normalBarotropicVelocity
            do k = minLevelEdgeBot(iEdge), kmax
               normalBaroclinicVelocity(k,iEdge) = &
                         normalVelocity(k,iEdge) - &
                 normalBarotropicVelocity(iEdge)
            enddo

            ! normalBaroclinicVelocity=0,
            ! normalVelocity=0 on land cells
            do k = kmax+1, nVertLevels
               normalBaroclinicVelocity(k,iEdge) = 0.0_RKIND
               normalVelocity(k,iEdge) = 0.0_RKIND
            enddo
         enddo ! edge loop

         if (config_filter_btr_mode) then
            ! filter normalBarotropicVelocity out of initial condition

            normalVelocity(:,:) = normalBaroclinicVelocity(:,:)
            normalBarotropicVelocity(:) = 0.0_RKIND

         endif

      endif ! .not. config_do_restart

      nCells = nCellsArray(1)

      ! Compute the root mean square of areaCell 
      ! for the solver tolerance
      local_num_cells = nCells
      call mpas_dmpar_sum_real(domain % dminfo, local_num_cells, &
                               total_num_cells)

      local_area_sum = 0.0_RKIND
      do iCell = 1,nCells
        local_area_sum = local_area_sum + areaCell(iCell)**2.0
      end do

      call mpas_dmpar_sum_real(domain % dminfo,local_area_sum, &
                                               total_area_sum)

      area_mean = dsqrt(total_area_sum / total_num_cells)
      ncpus = domain % dminfo % nprocs
      mean_num_cells = total_num_cells/ncpus

      ! Tolerance for the outer iteration
      tolerance_outer   = 0.01_RKIND * area_mean

      ! Tolerance for the inner iteration
      if ( config_btr_si_partition_match_mode ) then
         ! Tolerance for the partition match mode 
         tolerance_inner  = 1.0e-8_RKIND * area_mean
      else
         tolerance_inner  = config_btr_si_tolerance * area_mean
      endif


      ! Detection of ISMF (Temporariliy implemented. 
      !                    This will be revised in next SI version)
      ! If ISMF is detected, the split-implicit barotropic mode solver
      ! will solve a 'quasi-linear' barotropic system for the more 
      ! stable solver convergence.
      do iCell = 1, nCells
         k = maxLevelCell(iCell)
         zTop(k:nVertLevels,iCell) = -bottomDepth(iCell)      &
                                     +layerThickness(k,iCell)

         do k = maxLevelCell(iCell)-1, minLevelCell(iCell), -1
            zTop(k,iCell) = zTop(k+1,iCell) + layerThickness(k  ,iCell)
         end do

         ! copy zTop(1,iCell) into sea-surface height array
         ssh(iCell) = zTop(minLevelCell(iCell),iCell)
      end do

      tmp1 = minval(ssh)
      call mpas_dmpar_min_real(domain % dminfo, tmp1,tmp2 )

      si_ismf = 1
      if ( tmp2 < -10.d0 ) then
         si_ismf = 0
      endif

      ! Impliciness parameters
      alpha1= 0.5_RKIND
      alpha2= 1.0_RKIND - alpha1

      ! Get time step size to compute coefficients for the SI solver
      dt_si = dt

      ! Determination of nSiLargeIter (the barotropic system 
      !                                large iteration loop)
      !    - Currently, it is set as 2 when numTSIterations is 1.
      !    - Also, nSiLargeIter can be controlled by user if needed.
      !    - Higher nSiLargeIter can make simulations more stable and
      !      accurate, but runtime for the barotropic system will 
      !      increase.
      !    - Do not set larger than 2. This will be improved in next
      !      version.
      nSiLargeIter = config_n_btr_si_large_iter

      if ( numTSIterations == 1 ) then
         nSiLargeIter = 2
      else
         nSiLargeIter = config_n_btr_si_large_iter
         dt_si = dt_si / real(nSiLargeIter)
      endif


      ! Computation of coefficients which will be used in the SI solver
      R1_alpha1s_g_dts = 1.0_RKIND/((alpha1**2.0_RKIND) &
                           * gravity * dt_si**2.0_RKIND)
      R1_alpha1s_g_dt  = 1.0_RKIND/((alpha1**2.0_RKIND) &
                           * gravity * dt_si)
      R1_alpha1_g      = 1.0_RKIND/(gravity*alpha1)

      ! Compute preconditioner for the split-implicit barotropic
      !  mode solver
      call mpas_log_write(' Building a preconditioning matrix: ')
      call mpas_timer_start("preconditioning matrix build")
      call ocn_time_integrator_si_preconditioner(domain, dt)
      call mpas_timer_stop("preconditioning matrix build")

   !--------------------------------------------------------------------

   end subroutine ocn_time_integration_si_init!}}}

!***********************************************************************
!
!  routine ocn_time_integration_si_preconditioner
!
!> \brief   Construct a Block-Jacobi preconditioning matrix
!> \author  Hyun-Gyu Kang (Oak Ridge National Laboratory)
!> \date    September 2019
!> \details
!>  This routine constructs preconditioners for the
!>  split-implicit time stepper.
!
!-----------------------------------------------------------------------
   subroutine ocn_time_integrator_si_preconditioner(domain, dt)!{{{

      !-----------------------------------------------------------------
      ! Input variables
      !-----------------------------------------------------------------

      real (kind=RKIND), intent(in) :: &
         dt              !< [in] time step (sec) to move forward

      !-----------------------------------------------------------------
      ! Input/output variables
      !-----------------------------------------------------------------

      type (domain_type), intent(inout) :: &
         domain  !< [inout] model state to advance forward

      !-----------------------------------------------------------------
      ! Local variables
      !-----------------------------------------------------------------

      type (block_type), pointer :: &
         block ! structure with subdomain data

      type (mpas_pool_type), pointer :: &
         meshPool ! structure holding mesh variables

      integer,dimension(:),pointer :: &
         globalCellId ! global index of each cell

      integer ::         &
         nCells, nEdges, &! number of cells or edges (excl halos) 
         iCell, iEdge,   &! loop indices for cell and edge
         cell1, cell2,   &! neighbor cell indices across edge
         nCellsHalo1st,  &! number of cells within 1st halo layer
         nCellsHalo2nd,  &! number of cells within 2st halo layer
         nPrecMatPacked   ! number of matrix elements 
                          !    of an uppder digonal matrix

      integer ::  i, j, info, itmp1
      real (kind=RKIND) :: thicknessSum, fluxAx, temp1

      ! End preamble
      !-----------------------------------------------------------------
      ! Begin code

      block => domain % blocklist
      call mpas_pool_get_subpool(block % structs, 'mesh', meshPool)
      call mpas_pool_get_array(meshPool, 'indexToCellID', globalCellId)

      nCells   = nCellsOwned
      nEdges   = nEdgesOwned
      nCellsHalo1st = nCellsHalo(1)
      nCellsHalo2nd = nCellsHalo(2)

      call mpas_log_write('   config_btr_si_preconditioner: ' &
                           // trim(config_btr_si_preconditioner) )

      if ( trim(config_btr_si_preconditioner) == 'ras' .or. &
           trim(config_btr_si_preconditioner) == 'block_jacobi') then
         if ( int(mean_num_cells) > 3000 ) then
            call mpas_log_write( &
            '      nCells per core is larger than 3000.')
            call mpas_log_write( &
            '      Because of memory and computational efficiency,')
            call mpas_log_write( &
            '      the preconditioner is configured as jacobi.')
            config_btr_si_preconditioner = 'jacobi'
         endif
      endif

      if ( config_btr_si_partition_match_mode ) then
         call mpas_log_write( &
         '       Partition-match mode is turned on.')
         call mpas_log_write( &
         '       The preconditioner is configured as jacobi.')
         config_btr_si_preconditioner = 'jacobi'
         call mpas_log_write( &
         '       The bit-for-bit allreduce is used.')
      endif

      ! Restricted Additive Schwarz preconditioner --------------------!
      if ( trim(config_btr_si_preconditioner) == 'ras' ) then

         nPrecVec = nCellsHalo2nd ! length of preconditioning vector
         nPrecMatPacked = (nPrecVec*(nPrecVec+1))/2
                                  ! Packed size of preconditiong matrix

         allocate(prec_ivmat(1:nPrecMatPacked))
                  prec_ivmat(:) = 0.0_RKIND

         do iCell = 1, nPrecVec

            do i = 1, nEdgesOnCell(iCell)
               iEdge = edgesOnCell(i, iCell)
               cell1 = cellsOnEdge(1, iEdge)
               cell2 = cellsOnEdge(2, iEdge)

               ! method 1, matches method 0 without pbcs,
               ! works with pbcs.
               thicknessSum = min(bottomDepth(cell1), &
                                  bottomDepth(cell2))
               fluxAx = edgeSignOnCell(i,iCell) * dvEdge(iEdge) &
                      * thicknessSum / dcEdge(iEdge)

               if ( globalCellId(cell1) > 0 .and. &
                    globalCellId(cell1) < total_num_cells+1 ) then

                  if ( cell1 >= iCell .and. cell1 <= nPrecVec) then
                     prec_ivmat(iCell+((cell1-1)*cell1)/2) = &
                     prec_ivmat(iCell+((cell1-1)*cell1)/2) + fluxAx
                  endif
               endif

               if ( globalCellId(cell2) > 0 .and. &
                    globalCellId(cell2) < total_num_cells+1 ) then

                  if ( cell2 >= iCell .and. cell2 <= nPrecVec) then
                     prec_ivmat(iCell+((cell2-1)*cell2)/2) = &
                     prec_ivmat(iCell+((cell2-1)*cell2)/2) - fluxAx
                  endif
               endif
            end do ! i

            prec_ivmat(iCell+((iCell-1)*iCell)/2) = &
            prec_ivmat(iCell+((iCell-1)*iCell)/2)   &
               - (4.0_RKIND/(gravity*dt**2.0)) * areaCell(iCell)
         end do ! iCell

         ! Inversiion
           ! 1. Cholesky factorization of a real symmetric 
           !    positive definite matirx A
         prec_ivmat(:) = -prec_ivmat(:)
#ifdef USE_LAPACK
         call DPPTRF('U',nPrecVec,prec_ivmat,info)
#endif
           ! 2. Inversion of a real symmetric positive definite 
           !    matrix A using the Cholesky factorization
#ifdef USE_LAPACK
         call DPPTRI('U',nPrecVec,prec_ivmat,info)
#endif
         prec_ivmat(:) = -prec_ivmat(:)

         ! Block-Jacobi preconditioner --------------------------------!
      elseif ( trim(config_btr_si_preconditioner) == &
                                        'block_jacobi' ) then

         nPrecVec = nCells        ! length of preconditioning vector
         nPrecMatPacked = (nPrecVec*(nPrecVec+1))/2
                                  ! Packed size of preconditiong matrix

         allocate(prec_ivmat(1:nPrecMatPacked))
                  prec_ivmat(:) = 0.0_RKIND

         do iCell = 1, nPrecVec

            do i = 1, nEdgesOnCell(iCell)
               iEdge = edgesOnCell(i, iCell)
               cell1 = cellsOnEdge(1, iEdge)
               cell2 = cellsOnEdge(2, iEdge)

               ! method 1, matches method 0 without pbcs,
               ! works with pbcs.
               thicknessSum = min(bottomDepth(cell1), &
                                  bottomDepth(cell2))
               fluxAx = edgeSignOnCell(i,iCell) * dvEdge(iEdge) &
                      * thicknessSum / dcEdge(iEdge)

               if ( globalCellId(cell1) > 0 .and. &
                    globalCellId(cell1) < total_num_cells+1 ) then

                  if ( cell1 >= iCell .and. cell1 <= nPrecVec) then
                     prec_ivmat(iCell+((cell1-1)*cell1)/2) = &
                     prec_ivmat(iCell+((cell1-1)*cell1)/2) + fluxAx
                  endif
               endif

               if ( globalCellId(cell2) > 0 .and. &
                    globalCellId(cell2) < total_num_cells+1 ) then
                  if ( cell2 >= iCell .and. cell2 <= nPrecVec) then
                     prec_ivmat(iCell+((cell2-1)*cell2)/2) = &
                     prec_ivmat(iCell+((cell2-1)*cell2)/2) - fluxAx
                  endif
               endif
            end do ! i

            prec_ivmat(iCell+((iCell-1)*iCell)/2) = &
            prec_ivmat(iCell+((iCell-1)*iCell)/2)   &
               - (4.0_RKIND/(gravity*dt**2.0)) * areaCell(iCell)
         end do ! iCell

         ! Inversion
           ! 1. Cholesky factorization of a real symmetric 
           !    positive definite matirx A
         prec_ivmat(:) = -prec_ivmat(:)
#ifdef USE_LAPACK
         call DPPTRF('U',nPrecVec,prec_ivmat,info)
#endif
           ! 2. Inversion of a real symmetric positive definite
           !    matrix A using the Cholesky factorization
#ifdef USE_LAPACK
         call DPPTRI('U',nPrecVec,prec_ivmat,info)
#endif
         prec_ivmat(:) = -prec_ivmat(:)

      ! Jacobi preconditioner -----------------------------------------!
      else if ( trim(config_btr_si_preconditioner) == 'jacobi' ) then

         nPrecVec = nCells ! length of preconditioning vector

         allocate(prec_ivmat(1:nPrecVec))
                  prec_ivmat(:) = 0.0_RKIND

         do iCell = 1, nPrecVec

            do i = 1, nEdgesOnCell(iCell)
               iEdge = edgesOnCell(i, iCell)
               cell1 = cellsOnEdge(1, iEdge)
               cell2 = cellsOnEdge(2, iEdge)

               ! method 1, matches method 0 without pbcs,
               ! works with pbcs.
               thicknessSum =  min(bottomDepth(cell1), &
                                   bottomDepth(cell2))

               fluxAx = edgeSignOnCell(i,iCell) * dvEdge(iEdge) &
                      * thicknessSum / dcEdge(iEdge)

               if (cell1 == iCell) then
                  prec_ivmat(iCell) = prec_ivmat(iCell) + fluxAx 
                                                        ! reversed sign
               elseif ( cell2 == iCell) then
                  prec_ivmat(iCell) = prec_ivmat(iCell) - fluxAx
                                                        ! reversed sign
               endif
            end do ! i

            temp1 = prec_ivmat(iCell) &
                  - (4.0_RKIND/(gravity*dt**2.0)) * areaCell(iCell)

            prec_ivmat(iCell) = 1.0_RKIND / temp1

         end do ! iCell

      ! No preconditioner ---------------------------------------------!
      else if ( trim(config_btr_si_preconditioner) == 'none' ) then

         nPrecVec = nCells ! length of preconditioning vector

         allocate(prec_ivmat(1))
         prec_ivmat(:) = 1.0_RKIND

      else

         call mpas_log_write( &
         'Incorrect choice for config_btr_si_preconditioner: ' &
         // trim(config_btr_si_preconditioner) //              &
         '   choices are: ras, block_jacobi, jacobi, none',    &
         MPAS_LOG_CRIT)

      endif ! config_btr_si_preconditioner

   end subroutine ocn_time_integrator_si_preconditioner !}}}

end module ocn_time_integration_si

! vim: foldmethod=marker
