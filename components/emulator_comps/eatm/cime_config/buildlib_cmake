#!/usr/bin/env python3

"""
build cime component model library.   This buildlib script is used by all cime internal
components.
"""

import sys, os

_CIMEROOT = os.environ.get("CIMEROOT")
if _CIMEROOT == None:
    raise ValueError("ERROR: CIMEROOT not defined in buildlib_cmake.internal_components.")
sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))

from standard_script_setup import *
from CIME.buildlib import build_cime_component_lib, parse_input
from CIME.case import Case

def buildlib(bldroot, libroot, case, compname=None):
    if compname is None:
        thisdir = os.path.dirname(os.path.abspath(__file__))
        path, dir1 = os.path.split(thisdir)
        _, dir2 = os.path.split(path)
        if dir1 == "cime_config":
            compname = dir2
        else:
            compname = dir1.split('.')[1]

    # Build the component library (standard CIME pattern)
    build_cime_component_lib(case, compname, libroot, bldroot)

    casebuild = case.get_value("CASEBUILD")
    caseroot  = case.get_value("CASEROOT")
    srcroot   = case.get_value("SRCROOT")

    #---------------------------------------------------------------------------
    # Parse EATM_CMAKE_OPTIONS and create cmake_args
    #---------------------------------------------------------------------------
    eatm_opts = case.get_value("EATM_CMAKE_OPTIONS")
    cmake_args = ""
    
    if eatm_opts:
        tokens = eatm_opts.split()
        if len(tokens) % 2 != 0:
            raise ValueError(
                "Error! EATM_CMAKE_OPTIONS should contain pairs: 'NAME1 VALUE1 NAME2 VALUE2 ...'\n"
                f"Got: {eatm_opts}"
            )
        
        # Parse options into dict (allows overwriting via --append)
        cmake_args_dict = {}
        it = iter(tokens)
        for item in it:
            cmake_args_dict[item] = next(it)
        
        # Build cmake arguments string
        for k, v in cmake_args_dict.items():
            cmake_args += f" -D{k}={v}"
    
        #-----------------------------------------------------------------------
        # LibTorch Check
        #-----------------------------------------------------------------------
        if cmake_args_dict.get("EATM_INFERENCE_BACKEND") == "libtorch":
             # Check if Torch_DIR is provided either in options or env
             if "Torch_DIR" not in cmake_args_dict and "Torch_DIR" in os.environ:
                 # If explicit env var exists, pass it to cmake
                 # (If provided in EATM_CMAKE_OPTIONS, it's already in cmake_args)
                 cmake_args += f" -DTorch_DIR={os.environ['Torch_DIR']}"
                 cmake_args_dict["Torch_DIR"] = os.environ['Torch_DIR']

             # Log what we have
             if "Torch_DIR" in cmake_args_dict:
                 print(f"  EATM: LibTorch config provided: {cmake_args_dict['Torch_DIR']}")
             else:
                 # Warning only - user might relying on CMAKE_PREFIX_PATH or standard paths
                 print("  EATM: WARNING - LibTorch enabled but Torch_DIR not explicit in options.")

    # Write cmake_args to a file for reference
    cmake_opts_file = os.path.join(casebuild, "eatmconf", "cmake_options.txt")
    with open(cmake_opts_file, "w") as fd:
        fd.write(f"# EATM CMake options from EATM_CMAKE_OPTIONS\n")
        fd.write(f"# Generated by buildlib_cmake\n")
        fd.write(cmake_args + "\n")

    #---------------------------------------------------------------------------
    # Create Filepath (unlike most other components, eatm makes it here)
    #---------------------------------------------------------------------------
    filepaths = \
"""{caseroot}/SourceMods/src.eatm
{srcroot}/components/emulator_comps/common/src
{srcroot}/components/emulator_comps/common/src/inference
{srcroot}/components/emulator_comps/eatm/src
{srcroot}/components/emulator_comps/eatm/src/impl
{srcroot}/externals/scorpio/src/clib
""".format(caseroot=caseroot, srcroot=srcroot)

    with open(os.path.join(casebuild, "eatmconf", "Filepath"), "w") as fd:
        fd.write(filepaths)

    with open(os.path.join(casebuild, "eatmconf", "CIME_cppdefs"), "w") as fd:
        fd.write("")
    
    return cmake_args

def _main_func(args):
    caseroot, libroot, bldroot = parse_input(args)
    with Case(caseroot) as case:
        buildlib(bldroot, libroot, case)

if __name__ == "__main__":
    _main_func(sys.argv)
