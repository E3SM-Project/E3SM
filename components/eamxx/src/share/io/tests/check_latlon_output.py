#!/usr/bin/env python3

"""
Checks that latlon output matches expected values
"""

import argparse, sys, pathlib
from netCDF4 import Dataset
import numpy as np

###############################################################################
def parse_command_line(args, description):
###############################################################################
    parser = argparse.ArgumentParser(
        usage="""\n{0} <param>=<val> [<param>=<val>] ...
OR
{0} --help
""".format(pathlib.Path(args[0]).name),
        description=description,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument("--map-file",required=True,type=str,
        help="The path to the map file used in the io_latlon test",
    )

    parser.add_argument("--out-file",required=True,type=str,
        help="The name of the output file generated by the io_latlon test",
    )

    parser.add_argument("-m","--mask-cols",default=0,type=int,
        help="Number of columns to mask-out in each corner when comparing results"
    )

    return parser.parse_args(args[1:])

###############################################################################
def check_latlon_output(map_file,out_file,mask_cols):
###############################################################################
    # Open the output file to read f_lat and f_lon
    with Dataset(out_file, 'r') as out_ds:
        f_lat = out_ds.variables['f_lat'][:]  # Read f_lat variable
        f_lon = out_ds.variables['f_lon'][:]  # Read f_lon variable

    # Open the map file to read yc_b and xc_b
    with Dataset(map_file, 'r') as map_ds:
        yc_b = map_ds.variables['yc_b'][:]  # Read yc_b variable
        xc_b = map_ds.variables['xc_b'][:]  # Read xc_b variable

    # Reshape yc_b and xc_b to match the layout of f_lat and f_lon
    nlat = f_lat.shape[1] # nlat is the 2nd dim, as the 1st one is time
    nlon = f_lat.shape[2] # nlon is the 3nd dim, as the 1st one is time

    yc_b = yc_b.reshape(nlat,nlon)
    xc_b = xc_b.reshape(nlat,nlon)

    if (mask_cols>0):
        # Compare entries "far" from corners
        mask = np.ones(xc_b.shape, dtype=bool)
        mask[:mask_cols,:mask_cols] = False
        mask[:mask_cols,-mask_cols:] = False
        mask[-mask_cols:,-mask_cols:] = False
        mask[-mask_cols:,:mask_cols] = False

        lat_close = np.allclose(f_lat[0,:,:][mask], yc_b[mask], rtol=0.1)
        lon_close = np.allclose(f_lon[0,:,:][mask], xc_b[mask], rtol=0.1)
    else:
        # Compare all entries (use first time slice to match yc_b/xc_b shape)
        lat_close = np.allclose(f_lat[0,:,:], yc_b, rtol=0.1)
        lon_close = np.allclose(f_lon[0,:,:], xc_b, rtol=0.1)


    if not lat_close:
        print("lat is NOT close")
        print (f_lat[:])
        print (yc_b[:])

    if not lon_close:
        print("lon is NOT close")
        print (f_lon[:])
        print (xc_b[:])

    return lat_close and lon_close

###############################################################################
def _main_func(description):
###############################################################################
    success = check_latlon_output(**vars(parse_command_line(sys.argv, description)))
    sys.exit(0 if success else 1)

###############################################################################

if (__name__ == "__main__"):
    _main_func(__doc__)
