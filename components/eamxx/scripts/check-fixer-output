#!/usr/bin/env python3

#"""
# This postscript runs on the output from a test with testmod eamxx-fixer_debug_output,
# which produces debug output from the energy fixer, and verifies that the output 
# is below some tolerance. The output computes a rel difference between the energy that
# is expected and the energy that is currect after the fixer. Both should match up to a tolerance,
# and this is what the script verifies.
# The script is useless unless testmod eamxx-fixer_debug_output was utilized.
#"""

import sys, re, glob, pathlib, argparse, gzip

from utils import run_cmd_no_fail, expect, GoodFormatter

###############################################################################
def parse_command_line(args, description):
###############################################################################
    parser = argparse.ArgumentParser(
        usage="""\n{0} <CASE_DIR> [<param>=<val>] ...
OR
{0} --help

\033[1mEXAMPLES:\033[0m
    \033[1;32m# Run hash checker on /my/case/dir \033[0m
    > {0} /my/case/dir
""".format(pathlib.Path(args[0]).name),
        description=description,
        formatter_class=GoodFormatter
    )

    parser.add_argument(
        "case_dir",
        help="The test case you want to check"
    )

    return parser.parse_args(args[1:])

###############################################################################
def readall(fn):
###############################################################################
    with open(fn,'r') as f:
        txt = f.read()
    return txt

###############################################################################
def greptxt(pattern, txt):
###############################################################################
    return re.findall('(?:' + pattern + ').*', txt, flags=re.MULTILINE)

###############################################################################
def grep(pattern, fn):
###############################################################################
    txt = readall(fn)
    return greptxt(pattern, txt)

###############################################################################
def get_log_glob_from_atm_modelio(case_dir):
###############################################################################
    filename = case_dir / 'CaseDocs' / 'atm_modelio.nml'
    ln = grep('diro = ', filename)[0]
    run_dir = pathlib.Path(ln.split()[2].split('"')[1])
    ln = grep('logfile = ', filename)[0]
    atm_log_fn = ln.split()[2].split('"')[1]
    return str(run_dir / '**' / f'atm.log.*')

###############################################################################
def get_fixer_lines(fn,start_from_line):
###############################################################################
    # sample output that this routine reads:
    # EAMxx:: energy fixer: T tend added to each physics midlevel 0.000222
    # EAMxx:: energy fixer: total energy before fix 32486509719.486938
    # EAMxx:: energy fixer: rel energy error after fix -7.63290383866757e-18

    fixer_lines = []
    error_vals = []

    lines = []
    with gzip.open(fn,'rt') as file:
        start_line_found = False
        for line in file:
            if start_line_found:
                lines.append(line)
            elif start_from_line in line:
                start_line_found = True
    
    for line in lines:
        # eamxx hash line has the form "eamxx hash> date=YYYY-MM-DD-XXXXX (STRING), naccum=INT
        # The INT at the end says how many of the following line contain hashes for this proc-step
        if "EAMxx:: energy fixer: rel energy error" in line:
            fixer_lines.append(line)
            lline = (line.strip('\n'))
            errr = float(lline.split()[8])
            error_vals.append(errr)

    return fixer_lines,error_vals

###############################################################################
def get_model_start_of_step_lines (atm_log):
###############################################################################
    lines = []
    with gzip.open(atm_log,'rt') as file:
        for line in file:
            if "model beg-of-step time" in line:
                lines.append(line)
    return lines

###############################################################################
def check_fixer_output(case_dir):
###############################################################################

    ####################### TOLERANCE
    TOL = 1e-12

    case_dir_p = pathlib.Path(case_dir)
    expect(case_dir_p.is_dir(), f"{case_dir} is not a dir")

    # Look for the two atm.log files.
    glob_pat = get_log_glob_from_atm_modelio(case_dir_p)
    atm_fns = glob.glob(glob_pat, recursive=True)
    if len(atm_fns) == 0:
        print('Could not find atm.log files with glob string {}'.format(glob_pat))
        return False
    if len(atm_fns) == 1:
        print('Found output file {}'.format(atm_fns[0]))

    start_line = get_model_start_of_step_lines(atm_fns[0])[0]

    print (start_line)

    # Extract hash lines, along with their timestamps, but ignore anything
    # before the line $start_line
    f = atm_fns[0]
    fixer_lines,errs = get_fixer_lines(f,start_line)
    print('Array of rel. energy errors after energy fixer:',errs)
    errsa = [abs(ele) for ele in errs]
    mmax = max(errs)
    print('Abs. max. for the rel. energy errors:',mmax)

    if mmax < TOL:
        print('SUCCESS')
        return True
    else:
        print('FAIL, abs. max is less than tolerance, which is ', TOL)
        return False



###############################################################################
def _main_func(description):
###############################################################################
    success = check_fixer_output(**vars(parse_command_line(sys.argv, description)))
    sys.exit(0 if success else 1)

###############################################################################

if (__name__ == "__main__"):
    _main_func(__doc__)
