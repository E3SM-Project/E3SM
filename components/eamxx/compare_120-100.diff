diff --git i/components/eamxx/.clang-format w/components/eamxx/.clang-format
index 74a36fc6e1..d7ac296204 100644
--- i/components/eamxx/.clang-format
+++ w/components/eamxx/.clang-format
@@ -1,6 +1,6 @@
 ---
 BasedOnStyle: LLVM
-ColumnLimit: 120
+ColumnLimit: 100
 AlignConsecutiveAssignments: true
 AlignConsecutiveBitFields: true
 AlignConsecutiveMacros: true
diff --git i/components/eamxx/src/control/atmosphere_driver.cpp w/components/eamxx/src/control/atmosphere_driver.cpp
index 6e64c764fe..d8deed92fb 100644
--- i/components/eamxx/src/control/atmosphere_driver.cpp
+++ w/components/eamxx/src/control/atmosphere_driver.cpp
@@ -58,26 +58,25 @@ namespace control {
  *     Note: at this stage, atm procs that act on non-ref grid(s) should be able to create their
  *           remappers. The AD will *not* take care of remapping inputs/outputs of the process.
  *  4) Register all fields and all groups from all atm procs inside the field managers, and proceed
- *     to allocate fields. For more details, see the documentation in the share/field/field_request.hpp header.
- *  5) Set all the fields into the atm procs. Before this point, all the atm procs had were the
- *     FieldIdentifiers for their input/output fields and FieldGroupInfo for their input/output
- *     field groups. Now, we pass actual Field and FieldGroup objects to them, where both the
- *     data (Kokkos::View) and metadata (FieldHeader) inside will be shared across all copies
- *     of the field. This allow data and metadata to be always in sync.
- *     Note: output fields/groups are passed to an atm proc as read-write (i.e., non-const data type),
- *           while input ones are passed as read-only (i.e., const data type). Yes, the atm proc
- *           could cheat, and cast away the const, but we can't prevent that.
- *  6) All the atm inputs (that the AD can deduce by asking the atm proc group for the required fiedls)
- *     are initialized. For restart runs, all fields are read from a netcdf file (to allow BFB
- *     restarts), while for initial runs we offer a few more options (e.g., init a field to
- *     a constant, or as a copy of another field). During this process, we also set the initial
- *     time stamp on all the atm input fields.
- *     If an atm input is not found in the IC file, we'll error out, saving a DAG of the
- *     atm processes, which the user can inspect (to see what's missing in the IC file).
- *  7) All the atm process are initialized. During this call, atm process are able to set up
- *     all the internal structures that they were not able to init previously. For instance,
- *     they can set up remappers from the physics grid to the grid they operate on. They can
- *     also utilize their input fields to perform initialization of some internal data structure.
+ *     to allocate fields. For more details, see the documentation in the
+ * share/field/field_request.hpp header. 5) Set all the fields into the atm procs. Before this
+ * point, all the atm procs had were the FieldIdentifiers for their input/output fields and
+ * FieldGroupInfo for their input/output field groups. Now, we pass actual Field and FieldGroup
+ * objects to them, where both the data (Kokkos::View) and metadata (FieldHeader) inside will be
+ * shared across all copies of the field. This allow data and metadata to be always in sync. Note:
+ * output fields/groups are passed to an atm proc as read-write (i.e., non-const data type), while
+ * input ones are passed as read-only (i.e., const data type). Yes, the atm proc could cheat, and
+ * cast away the const, but we can't prevent that. 6) All the atm inputs (that the AD can deduce by
+ * asking the atm proc group for the required fiedls) are initialized. For restart runs, all fields
+ * are read from a netcdf file (to allow BFB restarts), while for initial runs we offer a few more
+ * options (e.g., init a field to a constant, or as a copy of another field). During this process,
+ * we also set the initial time stamp on all the atm input fields. If an atm input is not found in
+ * the IC file, we'll error out, saving a DAG of the atm processes, which the user can inspect (to
+ * see what's missing in the IC file). 7) All the atm process are initialized. During this call, atm
+ * process are able to set up all the internal structures that they were not able to init
+ * previously. For instance, they can set up remappers from the physics grid to the grid they
+ * operate on. They can also utilize their input fields to perform initialization of some internal
+ * data structure.
  *
  * For more info see header comments in the proper files:
  *  - for field                -> src/share/field/field.hpp
@@ -127,9 +126,10 @@ void AtmosphereDriver::init_scorpio(const int atm_id) {
   // Init scorpio right away, in case some class (atm procs, grids,...)
   // needs to source some data from NC files during construction,
   // before we start processing IC files.
-  EKAT_REQUIRE_MSG(!scorpio::is_subsystem_inited(),
-                   "Error! The PIO subsystem was alreday inited before the driver was constructed.\n"
-                   "       This is an unexpected behavior. Please, contact developers.\n");
+  EKAT_REQUIRE_MSG(
+      !scorpio::is_subsystem_inited(),
+      "Error! The PIO subsystem was alreday inited before the driver was constructed.\n"
+      "       This is an unexpected behavior. Please, contact developers.\n");
   scorpio::init_subsystem(m_atm_comm, atm_id);
 
   // In CIME runs, gptl is already inited. In standalone runs, it might
@@ -139,17 +139,19 @@ void AtmosphereDriver::init_scorpio(const int atm_id) {
   m_ad_status |= s_scorpio_inited;
 }
 
-void AtmosphereDriver::init_time_stamps(const util::TimeStamp &run_t0, const util::TimeStamp &case_t0, int run_type) {
+void AtmosphereDriver::init_time_stamps(const util::TimeStamp &run_t0,
+                                        const util::TimeStamp &case_t0, int run_type) {
   m_atm_logger->info("  [EAMxx] Run  start time stamp: " + run_t0.to_string());
   m_atm_logger->info("  [EAMxx] Case start time stamp: " + case_t0.to_string());
   m_atm_logger->flush(); // During init, flush often (to help debug crashes)
 
-  EKAT_REQUIRE_MSG(case_t0 <= run_t0, "Error! Case t0 time stamp must precede the run t0 time stamp.\n"
-                                      "  - case t0: " +
-                                          case_t0.to_string() +
-                                          "\n"
-                                          "  - run  t0: " +
-                                          run_t0.to_string() + "\n");
+  EKAT_REQUIRE_MSG(case_t0 <= run_t0,
+                   "Error! Case t0 time stamp must precede the run t0 time stamp.\n"
+                   "  - case t0: " +
+                       case_t0.to_string() +
+                       "\n"
+                       "  - run  t0: " +
+                       run_t0.to_string() + "\n");
 
   // Initialize time stamps
   m_run_t0 = m_current_ts = run_t0;
@@ -179,7 +181,8 @@ void AtmosphereDriver::setup_iop_data_manager() {
   check_ad_status(s_comm_set | s_params_set | s_ts_inited);
 
   // Check to make sure iop is not already initialized
-  EKAT_REQUIRE_MSG(not m_iop_data_manager, "Error! setup_iop_data_manager() is called, but IOP already set up.\n");
+  EKAT_REQUIRE_MSG(not m_iop_data_manager,
+                   "Error! setup_iop_data_manager() is called, but IOP already set up.\n");
 
   // This function should only be called if we are enabling IOP
   const bool enable_iop = m_atm_params.sublist("driver_options").get("enable_iop", false);
@@ -188,8 +191,9 @@ void AtmosphereDriver::setup_iop_data_manager() {
 
   // Params must include iop_options sublist.
   const auto iop_sublist_exists = m_atm_params.isSublist("iop_options");
-  EKAT_REQUIRE_MSG(iop_sublist_exists, "Error! setup_iop_data_manager() is called, but no iop_options "
-                                       "defined in parameters.\n");
+  EKAT_REQUIRE_MSG(iop_sublist_exists,
+                   "Error! setup_iop_data_manager() is called, but no iop_options "
+                   "defined in parameters.\n");
 
   const auto iop_params = m_atm_params.sublist("iop_options");
   const auto phys_grid  = m_grids_manager->get_grid("physics");
@@ -197,7 +201,8 @@ void AtmosphereDriver::setup_iop_data_manager() {
   const auto hyam       = phys_grid->get_geometry_data("hyam");
   const auto hybm       = phys_grid->get_geometry_data("hybm");
 
-  m_iop_data_manager = std::make_shared<IOPDataManager>(m_atm_comm, iop_params, m_run_t0, nlevs, hyam, hybm);
+  m_iop_data_manager =
+      std::make_shared<IOPDataManager>(m_atm_comm, iop_params, m_run_t0, nlevs, hyam, hybm);
 
   // Set IOP object in atm processes
   m_atm_process_group->set_iop_data_manager(m_iop_data_manager);
@@ -248,7 +253,7 @@ void AtmosphereDriver::create_grids() {
     // Restarted run -> read geo data from restart file
     const auto &provenance = m_atm_params.sublist("provenance");
     const auto &casename   = provenance.get<std::string>("rest_caseid");
-    auto filename          = find_filename_in_rpointer(casename + ".scream", true, m_atm_comm, m_run_t0);
+    auto filename = find_filename_in_rpointer(casename + ".scream", true, m_atm_comm, m_run_t0);
     gm_params.set("ic_filename", filename);
     m_atm_params.sublist("provenance").set("initial_conditions_file", filename);
   } else if (ic_pl.isParameter("filename")) {
@@ -298,15 +303,14 @@ void AtmosphereDriver::create_grids() {
   m_atm_logger->flush(); // During init, flush often (to help debug crashes)
 }
 
-void AtmosphereDriver::setup_surface_coupling_data_manager(SurfaceCouplingTransferType transfer_type,
-                                                           const int num_cpl_fields, const int num_scream_fields,
-                                                           const int field_size, Real *data_ptr,
+void AtmosphereDriver::setup_surface_coupling_data_manager(
+    SurfaceCouplingTransferType transfer_type, const int num_cpl_fields,
+    const int num_scream_fields, const int field_size, Real *data_ptr,
 #ifdef HAVE_MOAB
-                                                           Real *data_ptr_moab,
+    Real *data_ptr_moab,
 #endif
-                                                           char *names_ptr, int *cpl_indices_ptr, int *vec_comps_ptr,
-                                                           Real *constant_multiple_ptr,
-                                                           bool *do_transfer_during_init_ptr) {
+    char *names_ptr, int *cpl_indices_ptr, int *vec_comps_ptr, Real *constant_multiple_ptr,
+    bool *do_transfer_during_init_ptr) {
   std::shared_ptr<SCDataManager> sc_data_mgr;
 
   if (transfer_type == SurfaceCouplingTransferType::Import) {
@@ -347,7 +351,8 @@ void AtmosphereDriver::setup_surface_coupling_processes() const {
                        "but m_surface_coupling_import_data_manager was not "
                        "setup.\n");
 
-      std::shared_ptr<SurfaceCouplingImporter> importer = std::dynamic_pointer_cast<SurfaceCouplingImporter>(atm_proc);
+      std::shared_ptr<SurfaceCouplingImporter> importer =
+          std::dynamic_pointer_cast<SurfaceCouplingImporter>(atm_proc);
       importer->setup_surface_coupling_data(*m_surface_coupling_import_data_manager);
     }
     if (atm_proc->type() == AtmosphereProcessType::SurfaceCouplingExporter) {
@@ -358,7 +363,8 @@ void AtmosphereDriver::setup_surface_coupling_processes() const {
                        "but m_surface_coupling_export_data_manager was not "
                        "setup.\n");
 
-      std::shared_ptr<SurfaceCouplingExporter> exporter = std::dynamic_pointer_cast<SurfaceCouplingExporter>(atm_proc);
+      std::shared_ptr<SurfaceCouplingExporter> exporter =
+          std::dynamic_pointer_cast<SurfaceCouplingExporter>(atm_proc);
       exporter->setup_surface_coupling_data(*m_surface_coupling_export_data_manager);
     }
   }
@@ -366,12 +372,14 @@ void AtmosphereDriver::setup_surface_coupling_processes() const {
   // If import or export data manager is defined,
   // ensure corresponding atm process was found.
   if (m_surface_coupling_import_data_manager) {
-    EKAT_REQUIRE_MSG(importer_found, "Error! SurfaceCoupling importer data was setup, but no atm process "
-                                     "of type AtmosphereProcessType::SurfaceCouplingImporter exists.\n");
+    EKAT_REQUIRE_MSG(importer_found,
+                     "Error! SurfaceCoupling importer data was setup, but no atm process "
+                     "of type AtmosphereProcessType::SurfaceCouplingImporter exists.\n");
   }
   if (m_surface_coupling_export_data_manager) {
-    EKAT_REQUIRE_MSG(exporter_found, "Error! SurfaceCoupling exporter data was setup, but no atm process "
-                                     "of type AtmosphereProcessType::SurfaceCouplingExporter exists.\n");
+    EKAT_REQUIRE_MSG(exporter_found,
+                     "Error! SurfaceCoupling exporter data was setup, but no atm process "
+                     "of type AtmosphereProcessType::SurfaceCouplingExporter exists.\n");
   }
 }
 
@@ -404,21 +412,28 @@ void AtmosphereDriver::setup_column_conservation_checks() {
 
   // Get fields needed to run the mass and energy conservation checks. Require that
   // all fields exist.
-  EKAT_REQUIRE_MSG(
-      m_field_mgr->has_field("pseudo_density", phys_grid_name) and m_field_mgr->has_field("ps", phys_grid_name) and
-          m_field_mgr->has_field("phis", phys_grid_name) and m_field_mgr->has_field("horiz_winds", phys_grid_name) and
-          m_field_mgr->has_field("T_mid", phys_grid_name) and m_field_mgr->has_field("qv", phys_grid_name) and
-          m_field_mgr->has_field("qc", phys_grid_name) and m_field_mgr->has_field("qr", phys_grid_name) and
-          m_field_mgr->has_field("qi", phys_grid_name) and m_field_mgr->has_field("vapor_flux", phys_grid_name) and
-          m_field_mgr->has_field("water_flux", phys_grid_name) and
-          m_field_mgr->has_field("ice_flux", phys_grid_name) and m_field_mgr->has_field("heat_flux", phys_grid_name),
-      "Error! enable_column_conservation_checks=true for some atm process, "
-      "but not all fields needed for this check exist in the FieldManager.\n");
+  EKAT_REQUIRE_MSG(m_field_mgr->has_field("pseudo_density", phys_grid_name) and
+                       m_field_mgr->has_field("ps", phys_grid_name) and
+                       m_field_mgr->has_field("phis", phys_grid_name) and
+                       m_field_mgr->has_field("horiz_winds", phys_grid_name) and
+                       m_field_mgr->has_field("T_mid", phys_grid_name) and
+                       m_field_mgr->has_field("qv", phys_grid_name) and
+                       m_field_mgr->has_field("qc", phys_grid_name) and
+                       m_field_mgr->has_field("qr", phys_grid_name) and
+                       m_field_mgr->has_field("qi", phys_grid_name) and
+                       m_field_mgr->has_field("vapor_flux", phys_grid_name) and
+                       m_field_mgr->has_field("water_flux", phys_grid_name) and
+                       m_field_mgr->has_field("ice_flux", phys_grid_name) and
+                       m_field_mgr->has_field("heat_flux", phys_grid_name),
+                   "Error! enable_column_conservation_checks=true for some atm process, "
+                   "but not all fields needed for this check exist in the FieldManager.\n");
 
   // Get tolerances for mass and energy checks from driver_option parameters.
-  auto &driver_options_pl     = m_atm_params.sublist("driver_options");
-  const Real mass_error_tol   = driver_options_pl.get<double>("mass_column_conservation_error_tolerance", 1e-10);
-  const Real energy_error_tol = driver_options_pl.get<double>("energy_column_conservation_error_tolerance", 1e-14);
+  auto &driver_options_pl = m_atm_params.sublist("driver_options");
+  const Real mass_error_tol =
+      driver_options_pl.get<double>("mass_column_conservation_error_tolerance", 1e-10);
+  const Real energy_error_tol =
+      driver_options_pl.get<double>("energy_column_conservation_error_tolerance", 1e-14);
 
   // Create energy checker
   const auto pseudo_density = m_field_mgr->get_field("pseudo_density", phys_grid_name);
@@ -436,12 +451,12 @@ void AtmosphereDriver::setup_column_conservation_checks() {
   const auto heat_flux      = m_field_mgr->get_field("heat_flux", phys_grid_name);
 
   auto conservation_check = std::make_shared<MassAndEnergyColumnConservationCheck>(
-      phys_grid, mass_error_tol, energy_error_tol, pseudo_density, ps, phis, horiz_winds, T_mid, qv, qc, qr, qi,
-      vapor_flux, water_flux, ice_flux, heat_flux);
+      phys_grid, mass_error_tol, energy_error_tol, pseudo_density, ps, phis, horiz_winds, T_mid, qv,
+      qc, qr, qi, vapor_flux, water_flux, ice_flux, heat_flux);
 
   // Get fail handling type from driver_option parameters.
-  const std::string fail_handling_type_str =
-      driver_options_pl.get<std::string>("column_conservation_checks_fail_handling_type", "warning");
+  const std::string fail_handling_type_str = driver_options_pl.get<std::string>(
+      "column_conservation_checks_fail_handling_type", "warning");
 
   CheckFailHandling fail_handling_type;
   if (fail_handling_type_str == "warning") {
@@ -459,10 +474,12 @@ void AtmosphereDriver::setup_column_conservation_checks() {
 }
 
 void AtmosphereDriver::setup_shoc_tms_links() {
-  EKAT_REQUIRE_MSG(m_atm_process_group->has_process("tms"), "Error! Attempting to setup link between "
-                                                            "SHOC and TMS, but TMS is not defined.\n");
-  EKAT_REQUIRE_MSG(m_atm_process_group->has_process("shoc"), "Error! Attempting to setup link between "
-                                                             "SHOC and TMS, but SHOC is not defined.\n");
+  EKAT_REQUIRE_MSG(m_atm_process_group->has_process("tms"),
+                   "Error! Attempting to setup link between "
+                   "SHOC and TMS, but TMS is not defined.\n");
+  EKAT_REQUIRE_MSG(m_atm_process_group->has_process("shoc"),
+                   "Error! Attempting to setup link between "
+                   "SHOC and TMS, but SHOC is not defined.\n");
 
   auto shoc_process = m_atm_process_group->get_process_nonconst("shoc");
   shoc_process->get_params().set<bool>("apply_tms", true);
@@ -484,7 +501,8 @@ void AtmosphereDriver::add_additional_column_data_to_property_checks() {
                      "Error! The field " + fname +
                          " is requested for property "
                          "check output but does not exist on the physics grid.\n");
-    m_atm_process_group->add_additional_data_fields_to_property_checks(m_field_mgr->get_field(fname, grid_name));
+    m_atm_process_group->add_additional_data_fields_to_property_checks(
+        m_field_mgr->get_field(fname, grid_name));
   }
 }
 
@@ -615,7 +633,8 @@ void AtmosphereDriver::create_fields() {
     desc = "content of the EAMxx FieldManager corresponding to the 'physics' grid.\n"
            "The dict keys are the field names as used in EAMxx.\n"
            "For each field, we add the following entries:\n"
-           "  - standard_name: the name commonly used to refer to this field in atm sciences (if applicable)\n"
+           "  - standard_name: the name commonly used to refer to this field in atm sciences (if "
+           "applicable)\n"
            "  - units: the units for this field used in EAMxx\n"
            "  - layout: the names of the dimensions for this field (time excluded)\n"
            "  - providers: the atm processes that update/compute this field\n"
@@ -679,9 +698,10 @@ void AtmosphereDriver::create_output_managers() {
     m_restart_output_manager->initialize(m_atm_comm, params, m_run_t0, m_case_t0,
                                          /*is_model_restart_output*/ true);
 
-    // Store the "Output Control" pl of the model restart as the "checkpoint_control" for all other output streams
-    checkpoint_params.set<std::string>("frequency_units",
-                                       params.sublist("output_control").get<std::string>("frequency_units"));
+    // Store the "Output Control" pl of the model restart as the "checkpoint_control" for all other
+    // output streams
+    checkpoint_params.set<std::string>(
+        "frequency_units", params.sublist("output_control").get<std::string>("frequency_units"));
     checkpoint_params.set("frequency", params.sublist("output_control").get<int>("frequency"));
   }
 
@@ -696,7 +716,8 @@ void AtmosphereDriver::create_output_managers() {
     checkpoint_pl.set("frequency_units", checkpoint_params.get<std::string>("frequency_units"));
     checkpoint_pl.set("frequency", checkpoint_params.get<int>("frequency"));
 
-    // Check if the filename prefix for this file has already been set.  If not, use the simulation casename.
+    // Check if the filename prefix for this file has already been set.  If not, use the simulation
+    // casename.
     if (not params.isParameter("filename_prefix")) {
       params.set<std::string>("filename_prefix", m_casename + ".scream.h");
     }
@@ -742,8 +763,9 @@ void AtmosphereDriver::initialize_output_managers() {
 
   // Setup output managers
   for (auto &om : m_output_managers) {
-    EKAT_REQUIRE_MSG(not om.is_restart(), "Error! No restart output should be in m_output_managers. Model restart "
-                                          "output should be setup in m_restart_output_manager./n");
+    EKAT_REQUIRE_MSG(not om.is_restart(),
+                     "Error! No restart output should be in m_output_managers. Model restart "
+                     "output should be setup in m_restart_output_manager./n");
 
     om.set_logger(m_atm_logger);
     om.setup(m_field_mgr, m_grids_manager->get_grid_names());
@@ -757,8 +779,9 @@ void AtmosphereDriver::initialize_output_managers() {
   m_atm_logger->flush(); // During init, flush often (to help debug crashes)
 }
 
-void AtmosphereDriver::set_provenance_data(std::string caseid, std::string rest_caseid, std::string hostname,
-                                           std::string username, std::string versionid) {
+void AtmosphereDriver::set_provenance_data(std::string caseid, std::string rest_caseid,
+                                           std::string hostname, std::string username,
+                                           std::string versionid) {
 #ifdef SCREAM_CIME_BUILD
   // Check the inputs are valid
   EKAT_REQUIRE_MSG(caseid != "", "Error! Invalid case id: " + caseid + "\n");
@@ -803,7 +826,8 @@ void AtmosphereDriver::initialize_fields() {
   start_timer("EAMxx::init");
   start_timer("EAMxx::initialize_fields");
 
-  // See the [rrtmgp active gases] note in share/util/eamxx_fv_phys_rrtmgp_active_gases_workaround.hpp
+  // See the [rrtmgp active gases] note in
+  // share/util/eamxx_fv_phys_rrtmgp_active_gases_workaround.hpp
   if (fvphyshack) {
     TraceGasesWorkaround::singleton().run_type = m_run_type;
   }
@@ -862,7 +886,8 @@ void AtmosphereDriver::initialize_fields() {
   long long my_mem_usage = get_mem_usage(MB);
   long long max_mem_usage;
   m_atm_comm.all_reduce(&my_mem_usage, &max_mem_usage, 1, MPI_MAX);
-  m_atm_logger->debug("[EAMxx::init::initialize_fields] memory usage: " + std::to_string(max_mem_usage) + "MB");
+  m_atm_logger->debug(
+      "[EAMxx::init::initialize_fields] memory usage: " + std::to_string(max_mem_usage) + "MB");
 #endif
   stop_timer("EAMxx::initialize_fields");
   stop_timer("EAMxx::init");
@@ -876,7 +901,7 @@ void AtmosphereDriver::restart_model() {
   // First, figure out the name of the netcdf file containing the restart data
   const auto &provenance = m_atm_params.sublist("provenance");
   const auto &casename   = provenance.get<std::string>("rest_caseid");
-  auto filename          = find_filename_in_rpointer(casename + ".scream", true, m_atm_comm, m_run_t0);
+  auto filename = find_filename_in_rpointer(casename + ".scream", true, m_atm_comm, m_run_t0);
 
   m_atm_logger->info("    [EAMxx] Restart filename: " + filename);
 
@@ -910,13 +935,15 @@ void AtmosphereDriver::restart_model() {
     if (any.isType<int>()) {
       ekat::any_cast<int>(any) = scorpio::get_attribute<int>(filename, "GLOBAL", name);
     } else if (any.isType<std::int64_t>()) {
-      ekat::any_cast<std::int64_t>(any) = scorpio::get_attribute<std::int64_t>(filename, "GLOBAL", name);
+      ekat::any_cast<std::int64_t>(any) =
+          scorpio::get_attribute<std::int64_t>(filename, "GLOBAL", name);
     } else if (any.isType<float>()) {
       ekat::any_cast<float>(any) = scorpio::get_attribute<float>(filename, "GLOBAL", name);
     } else if (any.isType<double>()) {
       ekat::any_cast<double>(any) = scorpio::get_attribute<double>(filename, "GLOBAL", name);
     } else if (any.isType<std::string>()) {
-      ekat::any_cast<std::string>(any) = scorpio::get_attribute<std::string>(filename, "GLOBAL", name);
+      ekat::any_cast<std::string>(any) =
+          scorpio::get_attribute<std::string>(filename, "GLOBAL", name);
     } else {
       EKAT_ERROR_MSG("Error! Unrecognized/unsupported concrete type for restart extra data.\n"
                      " - extra data name  : " +
@@ -966,7 +993,8 @@ void AtmosphereDriver::create_logger() {
   };
 
   using logger_t = Logger<LogBasicFile, LogRootRank>;
-  m_atm_logger   = std::make_shared<logger_t>(log_fname, str2lev(log_level, "atm_log_level"), m_atm_comm, "");
+  m_atm_logger =
+      std::make_shared<logger_t>(log_fname, str2lev(log_level, "atm_log_level"), m_atm_comm, "");
   m_atm_logger->flush_on(str2lev(flush_level, "atm_flush_level"));
   m_atm_logger->set_no_format();
 
@@ -1045,8 +1073,9 @@ void AtmosphereDriver::set_initial_conditions() {
       } else if (fname == "sgh30") {
         // The eamxx field "sgh30" is called "SGH30" in the
         // topography file and is only available on the PG2 grid.
-        EKAT_ASSERT_MSG(grid_name == "physics_pg2", "Error! Requesting sgh30 field on " + grid_name +
-                                                        " topo file only has sgh30 for physics_pg2.\n");
+        EKAT_ASSERT_MSG(grid_name == "physics_pg2",
+                        "Error! Requesting sgh30 field on " + grid_name +
+                            " topo file only has sgh30 for physics_pg2.\n");
         topography_file_fields_names[grid_name].push_back("SGH30");
         topography_eamxx_fields_names[grid_name].push_back(fname);
         m_fields_inited[grid_name].push_back(fname);
@@ -1144,9 +1173,11 @@ void AtmosphereDriver::set_initial_conditions() {
     for (const auto &it : m_grids_manager->get_repo()) {
       const auto &grid      = it.second;
       const auto &grid_name = grid->name();
-      if (ic_fields_names[grid_name].size() > 0 or topography_eamxx_fields_names[grid_name].size() > 0) {
-        const auto &file_name = grid_name == "physics_gll" ? ic_pl.get<std::string>("filename")
-                                                           : ic_pl.get<std::string>("topography_filename");
+      if (ic_fields_names[grid_name].size() > 0 or
+          topography_eamxx_fields_names[grid_name].size() > 0) {
+        const auto &file_name = grid_name == "physics_gll"
+                                    ? ic_pl.get<std::string>("filename")
+                                    : ic_pl.get<std::string>("topography_filename");
         m_iop_data_manager->setup_io_info(file_name, grid);
       }
     }
@@ -1224,7 +1255,8 @@ void AtmosphereDriver::set_initial_conditions() {
         // The groups monolithic field has not been inited. Check if all the subfields
         // have been inited. If so, init the timestamp of the monlithic field too.
         const auto &children = track.get_children();
-        bool all_inited      = children.size() > 0; // If no children, then something is off, so mark as not good
+        bool all_inited =
+            children.size() > 0; // If no children, then something is off, so mark as not good
         for (auto wp : children) {
           auto sp = wp.lock();
           if (not sp->get_time_stamp().is_valid()) {
@@ -1324,7 +1356,8 @@ void AtmosphereDriver::set_initial_conditions() {
     // Setup RNG. There are two relevant params: generate_perturbation_random_seed and
     // perturbation_random_seed. We have 3 cases:
     //   1. Parameter generate_perturbation_random_seed is set true, assert perturbation_random_seed
-    //      is not given and generate a random seed using std::rand() to get an integer random value.
+    //      is not given and generate a random seed using std::rand() to get an integer random
+    //      value.
     //   2. Parameter perturbation_random_seed is given, use this value for the seed.
     //   3. Parameter perturbation_random_seed is not given and generate_perturbation_random_seed is
     //      not given, use 0 as the random seed.
@@ -1357,8 +1390,8 @@ void AtmosphereDriver::set_initial_conditions() {
     constexpr auto ps0      = physics::Constants<Real>::P0;
     const auto min_pressure = ic_pl.get<Real>("perturbation_minimum_pressure", 1050.0);
     auto pressure_mask      = [&](const int ilev) {
-      const auto pref =
-          (hyam_h(ilev) * ps0 + hybm_h(ilev) * ps0) / 100; // Reference pressure ps0 is in Pa, convert to millibar
+      const auto pref = (hyam_h(ilev) * ps0 + hybm_h(ilev) * ps0) /
+                        100; // Reference pressure ps0 is in Pa, convert to millibar
       return pref > min_pressure;
     };
 
@@ -1366,13 +1399,14 @@ void AtmosphereDriver::set_initial_conditions() {
     const std::string gll_grid_name = gll_grid->name();
     for (size_t f = 0; f < perturbed_fields.size(); ++f) {
       const auto fname = perturbed_fields[f];
-      EKAT_REQUIRE_MSG(ekat::contains(m_fields_inited[gll_grid_name], fname),
-                       "Error! Attempting to apply perturbation to field not in initial_conditions.\n"
-                       "  - Field: " +
-                           fname +
-                           "\n"
-                           "  - Grid:  " +
-                           gll_grid_name + "\n");
+      EKAT_REQUIRE_MSG(
+          ekat::contains(m_fields_inited[gll_grid_name], fname),
+          "Error! Attempting to apply perturbation to field not in initial_conditions.\n"
+          "  - Field: " +
+              fname +
+              "\n"
+              "  - Grid:  " +
+              gll_grid_name + "\n");
 
       auto field = m_field_mgr->get_field(fname, gll_grid_name);
       perturb(field, engine, pdf, seed, pressure_mask, gll_grid->get_dofs_gids());
@@ -1397,7 +1431,8 @@ void AtmosphereDriver::read_fields_from_file(const std::vector<Field> &fields,
   ic_reader.read_variables();
 }
 
-void AtmosphereDriver::initialize_constant_field(const FieldIdentifier &fid, const ekat::ParameterList &ic_pl) {
+void AtmosphereDriver::initialize_constant_field(const FieldIdentifier &fid,
+                                                 const ekat::ParameterList &ic_pl) {
   auto f = m_field_mgr->get_field(fid);
   // The user provided a constant value for this field. Simply use that.
   const auto &layout = f.get_header().get_identifier().get_layout();
@@ -1413,14 +1448,14 @@ void AtmosphereDriver::initialize_constant_field(const FieldIdentifier &fid, con
     const auto idim    = layout.get_vector_component_idx();
     const auto vec_dim = layout.get_vector_dim();
     const auto &values = ic_pl.get<std::vector<double>>(name);
-    EKAT_REQUIRE_MSG(values.size() == static_cast<size_t>(vec_dim), "Error! Initial condition values array for '" +
-                                                                        name +
-                                                                        "' has the wrong dimension.\n"
-                                                                        "       Field dimension: " +
-                                                                        std::to_string(vec_dim) +
-                                                                        "\n"
-                                                                        "       Array dimenions: " +
-                                                                        std::to_string(values.size()) + "\n");
+    EKAT_REQUIRE_MSG(values.size() == static_cast<size_t>(vec_dim),
+                     "Error! Initial condition values array for '" + name +
+                         "' has the wrong dimension.\n"
+                         "       Field dimension: " +
+                         std::to_string(vec_dim) +
+                         "\n"
+                         "       Array dimenions: " +
+                         std::to_string(values.size()) + "\n");
 
     if (layout.rank() == 2 && idim == 1) {
       // We cannot use 'get_component' for views of rank 2 with vector dimension
@@ -1569,10 +1604,10 @@ void AtmosphereDriver::run(const int dt) {
   EKAT_REQUIRE_MSG(dt > 0, "Error! Input time step must be positive.\n");
 
   // Print current timestamp information
-  m_atm_logger->log(ekat::logger::LogLevel::info, "Atmosphere step = " + std::to_string(m_current_ts.get_num_steps()) +
-                                                      "\n" +
-                                                      "  model start-of-step time = " + m_current_ts.get_date_string() +
-                                                      " " + m_current_ts.get_time_string() + "\n");
+  m_atm_logger->log(ekat::logger::LogLevel::info,
+                    "Atmosphere step = " + std::to_string(m_current_ts.get_num_steps()) + "\n" +
+                        "  model start-of-step time = " + m_current_ts.get_date_string() + " " +
+                        m_current_ts.get_time_string() + "\n");
 
   // Reset accum fields to 0
   // Note: at the 1st timestep this is redundant, since we did it at init,
@@ -1749,7 +1784,8 @@ void AtmosphereDriver::report_res_dep_memory_footprint() const {
 
     my_dev_mem_usage += sizeof(AbstractGrid::gid_type) * nldofs;
 
-    my_dev_mem_usage += sizeof(int) * grid->get_lid_to_idx_map().get_header().get_identifier().get_layout().size();
+    my_dev_mem_usage +=
+        sizeof(int) * grid->get_lid_to_idx_map().get_header().get_identifier().get_layout().size();
 
     const auto &geo_names = grid->get_geometry_data_names();
     my_dev_mem_usage += sizeof(Real) * geo_names.size() * nldofs;
@@ -1769,13 +1805,13 @@ void AtmosphereDriver::report_res_dep_memory_footprint() const {
   }
 
   m_atm_comm.all_reduce(&my_dev_mem_usage, &max_dev_mem_usage, 1, MPI_MAX);
-  m_atm_logger->info(
-      "[EAMxx::init] resolution-dependent device memory footprint: " + std::to_string(max_dev_mem_usage / 1e6) + "MB");
+  m_atm_logger->info("[EAMxx::init] resolution-dependent device memory footprint: " +
+                     std::to_string(max_dev_mem_usage / 1e6) + "MB");
 
   if (not std::is_same<HostDevice, DefaultDevice>::value) {
     m_atm_comm.all_reduce(&my_host_mem_usage, &max_host_mem_usage, 1, MPI_MAX);
-    m_atm_logger->info(
-        "[EAMxx::init] resolution-dependent host memory footprint: " + std::to_string(max_host_mem_usage / 1e6) + "MB");
+    m_atm_logger->info("[EAMxx::init] resolution-dependent host memory footprint: " +
+                       std::to_string(max_host_mem_usage / 1e6) + "MB");
   }
 
   // The following is a memory usage based on probing some OS tools
@@ -1783,8 +1819,8 @@ void AtmosphereDriver::report_res_dep_memory_footprint() const {
   long long my_mem_usage_from_os = get_mem_usage(MB);
   long long max_mem_usage_from_os;
   m_atm_comm.all_reduce(&my_mem_usage_from_os, &max_mem_usage_from_os, 1, MPI_MAX);
-  m_atm_logger->info("[EAMxx::init] memory usage from OS probing tools: " + std::to_string(max_mem_usage_from_os) +
-                     "MB");
+  m_atm_logger->info("[EAMxx::init] memory usage from OS probing tools: " +
+                     std::to_string(max_mem_usage_from_os) + "MB");
 #endif
 }
 
diff --git i/components/eamxx/src/control/atmosphere_driver.hpp w/components/eamxx/src/control/atmosphere_driver.hpp
index 9bf589721d..07cc02bf0e 100644
--- i/components/eamxx/src/control/atmosphere_driver.hpp
+++ w/components/eamxx/src/control/atmosphere_driver.hpp
@@ -65,7 +65,8 @@ public:
 
   // Init time stamps
   // run_type: -1: deduce from run/case t0, 0: initial, 1: restart
-  void init_time_stamps(const util::TimeStamp &run_t0, const util::TimeStamp &case_t0, int run_type = -1);
+  void init_time_stamps(const util::TimeStamp &run_t0, const util::TimeStamp &case_t0,
+                        int run_type = -1);
 
   // Set AD params
   void init_scorpio(const int atm_id = 0);
@@ -83,13 +84,15 @@ public:
   void create_fields();
 
   // Adds cpl import/export information to SCDataManager.
-  void setup_surface_coupling_data_manager(SurfaceCouplingTransferType transfer_type, const int num_cpl_fields,
-                                           const int num_scream_fields, const int field_size, Real *data_ptr,
+  void setup_surface_coupling_data_manager(SurfaceCouplingTransferType transfer_type,
+                                           const int num_cpl_fields, const int num_scream_fields,
+                                           const int field_size, Real *data_ptr,
 #ifdef HAVE_MOAB
                                            Real *data_ptr_moab,
 #endif
-                                           char *names_ptr, int *cpl_indices_ptr, int *vec_comps_ptr,
-                                           Real *constant_multiple_ptr, bool *do_transfer_during_init_ptr);
+                                           char *names_ptr, int *cpl_indices_ptr,
+                                           int *vec_comps_ptr, Real *constant_multiple_ptr,
+                                           bool *do_transfer_during_init_ptr);
 
   // Find surface coupling processes and have
   // them setup internal SurfaceCoupling data.
@@ -110,8 +113,9 @@ public:
   // for use in output.
   void add_additional_column_data_to_property_checks();
 
-  void set_provenance_data(std::string caseid = "", std::string rest_caseid = "", std::string hostname = "",
-                           std::string username = "", std::string versionid = "");
+  void set_provenance_data(std::string caseid = "", std::string rest_caseid = "",
+                           std::string hostname = "", std::string username = "",
+                           std::string versionid = "");
 
   // Load initial conditions for atm inputs
   void initialize_fields();
@@ -133,18 +137,18 @@ public:
   //  - params: parameter list with all atm options (organized in sublists)
   //  - run_t0 : the time stamp where the run starts
   //  - case_t0: the time stamp where the original simulation started (for restarts)
-  void initialize(const ekat::Comm &atm_comm, const ekat::ParameterList &params, const util::TimeStamp &run_t0,
-                  const util::TimeStamp &case_t0);
+  void initialize(const ekat::Comm &atm_comm, const ekat::ParameterList &params,
+                  const util::TimeStamp &run_t0, const util::TimeStamp &case_t0);
 
   // Shortcut for tests not doing restart
-  void initialize(const ekat::Comm &atm_comm, const ekat::ParameterList &params, const util::TimeStamp &t0) {
+  void initialize(const ekat::Comm &atm_comm, const ekat::ParameterList &params,
+                  const util::TimeStamp &t0) {
     initialize(atm_comm, params, t0, t0);
   }
 
   // The run method is responsible for advancing the atmosphere component by one atm time step
-  // Inside here you should find calls to the run method of each subcomponent, including parameterizations
-  // and dynamics (HOMME).
-  // Note: dt is assumed to be in seconds
+  // Inside here you should find calls to the run method of each subcomponent, including
+  // parameterizations and dynamics (HOMME). Note: dt is assumed to be in seconds
   void run(const int dt);
 
   // Clean up the driver (finalizes and cleans up all internals)
@@ -160,7 +164,9 @@ public:
 
   const std::shared_ptr<ATMBufferManager> &get_memory_buffer() const { return m_memory_buffer; }
 
-  const std::shared_ptr<AtmosphereProcessGroup> &get_atm_processes() const { return m_atm_process_group; }
+  const std::shared_ptr<AtmosphereProcessGroup> &get_atm_processes() const {
+    return m_atm_process_group;
+  }
 
 #ifndef KOKKOS_ENABLE_CUDA
   // Cuda requires methods enclosing __device__ lambda's to be public
@@ -176,7 +182,8 @@ protected:
   void restart_model();
 
   // Read fields from a file
-  void read_fields_from_file(const std::vector<Field> &fields, const std::shared_ptr<const AbstractGrid> &grid,
+  void read_fields_from_file(const std::vector<Field> &fields,
+                             const std::shared_ptr<const AbstractGrid> &grid,
                              const std::string &file_name);
   void register_groups();
 
diff --git i/components/eamxx/src/control/atmosphere_surface_coupling_exporter.cpp w/components/eamxx/src/control/atmosphere_surface_coupling_exporter.cpp
index ba44bd51a1..ae91afb3fa 100644
--- i/components/eamxx/src/control/atmosphere_surface_coupling_exporter.cpp
+++ w/components/eamxx/src/control/atmosphere_surface_coupling_exporter.cpp
@@ -9,7 +9,8 @@
 
 namespace scream {
 // =========================================================================================
-SurfaceCouplingExporter::SurfaceCouplingExporter(const ekat::Comm &comm, const ekat::ParameterList &params)
+SurfaceCouplingExporter::SurfaceCouplingExporter(const ekat::Comm &comm,
+                                                 const ekat::ParameterList &params)
     : AtmosphereProcess(comm, params) {}
 // =========================================================================================
 void SurfaceCouplingExporter::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
@@ -40,8 +41,8 @@ void SurfaceCouplingExporter::set_grids(const std::shared_ptr<const GridsManager
   add_field<Required>("p_mid", scalar3d_layout_mid, Pa, grid_name, ps);
   add_field<Required>("T_mid", scalar3d_layout_mid, K, grid_name, ps);
   add_tracer<Required>("qv", m_grid, kg / kg, ps);
-  // TODO: Switch horiz_winds to using U and V, note right now there is an issue with when the subfields are created, so
-  // can't switch yet.
+  // TODO: Switch horiz_winds to using U and V, note right now there is an issue with when the
+  // subfields are created, so can't switch yet.
   add_field<Required>("horiz_winds", vector3d_layout, m / s, grid_name);
   add_field<Required>("sfc_flux_dir_nir", scalar2d_layout, W / m2, grid_name);
   add_field<Required>("sfc_flux_dir_vis", scalar2d_layout, W / m2, grid_name);
@@ -71,7 +72,8 @@ void SurfaceCouplingExporter::set_grids(const std::shared_ptr<const GridsManager
   create_helper_field("Faxa_lwdn", scalar2d_layout, grid_name);
 }
 // =========================================================================================
-void SurfaceCouplingExporter::create_helper_field(const std::string &name, const FieldLayout &layout,
+void SurfaceCouplingExporter::create_helper_field(const std::string &name,
+                                                  const FieldLayout &layout,
                                                   const std::string &grid_name) {
   using namespace ekat::units;
   FieldIdentifier id(name, layout, Units::nondimensional(), grid_name);
@@ -88,7 +90,8 @@ void SurfaceCouplingExporter::create_helper_field(const std::string &name, const
 size_t SurfaceCouplingExporter::requested_buffer_size_in_bytes() const {
   // Number of Reals needed by local views in the interface
   return Buffer::num_2d_vector_mid * m_num_cols * ekat::npack<Spack>(m_num_levs) * sizeof(Spack) +
-         Buffer::num_2d_vector_int * m_num_cols * ekat::npack<Spack>(m_num_levs + 1) * sizeof(Spack);
+         Buffer::num_2d_vector_int * m_num_cols * ekat::npack<Spack>(m_num_levs + 1) *
+             sizeof(Spack);
 }
 // =========================================================================================
 void SurfaceCouplingExporter::init_buffers(const ATMBufferManager &buffer_manager) {
@@ -120,31 +123,35 @@ void SurfaceCouplingExporter::setup_surface_coupling_data(const SCDataManager &s
   m_num_cpl_exports    = sc_data_manager.get_num_cpl_fields();
   m_num_scream_exports = sc_data_manager.get_num_scream_fields();
 
-  EKAT_ASSERT_MSG(m_num_scream_exports <= m_num_cpl_exports, "Error! More SCREAM exports than actual cpl exports.\n");
+  EKAT_ASSERT_MSG(m_num_scream_exports <= m_num_cpl_exports,
+                  "Error! More SCREAM exports than actual cpl exports.\n");
   EKAT_ASSERT_MSG(m_num_cols == sc_data_manager.get_field_size(),
                   "Error! Surface Coupling exports need to have size ncols.");
 
   // The export data is of size ncols,num_cpl_exports. All other data is of size num_scream_exports
-  m_cpl_exports_view_h =
-      decltype(m_cpl_exports_view_h)(sc_data_manager.get_field_data_ptr(), m_num_cols, m_num_cpl_exports);
+  m_cpl_exports_view_h = decltype(m_cpl_exports_view_h)(sc_data_manager.get_field_data_ptr(),
+                                                        m_num_cols, m_num_cpl_exports);
   m_cpl_exports_view_d = Kokkos::create_mirror_view(DefaultDevice(), m_cpl_exports_view_h);
 
 #ifdef HAVE_MOAB
   // The export data is of size num_cpl_exports,ncols. All other data is of size num_scream_exports
-  m_moab_cpl_exports_view_h =
-      decltype(m_moab_cpl_exports_view_h)(sc_data_manager.get_field_data_moab_ptr(), m_num_cpl_exports, m_num_cols);
-  m_moab_cpl_exports_view_d = Kokkos::create_mirror_view(DefaultDevice(), m_moab_cpl_exports_view_h);
+  m_moab_cpl_exports_view_h = decltype(m_moab_cpl_exports_view_h)(
+      sc_data_manager.get_field_data_moab_ptr(), m_num_cpl_exports, m_num_cols);
+  m_moab_cpl_exports_view_d =
+      Kokkos::create_mirror_view(DefaultDevice(), m_moab_cpl_exports_view_h);
 #endif
 
   m_export_field_names = new name_t[m_num_scream_exports];
-  std::memcpy(m_export_field_names, sc_data_manager.get_field_name_ptr(), m_num_scream_exports * 32 * sizeof(char));
+  std::memcpy(m_export_field_names, sc_data_manager.get_field_name_ptr(),
+              m_num_scream_exports * 32 * sizeof(char));
 
-  m_cpl_indices_view = decltype(m_cpl_indices_view)(sc_data_manager.get_field_cpl_indices_ptr(), m_num_scream_exports);
+  m_cpl_indices_view = decltype(m_cpl_indices_view)(sc_data_manager.get_field_cpl_indices_ptr(),
+                                                    m_num_scream_exports);
 
-  m_vector_components_view =
-      decltype(m_vector_components_view)(sc_data_manager.get_field_vector_components_ptr(), m_num_scream_exports);
-  m_constant_multiple_view =
-      decltype(m_constant_multiple_view)(sc_data_manager.get_field_constant_multiple_ptr(), m_num_scream_exports);
+  m_vector_components_view = decltype(m_vector_components_view)(
+      sc_data_manager.get_field_vector_components_ptr(), m_num_scream_exports);
+  m_constant_multiple_view = decltype(m_constant_multiple_view)(
+      sc_data_manager.get_field_constant_multiple_ptr(), m_num_scream_exports);
   m_do_export_during_init_view = decltype(m_do_export_during_init_view)(
       sc_data_manager.get_field_transfer_during_init_ptr(), m_num_scream_exports);
 
@@ -159,20 +166,21 @@ void SurfaceCouplingExporter::initialize_impl(const RunType /* run_type */) {
 
     std::string fname = m_export_field_names[i];
     m_export_field_names_vector.push_back(fname);
-    EKAT_REQUIRE_MSG(has_helper_field(fname),
-                     "Error! Attempting to export " + fname + " which has not been added as a helper field.\n");
+    EKAT_REQUIRE_MSG(has_helper_field(fname), "Error! Attempting to export " + fname +
+                                                  " which has not been added as a helper field.\n");
     auto &field = m_helper_fields.at(fname);
 
     // Check that is valid
-    EKAT_REQUIRE_MSG(field.is_allocated(), "Error! Export field view has not been allocated yet.\n");
+    EKAT_REQUIRE_MSG(field.is_allocated(),
+                     "Error! Export field view has not been allocated yet.\n");
 
     // Set view data ptr. Since the field could be only "Required", we
     // must use the unsafe version of the get_internal_view_data().
     m_column_info_h(i).data = field.get_internal_view_data_unsafe<Real>();
 
     // Get column info from field utility function
-    get_col_info_for_surface_values(field.get_header_ptr(), m_vector_components_view(i), m_column_info_h(i).col_offset,
-                                    m_column_info_h(i).col_stride);
+    get_col_info_for_surface_values(field.get_header_ptr(), m_vector_components_view(i),
+                                    m_column_info_h(i).col_offset, m_column_info_h(i).col_stride);
 
     // Set constant multiple
     m_column_info_h(i).constant_multiple = m_constant_multiple_view(i);
@@ -194,8 +202,9 @@ void SurfaceCouplingExporter::initialize_impl(const RunType /* run_type */) {
   using vor_type    = std::vector<Real>;
   m_export_source   = view_1d<DefaultDevice, ExportType>("", m_num_scream_exports);
   m_export_source_h = Kokkos::create_mirror_view(m_export_source);
-  Kokkos::deep_copy(m_export_source_h,
-                    FROM_MODEL); // The default is that all export variables will be derived from the EAMxx state.
+  Kokkos::deep_copy(
+      m_export_source_h,
+      FROM_MODEL); // The default is that all export variables will be derived from the EAMxx state.
   m_num_from_model_exports = m_num_scream_exports;
 
   // Parse all fields that will be set by interpolating data from file(s):
@@ -203,18 +212,20 @@ void SurfaceCouplingExporter::initialize_impl(const RunType /* run_type */) {
     // Retrieve the parameters for prescribed from file
     auto export_from_file_params = m_params.sublist("prescribed_from_file");
     EKAT_REQUIRE_MSG(export_from_file_params.isParameter("fields"),
-                     "Error! surface_coupling_exporter::init - prescribed_from_file does not have 'fields' parameter.");
+                     "Error! surface_coupling_exporter::init - prescribed_from_file does not have "
+                     "'fields' parameter.");
     auto export_from_file_fields = export_from_file_params.get<vos_type>("fields");
 
     EKAT_REQUIRE_MSG(export_from_file_params.isParameter("files"),
-                     "Error! surface_coupling_exporter::init - prescribed_from_file does not have 'files' parameter.");
+                     "Error! surface_coupling_exporter::init - prescribed_from_file does not have "
+                     "'files' parameter.");
     auto export_from_file_names = export_from_file_params.get<vos_type>("files");
 
     bool are_fields_present = export_from_file_fields.size() > 0;
     bool are_files_present  = export_from_file_names.size() > 0;
-    EKAT_REQUIRE_MSG(
-        are_files_present == are_fields_present,
-        "ERROR!! When prescribing export fields from file, you must provide both fields names and file name(s).\n");
+    EKAT_REQUIRE_MSG(are_files_present == are_fields_present,
+                     "ERROR!! When prescribing export fields from file, you must provide both "
+                     "fields names and file name(s).\n");
     bool do_export_from_file = are_fields_present and are_files_present;
     if (do_export_from_file) {
       vos_type export_from_file_reg_names;
@@ -225,9 +236,10 @@ void SurfaceCouplingExporter::initialize_impl(const RunType /* run_type */) {
       for (auto entry : alt_names) {
         ekat::strip(entry, ' '); // remove empty spaces in case user did `a : b`
         auto tokens = ekat::split(entry, ':');
-        EKAT_REQUIRE_MSG(tokens.size() == 2, "Error! surface_coupling_exporter::init - expected "
-                                             "'EAMxx_var_name:FILE_var_name' entry in fields_alt_names, got '" +
-                                                 entry + "' instead.\n");
+        EKAT_REQUIRE_MSG(tokens.size() == 2,
+                         "Error! surface_coupling_exporter::init - expected "
+                         "'EAMxx_var_name:FILE_var_name' entry in fields_alt_names, got '" +
+                             entry + "' instead.\n");
         auto it = ekat::find(export_from_file_fields, tokens[0]);
         EKAT_REQUIRE_MSG(it != export_from_file_fields.end(),
                          "Error! surface_coupling_exporter::init - LHS of entry '" + entry +
@@ -246,19 +258,24 @@ void SurfaceCouplingExporter::initialize_impl(const RunType /* run_type */) {
         auto fname = export_from_file_fields[ii];
         auto rname = export_from_file_reg_names[ii];
         // Find the index for this field in the list of export fields.
-        auto v_loc = std::find(m_export_field_names_vector.begin(), m_export_field_names_vector.end(), fname);
-        EKAT_REQUIRE_MSG(v_loc != m_export_field_names_vector.end(),
-                         "ERROR!! surface_coupling_exporter::init - prescribed_from_file has field with name "
-                             << fname << " which can't be found in set of exported fields\n.");
+        auto v_loc = std::find(m_export_field_names_vector.begin(),
+                               m_export_field_names_vector.end(), fname);
+        EKAT_REQUIRE_MSG(
+            v_loc != m_export_field_names_vector.end(),
+            "ERROR!! surface_coupling_exporter::init - prescribed_from_file has field with name "
+                << fname << " which can't be found in set of exported fields\n.");
         auto idx = v_loc - m_export_field_names_vector.begin();
-        EKAT_REQUIRE_MSG(m_export_source_h(idx) == FROM_MODEL,
-                         "Error! surface_coupling_exporter::init - attempting to set field "
-                             << fname << " export type, which has already been set. Please check namelist options");
+        EKAT_REQUIRE_MSG(
+            m_export_source_h(idx) == FROM_MODEL,
+            "Error! surface_coupling_exporter::init - attempting to set field "
+                << fname
+                << " export type, which has already been set. Please check namelist options");
         m_export_source_h(idx) = FROM_FILE;
         ++m_num_from_file_exports;
         --m_num_from_model_exports;
         auto &f_helper = m_helper_fields.at(fname);
-        // We want to add the field as a deep copy so that the helper_fields are automatically updated.
+        // We want to add the field as a deep copy so that the helper_fields are automatically
+        // updated.
         m_time_interp.add_field(f_helper.alias(rname), true);
         m_export_from_file_field_names.push_back(fname);
       }
@@ -270,29 +287,35 @@ void SurfaceCouplingExporter::initialize_impl(const RunType /* run_type */) {
   if (m_params.isSublist("prescribed_constants")) {
     auto export_constant_params = m_params.sublist("prescribed_constants");
     EKAT_REQUIRE_MSG(export_constant_params.isParameter("fields"),
-                     "Error! surface_coupling_exporter::init - prescribed_constants does not have 'fields' parameter.");
+                     "Error! surface_coupling_exporter::init - prescribed_constants does not have "
+                     "'fields' parameter.");
     EKAT_REQUIRE_MSG(export_constant_params.isParameter("values"),
-                     "Error! surface_coupling_exporter::init - prescribed_constants does not have 'values' parameter.");
+                     "Error! surface_coupling_exporter::init - prescribed_constants does not have "
+                     "'values' parameter.");
     auto export_constant_fields = export_constant_params.get<vos_type>("fields");
     auto export_constant_values = export_constant_params.get<vor_type>("values");
-    EKAT_REQUIRE_MSG(
-        export_constant_fields.size() == export_constant_values.size(),
-        "Error! surface_coupling_exporter::init - prescribed_constants 'fields' and 'values' are not the same size");
+    EKAT_REQUIRE_MSG(export_constant_fields.size() == export_constant_values.size(),
+                     "Error! surface_coupling_exporter::init - prescribed_constants 'fields' and "
+                     "'values' are not the same size");
     bool are_fields_present = export_constant_fields.size() > 0;
     if (are_fields_present) {
       // Determine which fields need constants
       for (size_t ii = 0; ii < export_constant_fields.size(); ii++) {
         auto fname = export_constant_fields[ii];
         // Find the index for this field in the list of export fields.
-        auto v_loc = std::find(m_export_field_names_vector.begin(), m_export_field_names_vector.end(), fname);
-        EKAT_REQUIRE_MSG(v_loc != m_export_field_names_vector.end(),
-                         "ERROR!! surface_coupling_exporter::init - prescribed_constants has field with name "
-                             << fname << " which can't be found in set of exported fields\n.");
+        auto v_loc = std::find(m_export_field_names_vector.begin(),
+                               m_export_field_names_vector.end(), fname);
+        EKAT_REQUIRE_MSG(
+            v_loc != m_export_field_names_vector.end(),
+            "ERROR!! surface_coupling_exporter::init - prescribed_constants has field with name "
+                << fname << " which can't be found in set of exported fields\n.");
         auto idx = v_loc - m_export_field_names_vector.begin();
-        // This field should not have been set to anything else yet (recall FROM_MODEL is the default)
-        EKAT_REQUIRE_MSG(m_export_source_h(idx) == FROM_MODEL,
-                         "Error! surface_coupling_exporter::init - attempting to set field " + fname +
-                             " export type, which has already been set.  Please check namelist options");
+        // This field should not have been set to anything else yet (recall FROM_MODEL is the
+        // default)
+        EKAT_REQUIRE_MSG(
+            m_export_source_h(idx) == FROM_MODEL,
+            "Error! surface_coupling_exporter::init - attempting to set field " + fname +
+                " export type, which has already been set.  Please check namelist options");
         m_export_source_h(idx) = CONSTANT;
         ++m_num_const_exports;
         --m_num_from_model_exports;
@@ -303,10 +326,13 @@ void SurfaceCouplingExporter::initialize_impl(const RunType /* run_type */) {
   // Copy host view back to device view
   Kokkos::deep_copy(m_export_source, m_export_source_h);
   // Final sanity check
-  EKAT_REQUIRE_MSG(m_num_scream_exports = m_num_from_file_exports + m_num_const_exports + m_num_from_model_exports,
-                   "Error! surface_coupling_exporter - Something went wrong set the type of export for all variables.");
+  EKAT_REQUIRE_MSG(m_num_scream_exports =
+                       m_num_from_file_exports + m_num_const_exports + m_num_from_model_exports,
+                   "Error! surface_coupling_exporter - Something went wrong set the type of export "
+                   "for all variables.");
   EKAT_REQUIRE_MSG(m_num_from_model_exports >= 0,
-                   "Error! surface_coupling_exporter - The number of exports derived from EAMxx < 0, something must "
+                   "Error! surface_coupling_exporter - The number of exports derived from EAMxx < "
+                   "0, something must "
                    "have gone wrong in assigning the types of exports for all variables.");
 
   // Perform initial export (if any are marked for export during initialization)
@@ -346,8 +372,10 @@ void SurfaceCouplingExporter::set_constant_exports() {
   }
   // Gotta catch em all
   EKAT_REQUIRE_MSG(num_set == m_num_const_exports,
-                   "ERROR! SurfaceCouplingExporter::set_constant_exports() - Number of fields set to a constant (" +
-                       std::to_string(num_set) + ") doesn't match the number recorded at initialization (" +
+                   "ERROR! SurfaceCouplingExporter::set_constant_exports() - Number of fields set "
+                   "to a constant (" +
+                       std::to_string(num_set) +
+                       ") doesn't match the number recorded at initialization (" +
                        std::to_string(m_num_const_exports) + ").  Something went wrong.");
 }
 // =========================================================================================
@@ -356,13 +384,14 @@ void SurfaceCouplingExporter::set_from_file_exports() {
   m_time_interp.perform_time_interpolation(end_of_step_ts());
 }
 // =========================================================================================
-// This compute_eamxx_exports routine  handles all export variables that are derived from the EAMxx state.
-// Important! This setup assumes the numerical order of export_cpl_indices as listed in
+// This compute_eamxx_exports routine  handles all export variables that are derived from the EAMxx
+// state. Important! This setup assumes the numerical order of export_cpl_indices as listed in
 // /src/mct_coupling/eamxx_cpl_indices.F90
 //
 // If this order is changed or a new variable is added it is important to update the corresponding
 // index query in the below.
-void SurfaceCouplingExporter::compute_eamxx_exports(const double dt, const bool called_during_initialization) {
+void SurfaceCouplingExporter::compute_eamxx_exports(const double dt,
+                                                    const bool called_during_initialization) {
   using PC = physics::Constants<Real>;
 
   const auto &p_int          = get_field_in("p_int").get_view<const Real **>();
@@ -431,7 +460,8 @@ void SurfaceCouplingExporter::compute_eamxx_exports(const double dt, const bool
   // Preprocess exports
   auto export_source = m_export_source;
   const auto setup_policy =
-      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(num_cols, num_levs);
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(num_cols,
+                                                                                    num_levs);
   Kokkos::parallel_for(
       setup_policy, KOKKOS_LAMBDA(const Kokkos::TeamPolicy<KT::ExeSpace>::member_type &team) {
         const int i = team.league_rank();
@@ -473,8 +503,9 @@ void SurfaceCouplingExporter::compute_eamxx_exports(const double dt, const bool
         }
 
         if (export_source(idx_Sa_u) == FROM_MODEL) {
-          const auto u_wind_i =
-              ekat::subview(horiz_winds, i, 0); // TODO, when U and V work switch to using here instead of horiz_winds.
+          const auto u_wind_i = ekat::subview(
+              horiz_winds, i,
+              0); // TODO, when U and V work switch to using here instead of horiz_winds.
           Sa_u(i) = u_wind_i(num_levs - 1);
         }
 
@@ -503,14 +534,16 @@ void SurfaceCouplingExporter::compute_eamxx_exports(const double dt, const bool
         if (export_source(idx_Sa_dens) == FROM_MODEL) {
           const auto s_dz_i             = ekat::scalarize(dz_i);
           const auto s_pseudo_density_i = ekat::scalarize(pseudo_density_i);
-          Sa_dens(i)                    = PF::calculate_density(s_pseudo_density_i(num_levs - 1), s_dz_i(num_levs - 1));
+          Sa_dens(i) =
+              PF::calculate_density(s_pseudo_density_i(num_levs - 1), s_dz_i(num_levs - 1));
         }
 
         if (export_source(idx_Sa_pslv) == FROM_MODEL) {
           const auto p_int_i   = ekat::subview(p_int, i);
           const auto s_z_mid_i = ekat::scalarize(z_mid_i);
           // Calculate air temperature at bottom of cell closest to the ground for PSL
-          const Real T_int_bot = PF::calculate_surface_air_T(s_T_mid_i(num_levs - 1), s_z_mid_i(num_levs - 1));
+          const Real T_int_bot =
+              PF::calculate_surface_air_T(s_T_mid_i(num_levs - 1), s_z_mid_i(num_levs - 1));
 
           Sa_pslv(i) = PF::calculate_psl(T_int_bot, p_int_i(num_levs), phis(i));
         }
diff --git i/components/eamxx/src/control/atmosphere_surface_coupling_exporter.hpp w/components/eamxx/src/control/atmosphere_surface_coupling_exporter.hpp
index 8ffa0ee4dd..a9f3780223 100644
--- i/components/eamxx/src/control/atmosphere_surface_coupling_exporter.hpp
+++ w/components/eamxx/src/control/atmosphere_surface_coupling_exporter.hpp
@@ -34,8 +34,10 @@ public:
   using KT    = ekat::KokkosTypes<DefaultDevice>;
   using Spack = ekat::Pack<Real, SCREAM_SMALL_PACK_SIZE>;
 
-  template <typename DevT, typename DataT> using view_1d = typename KokkosTypes<DevT>::template view_1d<DataT>;
-  template <typename DevT, typename DataT> using view_2d = typename KokkosTypes<DevT>::template view_2d<DataT>;
+  template <typename DevT, typename DataT>
+  using view_1d = typename KokkosTypes<DevT>::template view_1d<DataT>;
+  template <typename DevT, typename DataT>
+  using view_2d = typename KokkosTypes<DevT>::template view_2d<DataT>;
 
   template <typename DevT, typename ScalarT> using uview_1d = Unmanaged<view_1d<DevT, ScalarT>>;
   template <typename DevT, typename ScalarT> using uview_2d = Unmanaged<view_2d<DevT, ScalarT>>;
@@ -68,14 +70,15 @@ public:
   // If calling in initialize_impl(), set
   // called_during_initialization=true to avoid exporting fields
   // which do not have valid entries.
-  void do_export(const double dt, const bool called_during_initialization = false); // Main export routine
-  void
-  compute_eamxx_exports(const double dt,
-                        const bool called_during_initialization = false); // Export vars are derived from eamxx state
-  void set_constant_exports();                                            // Export vars are set to a constant
+  void do_export(const double dt,
+                 const bool called_during_initialization = false); // Main export routine
+  void compute_eamxx_exports(
+      const double dt,
+      const bool called_during_initialization = false); // Export vars are derived from eamxx state
+  void set_constant_exports();                          // Export vars are set to a constant
   void set_from_file_exports(); // Export vars are set by interpolation of data from files
-  void
-  do_export_to_cpl(const bool called_during_initialization = false); // Finish export by copying data to cpl structures.
+  void do_export_to_cpl(const bool called_during_initialization =
+                            false); // Finish export by copying data to cpl structures.
 
   // Take and store data from SCDataManager
   void setup_surface_coupling_data(const SCDataManager &sc_data_manager);
@@ -87,10 +90,13 @@ protected:
   void finalize_impl();
 
   // Creates an helper field, not to be shared with the AD's FieldManager
-  void create_helper_field(const std::string &name, const FieldLayout &layout, const std::string &grid_name);
+  void create_helper_field(const std::string &name, const FieldLayout &layout,
+                           const std::string &grid_name);
 
   // Query if a local field exists
-  bool has_helper_field(const std::string &name) const { return m_helper_fields.find(name) != m_helper_fields.end(); }
+  bool has_helper_field(const std::string &name) const {
+    return m_helper_fields.find(name) != m_helper_fields.end();
+  }
 
   // Computes total number of bytes needed for local variables
   size_t requested_buffer_size_in_bytes() const;
diff --git i/components/eamxx/src/control/atmosphere_surface_coupling_importer.cpp w/components/eamxx/src/control/atmosphere_surface_coupling_importer.cpp
index 92c97ecc25..1944b8935e 100644
--- i/components/eamxx/src/control/atmosphere_surface_coupling_importer.cpp
+++ w/components/eamxx/src/control/atmosphere_surface_coupling_importer.cpp
@@ -10,7 +10,8 @@
 
 namespace scream {
 // =========================================================================================
-SurfaceCouplingImporter::SurfaceCouplingImporter(const ekat::Comm &comm, const ekat::ParameterList &params)
+SurfaceCouplingImporter::SurfaceCouplingImporter(const ekat::Comm &comm,
+                                                 const ekat::ParameterList &params)
     : AtmosphereProcess(comm, params) {}
 // =========================================================================================
 void SurfaceCouplingImporter::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
@@ -63,28 +64,32 @@ void SurfaceCouplingImporter::setup_surface_coupling_data(const SCDataManager &s
   m_num_cpl_imports    = sc_data_manager.get_num_cpl_fields();
   m_num_scream_imports = sc_data_manager.get_num_scream_fields();
 
-  EKAT_ASSERT_MSG(m_num_scream_imports <= m_num_cpl_imports, "Error! More SCREAM imports than actual cpl imports.\n");
+  EKAT_ASSERT_MSG(m_num_scream_imports <= m_num_cpl_imports,
+                  "Error! More SCREAM imports than actual cpl imports.\n");
   EKAT_ASSERT_MSG(m_num_cols == sc_data_manager.get_field_size(),
                   "Error! Surface Coupling imports need to have size ncols.\n");
 
   // The import data is of size ncols,num_cpl_imports. All other data is of size num_scream_imports
-  m_cpl_imports_view_h =
-      decltype(m_cpl_imports_view_h)(sc_data_manager.get_field_data_ptr(), m_num_cols, m_num_cpl_imports);
+  m_cpl_imports_view_h = decltype(m_cpl_imports_view_h)(sc_data_manager.get_field_data_ptr(),
+                                                        m_num_cols, m_num_cpl_imports);
   m_cpl_imports_view_d = Kokkos::create_mirror_view_and_copy(DefaultDevice(), m_cpl_imports_view_h);
 #ifdef HAVE_MOAB
   // The import data is of size num_cpl_imports, ncol. All other data is of size num_scream_imports
-  m_moab_cpl_imports_view_h =
-      decltype(m_moab_cpl_imports_view_h)(sc_data_manager.get_field_data_moab_ptr(), m_num_cpl_imports, m_num_cols);
-  m_moab_cpl_imports_view_d = Kokkos::create_mirror_view_and_copy(DefaultDevice(), m_moab_cpl_imports_view_h);
+  m_moab_cpl_imports_view_h = decltype(m_moab_cpl_imports_view_h)(
+      sc_data_manager.get_field_data_moab_ptr(), m_num_cpl_imports, m_num_cols);
+  m_moab_cpl_imports_view_d =
+      Kokkos::create_mirror_view_and_copy(DefaultDevice(), m_moab_cpl_imports_view_h);
 #endif
   m_import_field_names = new name_t[m_num_scream_imports];
-  std::memcpy(m_import_field_names, sc_data_manager.get_field_name_ptr(), m_num_scream_imports * 32 * sizeof(char));
+  std::memcpy(m_import_field_names, sc_data_manager.get_field_name_ptr(),
+              m_num_scream_imports * 32 * sizeof(char));
 
-  m_cpl_indices_view = decltype(m_cpl_indices_view)(sc_data_manager.get_field_cpl_indices_ptr(), m_num_scream_imports);
-  m_vector_components_view =
-      decltype(m_vector_components_view)(sc_data_manager.get_field_vector_components_ptr(), m_num_scream_imports);
-  m_constant_multiple_view =
-      decltype(m_constant_multiple_view)(sc_data_manager.get_field_constant_multiple_ptr(), m_num_scream_imports);
+  m_cpl_indices_view = decltype(m_cpl_indices_view)(sc_data_manager.get_field_cpl_indices_ptr(),
+                                                    m_num_scream_imports);
+  m_vector_components_view = decltype(m_vector_components_view)(
+      sc_data_manager.get_field_vector_components_ptr(), m_num_scream_imports);
+  m_constant_multiple_view = decltype(m_constant_multiple_view)(
+      sc_data_manager.get_field_constant_multiple_ptr(), m_num_scream_imports);
   m_do_import_during_init_view = decltype(m_do_import_during_init_view)(
       sc_data_manager.get_field_transfer_during_init_ptr(), m_num_scream_imports);
 
@@ -99,14 +104,15 @@ void SurfaceCouplingImporter::initialize_impl(const RunType /* run_type */) {
 
     std::string fname = m_import_field_names[i];
     Field field       = get_field_out(fname);
-    EKAT_REQUIRE_MSG(field.is_allocated(), "Error! Import field view has not been allocated yet.\n");
+    EKAT_REQUIRE_MSG(field.is_allocated(),
+                     "Error! Import field view has not been allocated yet.\n");
 
     // Set view data ptr
     m_column_info_h(i).data = field.get_internal_view_data<Real>();
 
     // Get column info from field utility function
-    get_col_info_for_surface_values(field.get_header_ptr(), m_vector_components_view(i), m_column_info_h(i).col_offset,
-                                    m_column_info_h(i).col_stride);
+    get_col_info_for_surface_values(field.get_header_ptr(), m_vector_components_view(i),
+                                    m_column_info_h(i).col_offset, m_column_info_h(i).col_stride);
 
     // Set constant multiple
     m_column_info_h(i).constant_multiple = m_constant_multiple_view(i);
@@ -124,10 +130,14 @@ void SurfaceCouplingImporter::initialize_impl(const RunType /* run_type */) {
   Kokkos::deep_copy(m_column_info_d, m_column_info_h);
 
   // Set property checks for fields in this proces
-  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("sfc_alb_dir_vis"), m_grid, 0.0, 1.0, true);
-  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("sfc_alb_dir_nir"), m_grid, 0.0, 1.0, true);
-  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("sfc_alb_dif_vis"), m_grid, 0.0, 1.0, true);
-  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("sfc_alb_dif_nir"), m_grid, 0.0, 1.0, true);
+  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("sfc_alb_dir_vis"), m_grid, 0.0,
+                                                    1.0, true);
+  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("sfc_alb_dir_nir"), m_grid, 0.0,
+                                                    1.0, true);
+  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("sfc_alb_dif_vis"), m_grid, 0.0,
+                                                    1.0, true);
+  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("sfc_alb_dif_nir"), m_grid, 0.0,
+                                                    1.0, true);
 
   // Perform initial import (if any are marked for import during initialization)
   if (any_initial_imports)
diff --git i/components/eamxx/src/control/atmosphere_surface_coupling_importer.hpp w/components/eamxx/src/control/atmosphere_surface_coupling_importer.hpp
index cc384ff4ff..478e43d484 100644
--- i/components/eamxx/src/control/atmosphere_surface_coupling_importer.hpp
+++ w/components/eamxx/src/control/atmosphere_surface_coupling_importer.hpp
@@ -20,8 +20,10 @@ namespace scream {
 
 class SurfaceCouplingImporter : public AtmosphereProcess {
 public:
-  template <typename DevT, typename DataT> using view_1d = typename KokkosTypes<DevT>::template view_1d<DataT>;
-  template <typename DevT, typename DataT> using view_2d = typename KokkosTypes<DevT>::template view_2d<DataT>;
+  template <typename DevT, typename DataT>
+  using view_1d = typename KokkosTypes<DevT>::template view_1d<DataT>;
+  template <typename DevT, typename DataT>
+  using view_2d = typename KokkosTypes<DevT>::template view_2d<DataT>;
 
   template <typename DevT, typename ScalarT> using uview_1d = Unmanaged<view_1d<DevT, ScalarT>>;
   template <typename DevT, typename ScalarT> using uview_2d = Unmanaged<view_2d<DevT, ScalarT>>;
diff --git i/components/eamxx/src/control/surface_coupling_utils.cpp w/components/eamxx/src/control/surface_coupling_utils.cpp
index 0dd0498637..41ff3b9260 100644
--- i/components/eamxx/src/control/surface_coupling_utils.cpp
+++ w/components/eamxx/src/control/surface_coupling_utils.cpp
@@ -2,8 +2,8 @@
 
 namespace scream {
 
-void get_col_info_for_surface_values(const std::shared_ptr<const FieldHeader> &fh, int vecComp, int &col_offset,
-                                     int &col_stride) {
+void get_col_info_for_surface_values(const std::shared_ptr<const FieldHeader> &fh, int vecComp,
+                                     int &col_offset, int &col_stride) {
   using namespace ShortFieldTagsNames;
 
   // Get this field layout info
@@ -14,7 +14,8 @@ void get_col_info_for_surface_values(const std::shared_ptr<const FieldHeader> &f
   const bool scalar   = lt == LayoutType::Scalar2D || lt == LayoutType::Scalar3D;
   const bool vector   = lt == LayoutType::Vector2D || lt == LayoutType::Vector3D;
   const bool layout3d = lt == LayoutType::Scalar3D || lt == LayoutType::Vector3D;
-  EKAT_REQUIRE_MSG(scalar || vector, "Error! Support for tensor fields not yet implemented in surface coupling.\n");
+  EKAT_REQUIRE_MSG(scalar || vector,
+                   "Error! Support for tensor fields not yet implemented in surface coupling.\n");
   EKAT_REQUIRE_MSG((vecComp < 0) == scalar,
                    "Error! You can and must specify a vector component only for vector fields.\n");
 
@@ -50,15 +51,17 @@ void get_col_info_for_surface_values(const std::shared_ptr<const FieldHeader> &f
 
     const auto parent_lt = parent->get_identifier().get_layout().type();
 
-    EKAT_REQUIRE_MSG(parent_lt == LayoutType::Vector3D, "Error! SurfaceCoupling expects all subfields to have parents "
-                                                        "with LayoutType::Vector3D.\n");
+    EKAT_REQUIRE_MSG(parent_lt == LayoutType::Vector3D,
+                     "Error! SurfaceCoupling expects all subfields to have parents "
+                     "with LayoutType::Vector3D.\n");
 
     const auto &sv_info = fh->get_alloc_properties().get_subview_info();
 
     // Recall: idx = (idim,k) = (dimension where slice happened, index along said dimension).
     // Field class only allows idim=0,1. But we should never be in the case of idim=0, here.
     // If we have idim=0, it means that the parent field did not have COL as tag[0].
-    EKAT_REQUIRE_MSG(sv_info.dim_idx == 1, "Error! Bizarre scenario discovered. Contact developers.\n");
+    EKAT_REQUIRE_MSG(sv_info.dim_idx == 1,
+                     "Error! Bizarre scenario discovered. Contact developers.\n");
 
     // Additional col_offset
     col_offset += sv_info.slice_idx * parent->get_alloc_properties().get_last_extent();
diff --git i/components/eamxx/src/control/surface_coupling_utils.hpp w/components/eamxx/src/control/surface_coupling_utils.hpp
index cb0e72c2e9..21bafbb9dc 100644
--- i/components/eamxx/src/control/surface_coupling_utils.hpp
+++ w/components/eamxx/src/control/surface_coupling_utils.hpp
@@ -34,14 +34,15 @@ struct SurfaceCouplingColumnInfo {
   int col_offset;
 
   // Constant multple applied to import data.
-  // An example where this is useful is for fluxes, where cpl and SCREAM have different interpretations
-  // of the positive direction. In this case, the constant multiple should be set to -1.
+  // An example where this is useful is for fluxes, where cpl and SCREAM have different
+  // interpretations of the positive direction. In this case, the constant multiple should be set to
+  // -1.
   Real constant_multiple;
 
-  // Boolean that dictates if the field can be imported/exported if do_import/export() is called during
-  // initialization. An example of when this useful inside SCREAM is that some exported fields require computation
-  // done in run_impl() of various processes, and therefore do not have valid entries during the do_export() call
-  // in initialization.
+  // Boolean that dictates if the field can be imported/exported if do_import/export() is called
+  // during initialization. An example of when this useful inside SCREAM is that some exported
+  // fields require computation done in run_impl() of various processes, and therefore do not have
+  // valid entries during the do_export() call in initialization.
   bool transfer_during_initialization;
 
   // Pointer to the scream field device memory
@@ -67,8 +68,8 @@ struct SurfaceCouplingColumnInfo {
 //
 // Field with parents are allowed if the parent has layout 3D vector (ncols, num_comp, nlevs),
 // and the field was sliced along num_comp. See comments below for details.
-void get_col_info_for_surface_values(const std::shared_ptr<const FieldHeader> &fh, int vecComp, int &col_offset,
-                                     int &col_stride);
+void get_col_info_for_surface_values(const std::shared_ptr<const FieldHeader> &fh, int vecComp,
+                                     int &col_offset, int &col_stride);
 
 } // namespace scream
 
diff --git i/components/eamxx/src/control/tests/dummy_atm_proc.hpp w/components/eamxx/src/control/tests/dummy_atm_proc.hpp
index d57b90fc27..4482121daa 100644
--- i/components/eamxx/src/control/tests/dummy_atm_proc.hpp
+++ w/components/eamxx/src/control/tests/dummy_atm_proc.hpp
@@ -14,7 +14,8 @@ public:
 
   enum DummyType { A2G, G2G, G2A };
 
-  DummyProcess(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereProcess(comm, params) {
+  DummyProcess(const ekat::Comm &comm, const ekat::ParameterList &params)
+      : AtmosphereProcess(comm, params) {
     m_name = m_params.get<std::string>("sub_name");
     if (m_name == "Group to Group") {
       m_dummy_type = G2G;
diff --git i/components/eamxx/src/diagnostics/aerocom_cld.cpp w/components/eamxx/src/diagnostics/aerocom_cld.cpp
index 1d8f734a00..ed481f4f97 100644
--- i/components/eamxx/src/diagnostics/aerocom_cld.cpp
+++ w/components/eamxx/src/diagnostics/aerocom_cld.cpp
@@ -8,14 +8,17 @@
 
 namespace scream {
 
-AeroComCld::AeroComCld(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereDiagnostic(comm, params) {
-  EKAT_REQUIRE_MSG(params.isParameter("aero_com_cld_kind"), "Error! AeroComCld requires 'aero_com_cld_kind' in its "
-                                                            "input parameters.\n");
+AeroComCld::AeroComCld(const ekat::Comm &comm, const ekat::ParameterList &params)
+    : AtmosphereDiagnostic(comm, params) {
+  EKAT_REQUIRE_MSG(params.isParameter("aero_com_cld_kind"),
+                   "Error! AeroComCld requires 'aero_com_cld_kind' in its "
+                   "input parameters.\n");
 
   m_topbot = m_params.get<std::string>("aero_com_cld_kind");
   // check if m_topbot is "Bot" or "Top", else error out
-  EKAT_REQUIRE_MSG(m_topbot == "Bot" || m_topbot == "Top", "Error! AeroComCld requires 'aero_com_cld_kind' "
-                                                           "to be 'Bot' or 'Top' in its input parameters.\n");
+  EKAT_REQUIRE_MSG(m_topbot == "Bot" || m_topbot == "Top",
+                   "Error! AeroComCld requires 'aero_com_cld_kind' "
+                   "to be 'Bot' or 'Top' in its input parameters.\n");
 }
 
 void AeroComCld::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
@@ -34,8 +37,9 @@ void AeroComCld::set_grids(const std::shared_ptr<const GridsManager> grids_manag
   m_ndiag     = aercom_util.size;
 
   // Ensure m_index_map and m_units_map match
-  EKAT_REQUIRE_MSG(m_index_map.size() == m_units_map.size(), "Error! Some inconsistency in AeroComCld: index and units "
-                                                             "maps do not match!\n");
+  EKAT_REQUIRE_MSG(m_index_map.size() == m_units_map.size(),
+                   "Error! Some inconsistency in AeroComCld: index and units "
+                   "maps do not match!\n");
   // Ensure m_index_map and m_ndiag match
   EKAT_REQUIRE_MSG(static_cast<int>(m_index_map.size()) == m_ndiag,
                    "Error! Some inconsistency in AeroComCld: index and units "
@@ -168,13 +172,15 @@ void AeroComCld::compute_diagnostic_impl() {
 
         auto topbot_calcs = [&](int ilay) {
           // Only do the calculation if certain conditions are met
-          if ((qc_icol(ilay) + qi_icol(ilay)) > q_threshold && (cld_icol(ilay) > cldfrac_tot_threshold)) {
+          if ((qc_icol(ilay) + qi_icol(ilay)) > q_threshold &&
+              (cld_icol(ilay) > cldfrac_tot_threshold)) {
             /* PART I: Probabilistically determining cloud top/bot */
             // Populate clr_tmp as the clear-sky fraction
             // probability of this level, where clr_icol is that of
             // the previous level
-            auto clr_tmp = clr_icol * (1.0 - ekat::impl::max(cld_icol(ilay - 1), cld_icol(ilay))) /
-                           (1.0 - ekat::impl::min(cld_icol(ilay - 1), Real(1.0 - cldfrac_tot_threshold)));
+            auto clr_tmp =
+                clr_icol * (1.0 - ekat::impl::max(cld_icol(ilay - 1), cld_icol(ilay))) /
+                (1.0 - ekat::impl::min(cld_icol(ilay - 1), Real(1.0 - cldfrac_tot_threshold)));
             // Temporary variable for probability "weights"
             auto wts = clr_icol - clr_tmp;
             // Temporary variable for liquid "phase"
@@ -191,7 +197,8 @@ void AeroComCld::compute_diagnostic_impl() {
             /* We need to convert nc from 1/mass to 1/volume first, and
              * from grid-mean to in-cloud, but after that, the
              * calculation follows the general logic */
-            auto cdnc = nc_icol(ilay) * pden_icol(ilay) / dz_icol(ilay) / physconst::gravit / cld_icol(ilay);
+            auto cdnc = nc_icol(ilay) * pden_icol(ilay) / dz_icol(ilay) / physconst::gravit /
+                        cld_icol(ilay);
             o_cdnc(icol) += cdnc * phi * wts;
             o_nc(icol) += nc_icol(ilay) * phi * wts;
             o_ni(icol) += ni_icol(ilay) * (1.0 - phi) * wts;
diff --git i/components/eamxx/src/diagnostics/aodvis.cpp w/components/eamxx/src/diagnostics/aodvis.cpp
index 0900ab18e6..4f716ab5a9 100644
--- i/components/eamxx/src/diagnostics/aodvis.cpp
+++ w/components/eamxx/src/diagnostics/aodvis.cpp
@@ -6,7 +6,8 @@
 
 namespace scream {
 
-AODVis::AODVis(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereDiagnostic(comm, params) {
+AODVis::AODVis(const ekat::Comm &comm, const ekat::ParameterList &params)
+    : AtmosphereDiagnostic(comm, params) {
   // Nothing to do here
 }
 
diff --git i/components/eamxx/src/diagnostics/atm_backtend.cpp w/components/eamxx/src/diagnostics/atm_backtend.cpp
index cea460a567..9b60619d95 100644
--- i/components/eamxx/src/diagnostics/atm_backtend.cpp
+++ w/components/eamxx/src/diagnostics/atm_backtend.cpp
@@ -8,8 +8,9 @@ namespace scream {
 
 AtmBackTendDiag::AtmBackTendDiag(const ekat::Comm &comm, const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
-  EKAT_REQUIRE_MSG(params.isParameter("tendency_name"), "Error! AtmBackTendDiag requires 'tendency_name' in its "
-                                                        "input parameters.\n");
+  EKAT_REQUIRE_MSG(params.isParameter("tendency_name"),
+                   "Error! AtmBackTendDiag requires 'tendency_name' in its "
+                   "input parameters.\n");
 
   m_name = m_params.get<std::string>("tendency_name");
 }
@@ -26,12 +27,13 @@ void AtmBackTendDiag::initialize_impl(const RunType /*run_type*/) {
 
   // Sanity checks
   const auto &layout = fid.get_layout();
-  EKAT_REQUIRE_MSG(f.data_type() == DataType::RealType, "Error! AtmBackTendDiag only supports Real data type field.\n"
-                                                        " - field name: " +
-                                                            fid.name() +
-                                                            "\n"
-                                                            " - field data type: " +
-                                                            e2str(f.data_type()) + "\n");
+  EKAT_REQUIRE_MSG(f.data_type() == DataType::RealType,
+                   "Error! AtmBackTendDiag only supports Real data type field.\n"
+                   " - field name: " +
+                       fid.name() +
+                       "\n"
+                       " - field data type: " +
+                       e2str(f.data_type()) + "\n");
 
   using namespace ekat::units;
   // The units are the same except per second
diff --git i/components/eamxx/src/diagnostics/atm_density.cpp w/components/eamxx/src/diagnostics/atm_density.cpp
index 121ade2045..7acf867140 100644
--- i/components/eamxx/src/diagnostics/atm_density.cpp
+++ w/components/eamxx/src/diagnostics/atm_density.cpp
@@ -3,7 +3,8 @@
 
 namespace scream {
 
-AtmDensityDiagnostic::AtmDensityDiagnostic(const ekat::Comm &comm, const ekat::ParameterList &params)
+AtmDensityDiagnostic::AtmDensityDiagnostic(const ekat::Comm &comm,
+                                           const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
   // Nothing to do here
 }
@@ -43,11 +44,12 @@ void AtmDensityDiagnostic::compute_diagnostic_impl() {
 
   int nlevs = m_num_levs;
   Kokkos::parallel_for(
-      "AtmosphereDensityDiagnostic", Kokkos::RangePolicy<>(0, m_num_cols * nlevs), KOKKOS_LAMBDA(const int &idx) {
-        const int icol = idx / nlevs;
-        const int ilev = idx % nlevs;
-        auto dz =
-            PF::calculate_dz(pseudo_density_mid(icol, ilev), p_mid(icol, ilev), T_mid(icol, ilev), qv_mid(icol, ilev));
+      "AtmosphereDensityDiagnostic", Kokkos::RangePolicy<>(0, m_num_cols * nlevs),
+      KOKKOS_LAMBDA(const int &idx) {
+        const int icol       = idx / nlevs;
+        const int ilev       = idx % nlevs;
+        auto dz              = PF::calculate_dz(pseudo_density_mid(icol, ilev), p_mid(icol, ilev),
+                                                T_mid(icol, ilev), qv_mid(icol, ilev));
         atm_dens(icol, ilev) = PF::calculate_density(pseudo_density_mid(icol, ilev), dz);
       });
   Kokkos::fence();
diff --git i/components/eamxx/src/diagnostics/dry_static_energy.cpp w/components/eamxx/src/diagnostics/dry_static_energy.cpp
index b843479d79..dea6af4009 100644
--- i/components/eamxx/src/diagnostics/dry_static_energy.cpp
+++ w/components/eamxx/src/diagnostics/dry_static_energy.cpp
@@ -6,7 +6,8 @@
 namespace scream {
 
 // =========================================================================================
-DryStaticEnergyDiagnostic::DryStaticEnergyDiagnostic(const ekat::Comm &comm, const ekat::ParameterList &params)
+DryStaticEnergyDiagnostic::DryStaticEnergyDiagnostic(const ekat::Comm &comm,
+                                                     const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
   // Nothing to do here
 }
@@ -48,7 +49,8 @@ void DryStaticEnergyDiagnostic::compute_diagnostic_impl() {
   using PF         = PhysicsFunctions<DefaultDevice>;
 
   const auto default_policy =
-      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(m_num_cols, m_num_levs);
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(m_num_cols,
+                                                                                    m_num_levs);
 
   const auto &dse                = m_diagnostic_output.get_view<Real **>();
   const auto &T_mid              = get_field_in("T_mid").get_view<const Real **>();
@@ -69,10 +71,11 @@ void DryStaticEnergyDiagnostic::compute_diagnostic_impl() {
         const int icol      = team.league_rank();
         const auto &dz_s    = ekat::subview(tmp_mid, icol);
         const auto &z_int_s = ekat::subview(tmp_int, icol);
-        const auto &z_mid_s = dz_s; // Reuse the memory for z_mid, but set a new variable for code readability.
+        const auto &z_mid_s =
+            dz_s; // Reuse the memory for z_mid, but set a new variable for code readability.
         Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_levs), [&](const Int &ilev) {
-          dz_s(ilev) = PF::calculate_dz(pseudo_density_mid(icol, ilev), p_mid(icol, ilev), T_mid(icol, ilev),
-                                        qv_mid(icol, ilev));
+          dz_s(ilev) = PF::calculate_dz(pseudo_density_mid(icol, ilev), p_mid(icol, ilev),
+                                        T_mid(icol, ilev), qv_mid(icol, ilev));
         });
         team.team_barrier();
 
diff --git i/components/eamxx/src/diagnostics/exner.cpp w/components/eamxx/src/diagnostics/exner.cpp
index d076dc2ec7..898a7dc67d 100644
--- i/components/eamxx/src/diagnostics/exner.cpp
+++ w/components/eamxx/src/diagnostics/exner.cpp
@@ -39,7 +39,8 @@ void ExnerDiagnostic::compute_diagnostic_impl() {
 
   int nlevs = m_num_levs;
   Kokkos::parallel_for(
-      "ExnerDiagnostic", Kokkos::RangePolicy<>(0, m_num_cols * nlevs), KOKKOS_LAMBDA(const int &idx) {
+      "ExnerDiagnostic", Kokkos::RangePolicy<>(0, m_num_cols * nlevs),
+      KOKKOS_LAMBDA(const int &idx) {
         const int icol    = idx / nlevs;
         const int ilev    = idx % nlevs;
         exner(icol, ilev) = PF::exner_function(p_mid(icol, ilev));
diff --git i/components/eamxx/src/diagnostics/field_at_height.cpp w/components/eamxx/src/diagnostics/field_at_height.cpp
index 1fbee10861..e5d7a0d20a 100644
--- i/components/eamxx/src/diagnostics/field_at_height.cpp
+++ w/components/eamxx/src/diagnostics/field_at_height.cpp
@@ -6,7 +6,8 @@
 namespace {
 // Find first position in array pointed by [beg,end) that is below z
 // If all z's in array are >=z, return end
-template <typename T> KOKKOS_INLINE_FUNCTION const T *find_first_smaller_z(const T *beg, const T *end, const T &z) {
+template <typename T>
+KOKKOS_INLINE_FUNCTION const T *find_first_smaller_z(const T *beg, const T *end, const T &z) {
   // It's easier to find the last entry that is not smaller than z,
   // and then we'll return the ptr after that
   int count = end - beg;
@@ -71,36 +72,40 @@ void FieldAtHeight::initialize_impl(const RunType /*run_type*/) {
   // Sanity checks
   using namespace ShortFieldTagsNames;
   const auto &layout = fid.get_layout();
-  EKAT_REQUIRE_MSG(f.data_type() == DataType::RealType, "Error! FieldAtHeight only supports Real data type field.\n"
-                                                        " - field name: " +
-                                                            fid.name() +
-                                                            "\n"
-                                                            " - field data type: " +
-                                                            e2str(f.data_type()) + "\n");
-  EKAT_REQUIRE_MSG(layout.rank() >= 2 && layout.rank() <= 3,
-                   "Error! Field rank not supported by FieldAtHeight.\n"
+  EKAT_REQUIRE_MSG(f.data_type() == DataType::RealType,
+                   "Error! FieldAtHeight only supports Real data type field.\n"
                    " - field name: " +
                        fid.name() +
                        "\n"
-                       " - field layout: " +
-                       layout.to_string() +
-                       "\n"
-                       "NOTE: if you requested something like 'field_horiz_avg_at_Y',\n"
-                       "      you can avoid this error by requesting 'fieldX_at_Y_horiz_avg' instead.\n");
+                       " - field data type: " +
+                       e2str(f.data_type()) + "\n");
+  EKAT_REQUIRE_MSG(
+      layout.rank() >= 2 && layout.rank() <= 3,
+      "Error! Field rank not supported by FieldAtHeight.\n"
+      " - field name: " +
+          fid.name() +
+          "\n"
+          " - field layout: " +
+          layout.to_string() +
+          "\n"
+          "NOTE: if you requested something like 'field_horiz_avg_at_Y',\n"
+          "      you can avoid this error by requesting 'fieldX_at_Y_horiz_avg' instead.\n");
   const auto tag = layout.tags().back();
-  EKAT_REQUIRE_MSG(tag == LEV || tag == ILEV,
-                   "Error! FieldAtHeight diagnostic expects a layout ending with 'LEV'/'ILEV' tag.\n"
-                   " - field name  : " +
-                       fid.name() +
-                       "\n"
-                       " - field layout: " +
-                       layout.to_string() + "\n");
+  EKAT_REQUIRE_MSG(
+      tag == LEV || tag == ILEV,
+      "Error! FieldAtHeight diagnostic expects a layout ending with 'LEV'/'ILEV' tag.\n"
+      " - field name  : " +
+          fid.name() +
+          "\n"
+          " - field layout: " +
+          layout.to_string() + "\n");
 
   // Figure out the z value
   m_z_suffix = tag == LEV ? "_mid" : "_int";
 
   // All good, create the diag output
-  FieldIdentifier d_fid(m_diag_name, layout.clone().strip_dim(tag), fid.get_units(), fid.get_grid_name());
+  FieldIdentifier d_fid(m_diag_name, layout.clone().strip_dim(tag), fid.get_units(),
+                        fid.get_grid_name());
   m_diagnostic_output = Field(d_fid);
   m_diagnostic_output.allocate_view();
 
@@ -109,7 +114,8 @@ void FieldAtHeight::initialize_impl(const RunType /*run_type*/) {
   // Propagate any io string attribute from input field to diag field
   const auto &src      = get_fields_in().front();
   const auto &src_atts = src.get_header().get_extra_data<stratts_t>("io: string attributes");
-  auto &dst_atts       = m_diagnostic_output.get_header().get_extra_data<stratts_t>("io: string attributes");
+  auto &dst_atts =
+      m_diagnostic_output.get_header().get_extra_data<stratts_t>("io: string attributes");
   for (const auto &[name, val] : src_atts) {
     dst_atts[name] = val;
   }
diff --git i/components/eamxx/src/diagnostics/field_at_level.cpp w/components/eamxx/src/diagnostics/field_at_level.cpp
index 5e69e896f1..b2d329d805 100644
--- i/components/eamxx/src/diagnostics/field_at_level.cpp
+++ w/components/eamxx/src/diagnostics/field_at_level.cpp
@@ -24,16 +24,17 @@ void FieldAtLevel::initialize_impl(const RunType /*run_type*/) {
   using namespace ShortFieldTagsNames;
   const auto &fid    = f.get_header().get_identifier();
   const auto &layout = fid.get_layout();
-  EKAT_REQUIRE_MSG(layout.rank() >= 2 && layout.rank() <= 6,
-                   "Error! Field rank not supported by FieldAtLevel.\n"
-                   " - field name: " +
-                       fid.name() +
-                       "\n"
-                       " - field layout: " +
-                       layout.to_string() +
-                       "\n"
-                       "NOTE: if you requested something like 'field_horiz_avg_at_Y',\n"
-                       "      you can avoid this error by requesting 'fieldX_at_Y_horiz_avg' instead.\n");
+  EKAT_REQUIRE_MSG(
+      layout.rank() >= 2 && layout.rank() <= 6,
+      "Error! Field rank not supported by FieldAtLevel.\n"
+      " - field name: " +
+          fid.name() +
+          "\n"
+          " - field layout: " +
+          layout.to_string() +
+          "\n"
+          "NOTE: if you requested something like 'field_horiz_avg_at_Y',\n"
+          "      you can avoid this error by requesting 'fieldX_at_Y_horiz_avg' instead.\n");
   const auto tag = layout.tags().back();
   EKAT_REQUIRE_MSG(tag == LEV || tag == ILEV,
                    "Error! FieldAtLevel diagnostic expects a layout ending with 'LEV'/'ILEV' tag.\n"
@@ -74,7 +75,8 @@ void FieldAtLevel::initialize_impl(const RunType /*run_type*/) {
   }
 
   // All good, create the diag output
-  FieldIdentifier d_fid(m_diag_name, layout.clone().strip_dim(tag), fid.get_units(), fid.get_grid_name());
+  FieldIdentifier d_fid(m_diag_name, layout.clone().strip_dim(tag), fid.get_units(),
+                        fid.get_grid_name());
   m_diagnostic_output = Field(d_fid);
   m_diagnostic_output.allocate_view();
 
@@ -83,7 +85,8 @@ void FieldAtLevel::initialize_impl(const RunType /*run_type*/) {
   // Propagate any io string attribute from input field to diag field
   const auto &src      = get_fields_in().front();
   const auto &src_atts = src.get_header().get_extra_data<stratts_t>("io: string attributes");
-  auto &dst_atts       = m_diagnostic_output.get_header().get_extra_data<stratts_t>("io: string attributes");
+  auto &dst_atts =
+      m_diagnostic_output.get_header().get_extra_data<stratts_t>("io: string attributes");
   for (const auto &[name, val] : src_atts) {
     dst_atts[name] = val;
   }
@@ -101,7 +104,8 @@ void FieldAtLevel::compute_diagnostic_impl() {
     auto f_view = f.get_view<const Real **>();
     auto d_view = m_diagnostic_output.get_view<Real *>();
     Kokkos::parallel_for(
-        m_diagnostic_output.name(), policy, KOKKOS_LAMBDA(const int idx) { d_view(idx) = f_view(idx, level); });
+        m_diagnostic_output.name(), policy,
+        KOKKOS_LAMBDA(const int idx) { d_view(idx) = f_view(idx, level); });
   } break;
   case 2: {
     auto f_view    = f.get_view<const Real ***>();
diff --git i/components/eamxx/src/diagnostics/field_at_pressure_level.cpp w/components/eamxx/src/diagnostics/field_at_pressure_level.cpp
index 57ee54d049..1301f89d35 100644
--- i/components/eamxx/src/diagnostics/field_at_pressure_level.cpp
+++ w/components/eamxx/src/diagnostics/field_at_pressure_level.cpp
@@ -8,16 +8,18 @@
 namespace scream {
 
 // =========================================================================================
-FieldAtPressureLevel::FieldAtPressureLevel(const ekat::Comm &comm, const ekat::ParameterList &params)
+FieldAtPressureLevel::FieldAtPressureLevel(const ekat::Comm &comm,
+                                           const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
   m_field_name = m_params.get<std::string>("field_name");
 
   const auto units = m_params.get<std::string>("pressure_units");
-  EKAT_REQUIRE_MSG(units == "mb" or units == "hPa" or units == "Pa", "Error! Invalid units for FieldAtPressureLevel.\n"
-                                                                     " - input units: " +
-                                                                         units +
-                                                                         "\n"
-                                                                         " - valid units: 'mb', 'hPa', 'Pa'\n");
+  EKAT_REQUIRE_MSG(units == "mb" or units == "hPa" or units == "Pa",
+                   "Error! Invalid units for FieldAtPressureLevel.\n"
+                   " - input units: " +
+                       units +
+                       "\n"
+                       " - valid units: 'mb', 'hPa', 'Pa'\n");
 
   // Figure out the pressure value, and convert to Pa if needed
   auto p_value = m_params.get<std::string>("pressure_value");
@@ -47,27 +49,30 @@ void FieldAtPressureLevel::initialize_impl(const RunType /*run_type*/) {
   // Sanity checks
   using namespace ShortFieldTagsNames;
   const auto &layout = fid.get_layout();
-  EKAT_REQUIRE_MSG(layout.rank() >= 2 && layout.rank() <= 3,
-                   "Error! Field rank not supported by FieldAtPressureLevel.\n"
-                   " - field name: " +
-                       fid.name() +
-                       "\n"
-                       " - field layout: " +
-                       layout.to_string() +
-                       "\n"
-                       "NOTE: if you requested something like 'field_horiz_avg_at_Y',\n"
-                       "      you can avoid this error by requesting 'fieldX_at_Y_horiz_avg' instead.\n");
+  EKAT_REQUIRE_MSG(
+      layout.rank() >= 2 && layout.rank() <= 3,
+      "Error! Field rank not supported by FieldAtPressureLevel.\n"
+      " - field name: " +
+          fid.name() +
+          "\n"
+          " - field layout: " +
+          layout.to_string() +
+          "\n"
+          "NOTE: if you requested something like 'field_horiz_avg_at_Y',\n"
+          "      you can avoid this error by requesting 'fieldX_at_Y_horiz_avg' instead.\n");
   const auto tag = layout.tags().back();
-  EKAT_REQUIRE_MSG(tag == LEV || tag == ILEV,
-                   "Error! FieldAtPressureLevel diagnostic expects a layout ending with 'LEV'/'ILEV' tag.\n"
-                   " - field name  : " +
-                       fid.name() +
-                       "\n"
-                       " - field layout: " +
-                       layout.to_string() + "\n");
+  EKAT_REQUIRE_MSG(
+      tag == LEV || tag == ILEV,
+      "Error! FieldAtPressureLevel diagnostic expects a layout ending with 'LEV'/'ILEV' tag.\n"
+      " - field name  : " +
+          fid.name() +
+          "\n"
+          " - field layout: " +
+          layout.to_string() + "\n");
 
   // All good, create the diag output
-  FieldIdentifier d_fid(m_diag_name, layout.clone().strip_dim(tag), fid.get_units(), fid.get_grid_name());
+  FieldIdentifier d_fid(m_diag_name, layout.clone().strip_dim(tag), fid.get_units(),
+                        fid.get_grid_name());
   m_diagnostic_output = Field(d_fid);
   m_diagnostic_output.allocate_view();
 
@@ -86,7 +91,7 @@ void FieldAtPressureLevel::initialize_impl(const RunType /*run_type*/) {
   // Add a field representing the mask as extra data to the diagnostic field.
   auto nondim       = ekat::units::Units::nondimensional();
   const auto &gname = fid.get_grid_name();
-  m_mask_val        = m_params.get<double>("mask_value", Real(constants::DefaultFillValue<float>::value));
+  m_mask_val = m_params.get<double>("mask_value", Real(constants::DefaultFillValue<float>::value));
 
   std::string mask_name = m_diag_name + " mask";
   FieldLayout mask_layout({COL}, {num_cols});
@@ -101,7 +106,8 @@ void FieldAtPressureLevel::initialize_impl(const RunType /*run_type*/) {
   // Propagate any io string attribute from input field to diag field
   const auto &src      = get_fields_in().front();
   const auto &src_atts = src.get_header().get_extra_data<stratts_t>("io: string attributes");
-  auto &dst_atts       = m_diagnostic_output.get_header().get_extra_data<stratts_t>("io: string attributes");
+  auto &dst_atts =
+      m_diagnostic_output.get_header().get_extra_data<stratts_t>("io: string attributes");
   for (const auto &[name, val] : src_atts) {
     dst_atts[name] = val;
   }
@@ -129,8 +135,9 @@ void FieldAtPressureLevel::compute_diagnostic_impl() {
   if (rank == 2) {
     auto policy = KT::RangePolicy(0, ncols);
     auto diag   = m_diagnostic_output.get_view<Real *>();
-    auto mask   = m_diagnostic_output.get_header().get_extra_data<Field>("mask_data").get_view<Real *>();
-    auto f_v    = f.get_view<const Real **>();
+    auto mask =
+        m_diagnostic_output.get_header().get_extra_data<Field>("mask_data").get_view<Real *>();
+    auto f_v = f.get_view<const Real **>();
     Kokkos::parallel_for(
         policy, KOKKOS_LAMBDA(const int icol) {
           auto x1   = ekat::subview(p_src_v, icol);
@@ -152,7 +159,8 @@ void FieldAtPressureLevel::compute_diagnostic_impl() {
               diag(icol) = y1(nlevs - 1);
             } else {
               // General case: interpolate between k1 and k1-1
-              diag(icol) = y1(k1 - 1) + (y1(k1) - y1(k1 - 1)) / (x1(k1) - x1(k1 - 1)) * (p_tgt - x1(k1 - 1));
+              diag(icol) =
+                  y1(k1 - 1) + (y1(k1) - y1(k1 - 1)) / (x1(k1) - x1(k1 - 1)) * (p_tgt - x1(k1 - 1));
             }
             mask(icol) = 1;
           }
@@ -161,8 +169,9 @@ void FieldAtPressureLevel::compute_diagnostic_impl() {
     const int ndims = f.get_header().get_identifier().get_layout().get_vector_dim();
     auto policy     = KT::TeamPolicy(ncols, ndims);
     auto diag       = m_diagnostic_output.get_view<Real **>();
-    auto mask       = m_diagnostic_output.get_header().get_extra_data<Field>("mask_data").get_view<Real *>();
-    auto f_v        = f.get_view<const Real ***>();
+    auto mask =
+        m_diagnostic_output.get_header().get_extra_data<Field>("mask_data").get_view<Real *>();
+    auto f_v = f.get_view<const Real ***>();
     Kokkos::parallel_for(
         policy, KOKKOS_LAMBDA(const MemberType &team) {
           int icol  = team.league_rank();
@@ -186,7 +195,8 @@ void FieldAtPressureLevel::compute_diagnostic_impl() {
                 diag(icol, idim) = y1(nlevs - 1);
               } else {
                 // General case: interpolate between k1 and k1-1
-                diag(icol, idim) = y1(k1 - 1) + (y1(k1) - y1(k1 - 1)) / (x1(k1) - x1(k1 - 1)) * (p_tgt - x1(k1 - 1));
+                diag(icol, idim) = y1(k1 - 1) + (y1(k1) - y1(k1 - 1)) / (x1(k1) - x1(k1 - 1)) *
+                                                    (p_tgt - x1(k1 - 1));
               }
               Kokkos::single(Kokkos::PerTeam(team), [&] { mask(icol) = 1; });
             }
diff --git i/components/eamxx/src/diagnostics/horiz_avg.cpp w/components/eamxx/src/diagnostics/horiz_avg.cpp
index 12b7f23207..6f6bcf95f5 100644
--- i/components/eamxx/src/diagnostics/horiz_avg.cpp
+++ w/components/eamxx/src/diagnostics/horiz_avg.cpp
@@ -27,21 +27,24 @@ void HorizAvgDiag::initialize_impl(const RunType /*run_type*/) {
   const auto &fid    = f.get_header().get_identifier();
   const auto &layout = fid.get_layout();
 
-  EKAT_REQUIRE_MSG(layout.rank() >= 1 && layout.rank() <= 3, "Error! Field rank not supported by HorizAvgDiag.\n"
-                                                             " - field name: " +
-                                                                 fid.name() +
-                                                                 "\n"
-                                                                 " - field layout: " +
-                                                                 layout.to_string() + "\n");
-  EKAT_REQUIRE_MSG(layout.tags()[0] == COL, "Error! HorizAvgDiag diagnostic expects a layout starting "
-                                            "with the 'COL' tag.\n"
-                                            " - field name  : " +
-                                                fid.name() +
-                                                "\n"
-                                                " - field layout: " +
-                                                layout.to_string() + "\n");
+  EKAT_REQUIRE_MSG(layout.rank() >= 1 && layout.rank() <= 3,
+                   "Error! Field rank not supported by HorizAvgDiag.\n"
+                   " - field name: " +
+                       fid.name() +
+                       "\n"
+                       " - field layout: " +
+                       layout.to_string() + "\n");
+  EKAT_REQUIRE_MSG(layout.tags()[0] == COL,
+                   "Error! HorizAvgDiag diagnostic expects a layout starting "
+                   "with the 'COL' tag.\n"
+                   " - field name  : " +
+                       fid.name() +
+                       "\n"
+                       " - field layout: " +
+                       layout.to_string() + "\n");
 
-  FieldIdentifier d_fid(m_diag_name, layout.clone().strip_dim(COL), fid.get_units(), fid.get_grid_name());
+  FieldIdentifier d_fid(m_diag_name, layout.clone().strip_dim(COL), fid.get_units(),
+                        fid.get_grid_name());
   m_diagnostic_output = Field(d_fid);
   m_diagnostic_output.allocate_view();
 
diff --git i/components/eamxx/src/diagnostics/longwave_cloud_forcing.cpp w/components/eamxx/src/diagnostics/longwave_cloud_forcing.cpp
index 5a15cc81ed..82e0a8fffc 100644
--- i/components/eamxx/src/diagnostics/longwave_cloud_forcing.cpp
+++ w/components/eamxx/src/diagnostics/longwave_cloud_forcing.cpp
@@ -12,7 +12,8 @@ LongwaveCloudForcingDiagnostic::LongwaveCloudForcingDiagnostic(const ekat::Comm
 }
 
 // =========================================================================================
-void LongwaveCloudForcingDiagnostic::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
+void LongwaveCloudForcingDiagnostic::set_grids(
+    const std::shared_ptr<const GridsManager> grids_manager) {
   using namespace ekat::units;
   using namespace ShortFieldTagsNames;
 
diff --git i/components/eamxx/src/diagnostics/number_path.cpp w/components/eamxx/src/diagnostics/number_path.cpp
index e151cbfbb4..d48df02c4f 100644
--- i/components/eamxx/src/diagnostics/number_path.cpp
+++ w/components/eamxx/src/diagnostics/number_path.cpp
@@ -6,10 +6,12 @@
 
 namespace scream {
 
-NumberPathDiagnostic::NumberPathDiagnostic(const ekat::Comm &comm, const ekat::ParameterList &params)
+NumberPathDiagnostic::NumberPathDiagnostic(const ekat::Comm &comm,
+                                           const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
-  EKAT_REQUIRE_MSG(params.isParameter("number_kind"), "Error! NumberPathDiagnostic requires 'number_kind' in its "
-                                                      "input parameters.\n");
+  EKAT_REQUIRE_MSG(params.isParameter("number_kind"),
+                   "Error! NumberPathDiagnostic requires 'number_kind' in its "
+                   "input parameters.\n");
 
   m_kind = m_params.get<std::string>("number_kind");
   if (m_kind == "Liq") {
@@ -77,7 +79,10 @@ void NumberPathDiagnostic::compute_diagnostic_impl() {
         auto rho_icol  = ekat::subview(rho, icol);
         Kokkos::parallel_reduce(
             Kokkos::TeamVectorRange(team, num_levs),
-            [&](const int &ilev, Real &lsum) { lsum += q_icol(ilev) * n_icol(ilev) * rho_icol(ilev) / g; }, np(icol));
+            [&](const int &ilev, Real &lsum) {
+              lsum += q_icol(ilev) * n_icol(ilev) * rho_icol(ilev) / g;
+            },
+            np(icol));
         team.team_barrier();
       });
 }
diff --git i/components/eamxx/src/diagnostics/potential_temperature.cpp w/components/eamxx/src/diagnostics/potential_temperature.cpp
index e67cb6bc8d..8e56a54a37 100644
--- i/components/eamxx/src/diagnostics/potential_temperature.cpp
+++ w/components/eamxx/src/diagnostics/potential_temperature.cpp
@@ -8,7 +8,8 @@ PotentialTemperatureDiagnostic::PotentialTemperatureDiagnostic(const ekat::Comm
                                                                const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
   EKAT_REQUIRE_MSG(params.isParameter("temperature_kind"),
-                   "Error! PotentialTemperatureDiagnostic requires 'temperature_kind' in its input parameters.\n");
+                   "Error! PotentialTemperatureDiagnostic requires 'temperature_kind' in its input "
+                   "parameters.\n");
 
   auto pt_type = params.get<std::string>("temperature_kind");
 
@@ -17,16 +18,18 @@ PotentialTemperatureDiagnostic::PotentialTemperatureDiagnostic(const ekat::Comm
   } else if (pt_type == "Liq") {
     m_ptype = "LiqPotentialTemperature";
   } else {
-    EKAT_ERROR_MSG("Error! Invalid choice for 'TemperatureKind' in PotentialTemperatureDiagnostic.\n"
-                   "  - input value: " +
-                   pt_type +
-                   "\n"
-                   "  - valid values: Tot, Liq\n");
+    EKAT_ERROR_MSG(
+        "Error! Invalid choice for 'TemperatureKind' in PotentialTemperatureDiagnostic.\n"
+        "  - input value: " +
+        pt_type +
+        "\n"
+        "  - valid values: Tot, Liq\n");
   }
 }
 
 // =========================================================================================
-void PotentialTemperatureDiagnostic::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
+void PotentialTemperatureDiagnostic::set_grids(
+    const std::shared_ptr<const GridsManager> grids_manager) {
   using namespace ekat::units;
   using namespace ShortFieldTagsNames;
 
@@ -71,7 +74,8 @@ void PotentialTemperatureDiagnostic::compute_diagnostic_impl() {
         auto temp      = PF::calculate_theta_from_T(T_mid(icol, ilev), p_mid(icol, ilev));
         if (is_liq) {
           // Liquid potential temperature (consistent with how it is calculated in SHOC)
-          theta(icol, ilev) = PF::calculate_thetal_from_theta(temp, T_mid(icol, ilev), q_mid(icol, ilev));
+          theta(icol, ilev) =
+              PF::calculate_thetal_from_theta(temp, T_mid(icol, ilev), q_mid(icol, ilev));
         } else {
           // The total potential temperature
           theta(icol, ilev) = temp;
diff --git i/components/eamxx/src/diagnostics/precip_surf_mass_flux.cpp w/components/eamxx/src/diagnostics/precip_surf_mass_flux.cpp
index ab83c7fd9a..d1840f870e 100644
--- i/components/eamxx/src/diagnostics/precip_surf_mass_flux.cpp
+++ w/components/eamxx/src/diagnostics/precip_surf_mass_flux.cpp
@@ -73,8 +73,9 @@ void PrecipSurfMassFlux::compute_diagnostic_impl() {
     const auto &t_start = mass_liq.get_header().get_tracking().get_accum_start_time();
     const auto &t_now   = mass_liq.get_header().get_tracking().get_time_stamp();
     if (use_ice) {
-      EKAT_REQUIRE_MSG(dt == (t_now - t_start),
-                       "Error! Liquid and ice precip mass fields have different accumulation time stamps!\n");
+      EKAT_REQUIRE_MSG(
+          dt == (t_now - t_start),
+          "Error! Liquid and ice precip mass fields have different accumulation time stamps!\n");
     } else {
       dt = t_now - t_start;
     }
diff --git i/components/eamxx/src/diagnostics/register_diagnostics.hpp w/components/eamxx/src/diagnostics/register_diagnostics.hpp
index 3c64e9201a..27b40559b5 100644
--- i/components/eamxx/src/diagnostics/register_diagnostics.hpp
+++ w/components/eamxx/src/diagnostics/register_diagnostics.hpp
@@ -31,23 +31,33 @@ namespace scream {
 
 inline void register_diagnostics() {
   auto &diag_factory = AtmosphereDiagnosticFactory::instance();
-  diag_factory.register_product("PotentialTemperature", &create_atmosphere_diagnostic<PotentialTemperatureDiagnostic>);
+  diag_factory.register_product("PotentialTemperature",
+                                &create_atmosphere_diagnostic<PotentialTemperatureDiagnostic>);
   diag_factory.register_product("FieldAtLevel", &create_atmosphere_diagnostic<FieldAtLevel>);
   diag_factory.register_product("FieldAtHeight", &create_atmosphere_diagnostic<FieldAtHeight>);
-  diag_factory.register_product("FieldAtPressureLevel", &create_atmosphere_diagnostic<FieldAtPressureLevel>);
-  diag_factory.register_product("AtmosphereDensity", &create_atmosphere_diagnostic<AtmDensityDiagnostic>);
+  diag_factory.register_product("FieldAtPressureLevel",
+                                &create_atmosphere_diagnostic<FieldAtPressureLevel>);
+  diag_factory.register_product("AtmosphereDensity",
+                                &create_atmosphere_diagnostic<AtmDensityDiagnostic>);
   diag_factory.register_product("Exner", &create_atmosphere_diagnostic<ExnerDiagnostic>);
-  diag_factory.register_product("VirtualTemperature", &create_atmosphere_diagnostic<VirtualTemperatureDiagnostic>);
-  diag_factory.register_product("DryStaticEnergy", &create_atmosphere_diagnostic<DryStaticEnergyDiagnostic>);
-  diag_factory.register_product("SeaLevelPressure", &create_atmosphere_diagnostic<SeaLevelPressureDiagnostic>);
+  diag_factory.register_product("VirtualTemperature",
+                                &create_atmosphere_diagnostic<VirtualTemperatureDiagnostic>);
+  diag_factory.register_product("DryStaticEnergy",
+                                &create_atmosphere_diagnostic<DryStaticEnergyDiagnostic>);
+  diag_factory.register_product("SeaLevelPressure",
+                                &create_atmosphere_diagnostic<SeaLevelPressureDiagnostic>);
   diag_factory.register_product("WaterPath", &create_atmosphere_diagnostic<WaterPathDiagnostic>);
   diag_factory.register_product("ShortwaveCloudForcing",
                                 &create_atmosphere_diagnostic<ShortwaveCloudForcingDiagnostic>);
-  diag_factory.register_product("LongwaveCloudForcing", &create_atmosphere_diagnostic<LongwaveCloudForcingDiagnostic>);
-  diag_factory.register_product("RelativeHumidity", &create_atmosphere_diagnostic<RelativeHumidityDiagnostic>);
+  diag_factory.register_product("LongwaveCloudForcing",
+                                &create_atmosphere_diagnostic<LongwaveCloudForcingDiagnostic>);
+  diag_factory.register_product("RelativeHumidity",
+                                &create_atmosphere_diagnostic<RelativeHumidityDiagnostic>);
   diag_factory.register_product("VaporFlux", &create_atmosphere_diagnostic<VaporFluxDiagnostic>);
-  diag_factory.register_product("VerticalLayer", &create_atmosphere_diagnostic<VerticalLayerDiagnostic>);
-  diag_factory.register_product("precip_surf_mass_flux", &create_atmosphere_diagnostic<PrecipSurfMassFlux>);
+  diag_factory.register_product("VerticalLayer",
+                                &create_atmosphere_diagnostic<VerticalLayerDiagnostic>);
+  diag_factory.register_product("precip_surf_mass_flux",
+                                &create_atmosphere_diagnostic<PrecipSurfMassFlux>);
   diag_factory.register_product("surface_upward_latent_heat_flux",
                                 &create_atmosphere_diagnostic<SurfaceUpwardLatentHeatFlux>);
   diag_factory.register_product("wind_speed", &create_atmosphere_diagnostic<WindSpeed>);
@@ -56,7 +66,8 @@ inline void register_diagnostics() {
   diag_factory.register_product("AeroComCld", &create_atmosphere_diagnostic<AeroComCld>);
   diag_factory.register_product("AtmBackTendDiag", &create_atmosphere_diagnostic<AtmBackTendDiag>);
   diag_factory.register_product("HorizAvgDiag", &create_atmosphere_diagnostic<HorizAvgDiag>);
-  diag_factory.register_product("VertContractDiag", &create_atmosphere_diagnostic<VertContractDiag>);
+  diag_factory.register_product("VertContractDiag",
+                                &create_atmosphere_diagnostic<VertContractDiag>);
 }
 
 } // namespace scream
diff --git i/components/eamxx/src/diagnostics/relative_humidity.cpp w/components/eamxx/src/diagnostics/relative_humidity.cpp
index 7485969616..cb60b5bcc0 100644
--- i/components/eamxx/src/diagnostics/relative_humidity.cpp
+++ w/components/eamxx/src/diagnostics/relative_humidity.cpp
@@ -4,12 +4,14 @@
 
 namespace scream {
 
-RelativeHumidityDiagnostic::RelativeHumidityDiagnostic(const ekat::Comm &comm, const ekat::ParameterList &params)
+RelativeHumidityDiagnostic::RelativeHumidityDiagnostic(const ekat::Comm &comm,
+                                                       const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
   // Nothing to do here
 }
 
-void RelativeHumidityDiagnostic::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
+void RelativeHumidityDiagnostic::set_grids(
+    const std::shared_ptr<const GridsManager> grids_manager) {
   using namespace ekat::units;
   using namespace ShortFieldTagsNames;
 
@@ -53,15 +55,17 @@ void RelativeHumidityDiagnostic::compute_diagnostic_impl() {
 
   Int num_levs = m_num_levs;
   Kokkos::parallel_for(
-      "RelativeHumidityDiagnostic", Kokkos::RangePolicy<>(0, m_num_cols * npacks), KOKKOS_LAMBDA(const int &idx) {
+      "RelativeHumidityDiagnostic", Kokkos::RangePolicy<>(0, m_num_cols * npacks),
+      KOKKOS_LAMBDA(const int &idx) {
         const int icol        = idx / npacks;
         const int jpack       = idx % npacks;
         const auto range_pack = ekat::range<Pack>(jpack * Pack::n);
         const auto range_mask = range_pack < num_levs;
-        auto qv_sat_l         = physics::qv_sat_wet(T_mid(icol, jpack), p_dry_mid(icol, jpack), true, range_mask,
-                                                    dp_wet(icol, jpack), dp_dry(icol, jpack), physics::MurphyKoop,
-                                                    "RelativeHumidityDiagnostic::compute_diagnostic_impl");
-        RH(icol, jpack)       = qv_mid(icol, jpack) / qv_sat_l;
+        auto qv_sat_l =
+            physics::qv_sat_wet(T_mid(icol, jpack), p_dry_mid(icol, jpack), true, range_mask,
+                                dp_wet(icol, jpack), dp_dry(icol, jpack), physics::MurphyKoop,
+                                "RelativeHumidityDiagnostic::compute_diagnostic_impl");
+        RH(icol, jpack) = qv_mid(icol, jpack) / qv_sat_l;
       });
   Kokkos::fence();
 }
diff --git i/components/eamxx/src/diagnostics/sea_level_pressure.cpp w/components/eamxx/src/diagnostics/sea_level_pressure.cpp
index 426bfa564e..91bb11c570 100644
--- i/components/eamxx/src/diagnostics/sea_level_pressure.cpp
+++ w/components/eamxx/src/diagnostics/sea_level_pressure.cpp
@@ -4,13 +4,15 @@
 namespace scream {
 
 // =========================================================================================
-SeaLevelPressureDiagnostic::SeaLevelPressureDiagnostic(const ekat::Comm &comm, const ekat::ParameterList &params)
+SeaLevelPressureDiagnostic::SeaLevelPressureDiagnostic(const ekat::Comm &comm,
+                                                       const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
   // Nothing to do here
 }
 
 // =========================================================================================
-void SeaLevelPressureDiagnostic::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
+void SeaLevelPressureDiagnostic::set_grids(
+    const std::shared_ptr<const GridsManager> grids_manager) {
   using namespace ekat::units;
 
   const auto m2 = pow(m, 2);
diff --git i/components/eamxx/src/diagnostics/shortwave_cloud_forcing.cpp w/components/eamxx/src/diagnostics/shortwave_cloud_forcing.cpp
index 4d4bdb0a0e..b158824fb8 100644
--- i/components/eamxx/src/diagnostics/shortwave_cloud_forcing.cpp
+++ w/components/eamxx/src/diagnostics/shortwave_cloud_forcing.cpp
@@ -10,7 +10,8 @@ ShortwaveCloudForcingDiagnostic::ShortwaveCloudForcingDiagnostic(const ekat::Com
   // Nothing to do here
 }
 
-void ShortwaveCloudForcingDiagnostic::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
+void ShortwaveCloudForcingDiagnostic::set_grids(
+    const std::shared_ptr<const GridsManager> grids_manager) {
   using namespace ekat::units;
 
   Units m2(m * m, "m2");
@@ -51,8 +52,8 @@ void ShortwaveCloudForcingDiagnostic::compute_diagnostic_impl() {
   Kokkos::parallel_for(
       "ShortwaveCloudForcingDiagnostic", default_policy, KOKKOS_LAMBDA(const MemberType &team) {
         const int icol = team.league_rank();
-        SWCF(icol) =
-            (SW_flux_dn(icol, 0) - SW_flux_up(icol, 0)) - (SW_clrsky_flux_dn(icol, 0) - SW_clrsky_flux_up(icol, 0));
+        SWCF(icol)     = (SW_flux_dn(icol, 0) - SW_flux_up(icol, 0)) -
+                     (SW_clrsky_flux_dn(icol, 0) - SW_clrsky_flux_up(icol, 0));
       });
   Kokkos::fence();
 }
diff --git i/components/eamxx/src/diagnostics/surf_upward_latent_heat_flux.cpp w/components/eamxx/src/diagnostics/surf_upward_latent_heat_flux.cpp
index 5ae47f3fe4..01fecbcdb7 100644
--- i/components/eamxx/src/diagnostics/surf_upward_latent_heat_flux.cpp
+++ w/components/eamxx/src/diagnostics/surf_upward_latent_heat_flux.cpp
@@ -5,7 +5,8 @@
 namespace scream {
 
 // ==============================================================================
-SurfaceUpwardLatentHeatFlux::SurfaceUpwardLatentHeatFlux(const ekat::Comm &comm, const ekat::ParameterList &params)
+SurfaceUpwardLatentHeatFlux::SurfaceUpwardLatentHeatFlux(const ekat::Comm &comm,
+                                                         const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params), m_name("surface_upward_latent_heat_flux"),
       cf_long_name("surface_upward_latent_heat_flux_due_to_evaporation") {
   // In the future we may add options to include latent heat fluxes due to other water species.
@@ -14,7 +15,8 @@ SurfaceUpwardLatentHeatFlux::SurfaceUpwardLatentHeatFlux(const ekat::Comm &comm,
 }
 
 // ==============================================================================
-void SurfaceUpwardLatentHeatFlux::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
+void SurfaceUpwardLatentHeatFlux::set_grids(
+    const std::shared_ptr<const GridsManager> grids_manager) {
   using namespace ekat::units;
   Units m2(m * m, "m2");
 
diff --git i/components/eamxx/src/diagnostics/tests/atm_density_test.cpp w/components/eamxx/src/diagnostics/tests/atm_density_test.cpp
index 82ef216d55..a48be7cad9 100644
--- i/components/eamxx/src/diagnostics/tests/atm_density_test.cpp
+++ w/components/eamxx/src/diagnostics/tests/atm_density_test.cpp
@@ -47,8 +47,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   const int packsize = SCREAM_PACK_SIZE;
   constexpr int num_levs =
-      packsize * 2 +
-      1; // Number of levels to use for tests, make sure the last pack can also have some empty slots (packsize>1).
+      packsize * 2 + 1; // Number of levels to use for tests, make sure the last pack can also have
+                        // some empty slots (packsize>1).
 
   // A world comm
   ekat::Comm comm(MPI_COMM_WORLD);
@@ -62,7 +62,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   // Construct random input data
   using RPDF = std::uniform_real_distribution<Real>;
-  RPDF pdf_qv(1e-6, 1e-3), pdf_pseudodens(1.0, 100.0), pdf_pres(0.0, PC::P0), pdf_temp(200.0, 400.0);
+  RPDF pdf_qv(1e-6, 1e-3), pdf_pseudodens(1.0, 100.0), pdf_pres(0.0, PC::P0),
+      pdf_temp(200.0, 400.0);
 
   // A time stamp
   util::TimeStamp t0({2022, 1, 1}, {0, 0, 0});
@@ -124,8 +125,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
         "", policy, KOKKOS_LAMBDA(const MemberType &team) {
           const int icol = team.league_rank();
           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_levs), [&](const Int &ilev) {
-            auto dz = PF::calculate_dz(pseudo_dens_v(icol, ilev), p_mid_v(icol, ilev), T_mid_v(icol, ilev),
-                                       qv_mid_v(icol, ilev));
+            auto dz = PF::calculate_dz(pseudo_dens_v(icol, ilev), p_mid_v(icol, ilev),
+                                       T_mid_v(icol, ilev), qv_mid_v(icol, ilev));
             atm_density_v(icol, ilev) = PF::calculate_density(pseudo_dens_v(icol, ilev), dz);
           });
           team.team_barrier();
diff --git i/components/eamxx/src/diagnostics/tests/dry_static_energy_test.cpp w/components/eamxx/src/diagnostics/tests/dry_static_energy_test.cpp
index e68c07f2d8..112f9fa50b 100644
--- i/components/eamxx/src/diagnostics/tests/dry_static_energy_test.cpp
+++ w/components/eamxx/src/diagnostics/tests/dry_static_energy_test.cpp
@@ -48,8 +48,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   const int packsize = SCREAM_PACK_SIZE;
   constexpr int num_levs =
-      packsize * 2 +
-      1; // Number of levels to use for tests, make sure the last pack can also have some empty slots (packsize>1).
+      packsize * 2 + 1; // Number of levels to use for tests, make sure the last pack can also have
+                        // some empty slots (packsize>1).
 
   // A world comm
   ekat::Comm comm(MPI_COMM_WORLD);
@@ -63,8 +63,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   // Construct random input data
   using RPDF = std::uniform_real_distribution<Real>;
-  RPDF pdf_qv(1e-6, 1e-3), pdf_pseudodens(1.0, 100.0), pdf_pres(0.0, PC::P0), pdf_temp(200.0, 400.0),
-      pdf_surface(100.0, 400.0);
+  RPDF pdf_qv(1e-6, 1e-3), pdf_pseudodens(1.0, 100.0), pdf_pres(0.0, PC::P0),
+      pdf_temp(200.0, 400.0), pdf_surface(100.0, 400.0);
 
   // A time stamp
   util::TimeStamp t0({2022, 1, 1}, {0, 0, 0});
@@ -133,8 +133,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
         "", policy, KOKKOS_LAMBDA(const MemberType &team) {
           const int icol = team.league_rank();
           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_levs), [&](const Int &ilev) {
-            dz_v(ilev) = PF::calculate_dz(pseudo_dens_v(icol, ilev), p_mid_v(icol, ilev), T_mid_v(icol, ilev),
-                                          qv_mid_v(icol, ilev));
+            dz_v(ilev) = PF::calculate_dz(pseudo_dens_v(icol, ilev), p_mid_v(icol, ilev),
+                                          T_mid_v(icol, ilev), qv_mid_v(icol, ilev));
           });
           team.team_barrier();
           const auto &dse_sub = ekat::subview(dse_v, icol);
diff --git i/components/eamxx/src/diagnostics/tests/exner_test.cpp w/components/eamxx/src/diagnostics/tests/exner_test.cpp
index 4af439d8e8..162e4dc802 100644
--- i/components/eamxx/src/diagnostics/tests/exner_test.cpp
+++ w/components/eamxx/src/diagnostics/tests/exner_test.cpp
@@ -47,8 +47,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   const int packsize = SCREAM_PACK_SIZE;
   constexpr int num_levs =
-      packsize * 2 +
-      1; // Number of levels to use for tests, make sure the last pack can also have some empty slots (packsize>1).
+      packsize * 2 + 1; // Number of levels to use for tests, make sure the last pack can also have
+                        // some empty slots (packsize>1).
 
   // A world comm
   ekat::Comm comm(MPI_COMM_WORLD);
@@ -111,8 +111,9 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
     Kokkos::parallel_for(
         "", policy, KOKKOS_LAMBDA(const MemberType &team) {
           const int icol = team.league_rank();
-          Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_levs),
-                               [&](const Int &ilev) { exner_v(icol, ilev) = PF::exner_function(p_mid_v(icol, ilev)); });
+          Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_levs), [&](const Int &ilev) {
+            exner_v(icol, ilev) = PF::exner_function(p_mid_v(icol, ilev));
+          });
           team.team_barrier();
         });
     Kokkos::fence();
diff --git i/components/eamxx/src/diagnostics/tests/field_at_height_tests.cpp w/components/eamxx/src/diagnostics/tests/field_at_height_tests.cpp
index c56dd9d21c..416d6d872c 100644
--- i/components/eamxx/src/diagnostics/tests/field_at_height_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/field_at_height_tests.cpp
@@ -10,8 +10,10 @@
 namespace scream {
 
 void f_z_src(const Real y0, const Real m, const Field &z_data, Field &out_data);
-void f_z_tgt(const Real y0, const Real m, const Real z_target, const Field &z_data, Field &out_data);
-bool views_are_approx_equal(const Field &f0, const Field &f1, const Real tol, const bool msg = true);
+void f_z_tgt(const Real y0, const Real m, const Real z_target, const Field &z_data,
+             Field &out_data);
+bool views_are_approx_equal(const Field &f0, const Field &f1, const Real tol,
+                            const bool msg = true);
 
 TEST_CASE("field_at_height") {
   using namespace ShortFieldTagsNames;
@@ -39,17 +41,21 @@ TEST_CASE("field_at_height") {
   // Create input data test fields
   FieldIdentifier s_mid_fid("s_mid", FieldLayout({COL, LEV}, {ncols, nlevs}), m, grid->name());
   FieldIdentifier s_int_fid("s_int", FieldLayout({COL, ILEV}, {ncols, nlevs + 1}), m, grid->name());
-  FieldIdentifier v_mid_fid("v_mid", FieldLayout({COL, CMP, LEV}, {ncols, ndims, nlevs}), m, grid->name());
-  FieldIdentifier v_int_fid("v_int", FieldLayout({COL, CMP, ILEV}, {ncols, ndims, nlevs + 1}), m, grid->name());
+  FieldIdentifier v_mid_fid("v_mid", FieldLayout({COL, CMP, LEV}, {ncols, ndims, nlevs}), m,
+                            grid->name());
+  FieldIdentifier v_int_fid("v_int", FieldLayout({COL, CMP, ILEV}, {ncols, ndims, nlevs + 1}), m,
+                            grid->name());
   // Create vertical fields z and geo on both midpoints and interfaces
   FieldIdentifier z_surf_fid("z_surf", FieldLayout({COL}, {ncols}), m, grid->name());
   FieldIdentifier z_mid_fid("z_mid", FieldLayout({COL, LEV}, {ncols, nlevs}), m, grid->name());
   FieldIdentifier z_int_fid("z_int", FieldLayout({COL, ILEV}, {ncols, nlevs + 1}), m, grid->name());
   FieldIdentifier h_mid_fid("height_mid", FieldLayout({COL, LEV}, {ncols, nlevs}), m, grid->name());
-  FieldIdentifier h_int_fid("height_int", FieldLayout({COL, ILEV}, {ncols, nlevs + 1}), m, grid->name());
+  FieldIdentifier h_int_fid("height_int", FieldLayout({COL, ILEV}, {ncols, nlevs + 1}), m,
+                            grid->name());
   // Keep track of reference fields for comparison
   FieldIdentifier s_tgt_fid("scalar_target", FieldLayout({COL}, {ncols}), m, grid->name());
-  FieldIdentifier v_tgt_fid("vector_target", FieldLayout({COL, CMP}, {ncols, ndims}), m, grid->name());
+  FieldIdentifier v_tgt_fid("vector_target", FieldLayout({COL, CMP}, {ncols, ndims}), m,
+                            grid->name());
 
   Field s_mid(s_mid_fid);
   Field s_int(s_int_fid);
@@ -144,10 +150,12 @@ TEST_CASE("field_at_height") {
     zsurf_v(ii)              = ii * surf_slope;
     max_surf                 = zsurf_v(ii) > max_surf ? zsurf_v(ii) : max_surf;
     const Real col_thickness = z_top - zsurf_v(ii);
-    min_col_thickness        = min_col_thickness < col_thickness ? col_thickness : min_col_thickness;
-    const Real dz            = (z_top - zsurf_v(ii)) / nlevs;
-    zint_v(ii, 0)            = z_top;
-    geoint_v(ii, 0) = z_top - zsurf_v(ii); // Note, the distance above surface needs to consider the surface height.
+    min_col_thickness = min_col_thickness < col_thickness ? col_thickness : min_col_thickness;
+    const Real dz     = (z_top - zsurf_v(ii)) / nlevs;
+    zint_v(ii, 0)     = z_top;
+    geoint_v(ii, 0) =
+        z_top -
+        zsurf_v(ii); // Note, the distance above surface needs to consider the surface height.
     for (int jj = 0; jj < nlevs; ++jj) {
       zint_v(ii, jj + 1)   = zint_v(ii, jj) - dz;
       zmid_v(ii, jj)       = 0.5 * (zint_v(ii, jj) + zint_v(ii, jj + 1));
@@ -284,7 +292,8 @@ void f_z_src(const Real y0, const Real m, const Field &z_data, Field &out_data)
 }
 //-------------------------------
 // Calculate the target data.  Note expression here must match the f_z_src abovel
-void f_z_tgt(const Real y0, const Real m, const Real z_target, const Field &z_data, Field &out_data) {
+void f_z_tgt(const Real y0, const Real m, const Real z_target, const Field &z_data,
+             Field &out_data) {
   using namespace ShortFieldTagsNames;
   const auto layout  = out_data.get_header().get_identifier().get_layout();
   const auto &z_view = z_data.get_view<const Real **, Host>();
@@ -324,16 +333,18 @@ void f_z_tgt(const Real y0, const Real m, const Real z_target, const Field &z_da
 bool views_are_approx_equal(const Field &f0, const Field &f1, const Real tol, const bool msg) {
   const auto &l0 = f0.get_header().get_identifier().get_layout();
   const auto &l1 = f1.get_header().get_identifier().get_layout();
-  EKAT_REQUIRE_MSG(l0 == l1, "Error! views_are_approx_equal - the two fields don't have matching layouts.");
-  // Take advantage of field utils update, min and max to assess the max difference between the two fields
-  // simply.
+  EKAT_REQUIRE_MSG(l0 == l1,
+                   "Error! views_are_approx_equal - the two fields don't have matching layouts.");
+  // Take advantage of field utils update, min and max to assess the max difference between the two
+  // fields simply.
   auto ft = f0.clone();
   ft.update(f1, 1.0, -1.0);
   auto d_min = field_min<Real>(ft);
   auto d_max = field_max<Real>(ft);
   if (std::abs(d_min) > tol or std::abs(d_max) > tol) {
     if (msg) {
-      printf("The two copies of (%16s) are NOT approx equal within a tolerance of %e.\n     The min and max errors are "
+      printf("The two copies of (%16s) are NOT approx equal within a tolerance of %e.\n     The "
+             "min and max errors are "
              "%e and %e respectively.\n",
              f0.name().c_str(), tol, d_min, d_max);
     }
diff --git i/components/eamxx/src/diagnostics/tests/field_at_pressure_level_tests.cpp w/components/eamxx/src/diagnostics/tests/field_at_pressure_level_tests.cpp
index afe5e7497b..6e4f49c2a6 100644
--- i/components/eamxx/src/diagnostics/tests/field_at_pressure_level_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/field_at_pressure_level_tests.cpp
@@ -38,9 +38,10 @@ struct PressureBnds {
 
 std::shared_ptr<FieldManager> get_test_fm(std::shared_ptr<const AbstractGrid> grid);
 
-std::shared_ptr<FieldAtPressureLevel> get_test_diag(const ekat::Comm &comm, std::shared_ptr<const FieldManager> fm,
-                                                    std::shared_ptr<const GridsManager> gm, const std::string &type,
-                                                    const Real plevel);
+std::shared_ptr<FieldAtPressureLevel> get_test_diag(const ekat::Comm &comm,
+                                                    std::shared_ptr<const FieldManager> fm,
+                                                    std::shared_ptr<const GridsManager> gm,
+                                                    const std::string &type, const Real plevel);
 
 Real get_test_pres(const int col, const int lev, const int num_lev, const int num_cols);
 Real get_test_data(const Real pres);
@@ -67,14 +68,15 @@ TEST_CASE("field_at_pressure_level_p2") {
   auto engine = scream::setup_random_test(&comm);
   using RPDF  = std::uniform_real_distribution<Real>;
   Real p_mid_bnds_dz =
-      pressure_bounds.p_surf /
-      nlevs; // Note, p_mid will actually never make it to p_top or p_surf in all columns, so we offset the bounds.
+      pressure_bounds.p_surf / nlevs; // Note, p_mid will actually never make it to p_top or p_surf
+                                      // in all columns, so we offset the bounds.
   RPDF pdf_pmid(pressure_bounds.p_top + p_mid_bnds_dz, pressure_bounds.p_surf - p_mid_bnds_dz);
   RPDF pdf_pint(pressure_bounds.p_top, pressure_bounds.p_surf);
 
   // Get a diagnostic factory
   auto &diag_factory = AtmosphereDiagnosticFactory::instance();
-  diag_factory.register_product("FieldAtPressureLevel", &create_atmosphere_diagnostic<FieldAtPressureLevel>);
+  diag_factory.register_product("FieldAtPressureLevel",
+                                &create_atmosphere_diagnostic<FieldAtPressureLevel>);
 
   {
     // Test 1: Take a slice at a random value for variable defined at midpoint.
@@ -113,7 +115,8 @@ TEST_CASE("field_at_pressure_level_p2") {
     }
   }
   {
-    // Test 3: Take a slice at a value outside the bounds, which should return the default masked value
+    // Test 3: Take a slice at a value outside the bounds, which should return the default masked
+    // value
     for (int test_itr = 0; test_itr < num_checks; test_itr++) {
       Real plevel = pressure_bounds.p_surf * 2;
       auto diag   = get_test_diag(comm, fm, gm, "int", plevel);
@@ -164,7 +167,8 @@ std::shared_ptr<FieldManager> get_test_fm(std::shared_ptr<const AbstractGrid> gr
   FieldIdentifier fid4("p_int", FL{tag_int, dims_int}, Pa, gn);
 
   // Register fields with fm
-  // Make sure packsize isn't bigger than the packsize for this machine, but not so big that we end up with only 1 pack.
+  // Make sure packsize isn't bigger than the packsize for this machine, but not so big that we end
+  // up with only 1 pack.
   fm->registration_begins();
   fm->register_field(FR{fid1, Pack::n});
   fm->register_field(FR{fid2, Pack::n});
@@ -186,8 +190,10 @@ std::shared_ptr<FieldManager> get_test_fm(std::shared_ptr<const AbstractGrid> gr
     for (int jj = 0; jj < num_levs; ++jj) {
       int ipack  = jj / packsize;
       int ivec   = jj % packsize;
-      Real p_mid = (get_test_pres(ii, jj, num_levs, num_lcols) + get_test_pres(ii, jj + 1, num_levs, num_lcols)) / 2;
-      Real p_int = get_test_pres(ii, jj, num_levs, num_lcols);
+      Real p_mid = (get_test_pres(ii, jj, num_levs, num_lcols) +
+                    get_test_pres(ii, jj + 1, num_levs, num_lcols)) /
+                   2;
+      Real p_int               = get_test_pres(ii, jj, num_levs, num_lcols);
       f1_host(ii, ipack)[ivec] = get_test_data(p_mid);
       f2_host(ii, ipack)[ivec] = get_test_data(p_int);
       f3_host(ii, ipack)[ivec] = p_mid;
@@ -212,9 +218,10 @@ std::shared_ptr<FieldManager> get_test_fm(std::shared_ptr<const AbstractGrid> gr
   return fm;
 }
 /*===================================================================================================*/
-std::shared_ptr<FieldAtPressureLevel> get_test_diag(const ekat::Comm &comm, std::shared_ptr<const FieldManager> fm,
-                                                    std::shared_ptr<const GridsManager> gm, const std::string &type,
-                                                    const Real plevel) {
+std::shared_ptr<FieldAtPressureLevel> get_test_diag(const ekat::Comm &comm,
+                                                    std::shared_ptr<const FieldManager> fm,
+                                                    std::shared_ptr<const GridsManager> gm,
+                                                    const std::string &type, const Real plevel) {
   std::string fname = "V_" + type;
   auto field        = fm->get_field(fname);
   auto fid          = field.get_header().get_identifier();
@@ -237,8 +244,8 @@ Real get_test_pres(const int col, const int lev, const int num_lev, const int nu
   Real p_surf = pressure_bounds.p_surf;
   Real p_top  = pressure_bounds.p_top;
   Real dp_dx  = p_top / (num_cols); // Make sure that 1 column hits the min pressure of 0 at tom
-  Real dp_dz =
-      (p_surf - (p_top - (col + 1) * dp_dx)) / (num_lev); // Make sure the max pressure at surface is the surf pressure
+  Real dp_dz  = (p_surf - (p_top - (col + 1) * dp_dx)) /
+               (num_lev); // Make sure the max pressure at surface is the surf pressure
   return (p_top - (col + 1) * dp_dx) + lev * dp_dz;
 }
 
diff --git i/components/eamxx/src/diagnostics/tests/horiz_avg_test.cpp w/components/eamxx/src/diagnostics/tests/horiz_avg_test.cpp
index 1feb691bca..bb8fde6d35 100644
--- i/components/eamxx/src/diagnostics/tests/horiz_avg_test.cpp
+++ w/components/eamxx/src/diagnostics/tests/horiz_avg_test.cpp
@@ -106,7 +106,8 @@ TEST_CASE("horiz_avg") {
   auto diag1_f = diag1->get_diagnostic();
 
   // Manual calculation
-  FieldIdentifier diag0_fid("qc_horiz_avg_manual", scalar1d_layout.clone().strip_dim(COL), kg / kg, grid->name());
+  FieldIdentifier diag0_fid("qc_horiz_avg_manual", scalar1d_layout.clone().strip_dim(COL), kg / kg,
+                            grid->name());
   Field diag0(diag0_fid);
   diag0.allocate_view();
 
@@ -126,7 +127,8 @@ TEST_CASE("horiz_avg") {
   qc1.deep_copy(wavg);
   diag1->compute_diagnostic();
   auto diag1_v2_host = diag1_f.get_view<Real, Host>();
-  REQUIRE_THAT(diag1_v2_host(), Catch::Matchers::WithinRel(wavg, tol)); // Catch2's floating point comparison
+  REQUIRE_THAT(diag1_v2_host(),
+               Catch::Matchers::WithinRel(wavg, tol)); // Catch2's floating point comparison
 
   // other diags
   // Set qc2_v to 5.0 to get weighted average of 5.0
@@ -145,8 +147,8 @@ TEST_CASE("horiz_avg") {
 
   // Try a random case with qc3
   auto qc3_v = qc3.get_view<Real ***>();
-  FieldIdentifier diag3_manual_fid("qc_horiz_avg_manual", scalar3d_layout.clone().strip_dim(COL), kg / kg,
-                                   grid->name());
+  FieldIdentifier diag3_manual_fid("qc_horiz_avg_manual", scalar3d_layout.clone().strip_dim(COL),
+                                   kg / kg, grid->name());
   Field diag3_manual(diag3_manual_fid);
   diag3_manual.allocate_view();
   horiz_contraction<Real>(diag3_manual, qc3, area, &comm);
diff --git i/components/eamxx/src/diagnostics/tests/longwave_cloud_forcing_tests.cpp w/components/eamxx/src/diagnostics/tests/longwave_cloud_forcing_tests.cpp
index e4e2400982..d97bea13c7 100644
--- i/components/eamxx/src/diagnostics/tests/longwave_cloud_forcing_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/longwave_cloud_forcing_tests.cpp
@@ -48,8 +48,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   const int packsize = SCREAM_PACK_SIZE;
   constexpr int num_levs =
-      packsize * 2 +
-      1; // Number of levels to use for tests, make sure the last pack can also have some empty slots (packsize>1).
+      packsize * 2 + 1; // Number of levels to use for tests, make sure the last pack can also have
+                        // some empty slots (packsize>1).
   const int num_mid_packs = ekat::npack<Pack>(num_levs);
 
   // A world comm
@@ -63,7 +63,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
   auto policy = ekat::ExeSpaceUtils<ExecSpace>::get_default_team_policy(ncols, num_mid_packs);
 
   // Input (randomized) views
-  view_1d LW_flux_up("LW_flux_up", num_mid_packs), LW_clrsky_flux_up("LW_clrsky_flux_up", num_mid_packs);
+  view_1d LW_flux_up("LW_flux_up", num_mid_packs),
+      LW_clrsky_flux_up("LW_clrsky_flux_up", num_mid_packs);
 
   auto dview_as_real = [&](const view_1d &v) -> rview_1d {
     return rview_1d(reinterpret_cast<Real *>(v.data()), v.size() * packsize);
diff --git i/components/eamxx/src/diagnostics/tests/number_paths_tests.cpp w/components/eamxx/src/diagnostics/tests/number_paths_tests.cpp
index 568ecde746..909a7d991a 100644
--- i/components/eamxx/src/diagnostics/tests/number_paths_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/number_paths_tests.cpp
@@ -49,8 +49,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
   auto gm         = create_gm(comm, ncols, num_levs);
 
   // Input (randomized) views
-  view_1d pseudo_density("pseudo_density", num_levs), qc("qc", num_levs), nc("nc", num_levs), qr("qr", num_levs),
-      nr("nr", num_levs), qi("qi", num_levs), ni("ni", num_levs);
+  view_1d pseudo_density("pseudo_density", num_levs), qc("qc", num_levs), nc("nc", num_levs),
+      qr("qr", num_levs), nr("nr", num_levs), qi("qi", num_levs), ni("ni", num_levs);
 
   // Construct random input data
   using RPDF = std::uniform_real_distribution<Real>;
diff --git i/components/eamxx/src/diagnostics/tests/potential_temperature_test.cpp w/components/eamxx/src/diagnostics/tests/potential_temperature_test.cpp
index cb2651cbe3..df243e21f6 100644
--- i/components/eamxx/src/diagnostics/tests/potential_temperature_test.cpp
+++ w/components/eamxx/src/diagnostics/tests/potential_temperature_test.cpp
@@ -47,8 +47,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine, int int_ptype) {
 
   const int packsize = SCREAM_PACK_SIZE;
   constexpr int num_levs =
-      packsize * 2 +
-      1; // Number of levels to use for tests, make sure the last pack can also have some empty slots (packsize>1).
+      packsize * 2 + 1; // Number of levels to use for tests, make sure the last pack can also have
+                        // some empty slots (packsize>1).
 
   // A world comm
   ekat::Comm comm(MPI_COMM_WORLD);
@@ -130,8 +130,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine, int int_ptype) {
           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_levs), [&](const Int &ilev) {
             auto theta = PF::calculate_theta_from_T(T_mid_v(icol, ilev), p_mid_v(icol, ilev));
             if (int_ptype == 1) {
-              theta_v(icol, ilev) =
-                  theta - (theta / T_mid_v(icol, ilev)) * (PC::LatVap / PC::Cpair) * q_mid_v(icol, ilev);
+              theta_v(icol, ilev) = theta - (theta / T_mid_v(icol, ilev)) *
+                                                (PC::LatVap / PC::Cpair) * q_mid_v(icol, ilev);
             } else {
               theta_v(icol, ilev) = theta;
             }
diff --git i/components/eamxx/src/diagnostics/tests/precip_surf_mass_flux_tests.cpp w/components/eamxx/src/diagnostics/tests/precip_surf_mass_flux_tests.cpp
index ed746c98c0..f84b675598 100644
--- i/components/eamxx/src/diagnostics/tests/precip_surf_mass_flux_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/precip_surf_mass_flux_tests.cpp
@@ -128,7 +128,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
   auto precip_ice_v   = preicp_ice_f.get_view<Real *>();
   const auto rhodt    = PC::RHO_H2O * dt;
   Kokkos::parallel_for(
-      "precip_total_surf_mass_flux_test", typename KT::RangePolicy(0, ncols), KOKKOS_LAMBDA(const int &icol) {
+      "precip_total_surf_mass_flux_test", typename KT::RangePolicy(0, ncols),
+      KOKKOS_LAMBDA(const int &icol) {
         precip_liq_v(icol)   = precip_liq_surf_mass_v(icol) / rhodt;
         precip_ice_v(icol)   = precip_ice_surf_mass_v(icol) / rhodt;
         precip_total_v(icol) = precip_liq_v(icol) + precip_ice_v(icol);
diff --git i/components/eamxx/src/diagnostics/tests/relative_humidity_tests.cpp w/components/eamxx/src/diagnostics/tests/relative_humidity_tests.cpp
index bbdadf3daa..d205f8c757 100644
--- i/components/eamxx/src/diagnostics/tests/relative_humidity_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/relative_humidity_tests.cpp
@@ -50,8 +50,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   const int packsize = SCREAM_PACK_SIZE;
   constexpr int num_levs =
-      packsize * 2 +
-      1; // Number of levels to use for tests, make sure the last pack can also have some empty slots (packsize>1).
+      packsize * 2 + 1; // Number of levels to use for tests, make sure the last pack can also have
+                        // some empty slots (packsize>1).
   const int num_mid_packs = ekat::npack<Pack>(num_levs);
 
   // A world comm
@@ -66,8 +66,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   // Input (randomized) views, device
   view_1d temperature("temperature", num_mid_packs), pressure("pressure", num_mid_packs),
-      pseudo_density("pseudo_density", num_mid_packs), pseudo_density_dry("pseudo_density_dry", num_mid_packs),
-      qv("qv", num_mid_packs);
+      pseudo_density("pseudo_density", num_mid_packs),
+      pseudo_density_dry("pseudo_density_dry", num_mid_packs), qv("qv", num_mid_packs);
 
   auto dview_as_real = [&](const view_1d &v) -> rview_1d {
     return rview_1d(reinterpret_cast<Real *>(v.data()), v.size() * packsize);
@@ -75,7 +75,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   // Construct random input data
   using RPDF = std::uniform_real_distribution<Real>;
-  RPDF pdf_pres(10.0, PC::P0), pdf_temp(200.0, 400.0), pdf_qv(0.0, 1e-2), pdf_pseudo_density(1.0, 100.0);
+  RPDF pdf_pres(10.0, PC::P0), pdf_temp(200.0, 400.0), pdf_qv(0.0, 1e-2),
+      pdf_pseudo_density(1.0, 100.0);
 
   // A time stamp
   util::TimeStamp t0({2022, 1, 1}, {0, 0, 0});
@@ -162,7 +163,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_mid_packs), [&](const Int &jpack) {
             dpdry_sub(jpack) = dpwet_sub(jpack) - dpwet_sub(jpack) * qv_sub(jpack);
-            auto qv_sat_l    = physics::qv_sat_dry(T_mid_v(icol, jpack), p_dry_mid_v(icol, jpack), true, range_mask);
+            auto qv_sat_l    = physics::qv_sat_dry(T_mid_v(icol, jpack), p_dry_mid_v(icol, jpack),
+                                                   true, range_mask);
             qv_sat_l *= dpdry_v(icol, jpack);
             qv_sat_l /= dpwet_v(icol, jpack);
             rh_v(icol, jpack) = qv_v(icol, jpack) / qv_sat_l;
diff --git i/components/eamxx/src/diagnostics/tests/sea_level_pressure_test.cpp w/components/eamxx/src/diagnostics/tests/sea_level_pressure_test.cpp
index 444fbccc57..47db03d4a1 100644
--- i/components/eamxx/src/diagnostics/tests/sea_level_pressure_test.cpp
+++ w/components/eamxx/src/diagnostics/tests/sea_level_pressure_test.cpp
@@ -47,8 +47,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   const int packsize = SCREAM_PACK_SIZE;
   constexpr int num_levs =
-      packsize * 2 +
-      1; // Number of levels to use for tests, make sure the last pack can also have some empty slots (packsize>1).
+      packsize * 2 + 1; // Number of levels to use for tests, make sure the last pack can also have
+                        // some empty slots (packsize>1).
 
   // A world comm
   ekat::Comm comm(MPI_COMM_WORLD);
@@ -118,7 +118,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
     auto policy              = RangePolicy(0, ncols);
     Kokkos::parallel_for(
         "", policy, KOKKOS_LAMBDA(const int icol) {
-          p_sealevel_v(icol) = PF::calculate_psl(T_mid_s(icol, surf_lev), p_mid_s(icol, surf_lev), phis_v(icol));
+          p_sealevel_v(icol) =
+              PF::calculate_psl(T_mid_s(icol, surf_lev), p_mid_s(icol, surf_lev), phis_v(icol));
         });
     Kokkos::fence();
     REQUIRE(views_are_equal(diag_out, p_sealevel_f));
diff --git i/components/eamxx/src/diagnostics/tests/shortwave_cloud_forcing_tests.cpp w/components/eamxx/src/diagnostics/tests/shortwave_cloud_forcing_tests.cpp
index e290e4a5bc..d6328690ec 100644
--- i/components/eamxx/src/diagnostics/tests/shortwave_cloud_forcing_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/shortwave_cloud_forcing_tests.cpp
@@ -48,8 +48,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   const int packsize = SCREAM_PACK_SIZE;
   constexpr int num_levs =
-      packsize * 2 +
-      1; // Number of levels to use for tests, make sure the last pack can also have some empty slots (packsize>1).
+      packsize * 2 + 1; // Number of levels to use for tests, make sure the last pack can also have
+                        // some empty slots (packsize>1).
   const int num_mid_packs = ekat::npack<Pack>(num_levs);
 
   // A world comm
@@ -64,7 +64,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   // Input (randomized) views
   view_1d SW_flux_dn("SW_flux_dn", num_mid_packs), SW_flux_up("SW_flux_up", num_mid_packs),
-      SW_clrsky_flux_dn("SW_clrsky_flux_dn", num_mid_packs), SW_clrsky_flux_up("SW_clrsky_flux_up", num_mid_packs);
+      SW_clrsky_flux_dn("SW_clrsky_flux_dn", num_mid_packs),
+      SW_clrsky_flux_up("SW_clrsky_flux_up", num_mid_packs);
 
   auto dview_as_real = [&](const view_1d &v) -> rview_1d {
     return rview_1d(reinterpret_cast<Real *>(v.data()), v.size() * packsize);
diff --git i/components/eamxx/src/diagnostics/tests/surf_upward_latent_heat_flux_tests.cpp w/components/eamxx/src/diagnostics/tests/surf_upward_latent_heat_flux_tests.cpp
index c4ae44c6ea..26146b9042 100644
--- i/components/eamxx/src/diagnostics/tests/surf_upward_latent_heat_flux_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/surf_upward_latent_heat_flux_tests.cpp
@@ -94,13 +94,15 @@ void run(std::mt19937_64 &engine, const ekat::Comm &comm, LoggerType &logger) {
   if (!views_are_equal(diag_latent_heat_out, surf_lhf)) {
     // In case of failure, log additional info before aborting with
     // Catch2's REQUIRE macro
-    logger.error("error: surf_lhf_v and diag_latent_heat_out are not passing the views_are_equal test.");
+    logger.error(
+        "error: surf_lhf_v and diag_latent_heat_out are not passing the views_are_equal test.");
     auto surf_lhf_h = Kokkos::create_mirror_view(surf_lhf_v);
     diag_latent_heat_out.sync_to_host();
     auto diag_latent_heat_out_h = diag_latent_heat->get_diagnostic().get_view<Real *, Host>();
     Kokkos::deep_copy(surf_lhf_h, surf_lhf_v);
     for (int i = 0; i < ncols; ++i) {
-      logger.debug("\tat col {}: diag_latent_heat_out = {} surf_lhf = {}", i, diag_latent_heat_out_h(i), surf_lhf_h(i));
+      logger.debug("\tat col {}: diag_latent_heat_out = {} surf_lhf = {}", i,
+                   diag_latent_heat_out_h(i), surf_lhf_h(i));
     }
   }
   REQUIRE(views_are_equal(diag_latent_heat_out, surf_lhf));
@@ -114,7 +116,8 @@ TEST_CASE("surf_upward_latent_heat_flux_test", "[surf_upward_latent_heat_flux_te
   using Device = scream::DefaultDevice;
 
   ekat::Comm comm(MPI_COMM_WORLD);
-  ekat::logger::Logger<> logger("surf_upward_latent_heat_flux_test", ekat::logger::LogLevel::debug, comm);
+  ekat::logger::Logger<> logger("surf_upward_latent_heat_flux_test", ekat::logger::LogLevel::debug,
+                                comm);
   constexpr int num_runs = 5;
   auto engine            = scream::setup_random_test();
   logger.info(" -> Number of randomized runs: {}", num_runs);
diff --git i/components/eamxx/src/diagnostics/tests/vapor_flux_tests.cpp w/components/eamxx/src/diagnostics/tests/vapor_flux_tests.cpp
index 9252e32f1b..e39c371c12 100644
--- i/components/eamxx/src/diagnostics/tests/vapor_flux_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/vapor_flux_tests.cpp
@@ -58,7 +58,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
   auto policy = ESU::get_default_team_policy(ncols, num_levs);
 
   // Input (randomized) views
-  view_1d qv("qv", num_levs), pseudo_density("pseudo_density", num_levs), u("u", num_levs), v("v", num_levs);
+  view_1d qv("qv", num_levs), pseudo_density("pseudo_density", num_levs), u("u", num_levs),
+      v("v", num_levs);
 
   // Construct random input data
   using RPDF = std::uniform_real_distribution<Real>;
diff --git i/components/eamxx/src/diagnostics/tests/vert_contract_test.cpp w/components/eamxx/src/diagnostics/tests/vert_contract_test.cpp
index 3548b6ff28..617fa676d6 100644
--- i/components/eamxx/src/diagnostics/tests/vert_contract_test.cpp
+++ w/components/eamxx/src/diagnostics/tests/vert_contract_test.cpp
@@ -148,8 +148,10 @@ TEST_CASE("vert_contract") {
   unweighted_avg->set_grids(gm);
 
   // Fields for manual calculation
-  FieldIdentifier diag1_fid("qc_vert_contract_manual", scalar2d_layout.clone().strip_dim(LEV), kg / kg, grid->name());
-  FieldIdentifier diag2_fid("qc_vert_contract_manual", scalar3d_layout.clone().strip_dim(LEV), kg / kg, grid->name());
+  FieldIdentifier diag1_fid("qc_vert_contract_manual", scalar2d_layout.clone().strip_dim(LEV),
+                            kg / kg, grid->name());
+  FieldIdentifier diag2_fid("qc_vert_contract_manual", scalar3d_layout.clone().strip_dim(LEV),
+                            kg / kg, grid->name());
   Field diag1_m(diag1_fid);
   Field diag2_m(diag2_fid);
   diag1_m.allocate_view();
diff --git i/components/eamxx/src/diagnostics/tests/vertical_layer_tests.cpp w/components/eamxx/src/diagnostics/tests/vertical_layer_tests.cpp
index 7486ae99db..3414baef29 100644
--- i/components/eamxx/src/diagnostics/tests/vertical_layer_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/vertical_layer_tests.cpp
@@ -26,13 +26,14 @@ std::shared_ptr<GridsManager> create_gm(const ekat::Comm &comm, const int ncols,
 }
 
 //-----------------------------------------------------------------------------------------------//
-template <typename DeviceT, int N> void run(const std::string &diag_name, const std::string &location) {
+template <typename DeviceT, int N>
+void run(const std::string &diag_name, const std::string &location) {
   using PC = scream::physics::Constants<Real>;
 
   const int packsize = N;
   constexpr int num_levs =
-      packsize * 2 +
-      1; // Number of levels to use for tests, make sure the last pack can also have some empty slots (packsize>1).
+      packsize * 2 + 1; // Number of levels to use for tests, make sure the last pack can also have
+                        // some empty slots (packsize>1).
 
   // A world comm
   ekat::Comm comm(MPI_COMM_WORLD);
diff --git i/components/eamxx/src/diagnostics/tests/virtual_temperature_test.cpp w/components/eamxx/src/diagnostics/tests/virtual_temperature_test.cpp
index 97633e08bd..0981ef64bd 100644
--- i/components/eamxx/src/diagnostics/tests/virtual_temperature_test.cpp
+++ w/components/eamxx/src/diagnostics/tests/virtual_temperature_test.cpp
@@ -46,8 +46,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
 
   const int packsize = SCREAM_PACK_SIZE;
   constexpr int num_levs =
-      packsize * 2 +
-      1; // Number of levels to use for tests, make sure the last pack can also have some empty slots (packsize>1).
+      packsize * 2 + 1; // Number of levels to use for tests, make sure the last pack can also have
+                        // some empty slots (packsize>1).
 
   // A world comm
   ekat::Comm comm(MPI_COMM_WORLD);
@@ -115,7 +115,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
         "", policy, KOKKOS_LAMBDA(const MemberType &team) {
           const int icol = team.league_rank();
           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_levs), [&](const Int &ilev) {
-            virtualT_v(icol, ilev) = PF::calculate_virtual_temperature(T_mid_v(icol, ilev), qv_mid_v(icol, ilev));
+            virtualT_v(icol, ilev) =
+                PF::calculate_virtual_temperature(T_mid_v(icol, ilev), qv_mid_v(icol, ilev));
           });
           team.team_barrier();
         });
diff --git i/components/eamxx/src/diagnostics/tests/water_path_tests.cpp w/components/eamxx/src/diagnostics/tests/water_path_tests.cpp
index 1efdb9f23b..c89b9a8bb8 100644
--- i/components/eamxx/src/diagnostics/tests/water_path_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/water_path_tests.cpp
@@ -59,8 +59,8 @@ template <typename DeviceT> void run(std::mt19937_64 &engine) {
   auto policy = ESU::get_default_team_policy(ncols, num_levs);
 
   // Input (randomized) views
-  view_1d pseudo_density("pseudo_density", num_levs), qv("qv", num_levs), qc("qc", num_levs), qr("qr", num_levs),
-      qi("qi", num_levs), qm("qm", num_levs);
+  view_1d pseudo_density("pseudo_density", num_levs), qv("qv", num_levs), qc("qc", num_levs),
+      qr("qr", num_levs), qi("qi", num_levs), qm("qm", num_levs);
 
   // Construct random input data
   using RPDF = std::uniform_real_distribution<Real>;
diff --git i/components/eamxx/src/diagnostics/tests/wind_speed_tests.cpp w/components/eamxx/src/diagnostics/tests/wind_speed_tests.cpp
index eb5f894a16..82bf9cd292 100644
--- i/components/eamxx/src/diagnostics/tests/wind_speed_tests.cpp
+++ w/components/eamxx/src/diagnostics/tests/wind_speed_tests.cpp
@@ -91,7 +91,8 @@ TEST_CASE("wind_speed") {
       for (int ilev = 0; ilev < nlevs; ++ilev) {
         const auto u = uv_h(icol, 0, ilev);
         const auto v = uv_h(icol, 1, ilev);
-        REQUIRE_THAT(ws_h(icol, ilev), Catch::Matchers::WithinULP(std::sqrt(u * u + v * v), ulp_tol));
+        REQUIRE_THAT(ws_h(icol, ilev),
+                     Catch::Matchers::WithinULP(std::sqrt(u * u + v * v), ulp_tol));
       }
     }
   }
diff --git i/components/eamxx/src/diagnostics/vapor_flux.cpp w/components/eamxx/src/diagnostics/vapor_flux.cpp
index f9457c6c3b..3c69f00e09 100644
--- i/components/eamxx/src/diagnostics/vapor_flux.cpp
+++ w/components/eamxx/src/diagnostics/vapor_flux.cpp
@@ -7,8 +7,9 @@ namespace scream {
 
 VaporFluxDiagnostic::VaporFluxDiagnostic(const ekat::Comm &comm, const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
-  EKAT_REQUIRE_MSG(params.isParameter("wind_component"),
-                   "Error! VaporFluxDiagnostic requires 'wind_component' in its input parameters.\n");
+  EKAT_REQUIRE_MSG(
+      params.isParameter("wind_component"),
+      "Error! VaporFluxDiagnostic requires 'wind_component' in its input parameters.\n");
 
   const auto &comp = m_params.get<std::string>("wind_component");
   if (comp == "Zonal") {
@@ -59,7 +60,8 @@ void VaporFluxDiagnostic::compute_diagnostic_impl() {
   const auto diag = m_diagnostic_output.get_view<Real *>();
   const auto qv   = get_field_in("qv").get_view<const Real **>();
   const auto rho  = get_field_in("pseudo_density").get_view<const Real **>();
-  const auto wind = get_field_in("horiz_winds").get_component(m_component).get_view<const Real **>();
+  const auto wind =
+      get_field_in("horiz_winds").get_component(m_component).get_view<const Real **>();
 
   const auto num_levs = m_num_levs;
   const auto policy   = ESU::get_default_team_policy(m_num_cols, m_num_levs);
@@ -73,7 +75,9 @@ void VaporFluxDiagnostic::compute_diagnostic_impl() {
 
         Kokkos::parallel_reduce(
             Kokkos::TeamVectorRange(team, num_levs),
-            [&](const int &ilev, Real &lsum) { lsum += wind_icol(ilev) * qv_icol(ilev) * rho_icol(ilev) / g; },
+            [&](const int &ilev, Real &lsum) {
+              lsum += wind_icol(ilev) * qv_icol(ilev) * rho_icol(ilev) / g;
+            },
             diag(icol));
         team.team_barrier();
       });
diff --git i/components/eamxx/src/diagnostics/vert_contract.cpp w/components/eamxx/src/diagnostics/vert_contract.cpp
index f4179fd3ae..73a76f7070 100644
--- i/components/eamxx/src/diagnostics/vert_contract.cpp
+++ w/components/eamxx/src/diagnostics/vert_contract.cpp
@@ -27,10 +27,11 @@ void VertContractDiag::set_grids(const std::shared_ptr<const GridsManager> grids
                        m_contract_method + "\n");
   // we support either dp or dz weighting, or no weighting at all (none)
   m_weighting_method = m_params.get<std::string>("weighting_method", "none");
-  EKAT_REQUIRE_MSG(m_weighting_method == "dp" || m_weighting_method == "dz" || m_weighting_method == "none",
-                   "Error! VertContractDiag only supports 'dp' or 'dz' or 'none' as weighting_method.\n"
-                   " - weighting_method: " +
-                       m_weighting_method + "\n");
+  EKAT_REQUIRE_MSG(
+      m_weighting_method == "dp" || m_weighting_method == "dz" || m_weighting_method == "none",
+      "Error! VertContractDiag only supports 'dp' or 'dz' or 'none' as weighting_method.\n"
+      " - weighting_method: " +
+          m_weighting_method + "\n");
   m_diag_name = fn + m_contract_method + "_" + m_weighting_method;
 
   auto scalar3d = g->get_3d_scalar_layout(true);
@@ -55,19 +56,21 @@ void VertContractDiag::initialize_impl(const RunType /*run_type*/) {
   const auto &fid    = f.get_header().get_identifier();
   const auto &layout = fid.get_layout();
 
-  EKAT_REQUIRE_MSG(layout.rank() >= 1 && layout.rank() <= 3, "Error! Field rank not supported by VertContractDiag.\n"
-                                                             " - field name: " +
-                                                                 fid.name() +
-                                                                 "\n"
-                                                                 " - field layout: " +
-                                                                 layout.to_string() + "\n");
-  EKAT_REQUIRE_MSG(layout.tags().back() == LEV, "Error! VertContractDiag diagnostic expects a layout ending "
-                                                "with the 'LEV' tag.\n"
-                                                " - field name  : " +
-                                                    fid.name() +
-                                                    "\n"
-                                                    " - field layout: " +
-                                                    layout.to_string() + "\n");
+  EKAT_REQUIRE_MSG(layout.rank() >= 1 && layout.rank() <= 3,
+                   "Error! Field rank not supported by VertContractDiag.\n"
+                   " - field name: " +
+                       fid.name() +
+                       "\n"
+                       " - field layout: " +
+                       layout.to_string() + "\n");
+  EKAT_REQUIRE_MSG(layout.tags().back() == LEV,
+                   "Error! VertContractDiag diagnostic expects a layout ending "
+                   "with the 'LEV' tag.\n"
+                   " - field name  : " +
+                       fid.name() +
+                       "\n"
+                       " - field layout: " +
+                       layout.to_string() + "\n");
 
   ekat::units::Units diag_units = fid.get_units();
 
@@ -82,7 +85,8 @@ void VertContractDiag::initialize_impl(const RunType /*run_type*/) {
   } else {
     // no weighting needed, so we set it to 1 with layout of (col, lev)
     FieldLayout layout_wts = {{COL, LEV}, {layout.dim(COL), layout.dim(LEV)}};
-    FieldIdentifier f_id("vert_contract_wts", layout_wts, ekat::units::Units::nondimensional(), fid.get_grid_name());
+    FieldIdentifier f_id("vert_contract_wts", layout_wts, ekat::units::Units::nondimensional(),
+                         fid.get_grid_name());
     m_weighting = Field(f_id);
     m_weighting.allocate_view();
     m_weighting.deep_copy(sp(1));
@@ -98,8 +102,8 @@ void VertContractDiag::initialize_impl(const RunType /*run_type*/) {
 
   if (m_contract_method == "avg") {
     auto wts_layout = m_weighting.get_header().get_identifier().get_layout();
-    FieldIdentifier wts_sum_fid("vert_contract_wts_sum", wts_layout.clone().strip_dim(LEV), diag_units,
-                                fid.get_grid_name());
+    FieldIdentifier wts_sum_fid("vert_contract_wts_sum", wts_layout.clone().strip_dim(LEV),
+                                diag_units, fid.get_grid_name());
     m_weighting_sum = Field(wts_sum_fid);
     m_weighting_sum.allocate_view();
     m_weighting_one = m_weighting.clone("vert_contract_wts_one");
@@ -108,7 +112,8 @@ void VertContractDiag::initialize_impl(const RunType /*run_type*/) {
     VertContractDiag::scale_wts(m_weighting, m_weighting_sum);
   }
 
-  FieldIdentifier d_fid(m_diag_name, layout.clone().strip_dim(LEV), diag_units, fid.get_grid_name());
+  FieldIdentifier d_fid(m_diag_name, layout.clone().strip_dim(LEV), diag_units,
+                        fid.get_grid_name());
   m_diagnostic_output = Field(d_fid);
   m_diagnostic_output.allocate_view();
 }
@@ -134,7 +139,8 @@ void VertContractDiag::scale_wts(Field &wts, const Field &wts_sum) {
   const auto wts_sum_v = wts_sum.get_view<const Real *>();
 
   Kokkos::parallel_for(
-      "VertContractDiag::scale_wts" + m_diag_name, RP(0, nlevs * ncols), KOKKOS_LAMBDA(const int &idx) {
+      "VertContractDiag::scale_wts" + m_diag_name, RP(0, nlevs * ncols),
+      KOKKOS_LAMBDA(const int &idx) {
         const int icol = idx / nlevs;
         const int ilev = idx % nlevs;
         if (wts_sum_v(icol) != 0) {
diff --git i/components/eamxx/src/diagnostics/vertical_layer.cpp w/components/eamxx/src/diagnostics/vertical_layer.cpp
index 8d8bfa8ba8..66c197a4f6 100644
--- i/components/eamxx/src/diagnostics/vertical_layer.cpp
+++ w/components/eamxx/src/diagnostics/vertical_layer.cpp
@@ -7,20 +7,23 @@
 namespace scream {
 
 // =========================================================================================
-VerticalLayerDiagnostic::VerticalLayerDiagnostic(const ekat::Comm &comm, const ekat::ParameterList &params)
+VerticalLayerDiagnostic::VerticalLayerDiagnostic(const ekat::Comm &comm,
+                                                 const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
   m_diag_name                        = params.get<std::string>("diag_name");
   std::vector<std::string> supported = {"z", "geopotential", "height", "dz"};
 
-  EKAT_REQUIRE_MSG(ekat::contains(supported, m_diag_name), "[VerticalLayerDiagnostic] Error! Invalid diag_name.\n"
-                                                           "  - diag_name  : " +
-                                                               m_diag_name +
-                                                               "\n"
-                                                               "  - valid names: " +
-                                                               ekat::join(supported, ", ") + "\n");
+  EKAT_REQUIRE_MSG(ekat::contains(supported, m_diag_name),
+                   "[VerticalLayerDiagnostic] Error! Invalid diag_name.\n"
+                   "  - diag_name  : " +
+                       m_diag_name +
+                       "\n"
+                       "  - valid names: " +
+                       ekat::join(supported, ", ") + "\n");
 
   auto vert_pos = params.get<std::string>("vert_location");
-  EKAT_REQUIRE_MSG(vert_pos == "mid" || vert_pos == "int" || vert_pos == "midpoints" || vert_pos == "interfaces",
+  EKAT_REQUIRE_MSG(vert_pos == "mid" || vert_pos == "int" || vert_pos == "midpoints" ||
+                       vert_pos == "interfaces",
                    "[VerticalLayerDiagnostic] Error! Invalid 'vert_location'.\n"
                    "  - input value: " +
                        vert_pos +
@@ -71,11 +74,12 @@ void VerticalLayerDiagnostic::initialize_impl(const RunType /*run_type*/) {
   auto m2 = pow(m, 2);
   auto s2 = pow(s, 2);
 
-  const auto &T    = get_field_in("T_mid");
-  const auto &rho  = get_field_in("pseudo_density");
-  const auto &p    = get_field_in("p_mid");
-  const auto &qv   = get_field_in("qv");
-  const auto &phis = m_from_sea_level ? get_field_in("phis") : T; // unused if m_from_sea_level=false
+  const auto &T   = get_field_in("T_mid");
+  const auto &rho = get_field_in("pseudo_density");
+  const auto &p   = get_field_in("p_mid");
+  const auto &qv  = get_field_in("qv");
+  const auto &phis =
+      m_from_sea_level ? get_field_in("phis") : T; // unused if m_from_sea_level=false
 
   // Construct and allocate the diagnostic field.
   // Notes:
@@ -102,7 +106,8 @@ void VerticalLayerDiagnostic::initialize_impl(const RunType /*run_type*/) {
   m_diagnostic_output.allocate_view();
 
   using stratts_t = std::map<std::string, std::string>;
-  auto &io_atts   = m_diagnostic_output.get_header().get_extra_data<stratts_t>("io: string attributes");
+  auto &io_atts =
+      m_diagnostic_output.get_header().get_extra_data<stratts_t>("io: string attributes");
   auto &long_name = io_atts["long_name"];
   if (m_diag_name == "dz") {
     long_name = "level thickness";
@@ -162,14 +167,15 @@ template <int PackSize> void VerticalLayerDiagnostic::do_compute_diagnostic_impl
   constexpr bool FromTop = false;
 
   const auto npacks = ekat::npack<PackT>(m_num_levs);
-  const auto policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(m_num_cols, npacks);
+  const auto policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(
+      m_num_cols, npacks);
 
   const auto &T   = get_field_in("T_mid").get_view<const PackT **>();
   const auto &p   = get_field_in("p_mid").get_view<const PackT **>();
   const auto &qv  = get_field_in("qv").get_view<const PackT **>();
   const auto &rho = get_field_in("pseudo_density").get_view<const PackT **>();
-  const auto phis =
-      m_from_sea_level ? get_field_in("phis").get_view<const Real *>() : typename KT::view_1d<const Real>();
+  const auto phis = m_from_sea_level ? get_field_in("phis").get_view<const Real *>()
+                                     : typename KT::view_1d<const Real>();
 
   const bool only_compute_dz     = m_diag_name == "dz";
   const bool is_interface_layout = m_is_interface_layout;
diff --git i/components/eamxx/src/diagnostics/vertical_layer.hpp w/components/eamxx/src/diagnostics/vertical_layer.hpp
index 699d4f73d2..5993b427cb 100644
--- i/components/eamxx/src/diagnostics/vertical_layer.hpp
+++ w/components/eamxx/src/diagnostics/vertical_layer.hpp
@@ -9,11 +9,12 @@ namespace scream {
  * This diagnostic will produce data related to the vertical layer based on
  * the parameter "diag_name" (required). The following can be produced:
  *   - diag_name = "dz":                       Vertical layer thickness for each column and level
- *   - diag_name = "z_int":                    Vertical layer height at each column and interface level.
- *                                             Values are computed from sea level (i.e., surf_geopotential=0).
+ *   - diag_name = "z_int":                    Vertical layer height at each column and interface
+ * level. Values are computed from sea level (i.e., surf_geopotential=0).
  *   - diag_name = "geopotential_int":         Same as z_int, but computed from topography data
  *                                             (i.e., surf_geopotential=phis).
- *   - diag_name = "z_mid"/"geopotential_mid": Same as z_int/geopotential_int but at midpoint levels.
+ *   - diag_name = "z_mid"/"geopotential_mid": Same as z_int/geopotential_int but at midpoint
+ * levels.
  */
 
 class VerticalLayerDiagnostic : public AtmosphereDiagnostic {
diff --git i/components/eamxx/src/diagnostics/virtual_temperature.cpp w/components/eamxx/src/diagnostics/virtual_temperature.cpp
index 6d2f060a92..18c3debca5 100644
--- i/components/eamxx/src/diagnostics/virtual_temperature.cpp
+++ w/components/eamxx/src/diagnostics/virtual_temperature.cpp
@@ -3,12 +3,14 @@
 
 namespace scream {
 
-VirtualTemperatureDiagnostic::VirtualTemperatureDiagnostic(const ekat::Comm &comm, const ekat::ParameterList &params)
+VirtualTemperatureDiagnostic::VirtualTemperatureDiagnostic(const ekat::Comm &comm,
+                                                           const ekat::ParameterList &params)
     : AtmosphereDiagnostic(comm, params) {
   // Nothing to do here
 }
 
-void VirtualTemperatureDiagnostic::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
+void VirtualTemperatureDiagnostic::set_grids(
+    const std::shared_ptr<const GridsManager> grids_manager) {
   using namespace ekat::units;
   using namespace ShortFieldTagsNames;
 
@@ -38,10 +40,12 @@ void VirtualTemperatureDiagnostic::compute_diagnostic_impl() {
 
   int nlevs = m_num_levs;
   Kokkos::parallel_for(
-      "VirtualTemperatureDiagnostic", Kokkos::RangePolicy<>(0, m_num_cols * nlevs), KOKKOS_LAMBDA(const int &idx) {
-        const int icol       = idx / nlevs;
-        const int ilev       = idx % nlevs;
-        virtualT(icol, ilev) = PF::calculate_virtual_temperature(T_mid(icol, ilev), qv_mid(icol, ilev));
+      "VirtualTemperatureDiagnostic", Kokkos::RangePolicy<>(0, m_num_cols * nlevs),
+      KOKKOS_LAMBDA(const int &idx) {
+        const int icol = idx / nlevs;
+        const int ilev = idx % nlevs;
+        virtualT(icol, ilev) =
+            PF::calculate_virtual_temperature(T_mid(icol, ilev), qv_mid(icol, ilev));
       });
   Kokkos::fence();
 }
diff --git i/components/eamxx/src/diagnostics/water_path.cpp w/components/eamxx/src/diagnostics/water_path.cpp
index 5eabccae72..a981c43d4a 100644
--- i/components/eamxx/src/diagnostics/water_path.cpp
+++ w/components/eamxx/src/diagnostics/water_path.cpp
@@ -74,7 +74,8 @@ void WaterPathDiagnostic::compute_diagnostic_impl() {
         auto rho_icol  = ekat::subview(rho, icol);
         Kokkos::parallel_reduce(
             Kokkos::TeamVectorRange(team, num_levs),
-            [&](const int &ilev, Real &lsum) { lsum += q_icol(ilev) * rho_icol(ilev) / g; }, wp(icol));
+            [&](const int &ilev, Real &lsum) { lsum += q_icol(ilev) * rho_icol(ilev) / g; },
+            wp(icol));
         team.team_barrier();
       });
 }
diff --git i/components/eamxx/src/diagnostics/wind_speed.cpp w/components/eamxx/src/diagnostics/wind_speed.cpp
index 597d4fc74e..456a2ece13 100644
--- i/components/eamxx/src/diagnostics/wind_speed.cpp
+++ w/components/eamxx/src/diagnostics/wind_speed.cpp
@@ -4,7 +4,8 @@
 
 namespace scream {
 
-WindSpeed::WindSpeed(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereDiagnostic(comm, params) {
+WindSpeed::WindSpeed(const ekat::Comm &comm, const ekat::ParameterList &params)
+    : AtmosphereDiagnostic(comm, params) {
   // Nothing to do here
 }
 
diff --git i/components/eamxx/src/dynamics/homme/eamxx_homme_fv_phys.cpp w/components/eamxx/src/dynamics/homme/eamxx_homme_fv_phys.cpp
index 31568b6716..146c8b8735 100644
--- i/components/eamxx/src/dynamics/homme/eamxx_homme_fv_phys.cpp
+++ w/components/eamxx/src/dynamics/homme/eamxx_homme_fv_phys.cpp
@@ -44,7 +44,9 @@ namespace scream {
 
 bool HommeDynamics::fv_phys_active() const { return m_phys_grid_pgN > 0; }
 
-void HommeDynamics::fv_phys_set_grids() { m_phys_grid_pgN = get_phys_grid_fv_param(m_phys_grid->name()); }
+void HommeDynamics::fv_phys_set_grids() {
+  m_phys_grid_pgN = get_phys_grid_fv_param(m_phys_grid->name());
+}
 
 void HommeDynamics::fv_phys_requested_buffer_size_in_bytes() const {
   if (not fv_phys_active())
@@ -75,7 +77,8 @@ struct HommeDynamics::GllFvRemapTmp {
 
 // Copy physics T,uv state to FT,M to form tendencies in next dynamics step.
 template <typename T_t, typename uv_t, typename FT_t, typename FM_t>
-static void copy_prev(const int ncols, const int npacks, const T_t &T, const uv_t &uv, const FT_t &FT, const FM_t &FM) {
+static void copy_prev(const int ncols, const int npacks, const T_t &T, const uv_t &uv,
+                      const FT_t &FT, const FM_t &FM) {
   using KT          = KokkosTypes<DefaultDevice>;
   using ESU         = ekat::ExeSpaceUtils<KT::ExeSpace>;
   const auto policy = ESU::get_default_team_policy(ncols, npacks);
@@ -110,12 +113,14 @@ void HommeDynamics::fv_phys_dyn_to_fv_phys(const util::TimeStamp &ts, const bool
     t.T_mid       = Homme::ExecView<Real ***>("T_mid_tmp", nelem, npg, npacks * N);
     t.horiz_winds = Homme::ExecView<Real ****>("horiz_winds_tmp", nelem, npg, 2, npacks * N);
     // Really need just the first tracer.
-    const auto qsize = get_group_out("tracers", pgn).m_monolithic_field->get_view<Real ***>().extent_int(1);
-    t.tracers        = Homme::ExecView<Real ****>("tracers_tmp", nelem, npg, qsize, npacks * N);
+    const auto qsize =
+        get_group_out("tracers", pgn).m_monolithic_field->get_view<Real ***>().extent_int(1);
+    t.tracers = Homme::ExecView<Real ****>("tracers_tmp", nelem, npg, qsize, npacks * N);
     remap_dyn_to_fv_phys(&t);
     assert(ncols == nelem * npg);
     Homme::ExecViewUnmanaged<Pack **> T(reinterpret_cast<Pack *>(t.T_mid.data()), ncols, npacks);
-    Homme::ExecViewUnmanaged<Pack ***> uv(reinterpret_cast<Pack *>(t.horiz_winds.data()), ncols, 2, npacks);
+    Homme::ExecViewUnmanaged<Pack ***> uv(reinterpret_cast<Pack *>(t.horiz_winds.data()), ncols, 2,
+                                          npacks);
     copy_prev(ncols, npacks, T, uv, FT, FM);
   } else {
     remap_dyn_to_fv_phys();
@@ -169,22 +174,28 @@ void HommeDynamics::remap_dyn_to_fv_phys(GllFvRemapTmp *t) const {
   const auto npg      = m_phys_grid_pgN * m_phys_grid_pgN;
   const auto &gn      = m_phys_grid->name();
   const auto nlev     = get_field_out("T_mid", gn).get_view<Real **>().extent_int(1);
-  const auto nq       = get_group_out("tracers").m_monolithic_field->get_view<Real ***>().extent_int(1);
+  const auto nq = get_group_out("tracers").m_monolithic_field->get_view<Real ***>().extent_int(1);
   assert(get_field_out("T_mid", gn).get_view<Real **>().extent_int(0) == nelem * npg);
   assert(get_field_out("horiz_winds", gn).get_view<Real ***>().extent_int(1) == 2);
 
-  const auto ps   = Homme::GllFvRemap::Phys1T(get_field_out("ps", gn).get_view<Real *>().data(), nelem, npg);
-  const auto phis = Homme::GllFvRemap::Phys1T(get_field_out("phis", gn).get_view<Real *>().data(), nelem, npg);
-  const auto T = Homme::GllFvRemap::Phys2T(t ? t->T_mid.data() : get_field_out("T_mid", gn).get_view<Real **>().data(),
-                                           nelem, npg, nlev);
-  const auto omega = Homme::GllFvRemap::Phys2T(get_field_out("omega", gn).get_view<Real **>().data(), nelem, npg, nlev);
-  const auto uv    = Homme::GllFvRemap::Phys3T(
-      t ? t->horiz_winds.data() : get_field_out("horiz_winds", gn).get_view<Real ***>().data(), nelem, npg, 2, nlev);
+  const auto ps =
+      Homme::GllFvRemap::Phys1T(get_field_out("ps", gn).get_view<Real *>().data(), nelem, npg);
+  const auto phis =
+      Homme::GllFvRemap::Phys1T(get_field_out("phis", gn).get_view<Real *>().data(), nelem, npg);
+  const auto T = Homme::GllFvRemap::Phys2T(
+      t ? t->T_mid.data() : get_field_out("T_mid", gn).get_view<Real **>().data(), nelem, npg,
+      nlev);
+  const auto omega = Homme::GllFvRemap::Phys2T(
+      get_field_out("omega", gn).get_view<Real **>().data(), nelem, npg, nlev);
+  const auto uv = Homme::GllFvRemap::Phys3T(
+      t ? t->horiz_winds.data() : get_field_out("horiz_winds", gn).get_view<Real ***>().data(),
+      nelem, npg, 2, nlev);
   const auto q = Homme::GllFvRemap::Phys3T(
-      t ? t->tracers.data() : get_group_out("tracers", gn).m_monolithic_field->get_view<Real ***>().data(), nelem, npg,
-      nq, nlev);
-  const auto dp =
-      Homme::GllFvRemap::Phys2T(get_field_out("pseudo_density", gn).get_view<Real **>().data(), nelem, npg, nlev);
+      t ? t->tracers.data()
+        : get_group_out("tracers", gn).m_monolithic_field->get_view<Real ***>().data(),
+      nelem, npg, nq, nlev);
+  const auto dp = Homme::GllFvRemap::Phys2T(
+      get_field_out("pseudo_density", gn).get_view<Real **>().data(), nelem, npg, nlev);
 
   gfr.run_dyn_to_fv_phys(time_idx, ps, phis, T, omega, uv, q, &dp);
   Kokkos::fence();
@@ -201,18 +212,20 @@ void HommeDynamics::remap_fv_phys_to_dyn() const {
   const auto npg      = m_phys_grid_pgN * m_phys_grid_pgN;
   const auto &gn      = m_phys_grid->name();
   const auto nlev     = m_helper_fields.at("FT_phys").get_view<const Real **>().extent_int(1);
-  const auto nq       = get_group_in("tracers", gn).m_monolithic_field->get_view<const Real ***>().extent_int(1);
+  const auto nq =
+      get_group_in("tracers", gn).m_monolithic_field->get_view<const Real ***>().extent_int(1);
   assert(m_helper_fields.at("FT_phys").get_view<const Real **>().extent_int(0) == nelem * npg);
 
   const auto uv_ndim = m_helper_fields.at("FM_phys").get_view<const Real ***>().extent_int(1);
   assert(uv_ndim == 2);
 
-  const auto T =
-      Homme::GllFvRemap::CPhys2T(m_helper_fields.at("FT_phys").get_view<const Real **>().data(), nelem, npg, nlev);
-  const auto uv = Homme::GllFvRemap::CPhys3T(m_helper_fields.at("FM_phys").get_view<const Real ***>().data(), nelem,
-                                             npg, uv_ndim, nlev);
-  const auto q  = Homme::GllFvRemap::CPhys3T(
-      get_group_in("tracers", gn).m_monolithic_field->get_view<const Real ***>().data(), nelem, npg, nq, nlev);
+  const auto T = Homme::GllFvRemap::CPhys2T(
+      m_helper_fields.at("FT_phys").get_view<const Real **>().data(), nelem, npg, nlev);
+  const auto uv = Homme::GllFvRemap::CPhys3T(
+      m_helper_fields.at("FM_phys").get_view<const Real ***>().data(), nelem, npg, uv_ndim, nlev);
+  const auto q = Homme::GllFvRemap::CPhys3T(
+      get_group_in("tracers", gn).m_monolithic_field->get_view<const Real ***>().data(), nelem, npg,
+      nq, nlev);
 
   gfr.run_fv_phys_to_dyn(time_idx, T, uv, q);
   Kokkos::fence();
@@ -221,7 +234,8 @@ void HommeDynamics::remap_fv_phys_to_dyn() const {
 }
 
 // See the [rrtmgp active gases] note in share/util/eamxx_fv_phys_rrtmgp_active_gases_workaround.hpp
-void HommeDynamics ::fv_phys_rrtmgp_active_gases_init(const std::shared_ptr<const GridsManager> &gm) {
+void HommeDynamics ::fv_phys_rrtmgp_active_gases_init(
+    const std::shared_ptr<const GridsManager> &gm) {
   // NOTE: we would like to avoid this if it's a restart run, but at this point of the
   //       init sequence we still don't know the run type. So we must add the trace gases
   //       fields, and we will deal with them later
@@ -281,10 +295,13 @@ void HommeDynamics::fv_phys_rrtmgp_active_gases_remap(const RunType run_type) {
         auto &f_phys       = get_field_out(e, pgn);
         const auto &v_dgll = f_dgll.get_view<const Real ****>();
         const auto &v_phys = f_phys.get_view<Real **>();
-        assert(v_dgll.extent_int(0) == nelem and v_dgll.extent_int(1) * v_dgll.extent_int(2) == ngll);
-        const auto in_dgll = Homme::GllFvRemap::CPhys3T(v_dgll.data(), nelem, 1, ngll, v_dgll.extent_int(3));
+        assert(v_dgll.extent_int(0) == nelem and
+               v_dgll.extent_int(1) * v_dgll.extent_int(2) == ngll);
+        const auto in_dgll =
+            Homme::GllFvRemap::CPhys3T(v_dgll.data(), nelem, 1, ngll, v_dgll.extent_int(3));
         assert(nelem * npg == v_phys.extent_int(0));
-        const auto out_phys = Homme::GllFvRemap::Phys3T(v_phys.data(), nelem, npg, 1, v_phys.extent_int(1));
+        const auto out_phys =
+            Homme::GllFvRemap::Phys3T(v_phys.data(), nelem, npg, 1, v_phys.extent_int(1));
         gfr.remap_tracer_dyn_to_fv_phys(time_idx, 1, in_dgll, out_phys);
         Kokkos::fence();
 
diff --git i/components/eamxx/src/dynamics/homme/eamxx_homme_process_interface.cpp w/components/eamxx/src/dynamics/homme/eamxx_homme_process_interface.cpp
index 7ff703e077..9669c9adb5 100644
--- i/components/eamxx/src/dynamics/homme/eamxx_homme_process_interface.cpp
+++ w/components/eamxx/src/dynamics/homme/eamxx_homme_process_interface.cpp
@@ -132,8 +132,8 @@ void HommeDynamics::set_grids(const std::shared_ptr<const GridsManager> grids_ma
      Additionally, Homme computes forcing as:
        - FT (temperature forcing): FT_dyn=PD( (T_phys_new - T_phys_old)/dt )
        - FM (momentum forcing): FM_dyn=PD( (v_phys_new-v_phys_old)/dt) )
-       - FQ (tracers forcing): FQ_dyn =  PD(Q_phys_new) (used as a hard adjustment or in increment calc)
-     Here, PD(x) is quantity x remapped from physics to dynamics grid (viceversa for DP(x)).
+       - FQ (tracers forcing): FQ_dyn =  PD(Q_phys_new) (used as a hard adjustment or in increment
+     calc) Here, PD(x) is quantity x remapped from physics to dynamics grid (viceversa for DP(x)).
      So for BFB restart, we need so store T_phys_old, [u,v,w]_phys_old.
      However, Homme computes Q=Qdp/dp at the end of the time step, so for BFB restarts we need to
      save Qdp only, and recompute Q_dyn_old=Qdp/dp.
@@ -207,10 +207,11 @@ void HommeDynamics::set_grids(const std::shared_ptr<const GridsManager> grids_ma
   create_helper_field("ps_dyn", {EL, TL, GP, GP}, {nelem, NTL, NP, NP}, dgn);
   create_helper_field("phis_dyn", {EL, GP, GP}, {nelem, NP, NP}, dgn);
   create_helper_field("omega_dyn", {EL, GP, GP, LEV}, {nelem, NP, NP, nlev_mid}, dgn);
-  create_helper_field("Qdp_dyn", {EL, TL, CMP, GP, GP, LEV}, {nelem, QTL, HOMMEXX_QSIZE_D, NP, NP, nlev_mid}, dgn);
+  create_helper_field("Qdp_dyn", {EL, TL, CMP, GP, GP, LEV},
+                      {nelem, QTL, HOMMEXX_QSIZE_D, NP, NP, nlev_mid}, dgn);
 
-  // For BFB restart, we need to read in the state on the dyn grid. The state above has NTL time slices,
-  // but only one is really needed for restart. Therefore, we create "dynamic" subfields for
+  // For BFB restart, we need to read in the state on the dyn grid. The state above has NTL time
+  // slices, but only one is really needed for restart. Therefore, we create "dynamic" subfields for
   // the state fields. This allows to save/read only the single slice needed
   // NOTE: the fcn init_time_level_c in Homme should really init also the qdp time levels,
   //       but it doesn't. So let's update them here. Notice that the qdp time levels update
@@ -264,12 +265,13 @@ size_t HommeDynamics::requested_buffer_size_in_bytes() const {
   auto &caar = c.create_if_not_there<CaarFunctor>(num_elems, params);
   auto &hvf  = c.create_if_not_there<HyperviscosityFunctor>(num_elems, params);
   auto &ff   = c.create_if_not_there<ForcingFunctor>(num_elems, num_elems, params.qsize);
-  auto &diag = c.create_if_not_there<Diagnostics>(num_elems, num_tracers, params.theta_hydrostatic_mode);
-  auto &vrm  = c.create_if_not_there<VerticalRemapManager>(num_elems);
+  auto &diag =
+      c.create_if_not_there<Diagnostics>(num_elems, num_tracers, params.theta_hydrostatic_mode);
+  auto &vrm = c.create_if_not_there<VerticalRemapManager>(num_elems);
 
-  const bool need_dirk =
-      (params.time_step_type == TimeStepType::ttype7_imex || params.time_step_type == TimeStepType::ttype9_imex ||
-       params.time_step_type == TimeStepType::ttype10_imex);
+  const bool need_dirk = (params.time_step_type == TimeStepType::ttype7_imex ||
+                          params.time_step_type == TimeStepType::ttype9_imex ||
+                          params.time_step_type == TimeStepType::ttype10_imex);
 
   // Request buffer sizes in FunctorsBuffersManager and then
   // return the total bytes using the calculated buffer size.
@@ -345,8 +347,9 @@ void HommeDynamics::initialize_impl(const RunType run_type) {
   //          to compute p_mid. Hence, if this assumption goes away, you need to restart
   //          p_mid by first remapping the restarted dp3d_dyn back to ref grid, and using
   //          that value to compute p_mid. Or, perhaps easier, write p_mid to restart file.
-  EKAT_REQUIRE_MSG(get_field_out("pseudo_density", pgn).get_header().get_tracking().get_providers().size() == 1,
-                   "Error! Someone other than dynamics is trying to update the pseudo_density.\n");
+  EKAT_REQUIRE_MSG(
+      get_field_out("pseudo_density", pgn).get_header().get_tracking().get_providers().size() == 1,
+      "Error! Someone other than dynamics is trying to update the pseudo_density.\n");
 
   // The groups 'tracers' and 'tracers_mass_dyn' should contain the same fields
   EKAT_REQUIRE_MSG(not get_group_out("Q", pgn).m_info->empty(),
@@ -389,7 +392,8 @@ void HommeDynamics::initialize_impl(const RunType run_type) {
     // ftype!=FORCING_0:
     //  1) remap Q_pgn->FQ_dyn
     // Remap Q directly into FQ, tendency computed in pre_process step
-    m_p2d_remapper->register_field(*get_group_out("Q", pgn).m_monolithic_field, m_helper_fields.at("FQ_dyn"));
+    m_p2d_remapper->register_field(*get_group_out("Q", pgn).m_monolithic_field,
+                                   m_helper_fields.at("FQ_dyn"));
     m_p2d_remapper->register_field(m_helper_fields.at("FT_phys"), m_helper_fields.at("FT_dyn"));
 
     // FM has 3 components on dyn grid, but only 2 on phys grid
@@ -398,13 +402,15 @@ void HommeDynamics::initialize_impl(const RunType run_type) {
     m_p2d_remapper->register_field(FM_phys.get_component(0), FM_dyn.get_component(0));
     m_p2d_remapper->register_field(FM_phys.get_component(1), FM_dyn.get_component(1));
 
-    // NOTE: for states, if/when we can remap subfields, we can remap the corresponding internal fields,
+    // NOTE: for states, if/when we can remap subfields, we can remap the corresponding internal
+    // fields,
     //       which are subviews of the corresponding helper field at time slice np1
     m_d2p_remapper->register_field(get_internal_field("vtheta_dp_dyn"), get_field_out("T_mid"));
     m_d2p_remapper->register_field(get_internal_field("v_dyn"), get_field_out("horiz_winds"));
     m_d2p_remapper->register_field(get_internal_field("dp3d_dyn"), get_field_out("pseudo_density"));
     m_d2p_remapper->register_field(get_internal_field("ps_dyn"), get_field_out("ps"));
-    m_d2p_remapper->register_field(m_helper_fields.at("Q_dyn"), *get_group_out("Q", pgn).m_monolithic_field);
+    m_d2p_remapper->register_field(m_helper_fields.at("Q_dyn"),
+                                   *get_group_out("Q", pgn).m_monolithic_field);
     m_d2p_remapper->register_field(m_helper_fields.at("omega_dyn"), get_field_out("omega"));
 
     m_p2d_remapper->registration_ends();
@@ -455,9 +461,11 @@ void HommeDynamics::initialize_impl(const RunType run_type) {
   using Interval   = FieldWithinIntervalCheck;
   using LowerBound = FieldLowerBoundCheck;
 
-  add_postcondition_check<LowerBound>(*get_group_out("Q", pgn).m_monolithic_field, m_phys_grid, 0, true);
+  add_postcondition_check<LowerBound>(*get_group_out("Q", pgn).m_monolithic_field, m_phys_grid, 0,
+                                      true);
   add_postcondition_check<Interval>(get_field_out("T_mid", pgn), m_phys_grid, 100.0, 500.0, false);
-  add_postcondition_check<Interval>(get_field_out("horiz_winds", pgn), m_phys_grid, -400.0, 400.0, false);
+  add_postcondition_check<Interval>(get_field_out("horiz_winds", pgn), m_phys_grid, -400.0, 400.0,
+                                    false);
   add_postcondition_check<Interval>(get_field_out("ps"), m_phys_grid, 30000.0, 120000.0, false);
 
   // Initialize Rayleigh friction variables
@@ -467,21 +475,22 @@ void HommeDynamics::initialize_impl(const RunType run_type) {
 void HommeDynamics::run_impl(const double dt) {
   try {
 
-    // Note: Homme's step lasts homme_dt*max(dt_remap_factor,dt_tracers_factor), and it must divide dt.
-    // We neeed to compute dt/homme_dt, and subcycle homme that many times
+    // Note: Homme's step lasts homme_dt*max(dt_remap_factor,dt_tracers_factor), and it must divide
+    // dt. We neeed to compute dt/homme_dt, and subcycle homme that many times
 
     // NOTE: we did not have atm_dt when we inited homme, so we set nsplit=1.
     //       Now we can compute the actual nsplit, and need to update its value
     //       in Hommexx's data structures.
     //       Also, nsplit calculation requires an integer atm timestep, so we
     //       check to ensure that's the case
-    EKAT_REQUIRE_MSG(std::abs(dt - std::round(dt)) < std::numeric_limits<double>::epsilon() * 10,
-                     "[HommeDynamics] Error! Input timestep departure from integer above tolerance.\n"
-                     "  - input dt : "
-                         << dt
-                         << "\n"
-                            "  - tolerance: "
-                         << std::numeric_limits<double>::epsilon() * 10 << "\n");
+    EKAT_REQUIRE_MSG(
+        std::abs(dt - std::round(dt)) < std::numeric_limits<double>::epsilon() * 10,
+        "[HommeDynamics] Error! Input timestep departure from integer above tolerance.\n"
+        "  - input dt : "
+            << dt
+            << "\n"
+               "  - tolerance: "
+            << std::numeric_limits<double>::epsilon() * 10 << "\n");
 
     if (m_bfb_hash_nstep > 0 && start_of_step_ts().get_num_steps() % m_bfb_hash_nstep == 0)
       print_fast_global_state_hash("Hommexx", start_of_step_ts());
@@ -701,7 +710,8 @@ void HommeDynamics::homme_post_process(const double dt) {
         const int &icol = team.league_rank();
 
         auto qv = ekat::subview(Q_view, icol, 0);
-        // TODO: Here we update the wet and dry pressure coordinates which is the same set of code used
+        // TODO: Here we update the wet and dry pressure coordinates which is the same set of code
+        // used
         //       in the update_pressure() subroutine.  A low-priority todo item would clean-up the
         //       interface to call update_pressure here or change that routine so that it can be
         //       called within the top-level Kokkos parallel_for loop.
@@ -719,8 +729,9 @@ void HommeDynamics::homme_post_process(const double dt) {
         auto p_dry_mid = ekat::subview(p_dry_mid_view, icol);
         auto p_dry_int = ekat::subview(p_dry_int_view, icol);
 
-        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, npacks),
-                             [&](const int &jpack) { dp_dry(jpack) = dp(jpack) * (1.0 - qv(jpack)); });
+        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, npacks), [&](const int &jpack) {
+          dp_dry(jpack) = dp(jpack) * (1.0 - qv(jpack));
+        });
         ColOps::column_scan<true>(team, nlevs, dp_dry, p_dry_int, ps0);
         team.team_barrier();
         ColOps::compute_midpoint_values(team, nlevs, p_dry_int, p_dry_mid);
@@ -834,7 +845,8 @@ void HommeDynamics::init_homme_views() {
   msg << "   npacks: " << npacks << "\n";
   msg << "   league_size: " << default_policy.league_size() << "\n";
   msg << "   team_size: " << default_policy.team_size() << "\n";
-  msg << "   concurrent teams: " << KT::ExeSpace().concurrency() / default_policy.team_size() << "\n";
+  msg << "   concurrent teams: " << KT::ExeSpace().concurrency() / default_policy.team_size()
+      << "\n";
 
   // TODO: Replace with scale_factor and laplacian_rigid_factor when available.
   // msg << "   rearth: " << params.rearth << "\n";
@@ -848,13 +860,14 @@ void HommeDynamics::init_homme_views() {
   state.m_v    = v_type(v_in.data(), nelem);
 
   // Virtual potential temperature
-  auto vtheta_in    = m_helper_fields.at("vtheta_dp_dyn").get_view<Homme::Scalar *[NTL][NP][NP][NVL]>();
+  auto vtheta_in =
+      m_helper_fields.at("vtheta_dp_dyn").get_view<Homme::Scalar *[NTL][NP][NP][NVL]>();
   using vtheta_type = std::remove_reference<decltype(state.m_vtheta_dp)>::type;
   state.m_vtheta_dp = vtheta_type(vtheta_in.data(), nelem);
 
   // Geopotential
-  auto phi_in     = m_helper_fields.at("phi_int_dyn").get_view<Homme::Scalar *[NTL][NP][NP][NVLI]>();
-  using phi_type  = std::remove_reference<decltype(state.m_phinh_i)>::type;
+  auto phi_in    = m_helper_fields.at("phi_int_dyn").get_view<Homme::Scalar *[NTL][NP][NP][NVLI]>();
+  using phi_type = std::remove_reference<decltype(state.m_phinh_i)>::type;
   state.m_phinh_i = phi_type(phi_in.data(), nelem);
 
   // Vertical velocity
@@ -863,7 +876,8 @@ void HommeDynamics::init_homme_views() {
   state.m_w_i  = w_type(w_in.data(), nelem);
 
   // Pseudo-density
-  auto dp3d_in    = m_helper_fields.at("dp3d_dyn").template get_view<Homme::Scalar *[NTL][NP][NP][NVL]>();
+  auto dp3d_in =
+      m_helper_fields.at("dp3d_dyn").template get_view<Homme::Scalar *[NTL][NP][NP][NVL]>();
   using dp3d_type = std::remove_reference<decltype(state.m_dp3d)>::type;
   state.m_dp3d    = dp3d_type(dp3d_in.data(), nelem);
 
@@ -873,7 +887,7 @@ void HommeDynamics::init_homme_views() {
   state.m_ps_v  = ps_type(ps_in.data(), nelem);
 
   // Vertical pressure velocity
-  auto omega_in     = m_helper_fields.at("omega_dyn").template get_view<Homme::Scalar *[NP][NP][NVL]>();
+  auto omega_in = m_helper_fields.at("omega_dyn").template get_view<Homme::Scalar *[NP][NP][NVL]>();
   using omega_type  = std::remove_reference<decltype(derived.m_omega_p)>::type;
   derived.m_omega_p = omega_type(omega_in.data(), nelem);
 
@@ -883,7 +897,8 @@ void HommeDynamics::init_homme_views() {
   tracers.Q    = q_type(q_in.data(), nelem, qsize);
 
   // Tracers mass
-  auto qdp_in    = m_helper_fields.at("Qdp_dyn").template get_view<Homme::Scalar *[QTL][QSZ][NP][NP][NVL]>();
+  auto qdp_in =
+      m_helper_fields.at("Qdp_dyn").template get_view<Homme::Scalar *[QTL][QSZ][NP][NP][NVL]>();
   using qdp_type = std::remove_reference<decltype(tracers.qdp)>::type;
   tracers.qdp    = qdp_type(qdp_in.data(), nelem);
 
@@ -908,7 +923,8 @@ void HommeDynamics::init_homme_views() {
 }
 
 void HommeDynamics::restart_homme_state() {
-  // Safety checks: internal fields *should* have been restarted (and therefore have a valid timestamp)
+  // Safety checks: internal fields *should* have been restarted (and therefore have a valid
+  // timestamp)
   for (auto &f : get_internal_fields()) {
     auto ts = f.get_header().get_tracking().get_time_stamp();
     EKAT_REQUIRE_MSG(ts.is_valid(), "Error! Found HommeDynamics internal field not restarted.\n"
@@ -943,24 +959,26 @@ void HommeDynamics::restart_homme_state() {
   const int npacks  = ekat::npack<Pack>(nlevs);
   const int qsize   = params.qsize;
 
-  // NOTE: when restarting stuff like T_prev, and other "previous steps" quantities that HommeDynamics
+  // NOTE: when restarting stuff like T_prev, and other "previous steps" quantities that
+  // HommeDynamics
   //       uses for tendencies calculation, we need to compute them in the *exact same way* as they
   //       were computed during the original simulation (in homme_post_process).
   //       E.g., we read vtheta_dp(dyn) from restart file, and need to recompute T_prev. Inside
   //       homme_post_process, we use qv(ref), but that's the qv obtained by remapping qv(dyn)
   //       to ref grid *right after homme ran*. Here, we cannot use qv(ref) as read from restart
   //       file, since that's qv(ref) *at the end of the timestep* in the original simulation.
-  //       Therefore, we need to remap the end-of-homme-step qv from dyn to ref grid, and use that one.
-  //       Another field we need is dp3d(ref), but Homme *CHECKS* that no other atm proc updates
-  //       dp3d(ref), so the p2d-remapped value read from restart file *coincides* with the value at the end
-  //       of the last Homme run. So we can safely recompute pressure using p2d(dp_dyn), with dp_dynread from restart.
+  //       Therefore, we need to remap the end-of-homme-step qv from dyn to ref grid, and use that
+  //       one. Another field we need is dp3d(ref), but Homme *CHECKS* that no other atm proc
+  //       updates dp3d(ref), so the p2d-remapped value read from restart file *coincides* with the
+  //       value at the end of the last Homme run. So we can safely recompute pressure using
+  //       p2d(dp_dyn), with dp_dynread from restart.
 
   // Copy all restarted dyn states on all timelevels.
   copy_dyn_states_to_all_timelevels();
 
   if (params.theta_hydrostatic_mode) {
-    // Nothing read from restart file for w_int, but Homme still does some global reduction on w_int when
-    // printing the state, so we need to make sure it doesn't contain NaNs
+    // Nothing read from restart file for w_int, but Homme still does some global reduction on w_int
+    // when printing the state, so we need to make sure it doesn't contain NaNs
     m_helper_fields.at("w_int_dyn").deep_copy(0);
   }
 
@@ -971,12 +989,13 @@ void HommeDynamics::restart_homme_state() {
   auto dp_dyn_view  = get_internal_field("dp3d_dyn", dgn).get_view<Pack ****>();
   Kokkos::parallel_for(
       Kokkos::RangePolicy<>(0, nelem * qsize * NGP * NGP * npacks), KOKKOS_LAMBDA(const int idx) {
-        const int ie                  = idx / (qsize * NGP * NGP * npacks);
-        const int iq                  = (idx / (NGP * NGP * npacks)) % qsize;
-        const int ip                  = (idx / (NGP * npacks)) % NGP;
-        const int jp                  = (idx / npacks) % NGP;
-        const int k                   = idx % npacks;
-        Q_dyn_view(ie, iq, ip, jp, k) = Qdp_dyn_view(ie, iq, ip, jp, k) / dp_dyn_view(ie, ip, jp, k);
+        const int ie = idx / (qsize * NGP * NGP * npacks);
+        const int iq = (idx / (NGP * NGP * npacks)) % qsize;
+        const int ip = (idx / (NGP * npacks)) % NGP;
+        const int jp = (idx / npacks) % NGP;
+        const int k  = idx % npacks;
+        Q_dyn_view(ie, iq, ip, jp, k) =
+            Qdp_dyn_view(ie, iq, ip, jp, k) / dp_dyn_view(ie, ip, jp, k);
       });
 
   if (fv_phys_active()) {
@@ -987,7 +1006,8 @@ void HommeDynamics::restart_homme_state() {
   m_ic_remapper->registration_begins();
   m_ic_remapper->register_field(m_helper_fields.at("FT_phys"), get_internal_field("vtheta_dp_dyn"));
   m_ic_remapper->register_field(m_helper_fields.at("FM_phys"), get_internal_field("v_dyn"));
-  m_ic_remapper->register_field(get_field_out("pseudo_density", pgn), get_internal_field("dp3d_dyn"));
+  m_ic_remapper->register_field(get_field_out("pseudo_density", pgn),
+                                get_internal_field("dp3d_dyn"));
   auto qv_prev_ref = std::make_shared<Field>();
   auto Q_dyn       = m_helper_fields.at("Q_dyn");
   if (params.ftype == Homme::ForcingAlg::FORCING_2) {
@@ -1078,7 +1098,8 @@ void HommeDynamics::initialize_homme_state() {
       policy_dp, KOKKOS_LAMBDA(const KT::MemberType &team) {
         const int icol = team.league_rank();
         Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlevs), [&](const int ilev) {
-          dp_ref(icol, ilev) = (hyai(ilev + 1) - hyai(ilev)) * ps0 + (hybi(ilev + 1) - hybi(ilev)) * ps_ref(icol);
+          dp_ref(icol, ilev) =
+              (hyai(ilev + 1) - hyai(ilev)) * ps0 + (hybi(ilev + 1) - hybi(ilev)) * ps_ref(icol);
         });
         team.team_barrier();
       });
@@ -1089,11 +1110,13 @@ void HommeDynamics::initialize_homme_state() {
   //       the helper fields (which have NTL time slices).
   m_ic_remapper->registration_begins();
   m_ic_remapper->register_field(get_field_in("horiz_winds", rgn), get_internal_field("v_dyn"));
-  m_ic_remapper->register_field(get_field_out("pseudo_density", rgn), get_internal_field("dp3d_dyn"));
+  m_ic_remapper->register_field(get_field_out("pseudo_density", rgn),
+                                get_internal_field("dp3d_dyn"));
   m_ic_remapper->register_field(get_field_in("ps", rgn), get_internal_field("ps_dyn"));
   m_ic_remapper->register_field(get_field_in("phis", rgn), m_helper_fields.at("phis_dyn"));
   m_ic_remapper->register_field(get_field_in("T_mid", rgn), get_internal_field("vtheta_dp_dyn"));
-  m_ic_remapper->register_field(*get_group_in("tracers", rgn).m_monolithic_field, m_helper_fields.at("Q_dyn"));
+  m_ic_remapper->register_field(*get_group_in("tracers", rgn).m_monolithic_field,
+                                m_helper_fields.at("Q_dyn"));
   m_ic_remapper->registration_ends();
   m_ic_remapper->remap_fwd();
 
@@ -1117,7 +1140,8 @@ void HommeDynamics::initialize_homme_state() {
   const auto phi_int_view  = m_helper_fields.at("phi_int_dyn").get_view<Pack *****>();
   const auto hyai0         = hvcoord.hybrid_ai0;
   // Need two temporaries, for pi_mid and pi_int
-  const auto policy = ESU::get_thread_range_parallel_scan_team_policy(nelem * NGP * NGP, npacks_mid);
+  const auto policy =
+      ESU::get_thread_range_parallel_scan_team_policy(nelem * NGP * NGP, npacks_mid);
   WorkspaceMgr wsm(npacks_int, 2, policy);
   Kokkos::parallel_for(
       policy, KOKKOS_LAMBDA(const KT::MemberType &team) {
@@ -1149,7 +1173,9 @@ void HommeDynamics::initialize_homme_state() {
         team.team_barrier();
 
         // Init geopotential
-        auto dphi    = [&](const int ilev) -> Pack { return EOS::compute_dphi(vTh_dp(ilev), p_mid(ilev)); };
+        auto dphi = [&](const int ilev) -> Pack {
+          return EOS::compute_dphi(vTh_dp(ilev), p_mid(ilev));
+        };
         auto phi_int = ekat::subview(phi_int_view, ie, n0, igp, jgp);
         ColOps::column_scan<false>(team, nlevs, dphi, phi_int, phis_dyn_view(ie, igp, jgp));
       });
@@ -1185,7 +1211,8 @@ void HommeDynamics::initialize_homme_state() {
   const auto q   = tracers.Q;
   const auto dp  = c.get<Homme::ElementsState>().m_dp3d;
   Kokkos::parallel_for(
-      Kokkos::RangePolicy<>(0, nelem * qsize * NGP * NGP * npacks_mid), KOKKOS_LAMBDA(const int idx) {
+      Kokkos::RangePolicy<>(0, nelem * qsize * NGP * NGP * npacks_mid),
+      KOKKOS_LAMBDA(const int idx) {
         const int ie = idx / (qsize * NGP * NGP * npacks_mid);
         const int iq = (idx / (NGP * NGP * npacks_mid)) % qsize;
         const int ip = (idx / (NGP * npacks_mid)) % NGP;
@@ -1293,8 +1320,9 @@ void HommeDynamics::update_pressure(const std::shared_ptr<const AbstractGrid> &g
         auto p_dry_mid = ekat::subview(p_dry_mid_view, icol);
         auto p_dry_int = ekat::subview(p_dry_int_view, icol);
 
-        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, npacks),
-                             [&](const int &jpack) { dp_dry(jpack) = dp(jpack) * (1.0 - qv(jpack)); });
+        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, npacks), [&](const int &jpack) {
+          dp_dry(jpack) = dp(jpack) * (1.0 - qv(jpack));
+        });
 
         ColOps::column_scan<true>(team, nlevs, dp, p_int, ps0);
         team.team_barrier();
diff --git i/components/eamxx/src/dynamics/homme/eamxx_homme_process_interface.hpp w/components/eamxx/src/dynamics/homme/eamxx_homme_process_interface.hpp
index b453be4330..849ead5dc8 100644
--- i/components/eamxx/src/dynamics/homme/eamxx_homme_process_interface.hpp
+++ w/components/eamxx/src/dynamics/homme/eamxx_homme_process_interface.hpp
@@ -126,8 +126,8 @@ protected:
   void init_buffers(const ATMBufferManager &buffer_manager);
 
   // Creates an helper field, not to be shared with the AD's FieldManager
-  void create_helper_field(const std::string &name, const std::vector<FieldTag> &tags, const std::vector<int> &dims,
-                           const std::string &grid);
+  void create_helper_field(const std::string &name, const std::vector<FieldTag> &tags,
+                           const std::vector<int> &dims, const std::string &grid);
 
   // Some helper fields.
   std::map<std::string, Field> m_helper_fields;
diff --git i/components/eamxx/src/dynamics/homme/homme_grids_manager.cpp w/components/eamxx/src/dynamics/homme/homme_grids_manager.cpp
index a977547287..fab160669d 100644
--- i/components/eamxx/src/dynamics/homme/homme_grids_manager.cpp
+++ w/components/eamxx/src/dynamics/homme/homme_grids_manager.cpp
@@ -24,7 +24,8 @@
 
 namespace scream {
 
-HommeGridsManager::HommeGridsManager(const ekat::Comm &comm, const ekat::ParameterList &p) : m_comm(comm), m_params(p) {
+HommeGridsManager::HommeGridsManager(const ekat::Comm &comm, const ekat::ParameterList &p)
+    : m_comm(comm), m_params(p) {
   if (!is_parallel_inited_f90()) {
     // While we're here, we can init homme's parallel session
     auto fcomm = MPI_Comm_c2f(comm.mpi_comm());
@@ -52,12 +53,14 @@ HommeGridsManager::~HommeGridsManager() {
   HommeContextUser::singleton().remove_user();
 }
 
-HommeGridsManager::remapper_ptr_type HommeGridsManager::do_create_remapper(const grid_ptr_type from_grid,
-                                                                           const grid_ptr_type to_grid) const {
+HommeGridsManager::remapper_ptr_type
+HommeGridsManager::do_create_remapper(const grid_ptr_type from_grid,
+                                      const grid_ptr_type to_grid) const {
   const auto from = from_grid->name();
   const auto to   = to_grid->name();
 
-  EKAT_REQUIRE_MSG(from == "dynamics" || to == "dynamics", "Error! Either source or target grid must be 'dynamics'.\n");
+  EKAT_REQUIRE_MSG(from == "dynamics" || to == "dynamics",
+                   "Error! Either source or target grid must be 'dynamics'.\n");
 
   const bool p2d = to == "dynamics";
 
@@ -74,7 +77,8 @@ HommeGridsManager::remapper_ptr_type HommeGridsManager::do_create_remapper(const
       return std::make_shared<InverseRemapper>(pd_remapper);
     }
   } else {
-    ekat::error::runtime_abort("Error! P-D remapping only implemented for 'physics_gll' phys grid.\n");
+    ekat::error::runtime_abort(
+        "Error! P-D remapping only implemented for 'physics_gll' phys grid.\n");
   }
   return nullptr;
 }
@@ -85,8 +89,9 @@ void HommeGridsManager::build_grids() {
   const ci_string pg_rebalance = m_params.get<std::string>("physics_grid_rebalance", "none");
 
   // Get the physics grid code
-  std::vector<int> pg_codes{m_pg_codes["gll"]["none"], // We always need this to read/write dyn grid stuff
-                            m_pg_codes[pg_type][pg_rebalance]};
+  std::vector<int> pg_codes{
+      m_pg_codes["gll"]["none"], // We always need this to read/write dyn grid stuff
+      m_pg_codes[pg_type][pg_rebalance]};
   // In case the two pg codes are the same...
   auto it              = std::unique(pg_codes.begin(), pg_codes.end());
   const int *codes_ptr = pg_codes.data();
@@ -158,8 +163,8 @@ void HommeGridsManager::build_dynamics_grid() {
   auto lon_h     = lon.get_view<Real ***, Host>();
 
   // Get (ie,igp,jgp,gid) data for each dof
-  get_dyn_grid_data_f90(dg_dofs_h.data(), cg_dofs_h.data(), elgpgp_h.data(), elgids_h.data(), lat_h.data(),
-                        lon_h.data());
+  get_dyn_grid_data_f90(dg_dofs_h.data(), cg_dofs_h.data(), elgpgp_h.data(), elgids_h.data(),
+                        lat_h.data(), lon_h.data());
 
   dg_dofs.sync_to_dev();
   cg_dofs.sync_to_dev();
@@ -291,7 +296,7 @@ void HommeGridsManager::build_physics_grid(const ci_string &type, const ci_strin
   if (is_planar_geometry_f90()) {
     // If running with IOP, store grid length size
     FieldLayout scalar0d({}, {});
-    auto dx_short_f                     = phys_grid->create_geometry_data("dx_short", scalar0d, rad);
+    auto dx_short_f = phys_grid->create_geometry_data("dx_short", scalar0d, rad);
     dx_short_f.get_view<Real, Host>()() = get_dx_short_f90(0);
     dx_short_f.sync_to_dev();
   }
@@ -354,8 +359,8 @@ void HommeGridsManager::initialize_vertical_coordinates(const nonconstgrid_ptr_t
 
   // Set vcoords in f90
   // NOTE: homme does the check for these arrays, so no need to do any property check here
-  prim_set_hvcoords_f90(ps0, host_views["hyai"].data(), host_views["hybi"].data(), host_views["hyam"].data(),
-                        host_views["hybm"].data());
+  prim_set_hvcoords_f90(ps0, host_views["hyai"].data(), host_views["hybi"].data(),
+                        host_views["hyam"].data(), host_views["hybm"].data());
 }
 
 void HommeGridsManager::build_pg_codes() {
diff --git i/components/eamxx/src/dynamics/homme/homme_grids_manager.hpp w/components/eamxx/src/dynamics/homme/homme_grids_manager.hpp
index 59ca150ca5..5ed447085f 100644
--- i/components/eamxx/src/dynamics/homme/homme_grids_manager.hpp
+++ w/components/eamxx/src/dynamics/homme/homme_grids_manager.hpp
@@ -29,7 +29,8 @@ protected:
   void build_physics_grid(const ci_string &type, const ci_string &rebalance);
 
 protected:
-  remapper_ptr_type do_create_remapper(const grid_ptr_type from_grid, const grid_ptr_type to_grid) const;
+  remapper_ptr_type do_create_remapper(const grid_ptr_type from_grid,
+                                       const grid_ptr_type to_grid) const;
 
   void build_pg_codes();
 
@@ -46,7 +47,8 @@ protected:
   strmap_t<strmap_t<int>> m_pg_codes;
 };
 
-inline std::shared_ptr<GridsManager> create_homme_grids_manager(const ekat::Comm &comm, const ekat::ParameterList &p) {
+inline std::shared_ptr<GridsManager> create_homme_grids_manager(const ekat::Comm &comm,
+                                                                const ekat::ParameterList &p) {
   return std::make_shared<HommeGridsManager>(comm, p);
 }
 
diff --git i/components/eamxx/src/dynamics/homme/interface/eamxx_homme_interface.hpp w/components/eamxx/src/dynamics/homme/interface/eamxx_homme_interface.hpp
index 939e8f9db7..29d15bc609 100644
--- i/components/eamxx/src/dynamics/homme/interface/eamxx_homme_interface.hpp
+++ w/components/eamxx/src/dynamics/homme/interface/eamxx_homme_interface.hpp
@@ -58,11 +58,12 @@ int get_num_local_columns_f90(const int pgN);
 int get_num_global_columns_f90(const int pgN);
 int get_num_local_elems_f90();
 int get_num_global_elems_f90();
-void get_dyn_grid_data_f90(AbstractGrid::gid_type *const &dg_gids, AbstractGrid::gid_type *const &cg_gids,
-                           int *const &elgp, AbstractGrid::gid_type *const &elgids, double *const &lat,
+void get_dyn_grid_data_f90(AbstractGrid::gid_type *const &dg_gids,
+                           AbstractGrid::gid_type *const &cg_gids, int *const &elgp,
+                           AbstractGrid::gid_type *const &elgids, double *const &lat,
                            double *const &lon);
-void get_phys_grid_data_f90(const int &pg_type, AbstractGrid::gid_type *const &gids, double *const &lat,
-                            double *const &lon, double *const &area);
+void get_phys_grid_data_f90(const int &pg_type, AbstractGrid::gid_type *const &gids,
+                            double *const &lat, double *const &lon, double *const &area);
 int get_homme_nsplit_f90(const int &atm_dt);
 double get_dx_short_f90(const int elem_idx);
 
diff --git i/components/eamxx/src/dynamics/homme/physics_dynamics_remapper.cpp w/components/eamxx/src/dynamics/homme/physics_dynamics_remapper.cpp
index 23663832ff..2f237cef66 100644
--- i/components/eamxx/src/dynamics/homme/physics_dynamics_remapper.cpp
+++ w/components/eamxx/src/dynamics/homme/physics_dynamics_remapper.cpp
@@ -19,7 +19,8 @@
 namespace {
 
 // Utility function to convert a view from a Field into a Homme-compatible view
-template <typename DataType>::Homme::ExecViewUnmanaged<DataType> getHommeView(const scream::Field &f) {
+template <typename DataType>
+::Homme::ExecViewUnmanaged<DataType> getHommeView(const scream::Field &f) {
   auto p             = f.get_header().get_parent();
   auto scream_view   = f.template get_view<DataType>();
   using homme_view_t = ::Homme::ExecViewUnmanaged<DataType>;
@@ -38,10 +39,13 @@ template <typename DataType>::Homme::ExecViewUnmanaged<DataType> getHommeView(co
 
 namespace scream {
 
-PhysicsDynamicsRemapper::PhysicsDynamicsRemapper(const grid_ptr_type &phys_grid, const grid_ptr_type &dyn_grid)
+PhysicsDynamicsRemapper::PhysicsDynamicsRemapper(const grid_ptr_type &phys_grid,
+                                                 const grid_ptr_type &dyn_grid)
     : AbstractRemapper(phys_grid, dyn_grid) {
-  EKAT_REQUIRE_MSG(dyn_grid->type() == GridType::SE, "Error! Input dynamics grid is not a SE grid.\n");
-  EKAT_REQUIRE_MSG(phys_grid->type() == GridType::Point, "Error! Input physics grid is not a Point grid.\n");
+  EKAT_REQUIRE_MSG(dyn_grid->type() == GridType::SE,
+                   "Error! Input dynamics grid is not a SE grid.\n");
+  EKAT_REQUIRE_MSG(phys_grid->type() == GridType::Point,
+                   "Error! Input physics grid is not a Point grid.\n");
 
   m_dyn_grid  = dyn_grid;
   m_phys_grid = phys_grid;
@@ -62,9 +66,10 @@ void PhysicsDynamicsRemapper::registration_ends_impl() {
 }
 
 void PhysicsDynamicsRemapper::initialize_device_variables() {
-  m_layout              = decltype(m_layout)("layout", this->m_num_fields);
-  m_pack_alloc_property = decltype(m_pack_alloc_property)("pack_alloc_property", this->m_num_fields);
-  m_num_levels          = decltype(m_num_levels)("num_physical_levels", this->m_num_fields);
+  m_layout = decltype(m_layout)("layout", this->m_num_fields);
+  m_pack_alloc_property =
+      decltype(m_pack_alloc_property)("pack_alloc_property", this->m_num_fields);
+  m_num_levels = decltype(m_num_levels)("num_physical_levels", this->m_num_fields);
 
   for (auto which : {'P', 'D'}) {
     auto &repo   = which == 'P' ? m_phys_repo : m_dyn_repo;
@@ -158,7 +163,8 @@ void PhysicsDynamicsRemapper::initialize_device_variables() {
 
     const auto &pap = ph.get_alloc_properties();
     const auto &dap = dh.get_alloc_properties();
-    if (is_field_3d && pap.template is_compatible<pack_type>() && dap.template is_compatible<pack_type>()) {
+    if (is_field_3d && pap.template is_compatible<pack_type>() &&
+        dap.template is_compatible<pack_type>()) {
       h_pack_alloc_property(i) = AllocPropType::PackAlloc;
     } else if (is_field_3d && pap.template is_compatible<small_pack_type>() &&
                dap.template is_compatible<small_pack_type>()) {
@@ -172,8 +178,8 @@ void PhysicsDynamicsRemapper::initialize_device_variables() {
   Kokkos::deep_copy(m_num_levels, h_num_levels);
 }
 
-bool PhysicsDynamicsRemapper::subfields_info_has_changed(const std::map<int, SubviewInfo> &subfield_info,
-                                                         const std::vector<Field> &fields) const {
+bool PhysicsDynamicsRemapper::subfields_info_has_changed(
+    const std::map<int, SubviewInfo> &subfield_info, const std::vector<Field> &fields) const {
   for (const auto &it : subfield_info) {
     const auto &f        = fields[it.first];
     const auto &info_old = it.second;
@@ -185,8 +191,9 @@ bool PhysicsDynamicsRemapper::subfields_info_has_changed(const std::map<int, Sub
   return false;
 }
 
-void PhysicsDynamicsRemapper::update_subfields_views(const std::map<int, SubviewInfo> &subfield_info,
-                                                     const ViewsRepo &repo, const std::vector<Field> &fields) const {
+void PhysicsDynamicsRemapper::update_subfields_views(
+    const std::map<int, SubviewInfo> &subfield_info, const ViewsRepo &repo,
+    const std::vector<Field> &fields) const {
   auto get_view = [&](const int i, const Field &f) {
     const auto rank = f.get_header().get_identifier().get_layout().rank();
     switch (rank) {
@@ -309,17 +316,17 @@ void PhysicsDynamicsRemapper::remap_fwd_impl() {
   const auto concurrency = KT::ExeSpace().concurrency();
 #ifdef KOKKOS_ENABLE_CUDA
 #ifdef KOKKOS_ENABLE_DEBUG
-  const int team_size =
-      std::min(256, std::min(128 * m_num_phys_cols, 32 * (concurrency / this->m_num_fields + 31) / 32));
+  const int team_size = std::min(
+      256, std::min(128 * m_num_phys_cols, 32 * (concurrency / this->m_num_fields + 31) / 32));
 #else
-  const int team_size =
-      std::min(1024, std::min(128 * m_num_phys_cols, 32 * (concurrency / this->m_num_fields + 31) / 32));
+  const int team_size = std::min(
+      1024, std::min(128 * m_num_phys_cols, 32 * (concurrency / this->m_num_fields + 31) / 32));
 #endif
 #endif
 
 #if defined KOKKOS_ENABLE_HIP || defined KOKKOS_ENABLE_SYCL
-  const int team_size =
-      std::min(256, std::min(128 * m_num_phys_cols, 32 * (concurrency / this->m_num_fields + 31) / 32));
+  const int team_size = std::min(
+      256, std::min(128 * m_num_phys_cols, 32 * (concurrency / this->m_num_fields + 31) / 32));
 #endif
 
 // should exclude above cases of CUDA and HIP
@@ -388,7 +395,8 @@ void PhysicsDynamicsRemapper::setup_boundary_exchange() {
       }
       break;
     default:
-      EKAT_ERROR_MSG("Error! Invalid layout. This is an internal error. Please, contact developers\n");
+      EKAT_ERROR_MSG(
+          "Error! Invalid layout. This is an internal error. Please, contact developers\n");
     }
   }
 
@@ -433,13 +441,15 @@ void PhysicsDynamicsRemapper::setup_boundary_exchange() {
       }
       break;
     default:
-      EKAT_ERROR_MSG("Error! Invalid layout. This is an internal error. Please, contact developers\n");
+      EKAT_ERROR_MSG(
+          "Error! Invalid layout. This is an internal error. Please, contact developers\n");
     }
   }
   m_be->registration_completed();
 }
 
-template <typename MT> KOKKOS_FUNCTION void PhysicsDynamicsRemapper::local_remap_fwd_2d(const MT &team) const {
+template <typename MT>
+KOKKOS_FUNCTION void PhysicsDynamicsRemapper::local_remap_fwd_2d(const MT &team) const {
   const int i = team.league_rank();
 
   switch (m_layout(i)) {
@@ -465,7 +475,7 @@ template <typename MT> KOKKOS_FUNCTION void PhysicsDynamicsRemapper::local_remap
       const int icol = idx / vec_dim;
       const int idim = idx % vec_dim;
 
-      const auto &elgp                     = Kokkos::subview(m_lid2elgp, m_p2d(icol), Kokkos::ALL());
+      const auto &elgp = Kokkos::subview(m_lid2elgp, m_p2d(icol), Kokkos::ALL());
       dyn(elgp[0], idim, elgp[1], elgp[2]) = phys(icol, idim);
     };
     Kokkos::parallel_for(tr, f);
@@ -494,7 +504,7 @@ KOKKOS_FUNCTION void PhysicsDynamicsRemapper::local_remap_fwd_3d(const MT &team)
       const int icol = idx / num_packs;
       const int ilev = idx % num_packs;
 
-      const auto &elgp                     = Kokkos::subview(m_lid2elgp, m_p2d(icol), Kokkos::ALL());
+      const auto &elgp = Kokkos::subview(m_lid2elgp, m_p2d(icol), Kokkos::ALL());
       dyn(elgp[0], elgp[1], elgp[2], ilev) = phys(icol, ilev);
     };
     Kokkos::parallel_for(tr, f);
@@ -511,7 +521,7 @@ KOKKOS_FUNCTION void PhysicsDynamicsRemapper::local_remap_fwd_3d(const MT &team)
       const int idim = (idx / num_packs) % vec_dim;
       const int ilev = idx % num_packs;
 
-      const auto &elgp                           = Kokkos::subview(m_lid2elgp, m_p2d(icol), Kokkos::ALL());
+      const auto &elgp = Kokkos::subview(m_lid2elgp, m_p2d(icol), Kokkos::ALL());
       dyn(elgp[0], idim, elgp[1], elgp[2], ilev) = phys(icol, idim, ilev);
     };
     Kokkos::parallel_for(tr, f);
@@ -522,7 +532,8 @@ KOKKOS_FUNCTION void PhysicsDynamicsRemapper::local_remap_fwd_3d(const MT &team)
   }
 }
 
-template <typename MT> KOKKOS_FUNCTION void PhysicsDynamicsRemapper::local_remap_bwd_2d(const MT &team) const {
+template <typename MT>
+KOKKOS_FUNCTION void PhysicsDynamicsRemapper::local_remap_bwd_2d(const MT &team) const {
   const int rank   = team.league_rank();
   const int i      = rank % this->m_num_fields;
   const int icol   = rank / this->m_num_fields;
@@ -542,7 +553,7 @@ template <typename MT> KOKKOS_FUNCTION void PhysicsDynamicsRemapper::local_remap
     const int vec_dim = phys.extent(1);
 
     const auto tr = Kokkos::TeamVectorRange(team, vec_dim);
-    const auto f  = [&](const int idim) { phys(icol, idim) = dyn(elgp[0], idim, elgp[1], elgp[2]); };
+    const auto f = [&](const int idim) { phys(icol, idim) = dyn(elgp[0], idim, elgp[1], elgp[2]); };
     Kokkos::parallel_for(tr, f);
     break;
   }
@@ -568,7 +579,7 @@ KOKKOS_FUNCTION void PhysicsDynamicsRemapper::local_remap_bwd_3d(const MT &team)
     auto dyn  = pack_view<const ScalarT>(m_dyn_repo.cviews[i].v4d);
 
     const auto tr = Kokkos::TeamVectorRange(team, num_packs);
-    const auto f  = [&](const int ilev) { phys(icol, ilev) = dyn(elgp[0], elgp[1], elgp[2], ilev); };
+    const auto f = [&](const int ilev) { phys(icol, ilev) = dyn(elgp[0], elgp[1], elgp[2], ilev); };
     Kokkos::parallel_for(tr, f);
     break;
   }
@@ -623,7 +634,8 @@ void PhysicsDynamicsRemapper::create_p2d_map() {
 }
 
 template <typename MT>
-KOKKOS_INLINE_FUNCTION void PhysicsDynamicsRemapper::operator()(const RemapFwdTag &, const MT &team) const {
+KOKKOS_INLINE_FUNCTION void PhysicsDynamicsRemapper::operator()(const RemapFwdTag &,
+                                                                const MT &team) const {
   const int i = team.league_rank();
 
   switch (m_layout(i)) {
@@ -659,7 +671,8 @@ KOKKOS_INLINE_FUNCTION void PhysicsDynamicsRemapper::operator()(const RemapFwdTa
 }
 
 template <typename MT>
-KOKKOS_INLINE_FUNCTION void PhysicsDynamicsRemapper::operator()(const RemapBwdTag &, const MT &team) const {
+KOKKOS_INLINE_FUNCTION void PhysicsDynamicsRemapper::operator()(const RemapBwdTag &,
+                                                                const MT &team) const {
   const int rank = team.league_rank();
   const int i    = rank % this->m_num_fields;
 
diff --git i/components/eamxx/src/dynamics/homme/physics_dynamics_remapper.hpp w/components/eamxx/src/dynamics/homme/physics_dynamics_remapper.hpp
index d99b0cf9fb..c7a6f4c355 100644
--- i/components/eamxx/src/dynamics/homme/physics_dynamics_remapper.hpp
+++ w/components/eamxx/src/dynamics/homme/physics_dynamics_remapper.hpp
@@ -37,7 +37,8 @@ public:
 
   bool is_valid_tgt_layout(const FieldLayout &layout) const override {
     // We don't want fields with TimeLevel in it. Just subview the fields instead
-    return AbstractRemapper::is_valid_tgt_layout(layout) and not ekat::contains(layout.tags(), FieldTag::TimeLevel);
+    return AbstractRemapper::is_valid_tgt_layout(layout) and
+           not ekat::contains(layout.tags(), FieldTag::TimeLevel);
   }
 
 protected:
@@ -136,8 +137,8 @@ protected:
 
   bool subfields_info_has_changed(const std::map<int, SubviewInfo> &subfield_info,
                                   const std::vector<Field> &fields) const;
-  void update_subfields_views(const std::map<int, SubviewInfo> &subfield_info, const ViewsRepo &repo,
-                              const std::vector<Field> &fields) const;
+  void update_subfields_views(const std::map<int, SubviewInfo> &subfield_info,
+                              const ViewsRepo &repo, const std::vector<Field> &fields) const;
 
   // Remap methods
   void remap_fwd_impl() override;
@@ -146,22 +147,27 @@ protected:
   // phys->dyn requires a halo-exchange. Since not all entries in dyn
   // are overwritten before the exchange, to avoid leftover garbage,
   // we need to set all entries of dyn to zero.
-  template <typename ScalarT, typename MT> KOKKOS_FUNCTION void set_dyn_to_zero(const MT &team) const;
+  template <typename ScalarT, typename MT>
+  KOKKOS_FUNCTION void set_dyn_to_zero(const MT &team) const;
 
   template <typename MT> KOKKOS_FUNCTION void local_remap_fwd_2d(const MT &team) const;
 
-  template <typename ScalarT, typename MT> KOKKOS_FUNCTION void local_remap_fwd_3d(const MT &team) const;
+  template <typename ScalarT, typename MT>
+  KOKKOS_FUNCTION void local_remap_fwd_3d(const MT &team) const;
 
   template <typename MT> KOKKOS_FUNCTION void local_remap_bwd_2d(const MT &team) const;
 
-  template <typename ScalarT, typename MT> KOKKOS_FUNCTION void local_remap_bwd_3d(const MT &team) const;
+  template <typename ScalarT, typename MT>
+  KOKKOS_FUNCTION void local_remap_bwd_3d(const MT &team) const;
 
 public:
   struct RemapFwdTag {};
   struct RemapBwdTag {};
 
-  template <typename MT> KOKKOS_INLINE_FUNCTION void operator()(const RemapFwdTag &, const MT &team) const;
-  template <typename MT> KOKKOS_INLINE_FUNCTION void operator()(const RemapBwdTag &, const MT &team) const;
+  template <typename MT>
+  KOKKOS_INLINE_FUNCTION void operator()(const RemapFwdTag &, const MT &team) const;
+  template <typename MT>
+  KOKKOS_INLINE_FUNCTION void operator()(const RemapBwdTag &, const MT &team) const;
 };
 
 } // namespace scream
diff --git i/components/eamxx/src/dynamics/homme/tests/dyn_grid_io.cpp w/components/eamxx/src/dynamics/homme/tests/dyn_grid_io.cpp
index 8420eaf70f..ca149b77d6 100644
--- i/components/eamxx/src/dynamics/homme/tests/dyn_grid_io.cpp
+++ w/components/eamxx/src/dynamics/homme/tests/dyn_grid_io.cpp
@@ -64,8 +64,10 @@ TEST_CASE("dyn_grid_io") {
   auto phys_grid = gm->get_grid("physics_gll");
 
   // Local counters
-  EKAT_REQUIRE_MSG(phys_grid->get_num_local_dofs() > 0, "Internal test error! Fix dyn_grid_io, please.\n");
-  EKAT_REQUIRE_MSG(get_num_local_elems_f90() > 0, "Internal test error! Fix dyn_grid_io, please.\n");
+  EKAT_REQUIRE_MSG(phys_grid->get_num_local_dofs() > 0,
+                   "Internal test error! Fix dyn_grid_io, please.\n");
+  EKAT_REQUIRE_MSG(get_num_local_elems_f90() > 0,
+                   "Internal test error! Fix dyn_grid_io, please.\n");
 
   // Create physics and dynamics fields
   auto dyn_scalar3d_mid = dyn_grid->get_3d_scalar_layout(true);
@@ -138,7 +140,9 @@ TEST_CASE("dyn_grid_io") {
   ekat::ParameterList out_params;
   out_params.set<std::string>("averaging_type", "instant");
   out_params.set<std::string>("filename_prefix", "dyn_grid_io");
-  out_params.sublist("fields").sublist("dynamics").set<std::vector<std::string>>("field_names", fnames);
+  out_params.sublist("fields")
+      .sublist("dynamics")
+      .set<std::vector<std::string>>("field_names", fnames);
   out_params.sublist("fields").sublist("dynamics").set<std::string>("io_grid_name", "physics_gll");
 
   out_params.sublist("output_control").set<int>("frequency", 1);
@@ -152,8 +156,8 @@ TEST_CASE("dyn_grid_io") {
   output.finalize();
 
   // Next, let's load all fields from file directly into the dyn grid fm
-  std::string filename =
-      "dyn_grid_io.INSTANT.nsteps_x1.np" + std::to_string(comm.size()) + "." + t0.to_string() + ".nc";
+  std::string filename = "dyn_grid_io.INSTANT.nsteps_x1.np" + std::to_string(comm.size()) + "." +
+                         t0.to_string() + ".nc";
   filename.erase(std::remove(filename.begin(), filename.end(), ':'), filename.end());
 
   ekat::ParameterList in_params;
diff --git i/components/eamxx/src/dynamics/homme/tests/homme_pd_remap_tests.cpp w/components/eamxx/src/dynamics/homme/tests/homme_pd_remap_tests.cpp
index 18706cd6a0..087fc9cf84 100644
--- i/components/eamxx/src/dynamics/homme/tests/homme_pd_remap_tests.cpp
+++ w/components/eamxx/src/dynamics/homme/tests/homme_pd_remap_tests.cpp
@@ -219,7 +219,8 @@ TEST_CASE("remap", "") {
       //       meaning that the values at the interface between two elements must match.
       //       To do this, we initialize each entry in the dynamic v with the id
       //       of the corresponding physics column.
-      //       But since this approach makes checking answers much easier, we use it also for phys->dyn.
+      //       But since this approach makes checking answers much easier, we use it also for
+      //       phys->dyn.
 
       if (fwd) {
         auto h_s_2d_view  = s_2d_field_phys.get_view<Homme::Real *, Host>();
@@ -422,7 +423,8 @@ TEST_CASE("remap", "") {
               for (int ilev = 0; ilev < NVL; ++ilev) {
                 if (dyn(ie, icomp, ip, jp, ilev) != h_d_dofs(idof)) {
                   printf(" ** 3D Vector ** \n");
-                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, icomp, ip, jp, ilev, dyn(ie, icomp, ip, jp, ilev));
+                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, icomp, ip, jp, ilev,
+                         dyn(ie, icomp, ip, jp, ilev));
                   printf("expected: = %d\n", h_d_dofs(idof));
                 }
                 REQUIRE(dyn(ie, icomp, ip, jp, ilev) == h_d_dofs(idof));
@@ -460,7 +462,8 @@ TEST_CASE("remap", "") {
               auto gid = h_d_dofs(idof);
               if (dyn(ie, n0, ip, jp, ilev) != gid) {
                 printf(" ** 3D Scalar State ** \n");
-                printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, n0, ip, jp, ilev, dyn(ie, n0, ip, jp, ilev));
+                printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, n0, ip, jp, ilev,
+                       dyn(ie, n0, ip, jp, ilev));
                 printf("expected: = %d\n", gid);
               }
               REQUIRE(dyn(ie, n0, ip, jp, ilev) == gid);
@@ -495,7 +498,8 @@ TEST_CASE("remap", "") {
               for (int ilev = 0; ilev < NVL; ++ilev) {
                 if (dyn(ie, n0, icomp, ip, jp, ilev) != h_d_dofs(idof)) {
                   printf(" ** 3D Vector State ** \n");
-                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, icomp, ip, jp, ilev, dyn(ie, n0, icomp, ip, jp, ilev));
+                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, icomp, ip, jp, ilev,
+                         dyn(ie, n0, icomp, ip, jp, ilev));
                   printf("expected: = %d\n", h_d_dofs(idof));
                 }
                 REQUIRE(dyn(ie, n0, icomp, ip, jp, ilev) == h_d_dofs(idof));
@@ -533,7 +537,8 @@ TEST_CASE("remap", "") {
               for (int ilev = 0; ilev < NVL; ++ilev) {
                 if (dyn(ie, iq, ip, jp, ilev) != h_d_dofs(idof)) {
                   printf(" ** 3D Tracer State ** \n");
-                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, iq, ip, jp, ilev, dyn(ie, iq, ip, jp, ilev));
+                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, iq, ip, jp, ilev,
+                         dyn(ie, iq, ip, jp, ilev));
                   printf("expected: = %d\n", h_d_dofs(idof));
                 }
                 REQUIRE(dyn(ie, iq, ip, jp, ilev) == h_d_dofs(idof));
@@ -760,7 +765,8 @@ TEST_CASE("combo_remap", "") {
       //       meaning that the values at the interface between two elements must match.
       //       To do this, we initialize each entry in the dynamic v with the id
       //       of the corresponding column.
-      //       But since this approach makes checking answers much easier, we use it also for phys->dyn.
+      //       But since this approach makes checking answers much easier, we use it also for
+      //       phys->dyn.
 
       if (pdp) {
         auto h_s_2d_view  = s_2d_field_phys.get_view<Homme::Real *, Host>();
@@ -979,7 +985,8 @@ TEST_CASE("combo_remap", "") {
               for (int ilev = 0; ilev < NVL; ++ilev) {
                 if (dyn(ie, icomp, ip, jp, ilev) != h_d_dofs(idof)) {
                   printf(" ** 3D Vector ** \n");
-                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, icomp, ip, jp, ilev, dyn(ie, icomp, ip, jp, ilev));
+                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, icomp, ip, jp, ilev,
+                         dyn(ie, icomp, ip, jp, ilev));
                   printf("expected: = %d\n", h_d_dofs(idof));
                 }
                 REQUIRE(dyn(ie, icomp, ip, jp, ilev) == h_d_dofs(idof));
@@ -1015,7 +1022,8 @@ TEST_CASE("combo_remap", "") {
               auto gid = h_d_dofs(idof);
               if (dyn(ie, n0, ip, jp, ilev) != gid) {
                 printf(" ** 3D Scalar State ** \n");
-                printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, n0, ip, jp, ilev, dyn(ie, n0, ip, jp, ilev));
+                printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, n0, ip, jp, ilev,
+                       dyn(ie, n0, ip, jp, ilev));
                 printf("expected: = %d\n", gid);
               }
               REQUIRE(dyn(ie, n0, ip, jp, ilev) == gid);
@@ -1052,7 +1060,8 @@ TEST_CASE("combo_remap", "") {
               for (int ilev = 0; ilev < NVL; ++ilev) {
                 if (dyn(ie, n0, icomp, ip, jp, ilev) != h_d_dofs(idof)) {
                   printf(" ** 3D Vector State ** \n");
-                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, icomp, ip, jp, ilev, dyn(ie, n0, icomp, ip, jp, ilev));
+                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, icomp, ip, jp, ilev,
+                         dyn(ie, n0, icomp, ip, jp, ilev));
                   printf("expected: = %d\n", h_d_dofs(idof));
                 }
                 REQUIRE(dyn(ie, n0, icomp, ip, jp, ilev) == h_d_dofs(idof));
@@ -1090,7 +1099,8 @@ TEST_CASE("combo_remap", "") {
               for (int ilev = 0; ilev < NVL; ++ilev) {
                 if (dyn(ie, iq, ip, jp, ilev) != h_d_dofs(idof)) {
                   printf(" ** 3D Tracer State ** \n");
-                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, iq, ip, jp, ilev, dyn(ie, iq, ip, jp, ilev));
+                  printf("d_out(%d,%d,%d,%d,%d): %2.16f\n", ie, iq, ip, jp, ilev,
+                         dyn(ie, iq, ip, jp, ilev));
                   printf("expected: = %d\n", h_d_dofs(idof));
                 }
                 REQUIRE(dyn(ie, iq, ip, jp, ilev) == h_d_dofs(idof));
diff --git i/components/eamxx/src/mct_coupling/ScreamContext.hpp w/components/eamxx/src/mct_coupling/ScreamContext.hpp
index f4ba00780d..76fd09017f 100644
--- i/components/eamxx/src/mct_coupling/ScreamContext.hpp
+++ w/components/eamxx/src/mct_coupling/ScreamContext.hpp
@@ -16,8 +16,9 @@ public:
 
   template <typename T, typename... Args> T &create(Args... args) {
     auto key = getKey<T>();
-    EKAT_REQUIRE_MSG(m_objects.find(key) == m_objects.end(), "Error! Object with key '" + (std::string)key.name() +
-                                                                 "' was already created in the scream context.\n");
+    EKAT_REQUIRE_MSG(m_objects.find(key) == m_objects.end(),
+                     "Error! Object with key '" + (std::string)key.name() +
+                         "' was already created in the scream context.\n");
 
     auto &obj = m_objects[key];
     obj.template reset<T>(args...);
@@ -28,7 +29,8 @@ public:
   template <typename T> const T &get() const {
     auto key = getKey<T>();
     EKAT_REQUIRE_MSG(m_objects.find(key) != m_objects.end(),
-                     "Error! Object with key '" + (std::string)key.name() + "' not found in the scream context.\n");
+                     "Error! Object with key '" + (std::string)key.name() +
+                         "' not found in the scream context.\n");
     const auto &obj = m_objects.at(key);
 
     return ekat::any_cast<T>(obj);
@@ -37,7 +39,8 @@ public:
   template <typename T> T &getNonConst() {
     auto key = getKey<T>();
     EKAT_REQUIRE_MSG(m_objects.find(key) != m_objects.end(),
-                     "Error! Object with key '" + (std::string)key.name() + "' not found in the scream context.\n");
+                     "Error! Object with key '" + (std::string)key.name() +
+                         "' not found in the scream context.\n");
     auto &obj = m_objects.at(key);
 
     return ekat::any_cast<T>(obj);
diff --git i/components/eamxx/src/mct_coupling/eamxx_cxx_f90_interface.cpp w/components/eamxx/src/mct_coupling/eamxx_cxx_f90_interface.cpp
index c328f0894b..6d765f285d 100644
--- i/components/eamxx/src/mct_coupling/eamxx_cxx_f90_interface.cpp
+++ w/components/eamxx/src/mct_coupling/eamxx_cxx_f90_interface.cpp
@@ -96,11 +96,13 @@ extern "C" {
 
 /*===============================================================================================*/
 // WARNING: make sure input_yaml_file is a null-terminated string!
-void scream_create_atm_instance(const MPI_Fint f_comm, const int atm_id, const char *input_yaml_file,
-                                const char *atm_log_file, const int run_type, const int run_start_ymd,
-                                const int run_start_tod, const int case_start_ymd, const int case_start_tod,
-                                const char *calendar_name, const char *caseid, const char *rest_caseid,
-                                const char *hostname, const char *username, const char *versionid) {
+void scream_create_atm_instance(const MPI_Fint f_comm, const int atm_id,
+                                const char *input_yaml_file, const char *atm_log_file,
+                                const int run_type, const int run_start_ymd,
+                                const int run_start_tod, const int case_start_ymd,
+                                const int case_start_tod, const char *calendar_name,
+                                const char *caseid, const char *rest_caseid, const char *hostname,
+                                const char *username, const char *versionid) {
   using namespace scream;
   using namespace scream::control;
 
@@ -174,20 +176,19 @@ void scream_create_atm_instance(const MPI_Fint f_comm, const int atm_id, const c
   });
 }
 
-void scream_setup_surface_coupling(const char *&import_field_names, int *&import_cpl_indices, double *&x2a_ptr,
+void scream_setup_surface_coupling(
+    const char *&import_field_names, int *&import_cpl_indices, double *&x2a_ptr,
 #ifdef HAVE_MOAB
-                                   double *&x2a_moab_ptr,
+    double *&x2a_moab_ptr,
 #endif
-                                   int *&import_vector_components, double *&import_constant_multiple,
-                                   bool *&do_import_during_init, const int &num_cpl_imports,
-                                   const int &num_scream_imports, const int &import_field_size,
-                                   char *&export_field_names, int *&export_cpl_indices, double *&a2x_ptr,
+    int *&import_vector_components, double *&import_constant_multiple, bool *&do_import_during_init,
+    const int &num_cpl_imports, const int &num_scream_imports, const int &import_field_size,
+    char *&export_field_names, int *&export_cpl_indices, double *&a2x_ptr,
 #ifdef HAVE_MOAB
-                                   double *&a2x_moab_ptr,
+    double *&a2x_moab_ptr,
 #endif
-                                   int *&export_vector_components, double *&export_constant_multiple,
-                                   bool *&do_export_during_init, const int &num_cpl_exports,
-                                   const int &num_scream_exports, const int &export_field_size) {
+    int *&export_vector_components, double *&export_constant_multiple, bool *&do_export_during_init,
+    const int &num_cpl_exports, const int &num_scream_exports, const int &export_field_size) {
   using namespace scream;
 
   fpe_guard_wrapper([&]() {
@@ -213,17 +214,21 @@ void scream_setup_surface_coupling(const char *&import_field_names, int *&import
     auto &ad = get_ad_nonconst();
 
     ad.setup_surface_coupling_data_manager(
-        scream::SurfaceCouplingTransferType::Import, num_cpl_imports, num_scream_imports, import_field_size, x2a_ptr,
+        scream::SurfaceCouplingTransferType::Import, num_cpl_imports, num_scream_imports,
+        import_field_size, x2a_ptr,
 #ifdef HAVE_MOAB
         x2a_moab_ptr,
 #endif
-        names_in[0], import_cpl_indices, import_vector_components, import_constant_multiple, do_import_during_init);
+        names_in[0], import_cpl_indices, import_vector_components, import_constant_multiple,
+        do_import_during_init);
     ad.setup_surface_coupling_data_manager(
-        scream::SurfaceCouplingTransferType::Export, num_cpl_exports, num_scream_exports, export_field_size, a2x_ptr,
+        scream::SurfaceCouplingTransferType::Export, num_cpl_exports, num_scream_exports,
+        export_field_size, a2x_ptr,
 #ifdef HAVE_MOAB
         a2x_moab_ptr,
 #endif
-        names_out[0], export_cpl_indices, export_vector_components, export_constant_multiple, do_export_during_init);
+        names_out[0], export_cpl_indices, export_vector_components, export_constant_multiple,
+        do_export_during_init);
   });
 }
 
diff --git i/components/eamxx/src/physics/cld_fraction/cld_fraction_functions.hpp w/components/eamxx/src/physics/cld_fraction/cld_fraction_functions.hpp
index de1b743d66..f11a90d4b5 100644
--- i/components/eamxx/src/physics/cld_fraction/cld_fraction_functions.hpp
+++ w/components/eamxx/src/physics/cld_fraction/cld_fraction_functions.hpp
@@ -34,18 +34,21 @@ template <typename ScalarT, typename DeviceT> struct CldFractionFunctions {
   template <typename S> using view_2d  = typename KT::template view_2d<S>;
   template <typename S> using uview_1d = typename ekat::template Unmanaged<view_1d<S>>;
 
-  static void main(const Int nj, const Int nk, const Real ice_threshold, const Real ice_4out_threshold,
-                   const view_2d<const Pack> &qi, const view_2d<const Pack> &liq_cld_frac,
-                   const view_2d<Pack> &ice_cld_frac, const view_2d<Pack> &tot_cld_frac,
-                   const view_2d<Pack> &ice_cld_frac_4out, const view_2d<Pack> &tot_cld_frac_4out);
+  static void main(const Int nj, const Int nk, const Real ice_threshold,
+                   const Real ice_4out_threshold, const view_2d<const Pack> &qi,
+                   const view_2d<const Pack> &liq_cld_frac, const view_2d<Pack> &ice_cld_frac,
+                   const view_2d<Pack> &tot_cld_frac, const view_2d<Pack> &ice_cld_frac_4out,
+                   const view_2d<Pack> &tot_cld_frac_4out);
 
   KOKKOS_FUNCTION
   static void calc_icefrac(const MemberType &team, const Int &nk, const Real &threshold,
                            const uview_1d<const Spack> &qi, const uview_1d<Spack> &ice_cld_frac);
 
   KOKKOS_FUNCTION
-  static void calc_totalfrac(const MemberType &team, const Int &nk, const uview_1d<const Spack> &liq_cld_frac,
-                             const uview_1d<const Spack> &ice_cld_frac, const uview_1d<Spack> &tot_cld_frac);
+  static void calc_totalfrac(const MemberType &team, const Int &nk,
+                             const uview_1d<const Spack> &liq_cld_frac,
+                             const uview_1d<const Spack> &ice_cld_frac,
+                             const uview_1d<Spack> &tot_cld_frac);
 
 }; // struct Functions
 
diff --git i/components/eamxx/src/physics/cld_fraction/cld_fraction_main_impl.hpp w/components/eamxx/src/physics/cld_fraction/cld_fraction_main_impl.hpp
index c44acde4fd..3642d9aa33 100644
--- i/components/eamxx/src/physics/cld_fraction/cld_fraction_main_impl.hpp
+++ w/components/eamxx/src/physics/cld_fraction/cld_fraction_main_impl.hpp
@@ -11,8 +11,10 @@ namespace cld_fraction {
 template <typename S, typename D>
 void CldFractionFunctions<S, D>::main(const Int nj, const Int nk, const Real ice_threshold,
                                       const Real ice_4out_threshold, const view_2d<const Spack> &qi,
-                                      const view_2d<const Spack> &liq_cld_frac, const view_2d<Spack> &ice_cld_frac,
-                                      const view_2d<Spack> &tot_cld_frac, const view_2d<Spack> &ice_cld_frac_4out,
+                                      const view_2d<const Spack> &liq_cld_frac,
+                                      const view_2d<Spack> &ice_cld_frac,
+                                      const view_2d<Spack> &tot_cld_frac,
+                                      const view_2d<Spack> &ice_cld_frac_4out,
                                       const view_2d<Spack> &tot_cld_frac_4out) {
   using ExeSpace    = typename KT::ExeSpace;
   const Int nk_pack = ekat::npack<Spack>(nk);
@@ -39,7 +41,8 @@ void CldFractionFunctions<S, D>::main(const Int nj, const Int nk, const Real ice
 /*-----------------------------------------------------------------*/
 template <typename S, typename D>
 KOKKOS_FUNCTION void CldFractionFunctions<S, D>::calc_icefrac(const MemberType &team, const Int &nk,
-                                                              const Real &threshold, const uview_1d<const Spack> &qi,
+                                                              const Real &threshold,
+                                                              const uview_1d<const Spack> &qi,
                                                               const uview_1d<Spack> &ice_cld_frac) {
   team.team_barrier();
   const Int nk_pack = ekat::npack<Spack>(nk);
@@ -53,10 +56,9 @@ KOKKOS_FUNCTION void CldFractionFunctions<S, D>::calc_icefrac(const MemberType &
 } // calc_icefrac
 /*-----------------------------------------------------------------*/
 template <typename S, typename D>
-KOKKOS_FUNCTION void CldFractionFunctions<S, D>::calc_totalfrac(const MemberType &team, const Int &nk,
-                                                                const uview_1d<const Spack> &liq_cld_frac,
-                                                                const uview_1d<const Spack> &ice_cld_frac,
-                                                                const uview_1d<Spack> &tot_cld_frac) {
+KOKKOS_FUNCTION void CldFractionFunctions<S, D>::calc_totalfrac(
+    const MemberType &team, const Int &nk, const uview_1d<const Spack> &liq_cld_frac,
+    const uview_1d<const Spack> &ice_cld_frac, const uview_1d<Spack> &tot_cld_frac) {
   team.team_barrier();
   const Int nk_pack = ekat::npack<Spack>(nk);
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nk_pack), [&](Int k) {
diff --git i/components/eamxx/src/physics/cld_fraction/eamxx_cld_fraction_process_interface.cpp w/components/eamxx/src/physics/cld_fraction/eamxx_cld_fraction_process_interface.cpp
index 01f78eff87..c85d93e530 100644
--- i/components/eamxx/src/physics/cld_fraction/eamxx_cld_fraction_process_interface.cpp
+++ w/components/eamxx/src/physics/cld_fraction/eamxx_cld_fraction_process_interface.cpp
@@ -9,7 +9,8 @@
 namespace scream {
 using namespace cld_fraction;
 // =========================================================================================
-CldFraction::CldFraction(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereProcess(comm, params) {
+CldFraction::CldFraction(const ekat::Comm &comm, const ekat::ParameterList &params)
+    : AtmosphereProcess(comm, params) {
   // Nothing to do here
 }
 
@@ -54,8 +55,9 @@ void CldFraction::set_grids(const std::shared_ptr<const GridsManager> grids_mana
   // - There are no fields used as both input and output.
 
   // Gather parameters for ice cloud thresholds from parameter list:
-  m_icecloud_threshold              = m_params.get<double>("ice_cloud_threshold", 1e-12);             // Default = 1e-12
-  m_icecloud_for_analysis_threshold = m_params.get<double>("ice_cloud_for_analysis_threshold", 1e-5); // Default = 1e-5
+  m_icecloud_threshold = m_params.get<double>("ice_cloud_threshold", 1e-12); // Default = 1e-12
+  m_icecloud_for_analysis_threshold =
+      m_params.get<double>("ice_cloud_for_analysis_threshold", 1e-5); // Default = 1e-5
 }
 
 // =========================================================================================
@@ -64,8 +66,10 @@ void CldFraction::initialize_impl(const RunType /* run_type */) {
   using Interval = FieldWithinIntervalCheck;
   add_postcondition_check<Interval>(get_field_out("cldfrac_ice"), m_grid, 0.0, 1.0, false);
   add_postcondition_check<Interval>(get_field_out("cldfrac_tot"), m_grid, 0.0, 1.0, false);
-  add_postcondition_check<Interval>(get_field_out("cldfrac_ice_for_analysis"), m_grid, 0.0, 1.0, false);
-  add_postcondition_check<Interval>(get_field_out("cldfrac_tot_for_analysis"), m_grid, 0.0, 1.0, false);
+  add_postcondition_check<Interval>(get_field_out("cldfrac_ice_for_analysis"), m_grid, 0.0, 1.0,
+                                    false);
+  add_postcondition_check<Interval>(get_field_out("cldfrac_tot_for_analysis"), m_grid, 0.0, 1.0,
+                                    false);
 }
 
 // =========================================================================================
@@ -79,8 +83,9 @@ void CldFraction::run_impl(const double /* dt */) {
   auto ice_cld_frac_4out = get_field_out("cldfrac_ice_for_analysis").get_view<Pack **>();
   auto tot_cld_frac_4out = get_field_out("cldfrac_tot_for_analysis").get_view<Pack **>();
 
-  CldFractionFunc::main(m_num_cols, m_num_levs, m_icecloud_threshold, m_icecloud_for_analysis_threshold, qi,
-                        liq_cld_frac, ice_cld_frac, tot_cld_frac, ice_cld_frac_4out, tot_cld_frac_4out);
+  CldFractionFunc::main(m_num_cols, m_num_levs, m_icecloud_threshold,
+                        m_icecloud_for_analysis_threshold, qi, liq_cld_frac, ice_cld_frac,
+                        tot_cld_frac, ice_cld_frac_4out, tot_cld_frac_4out);
 }
 
 // =========================================================================================
diff --git i/components/eamxx/src/physics/cosp/cosp_functions.hpp w/components/eamxx/src/physics/cosp/cosp_functions.hpp
index c5fe017a6d..e15555f0ec 100644
--- i/components/eamxx/src/physics/cosp/cosp_functions.hpp
+++ w/components/eamxx/src/physics/cosp/cosp_functions.hpp
@@ -4,39 +4,44 @@
 using scream::Real;
 extern "C" void cosp_c2f_init(int ncol, int nsubcol, int nlay);
 extern "C" void cosp_c2f_final();
-extern "C" void cosp_c2f_run(const int ncol, const int nsubcol, const int nlay, const int ntau, const int nctp,
-                             const int ncth, const Real emsfc_lw, const Real *sunlit, const Real *skt,
-                             const Real *T_mid, const Real *p_mid, const Real *p_int, const Real *z_mid, const Real *qv,
-                             const Real *qc, const Real *qi, const Real *cldfrac, const Real *reff_qc,
-                             const Real *reff_qi, const Real *dtau067, const Real *dtau105, Real *isccp_cldtot,
-                             Real *isccp_ctptau, Real *modis_ctptau, Real *misr_cthtau);
+extern "C" void cosp_c2f_run(const int ncol, const int nsubcol, const int nlay, const int ntau,
+                             const int nctp, const int ncth, const Real emsfc_lw,
+                             const Real *sunlit, const Real *skt, const Real *T_mid,
+                             const Real *p_mid, const Real *p_int, const Real *z_mid,
+                             const Real *qv, const Real *qc, const Real *qi, const Real *cldfrac,
+                             const Real *reff_qc, const Real *reff_qi, const Real *dtau067,
+                             const Real *dtau105, Real *isccp_cldtot, Real *isccp_ctptau,
+                             Real *modis_ctptau, Real *misr_cthtau);
 
 namespace scream {
 
 namespace CospFunc {
-using lview_host_1d                 = typename ekat::KokkosTypes<HostDevice>::template lview<Real *>;
-using lview_host_2d                 = typename ekat::KokkosTypes<HostDevice>::template lview<Real **>;
-using lview_host_3d                 = typename ekat::KokkosTypes<HostDevice>::template lview<Real ***>;
+using lview_host_1d = typename ekat::KokkosTypes<HostDevice>::template lview<Real *>;
+using lview_host_2d = typename ekat::KokkosTypes<HostDevice>::template lview<Real **>;
+using lview_host_3d = typename ekat::KokkosTypes<HostDevice>::template lview<Real ***>;
 template <typename S> using view_1d = typename ekat::KokkosTypes<HostDevice>::template view_1d<S>;
 template <typename S> using view_2d = typename ekat::KokkosTypes<HostDevice>::template view_2d<S>;
 template <typename S> using view_3d = typename ekat::KokkosTypes<HostDevice>::template view_3d<S>;
 
 inline void initialize(int ncol, int nsubcol, int nlay) { cosp_c2f_init(ncol, nsubcol, nlay); };
 inline void finalize() { cosp_c2f_final(); };
-inline void main(const Int ncol, const Int nsubcol, const Int nlay, const Int ntau, const Int nctp, const Int ncth,
-                 const Real emsfc_lw, const view_1d<const Real> &sunlit, const view_1d<const Real> &skt,
-                 const view_2d<const Real> &T_mid, const view_2d<const Real> &p_mid, const view_2d<const Real> &p_int,
-                 const view_2d<const Real> &z_mid, const view_2d<const Real> &qv, const view_2d<const Real> &qc,
-                 const view_2d<const Real> &qi, const view_2d<const Real> &cldfrac, const view_2d<const Real> &reff_qc,
+inline void main(const Int ncol, const Int nsubcol, const Int nlay, const Int ntau, const Int nctp,
+                 const Int ncth, const Real emsfc_lw, const view_1d<const Real> &sunlit,
+                 const view_1d<const Real> &skt, const view_2d<const Real> &T_mid,
+                 const view_2d<const Real> &p_mid, const view_2d<const Real> &p_int,
+                 const view_2d<const Real> &z_mid, const view_2d<const Real> &qv,
+                 const view_2d<const Real> &qc, const view_2d<const Real> &qi,
+                 const view_2d<const Real> &cldfrac, const view_2d<const Real> &reff_qc,
                  const view_2d<const Real> &reff_qi, const view_2d<const Real> &dtau067,
                  const view_2d<const Real> &dtau105, const view_1d<Real> &isccp_cldtot,
                  const view_3d<Real> &isccp_ctptau, const view_3d<Real> &modis_ctptau,
                  const view_3d<Real> &misr_cthtau) {
 
   // Make host copies and permute data as needed
-  lview_host_2d T_mid_h("T_mid_h", ncol, nlay), p_mid_h("p_mid_h", ncol, nlay), p_int_h("p_int_h", ncol, nlay + 1),
-      z_mid_h("z_mid_h", ncol, nlay), qv_h("qv_h", ncol, nlay), qc_h("qc_h", ncol, nlay), qi_h("qi_h", ncol, nlay),
-      cldfrac_h("cldfrac_h", ncol, nlay), reff_qc_h("reff_qc_h", ncol, nlay), reff_qi_h("reff_qi_h", ncol, nlay),
+  lview_host_2d T_mid_h("T_mid_h", ncol, nlay), p_mid_h("p_mid_h", ncol, nlay),
+      p_int_h("p_int_h", ncol, nlay + 1), z_mid_h("z_mid_h", ncol, nlay), qv_h("qv_h", ncol, nlay),
+      qc_h("qc_h", ncol, nlay), qi_h("qi_h", ncol, nlay), cldfrac_h("cldfrac_h", ncol, nlay),
+      reff_qc_h("reff_qc_h", ncol, nlay), reff_qi_h("reff_qi_h", ncol, nlay),
       dtau067_h("dtau_067_h", ncol, nlay), dtau105_h("dtau105_h", ncol, nlay);
   lview_host_3d isccp_ctptau_h("isccp_ctptau_h", ncol, ntau, nctp);
   lview_host_3d modis_ctptau_h("modis_ctptau_h", ncol, ntau, nctp);
@@ -67,10 +72,11 @@ inline void main(const Int ncol, const Int nsubcol, const Int nlay, const Int nt
   // Subsample here?
 
   // Call COSP wrapper
-  cosp_c2f_run(ncol, nsubcol, nlay, ntau, nctp, ncth, emsfc_lw, sunlit.data(), skt.data(), T_mid_h.data(),
-               p_mid_h.data(), p_int_h.data(), z_mid_h.data(), qv_h.data(), qc_h.data(), qi_h.data(), cldfrac_h.data(),
-               reff_qc_h.data(), reff_qi_h.data(), dtau067_h.data(), dtau105_h.data(), isccp_cldtot.data(),
-               isccp_ctptau_h.data(), modis_ctptau_h.data(), misr_cthtau_h.data());
+  cosp_c2f_run(ncol, nsubcol, nlay, ntau, nctp, ncth, emsfc_lw, sunlit.data(), skt.data(),
+               T_mid_h.data(), p_mid_h.data(), p_int_h.data(), z_mid_h.data(), qv_h.data(),
+               qc_h.data(), qi_h.data(), cldfrac_h.data(), reff_qc_h.data(), reff_qi_h.data(),
+               dtau067_h.data(), dtau105_h.data(), isccp_cldtot.data(), isccp_ctptau_h.data(),
+               modis_ctptau_h.data(), misr_cthtau_h.data());
 
   // Copy outputs back to layoutRight views
   for (int i = 0; i < ncol; i++) {
diff --git i/components/eamxx/src/physics/cosp/eamxx_cosp.cpp w/components/eamxx/src/physics/cosp/eamxx_cosp.cpp
index 708bacefdf..4691b8a6a3 100644
--- i/components/eamxx/src/physics/cosp/eamxx_cosp.cpp
+++ w/components/eamxx/src/physics/cosp/eamxx_cosp.cpp
@@ -12,7 +12,8 @@
 
 namespace scream {
 // =========================================================================================
-Cosp::Cosp(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereProcess(comm, params) {
+Cosp::Cosp(const ekat::Comm &comm, const ekat::ParameterList &params)
+    : AtmosphereProcess(comm, params) {
   // Determine how often to call COSP; units can be steps or hours
   m_cosp_frequency       = m_params.get<Int>("cosp_frequency", 1);
   m_cosp_frequency_units = m_params.get<std::string>("cosp_frequency_units", "steps");
@@ -76,8 +77,9 @@ void Cosp::set_grids(const std::shared_ptr<const GridsManager> grids_manager) {
   // Effective radii, should be computed in either microphysics or radiation interface
   // TODO: should these be meters or microns? Was meters before, but using "m" instead
   // of "micron" seemed to cause prim_model_finalize to throw error with the following:
-  // ABORTING WITH ERROR: Error! prim_init_model_f90 was not called yet (or prim_finalize_f90 was already called).
-  // P3 defines this field with micron instead of meters units, so is this a unit conversion issue?
+  // ABORTING WITH ERROR: Error! prim_init_model_f90 was not called yet (or prim_finalize_f90 was
+  // already called). P3 defines this field with micron instead of meters units, so is this a unit
+  // conversion issue?
   add_field<Required>("eff_radius_qc", scalar3d_mid, micron, grid_name);
   add_field<Required>("eff_radius_qi", scalar3d_mid, micron, grid_name);
   // Set of fields used strictly as output
@@ -118,7 +120,8 @@ void Cosp::run_impl(const double dt) {
   if (m_cosp_frequency_units == "steps") {
     cosp_freq_in_steps = m_cosp_frequency;
   } else if (m_cosp_frequency_units == "hours") {
-    EKAT_REQUIRE_MSG((3600 % int(dt)) == 0, "cosp_frequency_units is hours but dt does not evenly divide 1 hour");
+    EKAT_REQUIRE_MSG((3600 % int(dt)) == 0,
+                     "cosp_frequency_units is hours but dt does not evenly divide 1 hour");
     cosp_freq_in_steps = 3600.0 * m_cosp_frequency / dt;
   } else {
     EKAT_ERROR_MSG("cosp_frequency_units " + m_cosp_frequency_units + " not supported");
@@ -215,14 +218,16 @@ void Cosp::run_impl(const double dt) {
     auto isccp_ctptau_h = get_field_out("isccp_ctptau").get_view<Real ***, Host>();
     auto modis_ctptau_h = get_field_out("modis_ctptau").get_view<Real ***, Host>();
     auto misr_cthtau_h  = get_field_out("misr_cthtau").get_view<Real ***, Host>();
-    auto cosp_sunlit_h  = get_field_out("cosp_sunlit")
-                             .get_view<Real *, Host>(); // Copy of sunlit flag with COSP frequency for proper averaging
+    auto cosp_sunlit_h =
+        get_field_out("cosp_sunlit").get_view<Real *, Host>(); // Copy of sunlit flag with COSP
+                                                               // frequency for proper averaging
 
     Real emsfc_lw = 0.99;
     Kokkos::deep_copy(cosp_sunlit_h, sunlit_h);
-    CospFunc::main(m_num_cols, m_num_subcols, m_num_levs, m_num_tau, m_num_ctp, m_num_cth, emsfc_lw, sunlit_h, skt_h,
-                   T_mid_h, p_mid_h, p_int_h, z_mid_h, qv_h, qc_h, qi_h, cldfrac_h, reff_qc_h, reff_qi_h, dtau067_h,
-                   dtau105_h, isccp_cldtot_h, isccp_ctptau_h, modis_ctptau_h, misr_cthtau_h);
+    CospFunc::main(m_num_cols, m_num_subcols, m_num_levs, m_num_tau, m_num_ctp, m_num_cth, emsfc_lw,
+                   sunlit_h, skt_h, T_mid_h, p_mid_h, p_int_h, z_mid_h, qv_h, qc_h, qi_h, cldfrac_h,
+                   reff_qc_h, reff_qi_h, dtau067_h, dtau105_h, isccp_cldtot_h, isccp_ctptau_h,
+                   modis_ctptau_h, misr_cthtau_h);
     // Remask night values to ZERO since our I/O does not know how to handle masked/missing values
     // in temporal averages; this is all host data, so we can just use host loops like its the 1980s
     for (int i = 0; i < m_num_cols; i++) {
diff --git i/components/eamxx/src/physics/gw/gw_functions.hpp w/components/eamxx/src/physics/gw/gw_functions.hpp
index 6d1030b9fa..d48d9b2f65 100644
--- i/components/eamxx/src/physics/gw/gw_functions.hpp
+++ w/components/eamxx/src/physics/gw/gw_functions.hpp
@@ -63,11 +63,13 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   KOKKOS_FUNCTION
   static void gwd_compute_tendencies_from_stress_divergence(
       // Inputs
-      const Int &ncol, const Int &pver, const Int &pgwv, const Int &ngwv, const bool &do_taper, const Spack &dt,
-      const Spack &effgw, const uview_1d<const Int> &tend_level, const uview_1d<const Spack> &lat,
-      const uview_1d<const Spack> &dpm, const uview_1d<const Spack> &rdpm, const uview_1d<const Spack> &c,
-      const uview_1d<const Spack> &ubm, const uview_1d<const Spack> &t, const uview_1d<const Spack> &nm,
-      const uview_1d<const Spack> &xv, const uview_1d<const Spack> &yv,
+      const Int &ncol, const Int &pver, const Int &pgwv, const Int &ngwv, const bool &do_taper,
+      const Spack &dt, const Spack &effgw, const uview_1d<const Int> &tend_level,
+      const uview_1d<const Spack> &lat, const uview_1d<const Spack> &dpm,
+      const uview_1d<const Spack> &rdpm, const uview_1d<const Spack> &c,
+      const uview_1d<const Spack> &ubm, const uview_1d<const Spack> &t,
+      const uview_1d<const Spack> &nm, const uview_1d<const Spack> &xv,
+      const uview_1d<const Spack> &yv,
       // Inputs/Outputs
       const uview_1d<Spack> &tau,
       // Outputs
diff --git i/components/eamxx/src/physics/gw/impl/gw_gwd_compute_tendencies_from_stress_divergence_impl.hpp w/components/eamxx/src/physics/gw/impl/gw_gwd_compute_tendencies_from_stress_divergence_impl.hpp
index abeca64716..01a5514f61 100644
--- i/components/eamxx/src/physics/gw/impl/gw_gwd_compute_tendencies_from_stress_divergence_impl.hpp
+++ w/components/eamxx/src/physics/gw/impl/gw_gwd_compute_tendencies_from_stress_divergence_impl.hpp
@@ -14,17 +14,20 @@ namespace gw {
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::gwd_compute_tendencies_from_stress_divergence(
     // Inputs
-    const Int &ncol, const Int &pver, const Int &pgwv, const Int &ngwv, const bool &do_taper, const Spack &dt,
-    const Spack &effgw, const uview_1d<const Int> &tend_level, const uview_1d<const Spack> &lat,
-    const uview_1d<const Spack> &dpm, const uview_1d<const Spack> &rdpm, const uview_1d<const Spack> &c,
-    const uview_1d<const Spack> &ubm, const uview_1d<const Spack> &t, const uview_1d<const Spack> &nm,
-    const uview_1d<const Spack> &xv, const uview_1d<const Spack> &yv,
+    const Int &ncol, const Int &pver, const Int &pgwv, const Int &ngwv, const bool &do_taper,
+    const Spack &dt, const Spack &effgw, const uview_1d<const Int> &tend_level,
+    const uview_1d<const Spack> &lat, const uview_1d<const Spack> &dpm,
+    const uview_1d<const Spack> &rdpm, const uview_1d<const Spack> &c,
+    const uview_1d<const Spack> &ubm, const uview_1d<const Spack> &t,
+    const uview_1d<const Spack> &nm, const uview_1d<const Spack> &xv,
+    const uview_1d<const Spack> &yv,
     // Inputs/Outputs
     const uview_1d<Spack> &tau,
     // Outputs
     const uview_1d<Spack> &gwut, const uview_1d<Spack> &utgw, const uview_1d<Spack> &vtgw) {
   // TODO
-  // Note, argument types may need tweaking. Generator is not always able to tell what needs to be packed
+  // Note, argument types may need tweaking. Generator is not always able to tell what needs to be
+  // packed
 }
 
 } // namespace gw
diff --git i/components/eamxx/src/physics/gw/tests/gw_gwd_compute_tendencies_from_stress_divergence_tests.cpp w/components/eamxx/src/physics/gw/tests/gw_gwd_compute_tendencies_from_stress_divergence_tests.cpp
index cd4431df98..da11b933b1 100644
--- i/components/eamxx/src/physics/gw/tests/gw_gwd_compute_tendencies_from_stress_divergence_tests.cpp
+++ w/components/eamxx/src/physics/gw/tests/gw_gwd_compute_tendencies_from_stress_divergence_tests.cpp
@@ -13,7 +13,8 @@ namespace gw {
 namespace unit_test {
 
 template <typename D>
-struct UnitWrap::UnitTest<D>::TestGwdComputeTendenciesFromStressDivergence : public UnitWrap::UnitTest<D>::Base {
+struct UnitWrap::UnitTest<D>::TestGwdComputeTendenciesFromStressDivergence
+    : public UnitWrap::UnitTest<D>::Base {
 
   void run_bfb() {
     auto engine = Base::get_engine();
@@ -40,7 +41,8 @@ struct UnitWrap::UnitTest<D>::TestGwdComputeTendenciesFromStressDivergence : pub
         GwdComputeTendenciesFromStressDivergenceData(5, 10, true, 0.4, 0.3, init_data[0]),
     };
 
-    static constexpr Int num_runs = sizeof(baseline_data) / sizeof(GwdComputeTendenciesFromStressDivergenceData);
+    static constexpr Int num_runs =
+        sizeof(baseline_data) / sizeof(GwdComputeTendenciesFromStressDivergenceData);
 
     // Generate random input data
     // Alternatively, you can use the baseline_data construtors/initializer lists to hardcode data
@@ -104,8 +106,8 @@ struct UnitWrap::UnitTest<D>::TestGwdComputeTendenciesFromStressDivergence : pub
 namespace {
 
 TEST_CASE("gwd_compute_tendencies_from_stress_divergence_bfb", "[gw]") {
-  using TestStruct =
-      scream::gw::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestGwdComputeTendenciesFromStressDivergence;
+  using TestStruct = scream::gw::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestGwdComputeTendenciesFromStressDivergence;
 
   TestStruct t;
   t.run_bfb();
diff --git i/components/eamxx/src/physics/gw/tests/infra/gw_test_data.cpp w/components/eamxx/src/physics/gw/tests/infra/gw_test_data.cpp
index 13ffef4f3f..93624a3d20 100644
--- i/components/eamxx/src/physics/gw/tests/infra/gw_test_data.cpp
+++ w/components/eamxx/src/physics/gw/tests/infra/gw_test_data.cpp
@@ -22,29 +22,33 @@ using GWC = typename GWF::C;
 
 extern "C" {
 
-void gwd_compute_tendencies_from_stress_divergence_c(Int ncol, Int ngwv, bool do_taper, Real dt, Real effgw,
-                                                     Int *tend_level, Real *lat, Real *dpm, Real *rdpm, Real *c,
-                                                     Real *ubm, Real *t, Real *nm, Real *xv, Real *yv, Real *tau,
-                                                     Real *gwut, Real *utgw, Real *vtgw);
+void gwd_compute_tendencies_from_stress_divergence_c(Int ncol, Int ngwv, bool do_taper, Real dt,
+                                                     Real effgw, Int *tend_level, Real *lat,
+                                                     Real *dpm, Real *rdpm, Real *c, Real *ubm,
+                                                     Real *t, Real *nm, Real *xv, Real *yv,
+                                                     Real *tau, Real *gwut, Real *utgw, Real *vtgw);
 
-void gw_init_c(Int pver_in, Int pgwv_in, Real dc_in, Real *cref_in, bool orographic_only, bool do_molec_diff_in,
-               bool tau_0_ubc_in, Int nbot_molec_in, Int ktop_in, Int kbotbg_in, Real fcrit2_in, Real kwv_in,
-               Real gravit_in, Real rair_in, Real *alpha_in);
+void gw_init_c(Int pver_in, Int pgwv_in, Real dc_in, Real *cref_in, bool orographic_only,
+               bool do_molec_diff_in, bool tau_0_ubc_in, Int nbot_molec_in, Int ktop_in,
+               Int kbotbg_in, Real fcrit2_in, Real kwv_in, Real gravit_in, Real rair_in,
+               Real *alpha_in);
 
 } // extern "C" : end _c decls
 
 // Wrapper around gw_init
 void gw_init(GwInit &init) {
-  gw_init_c(init.pver, init.pgwv, init.dc, init.cref, init.orographic_only, init.do_molec_diff, init.tau_0_ubc,
-            init.nbot_molec, init.ktop, init.kbotbg, init.fcrit2, init.kwv, GWC::gravit, GWC::Rair, init.alpha);
+  gw_init_c(init.pver, init.pgwv, init.dc, init.cref, init.orographic_only, init.do_molec_diff,
+            init.tau_0_ubc, init.nbot_molec, init.ktop, init.kbotbg, init.fcrit2, init.kwv,
+            GWC::gravit, GWC::Rair, init.alpha);
 }
 
-void gwd_compute_tendencies_from_stress_divergence(GwdComputeTendenciesFromStressDivergenceData &d) {
+void gwd_compute_tendencies_from_stress_divergence(
+    GwdComputeTendenciesFromStressDivergenceData &d) {
   gw_init(d.init);
   d.transpose<ekat::TransposeDirection::c2f>();
-  gwd_compute_tendencies_from_stress_divergence_c(d.ncol, d.ngwv, d.do_taper, d.dt, d.effgw, d.tend_level, d.lat, d.dpm,
-                                                  d.rdpm, d.c, d.ubm, d.t, d.nm, d.xv, d.yv, d.tau, d.gwut, d.utgw,
-                                                  d.vtgw);
+  gwd_compute_tendencies_from_stress_divergence_c(
+      d.ncol, d.ngwv, d.do_taper, d.dt, d.effgw, d.tend_level, d.lat, d.dpm, d.rdpm, d.c, d.ubm,
+      d.t, d.nm, d.xv, d.yv, d.tau, d.gwut, d.utgw, d.vtgw);
   d.transpose<ekat::TransposeDirection::f2c>();
 }
 
diff --git i/components/eamxx/src/physics/gw/tests/infra/gw_test_data.hpp w/components/eamxx/src/physics/gw/tests/infra/gw_test_data.hpp
index f2f0097588..0127d81f17 100644
--- i/components/eamxx/src/physics/gw/tests/infra/gw_test_data.hpp
+++ w/components/eamxx/src/physics/gw/tests/infra/gw_test_data.hpp
@@ -27,11 +27,12 @@ struct GwInit : public PhysicsTestData {
   Real fcrit2, kwv;
   Real *cref, *alpha;
 
-  GwInit(Int pver_, Int pgwv_, Real dc_, bool orographic_only_, bool do_molec_diff_, bool tau_0_ubc_, Int nbot_molec_,
-         Int ktop_, Int kbotbg_, Real fcrit2_, Real kwv_)
-      : PhysicsTestData({{pgwv_ * 2}, {pver_ + 1}}, {{&cref}, {&alpha}}), pver(pver_), pgwv(pgwv_), dc(dc_),
-        orographic_only(orographic_only_), do_molec_diff(do_molec_diff_), tau_0_ubc(tau_0_ubc_),
-        nbot_molec(nbot_molec_), ktop(ktop_), kbotbg(kbotbg_), fcrit2(fcrit2_), kwv(kwv_) {
+  GwInit(Int pver_, Int pgwv_, Real dc_, bool orographic_only_, bool do_molec_diff_,
+         bool tau_0_ubc_, Int nbot_molec_, Int ktop_, Int kbotbg_, Real fcrit2_, Real kwv_)
+      : PhysicsTestData({{pgwv_ * 2}, {pver_ + 1}}, {{&cref}, {&alpha}}), pver(pver_), pgwv(pgwv_),
+        dc(dc_), orographic_only(orographic_only_), do_molec_diff(do_molec_diff_),
+        tau_0_ubc(tau_0_ubc_), nbot_molec(nbot_molec_), ktop(ktop_), kbotbg(kbotbg_),
+        fcrit2(fcrit2_), kwv(kwv_) {
     // Assert valid init data?
     assert(ktop <= pver);
     assert(kbotbg >= 0);
@@ -41,8 +42,8 @@ struct GwInit : public PhysicsTestData {
     assert(nbot_molec <= ktop);
   }
 
-  PTD_STD_DEF(GwInit, 11, pver, pgwv, dc, orographic_only, do_molec_diff, tau_0_ubc, nbot_molec, ktop, kbotbg, fcrit2,
-              kwv);
+  PTD_STD_DEF(GwInit, 11, pver, pgwv, dc, orographic_only, do_molec_diff, tau_0_ubc, nbot_molec,
+              ktop, kbotbg, fcrit2, kwv);
 };
 
 struct GwdComputeTendenciesFromStressDivergenceData : public PhysicsTestData {
@@ -60,19 +61,21 @@ struct GwdComputeTendenciesFromStressDivergenceData : public PhysicsTestData {
   // Outputs
   Real *gwut, *utgw, *vtgw;
 
-  GwdComputeTendenciesFromStressDivergenceData(Int ncol_, Int ngwv_, bool do_taper_, Real dt_, Real effgw_,
-                                               GwInit init_)
-      : PhysicsTestData({{ncol_},
-                         {ncol_, init_.pver},
-                         {ncol_, 2 * init_.pgwv},
-                         {ncol_, 2 * init_.pgwv, init_.pver + 1},
-                         {ncol_, init_.pver, 2 * ngwv_},
-                         {ncol_}},
-                        {{&lat, &xv, &yv}, {&dpm, &rdpm, &ubm, &t, &nm, &utgw, &vtgw}, {&c}, {&tau}, {&gwut}},
-                        {{&tend_level}}),
+  GwdComputeTendenciesFromStressDivergenceData(Int ncol_, Int ngwv_, bool do_taper_, Real dt_,
+                                               Real effgw_, GwInit init_)
+      : PhysicsTestData(
+            {{ncol_},
+             {ncol_, init_.pver},
+             {ncol_, 2 * init_.pgwv},
+             {ncol_, 2 * init_.pgwv, init_.pver + 1},
+             {ncol_, init_.pver, 2 * ngwv_},
+             {ncol_}},
+            {{&lat, &xv, &yv}, {&dpm, &rdpm, &ubm, &t, &nm, &utgw, &vtgw}, {&c}, {&tau}, {&gwut}},
+            {{&tend_level}}),
         ncol(ncol_), ngwv(ngwv_), do_taper(do_taper_), dt(dt_), effgw(effgw_), init(init_) {}
 
-  PTD_STD_DEF_INIT(GwdComputeTendenciesFromStressDivergenceData, 5, ncol, ngwv, do_taper, dt, effgw);
+  PTD_STD_DEF_INIT(GwdComputeTendenciesFromStressDivergenceData, 5, ncol, ngwv, do_taper, dt,
+                   effgw);
 };
 
 // Glue functions to call fortran from from C++ with the Data struct
diff --git i/components/eamxx/src/physics/iop_forcing/eamxx_iop_forcing_process_interface.cpp w/components/eamxx/src/physics/iop_forcing/eamxx_iop_forcing_process_interface.cpp
index 55d1225e92..d21f9bfda1 100644
--- i/components/eamxx/src/physics/iop_forcing/eamxx_iop_forcing_process_interface.cpp
+++ w/components/eamxx/src/physics/iop_forcing/eamxx_iop_forcing_process_interface.cpp
@@ -51,11 +51,13 @@ void IOPForcing::set_grids(const std::shared_ptr<const GridsManager> grids_manag
 }
 // =========================================================================================
 void IOPForcing::set_computed_group_impl(const FieldGroup &group) {
-  EKAT_REQUIRE_MSG(group.m_info->size() >= 1, "Error! IOPForcing requires at least qv as tracer input.\n");
+  EKAT_REQUIRE_MSG(group.m_info->size() >= 1,
+                   "Error! IOPForcing requires at least qv as tracer input.\n");
 
   const auto &name = group.m_info->m_group_name;
 
-  EKAT_REQUIRE_MSG(name == "tracers", "Error! IOPForcing was not expecting a field group called '" << name << "\n");
+  EKAT_REQUIRE_MSG(name == "tracers",
+                   "Error! IOPForcing was not expecting a field group called '" << name << "\n");
 
   EKAT_REQUIRE_MSG(group.m_info->m_monolithic_allocation,
                    "Error! IOPForcing expects a monolithic allocation for tracers.\n");
@@ -65,9 +67,10 @@ void IOPForcing::set_computed_group_impl(const FieldGroup &group) {
 // =========================================================================================
 size_t IOPForcing::requested_buffer_size_in_bytes() const {
   // Number of bytes needed by the WorkspaceManager passed to shoc_main
-  const int nlevi_packs  = ekat::npack<Pack>(m_num_levs + 1);
-  const auto policy      = ESU::get_default_team_policy(m_num_cols, nlevi_packs);
-  const size_t wsm_bytes = WorkspaceMgr::get_total_bytes_needed(nlevi_packs, 7 + m_num_tracers, policy);
+  const int nlevi_packs = ekat::npack<Pack>(m_num_levs + 1);
+  const auto policy     = ESU::get_default_team_policy(m_num_cols, nlevi_packs);
+  const size_t wsm_bytes =
+      WorkspaceMgr::get_total_bytes_needed(nlevi_packs, 7 + m_num_tracers, policy);
 
   return wsm_bytes;
 }
@@ -82,8 +85,9 @@ void IOPForcing::init_buffers(const ATMBufferManager &buffer_manager) {
   // WSM data
   m_buffer.wsm_data = mem;
 
-  const auto policy       = ESU::get_default_team_policy(m_num_cols, nlevi_packs);
-  const size_t wsm_npacks = WorkspaceMgr::get_total_bytes_needed(nlevi_packs, 7 + m_num_tracers, policy) / sizeof(Pack);
+  const auto policy = ESU::get_default_team_policy(m_num_cols, nlevi_packs);
+  const size_t wsm_npacks =
+      WorkspaceMgr::get_total_bytes_needed(nlevi_packs, 7 + m_num_tracers, policy) / sizeof(Pack);
   mem += wsm_npacks;
 
   size_t used_mem = (reinterpret_cast<Real *>(mem) - buffer_manager.get_memory()) * sizeof(Real);
@@ -91,8 +95,8 @@ void IOPForcing::init_buffers(const ATMBufferManager &buffer_manager) {
                    "Error! Used memory != requested memory for IOPForcing.\n");
 }
 // =========================================================================================
-void IOPForcing::create_helper_field(const std::string &name, const FieldLayout &layout, const std::string &grid_name,
-                                     const int ps) {
+void IOPForcing::create_helper_field(const std::string &name, const FieldLayout &layout,
+                                     const std::string &grid_name, const int ps) {
   using namespace ekat::units;
   FieldIdentifier id(name, layout, Units::nondimensional(), grid_name);
 
@@ -128,11 +132,14 @@ void IOPForcing::initialize_impl(const RunType run_type) {
 }
 // =========================================================================================
 KOKKOS_FUNCTION
-void IOPForcing::advance_iop_subsidence(const MemberType &team, const int nlevs, const Real dt, const Real ps,
-                                        const view_1d<const Pack> &ref_p_mid, const view_1d<const Pack> &ref_p_int,
-                                        const view_1d<const Pack> &ref_p_del, const view_1d<const Pack> &omega,
-                                        const Workspace &workspace, const view_1d<Pack> &u, const view_1d<Pack> &v,
-                                        const view_1d<Pack> &T, const view_2d<Pack> &Q) {
+void IOPForcing::advance_iop_subsidence(const MemberType &team, const int nlevs, const Real dt,
+                                        const Real ps, const view_1d<const Pack> &ref_p_mid,
+                                        const view_1d<const Pack> &ref_p_int,
+                                        const view_1d<const Pack> &ref_p_del,
+                                        const view_1d<const Pack> &omega,
+                                        const Workspace &workspace, const view_1d<Pack> &u,
+                                        const view_1d<Pack> &v, const view_1d<Pack> &T,
+                                        const view_2d<Pack> &Q) {
   constexpr Real Rair  = C::Rair;
   constexpr Real Cpair = C::Cpair;
 
@@ -164,7 +171,8 @@ void IOPForcing::advance_iop_subsidence(const MemberType &team, const int nlevs,
     ekat::index_and_shift<-1>(s_omega, range_pack, omega_k, omega_km1);
 
     const auto weight = (ref_p_int(k) - ref_p_mid_km1) / (ref_p_mid_k - ref_p_mid_km1);
-    omega_int(k).set(range_pack >= 1 and range_pack <= nlevs - 1, weight * omega_k + (1 - weight) * omega_km1);
+    omega_int(k).set(range_pack >= 1 and range_pack <= nlevs - 1,
+                     weight * omega_k + (1 - weight) * omega_km1);
   });
   omega_int(0)[0]                             = 0;
   omega_int(nlevs / Pack::n)[nlevs % Pack::n] = 0;
@@ -245,7 +253,8 @@ void IOPForcing::advance_iop_subsidence(const MemberType &team, const int nlevs,
     Pack delta_tracer_k, delta_tracer_km1;
     for (int iq = 0; iq < n_q_tracers; ++iq) {
       auto s_delta_tracer = Kokkos::subview(s_delta_Q, iq, Kokkos::ALL());
-      ekat::index_and_shift<-1>(s_delta_tracer, range_pack_for_m1_shift, delta_tracer_k, delta_tracer_km1);
+      ekat::index_and_shift<-1>(s_delta_tracer, range_pack_for_m1_shift, delta_tracer_k,
+                                delta_tracer_km1);
       if (any_at_top)
         delta_tracer_k.set(at_top, s_delta_tracer(0));
       if (any_at_bot)
@@ -263,8 +272,9 @@ void IOPForcing::advance_iop_subsidence(const MemberType &team, const int nlevs,
 // =========================================================================================
 KOKKOS_FUNCTION
 void IOPForcing::advance_iop_forcing(const MemberType &team, const int nlevs, const Real dt,
-                                     const view_1d<const Pack> &divT, const view_1d<const Pack> &divq,
-                                     const view_1d<Pack> &T, const view_1d<Pack> &qv) {
+                                     const view_1d<const Pack> &divT,
+                                     const view_1d<const Pack> &divq, const view_1d<Pack> &T,
+                                     const view_1d<Pack> &qv) {
   const auto nlev_packs = ekat::npack<Pack>(nlevs);
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev_packs), [&](const int k) {
     T(k).update(divT(k), dt, 1.0);
@@ -273,9 +283,10 @@ void IOPForcing::advance_iop_forcing(const MemberType &team, const int nlevs, co
 }
 // =========================================================================================
 KOKKOS_FUNCTION
-void IOPForcing::iop_apply_coriolis(const MemberType &team, const int nlevs, const Real dt, const Real lat,
-                                    const view_1d<const Pack> &u_ls, const view_1d<const Pack> &v_ls,
-                                    const view_1d<Pack> &u, const view_1d<Pack> &v) {
+void IOPForcing::iop_apply_coriolis(const MemberType &team, const int nlevs, const Real dt,
+                                    const Real lat, const view_1d<const Pack> &u_ls,
+                                    const view_1d<const Pack> &v_ls, const view_1d<Pack> &u,
+                                    const view_1d<Pack> &v) {
   constexpr Real pi             = C::Pi;
   constexpr Real earth_rotation = C::omega;
 
@@ -314,16 +325,17 @@ void IOPForcing::run_impl(const double dt) {
   m_iop_data_manager->read_iop_file_data(start_of_step_ts());
 
   // Define local IOP param values
-  const auto iop_dosubsidence     = m_iop_data_manager->get_params().get<bool>("iop_dosubsidence");
-  const auto iop_coriolis         = m_iop_data_manager->get_params().get<bool>("iop_coriolis");
-  const auto iop_nudge_tq         = m_iop_data_manager->get_params().get<bool>("iop_nudge_tq");
-  const auto iop_nudge_uv         = m_iop_data_manager->get_params().get<bool>("iop_nudge_uv");
-  const auto use_large_scale_wind = m_iop_data_manager->get_params().get<bool>("use_large_scale_wind");
-  const auto use_3d_forcing       = m_iop_data_manager->get_params().get<bool>("use_3d_forcing");
-  const auto target_lat           = m_iop_data_manager->get_params().get<Real>("target_latitude");
-  const auto iop_nudge_tscale     = m_iop_data_manager->get_params().get<Real>("iop_nudge_tscale");
-  const auto iop_nudge_tq_low     = m_iop_data_manager->get_params().get<Real>("iop_nudge_tq_low");
-  const auto iop_nudge_tq_high    = m_iop_data_manager->get_params().get<Real>("iop_nudge_tq_high");
+  const auto iop_dosubsidence = m_iop_data_manager->get_params().get<bool>("iop_dosubsidence");
+  const auto iop_coriolis     = m_iop_data_manager->get_params().get<bool>("iop_coriolis");
+  const auto iop_nudge_tq     = m_iop_data_manager->get_params().get<bool>("iop_nudge_tq");
+  const auto iop_nudge_uv     = m_iop_data_manager->get_params().get<bool>("iop_nudge_uv");
+  const auto use_large_scale_wind =
+      m_iop_data_manager->get_params().get<bool>("use_large_scale_wind");
+  const auto use_3d_forcing    = m_iop_data_manager->get_params().get<bool>("use_3d_forcing");
+  const auto target_lat        = m_iop_data_manager->get_params().get<Real>("target_latitude");
+  const auto iop_nudge_tscale  = m_iop_data_manager->get_params().get<Real>("iop_nudge_tscale");
+  const auto iop_nudge_tq_low  = m_iop_data_manager->get_params().get<Real>("iop_nudge_tq_low");
+  const auto iop_nudge_tq_high = m_iop_data_manager->get_params().get<Real>("iop_nudge_tq_high");
 
   // Define local IOP field views
   const Real ps_iop = m_iop_data_manager->get_iop_field("Ps").get_view<const Real, Host>()();
@@ -344,10 +356,12 @@ void IOPForcing::run_impl(const double dt) {
     t_iop  = m_iop_data_manager->get_iop_field("T").get_view<const Pack *>();
   }
   if (iop_nudge_uv) {
-    u_iop = use_large_scale_wind ? m_iop_data_manager->get_iop_field("u_ls").get_view<const Pack *>()
-                                 : m_iop_data_manager->get_iop_field("u").get_view<const Pack *>();
-    v_iop = use_large_scale_wind ? m_iop_data_manager->get_iop_field("v_ls").get_view<const Pack *>()
-                                 : m_iop_data_manager->get_iop_field("v").get_view<const Pack *>();
+    u_iop = use_large_scale_wind
+                ? m_iop_data_manager->get_iop_field("u_ls").get_view<const Pack *>()
+                : m_iop_data_manager->get_iop_field("u").get_view<const Pack *>();
+    v_iop = use_large_scale_wind
+                ? m_iop_data_manager->get_iop_field("v_ls").get_view<const Pack *>()
+                : m_iop_data_manager->get_iop_field("v").get_view<const Pack *>();
   }
 
   // Team policy and workspace manager for eamxx
@@ -393,8 +407,8 @@ void IOPForcing::run_impl(const double dt) {
 
         if (iop_dosubsidence) {
           // Compute subsidence due to large-scale forcing
-          advance_iop_subsidence(team, num_levs, dt, ps_i, ref_p_mid, ref_p_int, ref_p_del, omega, ws, u_i, v_i,
-                                 T_mid_i, Q_i);
+          advance_iop_subsidence(team, num_levs, dt, ps_i, ref_p_mid, ref_p_int, ref_p_del, omega,
+                                 ws, u_i, v_i, T_mid_i, Q_i);
         }
 
         // Update T and qv according to large scale forcing as specified in IOP file.
@@ -449,8 +463,9 @@ void IOPForcing::run_impl(const double dt) {
           // Compute reference pressures and layer thickness.
           // TODO: Allow geometry data to allocate packsize
           auto s_ref_p_mid = ekat::scalarize(ref_p_mid);
-          Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_levs),
-                               [&](const int &k) { s_ref_p_mid(k) = hyam(k) * ps0 + hybm(k) * ps_i; });
+          Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_levs), [&](const int &k) {
+            s_ref_p_mid(k) = hyam(k) * ps0 + hybm(k) * ps_i;
+          });
           team.team_barrier();
 
           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev_packs), [&](const int &k) {
diff --git i/components/eamxx/src/physics/iop_forcing/eamxx_iop_forcing_process_interface.hpp w/components/eamxx/src/physics/iop_forcing/eamxx_iop_forcing_process_interface.hpp
index 48b7742707..b39b2f3fbb 100644
--- i/components/eamxx/src/physics/iop_forcing/eamxx_iop_forcing_process_interface.hpp
+++ w/components/eamxx/src/physics/iop_forcing/eamxx_iop_forcing_process_interface.hpp
@@ -45,7 +45,8 @@ class IOPForcing : public scream::AtmosphereProcess {
 
 public:
   // Constructors
-  IOPForcing(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereProcess(comm, params) {}
+  IOPForcing(const ekat::Comm &comm, const ekat::ParameterList &params)
+      : AtmosphereProcess(comm, params) {}
 
   // The type of subcomponent
   AtmosphereProcessType type() const { return AtmosphereProcessType::Physics; }
@@ -65,10 +66,12 @@ protected:
 
   // Compute effects of large scale subsidence on T, q, u, and v.
   KOKKOS_FUNCTION
-  static void advance_iop_subsidence(const KT::MemberType &team, const int nlevs, const Real dt, const Real ps,
-                                     const view_1d<const Pack> &pmid, const view_1d<const Pack> &pint,
-                                     const view_1d<const Pack> &pdel, const view_1d<const Pack> &omega,
-                                     const Workspace &workspace, const view_1d<Pack> &u, const view_1d<Pack> &v,
+  static void advance_iop_subsidence(const KT::MemberType &team, const int nlevs, const Real dt,
+                                     const Real ps, const view_1d<const Pack> &pmid,
+                                     const view_1d<const Pack> &pint,
+                                     const view_1d<const Pack> &pdel,
+                                     const view_1d<const Pack> &omega, const Workspace &workspace,
+                                     const view_1d<Pack> &u, const view_1d<Pack> &v,
                                      const view_1d<Pack> &T, const view_2d<Pack> &Q);
 
   // Apply large scale forcing for temperature and water vapor as provided by the IOP file
@@ -77,11 +80,13 @@ protected:
                                   const view_1d<const Pack> &divT, const view_1d<const Pack> &divq,
                                   const view_1d<Pack> &T, const view_1d<Pack> &qv);
 
-  // Provide coriolis forcing to u and v winds, using large scale winds specified in IOP forcing file.
+  // Provide coriolis forcing to u and v winds, using large scale winds specified in IOP forcing
+  // file.
   KOKKOS_FUNCTION
-  static void iop_apply_coriolis(const KT::MemberType &team, const int nlevs, const Real dt, const Real lat,
-                                 const view_1d<const Pack> &u_ls, const view_1d<const Pack> &v_ls,
-                                 const view_1d<Pack> &u, const view_1d<Pack> &v);
+  static void iop_apply_coriolis(const KT::MemberType &team, const int nlevs, const Real dt,
+                                 const Real lat, const view_1d<const Pack> &u_ls,
+                                 const view_1d<const Pack> &v_ls, const view_1d<Pack> &u,
+                                 const view_1d<Pack> &v);
 
   void run_impl(const double dt);
 
@@ -89,8 +94,8 @@ protected:
   void finalize_impl() {}
 
   // Creates an helper field, not to be shared with the AD's FieldManager
-  void create_helper_field(const std::string &name, const FieldLayout &layout, const std::string &grid_name,
-                           const int ps = 1);
+  void create_helper_field(const std::string &name, const FieldLayout &layout,
+                           const std::string &grid_name, const int ps = 1);
 
   void set_computed_group_impl(const FieldGroup &group);
 
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_aci_functions.hpp w/components/eamxx/src/physics/mam/eamxx_mam_aci_functions.hpp
index 407e7f2208..dd3d1e51e7 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_aci_functions.hpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_aci_functions.hpp
@@ -9,8 +9,9 @@ namespace scream {
 
 namespace {
 
-void compute_w0_and_rho(haero::ThreadTeamPolicy team_policy, const mam_coupling::DryAtmosphere &dry_atmosphere,
-                        const int top_lev, const int nlev,
+void compute_w0_and_rho(haero::ThreadTeamPolicy team_policy,
+                        const mam_coupling::DryAtmosphere &dry_atmosphere, const int top_lev,
+                        const int nlev,
                         // output
                         MAMAci::view_2d w0, MAMAci::view_2d rho) {
   MAMAci::const_view_2d omega = dry_atmosphere.omega;
@@ -35,8 +36,9 @@ void compute_w0_and_rho(haero::ThreadTeamPolicy team_policy, const mam_coupling:
       });
 }
 
-void compute_tke_at_interfaces(haero::ThreadTeamPolicy team_policy, const MAMAci::const_view_2d var_mid,
-                               const MAMAci::view_2d dz, const int nlev_, MAMAci::view_2d w_sec_int,
+void compute_tke_at_interfaces(haero::ThreadTeamPolicy team_policy,
+                               const MAMAci::const_view_2d var_mid, const MAMAci::view_2d dz,
+                               const int nlev_, MAMAci::view_2d w_sec_int,
                                // output
                                MAMAci::view_2d tke) {
   using CO = scream::ColumnOps<DefaultDevice, Real>;
@@ -52,17 +54,20 @@ void compute_tke_at_interfaces(haero::ThreadTeamPolicy team_policy, const MAMAci
         const Real bc_top = var_mid_col(0);
         const Real bc_bot = var_mid_col(nlev_ - 1);
 
-        CO::compute_interface_values_linear(team, nlev_, var_mid_col, dz_col, bc_top, bc_bot, w_sec_int_col);
+        CO::compute_interface_values_linear(team, nlev_, var_mid_col, dz_col, bc_top, bc_bot,
+                                            w_sec_int_col);
         team.team_barrier();
         Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev_ + 1),
                              [&](int kk) { tke(icol, kk) = (3.0 / 2.0) * w_sec_int(icol, kk); });
       });
 }
 
-void compute_subgrid_scale_velocities(haero::ThreadTeamPolicy team_policy, const MAMAci::const_view_2d tke,
-                                      const Real wsubmin, const int top_lev, const int nlev,
+void compute_subgrid_scale_velocities(haero::ThreadTeamPolicy team_policy,
+                                      const MAMAci::const_view_2d tke, const Real wsubmin,
+                                      const int top_lev, const int nlev,
                                       // output
-                                      MAMAci::view_2d wsub, MAMAci::view_2d wsubice, MAMAci::view_2d wsig) {
+                                      MAMAci::view_2d wsub, MAMAci::view_2d wsubice,
+                                      MAMAci::view_2d wsig) {
   Kokkos::parallel_for(
       team_policy, KOKKOS_LAMBDA(const haero::ThreadTeam &team) {
         const int icol = team.league_rank();
@@ -83,15 +88,16 @@ void compute_subgrid_scale_velocities(haero::ThreadTeamPolicy team_policy, const
       });
 }
 
-void compute_nucleate_ice_tendencies(const mam4::NucleateIce &nucleate_ice, haero::ThreadTeamPolicy team_policy,
-                                     const mam_coupling::DryAtmosphere &dry_atmosphere,
-                                     const mam_coupling::AerosolState &dry_aero, const MAMAci::view_2d wsubice,
-                                     const MAMAci::view_2d aitken_dry_dia, const int nlev, const double dt,
-                                     // output
-                                     MAMAci::view_2d nihf, MAMAci::view_2d niim, MAMAci::view_2d nidep,
-                                     MAMAci::view_2d nimey, MAMAci::view_2d naai_hom,
-                                     // ## output used by other processes ##
-                                     MAMAci::view_2d naai) {
+void compute_nucleate_ice_tendencies(
+    const mam4::NucleateIce &nucleate_ice, haero::ThreadTeamPolicy team_policy,
+    const mam_coupling::DryAtmosphere &dry_atmosphere, const mam_coupling::AerosolState &dry_aero,
+    const MAMAci::view_2d wsubice, const MAMAci::view_2d aitken_dry_dia, const int nlev,
+    const double dt,
+    // output
+    MAMAci::view_2d nihf, MAMAci::view_2d niim, MAMAci::view_2d nidep, MAMAci::view_2d nimey,
+    MAMAci::view_2d naai_hom,
+    // ## output used by other processes ##
+    MAMAci::view_2d naai) {
   //-------------------------------------------------------------
   // Get number of activated aerosol for ice nucleation (naai)
   // from ice nucleation
@@ -144,12 +150,15 @@ void compute_nucleate_ice_tendencies(const mam4::NucleateIce &nucleate_ice, haer
         const mam4::Tendencies tends(nlev); // not used
         const mam4::AeroConfig aero_config;
         const Real t = 0; // not used
-        nucleate_ice.compute_tendencies(aero_config, team, t, dt, haero_atm, surf, progs, diags, tends);
+        nucleate_ice.compute_tendencies(aero_config, team, t, dt, haero_atm, surf, progs, diags,
+                                        tends);
       });
 }
-void store_liquid_cloud_fraction(haero::ThreadTeamPolicy team_policy, const mam_coupling::DryAtmosphere &dry_atmosphere,
-                                 const MAMAci::const_view_2d liqcldf, const MAMAci::const_view_2d liqcldf_prev,
-                                 const int top_lev, const int nlev,
+void store_liquid_cloud_fraction(haero::ThreadTeamPolicy team_policy,
+                                 const mam_coupling::DryAtmosphere &dry_atmosphere,
+                                 const MAMAci::const_view_2d liqcldf,
+                                 const MAMAci::const_view_2d liqcldf_prev, const int top_lev,
+                                 const int nlev,
                                  // output
                                  MAMAci::view_2d cloud_frac, MAMAci::view_2d cloud_frac_prev) {
   MAMAci::const_view_2d qc = dry_atmosphere.qc;
@@ -178,12 +187,14 @@ void store_liquid_cloud_fraction(haero::ThreadTeamPolicy team_policy, const mam_
 void call_function_dropmixnuc(
     haero::ThreadTeamPolicy team_policy, const Real dt, mam_coupling::DryAtmosphere &dry_atmosphere,
     const MAMAci::view_2d rpdel, const MAMAci::const_view_2d kvh_mid, const MAMAci::view_2d kvh_int,
-    const MAMAci::view_2d wsub, const MAMAci::view_2d cloud_frac, const MAMAci::view_2d cloud_frac_prev,
-    const mam_coupling::AerosolState &dry_aero, const int nlev, const int top_lev, const bool &enable_aero_vertical_mix,
+    const MAMAci::view_2d wsub, const MAMAci::view_2d cloud_frac,
+    const MAMAci::view_2d cloud_frac_prev, const mam_coupling::AerosolState &dry_aero,
+    const int nlev, const int top_lev, const bool &enable_aero_vertical_mix,
 
     // Following outputs are all diagnostics
-    MAMAci::view_2d coltend[mam4::ndrop::ncnst_tot], MAMAci::view_2d coltend_cw[mam4::ndrop::ncnst_tot],
-    MAMAci::view_2d qcld, MAMAci::view_2d ndropcol, MAMAci::view_2d ndropmix, MAMAci::view_2d nsource,
+    MAMAci::view_2d coltend[mam4::ndrop::ncnst_tot],
+    MAMAci::view_2d coltend_cw[mam4::ndrop::ncnst_tot], MAMAci::view_2d qcld,
+    MAMAci::view_2d ndropcol, MAMAci::view_2d ndropmix, MAMAci::view_2d nsource,
     MAMAci::view_2d wtke, MAMAci::view_3d ccn,
 
     // ## outputs to be used by other processes ##
@@ -280,12 +291,13 @@ void call_function_dropmixnuc(
 
   Real specdens_amode[maxd_aspectype] = {};
   Real spechygro[maxd_aspectype]      = {};
-  Real exp45logsig[ntot_amode] = {}, alogsig[ntot_amode] = {}, num2vol_ratio_min_nmodes[ntot_amode] = {},
-       num2vol_ratio_max_nmodes[ntot_amode] = {};
-  Real aten                                 = 0;
-  mam4::ndrop::get_e3sm_parameters(nspec_amode, lspectype_amode, lmassptr_amode, numptr_amode, specdens_amode,
-                                   spechygro, mam_idx, mam_cnst_idx);
-  mam4::ndrop::ndrop_init(exp45logsig, alogsig, aten, num2vol_ratio_min_nmodes, num2vol_ratio_max_nmodes);
+  Real exp45logsig[ntot_amode] = {}, alogsig[ntot_amode] = {},
+       num2vol_ratio_min_nmodes[ntot_amode] = {}, num2vol_ratio_max_nmodes[ntot_amode] = {};
+  Real aten = 0;
+  mam4::ndrop::get_e3sm_parameters(nspec_amode, lspectype_amode, lmassptr_amode, numptr_amode,
+                                   specdens_amode, spechygro, mam_idx, mam_cnst_idx);
+  mam4::ndrop::ndrop_init(exp45logsig, alogsig, aten, num2vol_ratio_min_nmodes,
+                          num2vol_ratio_max_nmodes);
   //---------------------------------------------------------------------------
   //---------------------------------------------------------------------------
   const bool local_enable_aero_vertical_mix = enable_aero_vertical_mix;
@@ -309,7 +321,8 @@ void call_function_dropmixnuc(
         for (int i = 0; i < mam4::aero_model::pcnst; ++i) {
           ptend_q_view[i] = ekat::subview(loc_ptend_q[i], icol);
         }
-        mam4::ColumnView coltend_view[mam4::ndrop::ncnst_tot], coltend_cw_view[mam4::ndrop::ncnst_tot];
+        mam4::ColumnView coltend_view[mam4::ndrop::ncnst_tot],
+            coltend_cw_view[mam4::ndrop::ncnst_tot];
         for (int i = 0; i < mam4::ndrop::ncnst_tot; ++i) {
           coltend_view[i]    = ekat::subview(loc_coltend[i], icol);
           coltend_cw_view[i] = ekat::subview(loc_coltend_cw[i], icol);
@@ -332,7 +345,8 @@ void call_function_dropmixnuc(
         const Real bc_top = kvh_mid_col(0);
         const Real bc_bot = kvh_mid_col(nlev - 1);
 
-        CO::compute_interface_values_linear(team, nlev, kvh_mid_col, dz_col, bc_top, bc_bot, kvh_int_col);
+        CO::compute_interface_values_linear(team, nlev, kvh_mid_col, dz_col, bc_top, bc_bot,
+                                            kvh_int_col);
 
         // Construct state_q (interstitial) and qqcw (cloud borne) arrays
         constexpr auto pver = mam4::ndrop::pver;
@@ -342,7 +356,8 @@ void call_function_dropmixnuc(
           // get state_q at a grid cell (col,lev)
           // NOTE: The order of species in state_q_at_lev_col
           // is the same as in E3SM state%q array
-          mam4::utils::extract_stateq_from_prognostics(progs_at_col, haero_atm, state_q_at_lev_col, klev);
+          mam4::utils::extract_stateq_from_prognostics(progs_at_col, haero_atm, state_q_at_lev_col,
+                                                       klev);
 
           // get the start index for aerosols species in the state_q array
           int istart = mam4::utils::aero_start_ind();
@@ -369,32 +384,36 @@ void call_function_dropmixnuc(
         });
         team.team_barrier();
         mam4::ndrop::dropmixnuc(
-            team, dt, ekat::subview(T_mid, icol), ekat::subview(p_mid, icol), ekat::subview(p_int, icol),
-            ekat::subview(pdel, icol), ekat::subview(rpdel, icol),
+            team, dt, ekat::subview(T_mid, icol), ekat::subview(p_mid, icol),
+            ekat::subview(p_int, icol), ekat::subview(pdel, icol), ekat::subview(rpdel, icol),
             // in zm[kk] - zm[kk+1], for pver zm[kk-1] - zm[kk]
             ekat::subview(zm, icol), ekat::subview(state_q_work_loc, icol), ekat::subview(nc, icol),
             ekat::subview(kvh_int, icol), // kvh[kk+1]
-            ekat::subview(cloud_frac, icol), lspectype_amode, specdens_amode, spechygro, lmassptr_amode,
-            num2vol_ratio_min_nmodes, num2vol_ratio_max_nmodes, numptr_amode, nspec_amode, exp45logsig, alogsig, aten,
-            mam_idx, mam_cnst_idx, local_enable_aero_vertical_mix, ekat::subview(qcld, icol), // out
-            ekat::subview(wsub, icol),                                                        // in
-            ekat::subview(cloud_frac_prev, icol),                                             // in
-            qqcw_view,                                                                        // inout
-            ptend_q_view, ekat::subview(tendnd, icol), ekat::subview(factnum, icol), ekat::subview(ndropcol, icol),
-            ekat::subview(ndropmix, icol), ekat::subview(nsource, icol), ekat::subview(wtke, icol),
-            ekat::subview(ccn, icol), coltend_view, coltend_cw_view, top_lev,
+            ekat::subview(cloud_frac, icol), lspectype_amode, specdens_amode, spechygro,
+            lmassptr_amode, num2vol_ratio_min_nmodes, num2vol_ratio_max_nmodes, numptr_amode,
+            nspec_amode, exp45logsig, alogsig, aten, mam_idx, mam_cnst_idx,
+            local_enable_aero_vertical_mix, ekat::subview(qcld, icol), // out
+            ekat::subview(wsub, icol),                                 // in
+            ekat::subview(cloud_frac_prev, icol),                      // in
+            qqcw_view,                                                 // inout
+            ptend_q_view, ekat::subview(tendnd, icol), ekat::subview(factnum, icol),
+            ekat::subview(ndropcol, icol), ekat::subview(ndropmix, icol),
+            ekat::subview(nsource, icol), ekat::subview(wtke, icol), ekat::subview(ccn, icol),
+            coltend_view, coltend_cw_view, top_lev,
             // work arrays
             raercol_cw_view, raercol_view, ekat::subview(nact, icol), ekat::subview(mact, icol),
             ekat::subview(eddy_diff, icol), ekat::subview(zn, icol), ekat::subview(csbot, icol),
             ekat::subview(zs, icol), ekat::subview(overlapp, icol), ekat::subview(overlapm, icol),
-            ekat::subview(eddy_diff_kp, icol), ekat::subview(eddy_diff_km, icol), ekat::subview(qncld, icol),
-            ekat::subview(srcn, icol), ekat::subview(source, icol), ekat::subview(dz, icol),
-            ekat::subview(csbot_cscen, icol), ekat::subview(raertend, icol), ekat::subview(qqcwtend, icol));
+            ekat::subview(eddy_diff_kp, icol), ekat::subview(eddy_diff_km, icol),
+            ekat::subview(qncld, icol), ekat::subview(srcn, icol), ekat::subview(source, icol),
+            ekat::subview(dz, icol), ekat::subview(csbot_cscen, icol),
+            ekat::subview(raertend, icol), ekat::subview(qqcwtend, icol));
       });
 }
 
 // Update cloud borne aerosols
-void update_cloud_borne_aerosols(const MAMAci::view_2d qqcw_fld_work[mam4::ndrop::ncnst_tot], const int nlev,
+void update_cloud_borne_aerosols(const MAMAci::view_2d qqcw_fld_work[mam4::ndrop::ncnst_tot],
+                                 const int nlev,
                                  // output
                                  mam_coupling::AerosolState &dry_aero) {
   int ind_qqcw = 0;
@@ -412,7 +431,8 @@ void update_cloud_borne_aerosols(const MAMAci::view_2d qqcw_fld_work[mam4::ndrop
 
 // Update interstitial aerosols using tendencies- cols and levs
 void update_interstitial_aerosols(haero::ThreadTeamPolicy team_policy,
-                                  const MAMAci::view_2d ptend_q[mam4::aero_model::pcnst], const int nlev, const Real dt,
+                                  const MAMAci::view_2d ptend_q[mam4::aero_model::pcnst],
+                                  const int nlev, const Real dt,
                                   // output
                                   mam_coupling::AerosolState &dry_aero) {
   // starting index of ptend_q array (for MAM4, pcnst=40, ncnst_tot=25 )
@@ -430,8 +450,9 @@ void update_interstitial_aerosols(haero::ThreadTeamPolicy team_policy,
             team_policy, KOKKOS_LAMBDA(const haero::ThreadTeam &team) {
               const int icol = team.league_rank();
               // update values for all levs at this column
-              Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev),
-                                   [&](int kk) { aero_mmr(icol, kk) += ptend_view(icol, kk) * dt; });
+              Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev), [&](int kk) {
+                aero_mmr(icol, kk) += ptend_view(icol, kk) * dt;
+              });
             });
         // update index for the next species (only if aero_mmr.data() is True)
         ++s_idx;
@@ -451,8 +472,9 @@ void update_interstitial_aerosols(haero::ThreadTeamPolicy team_policy,
 }
 
 void call_hetfrz_compute_tendencies(haero::ThreadTeamPolicy team_policy, mam4::Hetfrz &hetfrz_,
-                                    mam_coupling::DryAtmosphere &dry_atm_, mam_coupling::AerosolState &dry_aero_,
-                                    MAMAci::view_3d factnum, const double dt, const int nlev,
+                                    mam_coupling::DryAtmosphere &dry_atm_,
+                                    mam_coupling::AerosolState &dry_aero_, MAMAci::view_3d factnum,
+                                    const double dt, const int nlev,
                                     // output
                                     MAMAci::view_2d hetfrz_immersion_nucleation_tend,
                                     MAMAci::view_2d hetfrz_contact_nucleation_tend,
@@ -488,9 +510,11 @@ void call_hetfrz_compute_tendencies(haero::ThreadTeamPolicy team_policy, mam4::H
 
         // These are the output tendencies from heterogeneous freezing that need
         // to be added correctly to the cloud-micorphysics scheme.
-        diags.hetfrz_immersion_nucleation_tend = ekat::subview(hetfrz_immersion_nucleation_tend, icol);
-        diags.hetfrz_contact_nucleation_tend   = ekat::subview(hetfrz_contact_nucleation_tend, icol);
-        diags.hetfrz_depostion_nucleation_tend = ekat::subview(hetfrz_depostion_nucleation_tend, icol);
+        diags.hetfrz_immersion_nucleation_tend =
+            ekat::subview(hetfrz_immersion_nucleation_tend, icol);
+        diags.hetfrz_contact_nucleation_tend = ekat::subview(hetfrz_contact_nucleation_tend, icol);
+        diags.hetfrz_depostion_nucleation_tend =
+            ekat::subview(hetfrz_depostion_nucleation_tend, icol);
 
         diags.bc_num                    = ekat::subview(diagnostic_scratch[0], icol);
         diags.dst1_num                  = ekat::subview(diagnostic_scratch[1], icol);
@@ -538,8 +562,9 @@ void call_hetfrz_compute_tendencies(haero::ThreadTeamPolicy team_policy, mam4::H
 
         // assign cloud fraction
         constexpr auto pver = mam4::ndrop::pver;
-        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, 0u, pver),
-                             [&](int klev) { diags.stratiform_cloud_fraction(klev) = haero_atm.cloud_fraction(klev); });
+        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, 0u, pver), [&](int klev) {
+          diags.stratiform_cloud_fraction(klev) = haero_atm.cloud_fraction(klev);
+        });
         //-------------------------------------------------------------
         // Heterogeneous freezing
         // frzimm, frzcnt, frzdep are the outputs of
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_aci_process_interface.cpp w/components/eamxx/src/physics/mam/eamxx_mam_aci_process_interface.cpp
index ccbbbd947b..855aba459d 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_aci_process_interface.cpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_aci_process_interface.cpp
@@ -36,9 +36,11 @@ directly
 */
 
 namespace scream {
-MAMAci::MAMAci(const ekat::Comm &comm, const ekat::ParameterList &params) : MAMGenericInterface(comm, params) {
+MAMAci::MAMAci(const ekat::Comm &comm, const ekat::ParameterList &params)
+    : MAMGenericInterface(comm, params) {
   // Asserts for the runtime or namelist options
-  EKAT_REQUIRE_MSG(m_params.isParameter("wsubmin"), "ERROR: wsubmin is missing from mam_aci parameter list.");
+  EKAT_REQUIRE_MSG(m_params.isParameter("wsubmin"),
+                   "ERROR: wsubmin is missing from mam_aci parameter list.");
   EKAT_REQUIRE_MSG(m_params.isParameter("enable_aero_vertical_mix"),
                    "ERROR: enable_aero_vertical_mix is missing from mam_aci "
                    "parameter list.");
@@ -268,8 +270,9 @@ void MAMAci::init_temporary_views() {
   const int workspace_used     = work_ptr - buffer_.temporary_views.data();
   const int workspace_provided = buffer_.temporary_views.extent(0);
   EKAT_REQUIRE_MSG(workspace_used == workspace_provided,
-                   "Error: workspace_used (" + std::to_string(workspace_used) + ") and workspace_provided (" +
-                       std::to_string(workspace_provided) + ") should be equal. \n");
+                   "Error: workspace_used (" + std::to_string(workspace_used) +
+                       ") and workspace_provided (" + std::to_string(workspace_provided) +
+                       ") should be equal. \n");
 }
 // ================================================================
 //  INITIALIZE_IMPL
@@ -350,9 +353,12 @@ void MAMAci::initialize_impl(const RunType run_type) {
   populate_cloudborne_dry_aero(dry_aero_, buffer_);
 
   // hetrozenous freezing outputs
-  hetfrz_immersion_nucleation_tend_  = get_field_out("hetfrz_immersion_nucleation_tend").get_view<Real **>();
-  hetfrz_contact_nucleation_tend_    = get_field_out("hetfrz_contact_nucleation_tend").get_view<Real **>();
-  hetfrz_deposition_nucleation_tend_ = get_field_out("hetfrz_deposition_nucleation_tend").get_view<Real **>();
+  hetfrz_immersion_nucleation_tend_ =
+      get_field_out("hetfrz_immersion_nucleation_tend").get_view<Real **>();
+  hetfrz_contact_nucleation_tend_ =
+      get_field_out("hetfrz_contact_nucleation_tend").get_view<Real **>();
+  hetfrz_deposition_nucleation_tend_ =
+      get_field_out("hetfrz_deposition_nucleation_tend").get_view<Real **>();
 
   //---------------------------------------------------------------------------------
   // Allocate memory for the class members
@@ -477,7 +483,8 @@ void MAMAci::initialize_impl(const RunType run_type) {
 //  RUN_IMPL
 // ================================================================
 void MAMAci::run_impl(const double dt) {
-  const auto scan_policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
+  const auto scan_policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
 
   // preprocess input -- needs a scan for the calculation of local derivied
   // quantities
@@ -505,14 +512,16 @@ void MAMAci::run_impl(const double dt) {
                                    wsub_, wsubice_, wsig_);
 
   // We need dry diameter for only aitken mode
-  Kokkos::deep_copy(aitken_dry_dia_, ekat::subview_1(dgnum_, static_cast<int>(mam4::ModeIndex::Aitken)));
+  Kokkos::deep_copy(aitken_dry_dia_,
+                    ekat::subview_1(dgnum_, static_cast<int>(mam4::ModeIndex::Aitken)));
 
   Kokkos::fence(); // wait for aitken_dry_dia_ to be copied.
 
   //  Compute Ice nucleation
   //  NOTE: The Fortran version uses "ast" for cloud fraction which is
   //  equivalent to "cldfrac_tot" in FM. It is part of the "dry_atm_" struct
-  compute_nucleate_ice_tendencies(nucleate_ice_, team_policy, dry_atm_, dry_aero_, wsubice_, aitken_dry_dia_, nlev_, dt,
+  compute_nucleate_ice_tendencies(nucleate_ice_, team_policy, dry_atm_, dry_aero_, wsubice_,
+                                  aitken_dry_dia_, nlev_, dt,
                                   // output
                                   nihf_, niim_, nidep_, nimey_, naai_hom_,
                                   // ## output to be used by the other processes ##
@@ -532,14 +541,15 @@ void MAMAci::run_impl(const double dt) {
   //  Compute activated CCN number tendency (tendnd_) and updated
   //  cloud borne aerosols (stored in a work array) and interstitial
   //  aerosols tendencies
-  call_function_dropmixnuc(team_policy, dt, dry_atm_, rpdel_, kvh_mid_, kvh_int_, wsub_, cloud_frac_, cloud_frac_prev_,
-                           dry_aero_, nlev_, top_lev_, enable_aero_vertical_mix_,
-                           // output
-                           coltend_, coltend_cw_, qcld_, ndropcol_, ndropmix_, nsource_, wtke_, ccn_,
-                           // ## output to be used by the other processes ##
-                           qqcw_fld_work_, ptend_q_, factnum_, tendnd_,
-                           // work arrays
-                           raercol_cw_, raercol_, state_q_work_, nact_, mact_, dropmixnuc_scratch_mem_);
+  call_function_dropmixnuc(
+      team_policy, dt, dry_atm_, rpdel_, kvh_mid_, kvh_int_, wsub_, cloud_frac_, cloud_frac_prev_,
+      dry_aero_, nlev_, top_lev_, enable_aero_vertical_mix_,
+      // output
+      coltend_, coltend_cw_, qcld_, ndropcol_, ndropmix_, nsource_, wtke_, ccn_,
+      // ## output to be used by the other processes ##
+      qqcw_fld_work_, ptend_q_, factnum_, tendnd_,
+      // work arrays
+      raercol_cw_, raercol_, state_q_work_, nact_, mact_, dropmixnuc_scratch_mem_);
   Kokkos::fence(); // wait for ptend_q_ to be computed.
 
   Kokkos::deep_copy(ccn_0p02_, Kokkos::subview(ccn_, Kokkos::ALL(), Kokkos::ALL(), 0));
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_aci_process_interface.hpp w/components/eamxx/src/physics/mam/eamxx_mam_aci_process_interface.hpp
index 1fec2d60ed..24eae190f7 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_aci_process_interface.hpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_aci_process_interface.hpp
@@ -167,7 +167,8 @@ public:
     Preprocess() = default;
     // on host: initializes preprocess functor with necessary state data
     void initialize(const int ncol, const int nlev, const mam_coupling::WetAtmosphere &wet_atm,
-                    const mam_coupling::AerosolState &wet_aero, const mam_coupling::DryAtmosphere &dry_atm,
+                    const mam_coupling::AerosolState &wet_aero,
+                    const mam_coupling::DryAtmosphere &dry_atm,
                     const mam_coupling::AerosolState &dry_aero) {
       ncol_pre_     = ncol;
       nlev_pre_     = nlev;
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_constituent_fluxes_functions.hpp w/components/eamxx/src/physics/mam/eamxx_mam_constituent_fluxes_functions.hpp
index 14a6424029..bb1c0e7fac 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_constituent_fluxes_functions.hpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_constituent_fluxes_functions.hpp
@@ -8,11 +8,11 @@ namespace scream {
 
 namespace {
 
-void update_gas_aerosols_using_constituents(const int ncol, const int nlev, const double dt,
-                                            const mam_coupling::DryAtmosphere &dry_atm,
-                                            const MAMConstituentFluxes::const_view_2d &constituent_fluxes,
-                                            // output
-                                            const mam_coupling::AerosolState &wet_aero) {
+void update_gas_aerosols_using_constituents(
+    const int ncol, const int nlev, const double dt, const mam_coupling::DryAtmosphere &dry_atm,
+    const MAMConstituentFluxes::const_view_2d &constituent_fluxes,
+    // output
+    const mam_coupling::AerosolState &wet_aero) {
   using C                      = physics::Constants<Real>;
   static constexpr auto gravit = C::gravit; // Gravity [m/s2]
   static constexpr int pcnst   = mam4::aero_model::pcnst;
@@ -45,7 +45,8 @@ void update_gas_aerosols_using_constituents(const int ncol, const int nlev, cons
                                                      surface_lev);            // input
 
         // Compute the units conversion factor (kg/m2/s to kg/kg)
-        EKAT_KERNEL_ASSERT_MSG(dry_atm.p_del(icol, surface_lev) != 0, "Error! dry_atm.pdel must be non-zero!\n");
+        EKAT_KERNEL_ASSERT_MSG(dry_atm.p_del(icol, surface_lev) != 0,
+                               "Error! dry_atm.pdel must be non-zero!\n");
         const Real rpdel       = 1.0 / dry_atm.p_del(icol, surface_lev);
         const Real unit_factor = dt * gravit * rpdel;
 
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_constituent_fluxes_interface.cpp w/components/eamxx/src/physics/mam/eamxx_mam_constituent_fluxes_interface.cpp
index 4778f564ee..ea6137c294 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_constituent_fluxes_interface.cpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_constituent_fluxes_interface.cpp
@@ -7,7 +7,8 @@ namespace scream {
 // ================================================================
 //  Constructor
 // ================================================================
-MAMConstituentFluxes::MAMConstituentFluxes(const ekat::Comm &comm, const ekat::ParameterList &params)
+MAMConstituentFluxes::MAMConstituentFluxes(const ekat::Comm &comm,
+                                           const ekat::ParameterList &params)
     : MAMGenericInterface(comm, params) {
   /* Anything that can be initialized without grid information can be
    * initialized here. Like universal constants, mam wetscav options.
@@ -166,7 +167,8 @@ void MAMConstituentFluxes::run_impl(const double dt) {
                                icol);         // in
   };
   // policy
-  const auto scan_policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
+  const auto scan_policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
 
   Kokkos::parallel_for("mam_cfi_compute_updraft", scan_policy, lambda);
   Kokkos::fence();
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_dry_deposition_functions.hpp w/components/eamxx/src/physics/mam/eamxx_mam_dry_deposition_functions.hpp
index 5d21fe0af6..c8ba052899 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_dry_deposition_functions.hpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_dry_deposition_functions.hpp
@@ -14,7 +14,8 @@ void compute_tendencies(
     const int ncol, const int nlev, const double dt, const MAMDryDep::const_view_1d obklen,
     const MAMDryDep::const_view_1d surfric, const MAMDryDep::const_view_1d landfrac,
     const MAMDryDep::const_view_1d icefrac, const MAMDryDep::const_view_1d ocnfrac,
-    const MAMDryDep::const_view_1d friction_velocity, const MAMDryDep::const_view_1d aerodynamical_resistance,
+    const MAMDryDep::const_view_1d friction_velocity,
+    const MAMDryDep::const_view_1d aerodynamical_resistance,
     const MAMDryDep::const_view_2d fraction_landuse_, const MAMDryDep::const_view_3d dgncur_awet_,
     const MAMDryDep::const_view_3d wet_dens_, const mam_coupling::DryAtmosphere dry_atm,
     const mam_coupling::AerosolState dry_aero,
@@ -26,10 +27,11 @@ void compute_tendencies(
     MAMDryDep::view_3d ptend_q, MAMDryDep::view_2d aerdepdrycw, MAMDryDep::view_2d aerdepdryis,
 
     // work arrays
-    MAMDryDep::view_2d rho_, MAMDryDep::view_4d vlc_dry_, MAMDryDep::view_3d vlc_trb_, MAMDryDep::view_4d vlc_grv_,
-    MAMDryDep::view_3d dqdt_tmp_, MAMDryDep::view_3d qtracers) {
+    MAMDryDep::view_2d rho_, MAMDryDep::view_4d vlc_dry_, MAMDryDep::view_3d vlc_trb_,
+    MAMDryDep::view_4d vlc_grv_, MAMDryDep::view_3d dqdt_tmp_, MAMDryDep::view_3d qtracers) {
   static constexpr int num_aero_modes = mam_coupling::num_aero_modes();
-  const auto policy = ekat::ExeSpaceUtils<MAMDryDep::KT::ExeSpace>::get_default_team_policy(ncol, nlev);
+  const auto policy =
+      ekat::ExeSpaceUtils<MAMDryDep::KT::ExeSpace>::get_default_team_policy(ncol, nlev);
 
   // Parallel loop over all the columns
   Kokkos::parallel_for(
@@ -107,33 +109,39 @@ void compute_tendencies(
         bool ptend_lq[pcnst]; // currently unused
         mam4::aero_model_drydep(
             // inputs
-            team, fraction_landuse, atm.temperature, atm.pressure, atm.interface_pressure, atm.hydrostatic_dp,
-            ekat::subview(qtracers, icol), dgncur_awet, wet_dens, obklen[icol], surfric[icol], landfrac[icol],
-            icefrac[icol], ocnfrac[icol], friction_velocity[icol], aerodynamical_resistance[icol], dt,
+            team, fraction_landuse, atm.temperature, atm.pressure, atm.interface_pressure,
+            atm.hydrostatic_dp, ekat::subview(qtracers, icol), dgncur_awet, wet_dens, obklen[icol],
+            surfric[icol], landfrac[icol], icefrac[icol], ocnfrac[icol], friction_velocity[icol],
+            aerodynamical_resistance[icol], dt,
             // input-outputs
             qqcw,
             // outputs
-            ekat::subview(ptend_q, icol), ptend_lq, ekat::subview(aerdepdrycw, icol), ekat::subview(aerdepdryis, icol),
+            ekat::subview(ptend_q, icol), ptend_lq, ekat::subview(aerdepdrycw, icol),
+            ekat::subview(aerdepdryis, icol),
             // work arrays
             rho, vlc_dry, vlc_trb, vlc_grv, dqdt_tmp);
       }); // parallel_for for ncols
 } // Compute_tendencies ends
 
 // Update interstitial aerosols using ptend_q tendencies
-void update_interstitial_mmrs(const MAMDryDep::view_3d ptend_q, const double dt, const int ncol, const int nlev,
+void update_interstitial_mmrs(const MAMDryDep::view_3d ptend_q, const double dt, const int ncol,
+                              const int nlev,
                               // output
                               const mam_coupling::AerosolState dry_aero) {
-  const auto policy           = ekat::ExeSpaceUtils<MAMDryDep::KT::ExeSpace>::get_default_team_policy(ncol, nlev);
+  const auto policy =
+      ekat::ExeSpaceUtils<MAMDryDep::KT::ExeSpace>::get_default_team_policy(ncol, nlev);
   static constexpr int nmodes = mam4::AeroConfig::num_modes();
   Kokkos::parallel_for(
       policy, KOKKOS_LAMBDA(const MAMDryDep::KT::MemberType &team) {
         const int icol = team.league_rank();
         Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev), [&](int kk) {
           for (int m = 0; m < nmodes; ++m) {
-            dry_aero.int_aero_nmr[m](icol, kk) += ptend_q(icol, kk, mam4::ConvProc::numptrcw_amode(m)) * dt;
+            dry_aero.int_aero_nmr[m](icol, kk) +=
+                ptend_q(icol, kk, mam4::ConvProc::numptrcw_amode(m)) * dt;
             for (int a = 0; a < mam4::AeroConfig::num_aerosol_ids(); ++a)
               if (-1 < mam4::ConvProc::lmassptrcw_amode(a, m))
-                dry_aero.int_aero_mmr[m][a](icol, kk) += ptend_q(icol, kk, mam4::ConvProc::lmassptrcw_amode(a, m)) * dt;
+                dry_aero.int_aero_mmr[m][a](icol, kk) +=
+                    ptend_q(icol, kk, mam4::ConvProc::lmassptrcw_amode(a, m)) * dt;
           }
         }); // parallel_for nlevs
       });   // parallel_for icol
@@ -144,10 +152,12 @@ void update_cloudborne_mmrs(const MAMDryDep::view_3d qqcw, const double dt, cons
                             // output
                             const mam_coupling::AerosolState dry_aero) {
   for (int m = 0; m < mam_coupling::num_aero_modes(); ++m) {
-    Kokkos::deep_copy(dry_aero.cld_aero_nmr[m], ekat::subview(qqcw, mam4::ConvProc::numptrcw_amode(m)));
+    Kokkos::deep_copy(dry_aero.cld_aero_nmr[m],
+                      ekat::subview(qqcw, mam4::ConvProc::numptrcw_amode(m)));
     for (int a = 0; a < mam_coupling::num_aero_species(); ++a) {
       if (dry_aero.cld_aero_mmr[m][a].data()) {
-        Kokkos::deep_copy(dry_aero.cld_aero_mmr[m][a], ekat::subview(qqcw, mam4::ConvProc::lmassptrcw_amode(a, m)));
+        Kokkos::deep_copy(dry_aero.cld_aero_mmr[m][a],
+                          ekat::subview(qqcw, mam4::ConvProc::lmassptrcw_amode(a, m)));
       }
     }
   }
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_dry_deposition_process_interface.cpp w/components/eamxx/src/physics/mam/eamxx_mam_dry_deposition_process_interface.cpp
index 45d1c1d64b..4f4c9e50a4 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_dry_deposition_process_interface.cpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_dry_deposition_process_interface.cpp
@@ -10,7 +10,8 @@ namespace scream {
 
 using FracLandUseFunc = frac_landuse::fracLandUseFunctions<Real, DefaultDevice>;
 
-MAMDryDep::MAMDryDep(const ekat::Comm &comm, const ekat::ParameterList &params) : MAMGenericInterface(comm, params) {
+MAMDryDep::MAMDryDep(const ekat::Comm &comm, const ekat::ParameterList &params)
+    : MAMGenericInterface(comm, params) {
   /* Anything that can be initialized without grid information can be
    * initialized here. Like universal constants, mam wetscav options.
    */
@@ -134,9 +135,11 @@ void MAMDryDep::set_grids(const std::shared_ptr<const GridsManager> grids_manage
   // -------------------------------------------------------------
   // FIXME: These are diagnostics, remove them from FM after initial evaluation
   // surface deposition flux of cloud-borne  aerosols, [kg/m2/s] or [1/m2/s]
-  add_field<Computed>("deposition_flux_of_cloud_borne_aerosols", vector2d_pcnst, 1 / m2 / s, grid_name);
+  add_field<Computed>("deposition_flux_of_cloud_borne_aerosols", vector2d_pcnst, 1 / m2 / s,
+                      grid_name);
   // surface deposition flux of interstitial aerosols, [kg/m2/s] or [1/m2/s]
-  add_field<Computed>("deposition_flux_of_interstitial_aerosols", vector2d_pcnst, 1 / m2 / s, grid_name);
+  add_field<Computed>("deposition_flux_of_interstitial_aerosols", vector2d_pcnst, 1 / m2 / s,
+                      grid_name);
 
   // Fractional land use [fraction]
   add_field<Computed>("fraction_landuse", vector2d_class, nondim, grid_name);
@@ -155,8 +158,9 @@ void MAMDryDep::set_grids(const std::shared_ptr<const GridsManager> grids_manage
   const std::string dim_name2 = "class";
 
   // initialize the file read
-  FracLandUseFunc::init_frac_landuse_file_read(ncol_, field_name, dim_name1, dim_name2, grid_, frac_landuse_data_file,
-                                               mapping_file, horizInterp_, dataReader_); // output
+  FracLandUseFunc::init_frac_landuse_file_read(ncol_, field_name, dim_name1, dim_name2, grid_,
+                                               frac_landuse_data_file, mapping_file, horizInterp_,
+                                               dataReader_); // output
 
 } // set_grids
 
@@ -244,8 +248,9 @@ void MAMDryDep::init_temporary_views() {
   const int workspace_used     = work_ptr - buffer_.temporary_views.data();
   const int workspace_provided = buffer_.temporary_views.extent(0);
   EKAT_REQUIRE_MSG(workspace_used == workspace_provided,
-                   "Error: workspace_used (" + std::to_string(workspace_used) + ") and workspace_provided (" +
-                       std::to_string(workspace_provided) + ") should be equal. \n");
+                   "Error: workspace_used (" + std::to_string(workspace_used) +
+                       ") and workspace_provided (" + std::to_string(workspace_provided) +
+                       ") should be equal. \n");
 }
 
 // ================================================================
@@ -314,7 +319,8 @@ void MAMDryDep::initialize_impl(const RunType run_type) {
 
 // =========================================================================================
 void MAMDryDep::run_impl(const double dt) {
-  const auto scan_policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
+  const auto scan_policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
 
   // preprocess input -- needs a scan for the calculation of atm height
   pre_process(wet_aero_, dry_aero_, wet_atm_, dry_atm_);
@@ -354,9 +360,9 @@ void MAMDryDep::run_impl(const double dt) {
   //--------------------------------------------------------------------
   // Call drydeposition and get tendencies
   //--------------------------------------------------------------------
-  compute_tendencies(ncol_, nlev_, dt, obukhov_length_, surface_friction_velocty_, land_fraction_, ice_fraction_,
-                     ocean_fraction_, friction_velocity_, aerodynamical_resistance_, frac_landuse_, dgncur_awet_,
-                     wet_dens_, dry_atm_, dry_aero_,
+  compute_tendencies(ncol_, nlev_, dt, obukhov_length_, surface_friction_velocty_, land_fraction_,
+                     ice_fraction_, ocean_fraction_, friction_velocity_, aerodynamical_resistance_,
+                     frac_landuse_, dgncur_awet_, wet_dens_, dry_atm_, dry_aero_,
                      // Inouts-outputs
                      qqcw_,
                      // Outputs
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_generic_process_interface.cpp w/components/eamxx/src/physics/mam/eamxx_mam_generic_process_interface.cpp
index a7067ade12..6553b7aff2 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_generic_process_interface.cpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_generic_process_interface.cpp
@@ -45,7 +45,8 @@ void MAMGenericInterface::set_aerosol_and_gas_ranges() {
     limits_aerosol_gas_tracers_[gas_mmr_field_name] = mam_coupling::physical_min_max(mmr_label);
   } // end for loop num gases
 }
-void MAMGenericInterface::set_ranges_process(const std::map<std::string, std::pair<Real, Real>> &max_min_process) {
+void MAMGenericInterface::set_ranges_process(
+    const std::map<std::string, std::pair<Real, Real>> &max_min_process) {
   // NOTE: We are using the same range (mmr) for all aerosols and gases.
   // And aerosol numbers (nmr).
   // set ranges for aerosol and gases
@@ -57,7 +58,8 @@ void MAMGenericInterface::set_ranges_process(const std::map<std::string, std::pa
   set_ranges_ = true;
 }
 const std::pair<Real, Real> MAMGenericInterface::get_ranges(const std::string &field_name) {
-  EKAT_ASSERT_MSG(set_ranges_, "Error: min_max ranges are not set. Please invoke set_ranges_process.");
+  EKAT_ASSERT_MSG(set_ranges_,
+                  "Error: min_max ranges are not set. Please invoke set_ranges_process.");
 
   std::pair<Real, Real> min_max;
   // We obtain the minimum and maximum values for aerosol and gas species.
@@ -192,7 +194,8 @@ void MAMGenericInterface::populate_cloudborne_dry_aero(mam_coupling::AerosolStat
   }
 }
 // ================================================================
-void MAMGenericInterface::set_field_w_scratch_buffer(mam_coupling::view_2d &var, mam_coupling::Buffer &buffer,
+void MAMGenericInterface::set_field_w_scratch_buffer(mam_coupling::view_2d &var,
+                                                     mam_coupling::Buffer &buffer,
                                                      const bool set_to_zero) {
   var = buffer.scratch[i_scratch_vars_];
   i_scratch_vars_++;
@@ -208,7 +211,8 @@ void MAMGenericInterface::set_field_w_scratch_buffer(mam_coupling::view_2d &var,
   }
 }
 // ================================================================
-void MAMGenericInterface::populate_gases_dry_aero(mam_coupling::AerosolState &dry_aero, mam_coupling::Buffer &buffer) {
+void MAMGenericInterface::populate_gases_dry_aero(mam_coupling::AerosolState &dry_aero,
+                                                  mam_coupling::Buffer &buffer) {
   for (int g = 0; g < mam_coupling::num_aero_gases(); ++g) {
     dry_aero.gas_mmr[g] = buffer.dry_gas_mmr[g];
   }
@@ -274,7 +278,8 @@ void MAMGenericInterface::populate_wet_atm(mam_coupling::WetAtmosphere &wet_atm)
   wet_atm.qi = get_field_in("qi").get_view<const Real **>();
   wet_atm.ni = get_field_in("ni").get_view<const Real **>();
 }
-void MAMGenericInterface::populate_dry_atm(mam_coupling::DryAtmosphere &dry_atm, mam_coupling::Buffer &buffer) {
+void MAMGenericInterface::populate_dry_atm(mam_coupling::DryAtmosphere &dry_atm,
+                                           mam_coupling::Buffer &buffer) {
   // store rest fo the atm fields in dry_atm_in
   dry_atm.z_surf = 0;
   dry_atm.T_mid  = get_field_in("T_mid").get_view<const Real **>();
@@ -392,14 +397,18 @@ void MAMGenericInterface::add_interval_checks() {
       // physical_limits.hpp. Some variables from get_fields_out may not be part
       // of physical_min_max.
       if (min_value != -1 && max_value != -1)
-        add_postcondition_check<FieldWithinIntervalCheck>(field, grid_, min_value, max_value, false);
+        add_postcondition_check<FieldWithinIntervalCheck>(field, grid_, min_value, max_value,
+                                                          false);
     }
   }
 }
 
-void MAMGenericInterface::pre_process(mam_coupling::AerosolState &wet_aero, mam_coupling::AerosolState &dry_aero,
-                                      mam_coupling::WetAtmosphere &wet_atm, mam_coupling::DryAtmosphere &dry_atm) {
-  const auto scan_policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
+void MAMGenericInterface::pre_process(mam_coupling::AerosolState &wet_aero,
+                                      mam_coupling::AerosolState &dry_aero,
+                                      mam_coupling::WetAtmosphere &wet_atm,
+                                      mam_coupling::DryAtmosphere &dry_atm) {
+  const auto scan_policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
   Kokkos::parallel_for(
       scan_policy, KOKKOS_LAMBDA(const ThreadTeam &team) {
         const int i = team.league_rank(); // column index
@@ -416,9 +425,11 @@ void MAMGenericInterface::pre_process(mam_coupling::AerosolState &wet_aero, mam_
       });
 }
 
-void MAMGenericInterface::post_process(mam_coupling::AerosolState &wet_aero, mam_coupling::AerosolState &dry_aero,
+void MAMGenericInterface::post_process(mam_coupling::AerosolState &wet_aero,
+                                       mam_coupling::AerosolState &dry_aero,
                                        mam_coupling::DryAtmosphere &dry_atm) {
-  const auto scan_policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
+  const auto scan_policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
   Kokkos::parallel_for(
       scan_policy, KOKKOS_LAMBDA(const ThreadTeam &team) {
         const int i = team.league_rank(); // column index
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_generic_process_interface.hpp w/components/eamxx/src/physics/mam/eamxx_mam_generic_process_interface.hpp
index 3031135bbb..f35692e53e 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_generic_process_interface.hpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_generic_process_interface.hpp
@@ -32,11 +32,13 @@ protected:
   void add_interval_checks();
   // Populate the wet_aero and dry_aero structs.
   void populate_interstitial_wet_aero(mam_coupling::AerosolState &wet_aero);
-  void populate_interstitial_dry_aero(mam_coupling::AerosolState &dry_aero, mam_coupling::Buffer &buffer);
+  void populate_interstitial_dry_aero(mam_coupling::AerosolState &dry_aero,
+                                      mam_coupling::Buffer &buffer);
   void populate_gases_dry_aero(mam_coupling::AerosolState &dry_aero, mam_coupling::Buffer &buffer);
   void populate_gases_wet_aero(mam_coupling::AerosolState &wet_aero);
   void populate_cloudborne_wet_aero(mam_coupling::AerosolState &wet_aero);
-  void populate_cloudborne_dry_aero(mam_coupling::AerosolState &dry_aero, mam_coupling::Buffer &buffer);
+  void populate_cloudborne_dry_aero(mam_coupling::AerosolState &dry_aero,
+                                    mam_coupling::Buffer &buffer);
 
   // Populate the wet_atm and dry_atm struct.
   void populate_dry_atm(mam_coupling::DryAtmosphere &dry_atm, mam_coupling::Buffer &buffer);
@@ -56,7 +58,8 @@ protected:
   void post_process(mam_coupling::AerosolState &wet_aero, mam_coupling::AerosolState &dry_aero,
                     mam_coupling::DryAtmosphere &dry_atm);
   // Physics grid for column information.
-  void set_field_w_scratch_buffer(mam_coupling::view_2d &var, mam_coupling::Buffer &buffer, const bool set_to_zero);
+  void set_field_w_scratch_buffer(mam_coupling::view_2d &var, mam_coupling::Buffer &buffer,
+                                  const bool set_to_zero);
   std::shared_ptr<const AbstractGrid> grid_;
   bool check_fields_intervals_{false};
   // number of horizontal columns and vertical levels
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_microphysics_process_interface.cpp w/components/eamxx/src/physics/mam/eamxx_mam_microphysics_process_interface.cpp
index 198511da3d..6edb7d5151 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_microphysics_process_interface.cpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_microphysics_process_interface.cpp
@@ -123,7 +123,8 @@ void MAMMicrophysics::set_grids(const std::shared_ptr<const GridsManager> grids_
   constexpr int nmodes = mam4::AeroConfig::num_modes();
 
   // layout for 3D (ncol, nmodes, nlevs)
-  FieldLayout scalar3d_mid_nmodes = grid_->get_3d_vector_layout(true, nmodes, mam_coupling::num_modes_tag_name());
+  FieldLayout scalar3d_mid_nmodes =
+      grid_->get_3d_vector_layout(true, nmodes, mam_coupling::num_modes_tag_name());
 
   // Geometric mean dry diameter for number distribution [m]
   add_field<Required>("dgnum", scalar3d_mid_nmodes, m, grid_name);
@@ -135,7 +136,8 @@ void MAMMicrophysics::set_grids(const std::shared_ptr<const GridsManager> grids_
   add_field<Required>("wetdens", scalar3d_mid_nmodes, kg / m3, grid_name);
 
   // For fractional land use
-  const FieldLayout vector2d_class = grid_->get_2d_vector_layout(mam4::mo_drydep::n_land_type, "class");
+  const FieldLayout vector2d_class =
+      grid_->get_2d_vector_layout(mam4::mo_drydep::n_land_type, "class");
 
   // Fractional land use [fraction]
   add_field<Required>("fraction_landuse", vector2d_class, nondim, grid_name);
@@ -178,21 +180,25 @@ void MAMMicrophysics::set_grids(const std::shared_ptr<const GridsManager> grids_
   {
     linoz_file_name_                 = m_params.get<std::string>("mam4_linoz_file_name");
     const std::string linoz_map_file = m_params.get<std::string>("aero_microphys_remap_file", "");
-    const std::vector<std::string> var_names{"o3_clim",  "o3col_clim", "t_clim",      "PmL_clim",
-                                             "dPmL_dO3", "dPmL_dT",    "dPmL_dO3col", "cariolle_pscs"};
+    const std::vector<std::string> var_names{"o3_clim",     "o3col_clim",   "t_clim",
+                                             "PmL_clim",    "dPmL_dO3",     "dPmL_dT",
+                                             "dPmL_dO3col", "cariolle_pscs"};
 
     // in format YYYYMMDD
     const int linoz_cyclical_ymd = m_params.get<int>("mam4_linoz_ymd");
     scream::mam_coupling::setup_tracer_data(linoz_data_, linoz_file_name_, linoz_cyclical_ymd);
-    LinozHorizInterp_ =
-        scream::mam_coupling::create_horiz_remapper(grid_, linoz_file_name_, linoz_map_file, var_names, linoz_data_);
-    LinozDataReader_ = scream::mam_coupling::create_tracer_data_reader(LinozHorizInterp_, linoz_file_name_);
+    LinozHorizInterp_ = scream::mam_coupling::create_horiz_remapper(
+        grid_, linoz_file_name_, linoz_map_file, var_names, linoz_data_);
+    LinozDataReader_ =
+        scream::mam_coupling::create_tracer_data_reader(LinozHorizInterp_, linoz_file_name_);
 
     // linoz reader
-    const auto io_grid_linoz    = LinozHorizInterp_->get_tgt_grid();
-    const int num_cols_io_linoz = io_grid_linoz->get_num_local_dofs();      // Number of columns on this rank
-    const int num_levs_io_linoz = io_grid_linoz->get_num_vertical_levels(); // Number of levels per column
-    const int nvars             = int(var_names.size());
+    const auto io_grid_linoz = LinozHorizInterp_->get_tgt_grid();
+    const int num_cols_io_linoz =
+        io_grid_linoz->get_num_local_dofs(); // Number of columns on this rank
+    const int num_levs_io_linoz =
+        io_grid_linoz->get_num_vertical_levels(); // Number of levels per column
+    const int nvars = int(var_names.size());
     linoz_data_.init(num_cols_io_linoz, num_levs_io_linoz, nvars);
     linoz_data_.allocate_temporary_views();
   } // LINOZ reader
@@ -206,9 +212,10 @@ void MAMMicrophysics::set_grids(const std::shared_ptr<const GridsManager> grids_
     // in format YYYYMMDD
     const int oxid_ymd = m_params.get<int>("mam4_oxid_ymd");
     scream::mam_coupling::setup_tracer_data(tracer_data_, oxid_file_name_, oxid_ymd);
-    TracerHorizInterp_ =
-        scream::mam_coupling::create_horiz_remapper(grid_, oxid_file_name_, oxid_map_file, var_names, tracer_data_);
-    TracerDataReader_ = scream::mam_coupling::create_tracer_data_reader(TracerHorizInterp_, oxid_file_name_);
+    TracerHorizInterp_ = scream::mam_coupling::create_horiz_remapper(
+        grid_, oxid_file_name_, oxid_map_file, var_names, tracer_data_);
+    TracerDataReader_ =
+        scream::mam_coupling::create_tracer_data_reader(TracerHorizInterp_, oxid_file_name_);
 
     const int nvars       = int(var_names.size());
     const auto io_grid    = TracerHorizInterp_->get_tgt_grid();
@@ -229,7 +236,8 @@ void MAMMicrophysics::set_grids(const std::shared_ptr<const GridsManager> grids_
     // ','pom_a4          ','bc_a4           ', 'num_a1          ','num_a2
     // ','num_a4          ','SOAG            ' }
     // This order corresponds to files in namelist e3smv2
-    extfrc_lst_ = {"so2", "so4_a1", "so4_a2", "pom_a4", "bc_a4", "num_a1", "num_a2", "num_a4", "soag"};
+    extfrc_lst_ = {"so2",    "so4_a1", "so4_a2", "pom_a4", "bc_a4",
+                   "num_a1", "num_a2", "num_a4", "soag"};
 
     for (const auto &var_name : extfrc_lst_) {
       std::string item_name              = "mam4_" + var_name + "_elevated_emiss_file_name";
@@ -241,8 +249,8 @@ void MAMMicrophysics::set_grids(const std::shared_ptr<const GridsManager> grids_
     elevated_emis_var_names_["so4_a2"] = {"contvolc"};
     elevated_emis_var_names_["pom_a4"] = {"BB"};
     elevated_emis_var_names_["bc_a4"]  = {"BB"};
-    elevated_emis_var_names_["num_a1"] = {"num_a1_SO4_ELEV_BB", "num_a1_SO4_ELEV_ENE", "num_a1_SO4_ELEV_IND",
-                                          "num_a1_SO4_ELEV_contvolc"};
+    elevated_emis_var_names_["num_a1"] = {"num_a1_SO4_ELEV_BB", "num_a1_SO4_ELEV_ENE",
+                                          "num_a1_SO4_ELEV_IND", "num_a1_SO4_ELEV_contvolc"};
     elevated_emis_var_names_["num_a2"] = {"num_a2_SO4_ELEV_contvolc"};
     // num_a4
     // FIXME: why the sectors in this files are num_a1;
@@ -258,10 +266,11 @@ void MAMMicrophysics::set_grids(const std::shared_ptr<const GridsManager> grids_
 
       scream::mam_coupling::TracerData data_tracer;
       scream::mam_coupling::setup_tracer_data(data_tracer, file_name, elevated_emiss_cyclical_ymd);
-      auto hor_rem =
-          scream::mam_coupling::create_horiz_remapper(grid_, file_name, extfrc_map_file, var_names, data_tracer);
+      auto hor_rem = scream::mam_coupling::create_horiz_remapper(grid_, file_name, extfrc_map_file,
+                                                                 var_names, data_tracer);
 
-      auto file_reader = scream::mam_coupling::create_tracer_data_reader(hor_rem, file_name, data_tracer.file_type);
+      auto file_reader = scream::mam_coupling::create_tracer_data_reader(hor_rem, file_name,
+                                                                         data_tracer.file_type);
       ElevatedEmissionsHorizInterp_.push_back(hor_rem);
       ElevatedEmissionsDataReader_.push_back(file_reader);
       elevated_emis_data_.push_back(data_tracer);
@@ -276,16 +285,19 @@ void MAMMicrophysics::set_grids(const std::shared_ptr<const GridsManager> grids_
       forcings_[i].nsectors = nvars;
       // I am assuming the order of species in extfrc_lst_.
       // Indexing in mam4xx is fortran.
-      forcings_[i].frc_ndx       = i + 1;
-      const auto io_grid_emis    = ElevatedEmissionsHorizInterp_[i]->get_tgt_grid();
-      const int num_cols_io_emis = io_grid_emis->get_num_local_dofs();      // Number of columns on this rank
-      const int num_levs_io_emis = io_grid_emis->get_num_vertical_levels(); // Number of levels per column
+      forcings_[i].frc_ndx    = i + 1;
+      const auto io_grid_emis = ElevatedEmissionsHorizInterp_[i]->get_tgt_grid();
+      const int num_cols_io_emis =
+          io_grid_emis->get_num_local_dofs(); // Number of columns on this rank
+      const int num_levs_io_emis =
+          io_grid_emis->get_num_vertical_levels(); // Number of levels per column
       elevated_emis_data_[i].init(num_cols_io_emis, num_levs_io_emis, nvars);
       elevated_emis_data_[i].allocate_temporary_views();
       forcings_[i].file_alt_data = elevated_emis_data_[i].has_altitude_;
       for (int isp = 0; isp < nvars; ++isp) {
-        forcings_[i].offset                          = offset_emis_ver;
-        elevated_emis_output_[isp + offset_emis_ver] = view_2d("elevated_emis_output_", ncol_, nlev_);
+        forcings_[i].offset = offset_emis_ver;
+        elevated_emis_output_[isp + offset_emis_ver] =
+            view_2d("elevated_emis_output_", ncol_, nlev_);
       }
       offset_emis_ver += nvars;
       ++i;
@@ -373,8 +385,9 @@ void MAMMicrophysics::init_temporary_views() {
   const int workspace_used     = work_ptr - buffer_.temporary_views.data();
   const int workspace_provided = buffer_.temporary_views.extent(0);
   EKAT_REQUIRE_MSG(workspace_used == workspace_provided,
-                   "Error: workspace_used (" + std::to_string(workspace_used) + ") and workspace_provided (" +
-                       std::to_string(workspace_provided) + ") should be equal. \n");
+                   "Error: workspace_used (" + std::to_string(workspace_used) +
+                       ") and workspace_provided (" + std::to_string(workspace_provided) +
+                       ") should be equal. \n");
 }
 // ================================================================
 //  INITIALIZE_IMPL
@@ -448,22 +461,22 @@ void MAMMicrophysics::initialize_impl(const RunType run_type) {
 
   {
     // climatology data for linear stratospheric chemistry
-    auto linoz_o3_clim    = buffer_.scratch[0];    // ozone (climatology) [vmr]
-    auto linoz_o3col_clim = buffer_.scratch[1];    // column o3 above box (climatology) [Dobson Units
-                                                   // (DU)]
-    auto linoz_t_clim      = buffer_.scratch[2];   // temperature (climatology) [K]
-    auto linoz_PmL_clim    = buffer_.scratch[3];   // P minus L (climatology) [vmr/s]
-    auto linoz_dPmL_dO3    = buffer_.scratch[4];   // sensitivity of P minus L to O3 [1/s]
-    auto linoz_dPmL_dT     = buffer_.scratch[5];   // sensitivity of P minus L to T3 [K]
-    auto linoz_dPmL_dO3col = buffer_.scratch[6];   // sensitivity of P minus L to
-                                                   // overhead O3 column [vmr/DU]
+    auto linoz_o3_clim    = buffer_.scratch[0];  // ozone (climatology) [vmr]
+    auto linoz_o3col_clim = buffer_.scratch[1];  // column o3 above box (climatology) [Dobson Units
+                                                 // (DU)]
+    auto linoz_t_clim      = buffer_.scratch[2]; // temperature (climatology) [K]
+    auto linoz_PmL_clim    = buffer_.scratch[3]; // P minus L (climatology) [vmr/s]
+    auto linoz_dPmL_dO3    = buffer_.scratch[4]; // sensitivity of P minus L to O3 [1/s]
+    auto linoz_dPmL_dT     = buffer_.scratch[5]; // sensitivity of P minus L to T3 [K]
+    auto linoz_dPmL_dO3col = buffer_.scratch[6]; // sensitivity of P minus L to
+                                                 // overhead O3 column [vmr/DU]
     auto linoz_cariolle_pscs = buffer_.scratch[7]; // Cariolle parameter for PSC loss of ozone [1/s]
 
     auto ts                         = start_of_step_ts();
     std::string linoz_chlorine_file = m_params.get<std::string>("mam4_linoz_chlorine_file");
     int chlorine_loading_ymd        = m_params.get<int>("mam4_chlorine_loading_ymd");
-    scream::mam_coupling::create_linoz_chlorine_reader(linoz_chlorine_file, ts, chlorine_loading_ymd, chlorine_values_,
-                                                       chlorine_time_secs_);
+    scream::mam_coupling::create_linoz_chlorine_reader(
+        linoz_chlorine_file, ts, chlorine_loading_ymd, chlorine_values_, chlorine_time_secs_);
   } // LINOZ
 
   init_temporary_views();
@@ -474,13 +487,16 @@ void MAMMicrophysics::initialize_impl(const RunType run_type) {
   //       and extfrc_lst_end will be reloaded from file with the new month.
   const int curr_month = start_of_step_ts().get_month() - 1; // 0-based
 
-  scream::mam_coupling::update_tracer_data_from_file(LinozDataReader_, curr_month, *LinozHorizInterp_, linoz_data_);
+  scream::mam_coupling::update_tracer_data_from_file(LinozDataReader_, curr_month,
+                                                     *LinozHorizInterp_, linoz_data_);
 
-  scream::mam_coupling::update_tracer_data_from_file(TracerDataReader_, curr_month, *TracerHorizInterp_, tracer_data_);
+  scream::mam_coupling::update_tracer_data_from_file(TracerDataReader_, curr_month,
+                                                     *TracerHorizInterp_, tracer_data_);
 
   for (int i = 0; i < static_cast<int>(extfrc_lst_.size()); ++i) {
     scream::mam_coupling::update_tracer_data_from_file(ElevatedEmissionsDataReader_[i], curr_month,
-                                                       *ElevatedEmissionsHorizInterp_[i], elevated_emis_data_[i]);
+                                                       *ElevatedEmissionsHorizInterp_[i],
+                                                       elevated_emis_data_[i]);
   }
   // //
   acos_cosine_zenith_host_ = view_1d_host("host_acos(cosine_zenith)", ncol_);
@@ -513,16 +529,20 @@ void MAMMicrophysics::run_impl(const double dt) {
   const auto wetdens                       = get_field_in("wetdens").get_view<const Real ***>();
 
   // U wind component [m/s]
-  const const_view_2d u_wind = get_field_in("horiz_winds").get_component(0).get_view<const Real **>();
+  const const_view_2d u_wind =
+      get_field_in("horiz_winds").get_component(0).get_view<const Real **>();
 
   // V wind component [m/s]
-  const const_view_2d v_wind = get_field_in("horiz_winds").get_component(1).get_view<const Real **>();
+  const const_view_2d v_wind =
+      get_field_in("horiz_winds").get_component(1).get_view<const Real **>();
 
   // Liquid precip [kg/m2]
-  const const_view_1d precip_liq_surf_mass = get_field_in("precip_liq_surf_mass").get_view<const Real *>();
+  const const_view_1d precip_liq_surf_mass =
+      get_field_in("precip_liq_surf_mass").get_view<const Real *>();
 
   // Ice precip [kg/m2]
-  const const_view_1d precip_ice_surf_mass = get_field_in("precip_ice_surf_mass").get_view<const Real *>();
+  const const_view_1d precip_ice_surf_mass =
+      get_field_in("precip_ice_surf_mass").get_view<const Real *>();
 
   // Fractional land use [fraction]
   const const_view_2d fraction_landuse = get_field_in("fraction_landuse").get_view<const Real **>();
@@ -605,9 +625,10 @@ void MAMMicrophysics::run_impl(const double dt) {
     for (int isp = 0; isp < nsectors; ++isp) {
       elevated_emis_output[isp] = elevated_emis_output_[isp + forcings_[i].offset];
     }
-    scream::mam_coupling::advance_tracer_data(ElevatedEmissionsDataReader_[i], *ElevatedEmissionsHorizInterp_[i], ts,
-                                              elevated_emiss_time_state_, elevated_emis_data_[i], dry_atm_.p_mid,
-                                              dry_atm_.z_iface, elevated_emis_output);
+    scream::mam_coupling::advance_tracer_data(
+        ElevatedEmissionsDataReader_[i], *ElevatedEmissionsHorizInterp_[i], ts,
+        elevated_emiss_time_state_, elevated_emis_data_[i], dry_atm_.p_mid, dry_atm_.z_iface,
+        elevated_emis_output);
     i++;
     Kokkos::fence();
   }
@@ -815,23 +836,26 @@ void MAMMicrophysics::run_impl(const double dt) {
         // Input/Output: progs::stateq, progs::qqcw
         team.team_barrier();
         mam4::microphysics::perform_atmospheric_chemistry_and_microphysics(
-            team, dt, rlats, sfc_temperature(icol), sfc_pressure(icol), wind_speed, rain, solar_flux, cnst_offline_icol,
-            forcings_in, atm, photo_table, chlorine_loading, config.setsox, config.amicphys, config.linoz.psc_T,
-            zenith_angle(icol), d_sfc_alb_dir_vis(icol), o3_col_dens_i, photo_rates_icol, extfrc_icol, invariants_icol,
-            work_photo_table_icol, linoz_o3_clim_icol, linoz_t_clim_icol, linoz_o3col_clim_icol, linoz_PmL_clim_icol,
-            linoz_dPmL_dO3_icol, linoz_dPmL_dT_icol, linoz_dPmL_dO3col_icol, linoz_cariolle_pscs_icol, eccf,
-            adv_mass_kg_per_moles, fraction_landuse_icol, index_season, clsmap_4, permute_4, offset_aerosol,
-            config.linoz.o3_sfc, config.linoz.o3_tau, config.linoz.o3_lbl, dry_diameter_icol, wet_diameter_icol,
-            wetdens_icol, dry_atm.phis(icol), cmfdqr, prain_icol, nevapr_icol, work_set_het_icol, drydep_data, dvel_col,
-            dflx_col, progs);
+            team, dt, rlats, sfc_temperature(icol), sfc_pressure(icol), wind_speed, rain,
+            solar_flux, cnst_offline_icol, forcings_in, atm, photo_table, chlorine_loading,
+            config.setsox, config.amicphys, config.linoz.psc_T, zenith_angle(icol),
+            d_sfc_alb_dir_vis(icol), o3_col_dens_i, photo_rates_icol, extfrc_icol, invariants_icol,
+            work_photo_table_icol, linoz_o3_clim_icol, linoz_t_clim_icol, linoz_o3col_clim_icol,
+            linoz_PmL_clim_icol, linoz_dPmL_dO3_icol, linoz_dPmL_dT_icol, linoz_dPmL_dO3col_icol,
+            linoz_cariolle_pscs_icol, eccf, adv_mass_kg_per_moles, fraction_landuse_icol,
+            index_season, clsmap_4, permute_4, offset_aerosol, config.linoz.o3_sfc,
+            config.linoz.o3_tau, config.linoz.o3_lbl, dry_diameter_icol, wet_diameter_icol,
+            wetdens_icol, dry_atm.phis(icol), cmfdqr, prain_icol, nevapr_icol, work_set_het_icol,
+            drydep_data, dvel_col, dflx_col, progs);
 
         team.team_barrier();
         // Update constituent fluxes with gas drydep fluxes (dflx)
         // FIXME: Possible units mismatch (dflx is in kg/cm2/s but
         // constituent_fluxes is kg/m2/s) (Following mimics Fortran code
         // behavior but we should look into it)
-        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, offset_aerosol, pcnst),
-                             [&](int ispc) { constituent_fluxes(icol, ispc) -= dflx_col[ispc - offset_aerosol]; });
+        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, offset_aerosol, pcnst), [&](int ispc) {
+          constituent_fluxes(icol, ispc) -= dflx_col[ispc - offset_aerosol];
+        });
       }); // parallel_for for the column loop
   Kokkos::fence();
 
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_optics_process_interface.cpp w/components/eamxx/src/physics/mam/eamxx_mam_optics_process_interface.cpp
index 086c43d57f..c34ede78c4 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_optics_process_interface.cpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_optics_process_interface.cpp
@@ -128,8 +128,9 @@ void MAMOptics::init_temporary_views() {
   const int workspace_used     = work_ptr - buffer_.temporary_views.data();
   const int workspace_provided = buffer_.temporary_views.extent(0);
   EKAT_REQUIRE_MSG(workspace_used == workspace_provided,
-                   "Error: workspace_used (" + std::to_string(workspace_used) + ") and workspace_provided (" +
-                       std::to_string(workspace_provided) + ") should be equal. \n");
+                   "Error: workspace_used (" + std::to_string(workspace_used) +
+                       ") and workspace_provided (" + std::to_string(workspace_provided) +
+                       ") should be equal. \n");
 }
 
 void MAMOptics::init_buffers(const ATMBufferManager &buffer_manager) {
@@ -202,8 +203,10 @@ void MAMOptics::initialize_impl(const RunType run_type) {
 
     // Note: these functions do not set values for aerosol_optics_device_data_.
     mam4::modal_aer_opt::set_complex_views_modal_aero(aerosol_optics_device_data_);
-    mam4::modal_aer_opt::set_aerosol_optics_data_for_modal_aero_sw_views(aerosol_optics_device_data_);
-    mam4::modal_aer_opt::set_aerosol_optics_data_for_modal_aero_lw_views(aerosol_optics_device_data_);
+    mam4::modal_aer_opt::set_aerosol_optics_data_for_modal_aero_sw_views(
+        aerosol_optics_device_data_);
+    mam4::modal_aer_opt::set_aerosol_optics_data_for_modal_aero_lw_views(
+        aerosol_optics_device_data_);
 
     mam_coupling::AerosolOpticsHostData aerosol_optics_host_data;
 
@@ -218,8 +221,8 @@ void MAMOptics::initialize_impl(const RunType run_type) {
       const auto &fname = m_params.get<std::string>(key);
       mam_coupling::read_rrtmg_table(fname,
                                      imode, // mode No
-                                     rrtmg_params, grid_, host_views, layouts, aerosol_optics_host_data,
-                                     aerosol_optics_device_data_);
+                                     rrtmg_params, grid_, host_views, layouts,
+                                     aerosol_optics_host_data, aerosol_optics_device_data_);
     }
 
     std::string table_name_water = m_params.get<std::string>("mam4_water_refindex_file");
@@ -266,15 +269,16 @@ void MAMOptics::initialize_impl(const RunType run_type) {
         refindex_aerosol.read_variables();
         refindex_aerosol.finalize();
         // copy data to device
-        mam_coupling::set_refindex_aerosol(species_id, host_views_aero,
-                                           specrefndxsw_host, // complex refractive index for water visible
-                                           specrefndxlw_host);
+        mam_coupling::set_refindex_aerosol(
+            species_id, host_views_aero,
+            specrefndxsw_host, // complex refractive index for water visible
+            specrefndxlw_host);
       } // done ispec
       // reshape specrefndxsw_host and copy it to device
-      mam4::modal_aer_opt::set_device_specrefindex(aerosol_optics_device_data_.specrefindex_sw, "short_wave",
-                                                   specrefndxsw_host);
-      mam4::modal_aer_opt::set_device_specrefindex(aerosol_optics_device_data_.specrefindex_lw, "long_wave",
-                                                   specrefndxlw_host);
+      mam4::modal_aer_opt::set_device_specrefindex(aerosol_optics_device_data_.specrefindex_sw,
+                                                   "short_wave", specrefndxsw_host);
+      mam4::modal_aer_opt::set_device_specrefindex(aerosol_optics_device_data_.specrefindex_lw,
+                                                   "long_wave", specrefndxlw_host);
     }
   }
   // FIXME: We are hard-coding the band ordering in RRTMGP.
@@ -286,9 +290,11 @@ void MAMOptics::initialize_impl(const RunType run_type) {
   // rrtmgp_swband (new) = 1710, 2925, 3625, 4325, 4900, 5650, 6925, 7875,
   // 10450, 14425, 19325, 25825, 33500, 44000 ; given the rrtmg index return the
   // rrtmgp index
-  std::vector<int> temporal                   = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0};
-  auto get_idx_rrtmgp_from_rrtmg_swbands_host = mam_coupling::view_int_1d::HostMirror(temporal.data(), nswbands_);
-  get_idx_rrtmgp_from_rrtmg_swbands_          = mam_coupling::view_int_1d("rrtmg_to_rrtmgp_swbands", nswbands_);
+  std::vector<int> temporal = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0};
+  auto get_idx_rrtmgp_from_rrtmg_swbands_host =
+      mam_coupling::view_int_1d::HostMirror(temporal.data(), nswbands_);
+  get_idx_rrtmgp_from_rrtmg_swbands_ =
+      mam_coupling::view_int_1d("rrtmg_to_rrtmgp_swbands", nswbands_);
   Kokkos::deep_copy(get_idx_rrtmgp_from_rrtmg_swbands_, get_idx_rrtmgp_from_rrtmg_swbands_host);
   calsize_data_.initialize();
 }
@@ -296,8 +302,9 @@ void MAMOptics::run_impl(const double dt) {
   constexpr Real zero = 0.0;
   constexpr Real one  = 1.0;
 
-  const auto policy      = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(ncol_, nlev_);
-  const auto scan_policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
+  const auto policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(ncol_, nlev_);
+  const auto scan_policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
 
   // preprocess input -- needs a scan for the calculation of atm height
   pre_process(wet_aero_, dry_aero_, wet_atm_, dry_atm_);
@@ -365,9 +372,10 @@ void MAMOptics::run_impl(const double dt) {
         // fetch column-specific subviews into aerosol prognostics
         mam4::Prognostics progs = mam_coupling::aerosols_for_column(dry_aero, icol);
 
-        mam4::aer_rad_props::aer_rad_props_sw(team, dt, progs, atm, zi, pdel, ssa_cmip6_sw_icol, af_cmip6_sw_icol,
-                                              ext_cmip6_sw_icol, tau_icol, tau_w_icol, tau_w_g_icol, tau_w_f_icol,
-                                              aerosol_optics_device_data, calsize_data, aodvis(icol), work_icol);
+        mam4::aer_rad_props::aer_rad_props_sw(
+            team, dt, progs, atm, zi, pdel, ssa_cmip6_sw_icol, af_cmip6_sw_icol, ext_cmip6_sw_icol,
+            tau_icol, tau_w_icol, tau_w_g_icol, tau_w_f_icol, aerosol_optics_device_data,
+            calsize_data, aodvis(icol), work_icol);
       });
   Kokkos::fence();
   Kokkos::parallel_for(
@@ -386,7 +394,8 @@ void MAMOptics::run_impl(const double dt) {
         mam4::Prognostics progs = mam_coupling::aerosols_for_column(dry_aero, icol);
 
         mam4::aer_rad_props::aer_rad_props_lw(team, dt, progs, atm, zi, pdel, ext_cmip6_lw_icol,
-                                              aerosol_optics_device_data, calsize_data, odap_aer_icol);
+                                              aerosol_optics_device_data, calsize_data,
+                                              odap_aer_icol);
       });
   Kokkos::fence();
   // TODO: We will need to generate optical inputs files with  band ordering
@@ -405,7 +414,8 @@ void MAMOptics::run_impl(const double dt) {
 
   // nswbands loop is using rrtmg indexing.
   Kokkos::parallel_for(
-      "copying data from mam4xx to eamxx", Kokkos::MDRangePolicy<Kokkos::Rank<3>>({0, 0, 0}, {ncol_, nswbands_, nlev_}),
+      "copying data from mam4xx to eamxx",
+      Kokkos::MDRangePolicy<Kokkos::Rank<3>>({0, 0, 0}, {ncol_, nswbands_, nlev_}),
       KOKKOS_LAMBDA(const int icol, const int iswband, const int kk) {
         // Extract single scattering albedo from the product-defined fields
         if (tau_sw(icol, iswband, kk + 1) > zero) {
@@ -422,7 +432,8 @@ void MAMOptics::run_impl(const double dt) {
           aero_g_sw_eamxx(icol, get_idx_rrtmgp_from_rrtmg_swbands(iswband), kk) = zero;
         }
         // Copy cloud optical depth over directly
-        aero_tau_sw_eamxx(icol, get_idx_rrtmgp_from_rrtmg_swbands(iswband), kk) = tau_sw(icol, iswband, kk + 1);
+        aero_tau_sw_eamxx(icol, get_idx_rrtmgp_from_rrtmg_swbands(iswband), kk) =
+            tau_sw(icol, iswband, kk + 1);
       });
   Kokkos::fence();
 }
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_functions.hpp w/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_functions.hpp
index 47420a4826..7ee0abc284 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_functions.hpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_functions.hpp
@@ -18,7 +18,8 @@ void init_fluxes(const int &ncol,
   constexpr int pcnst     = mam4::aero_model::pcnst;
   const int gas_start_ind = mam4::utils::gasses_start_ind();
 
-  const auto policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(ncol, pcnst - gas_start_ind);
+  const auto policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(ncol, pcnst - gas_start_ind);
 
   // Parallel loop over all the columns
   Kokkos::parallel_for(
@@ -34,9 +35,11 @@ void init_fluxes(const int &ncol,
 
 //-------- compute online emissions for dust, sea salt and marine organics -----
 void compute_online_dust_nacl_emiss(const int &ncol, const int &nlev, const const_view_1d &ocnfrac,
-                                    const const_view_1d &sst, const const_view_2d &u_wind, const const_view_2d &v_wind,
-                                    const const_view_2d &dstflx, const const_view_1d &mpoly, const const_view_1d &mprot,
-                                    const const_view_1d &mlip, const const_view_1d &soil_erodibility,
+                                    const const_view_1d &sst, const const_view_2d &u_wind,
+                                    const const_view_2d &v_wind, const const_view_2d &dstflx,
+                                    const const_view_1d &mpoly, const const_view_1d &mprot,
+                                    const const_view_1d &mlip,
+                                    const const_view_1d &soil_erodibility,
                                     const const_view_2d &z_mid,
                                     // output
                                     view_2d &constituent_fluxes) {
@@ -53,11 +56,12 @@ void compute_online_dust_nacl_emiss(const int &ncol, const int &nlev, const cons
         // Compute online emissions
         // NOTE: mam4::aero_model_emissions calculates mass and number emission
         // fluxes in units of [kg/m2/s or #/m2/s] (MKS), so no need to convert
-        mam4::aero_model_emissions::aero_model_emissions(sst(icol), ocnfrac(icol), u_wind(icol, surf_lev),
-                                                         v_wind(icol, surf_lev), z_mid(icol, surf_lev), dstflx_icol,
-                                                         soil_erodibility(icol), mpoly(icol), mprot(icol), mlip(icol),
-                                                         // out
-                                                         fluxes_col);
+        mam4::aero_model_emissions::aero_model_emissions(
+            sst(icol), ocnfrac(icol), u_wind(icol, surf_lev), v_wind(icol, surf_lev),
+            z_mid(icol, surf_lev), dstflx_icol, soil_erodibility(icol), mpoly(icol), mprot(icol),
+            mlip(icol),
+            // out
+            fluxes_col);
       });
 } // compute_online_dust_nacl_emiss ends
 
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_process_interface.cpp w/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_process_interface.cpp
index ecef93328a..6ef3bd93c4 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_process_interface.cpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_process_interface.cpp
@@ -196,10 +196,11 @@ void MAMSrfOnlineEmiss::set_grids(const std::shared_ptr<const GridsManager> grid
   // Init data structures to read and interpolate
   //--------------------------------------------------------------------
   for (srf_emiss_ &ispec_srf : srf_emiss_species_) {
-    srfEmissFunc::init_srf_emiss_objects(ncol_, grid_, ispec_srf.data_file, ispec_srf.sectors, srf_map_file,
-                                         // output
-                                         ispec_srf.horizInterp_, ispec_srf.data_start_, ispec_srf.data_end_,
-                                         ispec_srf.data_out_, ispec_srf.dataReader_);
+    srfEmissFunc::init_srf_emiss_objects(
+        ncol_, grid_, ispec_srf.data_file, ispec_srf.sectors, srf_map_file,
+        // output
+        ispec_srf.horizInterp_, ispec_srf.data_start_, ispec_srf.data_end_, ispec_srf.data_out_,
+        ispec_srf.dataReader_);
   } // srf emissions file read init
 
   // -------------------------------------------------------------
@@ -215,8 +216,9 @@ void MAMSrfOnlineEmiss::set_grids(const std::shared_ptr<const GridsManager> grid
   const std::string soil_erod_dname = "ncol";
 
   // initialize the file read
-  soilErodibilityFunc::init_soil_erodibility_file_read(ncol_, soil_erod_fld_name, soil_erod_dname, grid_,
-                                                       soil_erodibility_data_file, srf_map_file, serod_horizInterp_,
+  soilErodibilityFunc::init_soil_erodibility_file_read(ncol_, soil_erod_fld_name, soil_erod_dname,
+                                                       grid_, soil_erodibility_data_file,
+                                                       srf_map_file, serod_horizInterp_,
                                                        serod_dataReader_); // output
 
   // -------------------------------------------------------------
@@ -270,8 +272,9 @@ void MAMSrfOnlineEmiss::initialize_impl(const RunType run_type) {
   // Check the interval values for the following fields used by this interface.
   // NOTE: We do not include aerosol and gas species, e.g., soa_a1, num_a1,
   // because we automatically added these fields.
-  const std::map<std::string, std::pair<Real, Real>> ranges_emissions = {{"sst", {-1e10, 1e10}}, // FIXME
-                                                                         {"dstflx", {-1e10, 1e10}}};
+  const std::map<std::string, std::pair<Real, Real>> ranges_emissions = {
+      {"sst", {-1e10, 1e10}}, // FIXME
+      {"dstflx", {-1e10, 1e10}}};
   set_ranges_process(ranges_emissions);
   add_interval_checks();
 
@@ -306,8 +309,8 @@ void MAMSrfOnlineEmiss::initialize_impl(const RunType run_type) {
   // Update surface emissions from file
   //--------------------------------------------------------------------
   for (srf_emiss_ &ispec_srf : srf_emiss_species_) {
-    srfEmissFunc::update_srfEmiss_data_from_file(ispec_srf.dataReader_, start_of_step_ts(), curr_month,
-                                                 *ispec_srf.horizInterp_,
+    srfEmissFunc::update_srfEmiss_data_from_file(ispec_srf.dataReader_, start_of_step_ts(),
+                                                 curr_month, *ispec_srf.horizInterp_,
                                                  ispec_srf.data_end_); // output
   }
 
@@ -316,15 +319,16 @@ void MAMSrfOnlineEmiss::initialize_impl(const RunType run_type) {
   //-----------------------------------------------------------------
   // This data is time-independent, we read all data here for the
   // entire simulation
-  soilErodibilityFunc::update_soil_erodibility_data_from_file(serod_dataReader_, *serod_horizInterp_,
+  soilErodibilityFunc::update_soil_erodibility_data_from_file(serod_dataReader_,
+                                                              *serod_horizInterp_,
                                                               soil_erodibility_); // output
 
   //--------------------------------------------------------------------
   // Update marine orgaincs from file
   //--------------------------------------------------------------------
   // Time dependent data
-  marineOrganicsFunc::update_marine_organics_data_from_file(morg_dataReader_, start_of_step_ts(), curr_month,
-                                                            *morg_horizInterp_,
+  marineOrganicsFunc::update_marine_organics_data_from_file(morg_dataReader_, start_of_step_ts(),
+                                                            curr_month, *morg_horizInterp_,
                                                             morg_data_end_); // output
 
   //-----------------------------------------------------------------
@@ -338,7 +342,8 @@ void MAMSrfOnlineEmiss::initialize_impl(const RunType run_type) {
 //  RUN_IMPL
 // ================================================================
 void MAMSrfOnlineEmiss::run_impl(const double dt) {
-  const auto scan_policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
+  const auto scan_policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
 
   // preprocess input -- needs a scan for the calculation of atm height
   Kokkos::parallel_for("preprocess", scan_policy, preprocess_);
@@ -366,10 +371,12 @@ void MAMSrfOnlineEmiss::run_impl(const double dt) {
   // Update time state and if the month has changed, update the data.
   marineOrganicsFunc::update_marine_organics_timestate(morg_dataReader_, ts, *morg_horizInterp_,
                                                        // output
-                                                       morg_timeState_, morg_data_start_, morg_data_end_);
+                                                       morg_timeState_, morg_data_start_,
+                                                       morg_data_end_);
 
   // Call the main marine organics routine to get interpolated forcings.
-  marineOrganicsFunc::marineOrganics_main(morg_timeState_, morg_data_start_, morg_data_end_, morg_data_out_);
+  marineOrganicsFunc::marineOrganics_main(morg_timeState_, morg_data_start_, morg_data_end_,
+                                          morg_data_out_);
 
   // Marine organics emission data read from the file (order is important here)
   const const_view_1d mpoly = ekat::subview(morg_data_out_.emiss_sectors, 0);
@@ -383,10 +390,12 @@ void MAMSrfOnlineEmiss::run_impl(const double dt) {
   const const_view_1d sst = get_field_in("sst").get_view<const Real *>();
 
   // U wind component [m/s]
-  const const_view_2d u_wind = get_field_in("horiz_winds").get_component(0).get_view<const Real **>();
+  const const_view_2d u_wind =
+      get_field_in("horiz_winds").get_component(0).get_view<const Real **>();
 
   // V wind component [m/s]
-  const const_view_2d v_wind = get_field_in("horiz_winds").get_component(1).get_view<const Real **>();
+  const const_view_2d v_wind =
+      get_field_in("horiz_winds").get_component(1).get_view<const Real **>();
 
   // Dust fluxes [kg/m^2/s]: Four flux values for each column
   const const_view_2d dstflx = get_field_in("dstflx").get_view<const Real **>();
@@ -397,8 +406,8 @@ void MAMSrfOnlineEmiss::run_impl(const double dt) {
   // Vertical layer height at midpoints
   const const_view_2d z_mid = dry_atm_.z_mid;
 
-  compute_online_dust_nacl_emiss(ncol_, nlev_, ocnfrac, sst, u_wind, v_wind, dstflx, mpoly, mprot, mlip,
-                                 soil_erodibility, z_mid,
+  compute_online_dust_nacl_emiss(ncol_, nlev_, ocnfrac, sst, u_wind, v_wind, dstflx, mpoly, mprot,
+                                 mlip, soil_erodibility, z_mid,
                                  // output
                                  constituent_fluxes);
   Kokkos::fence();
@@ -413,10 +422,12 @@ void MAMSrfOnlineEmiss::run_impl(const double dt) {
     // Update time state and if the month has changed, update the data.
     srfEmissFunc::update_srfEmiss_timestate(ispec_srf.dataReader_, ts, *ispec_srf.horizInterp_,
                                             // output
-                                            ispec_srf.timeState_, ispec_srf.data_start_, ispec_srf.data_end_);
+                                            ispec_srf.timeState_, ispec_srf.data_start_,
+                                            ispec_srf.data_end_);
 
     // Call the main srfEmiss routine to get interpolated aerosol forcings.
-    srfEmissFunc::srfEmiss_main(ispec_srf.timeState_, ispec_srf.data_start_, ispec_srf.data_end_, ispec_srf.data_out_);
+    srfEmissFunc::srfEmiss_main(ispec_srf.timeState_, ispec_srf.data_start_, ispec_srf.data_end_,
+                                ispec_srf.data_out_);
 
     //--------------------------------------------------------------------
     // Modify units to MKS units (from molecules/cm2/s to kg/m2/s)
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_process_interface.hpp w/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_process_interface.hpp
index 973dd0c80f..bc06b728de 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_process_interface.hpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_srf_and_online_emissions_process_interface.hpp
@@ -124,9 +124,10 @@ private:
   // FIXME: Remove the hardwired indices and use a function
   // to find them from an array.
   const std::map<std::string, int> spcIndex_in_pcnst_ = {
-      {"so2", 12},    {"dms", 13},    {"so4_a1", 15}, {"dst_a1", 19}, {"ncl_a1", 20}, {"mom_a1", 21},
-      {"num_a1", 22}, {"so4_a2", 23}, {"ncl_a2", 25}, {"mom_a2", 26}, {"num_a2", 27}, {"dst_a3", 28},
-      {"ncl_a3", 29}, {"num_a3", 35}, {"pom_a4", 36}, {"bc_a4", 37},  {"mom_a4", 38}, {"num_a4", 39}};
+      {"so2", 12},    {"dms", 13},    {"so4_a1", 15}, {"dst_a1", 19}, {"ncl_a1", 20},
+      {"mom_a1", 21}, {"num_a1", 22}, {"so4_a2", 23}, {"ncl_a2", 25}, {"mom_a2", 26},
+      {"num_a2", 27}, {"dst_a3", 28}, {"ncl_a3", 29}, {"num_a3", 35}, {"pom_a4", 36},
+      {"bc_a4", 37},  {"mom_a4", 38}, {"num_a4", 39}};
 
   // A struct carrying all the fields needed to read
   // surface emissions of a species
diff --git i/components/eamxx/src/physics/mam/eamxx_mam_wetscav_process_interface.cpp w/components/eamxx/src/physics/mam/eamxx_mam_wetscav_process_interface.cpp
index da333e2d92..3b1cc91592 100644
--- i/components/eamxx/src/physics/mam/eamxx_mam_wetscav_process_interface.cpp
+++ w/components/eamxx/src/physics/mam/eamxx_mam_wetscav_process_interface.cpp
@@ -11,7 +11,8 @@ NOTES:
 namespace scream {
 
 // =========================================================================================
-MAMWetscav::MAMWetscav(const ekat::Comm &comm, const ekat::ParameterList &params) : MAMGenericInterface(comm, params) {
+MAMWetscav::MAMWetscav(const ekat::Comm &comm, const ekat::ParameterList &params)
+    : MAMGenericInterface(comm, params) {
   /* Anything that can be initialized without grid information can be
    * initialized here. Like universal constants, mam wetscav options.
    */
@@ -45,7 +46,8 @@ void MAMWetscav::set_grids(const std::shared_ptr<const GridsManager> grids_manag
   FieldLayout scalar2d = grid_->get_2d_scalar_layout();
 
   // layout for 3D (ncol, nmodes, nlevs)
-  FieldLayout scalar3d_mid_nmodes = grid_->get_3d_vector_layout(true, nmodes, mam_coupling::num_modes_tag_name());
+  FieldLayout scalar3d_mid_nmodes =
+      grid_->get_3d_vector_layout(true, nmodes, mam_coupling::num_modes_tag_name());
 
   // layout for 2D (ncol, pcnst)
   FieldLayout scalar2d_pconst = grid_->get_2d_vector_layout(pcnst, "num_phys_constants");
@@ -165,8 +167,8 @@ void MAMWetscav::init_buffers(const ATMBufferManager &buffer_manager) {
   EKAT_REQUIRE_MSG(buffer_manager.allocated_bytes() >= requested_buffer_size_in_bytes(),
                    "Error! Insufficient buffer size.\n");
   size_t used_mem = mam_coupling::init_buffer(buffer_manager, ncol_, nlev_, buffer_);
-  std::cout << "used_mem " << used_mem << "requested_buffer_size_in_bytes() " << requested_buffer_size_in_bytes()
-            << "\n";
+  std::cout << "used_mem " << used_mem << "requested_buffer_size_in_bytes() "
+            << requested_buffer_size_in_bytes() << "\n";
   EKAT_REQUIRE_MSG(used_mem == requested_buffer_size_in_bytes(),
                    "Error! Used memory != requested memory for MAMWetscav.");
 }
@@ -189,8 +191,9 @@ void MAMWetscav::init_temporary_views() {
   const int workspace_used     = work_ptr - buffer_.temporary_views.data();
   const int workspace_provided = buffer_.temporary_views.extent(0);
   EKAT_REQUIRE_MSG(workspace_used == workspace_provided,
-                   "Error: workspace_used (" + std::to_string(workspace_used) + ") and workspace_provided (" +
-                       std::to_string(workspace_provided) + ") should be equal. \n");
+                   "Error: workspace_used (" + std::to_string(workspace_used) +
+                       ") and workspace_provided (" + std::to_string(workspace_provided) +
+                       ") should be equal. \n");
 }
 // ================================================================
 //  INITIALIZE_IMPL
@@ -304,8 +307,10 @@ void MAMWetscav::initialize_impl(const RunType run_type) {
 
   mam4::wetdep::init_scavimptbl(scavimptblvol_host, scavimptblnum_host);
 
-  scavimptblnum_ = view_2d("scavimptblnum", mam4::aero_model::nimptblgrow_total, mam4::AeroConfig::num_modes());
-  scavimptblvol_ = view_2d("scavimptblvol", mam4::aero_model::nimptblgrow_total, mam4::AeroConfig::num_modes());
+  scavimptblnum_ =
+      view_2d("scavimptblnum", mam4::aero_model::nimptblgrow_total, mam4::AeroConfig::num_modes());
+  scavimptblvol_ =
+      view_2d("scavimptblvol", mam4::aero_model::nimptblgrow_total, mam4::AeroConfig::num_modes());
   Kokkos::deep_copy(scavimptblnum_, scavimptblnum_host);
   Kokkos::deep_copy(scavimptblvol_, scavimptblvol_host);
 }
@@ -314,7 +319,8 @@ void MAMWetscav::initialize_impl(const RunType run_type) {
 //  RUN_IMPL
 // ================================================================
 void MAMWetscav::run_impl(const double dt) {
-  const auto scan_policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
+  const auto scan_policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncol_, nlev_);
 
   // preprocess input -- needs a scan for the calculation of all variables
   // needed by this process or setting up MAM4xx classes and their objects
@@ -414,7 +420,8 @@ void MAMWetscav::run_impl(const double dt) {
         mam4::Prognostics progs = mam_coupling::aerosols_for_column(dry_aero, icol);
         // fetch column-specific subviews into aerosol tendencies
         // Note: we are only updating interstitial aerosols.
-        mam4::Tendencies tends = mam_coupling::interstitial_aerosols_tendencies_for_column(dry_aero_tends, icol);
+        mam4::Tendencies tends =
+            mam_coupling::interstitial_aerosols_tendencies_for_column(dry_aero_tends, icol);
         /// shallow_convective_precipitation_production
         const auto rprdsh_icol = ekat::subview(rprdsh, icol);
         // deep_convective_precipitation_production
@@ -445,14 +452,15 @@ void MAMWetscav::run_impl(const double dt) {
 
         auto isprx_icol = ekat::subview(isprx, icol);
 
-        mam4::wetdep::aero_model_wetdep(team, atm, progs, tends, dt,
-                                        // inputs
-                                        cldt_icol, rprdsh_icol, rprddp_icol, evapcdp_icol, evapcsh_icol, dp_frac_icol,
-                                        sh_frac_icol, icwmrdp_col, icwmrsh_icol, nevapr_icol, dlf_icol, prain_icol,
-                                        scavimptblnum, scavimptblvol, calsize_data,
-                                        // outputs
-                                        wet_diameter_icol, dry_diameter_icol, qaerwat_icol, wetdens_icol,
-                                        aerdepwetis_icol, aerdepwetcw_icol, work_icol, isprx_icol);
+        mam4::wetdep::aero_model_wetdep(
+            team, atm, progs, tends, dt,
+            // inputs
+            cldt_icol, rprdsh_icol, rprddp_icol, evapcdp_icol, evapcsh_icol, dp_frac_icol,
+            sh_frac_icol, icwmrdp_col, icwmrsh_icol, nevapr_icol, dlf_icol, prain_icol,
+            scavimptblnum, scavimptblvol, calsize_data,
+            // outputs
+            wet_diameter_icol, dry_diameter_icol, qaerwat_icol, wetdens_icol, aerdepwetis_icol,
+            aerdepwetcw_icol, work_icol, isprx_icol);
         team.team_barrier();
         // update interstitial aerosol state
         Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev), [&](int kk) {
diff --git i/components/eamxx/src/physics/mam/mam_aerosol_optics_read_tables.hpp w/components/eamxx/src/physics/mam/mam_aerosol_optics_read_tables.hpp
index e9fef232ae..5e05d3c4d8 100644
--- i/components/eamxx/src/physics/mam/mam_aerosol_optics_read_tables.hpp
+++ w/components/eamxx/src/physics/mam/mam_aerosol_optics_read_tables.hpp
@@ -35,7 +35,8 @@ struct AerosolOpticsHostData {
 
 using AerosolOpticsDeviceData = mam4::modal_aer_opt::AerosolOpticsDeviceData;
 
-inline void set_parameters_table(AerosolOpticsHostData &aerosol_optics_host_data, ekat::ParameterList &rrtmg_params,
+inline void set_parameters_table(AerosolOpticsHostData &aerosol_optics_host_data,
+                                 ekat::ParameterList &rrtmg_params,
                                  std::map<std::string, FieldLayout> &layouts,
                                  std::map<std::string, view_1d_host> &host_views) {
   // Set up input structure to read data from file.
@@ -58,11 +59,15 @@ inline void set_parameters_table(AerosolOpticsHostData &aerosol_optics_host_data
   auto refindex_im_sw_host   = view_2d_host("refrtabsw_im_host", nswbands, refindex_im);
 
   // absplw(lw_band, mode, refindex_im, refindex_real, coef_number)
-  auto absplw_host = view_5d_host("absplw_host", nlwbands, 1, refindex_im, refindex_real, coef_number);
+  auto absplw_host =
+      view_5d_host("absplw_host", nlwbands, 1, refindex_im, refindex_real, coef_number);
 
-  auto asmpsw_host = view_5d_host("asmpsw_host", nswbands, 1, refindex_im, refindex_real, coef_number);
-  auto extpsw_host = view_5d_host("extpsw_host", nswbands, 1, refindex_im, refindex_real, coef_number);
-  auto abspsw_host = view_5d_host("abspsw_host", nswbands, 1, refindex_im, refindex_real, coef_number);
+  auto asmpsw_host =
+      view_5d_host("asmpsw_host", nswbands, 1, refindex_im, refindex_real, coef_number);
+  auto extpsw_host =
+      view_5d_host("extpsw_host", nswbands, 1, refindex_im, refindex_real, coef_number);
+  auto abspsw_host =
+      view_5d_host("abspsw_host", nswbands, 1, refindex_im, refindex_real, coef_number);
 
   aerosol_optics_host_data.refindex_real_lw_host = refindex_real_lw_host;
   aerosol_optics_host_data.refindex_im_lw_host   = refindex_im_lw_host;
@@ -73,28 +78,37 @@ inline void set_parameters_table(AerosolOpticsHostData &aerosol_optics_host_data
   aerosol_optics_host_data.extpsw_host           = extpsw_host;
   aerosol_optics_host_data.abspsw_host           = abspsw_host;
 
-  auto refindex_real_lw_layout = make_layout({nlwbands, refindex_real}, {"lwband", "refindex_real"});
-  auto refindex_im_lw_layout   = make_layout({nlwbands, refindex_im}, {"lwband", "refindex_im"});
-  auto refindex_real_sw_layout = make_layout({nswbands, refindex_real}, {"swband", "refindex_real"});
-  auto refindex_im_sw_layout   = make_layout({nswbands, refindex_im}, {"swband", "refindex_im"});
-  auto absplw_layout           = make_layout({nlwbands, 1, refindex_im, refindex_real, coef_number},
-                                             {"lwband", "mode", "refindex_im", "refindex_real", "coef_number"});
+  auto refindex_real_lw_layout =
+      make_layout({nlwbands, refindex_real}, {"lwband", "refindex_real"});
+  auto refindex_im_lw_layout = make_layout({nlwbands, refindex_im}, {"lwband", "refindex_im"});
+  auto refindex_real_sw_layout =
+      make_layout({nswbands, refindex_real}, {"swband", "refindex_real"});
+  auto refindex_im_sw_layout = make_layout({nswbands, refindex_im}, {"swband", "refindex_im"});
+  auto absplw_layout =
+      make_layout({nlwbands, 1, refindex_im, refindex_real, coef_number},
+                  {"lwband", "mode", "refindex_im", "refindex_real", "coef_number"});
   // use also for extpsw, abspsw
-  auto asmpsw_layout = make_layout({nswbands, 1, refindex_im, refindex_real, coef_number},
-                                   {"swband", "mode", "refindex_im", "refindex_real", "coef_number"});
+  auto asmpsw_layout =
+      make_layout({nswbands, 1, refindex_im, refindex_real, coef_number},
+                  {"swband", "mode", "refindex_im", "refindex_real", "coef_number"});
 
-  rrtmg_params.set<strvec_t>("field_names", {"asmpsw", "extpsw", "abspsw", "absplw", "refindex_real_sw",
-                                             "refindex_im_sw", "refindex_real_lw", "refindex_im_lw"});
+  rrtmg_params.set<strvec_t>("field_names",
+                             {"asmpsw", "extpsw", "abspsw", "absplw", "refindex_real_sw",
+                              "refindex_im_sw", "refindex_real_lw", "refindex_im_lw"});
 
   rrtmg_params.set("skip_grid_checks", true);
 
-  host_views["refindex_real_sw"] = view_1d_host(refindex_real_sw_host.data(), refindex_real_sw_host.size());
+  host_views["refindex_real_sw"] =
+      view_1d_host(refindex_real_sw_host.data(), refindex_real_sw_host.size());
 
-  host_views["refindex_im_sw"] = view_1d_host(refindex_im_sw_host.data(), refindex_im_sw_host.size());
+  host_views["refindex_im_sw"] =
+      view_1d_host(refindex_im_sw_host.data(), refindex_im_sw_host.size());
 
-  host_views["refindex_real_lw"] = view_1d_host(refindex_real_lw_host.data(), refindex_real_lw_host.size());
+  host_views["refindex_real_lw"] =
+      view_1d_host(refindex_real_lw_host.data(), refindex_real_lw_host.size());
 
-  host_views["refindex_im_lw"] = view_1d_host(refindex_im_lw_host.data(), refindex_im_lw_host.size());
+  host_views["refindex_im_lw"] =
+      view_1d_host(refindex_im_lw_host.data(), refindex_im_lw_host.size());
 
   host_views["absplw"] = view_1d_host(absplw_host.data(), absplw_host.size());
 
@@ -114,7 +128,8 @@ inline void set_parameters_table(AerosolOpticsHostData &aerosol_optics_host_data
   layouts.emplace("abspsw", asmpsw_layout);
 }
 // KOKKOS_INLINE_FUNCTION
-inline void read_rrtmg_table(const std::string &table_filename, const int imode, ekat::ParameterList &params,
+inline void read_rrtmg_table(const std::string &table_filename, const int imode,
+                             ekat::ParameterList &params,
                              const std::shared_ptr<const AbstractGrid> &grid,
                              const std::map<std::string, view_1d_host> &host_views_1d,
                              const std::map<std::string, FieldLayout> &layouts,
@@ -161,7 +176,8 @@ inline void read_rrtmg_table(const std::string &table_filename, const int imode,
                          Kokkos::MDRangePolicy<Kokkos::Rank<3>, Kokkos::DefaultHostExecutionSpace>(
                              {0, 0, 0}, {coef_number, refindex_real, refindex_im}),
                          [&](const int d2, const int d3, const int d4) {
-                           temp_lw_3d_host(d2, d3, d4) = aerosol_optics_host_data.absplw_host(d5, 0, d4, d3, d2);
+                           temp_lw_3d_host(d2, d3, d4) =
+                               aerosol_optics_host_data.absplw_host(d5, 0, d4, d3, d2);
                          });
     Kokkos::fence();
 
@@ -178,7 +194,8 @@ inline void read_rrtmg_table(const std::string &table_filename, const int imode,
                          Kokkos::MDRangePolicy<Kokkos::Rank<3>, Kokkos::DefaultHostExecutionSpace>(
                              {0, 0, 0}, {coef_number, refindex_real, refindex_im}),
                          [&](const int d2, const int d3, const int d4) {
-                           temp_lw_3d_host(d2, d3, d4) = aerosol_optics_host_data.asmpsw_host(d5, 0, d4, d3, d2);
+                           temp_lw_3d_host(d2, d3, d4) =
+                               aerosol_optics_host_data.asmpsw_host(d5, 0, d4, d3, d2);
                          });
     Kokkos::fence();
     // syn data to device
@@ -188,7 +205,8 @@ inline void read_rrtmg_table(const std::string &table_filename, const int imode,
                          Kokkos::MDRangePolicy<Kokkos::Rank<3>, Kokkos::DefaultHostExecutionSpace>(
                              {0, 0, 0}, {coef_number, refindex_real, refindex_im}),
                          [&](const int d2, const int d3, const int d4) {
-                           temp_lw_3d_host(d2, d3, d4) = aerosol_optics_host_data.abspsw_host(d5, 0, d4, d3, d2);
+                           temp_lw_3d_host(d2, d3, d4) =
+                               aerosol_optics_host_data.abspsw_host(d5, 0, d4, d3, d2);
                          });
     Kokkos::fence();
     // syn data to device
@@ -198,7 +216,8 @@ inline void read_rrtmg_table(const std::string &table_filename, const int imode,
                          Kokkos::MDRangePolicy<Kokkos::Rank<3>, Kokkos::DefaultHostExecutionSpace>(
                              {0, 0, 0}, {coef_number, refindex_real, refindex_im}),
                          [&](const int d2, const int d3, const int d4) {
-                           temp_lw_3d_host(d2, d3, d4) = aerosol_optics_host_data.extpsw_host(d5, 0, d4, d3, d2);
+                           temp_lw_3d_host(d2, d3, d4) =
+                               aerosol_optics_host_data.extpsw_host(d5, 0, d4, d3, d2);
                          });
 
     Kokkos::fence();
@@ -208,7 +227,8 @@ inline void read_rrtmg_table(const std::string &table_filename, const int imode,
   } // d5
 }
 
-inline void read_water_refindex(const std::string &table_filename, const std::shared_ptr<const AbstractGrid> &grid,
+inline void read_water_refindex(const std::string &table_filename,
+                                const std::shared_ptr<const AbstractGrid> &grid,
                                 const complex_view_1d &crefwlw, const complex_view_1d &crefwsw) {
   // refractive index for water read in read_water_refindex
   // crefwsw(nswbands) ! complex refractive index for water visible
@@ -224,8 +244,8 @@ inline void read_water_refindex(const std::string &table_filename, const std::sh
   params.set("filename", table_filename);
   params.set("skip_grid_checks", true);
 
-  params.set<strvec_t>("field_names", {"refindex_im_water_lw", "refindex_im_water_sw", "refindex_real_water_lw",
-                                       "refindex_real_water_sw"});
+  params.set<strvec_t>("field_names", {"refindex_im_water_lw", "refindex_im_water_sw",
+                                       "refindex_real_water_lw", "refindex_real_water_sw"});
   // make a list of host views
   std::map<std::string, view_1d_host> host_views_water;
   // fist allocate host views.
@@ -287,7 +307,8 @@ inline void set_refindex_names(std::string surname, ekat::ParameterList &params,
   std::string refindex_im_lw   = "refindex_im_" + surname + "_lw";
 
   params.set("skip_grid_checks", true);
-  params.set<strvec_t>("field_names", {refindex_real_sw, refindex_im_sw, refindex_real_lw, refindex_im_lw});
+  params.set<strvec_t>("field_names",
+                       {refindex_real_sw, refindex_im_sw, refindex_real_lw, refindex_im_lw});
   // allocate host views
   host_views[refindex_real_sw] = view_1d_host(refindex_real_sw, nswbands);
   host_views[refindex_im_sw]   = view_1d_host(refindex_im_sw, nswbands);
@@ -304,10 +325,11 @@ inline void set_refindex_names(std::string surname, ekat::ParameterList &params,
 
 } // set_refindex_aero
 
-inline void set_refindex_aerosol(
-    const int species_id, std::map<std::string, view_1d_host> &host_views,
-    mam_coupling::complex_view_2d::HostMirror &specrefndxsw_host, // complex refractive index for water visible
-    mam_coupling::complex_view_2d::HostMirror &specrefndxlw_host) {
+inline void
+set_refindex_aerosol(const int species_id, std::map<std::string, view_1d_host> &host_views,
+                     mam_coupling::complex_view_2d::HostMirror
+                         &specrefndxsw_host, // complex refractive index for water visible
+                     mam_coupling::complex_view_2d::HostMirror &specrefndxlw_host) {
   std::string sw_real_name = "refindex_real_aer_sw";
   std::string lw_real_name = "refindex_real_aer_lw";
   std::string sw_im_name   = "refindex_im_aer_sw";
diff --git i/components/eamxx/src/physics/mam/mam_coupling.hpp w/components/eamxx/src/physics/mam/mam_coupling.hpp
index 1986c2ab10..d7d36f545b 100644
--- i/components/eamxx/src/physics/mam/mam_coupling.hpp
+++ w/components/eamxx/src/physics/mam/mam_coupling.hpp
@@ -98,7 +98,8 @@ const char *aero_species_name(const int species_id) {
 // name of the gas species.
 KOKKOS_INLINE_FUNCTION
 const char *gas_species_name(const int gas_id) {
-  static const char *species_names[num_aero_gases()] = {"O3", "H2O2", "H2SO4", "SO2", "DMS", "SOAG"};
+  static const char *species_names[num_aero_gases()] = {"O3",  "H2O2", "H2SO4",
+                                                        "SO2", "DMS",  "SOAG"};
   return species_names[gas_id];
 }
 
@@ -230,7 +231,9 @@ const char *cld_aero_mmr_field_name(const int mode, const int species) {
 // Given a MAM aerosol-related gas identifier, returns the name of its mass
 // mixing ratio field in EAMxx
 KOKKOS_INLINE_FUNCTION
-const char *gas_mmr_field_name(const int gas) { return const_cast<const char *>(gas_species_name(gas)); }
+const char *gas_mmr_field_name(const int gas) {
+  return const_cast<const char *>(gas_species_name(gas));
+}
 
 // This type stores multi-column views related specifically to the wet
 // atmospheric state used by EAMxx.
@@ -285,7 +288,7 @@ struct AerosolState {
                                                               // ratios [kg aerosol / kg air]
   view_2d cld_aero_mmr[num_aero_modes()][num_aero_species()]; // cloudborne aerosol mass mixing
                                                               // ratios [kg aerosol / kg air]
-  view_2d gas_mmr[num_aero_gases()];                          // gas mass mixing ratios [kg gas / kg air]
+  view_2d gas_mmr[num_aero_gases()]; // gas mass mixing ratios [kg gas / kg air]
 };
 
 // storage for variables used within MAM atmosphere processes, initialized with
@@ -302,7 +305,8 @@ struct Buffer {
 
   // number of local fields stored at column midpoints
   static constexpr int min_num_2d_mid = 8 + // number of dry atm fields
-                                        2 * (num_aero_modes() + num_aero_tracers()) + num_aero_gases();
+                                        2 * (num_aero_modes() + num_aero_tracers()) +
+                                        num_aero_gases();
   // +
   // num_2d_scratch;
   int num_2d_scratch{0};
@@ -348,16 +352,20 @@ struct Buffer {
 
   void set_num_scratch(const int num_2d_scratch_in) {
     num_2d_scratch = num_2d_scratch_in;
-    EKAT_REQUIRE_MSG(num_2d_scratch < max_num_2d_scratch, "Error! Insufficient number of scratch size in mam "
-                                                          "buffer; increase max_num_2d_scratch\n");
+    EKAT_REQUIRE_MSG(num_2d_scratch < max_num_2d_scratch,
+                     "Error! Insufficient number of scratch size in mam "
+                     "buffer; increase max_num_2d_scratch\n");
   }
 
-  void set_len_temporary_views(const int len_temporary_views_len) { len_temporary_views = len_temporary_views_len; }
+  void set_len_temporary_views(const int len_temporary_views_len) {
+    len_temporary_views = len_temporary_views_len;
+  }
 };
 
 // ON HOST, returns the number of bytes of device memory needed by the above
 // Buffer type given the number of columns and vertical levels
-inline size_t buffer_size(const int ncol, const int nlev, const int num_2d_scratch, const int len_temporary_views) {
+inline size_t buffer_size(const int ncol, const int nlev, const int num_2d_scratch,
+                          const int len_temporary_views) {
   const int num_2d_mid = Buffer::min_num_2d_mid + num_2d_scratch;
   return sizeof(Real) * (num_2d_mid * ncol * nlev + Buffer::num_2d_iface * ncol * (nlev + 1)) +
          sizeof(Real) * len_temporary_views;
@@ -366,13 +374,14 @@ inline size_t buffer_size(const int ncol, const int nlev, const int num_2d_scrat
 // ON HOST, initialize the Buffer type with sufficient memory to store
 // intermediate (dry) quantities on the given number of columns with the given
 // number of vertical levels. Returns the number of bytes allocated.
-inline size_t init_buffer(const ATMBufferManager &buffer_manager, const int ncol, const int nlev, Buffer &buffer) {
+inline size_t init_buffer(const ATMBufferManager &buffer_manager, const int ncol, const int nlev,
+                          Buffer &buffer) {
   Real *mem = reinterpret_cast<Real *>(buffer_manager.get_memory());
 
   // set view pointers for midpoint fields
   uview_2d *view_2d_min_mid_ptrs[Buffer::min_num_2d_mid] = {
-      &buffer.z_mid, &buffer.dz, &buffer.qv_dry, &buffer.qc_dry, &buffer.nc_dry, &buffer.qi_dry, &buffer.ni_dry,
-      &buffer.w_updraft,
+      &buffer.z_mid, &buffer.dz, &buffer.qv_dry, &buffer.qc_dry, &buffer.nc_dry, &buffer.qi_dry,
+      &buffer.ni_dry, &buffer.w_updraft,
 
       // aerosol modes
       &buffer.dry_int_aero_nmr[0], &buffer.dry_int_aero_nmr[1], &buffer.dry_int_aero_nmr[2],
@@ -383,31 +392,37 @@ inline size_t init_buffer(const ATMBufferManager &buffer_manager, const int ncol
       // (see mode_aero_species() in mam4xx/aero_modes.hpp)
 
       // accumulation mode
-      &buffer.dry_int_aero_mmr[0][0], &buffer.dry_int_aero_mmr[0][1], &buffer.dry_int_aero_mmr[0][2],
-      &buffer.dry_int_aero_mmr[0][3], &buffer.dry_int_aero_mmr[0][4], &buffer.dry_int_aero_mmr[0][5],
-      &buffer.dry_int_aero_mmr[0][6], &buffer.dry_cld_aero_mmr[0][0], &buffer.dry_cld_aero_mmr[0][1],
-      &buffer.dry_cld_aero_mmr[0][2], &buffer.dry_cld_aero_mmr[0][3], &buffer.dry_cld_aero_mmr[0][4],
+      &buffer.dry_int_aero_mmr[0][0], &buffer.dry_int_aero_mmr[0][1],
+      &buffer.dry_int_aero_mmr[0][2], &buffer.dry_int_aero_mmr[0][3],
+      &buffer.dry_int_aero_mmr[0][4], &buffer.dry_int_aero_mmr[0][5],
+      &buffer.dry_int_aero_mmr[0][6], &buffer.dry_cld_aero_mmr[0][0],
+      &buffer.dry_cld_aero_mmr[0][1], &buffer.dry_cld_aero_mmr[0][2],
+      &buffer.dry_cld_aero_mmr[0][3], &buffer.dry_cld_aero_mmr[0][4],
       &buffer.dry_cld_aero_mmr[0][5], &buffer.dry_cld_aero_mmr[0][6],
 
       // aitken mode
-      &buffer.dry_int_aero_mmr[1][0], &buffer.dry_int_aero_mmr[1][1], &buffer.dry_int_aero_mmr[1][2],
-      &buffer.dry_int_aero_mmr[1][3], &buffer.dry_cld_aero_mmr[1][0], &buffer.dry_cld_aero_mmr[1][1],
+      &buffer.dry_int_aero_mmr[1][0], &buffer.dry_int_aero_mmr[1][1],
+      &buffer.dry_int_aero_mmr[1][2], &buffer.dry_int_aero_mmr[1][3],
+      &buffer.dry_cld_aero_mmr[1][0], &buffer.dry_cld_aero_mmr[1][1],
       &buffer.dry_cld_aero_mmr[1][2], &buffer.dry_cld_aero_mmr[1][3],
 
       // coarse mode
-      &buffer.dry_int_aero_mmr[2][0], &buffer.dry_int_aero_mmr[2][1], &buffer.dry_int_aero_mmr[2][2],
-      &buffer.dry_int_aero_mmr[2][3], &buffer.dry_int_aero_mmr[2][4], &buffer.dry_int_aero_mmr[2][5],
-      &buffer.dry_int_aero_mmr[2][6], &buffer.dry_cld_aero_mmr[2][0], &buffer.dry_cld_aero_mmr[2][1],
-      &buffer.dry_cld_aero_mmr[2][2], &buffer.dry_cld_aero_mmr[2][3], &buffer.dry_cld_aero_mmr[2][4],
+      &buffer.dry_int_aero_mmr[2][0], &buffer.dry_int_aero_mmr[2][1],
+      &buffer.dry_int_aero_mmr[2][2], &buffer.dry_int_aero_mmr[2][3],
+      &buffer.dry_int_aero_mmr[2][4], &buffer.dry_int_aero_mmr[2][5],
+      &buffer.dry_int_aero_mmr[2][6], &buffer.dry_cld_aero_mmr[2][0],
+      &buffer.dry_cld_aero_mmr[2][1], &buffer.dry_cld_aero_mmr[2][2],
+      &buffer.dry_cld_aero_mmr[2][3], &buffer.dry_cld_aero_mmr[2][4],
       &buffer.dry_cld_aero_mmr[2][5], &buffer.dry_cld_aero_mmr[2][6],
 
       // primary carbon mode
-      &buffer.dry_int_aero_mmr[3][0], &buffer.dry_int_aero_mmr[3][1], &buffer.dry_int_aero_mmr[3][2],
-      &buffer.dry_cld_aero_mmr[3][0], &buffer.dry_cld_aero_mmr[3][1], &buffer.dry_cld_aero_mmr[3][2],
+      &buffer.dry_int_aero_mmr[3][0], &buffer.dry_int_aero_mmr[3][1],
+      &buffer.dry_int_aero_mmr[3][2], &buffer.dry_cld_aero_mmr[3][0],
+      &buffer.dry_cld_aero_mmr[3][1], &buffer.dry_cld_aero_mmr[3][2],
 
       // aerosol gases
-      &buffer.dry_gas_mmr[0], &buffer.dry_gas_mmr[1], &buffer.dry_gas_mmr[2], &buffer.dry_gas_mmr[3],
-      &buffer.dry_gas_mmr[4], &buffer.dry_gas_mmr[5]};
+      &buffer.dry_gas_mmr[0], &buffer.dry_gas_mmr[1], &buffer.dry_gas_mmr[2],
+      &buffer.dry_gas_mmr[3], &buffer.dry_gas_mmr[4], &buffer.dry_gas_mmr[5]};
 
   for (int i = 0; i < Buffer::min_num_2d_mid; ++i) {
     *view_2d_min_mid_ptrs[i] = view_2d(mem, ncol, nlev);
@@ -455,25 +470,33 @@ inline size_t init_buffer(const ATMBufferManager &buffer_manager, const int ncol
 // column.
 KOKKOS_INLINE_FUNCTION
 haero::Atmosphere atmosphere_for_column(const DryAtmosphere &dry_atm, const int column_index) {
-  EKAT_KERNEL_ASSERT_MSG(dry_atm.T_mid.data() != nullptr, "T_mid not defined for dry atmosphere state!");
-  EKAT_KERNEL_ASSERT_MSG(dry_atm.p_mid.data() != nullptr, "p_mid not defined for dry atmosphere state!");
+  EKAT_KERNEL_ASSERT_MSG(dry_atm.T_mid.data() != nullptr,
+                         "T_mid not defined for dry atmosphere state!");
+  EKAT_KERNEL_ASSERT_MSG(dry_atm.p_mid.data() != nullptr,
+                         "p_mid not defined for dry atmosphere state!");
   EKAT_KERNEL_ASSERT_MSG(dry_atm.qv.data() != nullptr, "qv not defined for dry atmosphere state!");
   EKAT_KERNEL_ASSERT_MSG(dry_atm.qc.data() != nullptr, "qc not defined for dry atmosphere state!");
   EKAT_KERNEL_ASSERT_MSG(dry_atm.nc.data() != nullptr, "nc not defined for dry atmosphere state!");
   EKAT_KERNEL_ASSERT_MSG(dry_atm.qi.data() != nullptr, "qi not defined for dry atmosphere state!");
   EKAT_KERNEL_ASSERT_MSG(dry_atm.ni.data() != nullptr, "ni not defined for dry atmosphere state!");
-  EKAT_KERNEL_ASSERT_MSG(dry_atm.z_mid.data() != nullptr, "z_mid not defined for dry atmosphere state!");
-  EKAT_KERNEL_ASSERT_MSG(dry_atm.p_del.data() != nullptr, "p_del not defined for dry atmosphere state!");
-  EKAT_KERNEL_ASSERT_MSG(dry_atm.p_int.data() != nullptr, "p_int not defined for dry atmosphere state!");
-  EKAT_KERNEL_ASSERT_MSG(dry_atm.cldfrac.data() != nullptr, "cldfrac not defined for dry atmosphere state!");
-  EKAT_KERNEL_ASSERT_MSG(dry_atm.w_updraft.data() != nullptr, "w_updraft not defined for dry atmosphere state!");
-  return haero::Atmosphere(mam4::nlev, ekat::subview(dry_atm.T_mid, column_index),
-                           ekat::subview(dry_atm.p_mid, column_index), ekat::subview(dry_atm.qv, column_index),
-                           ekat::subview(dry_atm.qc, column_index), ekat::subview(dry_atm.nc, column_index),
-                           ekat::subview(dry_atm.qi, column_index), ekat::subview(dry_atm.ni, column_index),
-                           ekat::subview(dry_atm.z_mid, column_index), ekat::subview(dry_atm.p_del, column_index),
-                           ekat::subview(dry_atm.p_int, column_index), ekat::subview(dry_atm.cldfrac, column_index),
-                           ekat::subview(dry_atm.w_updraft, column_index), dry_atm.pblh(column_index));
+  EKAT_KERNEL_ASSERT_MSG(dry_atm.z_mid.data() != nullptr,
+                         "z_mid not defined for dry atmosphere state!");
+  EKAT_KERNEL_ASSERT_MSG(dry_atm.p_del.data() != nullptr,
+                         "p_del not defined for dry atmosphere state!");
+  EKAT_KERNEL_ASSERT_MSG(dry_atm.p_int.data() != nullptr,
+                         "p_int not defined for dry atmosphere state!");
+  EKAT_KERNEL_ASSERT_MSG(dry_atm.cldfrac.data() != nullptr,
+                         "cldfrac not defined for dry atmosphere state!");
+  EKAT_KERNEL_ASSERT_MSG(dry_atm.w_updraft.data() != nullptr,
+                         "w_updraft not defined for dry atmosphere state!");
+  return haero::Atmosphere(
+      mam4::nlev, ekat::subview(dry_atm.T_mid, column_index),
+      ekat::subview(dry_atm.p_mid, column_index), ekat::subview(dry_atm.qv, column_index),
+      ekat::subview(dry_atm.qc, column_index), ekat::subview(dry_atm.nc, column_index),
+      ekat::subview(dry_atm.qi, column_index), ekat::subview(dry_atm.ni, column_index),
+      ekat::subview(dry_atm.z_mid, column_index), ekat::subview(dry_atm.p_del, column_index),
+      ekat::subview(dry_atm.p_int, column_index), ekat::subview(dry_atm.cldfrac, column_index),
+      ekat::subview(dry_atm.w_updraft, column_index), dry_atm.pblh(column_index));
 }
 
 // Given an AerosolState with views for dry aerosol quantities, creates a
@@ -481,11 +504,13 @@ haero::Atmosphere atmosphere_for_column(const DryAtmosphere &dry_atm, const int
 // ONLY INTERSTITIAL AEROSOL VIEWS DEFINED. This object can be provided to
 // mam4xx for the column.
 KOKKOS_INLINE_FUNCTION
-mam4::Prognostics interstitial_aerosols_for_column(const AerosolState &dry_aero, const int column_index) {
+mam4::Prognostics interstitial_aerosols_for_column(const AerosolState &dry_aero,
+                                                   const int column_index) {
   constexpr int nlev = mam4::nlev;
   mam4::Prognostics progs(nlev);
   for (int m = 0; m < num_aero_modes(); ++m) {
-    EKAT_KERNEL_ASSERT_MSG(dry_aero.int_aero_nmr[m].data(), "int_aero_nmr not defined for dry aerosol state!");
+    EKAT_KERNEL_ASSERT_MSG(dry_aero.int_aero_nmr[m].data(),
+                           "int_aero_nmr not defined for dry aerosol state!");
     progs.n_mode_i[m] = ekat::subview(dry_aero.int_aero_nmr[m], column_index);
     for (int a = 0; a < num_aero_species(); ++a) {
       if (dry_aero.int_aero_mmr[m][a].data()) {
@@ -494,7 +519,8 @@ mam4::Prognostics interstitial_aerosols_for_column(const AerosolState &dry_aero,
     }
   }
   for (int g = 0; g < num_aero_gases(); ++g) {
-    EKAT_KERNEL_ASSERT_MSG(dry_aero.gas_mmr[g].data(), "gas_mmr not defined for dry aerosol state!");
+    EKAT_KERNEL_ASSERT_MSG(dry_aero.gas_mmr[g].data(),
+                           "gas_mmr not defined for dry aerosol state!");
     progs.q_gas[g] = ekat::subview(dry_aero.gas_mmr[g], column_index);
   }
   return progs;
@@ -505,11 +531,13 @@ mam4::Prognostics interstitial_aerosols_for_column(const AerosolState &dry_aero,
 // ONLY INTERSTITIAL AEROSOL VIEWS DEFINED. This object can be provided to
 // mam4xx for the column.
 KOKKOS_INLINE_FUNCTION
-mam4::Tendencies interstitial_aerosols_tendencies_for_column(const AerosolState &dry_aero, const int column_index) {
+mam4::Tendencies interstitial_aerosols_tendencies_for_column(const AerosolState &dry_aero,
+                                                             const int column_index) {
   constexpr int nlev = mam4::nlev;
   mam4::Tendencies tends(nlev);
   for (int m = 0; m < num_aero_modes(); ++m) {
-    EKAT_KERNEL_ASSERT_MSG(dry_aero.int_aero_nmr[m].data(), "int_aero_nmr not defined for dry aerosol state!");
+    EKAT_KERNEL_ASSERT_MSG(dry_aero.int_aero_nmr[m].data(),
+                           "int_aero_nmr not defined for dry aerosol state!");
     tends.n_mode_i[m] = ekat::subview(dry_aero.int_aero_nmr[m], column_index);
     for (int a = 0; a < num_aero_species(); ++a) {
       if (dry_aero.int_aero_mmr[m][a].data()) {
@@ -518,7 +546,8 @@ mam4::Tendencies interstitial_aerosols_tendencies_for_column(const AerosolState
     }
   }
   for (int g = 0; g < num_aero_gases(); ++g) {
-    EKAT_KERNEL_ASSERT_MSG(dry_aero.gas_mmr[g].data(), "gas_mmr not defined for dry aerosol state!");
+    EKAT_KERNEL_ASSERT_MSG(dry_aero.gas_mmr[g].data(),
+                           "gas_mmr not defined for dry aerosol state!");
     tends.q_gas[g] = ekat::subview(dry_aero.gas_mmr[g], column_index);
   }
   return tends;
@@ -531,7 +560,8 @@ KOKKOS_INLINE_FUNCTION
 mam4::Prognostics aerosols_for_column(const AerosolState &dry_aero, const int column_index) {
   auto progs = interstitial_aerosols_for_column(dry_aero, column_index);
   for (int m = 0; m < num_aero_modes(); ++m) {
-    EKAT_KERNEL_ASSERT_MSG(dry_aero.cld_aero_nmr[m].data(), "dry_cld_aero_nmr not defined for aerosol state!");
+    EKAT_KERNEL_ASSERT_MSG(dry_aero.cld_aero_nmr[m].data(),
+                           "dry_cld_aero_nmr not defined for aerosol state!");
     progs.n_mode_c[m] = ekat::subview(dry_aero.cld_aero_nmr[m], column_index);
     for (int a = 0; a < num_aero_species(); ++a) {
       if (dry_aero.cld_aero_mmr[m][a].data()) {
@@ -545,7 +575,8 @@ mam4::Prognostics aerosols_for_column(const AerosolState &dry_aero, const int co
 // the column with the given index with interstitial and cloudborne aerosol
 // views defined. This object can be provided to mam4xx for the column.
 KOKKOS_INLINE_FUNCTION
-mam4::Tendencies aerosols_tendencies_for_column(const AerosolState &dry_aero, const int column_index) {
+mam4::Tendencies aerosols_tendencies_for_column(const AerosolState &dry_aero,
+                                                const int column_index) {
   auto tends = interstitial_aerosols_tendencies_for_column(dry_aero, column_index);
   for (int m = 0; m < num_aero_modes(); ++m) {
     EKAT_KERNEL_ASSERT_MSG(dry_aero.cld_aero_nmr[m].data(),
@@ -563,8 +594,10 @@ mam4::Tendencies aerosols_tendencies_for_column(const AerosolState &dry_aero, co
 // team to compute vertical layer heights and interfaces for the column with
 // the given index.
 KOKKOS_INLINE_FUNCTION
-void compute_vertical_layer_heights(const Team &team, const DryAtmosphere &dry_atm, const int column_index) {
-  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(), "Given column index does not correspond to given team!");
+void compute_vertical_layer_heights(const Team &team, const DryAtmosphere &dry_atm,
+                                    const int column_index) {
+  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
+                         "Given column index does not correspond to given team!");
 
   // outputs
   const auto dz      = ekat::subview(dry_atm.dz, column_index);
@@ -584,24 +617,25 @@ void compute_vertical_layer_heights(const Team &team, const DryAtmosphere &dry_a
   EKAT_KERNEL_ASSERT_MSG(dry_atm.z_surf == 0, "dry_atm.z_surf must be zero");
   PF::calculate_z_int(team, mam4::nlev, dz, dry_atm.z_surf, // inputs
                       z_iface);                             // output
-  team.team_barrier();                                      // likely necessary to have z_iface up to date
-  PF::calculate_z_mid(team, mam4::nlev, z_iface,            // input
-                      z_mid);                               // output
+  team.team_barrier();                           // likely necessary to have z_iface up to date
+  PF::calculate_z_mid(team, mam4::nlev, z_iface, // input
+                      z_mid);                    // output
 }
 
 // Given a thread team and wet and dry atmospheres, dispatches threads from the
 // team to compute the vertical updraft velocity for the column with the given
 // index.
 KOKKOS_INLINE_FUNCTION
-void compute_updraft_velocities(const Team &team, const WetAtmosphere &wet_atm, const DryAtmosphere &dry_atm,
-                                const int column_index) {
-  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(), "Given column index does not correspond to given team!");
+void compute_updraft_velocities(const Team &team, const WetAtmosphere &wet_atm,
+                                const DryAtmosphere &dry_atm, const int column_index) {
+  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
+                         "Given column index does not correspond to given team!");
 
   constexpr int nlev = mam4::nlev;
   int i              = column_index;
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev), [&](const int k) {
-    dry_atm.dz(i, k) =
-        PF::calculate_dz(dry_atm.p_del(i, k), dry_atm.p_mid(i, k), dry_atm.T_mid(i, k), wet_atm.qv(i, k));
+    dry_atm.dz(i, k)        = PF::calculate_dz(dry_atm.p_del(i, k), dry_atm.p_mid(i, k),
+                                               dry_atm.T_mid(i, k), wet_atm.qv(i, k));
     const auto rho          = PF::calculate_density(dry_atm.p_del(i, k), dry_atm.dz(i, k));
     dry_atm.w_updraft(i, k) = PF::calculate_vertical_velocity(dry_atm.omega(i, k), rho);
   });
@@ -611,9 +645,10 @@ void compute_updraft_velocities(const Team &team, const WetAtmosphere &wet_atm,
 // from the team to compute mixing ratios for a dry atmosphere state in th
 // column with the given index.
 KOKKOS_INLINE_FUNCTION
-void compute_dry_mixing_ratios(const Team &team, const WetAtmosphere &wet_atm, const DryAtmosphere &dry_atm,
-                               const int column_index) {
-  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(), "Given column index does not correspond to given team!");
+void compute_dry_mixing_ratios(const Team &team, const WetAtmosphere &wet_atm,
+                               const DryAtmosphere &dry_atm, const int column_index) {
+  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
+                         "Given column index does not correspond to given team!");
 
   constexpr int nlev = mam4::nlev;
   int i              = column_index;
@@ -631,18 +666,22 @@ void compute_dry_mixing_ratios(const Team &team, const WetAtmosphere &wet_atm, c
 // threads from the team to compute mixing ratios for the given dry interstitial
 // aerosol state for the column with the given index.
 KOKKOS_INLINE_FUNCTION
-void compute_dry_mixing_ratios(const Team &team, const WetAtmosphere &wet_atm, const AerosolState &wet_aero,
-                               const AerosolState &dry_aero, const int column_index) {
-  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(), "Given column index does not correspond to given team!");
+void compute_dry_mixing_ratios(const Team &team, const WetAtmosphere &wet_atm,
+                               const AerosolState &wet_aero, const AerosolState &dry_aero,
+                               const int column_index) {
+  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
+                         "Given column index does not correspond to given team!");
 
   constexpr int nlev = mam4::nlev;
   int i              = column_index;
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev), [&](const int k) {
     const auto qv_ik = wet_atm.qv(i, k);
     for (int m = 0; m < num_aero_modes(); ++m) {
-      dry_aero.int_aero_nmr[m](i, k) = PF::calculate_drymmr_from_wetmmr(wet_aero.int_aero_nmr[m](i, k), qv_ik);
+      dry_aero.int_aero_nmr[m](i, k) =
+          PF::calculate_drymmr_from_wetmmr(wet_aero.int_aero_nmr[m](i, k), qv_ik);
       if (dry_aero.cld_aero_nmr[m].data()) {
-        dry_aero.cld_aero_nmr[m](i, k) = PF::calculate_drymmr_from_wetmmr(wet_aero.cld_aero_nmr[m](i, k), qv_ik);
+        dry_aero.cld_aero_nmr[m](i, k) =
+            PF::calculate_drymmr_from_wetmmr(wet_aero.cld_aero_nmr[m](i, k), qv_ik);
       }
       for (int a = 0; a < num_aero_species(); ++a) {
         if (dry_aero.int_aero_mmr[m][a].data()) {
@@ -656,7 +695,8 @@ void compute_dry_mixing_ratios(const Team &team, const WetAtmosphere &wet_atm, c
       }
     }
     for (int g = 0; g < num_aero_gases(); ++g) {
-      dry_aero.gas_mmr[g](i, k) = PF::calculate_drymmr_from_wetmmr(wet_aero.gas_mmr[g](i, k), qv_ik);
+      dry_aero.gas_mmr[g](i, k) =
+          PF::calculate_drymmr_from_wetmmr(wet_aero.gas_mmr[g](i, k), qv_ik);
     }
   });
 }
@@ -665,18 +705,22 @@ void compute_dry_mixing_ratios(const Team &team, const WetAtmosphere &wet_atm, c
 // threads from the team to compute mixing ratios for the given wet interstitial
 // aerosol state for the column with the given index.
 KOKKOS_INLINE_FUNCTION
-void compute_wet_mixing_ratios(const Team &team, const DryAtmosphere &dry_atm, const AerosolState &dry_aero,
-                               const AerosolState &wet_aero, const int column_index) {
-  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(), "Given column index does not correspond to given team!");
+void compute_wet_mixing_ratios(const Team &team, const DryAtmosphere &dry_atm,
+                               const AerosolState &dry_aero, const AerosolState &wet_aero,
+                               const int column_index) {
+  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
+                         "Given column index does not correspond to given team!");
 
   constexpr int nlev = mam4::nlev;
   int i              = column_index;
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev), [&](const int k) {
     const auto qv_ik = dry_atm.qv(i, k);
     for (int m = 0; m < num_aero_modes(); ++m) {
-      wet_aero.int_aero_nmr[m](i, k) = PF::calculate_wetmmr_from_drymmr(dry_aero.int_aero_nmr[m](i, k), qv_ik);
+      wet_aero.int_aero_nmr[m](i, k) =
+          PF::calculate_wetmmr_from_drymmr(dry_aero.int_aero_nmr[m](i, k), qv_ik);
       if (wet_aero.cld_aero_nmr[m].data()) {
-        wet_aero.cld_aero_nmr[m](i, k) = PF::calculate_wetmmr_from_drymmr(dry_aero.cld_aero_nmr[m](i, k), qv_ik);
+        wet_aero.cld_aero_nmr[m](i, k) =
+            PF::calculate_wetmmr_from_drymmr(dry_aero.cld_aero_nmr[m](i, k), qv_ik);
       }
       for (int a = 0; a < num_aero_species(); ++a) {
         if (wet_aero.int_aero_mmr[m][a].data()) {
@@ -690,15 +734,18 @@ void compute_wet_mixing_ratios(const Team &team, const DryAtmosphere &dry_atm, c
       }
     }
     for (int g = 0; g < num_aero_gases(); ++g) {
-      wet_aero.gas_mmr[g](i, k) = PF::calculate_wetmmr_from_drymmr(dry_aero.gas_mmr[g](i, k), qv_ik);
+      wet_aero.gas_mmr[g](i, k) =
+          PF::calculate_wetmmr_from_drymmr(dry_aero.gas_mmr[g](i, k), qv_ik);
     }
   });
 }
 
 // Set minimum background MMR for the interstitial aerosols
 KOKKOS_INLINE_FUNCTION
-void set_min_background_mmr(const Team &team, const AerosolState &dry_aero, const int column_index) {
-  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(), "Given column index does not correspond to given team!");
+void set_min_background_mmr(const Team &team, const AerosolState &dry_aero,
+                            const int column_index) {
+  EKAT_KERNEL_ASSERT_MSG(column_index == team.league_rank(),
+                         "Given column index does not correspond to given team!");
 
   // Minimum background value for the interstitial aerosols
   constexpr Real INTERSTITIAL_AERO_MIN_VAL = 1e-36;
@@ -711,8 +758,8 @@ void set_min_background_mmr(const Team &team, const AerosolState &dry_aero, cons
           haero::max(dry_aero.int_aero_nmr[imode](icol, klev), INTERSTITIAL_AERO_MIN_VAL);
       for (int ispec = 0; ispec < num_aero_species(); ++ispec) {
         if (dry_aero.int_aero_mmr[imode][ispec].data()) {
-          dry_aero.int_aero_mmr[imode][ispec](icol, klev) =
-              haero::max(dry_aero.int_aero_mmr[imode][ispec](icol, klev), INTERSTITIAL_AERO_MIN_VAL);
+          dry_aero.int_aero_mmr[imode][ispec](icol, klev) = haero::max(
+              dry_aero.int_aero_mmr[imode][ispec](icol, klev), INTERSTITIAL_AERO_MIN_VAL);
         }
       } // ispec
     } // imode
@@ -720,7 +767,8 @@ void set_min_background_mmr(const Team &team, const AerosolState &dry_aero, cons
 } // set_min_background_mmr
 
 // Computes the reciprocal of pseudo density for a column
-inline void compute_recipical_pseudo_density(haero::ThreadTeamPolicy team_policy, const_view_2d pdel, const int nlev,
+inline void compute_recipical_pseudo_density(haero::ThreadTeamPolicy team_policy,
+                                             const_view_2d pdel, const int nlev,
                                              // output
                                              view_2d rpdel) {
   Kokkos::parallel_for(
@@ -736,8 +784,8 @@ inline void compute_recipical_pseudo_density(haero::ThreadTeamPolicy team_policy
 // uses "packs". Following function copies a 2d view till model levels
 inline void copy_view_lev_slice(haero::ThreadTeamPolicy team_policy, // inputs
                                 const_view_2d &inp_view,             // input view to copy
-                                const int dim,                       // dimension till view should be copied
-                                view_2d &out_view) {                 // output view
+                                const int dim,       // dimension till view should be copied
+                                view_2d &out_view) { // output view
 
   Kokkos::parallel_for(
       team_policy, KOKKOS_LAMBDA(const haero::ThreadTeam &team) {
diff --git i/components/eamxx/src/physics/mam/physical_limits.hpp w/components/eamxx/src/physics/mam/physical_limits.hpp
index be00f093fb..631195bc99 100644
--- i/components/eamxx/src/physics/mam/physical_limits.hpp
+++ w/components/eamxx/src/physics/mam/physical_limits.hpp
@@ -15,7 +15,8 @@
 namespace scream::mam_coupling {
 
 inline const std::pair<Real, Real> &physical_min_max(const std::string &field_name) {
-  static const std::map<std::string, std::pair<Real, Real>> limits = {{"nmr", {0, 1e13}}, {"mmr", {-1e-10, 1e-2}}};
+  static const std::map<std::string, std::pair<Real, Real>> limits = {{"nmr", {0, 1e13}},
+                                                                      {"mmr", {-1e-10, 1e-2}}};
 
   auto it = limits.find(field_name);
   if (it == limits.end()) {
@@ -27,8 +28,12 @@ inline const std::pair<Real, Real> &physical_min_max(const std::string &field_na
     return it->second;
   }
 }
-inline Real physical_min(const std::string &field_name) { return physical_min_max(field_name).first; }
-inline Real physical_max(const std::string &field_name) { return physical_min_max(field_name).second; }
+inline Real physical_min(const std::string &field_name) {
+  return physical_min_max(field_name).first;
+}
+inline Real physical_max(const std::string &field_name) {
+  return physical_min_max(field_name).second;
+}
 
 } // namespace scream::mam_coupling
 
diff --git i/components/eamxx/src/physics/mam/readfiles/find_season_index_utils.hpp w/components/eamxx/src/physics/mam/readfiles/find_season_index_utils.hpp
index 8dbd1a00ab..fec3c74de4 100644
--- i/components/eamxx/src/physics/mam/readfiles/find_season_index_utils.hpp
+++ w/components/eamxx/src/physics/mam/readfiles/find_season_index_utils.hpp
@@ -42,16 +42,17 @@ inline void find_season_index_reader(const std::string &season_wes_file, const c
 
   scorpio::read_var(season_wes_file, "lat", lat_lai.data());
 
-  Kokkos::MDRangePolicy<Kokkos::HostSpace::execution_space, Kokkos::Rank<2>> policy_wk_lai({0, 0},
-                                                                                           {nlat_lai, npft_lai});
+  Kokkos::MDRangePolicy<Kokkos::HostSpace::execution_space, Kokkos::Rank<2>> policy_wk_lai(
+      {0, 0}, {nlat_lai, npft_lai});
 
   // loop over time to get all 12 instantence of season_wes
   for (int itime = 0; itime < 12; ++itime) {
     scorpio::read_var(season_wes_file, "season_wes", wk_lai_temp.data(), itime);
     // copy data from wk_lai_temp to wk_lai.
     // NOTE: season_wes has different layout that wk_lai
-    Kokkos::parallel_for("copy_to_wk_lai", policy_wk_lai,
-                         [&](const int j, const int k) { wk_lai(j, k, itime) = wk_lai_temp(k, j); });
+    Kokkos::parallel_for("copy_to_wk_lai", policy_wk_lai, [&](const int j, const int k) {
+      wk_lai(j, k, itime) = wk_lai_temp(k, j);
+    });
     Kokkos::fence();
   }
   scorpio::release_file(season_wes_file);
diff --git i/components/eamxx/src/physics/mam/readfiles/fractional_land_use.hpp w/components/eamxx/src/physics/mam/readfiles/fractional_land_use.hpp
index e10f091d50..1c46fb6f25 100644
--- i/components/eamxx/src/physics/mam/readfiles/fractional_land_use.hpp
+++ w/components/eamxx/src/physics/mam/readfiles/fractional_land_use.hpp
@@ -18,28 +18,33 @@ template <typename ScalarType, typename DeviceType> struct fracLandUseFunctions
 
   // Fractional land use routines
   static std::shared_ptr<AbstractRemapper>
-  create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid, const std::string &fracLandUse_data_file,
-                        const std::string &map_file, const std::string &field_name, const std::string &dim_name1,
+  create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid,
+                        const std::string &fracLandUse_data_file, const std::string &map_file,
+                        const std::string &field_name, const std::string &dim_name1,
                         const std::string &dim_name2);
 
   // -------------------------------------------------------------------------------------------
   // -------------------------------------------------------------------------------------------
 
-  static std::shared_ptr<AtmosphereInput> create_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
-                                                             const std::string &data_file);
+  static std::shared_ptr<AtmosphereInput>
+  create_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
+                     const std::string &data_file);
 
   // -------------------------------------------------------------------------------------------
   // -------------------------------------------------------------------------------------------
 
   static void update_frac_land_use_data_from_file(std::shared_ptr<AtmosphereInput> &scorpio_reader,
-                                                  AbstractRemapper &horiz_interp, const_view_2d &input);
+                                                  AbstractRemapper &horiz_interp,
+                                                  const_view_2d &input);
 
   // -------------------------------------------------------------------------------------------
   // -------------------------------------------------------------------------------------------
 
-  static void init_frac_landuse_file_read(const int ncol, const std::string field_name, const std::string dim_name1,
-                                          const std::string dim_name2, const std::shared_ptr<const AbstractGrid> &grid,
-                                          const std::string &data_file, const std::string &mapping_file,
+  static void init_frac_landuse_file_read(const int ncol, const std::string field_name,
+                                          const std::string dim_name1, const std::string dim_name2,
+                                          const std::shared_ptr<const AbstractGrid> &grid,
+                                          const std::string &data_file,
+                                          const std::string &mapping_file,
                                           // output
                                           std::shared_ptr<AbstractRemapper> &FracLandUseHorizInterp,
                                           std::shared_ptr<AtmosphereInput> &FracLandUseDataReader);
diff --git i/components/eamxx/src/physics/mam/readfiles/fractional_land_use_impl.hpp w/components/eamxx/src/physics/mam/readfiles/fractional_land_use_impl.hpp
index c3b104a34e..f33917d43a 100644
--- i/components/eamxx/src/physics/mam/readfiles/fractional_land_use_impl.hpp
+++ w/components/eamxx/src/physics/mam/readfiles/fractional_land_use_impl.hpp
@@ -11,8 +11,9 @@ namespace frac_landuse {
 
 template <typename S, typename D>
 std::shared_ptr<AbstractRemapper> fracLandUseFunctions<S, D>::create_horiz_remapper(
-    const std::shared_ptr<const AbstractGrid> &model_grid, const std::string &data_file, const std::string &map_file,
-    const std::string &field_name, const std::string &dim_name1, const std::string &dim_name2) {
+    const std::shared_ptr<const AbstractGrid> &model_grid, const std::string &data_file,
+    const std::string &map_file, const std::string &field_name, const std::string &dim_name1,
+    const std::string &dim_name2) {
   using namespace ShortFieldTagsNames;
 
   scorpio::register_file(data_file, scorpio::Read);
@@ -29,12 +30,14 @@ std::shared_ptr<AbstractRemapper> fracLandUseFunctions<S, D>::create_horiz_remap
   const int ncols_model = model_grid->get_num_global_dofs();
   std::shared_ptr<AbstractRemapper> remapper;
   if (ncols_data == ncols_model) {
-    remapper = std::make_shared<IdentityRemapper>(horiz_interp_tgt_grid, IdentityRemapper::SrcAliasTgt);
+    remapper =
+        std::make_shared<IdentityRemapper>(horiz_interp_tgt_grid, IdentityRemapper::SrcAliasTgt);
   } else {
-    EKAT_REQUIRE_MSG(ncols_data <= ncols_model, "Error! We do not allow to coarsen fractional land use "
-                                                "data to fit the model. We only allow\n"
-                                                "       fractional land use data to be at the same or "
-                                                "coarser resolution as the model.\n");
+    EKAT_REQUIRE_MSG(ncols_data <= ncols_model,
+                     "Error! We do not allow to coarsen fractional land use "
+                     "data to fit the model. We only allow\n"
+                     "       fractional land use data to be at the same or "
+                     "coarser resolution as the model.\n");
     // We must have a valid map file
     EKAT_REQUIRE_MSG(map_file != "", "ERROR: fractional land use data is on a different grid "
                                      "than the model one,\n"
@@ -65,9 +68,8 @@ std::shared_ptr<AbstractRemapper> fracLandUseFunctions<S, D>::create_horiz_remap
 // -------------------------------------------------------------------------------------------
 
 template <typename S, typename D>
-std::shared_ptr<AtmosphereInput>
-fracLandUseFunctions<S, D>::create_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
-                                               const std::string &data_file) {
+std::shared_ptr<AtmosphereInput> fracLandUseFunctions<S, D>::create_data_reader(
+    const std::shared_ptr<AbstractRemapper> &horiz_remapper, const std::string &data_file) {
   std::vector<Field> io_fields;
   for (int i = 0; i < horiz_remapper->get_num_fields(); ++i) {
     io_fields.push_back(horiz_remapper->get_src_field(i));
@@ -80,9 +82,9 @@ fracLandUseFunctions<S, D>::create_data_reader(const std::shared_ptr<AbstractRem
 // -------------------------------------------------------------------------------------------
 
 template <typename S, typename D>
-void fracLandUseFunctions<S, D>::update_frac_land_use_data_from_file(std::shared_ptr<AtmosphereInput> &scorpio_reader,
-                                                                     AbstractRemapper &horiz_interp,
-                                                                     const_view_2d &input) {
+void fracLandUseFunctions<S, D>::update_frac_land_use_data_from_file(
+    std::shared_ptr<AtmosphereInput> &scorpio_reader, AbstractRemapper &horiz_interp,
+    const_view_2d &input) {
   start_timer("EAMxx::FracLandUse::update_frac_land_use_data_from_file");
 
   // 1. Read from file
@@ -111,16 +113,16 @@ void fracLandUseFunctions<S, D>::update_frac_land_use_data_from_file(std::shared
 // -------------------------------------------------------------------------------------------
 
 template <typename S, typename D>
-void fracLandUseFunctions<S, D>::init_frac_landuse_file_read(const int ncol, const std::string field_name,
-                                                             const std::string dim_name1, const std::string dim_name2,
-                                                             const std::shared_ptr<const AbstractGrid> &grid,
-                                                             const std::string &data_file,
-                                                             const std::string &mapping_file,
-                                                             // output
-                                                             std::shared_ptr<AbstractRemapper> &FracLandUseHorizInterp,
-                                                             std::shared_ptr<AtmosphereInput> &FracLandUseDataReader) {
+void fracLandUseFunctions<S, D>::init_frac_landuse_file_read(
+    const int ncol, const std::string field_name, const std::string dim_name1,
+    const std::string dim_name2, const std::shared_ptr<const AbstractGrid> &grid,
+    const std::string &data_file, const std::string &mapping_file,
+    // output
+    std::shared_ptr<AbstractRemapper> &FracLandUseHorizInterp,
+    std::shared_ptr<AtmosphereInput> &FracLandUseDataReader) {
   // Init horizontal remap
-  FracLandUseHorizInterp = create_horiz_remapper(grid, data_file, mapping_file, field_name, dim_name1, dim_name2);
+  FracLandUseHorizInterp =
+      create_horiz_remapper(grid, data_file, mapping_file, field_name, dim_name1, dim_name2);
 
   // Create reader (an AtmosphereInput object)
   FracLandUseDataReader = create_data_reader(FracLandUseHorizInterp, data_file);
diff --git i/components/eamxx/src/physics/mam/readfiles/marine_organics.hpp w/components/eamxx/src/physics/mam/readfiles/marine_organics.hpp
index 6a60fd4706..c8b5cf8f28 100644
--- i/components/eamxx/src/physics/mam/readfiles/marine_organics.hpp
+++ w/components/eamxx/src/physics/mam/readfiles/marine_organics.hpp
@@ -63,52 +63,57 @@ template <typename ScalarType, typename DeviceType> struct marineOrganicsFunctio
   using marineOrganicsOutput = marineOrganicsData;
 
   // -------------------------------------------------------------------------------------------
-  static std::shared_ptr<AbstractRemapper> create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid,
-                                                                 const std::string &marineOrganics_data_file,
-                                                                 const std::string &map_file,
-                                                                 const std::vector<std::string> &field_name,
-                                                                 const std::string &dim_name1);
+  static std::shared_ptr<AbstractRemapper>
+  create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid,
+                        const std::string &marineOrganics_data_file, const std::string &map_file,
+                        const std::vector<std::string> &field_name, const std::string &dim_name1);
 
   // -------------------------------------------------------------------------------------------
-  static std::shared_ptr<AtmosphereInput> create_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
-                                                             const std::string &data_file);
+  static std::shared_ptr<AtmosphereInput>
+  create_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
+                     const std::string &data_file);
 
   // -------------------------------------------------------------------------------------------
-  static void update_marine_organics_data_from_file(std::shared_ptr<AtmosphereInput> &scorpio_reader,
-                                                    const util::TimeStamp &ts,
-                                                    const int &time_index, // zero-based
-                                                    AbstractRemapper &horiz_interp,
-                                                    marineOrganicsInput &marineOrganics_input);
+  static void update_marine_organics_data_from_file(
+      std::shared_ptr<AtmosphereInput> &scorpio_reader, const util::TimeStamp &ts,
+      const int &time_index, // zero-based
+      AbstractRemapper &horiz_interp, marineOrganicsInput &marineOrganics_input);
 
   // -------------------------------------------------------------------------------------------
   static void update_marine_organics_timestate(std::shared_ptr<AtmosphereInput> &scorpio_reader,
-                                               const util::TimeStamp &ts, AbstractRemapper &horiz_interp,
-                                               marineOrganicsTimeState &time_state, marineOrganicsInput &beg,
-                                               marineOrganicsInput &end);
+                                               const util::TimeStamp &ts,
+                                               AbstractRemapper &horiz_interp,
+                                               marineOrganicsTimeState &time_state,
+                                               marineOrganicsInput &beg, marineOrganicsInput &end);
 
   // -------------------------------------------------------------------------------------------
-  static void marineOrganics_main(const marineOrganicsTimeState &time_state, const marineOrganicsInput &data_beg,
-                                  const marineOrganicsInput &data_end, const marineOrganicsOutput &data_out);
+  static void marineOrganics_main(const marineOrganicsTimeState &time_state,
+                                  const marineOrganicsInput &data_beg,
+                                  const marineOrganicsInput &data_end,
+                                  const marineOrganicsOutput &data_out);
 
   // -------------------------------------------------------------------------------------------
-  static void perform_time_interpolation(const marineOrganicsTimeState &time_state, const marineOrganicsInput &data_beg,
-                                         const marineOrganicsInput &data_end, const marineOrganicsOutput &data_out);
+  static void perform_time_interpolation(const marineOrganicsTimeState &time_state,
+                                         const marineOrganicsInput &data_beg,
+                                         const marineOrganicsInput &data_end,
+                                         const marineOrganicsOutput &data_out);
 
   // -------------------------------------------------------------------------------------------
   // Performs convex interpolation of x0 and x1 at point t
   template <typename ScalarX, typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarX linear_interp(const ScalarX &x0, const ScalarX &x1, const ScalarT &t);
+  KOKKOS_INLINE_FUNCTION static ScalarX linear_interp(const ScalarX &x0, const ScalarX &x1,
+                                                      const ScalarT &t);
 
   // -------------------------------------------------------------------------------------------
-  static void init_marine_organics_file_read(const int &ncol, const std::vector<std::string> &field_name,
-                                             const std::string &dim_name1,
-                                             const std::shared_ptr<const AbstractGrid> &grid,
-                                             const std::string &data_file, const std::string &mapping_file,
-                                             // output
-                                             std::shared_ptr<AbstractRemapper> &marineOrganicsHorizInterp,
-                                             marineOrganicsInput &morg_data_start_, marineOrganicsInput &morg_data_end_,
-                                             marineOrganicsData &morg_data_out_,
-                                             std::shared_ptr<AtmosphereInput> &marineOrganicsDataReader);
+  static void init_marine_organics_file_read(
+      const int &ncol, const std::vector<std::string> &field_name, const std::string &dim_name1,
+      const std::shared_ptr<const AbstractGrid> &grid, const std::string &data_file,
+      const std::string &mapping_file,
+      // output
+      std::shared_ptr<AbstractRemapper> &marineOrganicsHorizInterp,
+      marineOrganicsInput &morg_data_start_, marineOrganicsInput &morg_data_end_,
+      marineOrganicsData &morg_data_out_,
+      std::shared_ptr<AtmosphereInput> &marineOrganicsDataReader);
 
 }; // struct marineOrganicsFunctions
 
diff --git i/components/eamxx/src/physics/mam/readfiles/marine_organics_impl.hpp w/components/eamxx/src/physics/mam/readfiles/marine_organics_impl.hpp
index 18849d9af7..d2352a9c61 100644
--- i/components/eamxx/src/physics/mam/readfiles/marine_organics_impl.hpp
+++ w/components/eamxx/src/physics/mam/readfiles/marine_organics_impl.hpp
@@ -11,8 +11,9 @@ namespace marine_organics {
 
 template <typename S, typename D>
 std::shared_ptr<AbstractRemapper> marineOrganicsFunctions<S, D>::create_horiz_remapper(
-    const std::shared_ptr<const AbstractGrid> &model_grid, const std::string &data_file, const std::string &map_file,
-    const std::vector<std::string> &field_name, const std::string &dim_name1) {
+    const std::shared_ptr<const AbstractGrid> &model_grid, const std::string &data_file,
+    const std::string &map_file, const std::vector<std::string> &field_name,
+    const std::string &dim_name1) {
   using namespace ShortFieldTagsNames;
 
   scorpio::register_file(data_file, scorpio::Read);
@@ -27,7 +28,8 @@ std::shared_ptr<AbstractRemapper> marineOrganicsFunctions<S, D>::create_horiz_re
   const int ncols_model = model_grid->get_num_global_dofs();
   std::shared_ptr<AbstractRemapper> remapper;
   if (ncols_data == ncols_model) {
-    remapper = std::make_shared<IdentityRemapper>(horiz_interp_tgt_grid, IdentityRemapper::SrcAliasTgt);
+    remapper =
+        std::make_shared<IdentityRemapper>(horiz_interp_tgt_grid, IdentityRemapper::SrcAliasTgt);
   } else {
     EKAT_REQUIRE_MSG(ncols_data <= ncols_model, "Error! We do not allow to coarsen marine organics "
                                                 "data to fit the model. We only allow\n"
@@ -71,9 +73,8 @@ std::shared_ptr<AbstractRemapper> marineOrganicsFunctions<S, D>::create_horiz_re
 
 // -------------------------------------------------------------------------------------------
 template <typename S, typename D>
-std::shared_ptr<AtmosphereInput>
-marineOrganicsFunctions<S, D>::create_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
-                                                  const std::string &data_file) {
+std::shared_ptr<AtmosphereInput> marineOrganicsFunctions<S, D>::create_data_reader(
+    const std::shared_ptr<AbstractRemapper> &horiz_remapper, const std::string &data_file) {
   std::vector<Field> io_fields;
   for (int ifld = 0; ifld < horiz_remapper->get_num_fields(); ++ifld) {
     io_fields.push_back(horiz_remapper->get_src_field(ifld));
@@ -112,8 +113,9 @@ void marineOrganicsFunctions<S, D>::update_marine_organics_data_from_file(
   // Read the field from the file
 
   for (int ifld = 0; ifld < horiz_interp.get_num_fields(); ++ifld) {
-    auto sector      = horiz_interp.get_tgt_field(ifld).get_view<const Real *>();
-    const auto emiss = Kokkos::subview(marineOrganics_input.data.emiss_sectors, ifld, Kokkos::ALL());
+    auto sector = horiz_interp.get_tgt_field(ifld).get_view<const Real *>();
+    const auto emiss =
+        Kokkos::subview(marineOrganics_input.data.emiss_sectors, ifld, Kokkos::ALL());
     Kokkos::deep_copy(emiss, sector);
   }
 
@@ -129,8 +131,9 @@ void marineOrganicsFunctions<S, D>::update_marine_organics_data_from_file(
 // -------------------------------------------------------------------------------------------
 template <typename S, typename D>
 void marineOrganicsFunctions<S, D>::update_marine_organics_timestate(
-    std::shared_ptr<AtmosphereInput> &scorpio_reader, const util::TimeStamp &ts, AbstractRemapper &horiz_interp,
-    marineOrganicsTimeState &time_state, marineOrganicsInput &beg, marineOrganicsInput &end) {
+    std::shared_ptr<AtmosphereInput> &scorpio_reader, const util::TimeStamp &ts,
+    AbstractRemapper &horiz_interp, marineOrganicsTimeState &time_state, marineOrganicsInput &beg,
+    marineOrganicsInput &end) {
   // Now we check if we have to update the data that changes monthly
   // NOTE:  This means that marineOrganics assumes monthly data to update.  Not
   //        any other frequency.
@@ -160,17 +163,17 @@ void marineOrganicsFunctions<S, D>::update_marine_organics_timestate(
 // -------------------------------------------------------------------------------------------
 template <typename S, typename D>
 template <typename ScalarX, typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarX marineOrganicsFunctions<S, D>::linear_interp(const ScalarX &x0, const ScalarX &x1,
+KOKKOS_INLINE_FUNCTION ScalarX marineOrganicsFunctions<S, D>::linear_interp(const ScalarX &x0,
+                                                                            const ScalarX &x1,
                                                                             const ScalarT &t) {
   return (1 - t) * x0 + t * x1;
 } // linear_interp
 
 // -------------------------------------------------------------------------------------------
 template <typename S, typename D>
-void marineOrganicsFunctions<S, D>::perform_time_interpolation(const marineOrganicsTimeState &time_state,
-                                                               const marineOrganicsInput &data_beg,
-                                                               const marineOrganicsInput &data_end,
-                                                               const marineOrganicsOutput &data_out) {
+void marineOrganicsFunctions<S, D>::perform_time_interpolation(
+    const marineOrganicsTimeState &time_state, const marineOrganicsInput &data_beg,
+    const marineOrganicsInput &data_end, const marineOrganicsOutput &data_out) {
   using ExeSpace = typename KT::ExeSpace;
   using ESU      = ekat::ExeSpaceUtils<ExeSpace>;
 
@@ -227,13 +230,13 @@ void marineOrganicsFunctions<S, D>::marineOrganics_main(const marineOrganicsTime
   // time of the month, so it can be done ONCE per month, *outside*
   // marineOrganics_main (when updating the beg/end states, reading them from
   // file).
-  EKAT_REQUIRE_MSG(data_end.data.ncols == data_out.ncols, "Error! Horizontal interpolation is performed *before* "
-                                                          "calling marineOrganics_main,\n"
-                                                          "       marineOrganicsInput and marineOrganicsOutput data "
-                                                          "structs must have the "
-                                                          "same number columns "
-                                                              << data_end.data.ncols << "  " << data_out.ncols
-                                                              << ".\n");
+  EKAT_REQUIRE_MSG(data_end.data.ncols == data_out.ncols,
+                   "Error! Horizontal interpolation is performed *before* "
+                   "calling marineOrganics_main,\n"
+                   "       marineOrganicsInput and marineOrganicsOutput data "
+                   "structs must have the "
+                   "same number columns "
+                       << data_end.data.ncols << "  " << data_out.ncols << ".\n");
 
   // Step 1. Perform time interpolation
   perform_time_interpolation(time_state, data_beg, data_end, data_out);
@@ -243,14 +246,16 @@ void marineOrganicsFunctions<S, D>::marineOrganics_main(const marineOrganicsTime
 template <typename S, typename D>
 void marineOrganicsFunctions<S, D>::init_marine_organics_file_read(
     const int &ncol, const std::vector<std::string> &field_name, const std::string &dim_name1,
-    const std::shared_ptr<const AbstractGrid> &grid, const std::string &data_file, const std::string &mapping_file,
+    const std::shared_ptr<const AbstractGrid> &grid, const std::string &data_file,
+    const std::string &mapping_file,
     // output
     std::shared_ptr<AbstractRemapper> &marineOrganicsHorizInterp, marineOrganicsInput &data_start_,
     marineOrganicsInput &data_end_, marineOrganicsData &data_out_,
     std::shared_ptr<AtmosphereInput> &marineOrganicsDataReader) {
   // Init horizontal remap
 
-  marineOrganicsHorizInterp = create_horiz_remapper(grid, data_file, mapping_file, field_name, dim_name1);
+  marineOrganicsHorizInterp =
+      create_horiz_remapper(grid, data_file, mapping_file, field_name, dim_name1);
 
   // Initialize the size of start/end/out data structures
   data_start_ = marineOrganicsInput(ncol, field_name.size());
diff --git i/components/eamxx/src/physics/mam/readfiles/photo_table_utils.cpp w/components/eamxx/src/physics/mam/readfiles/photo_table_utils.cpp
index ce2cf45b5d..abb0de5b80 100644
--- i/components/eamxx/src/physics/mam/readfiles/photo_table_utils.cpp
+++ w/components/eamxx/src/physics/mam/readfiles/photo_table_utils.cpp
@@ -19,21 +19,24 @@ std::vector<Real> populate_etfphot_from_e3sm_case() {
   // We obtained these values from an e3sm simulations.
   // We should only use this function on Host.
   std::vector<Real> etfphot_data = {
-      7.5691227E+11, 8.6525905E+11, 1.0355749E+12, 1.1846288E+12, 2.1524405E+12, 3.2362584E+12, 3.7289849E+12,
-      4.4204330E+12, 4.6835350E+12, 6.1217728E+12, 4.5575051E+12, 5.3491446E+12, 4.7016063E+12, 5.4281722E+12,
-      4.5023968E+12, 6.8931981E+12, 6.2012647E+12, 6.1430771E+12, 5.7820385E+12, 7.6770646E+12, 1.3966509E+13,
-      1.2105348E+13, 2.8588980E+13, 3.2160821E+13, 2.4978066E+13, 2.7825401E+13, 2.3276451E+13, 3.6343684E+13,
-      6.1787886E+13, 7.8009914E+13, 7.6440824E+13, 7.6291458E+13, 9.4645085E+13, 1.0124628E+14, 1.0354111E+14,
-      1.0999650E+14, 1.0889946E+14, 1.1381912E+14, 1.3490042E+14, 1.5941519E+14, 1.4983265E+14, 1.5184267E+14,
-      1.5991420E+14, 1.6976697E+14, 1.8771840E+14, 1.6434367E+14, 1.8371960E+14, 2.1966369E+14, 1.9617879E+14,
-      2.2399700E+14, 1.8429912E+14, 2.0129736E+14, 2.0541588E+14, 2.4334962E+14, 3.5077122E+14, 3.4517894E+14,
-      3.5749668E+14, 3.6624304E+14, 3.4975113E+14, 3.5566025E+14, 4.2825273E+14, 4.8406375E+14, 4.9511159E+14,
-      5.2695368E+14, 5.2401611E+14, 5.0877746E+14, 4.8780853E+14};
+      7.5691227E+11, 8.6525905E+11, 1.0355749E+12, 1.1846288E+12, 2.1524405E+12, 3.2362584E+12,
+      3.7289849E+12, 4.4204330E+12, 4.6835350E+12, 6.1217728E+12, 4.5575051E+12, 5.3491446E+12,
+      4.7016063E+12, 5.4281722E+12, 4.5023968E+12, 6.8931981E+12, 6.2012647E+12, 6.1430771E+12,
+      5.7820385E+12, 7.6770646E+12, 1.3966509E+13, 1.2105348E+13, 2.8588980E+13, 3.2160821E+13,
+      2.4978066E+13, 2.7825401E+13, 2.3276451E+13, 3.6343684E+13, 6.1787886E+13, 7.8009914E+13,
+      7.6440824E+13, 7.6291458E+13, 9.4645085E+13, 1.0124628E+14, 1.0354111E+14, 1.0999650E+14,
+      1.0889946E+14, 1.1381912E+14, 1.3490042E+14, 1.5941519E+14, 1.4983265E+14, 1.5184267E+14,
+      1.5991420E+14, 1.6976697E+14, 1.8771840E+14, 1.6434367E+14, 1.8371960E+14, 2.1966369E+14,
+      1.9617879E+14, 2.2399700E+14, 1.8429912E+14, 2.0129736E+14, 2.0541588E+14, 2.4334962E+14,
+      3.5077122E+14, 3.4517894E+14, 3.5749668E+14, 3.6624304E+14, 3.4975113E+14, 3.5566025E+14,
+      4.2825273E+14, 4.8406375E+14, 4.9511159E+14, 5.2695368E+14, 5.2401611E+14, 5.0877746E+14,
+      4.8780853E+14};
   return etfphot_data;
 }
 
 // This version uses eamxx_scorpio_interface to read netcdf files.
-mam4::mo_photo::PhotoTableData read_photo_table(const std::string &rsf_file, const std::string &xs_long_file) {
+mam4::mo_photo::PhotoTableData read_photo_table(const std::string &rsf_file,
+                                                const std::string &xs_long_file) {
   // set up the lng_indexer and pht_alias_mult_1 views based on our
   // (hardwired) chemical mechanism
   HostViewInt1D lng_indexer_h("lng_indexer", phtcnt);
@@ -56,7 +59,8 @@ mam4::mo_photo::PhotoTableData read_photo_table(const std::string &rsf_file, con
   int numj                 = 1;
   lng_indexer_h(0)         = 0;
   // allocate the photolysis table
-  auto table = mam4::mo_photo::create_photo_table_data(nw, nt, np_xs, numj, nump, numsza, numcolo3, numalb);
+  auto table =
+      mam4::mo_photo::create_photo_table_data(nw, nt, np_xs, numj, nump, numsza, numcolo3, numalb);
 
   // allocate host views for table data
   auto rsf_tab_h = Kokkos::create_mirror_view(table.rsf_tab);
@@ -119,17 +123,21 @@ mam4::mo_photo::PhotoTableData read_photo_table(const std::string &rsf_file, con
 
   // compute gradients (on device)
   Kokkos::parallel_for(
-      "del_p", nump - 1,
-      KOKKOS_LAMBDA(int i) { table.del_p(i) = 1.0 / haero::abs(table.press(i) - table.press(i + 1)); });
+      "del_p", nump - 1, KOKKOS_LAMBDA(int i) {
+        table.del_p(i) = 1.0 / haero::abs(table.press(i) - table.press(i + 1));
+      });
   Kokkos::parallel_for(
-      "del_sza", numsza - 1, KOKKOS_LAMBDA(int i) { table.del_sza(i) = 1.0 / (table.sza(i + 1) - table.sza(i)); });
+      "del_sza", numsza - 1,
+      KOKKOS_LAMBDA(int i) { table.del_sza(i) = 1.0 / (table.sza(i + 1) - table.sza(i)); });
   Kokkos::parallel_for(
-      "del_alb", numalb - 1, KOKKOS_LAMBDA(int i) { table.del_alb(i) = 1.0 / (table.alb(i + 1) - table.alb(i)); });
+      "del_alb", numalb - 1,
+      KOKKOS_LAMBDA(int i) { table.del_alb(i) = 1.0 / (table.alb(i + 1) - table.alb(i)); });
   Kokkos::parallel_for(
       "del_o3rat", numcolo3 - 1,
       KOKKOS_LAMBDA(int i) { table.del_o3rat(i) = 1.0 / (table.o3rat(i + 1) - table.o3rat(i)); });
   Kokkos::parallel_for(
-      "dprs", np_xs - 1, KOKKOS_LAMBDA(int i) { table.dprs(i) = 1.0 / (table.prs(i) - table.prs(i + 1)); });
+      "dprs", np_xs - 1,
+      KOKKOS_LAMBDA(int i) { table.dprs(i) = 1.0 / (table.prs(i) - table.prs(i + 1)); });
 
   return table;
 }
diff --git i/components/eamxx/src/physics/mam/readfiles/soil_erodibility.hpp w/components/eamxx/src/physics/mam/readfiles/soil_erodibility.hpp
index a4c06a58ed..25110fce41 100644
--- i/components/eamxx/src/physics/mam/readfiles/soil_erodibility.hpp
+++ w/components/eamxx/src/physics/mam/readfiles/soil_erodibility.hpp
@@ -13,24 +13,27 @@ template <typename ScalarType, typename DeviceType> struct soilErodibilityFuncti
   using KT            = KokkosTypes<Device>;
   using const_view_1d = typename KT::template view_1d<const Real>;
 
-  static std::shared_ptr<AbstractRemapper> create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid,
-                                                                 const std::string &soilErodibility_data_file,
-                                                                 const std::string &map_file,
-                                                                 const std::string &field_name,
-                                                                 const std::string &dim_name1);
+  static std::shared_ptr<AbstractRemapper>
+  create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid,
+                        const std::string &soilErodibility_data_file, const std::string &map_file,
+                        const std::string &field_name, const std::string &dim_name1);
 
-  static std::shared_ptr<AtmosphereInput> create_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
-                                                             const std::string &data_file);
+  static std::shared_ptr<AtmosphereInput>
+  create_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
+                     const std::string &data_file);
 
-  static void update_soil_erodibility_data_from_file(std::shared_ptr<AtmosphereInput> &scorpio_reader,
-                                                     AbstractRemapper &horiz_interp, const_view_1d &input);
+  static void
+  update_soil_erodibility_data_from_file(std::shared_ptr<AtmosphereInput> &scorpio_reader,
+                                         AbstractRemapper &horiz_interp, const_view_1d &input);
 
-  static void init_soil_erodibility_file_read(const int ncol, const std::string field_name, const std::string dim_name1,
-                                              const std::shared_ptr<const AbstractGrid> &grid,
-                                              const std::string &data_file, const std::string &mapping_file,
-                                              // output
-                                              std::shared_ptr<AbstractRemapper> &SoilErodibilityHorizInterp,
-                                              std::shared_ptr<AtmosphereInput> &SoilErodibilityDataReader);
+  static void
+  init_soil_erodibility_file_read(const int ncol, const std::string field_name,
+                                  const std::string dim_name1,
+                                  const std::shared_ptr<const AbstractGrid> &grid,
+                                  const std::string &data_file, const std::string &mapping_file,
+                                  // output
+                                  std::shared_ptr<AbstractRemapper> &SoilErodibilityHorizInterp,
+                                  std::shared_ptr<AtmosphereInput> &SoilErodibilityDataReader);
 
 }; // struct soilErodilityFunctions
 
diff --git i/components/eamxx/src/physics/mam/readfiles/soil_erodibility_impl.hpp w/components/eamxx/src/physics/mam/readfiles/soil_erodibility_impl.hpp
index c21c7fce6e..6f3f96101c 100644
--- i/components/eamxx/src/physics/mam/readfiles/soil_erodibility_impl.hpp
+++ w/components/eamxx/src/physics/mam/readfiles/soil_erodibility_impl.hpp
@@ -10,10 +10,9 @@ namespace scream {
 namespace soil_erodibility {
 
 template <typename S, typename D>
-std::shared_ptr<AbstractRemapper>
-soilErodibilityFunctions<S, D>::create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid,
-                                                      const std::string &data_file, const std::string &map_file,
-                                                      const std::string &field_name, const std::string &dim_name1) {
+std::shared_ptr<AbstractRemapper> soilErodibilityFunctions<S, D>::create_horiz_remapper(
+    const std::shared_ptr<const AbstractGrid> &model_grid, const std::string &data_file,
+    const std::string &map_file, const std::string &field_name, const std::string &dim_name1) {
   using namespace ShortFieldTagsNames;
 
   scorpio::register_file(data_file, scorpio::Read);
@@ -29,12 +28,14 @@ soilErodibilityFunctions<S, D>::create_horiz_remapper(const std::shared_ptr<cons
   const int ncols_model = model_grid->get_num_global_dofs();
   std::shared_ptr<AbstractRemapper> remapper;
   if (ncols_data == ncols_model) {
-    remapper = std::make_shared<IdentityRemapper>(horiz_interp_tgt_grid, IdentityRemapper::SrcAliasTgt);
+    remapper =
+        std::make_shared<IdentityRemapper>(horiz_interp_tgt_grid, IdentityRemapper::SrcAliasTgt);
   } else {
-    EKAT_REQUIRE_MSG(ncols_data <= ncols_model, "Error! We do not allow to coarsen soil erodibility "
-                                                "data to fit the model. We only allow\n"
-                                                "       soil erodibility data to be at the same or "
-                                                "coarser resolution as the model.\n");
+    EKAT_REQUIRE_MSG(ncols_data <= ncols_model,
+                     "Error! We do not allow to coarsen soil erodibility "
+                     "data to fit the model. We only allow\n"
+                     "       soil erodibility data to be at the same or "
+                     "coarser resolution as the model.\n");
     // We must have a valid map file
     EKAT_REQUIRE_MSG(map_file != "", "ERROR: soil erodibility data is on a different grid "
                                      "than the model one,\n"
@@ -64,9 +65,8 @@ soilErodibilityFunctions<S, D>::create_horiz_remapper(const std::shared_ptr<cons
 
 // -------------------------------------------------------------------------------------------
 template <typename S, typename D>
-std::shared_ptr<AtmosphereInput>
-soilErodibilityFunctions<S, D>::create_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
-                                                   const std::string &data_file) {
+std::shared_ptr<AtmosphereInput> soilErodibilityFunctions<S, D>::create_data_reader(
+    const std::shared_ptr<AbstractRemapper> &horiz_remapper, const std::string &data_file) {
   std::vector<Field> io_fields;
   for (int i = 0; i < horiz_remapper->get_num_fields(); ++i) {
     io_fields.push_back(horiz_remapper->get_src_field(i));
@@ -78,7 +78,8 @@ soilErodibilityFunctions<S, D>::create_data_reader(const std::shared_ptr<Abstrac
 // -------------------------------------------------------------------------------------------
 template <typename S, typename D>
 void soilErodibilityFunctions<S, D>::update_soil_erodibility_data_from_file(
-    std::shared_ptr<AtmosphereInput> &scorpio_reader, AbstractRemapper &horiz_interp, const_view_1d &input) {
+    std::shared_ptr<AtmosphereInput> &scorpio_reader, AbstractRemapper &horiz_interp,
+    const_view_1d &input) {
   start_timer("EAMxx::soilErodibility::update_soil_erodibility_data_from_file");
 
   // 1. Read from file
@@ -113,12 +114,14 @@ void soilErodibilityFunctions<S, D>::update_soil_erodibility_data_from_file(
 template <typename S, typename D>
 void soilErodibilityFunctions<S, D>::init_soil_erodibility_file_read(
     const int ncol, const std::string field_name, const std::string dim_name1,
-    const std::shared_ptr<const AbstractGrid> &grid, const std::string &data_file, const std::string &mapping_file,
+    const std::shared_ptr<const AbstractGrid> &grid, const std::string &data_file,
+    const std::string &mapping_file,
     // output
     std::shared_ptr<AbstractRemapper> &soilErodibilityHorizInterp,
     std::shared_ptr<AtmosphereInput> &soilErodibilityDataReader) {
   // Init horizontal remap
-  soilErodibilityHorizInterp = create_horiz_remapper(grid, data_file, mapping_file, field_name, dim_name1);
+  soilErodibilityHorizInterp =
+      create_horiz_remapper(grid, data_file, mapping_file, field_name, dim_name1);
 
   // Create reader (an AtmosphereInput object)
   soilErodibilityDataReader = create_data_reader(soilErodibilityHorizInterp, data_file);
diff --git i/components/eamxx/src/physics/mam/readfiles/tracer_reader_utils.hpp w/components/eamxx/src/physics/mam/readfiles/tracer_reader_utils.hpp
index 73bebfc1e4..b4b213e022 100644
--- i/components/eamxx/src/physics/mam/readfiles/tracer_reader_utils.hpp
+++ w/components/eamxx/src/physics/mam/readfiles/tracer_reader_utils.hpp
@@ -108,7 +108,8 @@ struct TracerData {
     ncol_  = ncol;
     nlev_  = nlev;
     nvars_ = nvars;
-    EKAT_REQUIRE_MSG(nvars_ <= int(MAX_NVARS_TRACER), "Error! Number of variables is bigger than NVARS_MAXTRACER. \n");
+    EKAT_REQUIRE_MSG(nvars_ <= int(MAX_NVARS_TRACER),
+                     "Error! Number of variables is bigger than NVARS_MAXTRACER. \n");
   }
 
   int ncol_{-1};
@@ -181,7 +182,9 @@ struct TracerData {
 };
 
 KOKKOS_INLINE_FUNCTION
-Real linear_interp(const Real &x0, const Real &x1, const Real &t) { return (1 - t) * x0 + t * x1; } // linear_interp
+Real linear_interp(const Real &x0, const Real &x1, const Real &t) {
+  return (1 - t) * x0 + t * x1;
+} // linear_interp
 
 // time[3]={year,month, day}
 inline util::TimeStamp convert_date(const int date) {
@@ -202,12 +205,14 @@ inline int compute_number_days_from_zero(const util::TimeStamp &ts) {
   return ts.get_year() * 365 + ts.get_month() * 30 + ts.get_day();
 }
 
-inline void create_linoz_chlorine_reader(const std::string &linoz_chlorine_file, const util::TimeStamp &model_time,
+inline void create_linoz_chlorine_reader(const std::string &linoz_chlorine_file,
+                                         const util::TimeStamp &model_time,
                                          const int chlorine_loading_ymd, // in format YYYYMMDD
                                          std::vector<Real> &values, std::vector<int> &time_secs) {
   auto time_stamp_beg = convert_date(chlorine_loading_ymd);
 
-  const int offset_time = compute_number_days_from_zero(time_stamp_beg) - compute_number_days_from_zero(model_time);
+  const int offset_time =
+      compute_number_days_from_zero(time_stamp_beg) - compute_number_days_from_zero(model_time);
   scorpio::register_file(linoz_chlorine_file, scorpio::Read);
   const int nlevs_time = scorpio::get_time_len(linoz_chlorine_file);
   for (int itime = 0; itime < nlevs_time; ++itime) {
@@ -246,10 +251,10 @@ inline void get_time_from_ncfile(const std::string &file_name,
     dates.push_back(date);
   } // end itime
 
-  EKAT_REQUIRE_MSG(cyclical_ymd_index >= 0, "Error! Current model time (" + std::to_string(cyclical_ymd) +
-                                                ") is not within " + "Tracer time period: [" +
-                                                std::to_string(dates[0]) + ", " + "(" +
-                                                std::to_string(dates[nlevs_time - 1]) + ").\n");
+  EKAT_REQUIRE_MSG(cyclical_ymd_index >= 0,
+                   "Error! Current model time (" + std::to_string(cyclical_ymd) +
+                       ") is not within " + "Tracer time period: [" + std::to_string(dates[0]) +
+                       ", " + "(" + std::to_string(dates[nlevs_time - 1]) + ").\n");
   scorpio::release_file(file_name);
 }
 
@@ -294,7 +299,8 @@ inline void setup_tracer_data(TracerData &tracer_data,            // out
     nlevs_data       = scorpio::get_dimlen(trace_data_file, "altitude");
     tracer_file_type = ELEVATED_EMISSIONS;
   }
-  EKAT_REQUIRE_MSG(nlevs_data != -1, "Error: The file does not contain either lev or altitude.   \n");
+  EKAT_REQUIRE_MSG(nlevs_data != -1,
+                   "Error: The file does not contain either lev or altitude.   \n");
 
   const int ncols_data = scorpio::get_dimlen(trace_data_file, "ncol");
 
@@ -343,7 +349,8 @@ inline void setup_tracer_data(TracerData &tracer_data,            // out
       }
     } // end itime
 
-    EKAT_REQUIRE_MSG(cyclical_ymd_index >= 0, "Error! Current model time (" + std::to_string(cyclical_ymd) +
+    EKAT_REQUIRE_MSG(cyclical_ymd_index >= 0, "Error! Current model time (" +
+                                                  std::to_string(cyclical_ymd) +
                                                   ") is not within " + "Tracer time period.\n");
 
     tracer_data.offset_time_index_ = cyclical_ymd_index;
@@ -356,8 +363,9 @@ inline void setup_tracer_data(TracerData &tracer_data,            // out
   tracer_data.has_altitude_ = has_altitude;
 }
 inline std::shared_ptr<AbstractRemapper>
-create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid, const std::string &trace_data_file,
-                      const std::string &map_file, const std::vector<std::string> &var_names, TracerData &tracer_data) {
+create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid,
+                      const std::string &trace_data_file, const std::string &map_file,
+                      const std::vector<std::string> &var_names, TracerData &tracer_data) {
   using namespace ShortFieldTagsNames;
   // We could use model_grid directly if using same num levels,
   // but since shallow clones are cheap, we may as well do it (less lines of
@@ -368,19 +376,22 @@ create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid, con
   const int ncols_model = model_grid->get_num_global_dofs();
   std::shared_ptr<AbstractRemapper> remapper;
   if (tracer_data.ncols_data == ncols_model) {
-    remapper = std::make_shared<IdentityRemapper>(horiz_interp_tgt_grid, IdentityRemapper::SrcAliasTgt);
+    remapper =
+        std::make_shared<IdentityRemapper>(horiz_interp_tgt_grid, IdentityRemapper::SrcAliasTgt);
   } else {
-    EKAT_REQUIRE_MSG(tracer_data.ncols_data <= ncols_model, "Error! We do not allow to coarsen tracer external "
-                                                            "forcing data to fit the "
-                                                            "model. We only allow\n"
-                                                            "       tracer external forcing data to be at the same or "
-                                                            "coarser resolution "
-                                                            "as the model.\n");
+    EKAT_REQUIRE_MSG(tracer_data.ncols_data <= ncols_model,
+                     "Error! We do not allow to coarsen tracer external "
+                     "forcing data to fit the "
+                     "model. We only allow\n"
+                     "       tracer external forcing data to be at the same or "
+                     "coarser resolution "
+                     "as the model.\n");
     // We must have a valid map file
-    EKAT_REQUIRE_MSG(map_file != "", "ERROR: tracer external forcing data is on a different grid than the "
-                                     "model one,\n"
-                                     "       but tracer external forcing data remap file is missing from "
-                                     "tracer external forcing data parameter list.");
+    EKAT_REQUIRE_MSG(map_file != "",
+                     "ERROR: tracer external forcing data is on a different grid than the "
+                     "model one,\n"
+                     "       but tracer external forcing data remap file is missing from "
+                     "tracer external forcing data parameter list.");
 
     remapper = std::make_shared<RefiningRemapperP2P>(horiz_interp_tgt_grid, map_file);
   }
@@ -410,7 +421,8 @@ create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid, con
 } // create_horiz_remapper
 
 inline std::shared_ptr<AtmosphereInput>
-create_tracer_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper, const std::string &tracer_data_file,
+create_tracer_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
+                          const std::string &tracer_data_file,
                           const TracerFileType file_type = NONE) {
   std::vector<Field> io_fields;
   for (int i = 0; i < horiz_remapper->get_num_fields(); ++i) {
@@ -424,7 +436,8 @@ create_tracer_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remappe
     auto horiz_interp_src_grid = io_grid->clone(horiz_remapper->get_src_grid()->name(), true);
     horiz_interp_src_grid->reset_field_tag_name(LEV, "altitude");
     horiz_interp_src_grid->reset_field_tag_name(ILEV, "altitude_int");
-    return std::make_shared<AtmosphereInput>(tracer_data_file, horiz_interp_src_grid, io_fields, true);
+    return std::make_shared<AtmosphereInput>(tracer_data_file, horiz_interp_src_grid, io_fields,
+                                             true);
   } else {
     // We do not need to rename tags in or clone io_grid for other types of
     // files.
@@ -435,7 +448,8 @@ create_tracer_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remappe
 
 inline void update_tracer_data_from_file(const std::shared_ptr<AtmosphereInput> &scorpio_reader,
                                          const int time_index, // zero-based
-                                         AbstractRemapper &tracer_horiz_interp, TracerData &tracer_data) {
+                                         AbstractRemapper &tracer_horiz_interp,
+                                         TracerData &tracer_data) {
   // 1. read from field
   scorpio_reader->read_variables(time_index);
   // 2. Run the horiz remapper (it is a do-nothing op if tracer external forcing
@@ -445,19 +459,22 @@ inline void update_tracer_data_from_file(const std::shared_ptr<AtmosphereInput>
   const int nvars = tracer_data.nvars_;
   //
   for (int i = 0; i < nvars; ++i) {
-    tracer_data.data[TracerDataIndex::END][i] = tracer_horiz_interp.get_tgt_field(i).get_view<Real **>();
+    tracer_data.data[TracerDataIndex::END][i] =
+        tracer_horiz_interp.get_tgt_field(i).get_view<Real **>();
   }
 
   if (tracer_data.file_type == FORMULA_PS) {
     // Recall, the fields are registered in the order: tracers, ps
     // 3. Copy from the tgt field of the remapper into the spa_data
-    tracer_data.ps[TracerDataIndex::END] = tracer_horiz_interp.get_tgt_field(nvars).get_view<Real *>();
+    tracer_data.ps[TracerDataIndex::END] =
+        tracer_horiz_interp.get_tgt_field(nvars).get_view<Real *>();
   }
 
 } // update_tracer_data_from_file
-inline void update_tracer_timestate(const std::shared_ptr<AtmosphereInput> &scorpio_reader, const util::TimeStamp &ts,
-                                    AbstractRemapper &tracer_horiz_interp, TracerTimeState &time_state,
-                                    TracerData &data_tracer) {
+inline void update_tracer_timestate(const std::shared_ptr<AtmosphereInput> &scorpio_reader,
+                                    const util::TimeStamp &ts,
+                                    AbstractRemapper &tracer_horiz_interp,
+                                    TracerTimeState &time_state, TracerData &data_tracer) {
   // Now we check if we have to update the data that changes monthly
   // NOTE:  This means that tracer external forcing assumes monthly data to
   // update.  Not
@@ -475,7 +492,8 @@ inline void update_tracer_timestate(const std::shared_ptr<AtmosphereInput> &scor
 
     // Copy spa_end'data into spa_beg'data, and read in the new spa_end
     for (int ivar = 0; ivar < nvars; ++ivar) {
-      Kokkos::deep_copy(tracer_data[TracerDataIndex::BEG][ivar], tracer_data[TracerDataIndex::END][ivar]);
+      Kokkos::deep_copy(tracer_data[TracerDataIndex::BEG][ivar],
+                        tracer_data[TracerDataIndex::END][ivar]);
     }
 
     if (data_tracer.file_type == FORMULA_PS) {
@@ -499,7 +517,8 @@ inline void update_tracer_timestate(const std::shared_ptr<AtmosphereInput> &scor
 } // END update_tracer_timestate
 
 // This function is based on the SPA::perform_time_interpolation function.
-inline void perform_time_interpolation(const TracerTimeState &time_state, const TracerData &data_tracer) {
+inline void perform_time_interpolation(const TracerTimeState &time_state,
+                                       const TracerData &data_tracer) {
   // NOTE: we *assume* data_beg and data_end have the *same* hybrid v coords.
   //       IF this ever ceases to be the case, you can interp those too.
   // Gather time stamp info
@@ -550,15 +569,15 @@ inline void perform_time_interpolation(const TracerTimeState &time_state, const
         });
         // linoz files do not have ps variables.
         if (ivar == 1 && file_type == FORMULA_PS) {
-          ps[TracerDataIndex::OUT](icol) =
-              linear_interp(ps[TracerDataIndex::BEG](icol), ps[TracerDataIndex::END](icol), delta_t_fraction);
+          ps[TracerDataIndex::OUT](icol) = linear_interp(
+              ps[TracerDataIndex::BEG](icol), ps[TracerDataIndex::END](icol), delta_t_fraction);
         }
       });
   Kokkos::fence();
 } // perform_time_interpolation
 
-inline void compute_source_pressure_levels(const view_1d &ps_src, const view_2d &p_src, const const_view_1d &hyam,
-                                           const const_view_1d &hybm) {
+inline void compute_source_pressure_levels(const view_1d &ps_src, const view_2d &p_src,
+                                           const const_view_1d &hyam, const const_view_1d &hybm) {
   constexpr auto P0        = C::P0;
   const int ncols          = ps_src.extent(0);
   const int num_vert_packs = p_src.extent(1);
@@ -567,8 +586,9 @@ inline void compute_source_pressure_levels(const view_1d &ps_src, const view_2d
   Kokkos::parallel_for(
       "tracer_compute_p_src_loop", policy, KOKKOS_LAMBDA(const Team &team) {
         const int icol = team.league_rank();
-        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_vert_packs),
-                             [&](const int k) { p_src(icol, k) = ps_src(icol) * hybm(k) + P0 * hyam(k); });
+        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_vert_packs), [&](const int k) {
+          p_src(icol, k) = ps_src(icol) * hybm(k) + P0 * hyam(k);
+        });
       });
 } // compute_source_pressure_levels
 
@@ -581,7 +601,8 @@ inline void perform_vertical_interpolation(const view_2d &p_src_c, const const_v
   const int num_vars = input.nvars_;
   // make a local copy of output
   view_2d output_local[MAX_NVARS_TRACER];
-  EKAT_REQUIRE_MSG(num_vars <= int(MAX_NVARS_TRACER), "Error! Number of variables is bigger than NVARS_MAXTRACER. \n");
+  EKAT_REQUIRE_MSG(num_vars <= int(MAX_NVARS_TRACER),
+                   "Error! Number of variables is bigger than NVARS_MAXTRACER. \n");
   for (int ivar = 0; ivar < num_vars; ++ivar) {
     // At this stage, begin/end must have the same horiz dimensions
     EKAT_REQUIRE(input.ncol_ == output[ivar].extent_int(0));
@@ -603,13 +624,14 @@ inline void perform_vertical_interpolation(const view_2d &p_src_c, const const_v
         const auto dataout         = output_local[ivar];
         const auto dataout_at_icol = ekat::subview(dataout, icol);
 
-        mam4::vertical_interpolation::vert_interp(team, levsiz, pver, pin_at_icol, pmid_at_icol, datain_at_icol,
-                                                  dataout_at_icol);
+        mam4::vertical_interpolation::vert_interp(team, levsiz, pver, pin_at_icol, pmid_at_icol,
+                                                  datain_at_icol, dataout_at_icol);
       });
 }
 
-inline void perform_vertical_interpolation(const const_view_1d &altitude_int, const const_view_2d &zi,
-                                           const TracerData &input, const view_2d output[]) {
+inline void perform_vertical_interpolation(const const_view_1d &altitude_int,
+                                           const const_view_2d &zi, const TracerData &input,
+                                           const view_2d output[]) {
   EKAT_REQUIRE_MSG(input.file_type == ELEVATED_EMISSIONS,
                    "Error! vertical interpolation only with altitude variable. \n");
   const int ncols                   = input.ncol_;
@@ -628,7 +650,8 @@ inline void perform_vertical_interpolation(const const_view_1d &altitude_int, co
 
   // make a local copy of output
   view_2d output_local[MAX_NVARS_TRACER];
-  EKAT_REQUIRE_MSG(num_vars <= int(MAX_NVARS_TRACER), "Error! Number of variables is bigger than NVARS_MAXTRACER. \n");
+  EKAT_REQUIRE_MSG(num_vars <= int(MAX_NVARS_TRACER),
+                   "Error! Number of variables is bigger than NVARS_MAXTRACER. \n");
   for (int ivar = 0; ivar < num_vars; ++ivar) {
     // At this stage, begin/end must have the same horiz dimensions
     EKAT_REQUIRE(input.ncol_ == output[ivar].extent_int(0));
@@ -650,7 +673,8 @@ inline void perform_vertical_interpolation(const const_view_1d &altitude_int, co
           trg_x[pverp - i - 1] = m2km * zi(icol, i);
         }
         team.team_barrier();
-        mam4::vertical_interpolation::rebin(team, nsrc, num_vertical_lev_target, src_x, trg_x, src, trg);
+        mam4::vertical_interpolation::rebin(team, nsrc, num_vertical_lev_target, src_x, trg_x, src,
+                                            trg);
       });
 }
 
diff --git i/components/eamxx/src/physics/mam/srf_emission.hpp w/components/eamxx/src/physics/mam/srf_emission.hpp
index 17451b5f1c..d46ae34a9e 100644
--- i/components/eamxx/src/physics/mam/srf_emission.hpp
+++ w/components/eamxx/src/physics/mam/srf_emission.hpp
@@ -59,14 +59,14 @@ template <typename ScalarType, typename DeviceType> struct srfEmissFunctions {
    */
   // Surface emissions routines
   template <std::size_t numSectors>
-  static std::shared_ptr<AbstractRemapper>
-  create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid, const std::string &srfEmiss_data_file,
-                        const std::array<std::string, numSectors> &field_names, const std::string &map_file);
+  static std::shared_ptr<AbstractRemapper> create_horiz_remapper(
+      const std::shared_ptr<const AbstractGrid> &model_grid, const std::string &srfEmiss_data_file,
+      const std::array<std::string, numSectors> &field_names, const std::string &map_file);
 
-  static std::shared_ptr<AbstractRemapper> create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid,
-                                                                 const std::string &srfEmiss_data_file,
-                                                                 const std::vector<std::string> &field_names,
-                                                                 const std::string &map_file);
+  static std::shared_ptr<AbstractRemapper>
+  create_horiz_remapper(const std::shared_ptr<const AbstractGrid> &model_grid,
+                        const std::string &srfEmiss_data_file,
+                        const std::vector<std::string> &field_names, const std::string &map_file);
 
   static std::shared_ptr<AtmosphereInput>
   create_srfEmiss_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
@@ -78,35 +78,40 @@ template <typename ScalarType, typename DeviceType> struct srfEmissFunctions {
   static void update_srfEmiss_data_from_file(std::shared_ptr<AtmosphereInput> &scorpio_reader,
                                              const util::TimeStamp &ts,
                                              const int time_index, // zero-based
-                                             AbstractRemapper &srfEmiss_horiz_interp, srfEmissInput &srfEmiss_input);
-  static void update_srfEmiss_timestate(std::shared_ptr<AtmosphereInput> &scorpio_reader, const util::TimeStamp &ts,
-                                        AbstractRemapper &srfEmiss_horiz_interp, srfEmissTimeState &time_state,
-                                        srfEmissInput &srfEmiss_beg, srfEmissInput &srfEmiss_end);
+                                             AbstractRemapper &srfEmiss_horiz_interp,
+                                             srfEmissInput &srfEmiss_input);
+  static void update_srfEmiss_timestate(std::shared_ptr<AtmosphereInput> &scorpio_reader,
+                                        const util::TimeStamp &ts,
+                                        AbstractRemapper &srfEmiss_horiz_interp,
+                                        srfEmissTimeState &time_state, srfEmissInput &srfEmiss_beg,
+                                        srfEmissInput &srfEmiss_end);
 
   // The following three are called during srfEmiss_main
-  static void perform_time_interpolation(const srfEmissTimeState &time_state, const srfEmissInput &data_beg,
-                                         const srfEmissInput &data_end, const srfEmissOutput &data_out);
+  static void perform_time_interpolation(const srfEmissTimeState &time_state,
+                                         const srfEmissInput &data_beg,
+                                         const srfEmissInput &data_end,
+                                         const srfEmissOutput &data_out);
 
   // Performs convex interpolation of x0 and x1 at point t
   template <typename ScalarX, typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarX linear_interp(const ScalarX &x0, const ScalarX &x1, const ScalarT &t);
+  KOKKOS_INLINE_FUNCTION static ScalarX linear_interp(const ScalarX &x0, const ScalarX &x1,
+                                                      const ScalarT &t);
   template <std::size_t numSectors>
-  static void
-  init_srf_emiss_objects(const int ncol, const std::shared_ptr<const AbstractGrid> &grid, const std::string &data_file,
-                         const std::array<std::string, numSectors> &sectors, const std::string &srf_map_file,
-                         // output
-                         std::shared_ptr<AbstractRemapper> &SrfEmissHorizInterp, srfEmissInput &SrfEmissData_start,
-                         srfEmissInput &SrfEmissData_end, srfEmissOutput &SrfEmissData_out,
-                         std::shared_ptr<AtmosphereInput> &SrfEmissDataReader);
+  static void init_srf_emiss_objects(
+      const int ncol, const std::shared_ptr<const AbstractGrid> &grid, const std::string &data_file,
+      const std::array<std::string, numSectors> &sectors, const std::string &srf_map_file,
+      // output
+      std::shared_ptr<AbstractRemapper> &SrfEmissHorizInterp, srfEmissInput &SrfEmissData_start,
+      srfEmissInput &SrfEmissData_end, srfEmissOutput &SrfEmissData_out,
+      std::shared_ptr<AtmosphereInput> &SrfEmissDataReader);
 
-  static void init_srf_emiss_objects(const int ncol, const std::shared_ptr<const AbstractGrid> &grid,
-                                     const std::string &data_file, const std::vector<std::string> &sectors,
-                                     const std::string &srf_map_file,
-                                     // output
-                                     std::shared_ptr<AbstractRemapper> &SrfEmissHorizInterp,
-                                     srfEmissInput &SrfEmissData_start, srfEmissInput &SrfEmissData_end,
-                                     srfEmissOutput &SrfEmissData_out,
-                                     std::shared_ptr<AtmosphereInput> &SrfEmissDataReader);
+  static void init_srf_emiss_objects(
+      const int ncol, const std::shared_ptr<const AbstractGrid> &grid, const std::string &data_file,
+      const std::vector<std::string> &sectors, const std::string &srf_map_file,
+      // output
+      std::shared_ptr<AbstractRemapper> &SrfEmissHorizInterp, srfEmissInput &SrfEmissData_start,
+      srfEmissInput &SrfEmissData_end, srfEmissOutput &SrfEmissData_out,
+      std::shared_ptr<AtmosphereInput> &SrfEmissDataReader);
 
 }; // struct srfEmissFunctions
 } // namespace scream::mam_coupling
diff --git i/components/eamxx/src/physics/mam/srf_emission_impl.hpp w/components/eamxx/src/physics/mam/srf_emission_impl.hpp
index c58ddcbc98..7cf44d8c68 100644
--- i/components/eamxx/src/physics/mam/srf_emission_impl.hpp
+++ w/components/eamxx/src/physics/mam/srf_emission_impl.hpp
@@ -26,16 +26,19 @@ std::shared_ptr<AbstractRemapper> srfEmissFunctions<S, D>::create_horiz_remapper
   // if the file's grid is same as model's native grid, we identity remapper
   //  (i.e., no interpolation)
   if (ncols_data == ncols_model) {
-    remapper = std::make_shared<IdentityRemapper>(horiz_interp_tgt_grid, IdentityRemapper::SrcAliasTgt);
+    remapper =
+        std::make_shared<IdentityRemapper>(horiz_interp_tgt_grid, IdentityRemapper::SrcAliasTgt);
   } else {
-    EKAT_REQUIRE_MSG(ncols_data <= ncols_model, "Error! We do not allow to coarsen srfEmiss data to fit "
-                                                "the model. We only allow\n"
-                                                "srfEmiss data to be at the same or coarser resolution as "
-                                                "the model.\n");
+    EKAT_REQUIRE_MSG(ncols_data <= ncols_model,
+                     "Error! We do not allow to coarsen srfEmiss data to fit "
+                     "the model. We only allow\n"
+                     "srfEmiss data to be at the same or coarser resolution as "
+                     "the model.\n");
     // We must have a valid map file
-    EKAT_REQUIRE_MSG(map_file != "", "ERROR: srfEmiss data is on a different grid than the model one,\n"
-                                     "but srfEmiss_remap_file is missing from srfEmiss parameter "
-                                     "list.");
+    EKAT_REQUIRE_MSG(map_file != "",
+                     "ERROR: srfEmiss data is on a different grid than the model one,\n"
+                     "but srfEmiss_remap_file is missing from srfEmiss parameter "
+                     "list.");
 
     remapper = std::make_shared<RefiningRemapperP2P>(horiz_interp_tgt_grid, map_file);
   }
@@ -65,9 +68,9 @@ std::shared_ptr<AbstractRemapper> srfEmissFunctions<S, D>::create_horiz_remapper
 } // create_horiz_remapper
 
 template <typename S, typename D>
-std::shared_ptr<AtmosphereInput>
-srfEmissFunctions<S, D>::create_srfEmiss_data_reader(const std::shared_ptr<AbstractRemapper> &horiz_remapper,
-                                                     const std::string &srfEmiss_data_file) {
+std::shared_ptr<AtmosphereInput> srfEmissFunctions<S, D>::create_srfEmiss_data_reader(
+    const std::shared_ptr<AbstractRemapper> &horiz_remapper,
+    const std::string &srfEmiss_data_file) {
   std::vector<Field> field_emiss_sectors;
   for (int i = 0; i < horiz_remapper->get_num_fields(); ++i) {
     field_emiss_sectors.push_back(horiz_remapper->get_src_field(i));
@@ -78,14 +81,16 @@ srfEmissFunctions<S, D>::create_srfEmiss_data_reader(const std::shared_ptr<Abstr
 
 template <typename S, typename D>
 template <typename ScalarX, typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarX srfEmissFunctions<S, D>::linear_interp(const ScalarX &x0, const ScalarX &x1,
+KOKKOS_INLINE_FUNCTION ScalarX srfEmissFunctions<S, D>::linear_interp(const ScalarX &x0,
+                                                                      const ScalarX &x1,
                                                                       const ScalarT &t) {
   return (1 - t) * x0 + t * x1;
 } // linear_interp
 
 template <typename S, typename D>
 void srfEmissFunctions<S, D>::perform_time_interpolation(const srfEmissTimeState &time_state,
-                                                         const srfEmissInput &data_beg, const srfEmissInput &data_end,
+                                                         const srfEmissInput &data_beg,
+                                                         const srfEmissInput &data_end,
                                                          const srfEmissOutput &data_out) {
   // NOTE: we *assume* data_beg and data_end have the *same* hybrid v coords.
   //       IF this ever ceases to be the case, you can interp those too.
@@ -135,8 +140,10 @@ void srfEmissFunctions<S, D>::perform_time_interpolation(const srfEmissTimeState
 } // perform_time_interpolation
 
 template <typename S, typename D>
-void srfEmissFunctions<S, D>::srfEmiss_main(const srfEmissTimeState &time_state, const srfEmissInput &data_beg,
-                                            const srfEmissInput &data_end, const srfEmissOutput &data_out) {
+void srfEmissFunctions<S, D>::srfEmiss_main(const srfEmissTimeState &time_state,
+                                            const srfEmissInput &data_beg,
+                                            const srfEmissInput &data_end,
+                                            const srfEmissOutput &data_out) {
   // Beg/End/Tmp month must have all sizes matching
 
   EKAT_REQUIRE_MSG(data_end.data.ncols == data_beg.data.ncols,
@@ -157,11 +164,10 @@ void srfEmissFunctions<S, D>::srfEmiss_main(const srfEmissTimeState &time_state,
 } // srfEmiss_main
 
 template <typename S, typename D>
-void srfEmissFunctions<S, D>::update_srfEmiss_data_from_file(std::shared_ptr<AtmosphereInput> &scorpio_reader,
-                                                             const util::TimeStamp &ts,
-                                                             const int time_index, // zero-based
-                                                             AbstractRemapper &srfEmiss_horiz_interp,
-                                                             srfEmissInput &srfEmiss_input) {
+void srfEmissFunctions<S, D>::update_srfEmiss_data_from_file(
+    std::shared_ptr<AtmosphereInput> &scorpio_reader, const util::TimeStamp &ts,
+    const int time_index, // zero-based
+    AbstractRemapper &srfEmiss_horiz_interp, srfEmissInput &srfEmiss_input) {
   using namespace ShortFieldTagsNames;
 
   start_timer("EAMxx::srfEmiss::update_srfEmiss_data_from_file");
@@ -198,11 +204,10 @@ void srfEmissFunctions<S, D>::update_srfEmiss_data_from_file(std::shared_ptr<Atm
 } // END update_srfEmiss_data_from_file
 
 template <typename S, typename D>
-void srfEmissFunctions<S, D>::update_srfEmiss_timestate(std::shared_ptr<AtmosphereInput> &scorpio_reader,
-                                                        const util::TimeStamp &ts,
-                                                        AbstractRemapper &srfEmiss_horiz_interp,
-                                                        srfEmissTimeState &time_state, srfEmissInput &srfEmiss_beg,
-                                                        srfEmissInput &srfEmiss_end) {
+void srfEmissFunctions<S, D>::update_srfEmiss_timestate(
+    std::shared_ptr<AtmosphereInput> &scorpio_reader, const util::TimeStamp &ts,
+    AbstractRemapper &srfEmiss_horiz_interp, srfEmissTimeState &time_state,
+    srfEmissInput &srfEmiss_beg, srfEmissInput &srfEmiss_end) {
   // Now we check if we have to update the data that changes monthly
   // NOTE:  This means that srfEmiss assumes monthly data to update.  Not
   //        any other frequency.
@@ -224,21 +229,20 @@ void srfEmissFunctions<S, D>::update_srfEmiss_timestate(std::shared_ptr<Atmosphe
     //       to be assigned.  A timestep greater than a month is very unlikely
     //       so we will proceed.
     int next_month = (time_state.current_month + 1) % 12;
-    update_srfEmiss_data_from_file(scorpio_reader, ts, next_month, srfEmiss_horiz_interp, srfEmiss_end);
+    update_srfEmiss_data_from_file(scorpio_reader, ts, next_month, srfEmiss_horiz_interp,
+                                   srfEmiss_end);
   }
 
 } // END updata_srfEmiss_timestate
 
 template <typename S, typename D>
-void srfEmissFunctions<S, D>::init_srf_emiss_objects(const int ncol, const std::shared_ptr<const AbstractGrid> &grid,
-                                                     const std::string &data_file,
-                                                     const std::vector<std::string> &sectors,
-                                                     const std::string &srf_map_file,
-                                                     // output
-                                                     std::shared_ptr<AbstractRemapper> &SrfEmissHorizInterp,
-                                                     srfEmissInput &SrfEmissData_start, srfEmissInput &SrfEmissData_end,
-                                                     srfEmissOutput &SrfEmissData_out,
-                                                     std::shared_ptr<AtmosphereInput> &SrfEmissDataReader) {
+void srfEmissFunctions<S, D>::init_srf_emiss_objects(
+    const int ncol, const std::shared_ptr<const AbstractGrid> &grid, const std::string &data_file,
+    const std::vector<std::string> &sectors, const std::string &srf_map_file,
+    // output
+    std::shared_ptr<AbstractRemapper> &SrfEmissHorizInterp, srfEmissInput &SrfEmissData_start,
+    srfEmissInput &SrfEmissData_end, srfEmissOutput &SrfEmissData_out,
+    std::shared_ptr<AtmosphereInput> &SrfEmissDataReader) {
   // Init horizontal remap
   SrfEmissHorizInterp = create_horiz_remapper(grid, data_file, sectors, srf_map_file);
 
diff --git i/components/eamxx/src/physics/ml_correction/eamxx_ml_correction_process_interface.cpp w/components/eamxx/src/physics/ml_correction/eamxx_ml_correction_process_interface.cpp
index c83a65a49d..126d9ae87c 100644
--- i/components/eamxx/src/physics/ml_correction/eamxx_ml_correction_process_interface.cpp
+++ w/components/eamxx/src/physics/ml_correction/eamxx_ml_correction_process_interface.cpp
@@ -107,8 +107,8 @@ void MLCorrection::run_impl(const double dt) {
   const auto &SW_flux_dn      = get_field_out("SW_flux_dn").get_view<Real **, Host>();
   const auto &sfc_flux_sw_net = get_field_out("sfc_flux_sw_net").get_view<Real *, Host>();
   const auto &sfc_flux_lw_dn  = get_field_out("sfc_flux_lw_dn").get_view<Real *, Host>();
-  const auto &u               = get_field_out("horiz_winds").get_component(0).get_view<Real **, Host>();
-  const auto &v               = get_field_out("horiz_winds").get_component(1).get_view<Real **, Host>();
+  const auto &u = get_field_out("horiz_winds").get_component(0).get_view<Real **, Host>();
+  const auto &v = get_field_out("horiz_winds").get_component(1).get_view<Real **, Host>();
 
   // For precipitation adjustment we need to track the change in column integrated 'qv'
   // So we clone the original qv before ML changes the state so we can back out a qv_tend
@@ -130,30 +130,41 @@ void MLCorrection::run_impl(const double dt) {
   // for qv, we need to stride across number of tracers
   pybind11::object ob1 = py_correction.attr("update_fields")(
       pybind11::array_t < Real,
-      pybind11::array::c_style | pybind11::array::forcecast > (m_num_cols * m_num_levs, T_mid.data(), pybind11::str{}),
+      pybind11::array::c_style |
+          pybind11::array::forcecast > (m_num_cols * m_num_levs, T_mid.data(), pybind11::str{}),
       pybind11::array_t < Real,
       pybind11::array::c_style |
-          pybind11::array::forcecast > (m_num_cols * m_num_levs * num_tracers, qv.data(), pybind11::str{}),
-      pybind11::array_t < Real,
-      pybind11::array::c_style | pybind11::array::forcecast > (m_num_cols * m_num_levs, u.data(), pybind11::str{}),
-      pybind11::array_t < Real,
-      pybind11::array::c_style | pybind11::array::forcecast > (m_num_cols * m_num_levs, v.data(), pybind11::str{}),
-      pybind11::array_t < Real,
-      pybind11::array::c_style | pybind11::array::forcecast > (m_num_cols, h_lat.data(), pybind11::str{}),
-      pybind11::array_t < Real,
-      pybind11::array::c_style | pybind11::array::forcecast > (m_num_cols, h_lon.data(), pybind11::str{}),
-      pybind11::array_t < Real,
-      pybind11::array::c_style | pybind11::array::forcecast > (m_num_cols, phis.data(), pybind11::str{}),
+          pybind11::array::forcecast >
+              (m_num_cols * m_num_levs * num_tracers, qv.data(), pybind11::str{}),
       pybind11::array_t < Real,
       pybind11::array::c_style |
-          pybind11::array::forcecast > (m_num_cols * (m_num_levs + 1), SW_flux_dn.data(), pybind11::str{}),
+          pybind11::array::forcecast > (m_num_cols * m_num_levs, u.data(), pybind11::str{}),
       pybind11::array_t < Real,
-      pybind11::array::c_style | pybind11::array::forcecast > (m_num_cols, sfc_alb_dif_vis.data(), pybind11::str{}),
+      pybind11::array::c_style |
+          pybind11::array::forcecast > (m_num_cols * m_num_levs, v.data(), pybind11::str{}),
       pybind11::array_t < Real,
-      pybind11::array::c_style | pybind11::array::forcecast > (m_num_cols, sfc_flux_sw_net.data(), pybind11::str{}),
+      pybind11::array::c_style |
+          pybind11::array::forcecast > (m_num_cols, h_lat.data(), pybind11::str{}),
       pybind11::array_t < Real,
-      pybind11::array::c_style | pybind11::array::forcecast > (m_num_cols, sfc_flux_lw_dn.data(), pybind11::str{}),
-      m_num_cols, m_num_levs, num_tracers, dt, ML_model_tq, ML_model_uv, ML_model_sfc_fluxes, datetime_str);
+      pybind11::array::c_style |
+          pybind11::array::forcecast > (m_num_cols, h_lon.data(), pybind11::str{}),
+      pybind11::array_t < Real,
+      pybind11::array::c_style |
+          pybind11::array::forcecast > (m_num_cols, phis.data(), pybind11::str{}),
+      pybind11::array_t < Real,
+      pybind11::array::c_style | pybind11::array::forcecast > (m_num_cols * (m_num_levs + 1),
+                                                               SW_flux_dn.data(), pybind11::str{}),
+      pybind11::array_t < Real,
+      pybind11::array::c_style |
+          pybind11::array::forcecast > (m_num_cols, sfc_alb_dif_vis.data(), pybind11::str{}),
+      pybind11::array_t < Real,
+      pybind11::array::c_style |
+          pybind11::array::forcecast > (m_num_cols, sfc_flux_sw_net.data(), pybind11::str{}),
+      pybind11::array_t < Real,
+      pybind11::array::c_style |
+          pybind11::array::forcecast > (m_num_cols, sfc_flux_lw_dn.data(), pybind11::str{}),
+      m_num_cols, m_num_levs, num_tracers, dt, ML_model_tq, ML_model_uv, ML_model_sfc_fluxes,
+      datetime_str);
   pybind11::gil_scoped_release no_gil;
   ekat::enable_fpes(fpe_mask);
 
@@ -180,8 +191,8 @@ void MLCorrection::run_impl(const double dt) {
           auto rho_icol              = ekat::subview(pseudo_density, icol);
           Real net_column_moistening = 0;
           // Compute WaterVaporPath Difference
-          // The water vapor path (WVP) is calculated as the integral of d_qv over the vertical column
-          // which is converted to the units of precipitation which are kg/m*m
+          // The water vapor path (WVP) is calculated as the integral of d_qv over the vertical
+          // column which is converted to the units of precipitation which are kg/m*m
           //     WVP = sum( d_qv * pseudo_density / gravity ),
           //       where d_qv = qv_new - qv_old
           //       units sanity check
@@ -192,7 +203,9 @@ void MLCorrection::run_impl(const double dt) {
           // Compute WaterVaporPath Difference
           Kokkos::parallel_reduce(
               Kokkos::TeamVectorRange(team, num_levs),
-              [&](const int &ilev, Real &lsum) { lsum += (qnew_icol(ilev) - qold_icol(ilev)) * rho_icol(ilev) / g; },
+              [&](const int &ilev, Real &lsum) {
+                lsum += (qnew_icol(ilev) - qold_icol(ilev)) * rho_icol(ilev) / g;
+              },
               Kokkos::Sum<Real>(net_column_moistening));
           team.team_barrier();
           // Adjust Precipitation
diff --git i/components/eamxx/src/physics/nudging/eamxx_nudging_process_interface.cpp w/components/eamxx/src/physics/nudging/eamxx_nudging_process_interface.cpp
index ce93b5555d..bde2bbc1c9 100644
--- i/components/eamxx/src/physics/nudging/eamxx_nudging_process_interface.cpp
+++ w/components/eamxx/src/physics/nudging/eamxx_nudging_process_interface.cpp
@@ -12,7 +12,8 @@
 namespace scream {
 
 // =========================================================================================
-Nudging::Nudging(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereProcess(comm, params) {
+Nudging::Nudging(const ekat::Comm &comm, const ekat::ParameterList &params)
+    : AtmosphereProcess(comm, params) {
   m_datafiles = filename_glob(m_params.get<std::vector<std::string>>("nudging_filenames_patterns"));
   m_timescale = m_params.get<int>("nudging_timescale", 0);
 
@@ -20,19 +21,24 @@ Nudging::Nudging(const ekat::Comm &comm, const ekat::ParameterList &params) : At
   m_use_weights             = m_params.get<bool>("use_nudging_weights", false);
   m_skip_vert_interpolation = m_params.get<bool>("skip_vert_interpolation", false);
   // If we are doing horizontal refine-remapping, we need to get the mapfile from user
-  m_refine_remap_file        = m_params.get<std::string>("nudging_refine_remap_mapfile", "no-file-given");
+  m_refine_remap_file = m_params.get<std::string>("nudging_refine_remap_mapfile", "no-file-given");
   m_refine_remap_vert_cutoff = m_params.get<Real>("nudging_refine_remap_vert_cutoff", 0.0);
-  auto src_pres_type         = m_params.get<std::string>("source_pressure_type", "TIME_DEPENDENT_3D_PROFILE");
+  auto src_pres_type =
+      m_params.get<std::string>("source_pressure_type", "TIME_DEPENDENT_3D_PROFILE");
   if (src_pres_type == "TIME_DEPENDENT_3D_PROFILE") {
     m_src_pres_type = TIME_DEPENDENT_3D_PROFILE;
   } else if (src_pres_type == "STATIC_1D_VERTICAL_PROFILE") {
     m_src_pres_type = STATIC_1D_VERTICAL_PROFILE;
-    // Check for a designated source pressure file, default to first nudging data source if not given.
-    m_static_vertical_pressure_file = m_params.get<std::string>("source_pressure_file", m_datafiles[0]);
-    EKAT_REQUIRE_MSG(m_skip_vert_interpolation == false,
-                     "Error! It makes no sense to not interpolate if src press is uniform and constant ");
+    // Check for a designated source pressure file, default to first nudging data source if not
+    // given.
+    m_static_vertical_pressure_file =
+        m_params.get<std::string>("source_pressure_file", m_datafiles[0]);
+    EKAT_REQUIRE_MSG(
+        m_skip_vert_interpolation == false,
+        "Error! It makes no sense to not interpolate if src press is uniform and constant ");
   } else {
-    EKAT_ERROR_MSG("ERROR! Nudging::parameter_list - unsupported source_pressure_type provided.  Current options are "
+    EKAT_ERROR_MSG("ERROR! Nudging::parameter_list - unsupported source_pressure_type provided.  "
+                   "Current options are "
                    "[TIME_DEPENDENT_3D_PROFILE,STATIC_1D_VERTICAL_PROFILE].  Please check");
   }
   int first_file_levs = scorpio::get_dimlen(m_datafiles[0], "lev");
@@ -93,8 +99,9 @@ void Nudging::set_grids(const std::shared_ptr<const GridsManager> grids_manager)
     m_num_src_levs = scorpio::get_dimlen(m_static_vertical_pressure_file, "lev");
   }
   if (m_skip_vert_interpolation) {
-    EKAT_REQUIRE_MSG(m_num_src_levs == m_num_levs, "Error! skip_vert_interpolation requires the vertical level to be "
-                                                       << " the same as model vertical level ");
+    EKAT_REQUIRE_MSG(m_num_src_levs == m_num_levs,
+                     "Error! skip_vert_interpolation requires the vertical level to be "
+                         << " the same as model vertical level ");
   }
 
   /* Check for consistency between nudging files, map file, and remapper */
@@ -107,11 +114,12 @@ void Nudging::set_grids(const std::shared_ptr<const GridsManager> grids_manager)
 
   if (num_cols_src != num_cols_global) {
     // If differing cols, check if remap file is provided
-    EKAT_REQUIRE_MSG(m_refine_remap_file != "no-file-given",
-                     "Error! Nudging::set_grids - the number of columns in the nudging data file "
-                         << std::to_string(num_cols_src) << " does not match the number of columns in the "
-                         << "model grid " << std::to_string(num_cols_global) << ".  Please check the "
-                         << "nudging data file and/or the model grid.");
+    EKAT_REQUIRE_MSG(
+        m_refine_remap_file != "no-file-given",
+        "Error! Nudging::set_grids - the number of columns in the nudging data file "
+            << std::to_string(num_cols_src) << " does not match the number of columns in the "
+            << "model grid " << std::to_string(num_cols_global) << ".  Please check the "
+            << "nudging data file and/or the model grid.");
     // If remap file is provided, check if it is consistent with the nudging data file
     // First get the data from the mapfile
     int num_cols_remap_a = scorpio::get_dimlen(m_refine_remap_file, "n_a");
@@ -119,19 +127,24 @@ void Nudging::set_grids(const std::shared_ptr<const GridsManager> grids_manager)
     // Then, check if n_a (source) and n_b (target) are consistent
     EKAT_REQUIRE_MSG(num_cols_remap_a == num_cols_src,
                      "Error! Nudging::set_grids - the number of columns in the nudging data file "
-                         << std::to_string(num_cols_src) << " does not match the number of columns in the "
+                         << std::to_string(num_cols_src)
+                         << " does not match the number of columns in the "
                          << "mapfile " << std::to_string(num_cols_remap_a) << ".  Please check the "
                          << "nudging data file and/or the mapfile.");
     EKAT_REQUIRE_MSG(num_cols_remap_b == num_cols_global,
                      "Error! Nudging::set_grids - the number of columns in the model grid "
-                         << std::to_string(num_cols_global) << " does not match the number of columns in the "
+                         << std::to_string(num_cols_global)
+                         << " does not match the number of columns in the "
                          << "mapfile " << std::to_string(num_cols_remap_b) << ".  Please check the "
                          << "model grid and/or the mapfile.");
-    EKAT_REQUIRE_MSG(m_use_weights == false,
-                     "Error! Nudging::set_grids - it seems that the user intends to use both nuding "
-                         << "from coarse data as well as weighted nudging simultaneously. This is not supported. "
-                         << "If the user wants to use both at their own risk, the user should edit the source code "
-                         << "by deleting this error message.");
+    EKAT_REQUIRE_MSG(
+        m_use_weights == false,
+        "Error! Nudging::set_grids - it seems that the user intends to use both nuding "
+            << "from coarse data as well as weighted nudging simultaneously. This is not "
+               "supported. "
+            << "If the user wants to use both at their own risk, the user should edit the source "
+               "code "
+            << "by deleting this error message.");
     // If we get here, we are good to go!
     m_refine_remap = true;
   } else {
@@ -150,11 +163,12 @@ void Nudging::set_grids(const std::shared_ptr<const GridsManager> grids_manager)
     }
     // If the user gives us the vertical cutoff, warn them
     if (m_refine_remap_vert_cutoff > 0.0) {
-      m_atm_logger->warn("[Nudging::set_grids] Warning! Non-zero vertical cutoff provided, but it is not needed\n"
-                         " - vertical cutoff: " +
-                         std::to_string(m_refine_remap_vert_cutoff) +
-                         "\n"
-                         " Please, check your settings. This parameter is only needed if we are remapping.");
+      m_atm_logger->warn(
+          "[Nudging::set_grids] Warning! Non-zero vertical cutoff provided, but it is not needed\n"
+          " - vertical cutoff: " +
+          std::to_string(m_refine_remap_vert_cutoff) +
+          "\n"
+          " Please, check your settings. This parameter is only needed if we are remapping.");
     }
     // Set m_refine_remap to false
     m_refine_remap = false;
@@ -287,8 +301,10 @@ void Nudging::initialize_impl(const RunType /* run_type */) {
     create_helper_field("padded_p_mid_tmp", layout_padded, "");
   } else if (m_src_pres_type == STATIC_1D_VERTICAL_PROFILE) {
     // For static 1D profile, we can read p_mid now
-    auto pmid_ext = create_helper_field("p_mid_ext", grid_ext->get_vertical_layout(true), grid_ext->name());
-    AtmosphereInput src_input(m_static_vertical_pressure_file, grid_ext, {pmid_ext.alias("p_levs")}, true);
+    auto pmid_ext =
+        create_helper_field("p_mid_ext", grid_ext->get_vertical_layout(true), grid_ext->name());
+    AtmosphereInput src_input(m_static_vertical_pressure_file, grid_ext, {pmid_ext.alias("p_levs")},
+                              true);
     src_input.read_variables(-1);
 
     // For static 1d profile, p_mid_tmp is an alias of p_mid_ext
@@ -359,8 +375,9 @@ void Nudging::run_impl(const double dt) {
           last_good  = ekat::impl::max(last_good, k);
         }
       }
-      EKAT_KERNEL_REQUIRE_MSG(first_good < nlevs and last_good >= 0,
-                                    "[Nudging] Error! Could not locate a non-masked entry in a column.\n");
+      EKAT_KERNEL_REQUIRE_MSG(
+          first_good < nlevs and last_good >= 0,
+          "[Nudging] Error! Could not locate a non-masked entry in a column.\n");
 
       // Fix near TOM
       for (int k = 0; k < first_good; ++k) {
@@ -526,8 +543,8 @@ void Nudging::run_impl(const double dt) {
 // =========================================================================================
 void Nudging::finalize_impl() { m_time_interp.finalize(); }
 // =========================================================================================
-Field Nudging::create_helper_field(const std::string &name, const FieldLayout &layout, const std::string &grid_name,
-                                   const int ps) {
+Field Nudging::create_helper_field(const std::string &name, const FieldLayout &layout,
+                                   const std::string &grid_name, const int ps) {
   using namespace ekat::units;
 
   // For helper fields we don't bother w/ units, so we set them to non-dimensional
diff --git i/components/eamxx/src/physics/nudging/eamxx_nudging_process_interface.hpp w/components/eamxx/src/physics/nudging/eamxx_nudging_process_interface.hpp
index 31f2f108e1..ce25d5cfad 100644
--- i/components/eamxx/src/physics/nudging/eamxx_nudging_process_interface.hpp
+++ w/components/eamxx/src/physics/nudging/eamxx_nudging_process_interface.hpp
@@ -18,9 +18,11 @@ class Nudging : public AtmosphereProcess {
 public:
   // enum to track how the source pressure levels are defined
   enum SourcePresType {
-    // DEFAULT - source data should include time/spatially varying p_mid with dimensions (time, col, lev)
+    // DEFAULT - source data should include time/spatially varying p_mid with dimensions (time, col,
+    // lev)
     TIME_DEPENDENT_3D_PROFILE,
-    // source data includes p_levs which is a static set of levels in both space and time, with dimensions (lev),
+    // source data includes p_levs which is a static set of levels in both space and time, with
+    // dimensions (lev),
     STATIC_1D_VERTICAL_PROFILE
   };
 
@@ -55,8 +57,8 @@ protected:
   void finalize_impl() override;
 
   // Creates an helper field, not to be shared with the AD's FieldManager
-  Field create_helper_field(const std::string &name, const FieldLayout &layout, const std::string &grid_name,
-                            const int ps = 1);
+  Field create_helper_field(const std::string &name, const FieldLayout &layout,
+                            const std::string &grid_name, const int ps = 1);
 
   // Retrieve a helper field
   Field get_helper_field(const std::string &name) const { return m_helper_fields.at(name); }
diff --git i/components/eamxx/src/physics/nudging/tests/create_map_file.cpp w/components/eamxx/src/physics/nudging/tests/create_map_file.cpp
index 0bf9964dc6..f095379eb8 100644
--- i/components/eamxx/src/physics/nudging/tests/create_map_file.cpp
+++ w/components/eamxx/src/physics/nudging/tests/create_map_file.cpp
@@ -12,7 +12,8 @@ TEST_CASE("create_map_file") {
   const int ngdofs_src = 12;
   const int ngdofs_tgt = 2 * ngdofs_src - 1;
 
-  std::string filename = "map_ncol" + std::to_string(ngdofs_src) + "_to_" + std::to_string(ngdofs_tgt) + ".nc";
+  std::string filename =
+      "map_ncol" + std::to_string(ngdofs_src) + "_to_" + std::to_string(ngdofs_tgt) + ".nc";
 
   // Existing dofs are "copied", added dofs are averaged from neighbors
   const int nnz = ngdofs_src + 2 * (ngdofs_src - 1);
diff --git i/components/eamxx/src/physics/nudging/tests/nudging_tests.cpp w/components/eamxx/src/physics/nudging/tests/nudging_tests.cpp
index 6731582dbc..6a8dc9be63 100644
--- i/components/eamxx/src/physics/nudging/tests/nudging_tests.cpp
+++ w/components/eamxx/src/physics/nudging/tests/nudging_tests.cpp
@@ -10,7 +10,8 @@ using namespace scream;
 
 std::shared_ptr<Nudging> create_nudging(const ekat::Comm &comm, const ekat::ParameterList &params,
                                         const std::shared_ptr<FieldManager> &fm,
-                                        const std::shared_ptr<GridsManager> &gm, const util::TimeStamp &t0) {
+                                        const std::shared_ptr<GridsManager> &gm,
+                                        const util::TimeStamp &t0) {
   auto nudging = std::make_shared<Nudging>(comm, params);
   nudging->set_grids(gm);
   for (const auto &req : nudging->get_required_field_requests()) {
@@ -50,7 +51,8 @@ TEST_CASE("nudging_tests") {
   auto postfix             = ".INSTANT.nsteps_x1.np*." + get_t0().to_string() + ".nc";
   auto nudging_data        = "nudging_data" + postfix;
   auto nudging_data_filled = "nudging_data_filled" + postfix;
-  auto map_file            = "map_ncol" + std::to_string(ngcols_data) + "_to_" + std::to_string(ngcols_fine) + ".nc";
+  auto map_file =
+      "map_ncol" + std::to_string(ngcols_data) + "_to_" + std::to_string(ngcols_fine) + ".nc";
 
   // For grids managers, depending on whether ncols/nlevs match the (coarse)
   // values used to generate the data or are finer
@@ -121,7 +123,8 @@ TEST_CASE("nudging_tests") {
       auto tmp1 = U.clone("");
       auto tmp2 = U.clone("");
 
-      auto check_f = [&](const Field &f, const util::TimeStamp &t_prev, const util::TimeStamp &t_next) {
+      auto check_f = [&](const Field &f, const util::TimeStamp &t_prev,
+                         const util::TimeStamp &t_next) {
         compute_field(tmp1, t_prev, comm, 0);
         compute_field(tmp2, t_next, comm, 0);
         tmp1.update(tmp2, 0.5, 0.5);
@@ -339,7 +342,8 @@ TEST_CASE("nudging_tests") {
         for (int ilev = 0; ilev < nlevs_data; ++ilev) {
           glb_fine_h(icol, ilev) = glb_data_h(icol, ilev);
           if (icol < ngcols_data - 1) {
-            glb_fine_h(ngcols_data + icol, ilev) = (glb_data_h(icol, ilev) + glb_data_h(icol + 1, ilev)) / 2;
+            glb_fine_h(ngcols_data + icol, ilev) =
+                (glb_data_h(icol, ilev) + glb_data_h(icol + 1, ilev)) / 2;
           }
         }
       }
diff --git i/components/eamxx/src/physics/nudging/tests/nudging_tests_helpers.hpp w/components/eamxx/src/physics/nudging/tests/nudging_tests_helpers.hpp
index 1595661d8b..f1ea27e851 100644
--- i/components/eamxx/src/physics/nudging/tests/nudging_tests_helpers.hpp
+++ w/components/eamxx/src/physics/nudging/tests/nudging_tests_helpers.hpp
@@ -62,7 +62,8 @@ std::shared_ptr<FieldManager> create_fm(const std::shared_ptr<const AbstractGrid
   return fm;
 }
 
-void compute_field(Field f, const util::TimeStamp &time, const ekat::Comm &comm, const int num_masked_levs = 0) {
+void compute_field(Field f, const util::TimeStamp &time, const ekat::Comm &comm,
+                   const int num_masked_levs = 0) {
   const auto &fl = f.get_header().get_identifier().get_layout();
 
   const int ncols = fl.dim(0);
@@ -108,8 +109,9 @@ void compute_field(Field f, const util::TimeStamp &time, const ekat::Comm &comm,
   f.get_header().get_tracking().update_time_stamp(time);
 }
 
-void compute_fields(const std::shared_ptr<FieldManager> &fm, const util::TimeStamp &time, const ekat::Comm &comm,
-                    const int num_masked_levs = 0, const bool update_p_mid = true) {
+void compute_fields(const std::shared_ptr<FieldManager> &fm, const util::TimeStamp &time,
+                    const ekat::Comm &comm, const int num_masked_levs = 0,
+                    const bool update_p_mid = true) {
   if (update_p_mid) {
     // Don't mask pressure
     compute_field(fm->get_field("p_mid"), time, comm, 0);
@@ -121,9 +123,10 @@ void compute_fields(const std::shared_ptr<FieldManager> &fm, const util::TimeSta
   fm->get_field("horiz_winds").get_header().get_tracking().update_time_stamp(time);
 }
 
-std::shared_ptr<OutputManager> create_om(const std::string &filename_prefix, const std::shared_ptr<FieldManager> &fm,
-                                         const std::shared_ptr<GridsManager> &gm, const util::TimeStamp &t0,
-                                         const ekat::Comm &comm) {
+std::shared_ptr<OutputManager> create_om(const std::string &filename_prefix,
+                                         const std::shared_ptr<FieldManager> &fm,
+                                         const std::shared_ptr<GridsManager> &gm,
+                                         const util::TimeStamp &t0, const ekat::Comm &comm) {
   using strvec_t = std::vector<std::string>;
 
   // NOTE: ask "real" fp precision, so even when building in double precision
diff --git i/components/eamxx/src/physics/p3/disp/p3_check_values_impl_disp.cpp w/components/eamxx/src/physics/p3/disp/p3_check_values_impl_disp.cpp
index d8b396c1bd..e561436bcf 100644
--- i/components/eamxx/src/physics/p3/disp/p3_check_values_impl_disp.cpp
+++ w/components/eamxx/src/physics/p3/disp/p3_check_values_impl_disp.cpp
@@ -7,12 +7,10 @@ namespace scream {
 namespace p3 {
 
 template <>
-void Functions<Real, DefaultDevice>::check_values_disp(const uview_2d<const Spack> &qv,
-                                                       const uview_2d<const Spack> &temp, const Int &ktop,
-                                                       const Int &kbot, const Int &timestepcount,
-                                                       const bool &force_abort, const Int &source_ind,
-                                                       const uview_2d<const Scalar> &col_loc, const Int &nj,
-                                                       const Int &nk) {
+void Functions<Real, DefaultDevice>::check_values_disp(
+    const uview_2d<const Spack> &qv, const uview_2d<const Spack> &temp, const Int &ktop,
+    const Int &kbot, const Int &timestepcount, const bool &force_abort, const Int &source_ind,
+    const uview_2d<const Scalar> &col_loc, const Int &nj, const Int &nk) {
 
   using ExeSpace    = typename KT::ExeSpace;
   const Int nk_pack = ekat::npack<Spack>(nk);
@@ -22,8 +20,8 @@ void Functions<Real, DefaultDevice>::check_values_disp(const uview_2d<const Spac
       "p3_check_values", policy, KOKKOS_LAMBDA(const MemberType &team) {
         const Int i = team.league_rank();
 
-        check_values(ekat::subview(qv, i), ekat::subview(temp, i), ktop, kbot, timestepcount, force_abort, 900, team,
-                     ekat::subview(col_loc, i));
+        check_values(ekat::subview(qv, i), ekat::subview(temp, i), ktop, kbot, timestepcount,
+                     force_abort, 900, team, ekat::subview(col_loc, i));
       });
 }
 
diff --git i/components/eamxx/src/physics/p3/disp/p3_cloud_sed_impl_disp.cpp w/components/eamxx/src/physics/p3/disp/p3_cloud_sed_impl_disp.cpp
index 9298f8f8a7..cd8e310acb 100644
--- i/components/eamxx/src/physics/p3/disp/p3_cloud_sed_impl_disp.cpp
+++ w/components/eamxx/src/physics/p3/disp/p3_cloud_sed_impl_disp.cpp
@@ -12,12 +12,14 @@ namespace p3 {
 
 template <>
 void Functions<Real, DefaultDevice>::cloud_sedimentation_disp(
-    const uview_2d<Spack> &qc_incld, const uview_2d<const Spack> &rho, const uview_2d<const Spack> &inv_rho,
-    const uview_2d<const Spack> &cld_frac_l, const uview_2d<const Spack> &acn, const uview_2d<const Spack> &inv_dz,
-    const view_dnu_table &dnu, const WorkspaceManager &workspace_mgr, const Int &nj, const Int &nk, const Int &ktop,
-    const Int &kbot, const Int &kdir, const Scalar &dt, const Scalar &inv_dt, const bool &do_predict_nc,
-    const uview_2d<Spack> &qc, const uview_2d<Spack> &nc, const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &mu_c,
-    const uview_2d<Spack> &lamc, const uview_2d<Spack> &qc_tend, const uview_2d<Spack> &nc_tend,
+    const uview_2d<Spack> &qc_incld, const uview_2d<const Spack> &rho,
+    const uview_2d<const Spack> &inv_rho, const uview_2d<const Spack> &cld_frac_l,
+    const uview_2d<const Spack> &acn, const uview_2d<const Spack> &inv_dz,
+    const view_dnu_table &dnu, const WorkspaceManager &workspace_mgr, const Int &nj, const Int &nk,
+    const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt, const Scalar &inv_dt,
+    const bool &do_predict_nc, const uview_2d<Spack> &qc, const uview_2d<Spack> &nc,
+    const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &mu_c, const uview_2d<Spack> &lamc,
+    const uview_2d<Spack> &qc_tend, const uview_2d<Spack> &nc_tend,
     const uview_1d<Scalar> &precip_liq_surf, const uview_1d<bool> &nucleationPossible,
     const uview_1d<bool> &hydrometeorsPresent) {
   using ExeSpace    = typename KT::ExeSpace;
@@ -32,12 +34,13 @@ void Functions<Real, DefaultDevice>::cloud_sedimentation_disp(
           return;
         }
 
-        cloud_sedimentation(ekat::subview(qc_incld, i), ekat::subview(rho, i), ekat::subview(inv_rho, i),
-                            ekat::subview(cld_frac_l, i), ekat::subview(acn, i), ekat::subview(inv_dz, i), dnu, team,
-                            workspace, nk, ktop, kbot, kdir, dt, inv_dt, do_predict_nc, ekat::subview(qc, i),
-                            ekat::subview(nc, i), ekat::subview(nc_incld, i), ekat::subview(mu_c, i),
-                            ekat::subview(lamc, i), ekat::subview(qc_tend, i), ekat::subview(nc_tend, i),
-                            precip_liq_surf(i));
+        cloud_sedimentation(
+            ekat::subview(qc_incld, i), ekat::subview(rho, i), ekat::subview(inv_rho, i),
+            ekat::subview(cld_frac_l, i), ekat::subview(acn, i), ekat::subview(inv_dz, i), dnu,
+            team, workspace, nk, ktop, kbot, kdir, dt, inv_dt, do_predict_nc, ekat::subview(qc, i),
+            ekat::subview(nc, i), ekat::subview(nc_incld, i), ekat::subview(mu_c, i),
+            ekat::subview(lamc, i), ekat::subview(qc_tend, i), ekat::subview(nc_tend, i),
+            precip_liq_surf(i));
       });
 }
 
diff --git i/components/eamxx/src/physics/p3/disp/p3_ice_sed_impl_disp.cpp w/components/eamxx/src/physics/p3/disp/p3_ice_sed_impl_disp.cpp
index 91b086db3a..313ccc0365 100644
--- i/components/eamxx/src/physics/p3/disp/p3_ice_sed_impl_disp.cpp
+++ w/components/eamxx/src/physics/p3/disp/p3_ice_sed_impl_disp.cpp
@@ -7,13 +7,15 @@ namespace p3 {
 
 template <>
 void Functions<Real, DefaultDevice>::ice_sedimentation_disp(
-    const uview_2d<const Spack> &rho, const uview_2d<const Spack> &inv_rho, const uview_2d<const Spack> &rhofaci,
-    const uview_2d<const Spack> &cld_frac_i, const uview_2d<const Spack> &inv_dz, const WorkspaceManager &workspace_mgr,
-    const Int &nj, const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
-    const Scalar &inv_dt, const uview_2d<Spack> &qi, const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &ni,
-    const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &qm, const uview_2d<Spack> &qm_incld,
-    const uview_2d<Spack> &bm, const uview_2d<Spack> &bm_incld, const uview_2d<Spack> &qi_tend,
-    const uview_2d<Spack> &ni_tend, const view_ice_table &ice_table_vals, const uview_1d<Scalar> &precip_ice_surf,
+    const uview_2d<const Spack> &rho, const uview_2d<const Spack> &inv_rho,
+    const uview_2d<const Spack> &rhofaci, const uview_2d<const Spack> &cld_frac_i,
+    const uview_2d<const Spack> &inv_dz, const WorkspaceManager &workspace_mgr, const Int &nj,
+    const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
+    const Scalar &inv_dt, const uview_2d<Spack> &qi, const uview_2d<Spack> &qi_incld,
+    const uview_2d<Spack> &ni, const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &qm,
+    const uview_2d<Spack> &qm_incld, const uview_2d<Spack> &bm, const uview_2d<Spack> &bm_incld,
+    const uview_2d<Spack> &qi_tend, const uview_2d<Spack> &ni_tend,
+    const view_ice_table &ice_table_vals, const uview_1d<Scalar> &precip_ice_surf,
     const uview_1d<bool> &nucleationPossible, const uview_1d<bool> &hydrometeorsPresent,
     const P3Runtime &runtime_options) {
   using ExeSpace    = typename KT::ExeSpace;
@@ -29,21 +31,24 @@ void Functions<Real, DefaultDevice>::ice_sedimentation_disp(
         auto workspace = workspace_mgr.get_workspace(team);
 
         // Ice sedimentation:  (adaptive substepping)
-        ice_sedimentation(ekat::subview(rho, i), ekat::subview(inv_rho, i), ekat::subview(rhofaci, i),
-                          ekat::subview(cld_frac_i, i), ekat::subview(inv_dz, i), team, workspace, nk, ktop, kbot, kdir,
-                          dt, inv_dt, ekat::subview(qi, i), ekat::subview(qi_incld, i), ekat::subview(ni, i),
-                          ekat::subview(ni_incld, i), ekat::subview(qm, i), ekat::subview(qm_incld, i),
-                          ekat::subview(bm, i), ekat::subview(bm_incld, i), ekat::subview(qi_tend, i),
-                          ekat::subview(ni_tend, i), ice_table_vals, precip_ice_surf(i), runtime_options);
+        ice_sedimentation(
+            ekat::subview(rho, i), ekat::subview(inv_rho, i), ekat::subview(rhofaci, i),
+            ekat::subview(cld_frac_i, i), ekat::subview(inv_dz, i), team, workspace, nk, ktop, kbot,
+            kdir, dt, inv_dt, ekat::subview(qi, i), ekat::subview(qi_incld, i),
+            ekat::subview(ni, i), ekat::subview(ni_incld, i), ekat::subview(qm, i),
+            ekat::subview(qm_incld, i), ekat::subview(bm, i), ekat::subview(bm_incld, i),
+            ekat::subview(qi_tend, i), ekat::subview(ni_tend, i), ice_table_vals,
+            precip_ice_surf(i), runtime_options);
       });
 }
 
 template <>
 void Functions<Real, DefaultDevice>::homogeneous_freezing_disp(
-    const uview_2d<const Spack> &T_atm, const uview_2d<const Spack> &inv_exner, const Int &nj, const Int &nk,
-    const Int &ktop, const Int &kbot, const Int &kdir, const uview_2d<Spack> &qc, const uview_2d<Spack> &nc,
-    const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &qi, const uview_2d<Spack> &ni,
-    const uview_2d<Spack> &qm, const uview_2d<Spack> &bm, const uview_2d<Spack> &th_atm,
+    const uview_2d<const Spack> &T_atm, const uview_2d<const Spack> &inv_exner, const Int &nj,
+    const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const uview_2d<Spack> &qc,
+    const uview_2d<Spack> &nc, const uview_2d<Spack> &qr, const uview_2d<Spack> &nr,
+    const uview_2d<Spack> &qi, const uview_2d<Spack> &ni, const uview_2d<Spack> &qm,
+    const uview_2d<Spack> &bm, const uview_2d<Spack> &th_atm,
     const uview_1d<bool> &nucleationPossible, const uview_1d<bool> &hydrometeorsPresent) {
   using ExeSpace    = typename KT::ExeSpace;
   const Int nk_pack = ekat::npack<Spack>(nk);
@@ -57,9 +62,10 @@ void Functions<Real, DefaultDevice>::homogeneous_freezing_disp(
         }
 
         // homogeneous freezing of cloud and rain
-        homogeneous_freezing(ekat::subview(T_atm, i), ekat::subview(inv_exner, i), team, nk, ktop, kbot, kdir,
-                             ekat::subview(qc, i), ekat::subview(nc, i), ekat::subview(qr, i), ekat::subview(nr, i),
-                             ekat::subview(qi, i), ekat::subview(ni, i), ekat::subview(qm, i), ekat::subview(bm, i),
+        homogeneous_freezing(ekat::subview(T_atm, i), ekat::subview(inv_exner, i), team, nk, ktop,
+                             kbot, kdir, ekat::subview(qc, i), ekat::subview(nc, i),
+                             ekat::subview(qr, i), ekat::subview(nr, i), ekat::subview(qi, i),
+                             ekat::subview(ni, i), ekat::subview(qm, i), ekat::subview(bm, i),
                              ekat::subview(th_atm, i));
       });
 }
diff --git i/components/eamxx/src/physics/p3/disp/p3_main_impl_disp.cpp w/components/eamxx/src/physics/p3/disp/p3_main_impl_disp.cpp
index df9923eea5..73cbd52351 100644
--- i/components/eamxx/src/physics/p3/disp/p3_main_impl_disp.cpp
+++ w/components/eamxx/src/physics/p3/disp/p3_main_impl_disp.cpp
@@ -14,26 +14,31 @@ namespace p3 {
 
 template <>
 void Functions<Real, DefaultDevice>::p3_main_init_disp(
-    const Int &nj, const Int &nk_pack, const uview_2d<const Spack> &cld_frac_i, const uview_2d<const Spack> &cld_frac_l,
-    const uview_2d<const Spack> &cld_frac_r, const uview_2d<const Spack> &inv_exner,
-    const uview_2d<const Spack> &th_atm, const uview_2d<const Spack> &dz,
-    const uview_2d<Spack> &diag_equiv_reflectivity, const uview_2d<Spack> &ze_ice, const uview_2d<Spack> &ze_rain,
+    const Int &nj, const Int &nk_pack, const uview_2d<const Spack> &cld_frac_i,
+    const uview_2d<const Spack> &cld_frac_l, const uview_2d<const Spack> &cld_frac_r,
+    const uview_2d<const Spack> &inv_exner, const uview_2d<const Spack> &th_atm,
+    const uview_2d<const Spack> &dz, const uview_2d<Spack> &diag_equiv_reflectivity,
+    const uview_2d<Spack> &ze_ice, const uview_2d<Spack> &ze_rain,
     const uview_2d<Spack> &diag_eff_radius_qc, const uview_2d<Spack> &diag_eff_radius_qi,
     const uview_2d<Spack> &diag_eff_radius_qr, const uview_2d<Spack> &inv_cld_frac_i,
-    const uview_2d<Spack> &inv_cld_frac_l, const uview_2d<Spack> &inv_cld_frac_r, const uview_2d<Spack> &exner,
-    const uview_2d<Spack> &T_atm, const uview_2d<Spack> &qv, const uview_2d<Spack> &inv_dz,
-    const uview_1d<Scalar> &precip_liq_surf, const uview_1d<Scalar> &precip_ice_surf, const uview_2d<Spack> &mu_r,
-    const uview_2d<Spack> &lamr, const uview_2d<Spack> &logn0r, const uview_2d<Spack> &nu, const uview_2d<Spack> &cdist,
-    const uview_2d<Spack> &cdist1, const uview_2d<Spack> &cdistr, const uview_2d<Spack> &qc_incld,
-    const uview_2d<Spack> &qr_incld, const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld,
-    const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &nr_incld, const uview_2d<Spack> &ni_incld,
-    const uview_2d<Spack> &bm_incld, const uview_2d<Spack> &inv_rho, const uview_2d<Spack> &prec,
-    const uview_2d<Spack> &rho, const uview_2d<Spack> &rhofacr, const uview_2d<Spack> &rhofaci,
-    const uview_2d<Spack> &acn, const uview_2d<Spack> &qv_sat_l, const uview_2d<Spack> &qv_sat_i,
-    const uview_2d<Spack> &sup, const uview_2d<Spack> &qv_supersat_i, const uview_2d<Spack> &qtend_ignore,
+    const uview_2d<Spack> &inv_cld_frac_l, const uview_2d<Spack> &inv_cld_frac_r,
+    const uview_2d<Spack> &exner, const uview_2d<Spack> &T_atm, const uview_2d<Spack> &qv,
+    const uview_2d<Spack> &inv_dz, const uview_1d<Scalar> &precip_liq_surf,
+    const uview_1d<Scalar> &precip_ice_surf, const uview_2d<Spack> &mu_r,
+    const uview_2d<Spack> &lamr, const uview_2d<Spack> &logn0r, const uview_2d<Spack> &nu,
+    const uview_2d<Spack> &cdist, const uview_2d<Spack> &cdist1, const uview_2d<Spack> &cdistr,
+    const uview_2d<Spack> &qc_incld, const uview_2d<Spack> &qr_incld,
+    const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld,
+    const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &nr_incld,
+    const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &bm_incld,
+    const uview_2d<Spack> &inv_rho, const uview_2d<Spack> &prec, const uview_2d<Spack> &rho,
+    const uview_2d<Spack> &rhofacr, const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &acn,
+    const uview_2d<Spack> &qv_sat_l, const uview_2d<Spack> &qv_sat_i, const uview_2d<Spack> &sup,
+    const uview_2d<Spack> &qv_supersat_i, const uview_2d<Spack> &qtend_ignore,
     const uview_2d<Spack> &ntend_ignore, const uview_2d<Spack> &mu_c, const uview_2d<Spack> &lamc,
-    const uview_2d<Spack> &rho_qi, const uview_2d<Spack> &qv2qi_depos_tend, const uview_2d<Spack> &precip_total_tend,
-    const uview_2d<Spack> &nevapr, const uview_2d<Spack> &precip_liq_flux, const uview_2d<Spack> &precip_ice_flux) {
+    const uview_2d<Spack> &rho_qi, const uview_2d<Spack> &qv2qi_depos_tend,
+    const uview_2d<Spack> &precip_total_tend, const uview_2d<Spack> &nevapr,
+    const uview_2d<Spack> &precip_liq_flux, const uview_2d<Spack> &precip_ice_flux) {
   using ExeSpace    = typename KT::ExeSpace;
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(nj, nk_pack);
 
@@ -100,8 +105,9 @@ template <>
 Int Functions<Real, DefaultDevice>::p3_main_internal_disp(
     const P3Runtime &runtime_options, const P3PrognosticState &prognostic_state,
     const P3DiagnosticInputs &diagnostic_inputs, const P3DiagnosticOutputs &diagnostic_outputs,
-    const P3Infrastructure &infrastructure, const P3HistoryOnly &history_only, const P3LookupTables &lookup_tables,
-    const P3Temporaries &temporaries, const WorkspaceManager &workspace_mgr, Int nj, Int nk) {
+    const P3Infrastructure &infrastructure, const P3HistoryOnly &history_only,
+    const P3LookupTables &lookup_tables, const P3Temporaries &temporaries,
+    const WorkspaceManager &workspace_mgr, Int nj, Int nk) {
   using ExeSpace = typename KT::ExeSpace;
 
   const Int nk_pack = ekat::npack<Spack>(nk);
@@ -237,35 +243,40 @@ Int Functions<Real, DefaultDevice>::p3_main_internal_disp(
   auto start = std::chrono::steady_clock::now();
 
   // initialize
-  p3_main_init_disp(nj, nk_pack, cld_frac_i, cld_frac_l, cld_frac_r, inv_exner, th, dz, diag_equiv_reflectivity, ze_ice,
-                    ze_rain, diag_eff_radius_qc, diag_eff_radius_qi, diag_eff_radius_qr, inv_cld_frac_i, inv_cld_frac_l,
+  p3_main_init_disp(nj, nk_pack, cld_frac_i, cld_frac_l, cld_frac_r, inv_exner, th, dz,
+                    diag_equiv_reflectivity, ze_ice, ze_rain, diag_eff_radius_qc,
+                    diag_eff_radius_qi, diag_eff_radius_qr, inv_cld_frac_i, inv_cld_frac_l,
                     inv_cld_frac_r, exner, T_atm, qv, inv_dz, diagnostic_outputs.precip_liq_surf,
-                    diagnostic_outputs.precip_ice_surf, mu_r, lamr, logn0r, nu, cdist, cdist1, cdistr, qc_incld,
-                    qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld, bm_incld, inv_rho, prec, rho, rhofacr,
-                    rhofaci, acn, qv_sat_l, qv_sat_i, sup, qv_supersat_i, qtend_ignore, ntend_ignore, mu_c, lamc,
-                    rho_qi, qv2qi_depos_tend, precip_total_tend, nevapr, precip_liq_flux, precip_ice_flux);
+                    diagnostic_outputs.precip_ice_surf, mu_r, lamr, logn0r, nu, cdist, cdist1,
+                    cdistr, qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld,
+                    bm_incld, inv_rho, prec, rho, rhofacr, rhofaci, acn, qv_sat_l, qv_sat_i, sup,
+                    qv_supersat_i, qtend_ignore, ntend_ignore, mu_c, lamc, rho_qi, qv2qi_depos_tend,
+                    precip_total_tend, nevapr, precip_liq_flux, precip_ice_flux);
 
-  p3_main_part1_disp(nj, nk, infrastructure.predictNc, infrastructure.prescribedCCN, infrastructure.dt, pres, dpres, dz,
-                     nc_nuceat_tend, nccn_prescribed, inv_exner, exner, inv_cld_frac_l, inv_cld_frac_i, inv_cld_frac_r,
-                     T_atm, rho, inv_rho, qv_sat_l, qv_sat_i, qv_supersat_i, rhofacr, rhofaci, acn, qv, th, qc, nc, qr,
-                     nr, qi, ni, qm, bm, qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld, bm_incld,
-                     nucleationPossible, hydrometeorsPresent, runtime_options);
+  p3_main_part1_disp(nj, nk, infrastructure.predictNc, infrastructure.prescribedCCN,
+                     infrastructure.dt, pres, dpres, dz, nc_nuceat_tend, nccn_prescribed, inv_exner,
+                     exner, inv_cld_frac_l, inv_cld_frac_i, inv_cld_frac_r, T_atm, rho, inv_rho,
+                     qv_sat_l, qv_sat_i, qv_supersat_i, rhofacr, rhofaci, acn, qv, th, qc, nc, qr,
+                     nr, qi, ni, qm, bm, qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld,
+                     ni_incld, bm_incld, nucleationPossible, hydrometeorsPresent, runtime_options);
 
   // ------------------------------------------------------------------------------------------
   // main k-loop (for processes):
 
   p3_main_part2_disp(
-      nj, nk, runtime_options.max_total_ni, infrastructure.predictNc, infrastructure.prescribedCCN, infrastructure.dt,
-      inv_dt, hetfrz_immersion_nucleation_tend, hetfrz_contact_nucleation_tend, hetfrz_deposition_nucleation_tend,
-      lookup_tables.dnu_table_vals, lookup_tables.ice_table_vals, lookup_tables.collect_table_vals,
-      lookup_tables.revap_table_vals, pres, dpres, dz, nc_nuceat_tend, inv_exner, exner, inv_cld_frac_l, inv_cld_frac_i,
-      inv_cld_frac_r, ni_activated, inv_qc_relvar, cld_frac_i, cld_frac_l, cld_frac_r, qv_prev, t_prev, T_atm, rho,
-      inv_rho, qv_sat_l, qv_sat_i, qv_supersat_i, rhofacr, rhofaci, acn, qv, th, qc, nc, qr, nr, qi, ni, qm, bm,
-      qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld, bm_incld, mu_c, nu, lamc, cdist, cdist1,
-      cdistr, mu_r, lamr, logn0r, qv2qi_depos_tend, precip_total_tend, nevapr, qr_evap_tend, vap_liq_exchange,
-      vap_ice_exchange, liq_ice_exchange, qr2qv_evap, qi2qv_sublim, qc2qr_accret, qc2qr_autoconv, qv2qi_vapdep,
-      qc2qi_berg, qc2qr_ice_shed, qc2qi_collect, qr2qi_collect, qc2qi_hetero_freeze, qr2qi_immers_freeze, qi2qr_melt,
-      pratot, prctot, nucleationPossible, hydrometeorsPresent, runtime_options);
+      nj, nk, runtime_options.max_total_ni, infrastructure.predictNc, infrastructure.prescribedCCN,
+      infrastructure.dt, inv_dt, hetfrz_immersion_nucleation_tend, hetfrz_contact_nucleation_tend,
+      hetfrz_deposition_nucleation_tend, lookup_tables.dnu_table_vals, lookup_tables.ice_table_vals,
+      lookup_tables.collect_table_vals, lookup_tables.revap_table_vals, pres, dpres, dz,
+      nc_nuceat_tend, inv_exner, exner, inv_cld_frac_l, inv_cld_frac_i, inv_cld_frac_r,
+      ni_activated, inv_qc_relvar, cld_frac_i, cld_frac_l, cld_frac_r, qv_prev, t_prev, T_atm, rho,
+      inv_rho, qv_sat_l, qv_sat_i, qv_supersat_i, rhofacr, rhofaci, acn, qv, th, qc, nc, qr, nr, qi,
+      ni, qm, bm, qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld, bm_incld,
+      mu_c, nu, lamc, cdist, cdist1, cdistr, mu_r, lamr, logn0r, qv2qi_depos_tend,
+      precip_total_tend, nevapr, qr_evap_tend, vap_liq_exchange, vap_ice_exchange, liq_ice_exchange,
+      qr2qv_evap, qi2qv_sublim, qc2qr_accret, qc2qr_autoconv, qv2qi_vapdep, qc2qi_berg,
+      qc2qr_ice_shed, qc2qi_collect, qr2qi_collect, qc2qi_hetero_freeze, qr2qi_immers_freeze,
+      qi2qr_melt, pratot, prctot, nucleationPossible, hydrometeorsPresent, runtime_options);
 
   // NOTE: At this point, it is possible to have negative (but small) nc, nr, ni.  This is not
   //       a problem; those values get clipped to zero in the sedimentation section (if necessary).
@@ -279,28 +290,30 @@ Int Functions<Real, DefaultDevice>::p3_main_internal_disp(
   // Sedimentation:
 
   // Cloud sedimentation:  (adaptive substepping)
-  cloud_sedimentation_disp(qc_incld, rho, inv_rho, cld_frac_l, acn, inv_dz, lookup_tables.dnu_table_vals, workspace_mgr,
-                           nj, nk, ktop, kbot, kdir, infrastructure.dt, inv_dt, infrastructure.predictNc, qc, nc,
-                           nc_incld, mu_c, lamc, qc_sed, ntend_ignore, diagnostic_outputs.precip_liq_surf,
+  cloud_sedimentation_disp(qc_incld, rho, inv_rho, cld_frac_l, acn, inv_dz,
+                           lookup_tables.dnu_table_vals, workspace_mgr, nj, nk, ktop, kbot, kdir,
+                           infrastructure.dt, inv_dt, infrastructure.predictNc, qc, nc, nc_incld,
+                           mu_c, lamc, qc_sed, ntend_ignore, diagnostic_outputs.precip_liq_surf,
                            nucleationPossible, hydrometeorsPresent);
 
   // Rain sedimentation:  (adaptive substepping)
   rain_sedimentation_disp(rho, inv_rho, rhofacr, cld_frac_r, inv_dz, qr_incld, workspace_mgr,
-                          lookup_tables.vn_table_vals, lookup_tables.vm_table_vals, nj, nk, ktop, kbot, kdir,
-                          infrastructure.dt, inv_dt, qr, nr, nr_incld, mu_r, lamr, precip_liq_flux, qr_sed,
-                          ntend_ignore, diagnostic_outputs.precip_liq_surf, nucleationPossible, hydrometeorsPresent,
-                          runtime_options);
+                          lookup_tables.vn_table_vals, lookup_tables.vm_table_vals, nj, nk, ktop,
+                          kbot, kdir, infrastructure.dt, inv_dt, qr, nr, nr_incld, mu_r, lamr,
+                          precip_liq_flux, qr_sed, ntend_ignore, diagnostic_outputs.precip_liq_surf,
+                          nucleationPossible, hydrometeorsPresent, runtime_options);
 
   // Ice sedimentation:  (adaptive substepping)
-  ice_sedimentation_disp(rho, inv_rho, rhofaci, cld_frac_i, inv_dz, workspace_mgr, nj, nk, ktop, kbot, kdir,
-                         infrastructure.dt, inv_dt, qi, qi_incld, ni, ni_incld, qm, qm_incld, bm, bm_incld, qi_sed,
-                         ntend_ignore, lookup_tables.ice_table_vals, diagnostic_outputs.precip_ice_surf,
-                         nucleationPossible, hydrometeorsPresent, runtime_options);
+  ice_sedimentation_disp(rho, inv_rho, rhofaci, cld_frac_i, inv_dz, workspace_mgr, nj, nk, ktop,
+                         kbot, kdir, infrastructure.dt, inv_dt, qi, qi_incld, ni, ni_incld, qm,
+                         qm_incld, bm, bm_incld, qi_sed, ntend_ignore, lookup_tables.ice_table_vals,
+                         diagnostic_outputs.precip_ice_surf, nucleationPossible,
+                         hydrometeorsPresent, runtime_options);
 
   // homogeneous freezing f cloud and rain
   if (do_ice_production) {
-    homogeneous_freezing_disp(T_atm, inv_exner, nj, nk, ktop, kbot, kdir, qc, nc, qr, nr, qi, ni, qm, bm, th,
-                              nucleationPossible, hydrometeorsPresent);
+    homogeneous_freezing_disp(T_atm, inv_exner, nj, nk, ktop, kbot, kdir, qc, nc, qr, nr, qi, ni,
+                              qm, bm, th, nucleationPossible, hydrometeorsPresent);
   }
 
   //
@@ -308,10 +321,11 @@ Int Functions<Real, DefaultDevice>::p3_main_internal_disp(
   // and compute diagnostic fields for output
   //
   p3_main_part3_disp(nj, nk_pack, runtime_options.max_total_ni, lookup_tables.dnu_table_vals,
-                     lookup_tables.ice_table_vals, inv_exner, cld_frac_l, cld_frac_r, cld_frac_i, rho, inv_rho, rhofaci,
-                     qv, th, qc, nc, qr, nr, qi, ni, qm, bm, mu_c, nu, lamc, mu_r, lamr, vap_liq_exchange, ze_rain,
-                     ze_ice, diag_vm_qi, diag_eff_radius_qi, diag_diam_qi, rho_qi, diag_equiv_reflectivity,
-                     diag_eff_radius_qc, diag_eff_radius_qr, nucleationPossible, hydrometeorsPresent, runtime_options);
+                     lookup_tables.ice_table_vals, inv_exner, cld_frac_l, cld_frac_r, cld_frac_i,
+                     rho, inv_rho, rhofaci, qv, th, qc, nc, qr, nr, qi, ni, qm, bm, mu_c, nu, lamc,
+                     mu_r, lamr, vap_liq_exchange, ze_rain, ze_ice, diag_vm_qi, diag_eff_radius_qi,
+                     diag_diam_qi, rho_qi, diag_equiv_reflectivity, diag_eff_radius_qc,
+                     diag_eff_radius_qr, nucleationPossible, hydrometeorsPresent, runtime_options);
 
   //
   // merge ice categories with similar properties
@@ -325,7 +339,8 @@ Int Functions<Real, DefaultDevice>::p3_main_internal_disp(
   Kokkos::parallel_for(
       Kokkos::MDRangePolicy<ExeSpace, Kokkos::Rank<2>>({0, 0}, {nj, nk_pack}),
       KOKKOS_LAMBDA(int i, int k) { tmparr2(i, k) = th(i, k) * exner(i, k); });
-  check_values_disp(qv, tmparr2, ktop, kbot, infrastructure.it, debug_ABORT, 900, col_location, nj, nk);
+  check_values_disp(qv, tmparr2, ktop, kbot, infrastructure.it, debug_ABORT, 900, col_location, nj,
+                    nk);
 #endif
   Kokkos::fence();
 
diff --git i/components/eamxx/src/physics/p3/disp/p3_main_impl_part1_disp.cpp w/components/eamxx/src/physics/p3/disp/p3_main_impl_part1_disp.cpp
index ca95f71567..5d4bdbde1e 100644
--- i/components/eamxx/src/physics/p3/disp/p3_main_impl_part1_disp.cpp
+++ w/components/eamxx/src/physics/p3/disp/p3_main_impl_part1_disp.cpp
@@ -15,21 +15,25 @@ namespace p3 {
 
 template <>
 void Functions<Real, DefaultDevice>::p3_main_part1_disp(
-    const Int &nj, const Int &nk, const bool &predictNc, const bool &prescribedCCN, const Scalar &dt,
-    const uview_2d<const Spack> &pres, const uview_2d<const Spack> &dpres, const uview_2d<const Spack> &dz,
-    const uview_2d<const Spack> &nc_nuceat_tend, const uview_2d<const Spack> &nccn_prescribed,
-    const uview_2d<const Spack> &inv_exner, const uview_2d<const Spack> &exner,
-    const uview_2d<const Spack> &inv_cld_frac_l, const uview_2d<const Spack> &inv_cld_frac_i,
-    const uview_2d<const Spack> &inv_cld_frac_r, const uview_2d<Spack> &T_atm, const uview_2d<Spack> &rho,
-    const uview_2d<Spack> &inv_rho, const uview_2d<Spack> &qv_sat_l, const uview_2d<Spack> &qv_sat_i,
-    const uview_2d<Spack> &qv_supersat_i, const uview_2d<Spack> &rhofacr, const uview_2d<Spack> &rhofaci,
-    const uview_2d<Spack> &acn, const uview_2d<Spack> &qv, const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc,
-    const uview_2d<Spack> &nc, const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &qi,
-    const uview_2d<Spack> &ni, const uview_2d<Spack> &qm, const uview_2d<Spack> &bm, const uview_2d<Spack> &qc_incld,
-    const uview_2d<Spack> &qr_incld, const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld,
-    const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &nr_incld, const uview_2d<Spack> &ni_incld,
-    const uview_2d<Spack> &bm_incld, const uview_1d<bool> &nucleationPossible,
-    const uview_1d<bool> &hydrometeorsPresent, const P3Runtime &runtime_options) {
+    const Int &nj, const Int &nk, const bool &predictNc, const bool &prescribedCCN,
+    const Scalar &dt, const uview_2d<const Spack> &pres, const uview_2d<const Spack> &dpres,
+    const uview_2d<const Spack> &dz, const uview_2d<const Spack> &nc_nuceat_tend,
+    const uview_2d<const Spack> &nccn_prescribed, const uview_2d<const Spack> &inv_exner,
+    const uview_2d<const Spack> &exner, const uview_2d<const Spack> &inv_cld_frac_l,
+    const uview_2d<const Spack> &inv_cld_frac_i, const uview_2d<const Spack> &inv_cld_frac_r,
+    const uview_2d<Spack> &T_atm, const uview_2d<Spack> &rho, const uview_2d<Spack> &inv_rho,
+    const uview_2d<Spack> &qv_sat_l, const uview_2d<Spack> &qv_sat_i,
+    const uview_2d<Spack> &qv_supersat_i, const uview_2d<Spack> &rhofacr,
+    const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &acn, const uview_2d<Spack> &qv,
+    const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc, const uview_2d<Spack> &nc,
+    const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &qi,
+    const uview_2d<Spack> &ni, const uview_2d<Spack> &qm, const uview_2d<Spack> &bm,
+    const uview_2d<Spack> &qc_incld, const uview_2d<Spack> &qr_incld,
+    const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld,
+    const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &nr_incld,
+    const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &bm_incld,
+    const uview_1d<bool> &nucleationPossible, const uview_1d<bool> &hydrometeorsPresent,
+    const P3Runtime &runtime_options) {
   using ExeSpace    = typename KT::ExeSpace;
   const Int nk_pack = ekat::npack<Spack>(nk);
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(nj, nk_pack);
@@ -38,19 +42,21 @@ void Functions<Real, DefaultDevice>::p3_main_part1_disp(
       "p3_main_part1", policy, KOKKOS_LAMBDA(const MemberType &team) {
         const Int i = team.league_rank();
 
-        p3_main_part1(team, nk, predictNc, prescribedCCN, dt, ekat::subview(pres, i), ekat::subview(dpres, i),
-                      ekat::subview(dz, i), ekat::subview(nc_nuceat_tend, i), ekat::subview(nccn_prescribed, i),
-                      ekat::subview(inv_exner, i), ekat::subview(exner, i), ekat::subview(inv_cld_frac_l, i),
-                      ekat::subview(inv_cld_frac_i, i), ekat::subview(inv_cld_frac_r, i), ekat::subview(T_atm, i),
-                      ekat::subview(rho, i), ekat::subview(inv_rho, i), ekat::subview(qv_sat_l, i),
-                      ekat::subview(qv_sat_i, i), ekat::subview(qv_supersat_i, i), ekat::subview(rhofacr, i),
-                      ekat::subview(rhofaci, i), ekat::subview(acn, i), ekat::subview(qv, i), ekat::subview(th_atm, i),
-                      ekat::subview(qc, i), ekat::subview(nc, i), ekat::subview(qr, i), ekat::subview(nr, i),
-                      ekat::subview(qi, i), ekat::subview(ni, i), ekat::subview(qm, i), ekat::subview(bm, i),
-                      ekat::subview(qc_incld, i), ekat::subview(qr_incld, i), ekat::subview(qi_incld, i),
-                      ekat::subview(qm_incld, i), ekat::subview(nc_incld, i), ekat::subview(nr_incld, i),
-                      ekat::subview(ni_incld, i), ekat::subview(bm_incld, i), nucleationPossible(i),
-                      hydrometeorsPresent(i), runtime_options);
+        p3_main_part1(
+            team, nk, predictNc, prescribedCCN, dt, ekat::subview(pres, i), ekat::subview(dpres, i),
+            ekat::subview(dz, i), ekat::subview(nc_nuceat_tend, i),
+            ekat::subview(nccn_prescribed, i), ekat::subview(inv_exner, i), ekat::subview(exner, i),
+            ekat::subview(inv_cld_frac_l, i), ekat::subview(inv_cld_frac_i, i),
+            ekat::subview(inv_cld_frac_r, i), ekat::subview(T_atm, i), ekat::subview(rho, i),
+            ekat::subview(inv_rho, i), ekat::subview(qv_sat_l, i), ekat::subview(qv_sat_i, i),
+            ekat::subview(qv_supersat_i, i), ekat::subview(rhofacr, i), ekat::subview(rhofaci, i),
+            ekat::subview(acn, i), ekat::subview(qv, i), ekat::subview(th_atm, i),
+            ekat::subview(qc, i), ekat::subview(nc, i), ekat::subview(qr, i), ekat::subview(nr, i),
+            ekat::subview(qi, i), ekat::subview(ni, i), ekat::subview(qm, i), ekat::subview(bm, i),
+            ekat::subview(qc_incld, i), ekat::subview(qr_incld, i), ekat::subview(qi_incld, i),
+            ekat::subview(qm_incld, i), ekat::subview(nc_incld, i), ekat::subview(nr_incld, i),
+            ekat::subview(ni_incld, i), ekat::subview(bm_incld, i), nucleationPossible(i),
+            hydrometeorsPresent(i), runtime_options);
       });
 }
 
diff --git i/components/eamxx/src/physics/p3/disp/p3_main_impl_part2_disp.cpp w/components/eamxx/src/physics/p3/disp/p3_main_impl_part2_disp.cpp
index 941639c400..503f9bb254 100644
--- i/components/eamxx/src/physics/p3/disp/p3_main_impl_part2_disp.cpp
+++ w/components/eamxx/src/physics/p3/disp/p3_main_impl_part2_disp.cpp
@@ -15,38 +15,46 @@ namespace p3 {
 #endif
 template <>
 void Functions<Real, DefaultDevice>::p3_main_part2_disp(
-    const Int &nj, const Int &nk, const Scalar &max_total_ni, const bool &predictNc, const bool &do_prescribed_CCN,
-    const Scalar &dt, const Scalar &inv_dt, const uview_2d<const Spack> &hetfrz_immersion_nucleation_tend,
+    const Int &nj, const Int &nk, const Scalar &max_total_ni, const bool &predictNc,
+    const bool &do_prescribed_CCN, const Scalar &dt, const Scalar &inv_dt,
+    const uview_2d<const Spack> &hetfrz_immersion_nucleation_tend,
     const uview_2d<const Spack> &hetfrz_contact_nucleation_tend,
-    const uview_2d<const Spack> &hetfrz_deposition_nucleation_tend, const view_dnu_table &dnu_table_vals,
-    const view_ice_table &ice_table_vals, const view_collect_table &collect_table_vals,
-    const view_2d_table &revap_table_vals, const uview_2d<const Spack> &pres, const uview_2d<const Spack> &dpres,
+    const uview_2d<const Spack> &hetfrz_deposition_nucleation_tend,
+    const view_dnu_table &dnu_table_vals, const view_ice_table &ice_table_vals,
+    const view_collect_table &collect_table_vals, const view_2d_table &revap_table_vals,
+    const uview_2d<const Spack> &pres, const uview_2d<const Spack> &dpres,
     const uview_2d<const Spack> &dz, const uview_2d<const Spack> &nc_nuceat_tend,
     const uview_2d<const Spack> &inv_exner, const uview_2d<const Spack> &exner,
     const uview_2d<const Spack> &inv_cld_frac_l, const uview_2d<const Spack> &inv_cld_frac_i,
     const uview_2d<const Spack> &inv_cld_frac_r, const uview_2d<const Spack> &ni_activated,
     const uview_2d<const Spack> &inv_qc_relvar, const uview_2d<const Spack> &cld_frac_i,
     const uview_2d<const Spack> &cld_frac_l, const uview_2d<const Spack> &cld_frac_r,
-    const uview_2d<const Spack> &qv_prev, const uview_2d<const Spack> &t_prev, const uview_2d<Spack> &T_atm,
-    const uview_2d<Spack> &rho, const uview_2d<Spack> &inv_rho, const uview_2d<Spack> &qv_sat_l,
-    const uview_2d<Spack> &qv_sat_i, const uview_2d<Spack> &qv_supersat_i, const uview_2d<Spack> &rhofacr,
+    const uview_2d<const Spack> &qv_prev, const uview_2d<const Spack> &t_prev,
+    const uview_2d<Spack> &T_atm, const uview_2d<Spack> &rho, const uview_2d<Spack> &inv_rho,
+    const uview_2d<Spack> &qv_sat_l, const uview_2d<Spack> &qv_sat_i,
+    const uview_2d<Spack> &qv_supersat_i, const uview_2d<Spack> &rhofacr,
     const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &acn, const uview_2d<Spack> &qv,
-    const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc, const uview_2d<Spack> &nc, const uview_2d<Spack> &qr,
-    const uview_2d<Spack> &nr, const uview_2d<Spack> &qi, const uview_2d<Spack> &ni, const uview_2d<Spack> &qm,
-    const uview_2d<Spack> &bm, const uview_2d<Spack> &qc_incld, const uview_2d<Spack> &qr_incld,
-    const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld, const uview_2d<Spack> &nc_incld,
-    const uview_2d<Spack> &nr_incld, const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &bm_incld,
-    const uview_2d<Spack> &mu_c, const uview_2d<Spack> &nu, const uview_2d<Spack> &lamc, const uview_2d<Spack> &cdist,
+    const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc, const uview_2d<Spack> &nc,
+    const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &qi,
+    const uview_2d<Spack> &ni, const uview_2d<Spack> &qm, const uview_2d<Spack> &bm,
+    const uview_2d<Spack> &qc_incld, const uview_2d<Spack> &qr_incld,
+    const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld,
+    const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &nr_incld,
+    const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &bm_incld, const uview_2d<Spack> &mu_c,
+    const uview_2d<Spack> &nu, const uview_2d<Spack> &lamc, const uview_2d<Spack> &cdist,
     const uview_2d<Spack> &cdist1, const uview_2d<Spack> &cdistr, const uview_2d<Spack> &mu_r,
-    const uview_2d<Spack> &lamr, const uview_2d<Spack> &logn0r, const uview_2d<Spack> &qv2qi_depos_tend,
-    const uview_2d<Spack> &precip_total_tend, const uview_2d<Spack> &nevapr, const uview_2d<Spack> &qr_evap_tend,
+    const uview_2d<Spack> &lamr, const uview_2d<Spack> &logn0r,
+    const uview_2d<Spack> &qv2qi_depos_tend, const uview_2d<Spack> &precip_total_tend,
+    const uview_2d<Spack> &nevapr, const uview_2d<Spack> &qr_evap_tend,
     const uview_2d<Spack> &vap_liq_exchange, const uview_2d<Spack> &vap_ice_exchange,
-    const uview_2d<Spack> &liq_ice_exchange, const uview_2d<Spack> &qr2qv_evap, const uview_2d<Spack> &qi2qv_sublim,
-    const uview_2d<Spack> &qc2qr_accret, const uview_2d<Spack> &qc2qr_autoconv, const uview_2d<Spack> &qv2qi_vapdep,
-    const uview_2d<Spack> &qc2qi_berg, const uview_2d<Spack> &qc2qr_ice_shed, const uview_2d<Spack> &qc2qi_collect,
-    const uview_2d<Spack> &qr2qi_collect, const uview_2d<Spack> &qc2qi_hetero_freeze,
-    const uview_2d<Spack> &qr2qi_immers_freeze, const uview_2d<Spack> &qi2qr_melt, const uview_2d<Spack> &pratot,
-    const uview_2d<Spack> &prctot, const uview_1d<bool> &nucleationPossible, const uview_1d<bool> &hydrometeorsPresent,
+    const uview_2d<Spack> &liq_ice_exchange, const uview_2d<Spack> &qr2qv_evap,
+    const uview_2d<Spack> &qi2qv_sublim, const uview_2d<Spack> &qc2qr_accret,
+    const uview_2d<Spack> &qc2qr_autoconv, const uview_2d<Spack> &qv2qi_vapdep,
+    const uview_2d<Spack> &qc2qi_berg, const uview_2d<Spack> &qc2qr_ice_shed,
+    const uview_2d<Spack> &qc2qi_collect, const uview_2d<Spack> &qr2qi_collect,
+    const uview_2d<Spack> &qc2qi_hetero_freeze, const uview_2d<Spack> &qr2qi_immers_freeze,
+    const uview_2d<Spack> &qi2qr_melt, const uview_2d<Spack> &pratot, const uview_2d<Spack> &prctot,
+    const uview_1d<bool> &nucleationPossible, const uview_1d<bool> &hydrometeorsPresent,
     const P3Runtime &runtime_options) {
   using ExeSpace    = typename KT::ExeSpace;
   const Int nk_pack = ekat::npack<Spack>(nk);
@@ -64,31 +72,39 @@ void Functions<Real, DefaultDevice>::p3_main_part2_disp(
         // main k-loop (for processes):
         p3_main_part2(
             team, nk_pack, max_total_ni, predictNc, do_prescribed_CCN, dt, inv_dt,
-            ekat::subview(hetfrz_immersion_nucleation_tend, i), ekat::subview(hetfrz_contact_nucleation_tend, i),
-            ekat::subview(hetfrz_deposition_nucleation_tend, i), dnu_table_vals, ice_table_vals, collect_table_vals,
-            revap_table_vals, ekat::subview(pres, i), ekat::subview(dpres, i), ekat::subview(dz, i),
-            ekat::subview(nc_nuceat_tend, i), ekat::subview(inv_exner, i), ekat::subview(exner, i),
-            ekat::subview(inv_cld_frac_l, i), ekat::subview(inv_cld_frac_i, i), ekat::subview(inv_cld_frac_r, i),
-            ekat::subview(ni_activated, i), ekat::subview(inv_qc_relvar, i), ekat::subview(cld_frac_i, i),
-            ekat::subview(cld_frac_l, i), ekat::subview(cld_frac_r, i), ekat::subview(qv_prev, i),
-            ekat::subview(t_prev, i), ekat::subview(T_atm, i), ekat::subview(rho, i), ekat::subview(inv_rho, i),
+            ekat::subview(hetfrz_immersion_nucleation_tend, i),
+            ekat::subview(hetfrz_contact_nucleation_tend, i),
+            ekat::subview(hetfrz_deposition_nucleation_tend, i), dnu_table_vals, ice_table_vals,
+            collect_table_vals, revap_table_vals, ekat::subview(pres, i), ekat::subview(dpres, i),
+            ekat::subview(dz, i), ekat::subview(nc_nuceat_tend, i), ekat::subview(inv_exner, i),
+            ekat::subview(exner, i), ekat::subview(inv_cld_frac_l, i),
+            ekat::subview(inv_cld_frac_i, i), ekat::subview(inv_cld_frac_r, i),
+            ekat::subview(ni_activated, i), ekat::subview(inv_qc_relvar, i),
+            ekat::subview(cld_frac_i, i), ekat::subview(cld_frac_l, i),
+            ekat::subview(cld_frac_r, i), ekat::subview(qv_prev, i), ekat::subview(t_prev, i),
+            ekat::subview(T_atm, i), ekat::subview(rho, i), ekat::subview(inv_rho, i),
             ekat::subview(qv_sat_l, i), ekat::subview(qv_sat_i, i), ekat::subview(qv_supersat_i, i),
-            ekat::subview(rhofacr, i), ekat::subview(rhofaci, i), ekat::subview(acn, i), ekat::subview(qv, i),
-            ekat::subview(th_atm, i), ekat::subview(qc, i), ekat::subview(nc, i), ekat::subview(qr, i),
-            ekat::subview(nr, i), ekat::subview(qi, i), ekat::subview(ni, i), ekat::subview(qm, i),
-            ekat::subview(bm, i), ekat::subview(qc_incld, i), ekat::subview(qr_incld, i), ekat::subview(qi_incld, i),
+            ekat::subview(rhofacr, i), ekat::subview(rhofaci, i), ekat::subview(acn, i),
+            ekat::subview(qv, i), ekat::subview(th_atm, i), ekat::subview(qc, i),
+            ekat::subview(nc, i), ekat::subview(qr, i), ekat::subview(nr, i), ekat::subview(qi, i),
+            ekat::subview(ni, i), ekat::subview(qm, i), ekat::subview(bm, i),
+            ekat::subview(qc_incld, i), ekat::subview(qr_incld, i), ekat::subview(qi_incld, i),
             ekat::subview(qm_incld, i), ekat::subview(nc_incld, i), ekat::subview(nr_incld, i),
-            ekat::subview(ni_incld, i), ekat::subview(bm_incld, i), ekat::subview(mu_c, i), ekat::subview(nu, i),
-            ekat::subview(lamc, i), ekat::subview(cdist, i), ekat::subview(cdist1, i), ekat::subview(cdistr, i),
-            ekat::subview(mu_r, i), ekat::subview(lamr, i), ekat::subview(logn0r, i),
-            ekat::subview(qv2qi_depos_tend, i), ekat::subview(precip_total_tend, i), ekat::subview(nevapr, i),
-            ekat::subview(qr_evap_tend, i), ekat::subview(vap_liq_exchange, i), ekat::subview(vap_ice_exchange, i),
-            ekat::subview(liq_ice_exchange, i), ekat::subview(qr2qv_evap, i), ekat::subview(qi2qv_sublim, i),
-            ekat::subview(qc2qr_accret, i), ekat::subview(qc2qr_autoconv, i), ekat::subview(qv2qi_vapdep, i),
-            ekat::subview(qc2qi_berg, i), ekat::subview(qc2qr_ice_shed, i), ekat::subview(qc2qi_collect, i),
+            ekat::subview(ni_incld, i), ekat::subview(bm_incld, i), ekat::subview(mu_c, i),
+            ekat::subview(nu, i), ekat::subview(lamc, i), ekat::subview(cdist, i),
+            ekat::subview(cdist1, i), ekat::subview(cdistr, i), ekat::subview(mu_r, i),
+            ekat::subview(lamr, i), ekat::subview(logn0r, i), ekat::subview(qv2qi_depos_tend, i),
+            ekat::subview(precip_total_tend, i), ekat::subview(nevapr, i),
+            ekat::subview(qr_evap_tend, i), ekat::subview(vap_liq_exchange, i),
+            ekat::subview(vap_ice_exchange, i), ekat::subview(liq_ice_exchange, i),
+            ekat::subview(qr2qv_evap, i), ekat::subview(qi2qv_sublim, i),
+            ekat::subview(qc2qr_accret, i), ekat::subview(qc2qr_autoconv, i),
+            ekat::subview(qv2qi_vapdep, i), ekat::subview(qc2qi_berg, i),
+            ekat::subview(qc2qr_ice_shed, i), ekat::subview(qc2qi_collect, i),
             ekat::subview(qr2qi_collect, i), ekat::subview(qc2qi_hetero_freeze, i),
-            ekat::subview(qr2qi_immers_freeze, i), ekat::subview(qi2qr_melt, i), ekat::subview(pratot, i),
-            ekat::subview(prctot, i), hydrometeorsPresent(i), nk, runtime_options);
+            ekat::subview(qr2qi_immers_freeze, i), ekat::subview(qi2qr_melt, i),
+            ekat::subview(pratot, i), ekat::subview(prctot, i), hydrometeorsPresent(i), nk,
+            runtime_options);
 
         if (!hydrometeorsPresent(i))
           return;
diff --git i/components/eamxx/src/physics/p3/disp/p3_main_impl_part3_disp.cpp w/components/eamxx/src/physics/p3/disp/p3_main_impl_part3_disp.cpp
index f3aa897357..266ef818ae 100644
--- i/components/eamxx/src/physics/p3/disp/p3_main_impl_part3_disp.cpp
+++ w/components/eamxx/src/physics/p3/disp/p3_main_impl_part3_disp.cpp
@@ -15,16 +15,19 @@ namespace p3 {
 
 template <>
 void Functions<Real, DefaultDevice>::p3_main_part3_disp(
-    const Int &nj, const Int &nk_pack, const Scalar &max_total_ni, const view_dnu_table &dnu_table_vals,
-    const view_ice_table &ice_table_vals, const uview_2d<const Spack> &inv_exner,
-    const uview_2d<const Spack> &cld_frac_l, const uview_2d<const Spack> &cld_frac_r,
-    const uview_2d<const Spack> &cld_frac_i, const uview_2d<Spack> &rho, const uview_2d<Spack> &inv_rho,
-    const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &qv, const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc,
-    const uview_2d<Spack> &nc, const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &qi,
-    const uview_2d<Spack> &ni, const uview_2d<Spack> &qm, const uview_2d<Spack> &bm, const uview_2d<Spack> &mu_c,
-    const uview_2d<Spack> &nu, const uview_2d<Spack> &lamc, const uview_2d<Spack> &mu_r, const uview_2d<Spack> &lamr,
-    const uview_2d<Spack> &vap_liq_exchange, const uview_2d<Spack> &ze_rain, const uview_2d<Spack> &ze_ice,
-    const uview_2d<Spack> &diag_vm_qi, const uview_2d<Spack> &diag_eff_radius_qi, const uview_2d<Spack> &diag_diam_qi,
+    const Int &nj, const Int &nk_pack, const Scalar &max_total_ni,
+    const view_dnu_table &dnu_table_vals, const view_ice_table &ice_table_vals,
+    const uview_2d<const Spack> &inv_exner, const uview_2d<const Spack> &cld_frac_l,
+    const uview_2d<const Spack> &cld_frac_r, const uview_2d<const Spack> &cld_frac_i,
+    const uview_2d<Spack> &rho, const uview_2d<Spack> &inv_rho, const uview_2d<Spack> &rhofaci,
+    const uview_2d<Spack> &qv, const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc,
+    const uview_2d<Spack> &nc, const uview_2d<Spack> &qr, const uview_2d<Spack> &nr,
+    const uview_2d<Spack> &qi, const uview_2d<Spack> &ni, const uview_2d<Spack> &qm,
+    const uview_2d<Spack> &bm, const uview_2d<Spack> &mu_c, const uview_2d<Spack> &nu,
+    const uview_2d<Spack> &lamc, const uview_2d<Spack> &mu_r, const uview_2d<Spack> &lamr,
+    const uview_2d<Spack> &vap_liq_exchange, const uview_2d<Spack> &ze_rain,
+    const uview_2d<Spack> &ze_ice, const uview_2d<Spack> &diag_vm_qi,
+    const uview_2d<Spack> &diag_eff_radius_qi, const uview_2d<Spack> &diag_diam_qi,
     const uview_2d<Spack> &rho_qi, const uview_2d<Spack> &diag_equiv_reflectivity,
     const uview_2d<Spack> &diag_eff_radius_qc, const uview_2d<Spack> &diag_eff_radius_qr,
     const uview_1d<bool> &nucleationPossible, const uview_1d<bool> &hydrometeorsPresent,
@@ -43,17 +46,20 @@ void Functions<Real, DefaultDevice>::p3_main_part3_disp(
         // final checks to ensure consistency of mass/number
         // and compute diagnostic fields for output
         //
-        p3_main_part3(team, nk_pack, max_total_ni, dnu_table_vals, ice_table_vals, ekat::subview(inv_exner, i),
-                      ekat::subview(cld_frac_l, i), ekat::subview(cld_frac_r, i), ekat::subview(cld_frac_i, i),
-                      ekat::subview(rho, i), ekat::subview(inv_rho, i), ekat::subview(rhofaci, i), ekat::subview(qv, i),
-                      ekat::subview(th_atm, i), ekat::subview(qc, i), ekat::subview(nc, i), ekat::subview(qr, i),
-                      ekat::subview(nr, i), ekat::subview(qi, i), ekat::subview(ni, i), ekat::subview(qm, i),
-                      ekat::subview(bm, i), ekat::subview(mu_c, i), ekat::subview(nu, i), ekat::subview(lamc, i),
-                      ekat::subview(mu_r, i), ekat::subview(lamr, i), ekat::subview(vap_liq_exchange, i),
-                      ekat::subview(ze_rain, i), ekat::subview(ze_ice, i), ekat::subview(diag_vm_qi, i),
-                      ekat::subview(diag_eff_radius_qi, i), ekat::subview(diag_diam_qi, i), ekat::subview(rho_qi, i),
-                      ekat::subview(diag_equiv_reflectivity, i), ekat::subview(diag_eff_radius_qc, i),
-                      ekat::subview(diag_eff_radius_qr, i), runtime_options);
+        p3_main_part3(
+            team, nk_pack, max_total_ni, dnu_table_vals, ice_table_vals,
+            ekat::subview(inv_exner, i), ekat::subview(cld_frac_l, i), ekat::subview(cld_frac_r, i),
+            ekat::subview(cld_frac_i, i), ekat::subview(rho, i), ekat::subview(inv_rho, i),
+            ekat::subview(rhofaci, i), ekat::subview(qv, i), ekat::subview(th_atm, i),
+            ekat::subview(qc, i), ekat::subview(nc, i), ekat::subview(qr, i), ekat::subview(nr, i),
+            ekat::subview(qi, i), ekat::subview(ni, i), ekat::subview(qm, i), ekat::subview(bm, i),
+            ekat::subview(mu_c, i), ekat::subview(nu, i), ekat::subview(lamc, i),
+            ekat::subview(mu_r, i), ekat::subview(lamr, i), ekat::subview(vap_liq_exchange, i),
+            ekat::subview(ze_rain, i), ekat::subview(ze_ice, i), ekat::subview(diag_vm_qi, i),
+            ekat::subview(diag_eff_radius_qi, i), ekat::subview(diag_diam_qi, i),
+            ekat::subview(rho_qi, i), ekat::subview(diag_equiv_reflectivity, i),
+            ekat::subview(diag_eff_radius_qc, i), ekat::subview(diag_eff_radius_qr, i),
+            runtime_options);
       });
 }
 
diff --git i/components/eamxx/src/physics/p3/disp/p3_rain_sed_impl_disp.cpp w/components/eamxx/src/physics/p3/disp/p3_rain_sed_impl_disp.cpp
index f58ab7351d..1f57618b3f 100644
--- i/components/eamxx/src/physics/p3/disp/p3_rain_sed_impl_disp.cpp
+++ w/components/eamxx/src/physics/p3/disp/p3_rain_sed_impl_disp.cpp
@@ -7,13 +7,16 @@ namespace p3 {
 
 template <>
 void Functions<Real, DefaultDevice>::rain_sedimentation_disp(
-    const uview_2d<const Spack> &rho, const uview_2d<const Spack> &inv_rho, const uview_2d<const Spack> &rhofacr,
-    const uview_2d<const Spack> &cld_frac_r, const uview_2d<const Spack> &inv_dz, const uview_2d<Spack> &qr_incld,
-    const WorkspaceManager &workspace_mgr, const view_2d_table &vn_table_vals, const view_2d_table &vm_table_vals,
-    const Int &nj, const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
-    const Scalar &inv_dt, const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &nr_incld,
-    const uview_2d<Spack> &mu_r, const uview_2d<Spack> &lamr, const uview_2d<Spack> &precip_liq_flux,
-    const uview_2d<Spack> &qr_tend, const uview_2d<Spack> &nr_tend, const uview_1d<Scalar> &precip_liq_surf,
+    const uview_2d<const Spack> &rho, const uview_2d<const Spack> &inv_rho,
+    const uview_2d<const Spack> &rhofacr, const uview_2d<const Spack> &cld_frac_r,
+    const uview_2d<const Spack> &inv_dz, const uview_2d<Spack> &qr_incld,
+    const WorkspaceManager &workspace_mgr, const view_2d_table &vn_table_vals,
+    const view_2d_table &vm_table_vals, const Int &nj, const Int &nk, const Int &ktop,
+    const Int &kbot, const Int &kdir, const Scalar &dt, const Scalar &inv_dt,
+    const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &nr_incld,
+    const uview_2d<Spack> &mu_r, const uview_2d<Spack> &lamr,
+    const uview_2d<Spack> &precip_liq_flux, const uview_2d<Spack> &qr_tend,
+    const uview_2d<Spack> &nr_tend, const uview_1d<Scalar> &precip_liq_surf,
     const uview_1d<bool> &nucleationPossible, const uview_1d<bool> &hydrometeorsPresent,
     const P3Runtime &runtime_options) {
   using ExeSpace    = typename KT::ExeSpace;
@@ -29,12 +32,14 @@ void Functions<Real, DefaultDevice>::rain_sedimentation_disp(
         }
 
         // Rain sedimentation:  (adaptive substepping)
-        rain_sedimentation(ekat::subview(rho, i), ekat::subview(inv_rho, i), ekat::subview(rhofacr, i),
-                           ekat::subview(cld_frac_r, i), ekat::subview(inv_dz, i), ekat::subview(qr_incld, i), team,
-                           workspace, vn_table_vals, vm_table_vals, nk, ktop, kbot, kdir, dt, inv_dt,
+        rain_sedimentation(ekat::subview(rho, i), ekat::subview(inv_rho, i),
+                           ekat::subview(rhofacr, i), ekat::subview(cld_frac_r, i),
+                           ekat::subview(inv_dz, i), ekat::subview(qr_incld, i), team, workspace,
+                           vn_table_vals, vm_table_vals, nk, ktop, kbot, kdir, dt, inv_dt,
                            ekat::subview(qr, i), ekat::subview(nr, i), ekat::subview(nr_incld, i),
-                           ekat::subview(mu_r, i), ekat::subview(lamr, i), ekat::subview(precip_liq_flux, i),
-                           ekat::subview(qr_tend, i), ekat::subview(nr_tend, i), precip_liq_surf(i), runtime_options);
+                           ekat::subview(mu_r, i), ekat::subview(lamr, i),
+                           ekat::subview(precip_liq_flux, i), ekat::subview(qr_tend, i),
+                           ekat::subview(nr_tend, i), precip_liq_surf(i), runtime_options);
       });
 }
 } // namespace p3
diff --git i/components/eamxx/src/physics/p3/eamxx_p3_process_interface.cpp w/components/eamxx/src/physics/p3/eamxx_p3_process_interface.cpp
index 52c643b34c..58c19c57d5 100644
--- i/components/eamxx/src/physics/p3/eamxx_p3_process_interface.cpp
+++ w/components/eamxx/src/physics/p3/eamxx_p3_process_interface.cpp
@@ -84,7 +84,8 @@ void P3Microphysics::set_grids(const std::shared_ptr<const GridsManager> grids_m
   add_tracer<Updated>("ni", m_grid, 1 / kg, ps);
   add_tracer<Updated>("bm", m_grid, 1 / kg, ps);
 
-  // Diagnostic Inputs: (only the X_prev fields are both input and output, all others are just inputs)
+  // Diagnostic Inputs: (only the X_prev fields are both input and output, all others are just
+  // inputs)
   add_field<Required>("nc_nuceat_tend", scalar3d_layout_mid, 1 / (kg * s), grid_name, ps);
   if (infrastructure.prescribedCCN) {
     add_field<Required>("nccn", scalar3d_layout_mid, 1 / kg, grid_name, ps);
@@ -103,13 +104,16 @@ void P3Microphysics::set_grids(const std::shared_ptr<const GridsManager> grids_m
     // units of number mixing ratios of tracers
     constexpr auto frz_unit = 1 / (cm * cm * cm * s);
     //  heterogeneous freezing by immersion nucleation [cm^-3 s^-1]
-    add_field<Required>("hetfrz_immersion_nucleation_tend", scalar3d_layout_mid, frz_unit, grid_name, ps);
+    add_field<Required>("hetfrz_immersion_nucleation_tend", scalar3d_layout_mid, frz_unit,
+                        grid_name, ps);
 
     // heterogeneous freezing by contact nucleation [cm^-3 s^-1]
-    add_field<Required>("hetfrz_contact_nucleation_tend", scalar3d_layout_mid, frz_unit, grid_name, ps);
+    add_field<Required>("hetfrz_contact_nucleation_tend", scalar3d_layout_mid, frz_unit, grid_name,
+                        ps);
 
     // heterogeneous freezing by deposition nucleation [cm^-3 s^-1]
-    add_field<Required>("hetfrz_deposition_nucleation_tend", scalar3d_layout_mid, frz_unit, grid_name, ps);
+    add_field<Required>("hetfrz_deposition_nucleation_tend", scalar3d_layout_mid, frz_unit,
+                        grid_name, ps);
   }
 
   // Diagnostic Outputs: (all fields are just outputs w.r.t. P3)
@@ -173,7 +177,8 @@ size_t P3Microphysics::requested_buffer_size_in_bytes() const {
       m_num_cols * 3 * sizeof(Real);
 
   // Number of Reals needed by the WorkspaceManager passed to p3_main
-  const auto policy        = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nk_pack);
+  const auto policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nk_pack);
   const size_t wsm_request = WSM::get_total_bytes_needed(nk_pack_p1, 52, policy);
 
   return interface_request + wsm_request;
@@ -187,7 +192,7 @@ void P3Microphysics::init_buffers(const ATMBufferManager &buffer_manager) {
   Real *mem = reinterpret_cast<Real *>(buffer_manager.get_memory());
 
   // 1d scalar views
-  using scalar_1d_view_t                                        = decltype(m_buffer.precip_liq_surf_flux);
+  using scalar_1d_view_t = decltype(m_buffer.precip_liq_surf_flux);
   scalar_1d_view_t *_1d_scalar_view_ptrs[Buffer::num_1d_scalar] = {&m_buffer.precip_liq_surf_flux,
                                                                    &m_buffer.precip_ice_surf_flux};
   for (int i = 0; i < Buffer::num_1d_scalar; ++i) {
@@ -290,7 +295,8 @@ void P3Microphysics::init_buffers(const ATMBufferManager &buffer_manager) {
 
   // Compute workspace manager size to check used memory
   // vs. requested memory
-  const auto policy  = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nk_pack);
+  const auto policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nk_pack);
   const int wsm_size = WSM::get_total_bytes_needed(nk_pack_p1, 52, policy) / sizeof(Spack);
   s_mem += wsm_size;
 
@@ -303,7 +309,8 @@ void P3Microphysics::init_buffers(const ATMBufferManager &buffer_manager) {
 void P3Microphysics::initialize_impl(const RunType /* run_type */) {
 
   // Set property checks for fields in this process
-  add_invariant_check<FieldWithinIntervalCheck>(get_field_out("T_mid"), m_grid, 100.0, 500.0, false);
+  add_invariant_check<FieldWithinIntervalCheck>(get_field_out("T_mid"), m_grid, 100.0, 500.0,
+                                                false);
   add_invariant_check<FieldWithinIntervalCheck>(get_field_out("qv"), m_grid, 1e-13, 0.2, true);
   add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("qc"), m_grid, 0.0, 0.1, false);
   add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("qi"), m_grid, 0.0, 0.1, false);
@@ -316,11 +323,16 @@ void P3Microphysics::initialize_impl(const RunType /* run_type */) {
   // The following checks on precip have been changed to lower bound checks, from an interval check.
   // TODO: Change back to interval check when it is possible to pass dt_atm for the check.  Because
   //       precip is now an accumulated mass, the upper bound is dependent on the timestep.
-  add_postcondition_check<FieldLowerBoundCheck>(get_field_out("precip_liq_surf_mass"), m_grid, 0.0, false);
-  add_postcondition_check<FieldLowerBoundCheck>(get_field_out("precip_ice_surf_mass"), m_grid, 0.0, false);
-  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("eff_radius_qc"), m_grid, 0.0, 1.0e2, false);
-  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("eff_radius_qi"), m_grid, 0.0, 5.0e3, false);
-  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("eff_radius_qr"), m_grid, 0.0, 5.0e3, false);
+  add_postcondition_check<FieldLowerBoundCheck>(get_field_out("precip_liq_surf_mass"), m_grid, 0.0,
+                                                false);
+  add_postcondition_check<FieldLowerBoundCheck>(get_field_out("precip_ice_surf_mass"), m_grid, 0.0,
+                                                false);
+  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("eff_radius_qc"), m_grid, 0.0,
+                                                    1.0e2, false);
+  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("eff_radius_qi"), m_grid, 0.0,
+                                                    5.0e3, false);
+  add_postcondition_check<FieldWithinIntervalCheck>(get_field_out("eff_radius_qr"), m_grid, 0.0,
+                                                    5.0e3, false);
 
   // Initialize p3
   lookup_tables = P3F::p3_init(/* write_tables = */ false, this->get_comm().am_i_root());
@@ -367,9 +379,10 @@ void P3Microphysics::initialize_impl(const RunType /* run_type */) {
   auto dz         = m_buffer.dz;
 
   // -- Set values for the pre-amble structure
-  p3_preproc.set_variables(m_num_cols, m_num_levs, pmid, pmid_dry, pseudo_density, pseudo_density_dry, T_atm,
-                           cld_frac_t_in, cld_frac_l_in, cld_frac_i_in, qv, qc, nc, qr, nr, qi, qm, ni, bm, qv_prev,
-                           inv_exner, th_atm, cld_frac_l, cld_frac_i, cld_frac_r, dz, runtime_options);
+  p3_preproc.set_variables(m_num_cols, m_num_levs, pmid, pmid_dry, pseudo_density,
+                           pseudo_density_dry, T_atm, cld_frac_t_in, cld_frac_l_in, cld_frac_i_in,
+                           qv, qc, nc, qr, nr, qi, qm, ni, bm, qv_prev, inv_exner, th_atm,
+                           cld_frac_l, cld_frac_i, cld_frac_r, dz, runtime_options);
   // --Prognostic State Variables:
   prog_state.qc = p3_preproc.qc;
   prog_state.nc = p3_preproc.nc;
@@ -386,8 +399,8 @@ void P3Microphysics::initialize_impl(const RunType /* run_type */) {
   if (infrastructure.prescribedCCN) {
     diag_inputs.nccn = get_field_in("nccn").get_view<const Pack **>();
   } else {
-    diag_inputs.nccn = m_buffer.unused; // TODO set value of unused to something like 0.0 or nan as a layer of
-                                        // protection that it isn't being used.
+    diag_inputs.nccn = m_buffer.unused; // TODO set value of unused to something like 0.0 or nan as
+                                        // a layer of protection that it isn't being used.
   }
   diag_inputs.ni_activated  = get_field_in("ni_activated").get_view<const Pack **>();
   diag_inputs.inv_qc_relvar = get_field_in("inv_qc_relvar").get_view<const Pack **>();
@@ -420,12 +433,13 @@ void P3Microphysics::initialize_impl(const RunType /* run_type */) {
   }
 
   // --Diagnostic Outputs
-  diag_outputs.diag_eff_radius_qc      = get_field_out("eff_radius_qc").get_view<Pack **>();
-  diag_outputs.diag_eff_radius_qi      = get_field_out("eff_radius_qi").get_view<Pack **>();
-  diag_outputs.diag_eff_radius_qr      = get_field_out("eff_radius_qr").get_view<Pack **>();
-  diag_outputs.precip_total_tend       = get_field_out("precip_total_tend").get_view<Pack **>();
-  diag_outputs.nevapr                  = get_field_out("nevapr").get_view<Pack **>();
-  diag_outputs.diag_equiv_reflectivity = get_field_out("diag_equiv_reflectivity").get_view<Pack **>();
+  diag_outputs.diag_eff_radius_qc = get_field_out("eff_radius_qc").get_view<Pack **>();
+  diag_outputs.diag_eff_radius_qi = get_field_out("eff_radius_qi").get_view<Pack **>();
+  diag_outputs.diag_eff_radius_qr = get_field_out("eff_radius_qr").get_view<Pack **>();
+  diag_outputs.precip_total_tend  = get_field_out("precip_total_tend").get_view<Pack **>();
+  diag_outputs.nevapr             = get_field_out("nevapr").get_view<Pack **>();
+  diag_outputs.diag_equiv_reflectivity =
+      get_field_out("diag_equiv_reflectivity").get_view<Pack **>();
 
   diag_outputs.precip_liq_surf  = m_buffer.precip_liq_surf_flux;
   diag_outputs.precip_ice_surf  = m_buffer.precip_ice_surf_flux;
@@ -434,8 +448,8 @@ void P3Microphysics::initialize_impl(const RunType /* run_type */) {
   diag_outputs.precip_liq_flux  = m_buffer.precip_liq_flux;
   diag_outputs.precip_ice_flux  = m_buffer.precip_ice_flux;
   // -- Infrastructure, what is left to assign
-  infrastructure.col_location =
-      m_buffer.col_location; // TODO: Initialize this here and now when P3 has access to lat/lon for each column.
+  infrastructure.col_location = m_buffer.col_location; // TODO: Initialize this here and now when P3
+                                                       // has access to lat/lon for each column.
   // --History Only
   history_only.liq_ice_exchange = get_field_out("micro_liq_ice_exchange").get_view<Pack **>();
   history_only.vap_liq_exchange = get_field_out("micro_vap_liq_exchange").get_view<Pack **>();
@@ -535,12 +549,13 @@ void P3Microphysics::initialize_impl(const RunType /* run_type */) {
 #endif
 
   // -- Set values for the post-amble structure
-  p3_postproc.set_variables(m_num_cols, nk_pack, prog_state.th, pmid, pmid_dry, T_atm, t_prev, pseudo_density,
-                            pseudo_density_dry, prog_state.qv, prog_state.qc, prog_state.nc, prog_state.qr,
-                            prog_state.nr, prog_state.qi, prog_state.qm, prog_state.ni, prog_state.bm, qv_prev,
-                            diag_outputs.diag_eff_radius_qc, diag_outputs.diag_eff_radius_qi,
-                            diag_outputs.diag_eff_radius_qr, diag_outputs.precip_liq_surf, diag_outputs.precip_ice_surf,
-                            precip_liq_surf_mass, precip_ice_surf_mass);
+  p3_postproc.set_variables(
+      m_num_cols, nk_pack, prog_state.th, pmid, pmid_dry, T_atm, t_prev, pseudo_density,
+      pseudo_density_dry, prog_state.qv, prog_state.qc, prog_state.nc, prog_state.qr, prog_state.nr,
+      prog_state.qi, prog_state.qm, prog_state.ni, prog_state.bm, qv_prev,
+      diag_outputs.diag_eff_radius_qc, diag_outputs.diag_eff_radius_qi,
+      diag_outputs.diag_eff_radius_qr, diag_outputs.precip_liq_surf, diag_outputs.precip_ice_surf,
+      precip_liq_surf_mass, precip_ice_surf_mass);
 
   if (has_column_conservation_check()) {
     const auto &vapor_flux = get_field_out("vapor_flux").get_view<Real *>();
@@ -551,7 +566,8 @@ void P3Microphysics::initialize_impl(const RunType /* run_type */) {
   }
 
   // Setup WSM for internal local variables
-  const auto policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nk_pack);
+  const auto policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nk_pack);
   workspace_mgr.setup(m_buffer.wsm_data, nk_pack_p1, 52, policy);
 }
 
diff --git i/components/eamxx/src/physics/p3/eamxx_p3_process_interface.hpp w/components/eamxx/src/physics/p3/eamxx_p3_process_interface.hpp
index 663495b77b..1eacd08cb3 100644
--- i/components/eamxx/src/physics/p3/eamxx_p3_process_interface.hpp
+++ w/components/eamxx/src/physics/p3/eamxx_p3_process_interface.hpp
@@ -78,39 +78,50 @@ public:
         const Spack &pseudo_density_dry_pack(pseudo_density_dry(icol, ipack));
 
         // compute dz from full pressure
-        dz(icol, ipack) = PF::calculate_dz(pseudo_density_pack, pmid_pack, T_atm_pack, qv(icol, ipack));
+        dz(icol, ipack) =
+            PF::calculate_dz(pseudo_density_pack, pmid_pack, T_atm_pack, qv(icol, ipack));
 
         /*----------------------------------------------------------------------------------------------------------------------
          *Wet to dry mixing ratios:
          *-------------------------
          *Since state constituents from the host model (or AD) are  wet mixing ratios and P3 needs
-         *these constituents in dry mixing ratios, we convert the wet mixing ratios to dry mixing ratios.
+         *these constituents in dry mixing ratios, we convert the wet mixing ratios to dry mixing
+         *ratios.
          *----------------------------------------------------------------------------------------------------------------------
          */
 
-        // Units of all constituents below are [kg/kg(dry-air)] for mass and [#/kg(dry-air)] for number
-        qc(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(qc(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Cloud liquid mass
-        nc(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(nc(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Cloud liquid numbe
-        qr(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(qr(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Rain mass
-        nr(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(nr(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Rain number
-        qi(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(qi(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Cloud ice mass
-        ni(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(ni(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Cloud ice number
-        qm(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(qm(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Rimmed ice mass
-        bm(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(bm(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Rimmed ice number
-        qv(icol, ipack) =
-            PF::calculate_drymmr_from_wetmmr_dp_based(qv(icol, ipack), pseudo_density_pack, pseudo_density_dry_pack);
+        // Units of all constituents below are [kg/kg(dry-air)] for mass and [#/kg(dry-air)] for
+        // number
+        qc(icol, ipack) =
+            PF::calculate_drymmr_from_wetmmr_dp_based(qc(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Cloud liquid mass
+        nc(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(
+            nc(icol, ipack), pseudo_density_pack,
+            pseudo_density_dry_pack); // Cloud liquid numbe
+        qr(icol, ipack) =
+            PF::calculate_drymmr_from_wetmmr_dp_based(qr(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Rain mass
+        nr(icol, ipack) =
+            PF::calculate_drymmr_from_wetmmr_dp_based(nr(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Rain number
+        qi(icol, ipack) =
+            PF::calculate_drymmr_from_wetmmr_dp_based(qi(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Cloud ice mass
+        ni(icol, ipack) =
+            PF::calculate_drymmr_from_wetmmr_dp_based(ni(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Cloud ice number
+        qm(icol, ipack) =
+            PF::calculate_drymmr_from_wetmmr_dp_based(qm(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Rimmed ice mass
+        bm(icol, ipack) =
+            PF::calculate_drymmr_from_wetmmr_dp_based(bm(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Rimmed ice number
+        qv(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(
+            qv(icol, ipack), pseudo_density_pack, pseudo_density_dry_pack);
 
         // Water vapor from previous time step
-        qv_prev(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(qv_prev(icol, ipack), pseudo_density_pack,
-                                                                         pseudo_density_dry_pack);
+        qv_prev(icol, ipack) = PF::calculate_drymmr_from_wetmmr_dp_based(
+            qv_prev(icol, ipack), pseudo_density_pack, pseudo_density_dry_pack);
 
         // Exner from full pressure
         const auto &exner      = PF::exner_function(pmid_pack);
@@ -121,13 +132,18 @@ public:
         // Set minimum cloud fraction - avoids division by zero
         // Alternatively set fraction to 1 everywhere to disable subgrid effects
         if (runtime_opts.use_separate_ice_liq_frac) {
-          cld_frac_l(icol, ipack) = runtime_opts.set_cld_frac_l_to_one ? 1 : ekat::max(cld_frac_l_in_pack, mincld);
-          cld_frac_i(icol, ipack) = runtime_opts.set_cld_frac_i_to_one ? 1 : ekat::max(cld_frac_i_in_pack, mincld);
+          cld_frac_l(icol, ipack) =
+              runtime_opts.set_cld_frac_l_to_one ? 1 : ekat::max(cld_frac_l_in_pack, mincld);
+          cld_frac_i(icol, ipack) =
+              runtime_opts.set_cld_frac_i_to_one ? 1 : ekat::max(cld_frac_i_in_pack, mincld);
         } else {
-          cld_frac_l(icol, ipack) = runtime_opts.set_cld_frac_l_to_one ? 1 : ekat::max(cld_frac_t_in_pack, mincld);
-          cld_frac_i(icol, ipack) = runtime_opts.set_cld_frac_i_to_one ? 1 : ekat::max(cld_frac_t_in_pack, mincld);
+          cld_frac_l(icol, ipack) =
+              runtime_opts.set_cld_frac_l_to_one ? 1 : ekat::max(cld_frac_t_in_pack, mincld);
+          cld_frac_i(icol, ipack) =
+              runtime_opts.set_cld_frac_i_to_one ? 1 : ekat::max(cld_frac_t_in_pack, mincld);
         }
-        cld_frac_r(icol, ipack) = runtime_opts.set_cld_frac_r_to_one ? 1 : ekat::max(cld_frac_t_in_pack, mincld);
+        cld_frac_r(icol, ipack) =
+            runtime_opts.set_cld_frac_r_to_one ? 1 : ekat::max(cld_frac_t_in_pack, mincld);
 
         // update rain cloud fraction given neighboring levels using max-overlap approach.
         if (not runtime_opts.set_cld_frac_r_to_one) {
@@ -136,11 +152,15 @@ public:
           Spack cld_frac_t_in_k, cld_frac_t_in_km1;
           auto range_pack1 = ekat::range<IntSpack>(ipack * Spack::n);
           auto range_pack2 = range_pack1;
-          range_pack2.set(range_pack1 < 1, 1); // don't want the shift to go below zero. we mask out that result anyway
-          ekat::index_and_shift<-1>(cld_frac_t_in_s, range_pack2, cld_frac_t_in_k, cld_frac_t_in_km1);
+          range_pack2.set(
+              range_pack1 < 1,
+              1); // don't want the shift to go below zero. we mask out that result anyway
+          ekat::index_and_shift<-1>(cld_frac_t_in_s, range_pack2, cld_frac_t_in_k,
+                                    cld_frac_t_in_km1);
 
-          // Hard-coded max-overlap cloud fraction calculation.  Cycle through the layers from top to bottom and
-          // determine if the rain fraction needs to be updated to match the cloud fraction in the layer above.
+          // Hard-coded max-overlap cloud fraction calculation.  Cycle through the layers from top
+          // to bottom and determine if the rain fraction needs to be updated to match the cloud
+          // fraction in the layer above.
           const auto active_range = range_pack1 > 0 && range_pack1 < m_nlev;
           if (active_range.any()) {
             const auto set_to_t_in = cld_frac_t_in_km1 > cld_frac_r(icol, ipack);
@@ -152,8 +172,8 @@ public:
 
     // Local variables
     int m_ncol, m_nlev;
-    Real mincld =
-        0.0001; // TODO: These should be stored somewhere as more universal constants.  Or maybe in the P3 class hpp
+    Real mincld = 0.0001; // TODO: These should be stored somewhere as more universal constants.  Or
+                          // maybe in the P3 class hpp
     view_2d_const pmid;
     view_2d_const pmid_dry;
     view_2d_const pseudo_density;
@@ -181,14 +201,17 @@ public:
     // Add runtime_options as a member variable
     P3F::P3Runtime runtime_opts;
     // Assigning local variables
-    void set_variables(const int ncol, const int nlev, const view_2d_const &pmid_, const view_2d_const &pmid_dry_,
-                       const view_2d_const &pseudo_density_, const view_2d_const &pseudo_density_dry_,
-                       const view_2d &T_atm_, const view_2d_const &cld_frac_t_in_, const view_2d_const &cld_frac_l_in_,
-                       const view_2d_const &cld_frac_i_in_, const view_2d &qv_, const view_2d &qc_, const view_2d &nc_,
-                       const view_2d &qr_, const view_2d &nr_, const view_2d &qi_, const view_2d &qm_,
-                       const view_2d &ni_, const view_2d &bm_, const view_2d &qv_prev_, const view_2d &inv_exner_,
-                       const view_2d &th_atm_, const view_2d &cld_frac_l_, const view_2d &cld_frac_i_,
-                       const view_2d &cld_frac_r_, const view_2d &dz_, const P3F::P3Runtime &runtime_options) {
+    void set_variables(const int ncol, const int nlev, const view_2d_const &pmid_,
+                       const view_2d_const &pmid_dry_, const view_2d_const &pseudo_density_,
+                       const view_2d_const &pseudo_density_dry_, const view_2d &T_atm_,
+                       const view_2d_const &cld_frac_t_in_, const view_2d_const &cld_frac_l_in_,
+                       const view_2d_const &cld_frac_i_in_, const view_2d &qv_, const view_2d &qc_,
+                       const view_2d &nc_, const view_2d &qr_, const view_2d &nr_,
+                       const view_2d &qi_, const view_2d &qm_, const view_2d &ni_,
+                       const view_2d &bm_, const view_2d &qv_prev_, const view_2d &inv_exner_,
+                       const view_2d &th_atm_, const view_2d &cld_frac_l_,
+                       const view_2d &cld_frac_i_, const view_2d &cld_frac_r_, const view_2d &dz_,
+                       const P3F::P3Runtime &runtime_options) {
       m_ncol = ncol;
       m_nlev = nlev;
       // IN
@@ -241,7 +264,8 @@ public:
         {
           // this computes rescaled dT
           const Spack T_atm_before_p3 = T_atm(icol, ipack);
-          T_atm(icol, ipack) = (PF::calculate_T_from_theta(th_atm(icol, ipack), pmid(icol, ipack)) - T_atm_before_p3) *
+          T_atm(icol, ipack) = (PF::calculate_T_from_theta(th_atm(icol, ipack), pmid(icol, ipack)) -
+                                T_atm_before_p3) *
                                pseudo_density_dry(icol, ipack) / pseudo_density(icol, ipack);
           // add rescaled dT to T
           T_atm(icol, ipack) += T_atm_before_p3;
@@ -251,29 +275,38 @@ public:
         /*----------------------------------------------------------------------------------------------------------------------
          *DRY-TO-WET MMRs:
          *-----------------
-         *Since the host model (or AD) needs wet mixing ratios, we need to convert dry mixing ratios from P3 to
-         *wet mixing ratios.
+         *Since the host model (or AD) needs wet mixing ratios, we need to convert dry mixing ratios
+         *from P3 to wet mixing ratios.
          *----------------------------------------------------------------------------------------------------------------------
          */
-        // Units of all constituents below are [kg/kg(wet-air)] for mass and [#/kg(wet-air)] for number
-        qc(icol, ipack) = PF::calculate_wetmmr_from_drymmr_dp_based(qc(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Cloud liquid mass
-        nc(icol, ipack) = PF::calculate_wetmmr_from_drymmr_dp_based(nc(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Cloud liquid number
-        qr(icol, ipack) = PF::calculate_wetmmr_from_drymmr_dp_based(qr(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Rain mass
-        nr(icol, ipack) = PF::calculate_wetmmr_from_drymmr_dp_based(nr(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Rain number
-        qi(icol, ipack) = PF::calculate_wetmmr_from_drymmr_dp_based(qi(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Cloud ice mass
-        ni(icol, ipack) = PF::calculate_wetmmr_from_drymmr_dp_based(ni(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Cloud ice number
-        qm(icol, ipack) = PF::calculate_wetmmr_from_drymmr_dp_based(qm(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Rimmed ice mass
-        bm(icol, ipack) = PF::calculate_wetmmr_from_drymmr_dp_based(bm(icol, ipack), pseudo_density_pack,
-                                                                    pseudo_density_dry_pack); // Rimmed ice number
-        qv(icol, ipack) =
-            PF::calculate_wetmmr_from_drymmr_dp_based(qv(icol, ipack), pseudo_density_pack, pseudo_density_dry_pack);
+        // Units of all constituents below are [kg/kg(wet-air)] for mass and [#/kg(wet-air)] for
+        // number
+        qc(icol, ipack) =
+            PF::calculate_wetmmr_from_drymmr_dp_based(qc(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Cloud liquid mass
+        nc(icol, ipack) = PF::calculate_wetmmr_from_drymmr_dp_based(
+            nc(icol, ipack), pseudo_density_pack,
+            pseudo_density_dry_pack); // Cloud liquid number
+        qr(icol, ipack) =
+            PF::calculate_wetmmr_from_drymmr_dp_based(qr(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Rain mass
+        nr(icol, ipack) =
+            PF::calculate_wetmmr_from_drymmr_dp_based(nr(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Rain number
+        qi(icol, ipack) =
+            PF::calculate_wetmmr_from_drymmr_dp_based(qi(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Cloud ice mass
+        ni(icol, ipack) =
+            PF::calculate_wetmmr_from_drymmr_dp_based(ni(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Cloud ice number
+        qm(icol, ipack) =
+            PF::calculate_wetmmr_from_drymmr_dp_based(qm(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Rimmed ice mass
+        bm(icol, ipack) =
+            PF::calculate_wetmmr_from_drymmr_dp_based(bm(icol, ipack), pseudo_density_pack,
+                                                      pseudo_density_dry_pack); // Rimmed ice number
+        qv(icol, ipack) = PF::calculate_wetmmr_from_drymmr_dp_based(
+            qv(icol, ipack), pseudo_density_pack, pseudo_density_dry_pack);
         qv_prev(icol, ipack) = qv(icol, ipack);
 
         // Rescale effective radius' into microns
@@ -337,15 +370,16 @@ public:
     view_1d ice_flux;
     view_1d heat_flux;
 
-    void set_variables(const int ncol, const int npack, const view_2d &th_atm_, const view_2d_const &pmid_,
-                       const view_2d_const &pmid_dry_, const view_2d &T_atm_, const view_2d &T_prev_,
-                       const view_2d_const &pseudo_density_, const view_2d_const &pseudo_density_dry_,
-                       const view_2d &qv_, const view_2d &qc_, const view_2d &nc_, const view_2d &qr_,
-                       const view_2d &nr_, const view_2d &qi_, const view_2d &qm_, const view_2d &ni_,
-                       const view_2d &bm_, const view_2d &qv_prev_, const view_2d &diag_eff_radius_qc_,
-                       const view_2d &diag_eff_radius_qi_, const view_2d &diag_eff_radius_qr_,
-                       const view_1d_const &precip_liq_surf_flux_, const view_1d_const &precip_ice_surf_flux_,
-                       const view_1d &precip_liq_surf_mass_, const view_1d &precip_ice_surf_mass_) {
+    void set_variables(
+        const int ncol, const int npack, const view_2d &th_atm_, const view_2d_const &pmid_,
+        const view_2d_const &pmid_dry_, const view_2d &T_atm_, const view_2d &T_prev_,
+        const view_2d_const &pseudo_density_, const view_2d_const &pseudo_density_dry_,
+        const view_2d &qv_, const view_2d &qc_, const view_2d &nc_, const view_2d &qr_,
+        const view_2d &nr_, const view_2d &qi_, const view_2d &qm_, const view_2d &ni_,
+        const view_2d &bm_, const view_2d &qv_prev_, const view_2d &diag_eff_radius_qc_,
+        const view_2d &diag_eff_radius_qi_, const view_2d &diag_eff_radius_qr_,
+        const view_1d_const &precip_liq_surf_flux_, const view_1d_const &precip_ice_surf_flux_,
+        const view_1d &precip_liq_surf_mass_, const view_1d &precip_ice_surf_mass_) {
       m_ncol  = ncol;
       m_npack = npack;
       // IN
@@ -383,8 +417,8 @@ public:
       // COSP Vars: flxprc, flxsnw, flxprc, flxsnw, cvreffliq, cvreffice, reffsnow
     } // set_variables
 
-    void set_mass_and_energy_fluxes(const view_1d &vapor_flux_, const view_1d &water_flux_, const view_1d &ice_flux_,
-                                    const view_1d &heat_flux_) {
+    void set_mass_and_energy_fluxes(const view_1d &vapor_flux_, const view_1d &water_flux_,
+                                    const view_1d &ice_flux_, const view_1d &heat_flux_) {
       compute_mass_and_energy_fluxes = true;
       vapor_flux                     = vapor_flux_;
       water_flux                     = water_flux_;
@@ -397,8 +431,9 @@ public:
   // Structure for storing local variables initialized using the ATMBufferManager
   struct Buffer {
     // 1d view scalar, size (ncol)
-    static constexpr int num_1d_scalar = 2; // no 2d vars now, but keeping 1d struct for future expansion
-    // 2d view packed, size (ncol, nlev_packs)
+    static constexpr int num_1d_scalar =
+        2; // no 2d vars now, but keeping 1d struct for future expansion
+           // 2d view packed, size (ncol, nlev_packs)
 #ifdef SCREAM_P3_SMALL_KERNELS
     static constexpr int num_2d_vector = 63;
 #else
@@ -420,11 +455,12 @@ public:
     uview_2d unused;
 
 #ifdef SCREAM_P3_SMALL_KERNELS
-    uview_2d mu_r, T_atm, lamr, logn0r, nu, cdist, cdist1, cdistr, inv_cld_frac_i, inv_cld_frac_l, inv_cld_frac_r,
-        qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld, bm_incld, inv_dz, inv_rho, ze_ice,
-        ze_rain, prec, rho, rhofacr, rhofaci, acn, qv_sat_l, qv_sat_i, sup, qv_supersat_i, tmparr2, exner, diag_vm_qi,
-        diag_diam_qi, pratot, prctot, qtend_ignore, ntend_ignore, mu_c, lamc, qr_evap_tend, v_qc, v_nc, flux_qx,
-        flux_nx, v_qit, v_nit, flux_nit, flux_bir, flux_qir, flux_qit, v_qr, v_nr;
+    uview_2d mu_r, T_atm, lamr, logn0r, nu, cdist, cdist1, cdistr, inv_cld_frac_i, inv_cld_frac_l,
+        inv_cld_frac_r, qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld,
+        bm_incld, inv_dz, inv_rho, ze_ice, ze_rain, prec, rho, rhofacr, rhofaci, acn, qv_sat_l,
+        qv_sat_i, sup, qv_supersat_i, tmparr2, exner, diag_vm_qi, diag_diam_qi, pratot, prctot,
+        qtend_ignore, ntend_ignore, mu_c, lamc, qr_evap_tend, v_qc, v_nc, flux_qx, flux_nx, v_qit,
+        v_nit, flux_nit, flux_bir, flux_qir, flux_qit, v_qr, v_nr;
 #endif
 
     suview_2d col_location;
@@ -471,8 +507,9 @@ protected:
   ekat::WorkspaceManager<Spack, KT::Device> workspace_mgr;
 
   std::shared_ptr<const AbstractGrid> m_grid;
-  // Iteration count is internal to P3 and keeps track of the number of times p3_main has been called.
-  // infrastructure.it is passed as an arguement to p3_main and is used for identifying which iteration an error occurs.
+  // Iteration count is internal to P3 and keeps track of the number of times p3_main has been
+  // called. infrastructure.it is passed as an arguement to p3_main and is used for identifying
+  // which iteration an error occurs.
 
 }; // class P3Microphysics
 
diff --git i/components/eamxx/src/physics/p3/eamxx_p3_run.cpp w/components/eamxx/src/physics/p3/eamxx_p3_run.cpp
index 0600d618f9..2d9a18806b 100644
--- i/components/eamxx/src/physics/p3/eamxx_p3_run.cpp
+++ w/components/eamxx/src/physics/p3/eamxx_p3_run.cpp
@@ -8,7 +8,8 @@ void P3Microphysics::run_impl(const double dt) {
 
   // Create policy for pre and post process pfor
   const auto nlev_packs = ekat::npack<Spack>(m_num_levs);
-  const auto policy     = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
+  const auto policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
 
   // Assign values to local arrays used by P3, these are now stored in p3_loc.
   Kokkos::parallel_for("p3_pre_process", policy, p3_preproc);
@@ -46,7 +47,8 @@ void P3Microphysics::run_impl(const double dt) {
     get_field_out("qi_sed").deep_copy(0.0);
   }
 
-  P3F::p3_main(runtime_options, prog_state, diag_inputs, diag_outputs, infrastructure, history_only, lookup_tables,
+  P3F::p3_main(runtime_options, prog_state, diag_inputs, diag_outputs, infrastructure, history_only,
+               lookup_tables,
 #ifdef SCREAM_P3_SMALL_KERNELS
                temporaries,
 #endif
diff --git i/components/eamxx/src/physics/p3/eti/p3_upwind.cpp w/components/eamxx/src/physics/p3/eti/p3_upwind.cpp
index 1f0e76fdc4..b281cb386f 100644
--- i/components/eamxx/src/physics/p3/eti/p3_upwind.cpp
+++ w/components/eamxx/src/physics/p3/eti/p3_upwind.cpp
@@ -8,22 +8,24 @@ namespace p3 {
  * default device.
  */
 
-#define ETI_UPWIND(nfield)                                                                                           \
-  template void Functions<Real, DefaultDevice>::calc_first_order_upwind_step<nfield>(                                \
-      const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &inv_dz,   \
-      const MemberType &team, const Int &nk, const Int &k_bot, const Int &k_top, const Int &kdir,                    \
-      const Scalar &dt_sub, const view_1d_ptr_array<Spack, nfield> &flux, const view_1d_ptr_array<Spack, nfield> &V, \
+#define ETI_UPWIND(nfield)                                                                     \
+  template void Functions<Real, DefaultDevice>::calc_first_order_upwind_step<nfield>(          \
+      const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,                  \
+      const uview_1d<const Spack> &inv_dz, const MemberType &team, const Int &nk,              \
+      const Int &k_bot, const Int &k_top, const Int &kdir, const Scalar &dt_sub,               \
+      const view_1d_ptr_array<Spack, nfield> &flux, const view_1d_ptr_array<Spack, nfield> &V, \
       const view_1d_ptr_array<Spack, nfield> &r);
 ETI_UPWIND(1)
 ETI_UPWIND(2)
 ETI_UPWIND(4)
 #undef ETI_UPWIND
 
-#define ETI_GENSED(nfield)                                                                                         \
-  template void Functions<Real, DefaultDevice>::generalized_sedimentation<nfield>(                                 \
-      const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &inv_dz, \
-      const MemberType &team, const Int &nk, const Int &k_qxtop, Int &k_qxbot, const Int &kbot, const Int &kdir,   \
-      const Scalar &Co_max, Scalar &dt_left, Scalar &prt_accum, const view_1d_ptr_array<Spack, nfield> &flux,      \
+#define ETI_GENSED(nfield)                                                                      \
+  template void Functions<Real, DefaultDevice>::generalized_sedimentation<nfield>(              \
+      const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,                   \
+      const uview_1d<const Spack> &inv_dz, const MemberType &team, const Int &nk,               \
+      const Int &k_qxtop, Int &k_qxbot, const Int &kbot, const Int &kdir, const Scalar &Co_max, \
+      Scalar &dt_left, Scalar &prt_accum, const view_1d_ptr_array<Spack, nfield> &flux,         \
       const view_1d_ptr_array<Spack, nfield> &V, const view_1d_ptr_array<Spack, nfield> &r);
 ETI_GENSED(1)
 ETI_GENSED(2)
diff --git i/components/eamxx/src/physics/p3/impl/p3_autoconversion_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_autoconversion_impl.hpp
index d3a04e89a8..31442e5805 100644
--- i/components/eamxx/src/physics/p3/impl/p3_autoconversion_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_autoconversion_impl.hpp
@@ -8,11 +8,10 @@ namespace scream {
 namespace p3 {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::cloud_water_autoconversion(const Spack &rho, const Spack &qc_incld,
-                                                                 const Spack &nc_incld, const Spack &inv_qc_relvar,
-                                                                 Spack &qc2qr_autoconv_tend, Spack &nc2nr_autoconv_tend,
-                                                                 Spack &ncautr, const P3Runtime &runtime_options,
-                                                                 const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::cloud_water_autoconversion(
+    const Spack &rho, const Spack &qc_incld, const Spack &nc_incld, const Spack &inv_qc_relvar,
+    Spack &qc2qr_autoconv_tend, Spack &nc2nr_autoconv_tend, Spack &ncautr,
+    const P3Runtime &runtime_options, const Smask &context) {
 
   // Khroutdinov and Kogan (2000)
   const auto qc_not_small = qc_incld >= 1e-8 && context;
@@ -35,9 +34,10 @@ KOKKOS_FUNCTION void Functions<S, D>::cloud_water_autoconversion(const Spack &rh
     // sgs_var_coef = subgrid_variance_scaling(inv_qc_relvar, sp(2.47) );
     sgs_var_coef = 1;
 
-    qc2qr_autoconv_tend.set(qc_not_small, sgs_var_coef * autoconversion_prefactor *
-                                              pow(qc_incld, autoconversion_qc_exponent) *
-                                              pow(nc_incld * sp(1.e-6) * rho, -autoconversion_nc_exponent));
+    qc2qr_autoconv_tend.set(qc_not_small,
+                            sgs_var_coef * autoconversion_prefactor *
+                                pow(qc_incld, autoconversion_qc_exponent) *
+                                pow(nc_incld * sp(1.e-6) * rho, -autoconversion_nc_exponent));
     // note: ncautr is change in Nr; nc2nr_autoconv_tend is change in Nc
     ncautr.set(qc_not_small, qc2qr_autoconv_tend * CONS3);
     nc2nr_autoconv_tend.set(qc_not_small, qc2qr_autoconv_tend * nc_incld / qc_incld);
diff --git i/components/eamxx/src/physics/p3/impl/p3_back_to_cell_average_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_back_to_cell_average_impl.hpp
index f743c76c4b..8b803324a0 100644
--- i/components/eamxx/src/physics/p3/impl/p3_back_to_cell_average_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_back_to_cell_average_impl.hpp
@@ -13,22 +13,26 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::back_to_cell_average(
-    const Spack &cld_frac_l, const Spack &cld_frac_r, const Spack &cld_frac_i, Spack &qc2qr_accret_tend,
-    Spack &qr2qv_evap_tend, Spack &qc2qr_autoconv_tend, Spack &nc_accret_tend, Spack &nc_selfcollect_tend,
-    Spack &nc2nr_autoconv_tend, Spack &nr_selfcollect_tend, Spack &nr_evap_tend, Spack &ncautr,
-    Spack &qi2qv_sublim_tend, Spack &nr_ice_shed_tend, Spack &qc2qi_hetero_freeze_tend, Spack &qr2qi_collect_tend,
-    Spack &qc2qr_ice_shed_tend, Spack &qi2qr_melt_tend, Spack &qc2qi_collect_tend, Spack &qr2qi_immers_freeze_tend,
-    Spack &ni2nr_melt_tend, Spack &nc_collect_tend, Spack &ncshdc, Spack &nc2ni_immers_freeze_tend,
-    Spack &nr_collect_tend, Spack &ni_selfcollect_tend, Spack &qv2qi_vapdep_tend, Spack &nr2ni_immers_freeze_tend,
-    Spack &ni_sublim_tend, Spack &qv2qi_nucleat_tend, Spack &ni_nucleat_tend, Spack &qc2qi_berg_tend, Spack &ncheti_cnt,
-    Spack &qcheti_cnt, Spack &nicnt, Spack &qicnt, Spack &ninuc_cnt, Spack &qinuc_cnt, const Smask &context,
-    const P3Runtime &runtime_options) {
+    const Spack &cld_frac_l, const Spack &cld_frac_r, const Spack &cld_frac_i,
+    Spack &qc2qr_accret_tend, Spack &qr2qv_evap_tend, Spack &qc2qr_autoconv_tend,
+    Spack &nc_accret_tend, Spack &nc_selfcollect_tend, Spack &nc2nr_autoconv_tend,
+    Spack &nr_selfcollect_tend, Spack &nr_evap_tend, Spack &ncautr, Spack &qi2qv_sublim_tend,
+    Spack &nr_ice_shed_tend, Spack &qc2qi_hetero_freeze_tend, Spack &qr2qi_collect_tend,
+    Spack &qc2qr_ice_shed_tend, Spack &qi2qr_melt_tend, Spack &qc2qi_collect_tend,
+    Spack &qr2qi_immers_freeze_tend, Spack &ni2nr_melt_tend, Spack &nc_collect_tend, Spack &ncshdc,
+    Spack &nc2ni_immers_freeze_tend, Spack &nr_collect_tend, Spack &ni_selfcollect_tend,
+    Spack &qv2qi_vapdep_tend, Spack &nr2ni_immers_freeze_tend, Spack &ni_sublim_tend,
+    Spack &qv2qi_nucleat_tend, Spack &ni_nucleat_tend, Spack &qc2qi_berg_tend, Spack &ncheti_cnt,
+    Spack &qcheti_cnt, Spack &nicnt, Spack &qicnt, Spack &ninuc_cnt, Spack &qinuc_cnt,
+    const Smask &context, const P3Runtime &runtime_options) {
   Spack ir_cldm, il_cldm, lr_cldm, cld_frac_glaciated;
-  ir_cldm = min(cld_frac_i, cld_frac_r); // Intersection of ICE and RAIN cloud
-  il_cldm = min(cld_frac_i, cld_frac_l); // Intersection of ICE and LIQUID cloud
-  lr_cldm = min(cld_frac_l, cld_frac_r); // Intersection of LIQUID and RAIN cloud
-  cld_frac_glaciated =
-      max(0.0001, cld_frac_i - il_cldm); // Fraction (if any) of cell that is occupied by only ice and not liquid cloud
+  ir_cldm            = min(cld_frac_i, cld_frac_r); // Intersection of ICE and RAIN cloud
+  il_cldm            = min(cld_frac_i, cld_frac_l); // Intersection of ICE and LIQUID cloud
+  lr_cldm            = min(cld_frac_l, cld_frac_r); // Intersection of LIQUID and RAIN cloud
+  cld_frac_glaciated = max(
+      0.0001,
+      cld_frac_i -
+          il_cldm); // Fraction (if any) of cell that is occupied by only ice and not liquid cloud
 
   // Some process rates take place within the intersection of liquid, rain and
   // ice cloud fractions. We calculate the intersection as the minimum between
@@ -39,49 +43,64 @@ KOKKOS_FUNCTION void Functions<S, D>::back_to_cell_average(
   qc2qr_accret_tend.set(context, qc2qr_accret_tend * lr_cldm);        // Accretion of liquid to rain
   qr2qv_evap_tend.set(context, qr2qv_evap_tend * cld_frac_r);         // Evaporation of rain
   qc2qr_autoconv_tend.set(context, qc2qr_autoconv_tend * cld_frac_l); // Autoconversion of liquid
-  nc_accret_tend.set(context, nc_accret_tend * lr_cldm);              // Number change due to accretion
-  nc_selfcollect_tend.set(context, nc_selfcollect_tend * cld_frac_l); // Self collection occurs locally in liq. cloud
-  nc2nr_autoconv_tend.set(context, nc2nr_autoconv_tend * cld_frac_l); // Impact of autoconversion on number
-  nr_selfcollect_tend.set(context, nr_selfcollect_tend * cld_frac_r); // Self collection occurs locally in rain cloud
-  nr_evap_tend.set(context, nr_evap_tend * cld_frac_r);               // Change in rain number due to evaporation
+  nc_accret_tend.set(context, nc_accret_tend * lr_cldm); // Number change due to accretion
+  nc_selfcollect_tend.set(context, nc_selfcollect_tend *
+                                       cld_frac_l); // Self collection occurs locally in liq. cloud
+  nc2nr_autoconv_tend.set(context,
+                          nc2nr_autoconv_tend * cld_frac_l); // Impact of autoconversion on number
+  nr_selfcollect_tend.set(context, nr_selfcollect_tend *
+                                       cld_frac_r); // Self collection occurs locally in rain cloud
+  nr_evap_tend.set(context, nr_evap_tend * cld_frac_r); // Change in rain number due to evaporation
   ncautr.set(context, ncautr * lr_cldm); // Autoconversion of rain drops within rain/liq cloud
 
   // map ice-phase  process rates to cell-avg
   if (runtime_options.use_separate_ice_liq_frac) {
     qi2qv_sublim_tend.set(context, qi2qv_sublim_tend * cld_frac_glaciated);
   } else {
-    qi2qv_sublim_tend.set(context, qi2qv_sublim_tend * cld_frac_i); // Sublimation of ice in ice cloud
+    qi2qv_sublim_tend.set(context,
+                          qi2qv_sublim_tend * cld_frac_i); // Sublimation of ice in ice cloud
   }
-  nr_ice_shed_tend.set(
-      context,
-      nr_ice_shed_tend *
-          il_cldm); // Rain # increase due to shedding from rain-ice collisions, occurs when ice and liquid interact
-  qc2qi_hetero_freeze_tend.set(context, qc2qi_hetero_freeze_tend * il_cldm); // Immersion freezing of cloud drops
-  qr2qi_collect_tend.set(context, qr2qi_collect_tend * ir_cldm);             // Collection of rain mass by ice
+  nr_ice_shed_tend.set(context,
+                       nr_ice_shed_tend *
+                           il_cldm); // Rain # increase due to shedding from rain-ice collisions,
+                                     // occurs when ice and liquid interact
+  qc2qi_hetero_freeze_tend.set(context, qc2qi_hetero_freeze_tend *
+                                            il_cldm); // Immersion freezing of cloud drops
+  qr2qi_collect_tend.set(context, qr2qi_collect_tend * ir_cldm); // Collection of rain mass by ice
   qc2qr_ice_shed_tend.set(context,
-                          qc2qr_ice_shed_tend * il_cldm); // Rain mass growth due to shedding of fain drops after
-                                                          // collisions with ice, occurs when ice and liquid interact
-  qi2qr_melt_tend.set(context, qi2qr_melt_tend * cld_frac_i);                   // Melting of ice
-  qc2qi_collect_tend.set(context, qc2qi_collect_tend * il_cldm);                // Collection of water by ice
-  qr2qi_immers_freeze_tend.set(context, qr2qi_immers_freeze_tend * cld_frac_r); // Immersion freezing of rain
-  ni2nr_melt_tend.set(context, ni2nr_melt_tend * cld_frac_i);                   // Change in number due to melting
-  nc_collect_tend.set(context, nc_collect_tend * il_cldm); // Cloud # change due to collection of cld water by ice
-  ncshdc.set(context, ncshdc * il_cldm); // Number change due to shedding, occurs when ice and liquid interact
-  nc2ni_immers_freeze_tend.set(context, nc2ni_immers_freeze_tend *
-                                            cld_frac_l);   // Number change associated with freexzing of cld drops
-  nr_collect_tend.set(context, nr_collect_tend * ir_cldm); // Rain number change due to collection from ice
+                          qc2qr_ice_shed_tend *
+                              il_cldm); // Rain mass growth due to shedding of fain drops after
+                                        // collisions with ice, occurs when ice and liquid interact
+  qi2qr_melt_tend.set(context, qi2qr_melt_tend * cld_frac_i);    // Melting of ice
+  qc2qi_collect_tend.set(context, qc2qi_collect_tend * il_cldm); // Collection of water by ice
+  qr2qi_immers_freeze_tend.set(context,
+                               qr2qi_immers_freeze_tend * cld_frac_r); // Immersion freezing of rain
+  ni2nr_melt_tend.set(context, ni2nr_melt_tend * cld_frac_i); // Change in number due to melting
+  nc_collect_tend.set(context, nc_collect_tend *
+                                   il_cldm); // Cloud # change due to collection of cld water by ice
+  ncshdc.set(context,
+             ncshdc *
+                 il_cldm); // Number change due to shedding, occurs when ice and liquid interact
+  nc2ni_immers_freeze_tend.set(
+      context, nc2ni_immers_freeze_tend *
+                   cld_frac_l); // Number change associated with freexzing of cld drops
+  nr_collect_tend.set(context,
+                      nr_collect_tend * ir_cldm); // Rain number change due to collection from ice
   ni_selfcollect_tend.set(context, ni_selfcollect_tend * cld_frac_i); // Ice self collection
   if (runtime_options.use_separate_ice_liq_frac) {
-    qv2qi_vapdep_tend.set(context, qv2qi_vapdep_tend * cld_frac_glaciated); // Vapor deposition to ice phase
+    qv2qi_vapdep_tend.set(context,
+                          qv2qi_vapdep_tend * cld_frac_glaciated); // Vapor deposition to ice phase
   } else {
     qv2qi_vapdep_tend.set(context, qv2qi_vapdep_tend * cld_frac_i); // Vapor deposition to ice phase
   }
-  nr2ni_immers_freeze_tend.set(context, nr2ni_immers_freeze_tend *
-                                            cld_frac_r); // Change in number due to immersion freezing of rain
+  nr2ni_immers_freeze_tend.set(
+      context,
+      nr2ni_immers_freeze_tend * cld_frac_r); // Change in number due to immersion freezing of rain
   if (runtime_options.use_separate_ice_liq_frac) {
     ni_sublim_tend.set(context, ni_sublim_tend * cld_frac_glaciated);
   } else {
-    ni_sublim_tend.set(context, ni_sublim_tend * cld_frac_i); // Number change due to sublimation of ice
+    ni_sublim_tend.set(context,
+                       ni_sublim_tend * cld_frac_i); // Number change due to sublimation of ice
   }
   qc2qi_berg_tend.set(context, qc2qi_berg_tend * il_cldm); // Bergeron process
   ncheti_cnt.set(context, ncheti_cnt * cld_frac_l);
@@ -91,10 +110,10 @@ KOKKOS_FUNCTION void Functions<S, D>::back_to_cell_average(
   ninuc_cnt.set(context, ninuc_cnt * cld_frac_l);
   qinuc_cnt.set(context, qinuc_cnt * cld_frac_l);
 
-  // AaronDonahue: These variables are related to aerosol activation and their usage will be changed in a later PR.
-  // qv2qi_nucleat_tend = qv2qi_nucleat_tend;           // Deposition and condensation-freezing nucleation, already
-  // cell-averaged ni_nucleat_tend = ni_nucleat_tend;           // Number change due to deposition and
-  // condensation-freezing, already cell-averaged
+  // AaronDonahue: These variables are related to aerosol activation and their usage will be changed
+  // in a later PR. qv2qi_nucleat_tend = qv2qi_nucleat_tend;           // Deposition and
+  // condensation-freezing nucleation, already cell-averaged ni_nucleat_tend = ni_nucleat_tend; //
+  // Number change due to deposition and condensation-freezing, already cell-averaged
 }
 
 } // namespace p3
diff --git i/components/eamxx/src/physics/p3/impl/p3_calc_liq_relaxation_timescale_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_calc_liq_relaxation_timescale_impl.hpp
index d7fddbc7ab..c1a8cb1c39 100644
--- i/components/eamxx/src/physics/p3/impl/p3_calc_liq_relaxation_timescale_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_calc_liq_relaxation_timescale_impl.hpp
@@ -13,9 +13,10 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::calc_liq_relaxation_timescale(
-    const view_2d_table &revap_table_vals, const Spack &rho, const Scalar &f1r, const Scalar &f2r, const Spack &dv,
-    const Spack &mu, const Spack &sc, const Spack &mu_r, const Spack &lamr, const Spack &cdistr, const Spack &cdist,
-    const Spack &qr_incld, const Spack &qc_incld, Spack &epsr, Spack &epsc, const Smask &context) {
+    const view_2d_table &revap_table_vals, const Spack &rho, const Scalar &f1r, const Scalar &f2r,
+    const Spack &dv, const Spack &mu, const Spack &sc, const Spack &mu_r, const Spack &lamr,
+    const Spack &cdistr, const Spack &cdist, const Spack &qr_incld, const Spack &qc_incld,
+    Spack &epsr, Spack &epsc, const Smask &context) {
   constexpr Scalar qsmall = C::QSMALL;
   constexpr Scalar pi     = C::Pi;
 
@@ -24,9 +25,10 @@ KOKKOS_FUNCTION void Functions<S, D>::calc_liq_relaxation_timescale(
   if (qr_not_small.any()) {
     Table3 table;
     lookup(mu_r, lamr, table, qr_not_small);
-    epsr.set(qr_not_small, 2 * pi * cdistr * rho * dv *
-                               (f1r * tgamma(mu_r + 2) / lamr +
-                                f2r * sqrt(rho / mu) * cbrt(sc) * apply_table(revap_table_vals, table)));
+    epsr.set(qr_not_small,
+             2 * pi * cdistr * rho * dv *
+                 (f1r * tgamma(mu_r + 2) / lamr +
+                  f2r * sqrt(rho / mu) * cbrt(sc) * apply_table(revap_table_vals, table)));
   }
 
   const auto qc_not_small = (qc_incld >= qsmall) && context;
diff --git i/components/eamxx/src/physics/p3/impl/p3_calc_rime_density_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_calc_rime_density_impl.hpp
index 8926634fce..62db569eb7 100644
--- i/components/eamxx/src/physics/p3/impl/p3_calc_rime_density_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_calc_rime_density_impl.hpp
@@ -12,11 +12,10 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::calc_rime_density(const Spack &T_atm, const Spack &rhofaci,
-                                                        const Spack &table_val_qi_fallspd, const Spack &acn,
-                                                        const Spack &lamc, const Spack &mu_c, const Spack &qc_incld,
-                                                        const Spack &qc2qi_collect_tend, Spack &vtrmi1,
-                                                        Spack &rho_qm_cloud, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::calc_rime_density(
+    const Spack &T_atm, const Spack &rhofaci, const Spack &table_val_qi_fallspd, const Spack &acn,
+    const Spack &lamc, const Spack &mu_c, const Spack &qc_incld, const Spack &qc2qi_collect_tend,
+    Spack &vtrmi1, Spack &rho_qm_cloud, const Smask &context) {
   constexpr Scalar qsmall     = C::QSMALL;
   constexpr Scalar T_zerodegc = C::T_zerodegc;
   constexpr Scalar bcn        = C::bcn;
diff --git i/components/eamxx/src/physics/p3/impl/p3_check_values_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_check_values_impl.hpp
index 5049d8e953..b5401d1f8d 100644
--- i/components/eamxx/src/physics/p3/impl/p3_check_values_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_check_values_impl.hpp
@@ -23,10 +23,11 @@ namespace p3 {
   -----------------------------------------------------------------------------------
 */
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::check_values(const uview_1d<const Spack> &qv, const uview_1d<const Spack> &temp,
-                                                   const Int &ktop, const Int &kbot, const Int &timestepcount,
-                                                   const bool &force_abort, const Int &source_ind,
-                                                   const MemberType &team, const uview_1d<const Scalar> &col_loc) {
+KOKKOS_FUNCTION void
+Functions<S, D>::check_values(const uview_1d<const Spack> &qv, const uview_1d<const Spack> &temp,
+                              const Int &ktop, const Int &kbot, const Int &timestepcount,
+                              const bool &force_abort, const Int &source_ind,
+                              const MemberType &team, const uview_1d<const Scalar> &col_loc) {
   constexpr Scalar T_low  = 173.;
   constexpr Scalar T_high = 323.;
   constexpr Scalar Q_high = 40.e-3;
@@ -52,16 +53,17 @@ KOKKOS_FUNCTION void Functions<S, D>::check_values(const uview_1d<const Spack> &
     if (t_out_bounds.any()) {
       for (int s = 0; s < Spack::n; ++s) {
         trap = true;
-        // printf ("** WARNING IN P3_MAIN -- src, gcol, lon, lat, lvl, tstep, T: %d, %d, %13.6f, %13.6f, %d, %d,
-        // %13.6f\n" ,source_ind,static_cast<int>(col_loc(0)),col_loc(1),col_loc(2),pk,timestepcount,temp(pk)[s]);
+        // printf ("** WARNING IN P3_MAIN -- src, gcol, lon, lat, lvl, tstep, T: %d, %d, %13.6f,
+        // %13.6f, %d, %d, %13.6f\n"
+        // ,source_ind,static_cast<int>(col_loc(0)),col_loc(1),col_loc(2),pk,timestepcount,temp(pk)[s]);
       }
     }
 
     if (qv_out_bounds.any()) {
       for (int s = 0; s < Spack::n; ++s) {
         // trap = .true.  !note, tentatively no trap, since Qv could be negative passed in to mp
-        // printf ("** WARNING IN P3_MAIN -- src, gcol, lon, lat, lvl, tstep, Qv: %d, %d, %13.6f, %13.6f, %d, %d,
-        // %13.6f\n"
+        // printf ("** WARNING IN P3_MAIN -- src, gcol, lon, lat, lvl, tstep, Qv: %d, %d, %13.6f,
+        // %13.6f, %d, %d, %13.6f\n"
         //        ,source_ind,static_cast<int>(col_loc(0)),col_loc(1),col_loc(2),pk,timestepcount,qv(pk)[s]);
       }
     }
diff --git i/components/eamxx/src/physics/p3/impl/p3_cldliq_imm_freezing_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_cldliq_imm_freezing_impl.hpp
index 9e4425611a..a4fbed1d75 100644
--- i/components/eamxx/src/physics/p3/impl/p3_cldliq_imm_freezing_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_cldliq_imm_freezing_impl.hpp
@@ -13,11 +13,10 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::cldliq_immersion_freezing(const Spack &T_atm, const Spack &lamc, const Spack &mu_c,
-                                           const Spack &cdist1, const Spack &qc_incld, const Spack &inv_qc_relvar,
-                                           Spack &qc2qi_hetero_freeze_tend, Spack &nc2ni_immers_freeze_tend,
-                                           const P3Runtime &runtime_options, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::cldliq_immersion_freezing(
+    const Spack &T_atm, const Spack &lamc, const Spack &mu_c, const Spack &cdist1,
+    const Spack &qc_incld, const Spack &inv_qc_relvar, Spack &qc2qi_hetero_freeze_tend,
+    Spack &nc2ni_immers_freeze_tend, const P3Runtime &runtime_options, const Smask &context) {
   constexpr Scalar qsmall                  = C::QSMALL;
   constexpr Scalar T_rainfrz               = C::T_rainfrz;
   constexpr Scalar T_zerodegc              = C::T_zerodegc;
@@ -28,15 +27,17 @@ Functions<S, D>::cldliq_immersion_freezing(const Spack &T_atm, const Spack &lamc
   const auto qc_not_small_and_t_freezing = (qc_incld >= qsmall) && (T_atm <= T_rainfrz) && context;
   if (qc_not_small_and_t_freezing.any()) {
     Spack expAimmDt, inv_lamc3;
-    expAimmDt.set(qc_not_small_and_t_freezing, exp(immersion_freezing_exponent * (T_zerodegc - T_atm)));
+    expAimmDt.set(qc_not_small_and_t_freezing,
+                  exp(immersion_freezing_exponent * (T_zerodegc - T_atm)));
     inv_lamc3.set(qc_not_small_and_t_freezing, cube(1 / lamc));
 
     Spack sgs_var_coef;
     // sgs_var_coef = subgrid_variance_scaling(inv_qc_relvar, 2);
     sgs_var_coef = 1;
 
-    qc2qi_hetero_freeze_tend.set(qc_not_small_and_t_freezing,
-                                 sgs_var_coef * CONS6 * cdist1 * tgamma(7 + mu_c) * expAimmDt * square(inv_lamc3));
+    qc2qi_hetero_freeze_tend.set(qc_not_small_and_t_freezing, sgs_var_coef * CONS6 * cdist1 *
+                                                                  tgamma(7 + mu_c) * expAimmDt *
+                                                                  square(inv_lamc3));
     nc2ni_immers_freeze_tend.set(qc_not_small_and_t_freezing,
                                  CONS5 * cdist1 * tgamma(sp(4.0) + mu_c) * expAimmDt * inv_lamc3);
   }
diff --git i/components/eamxx/src/physics/p3/impl/p3_cloud_rain_acc_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_cloud_rain_acc_impl.hpp
index 6a8277df3e..962fda72eb 100644
--- i/components/eamxx/src/physics/p3/impl/p3_cloud_rain_acc_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_cloud_rain_acc_impl.hpp
@@ -13,11 +13,10 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::cloud_rain_accretion(const Spack &rho, const Spack &inv_rho,
-                                                           const Spack &qc_incld, const Spack &nc_incld,
-                                                           const Spack &qr_incld, const Spack &inv_qc_relvar,
-                                                           Spack &qc2qr_accret_tend, Spack &nc_accret_tend,
-                                                           const P3Runtime &runtime_options, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::cloud_rain_accretion(
+    const Spack &rho, const Spack &inv_rho, const Spack &qc_incld, const Spack &nc_incld,
+    const Spack &qr_incld, const Spack &inv_qc_relvar, Spack &qc2qr_accret_tend,
+    Spack &nc_accret_tend, const P3Runtime &runtime_options, const Smask &context) {
   constexpr Scalar qsmall = C::QSMALL;
 
   const Scalar accretion_prefactor   = runtime_options.accretion_prefactor;
@@ -34,7 +33,8 @@ KOKKOS_FUNCTION void Functions<S, D>::cloud_rain_accretion(const Spack &rho, con
     // TODO: always default to second branch after BFB stuff is addressed
     if (accretion_qc_exponent == accretion_qr_exponent) {
       qc2qr_accret_tend.set(qr_and_qc_not_small,
-                            sgs_var_coef * accretion_prefactor * pow(qc_incld * qr_incld, accretion_qr_exponent));
+                            sgs_var_coef * accretion_prefactor *
+                                pow(qc_incld * qr_incld, accretion_qr_exponent));
     } else {
       qc2qr_accret_tend.set(qr_and_qc_not_small, sgs_var_coef * accretion_prefactor *
                                                      pow(qc_incld, accretion_qc_exponent) *
diff --git i/components/eamxx/src/physics/p3/impl/p3_cloud_sed_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_cloud_sed_impl.hpp
index 9b84cbc727..8abdc95de1 100644
--- i/components/eamxx/src/physics/p3/impl/p3_cloud_sed_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_cloud_sed_impl.hpp
@@ -13,19 +13,21 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::cloud_sedimentation(
-    const uview_1d<Spack> &qc_incld, const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
-    const uview_1d<const Spack> &cld_frac_l, const uview_1d<const Spack> &acn, const uview_1d<const Spack> &inv_dz,
-    const view_dnu_table &dnu, const MemberType &team, const Workspace &workspace, const Int &nk, const Int &ktop,
-    const Int &kbot, const Int &kdir, const Scalar &dt, const Scalar &inv_dt, const bool &do_predict_nc,
-    const uview_1d<Spack> &qc, const uview_1d<Spack> &nc, const uview_1d<Spack> &nc_incld, const uview_1d<Spack> &mu_c,
-    const uview_1d<Spack> &lamc, const uview_1d<Spack> &qc_tend, const uview_1d<Spack> &nc_tend,
-    Scalar &precip_liq_surf) {
+    const uview_1d<Spack> &qc_incld, const uview_1d<const Spack> &rho,
+    const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &cld_frac_l,
+    const uview_1d<const Spack> &acn, const uview_1d<const Spack> &inv_dz,
+    const view_dnu_table &dnu, const MemberType &team, const Workspace &workspace, const Int &nk,
+    const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt, const Scalar &inv_dt,
+    const bool &do_predict_nc, const uview_1d<Spack> &qc, const uview_1d<Spack> &nc,
+    const uview_1d<Spack> &nc_incld, const uview_1d<Spack> &mu_c, const uview_1d<Spack> &lamc,
+    const uview_1d<Spack> &qc_tend, const uview_1d<Spack> &nc_tend, Scalar &precip_liq_surf) {
   // Get temporary workspaces needed for the cloud-sed calculation
   uview_1d<Spack> V_qc, V_nc, flux_qx, flux_nx;
   workspace.template take_many_contiguous_unsafe<4>({"V_qc", "V_nc", "flux_qx", "flux_nx"},
                                                     {&V_qc, &V_nc, &flux_qx, &flux_nx});
 
-  const view_1d_ptr_array<Spack, 2> fluxes_ptr = {&flux_qx, &flux_nx}, vs_ptr = {&V_qc, &V_nc}, qnr_ptr = {&qc, &nc};
+  const view_1d_ptr_array<Spack, 2> fluxes_ptr = {&flux_qx, &flux_nx}, vs_ptr = {&V_qc, &V_nc},
+                                    qnr_ptr = {&qc, &nc};
 
   const view_1d_ptr_array<Spack, 1> flux_ptr = {&flux_qx}, v_ptr = {&V_qc}, qr_ptr = {&qc};
 
@@ -70,8 +72,8 @@ KOKKOS_FUNCTION void Functions<S, D>::cloud_sedimentation(
             if (qc_gt_small.any()) {
               // compute Vq, Vn
               Spack nu, cdist, cdist1, dum;
-              get_cloud_dsd2(qc_incld(pk), nc_incld(pk), mu_c(pk), rho(pk), nu, dnu, lamc(pk), cdist, cdist1,
-                             qc_gt_small);
+              get_cloud_dsd2(qc_incld(pk), nc_incld(pk), mu_c(pk), rho(pk), nu, dnu, lamc(pk),
+                             cdist, cdist1, qc_gt_small);
 
               // get_cloud_dsd2 keeps the drop-size distribution within reasonable
               // bounds by modifying nc_incld. The next line maintains consistency
@@ -79,9 +81,11 @@ KOKKOS_FUNCTION void Functions<S, D>::cloud_sedimentation(
               nc(pk).set(qc_gt_small, nc_incld(pk) * cld_frac_l(pk));
 
               dum = 1 / pow(lamc(pk), bcn);
-              V_qc(pk).set(qc_gt_small, acn(pk) * tgamma(4 + bcn + mu_c(pk)) * dum / tgamma(mu_c(pk) + 4));
+              V_qc(pk).set(qc_gt_small,
+                           acn(pk) * tgamma(4 + bcn + mu_c(pk)) * dum / tgamma(mu_c(pk) + 4));
               if (do_predict_nc) {
-                V_nc(pk).set(qc_gt_small, acn(pk) * tgamma(1 + bcn + mu_c(pk)) * dum / tgamma(mu_c(pk) + 1));
+                V_nc(pk).set(qc_gt_small,
+                             acn(pk) * tgamma(1 + bcn + mu_c(pk)) * dum / tgamma(mu_c(pk) + 1));
               }
             }
 
@@ -93,11 +97,11 @@ KOKKOS_FUNCTION void Functions<S, D>::cloud_sedimentation(
       team.team_barrier();
 
       if (do_predict_nc) {
-        generalized_sedimentation<2>(rho, inv_rho, inv_dz, team, nk, k_qxtop, k_qxbot, kbot, kdir, Co_max, dt_left,
-                                     prt_accum, fluxes_ptr, vs_ptr, qnr_ptr);
+        generalized_sedimentation<2>(rho, inv_rho, inv_dz, team, nk, k_qxtop, k_qxbot, kbot, kdir,
+                                     Co_max, dt_left, prt_accum, fluxes_ptr, vs_ptr, qnr_ptr);
       } else {
-        generalized_sedimentation<1>(rho, inv_rho, inv_dz, team, nk, k_qxtop, k_qxbot, kbot, kdir, Co_max, dt_left,
-                                     prt_accum, flux_ptr, v_ptr, qr_ptr);
+        generalized_sedimentation<1>(rho, inv_rho, inv_dz, team, nk, k_qxtop, k_qxbot, kbot, kdir,
+                                     Co_max, dt_left, prt_accum, flux_ptr, v_ptr, qr_ptr);
       }
 
       // Update _incld values with end-of-step cell-ave values
@@ -109,7 +113,8 @@ KOKKOS_FUNCTION void Functions<S, D>::cloud_sedimentation(
 
     } // end CFL substep loop
 
-    Kokkos::single(Kokkos::PerTeam(team), [&]() { precip_liq_surf = prt_accum * C::INV_RHO_H2O * inv_dt; });
+    Kokkos::single(Kokkos::PerTeam(team),
+                   [&]() { precip_liq_surf = prt_accum * C::INV_RHO_H2O * inv_dt; });
   }
 
   const Int nk_pack = ekat::npack<Spack>(nk);
diff --git i/components/eamxx/src/physics/p3/impl/p3_conservation_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_conservation_impl.hpp
index 7794e6aa15..902ddf799c 100644
--- i/components/eamxx/src/physics/p3/impl/p3_conservation_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_conservation_impl.hpp
@@ -9,31 +9,33 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::cloud_water_conservation(
-    const Spack &qc, const Scalar dt, Spack &qc2qr_autoconv_tend, Spack &qc2qr_accret_tend, Spack &qc2qi_collect_tend,
-    Spack &qc2qi_hetero_freeze_tend, Spack &qc2qr_ice_shed_tend, Spack &qc2qi_berg_tend, Spack &qi2qv_sublim_tend,
-    Spack &qv2qi_vapdep_tend, Spack &qcheti_cnt, Spack &qicnt, const bool &use_hetfrz_classnuc, const Smask &context,
-    const Spack &cld_frac_l, const Spack &cld_frac_i, const P3Runtime &runtime_options) {
+    const Spack &qc, const Scalar dt, Spack &qc2qr_autoconv_tend, Spack &qc2qr_accret_tend,
+    Spack &qc2qi_collect_tend, Spack &qc2qi_hetero_freeze_tend, Spack &qc2qr_ice_shed_tend,
+    Spack &qc2qi_berg_tend, Spack &qi2qv_sublim_tend, Spack &qv2qi_vapdep_tend, Spack &qcheti_cnt,
+    Spack &qicnt, const bool &use_hetfrz_classnuc, const Smask &context, const Spack &cld_frac_l,
+    const Spack &cld_frac_i, const P3Runtime &runtime_options) {
 
   Spack sinks;
   if (use_hetfrz_classnuc) {
-    sinks = (qc2qr_autoconv_tend + qc2qr_accret_tend + qc2qi_collect_tend + qcheti_cnt + qc2qr_ice_shed_tend +
-             qc2qi_berg_tend) *
+    sinks = (qc2qr_autoconv_tend + qc2qr_accret_tend + qc2qi_collect_tend + qcheti_cnt +
+             qc2qr_ice_shed_tend + qc2qi_berg_tend) *
             dt; // Sinks of cloud water
   } else {
-    sinks = (qc2qr_autoconv_tend + qc2qr_accret_tend + qc2qi_collect_tend + qc2qi_hetero_freeze_tend +
-             qc2qr_ice_shed_tend + qc2qi_berg_tend) *
+    sinks = (qc2qr_autoconv_tend + qc2qr_accret_tend + qc2qi_collect_tend +
+             qc2qi_hetero_freeze_tend + qc2qr_ice_shed_tend + qc2qi_berg_tend) *
             dt; // Sinks of cloud water
   }
   const auto sources = qc; // Source of cloud water
   // il_cldm is the intersection of ice and liquid cloud fractions
-  const auto il_cldm = (runtime_options.use_separate_ice_liq_frac) ? min(cld_frac_i, cld_frac_l) : Spack(1);
+  const auto il_cldm =
+      (runtime_options.use_separate_ice_liq_frac) ? min(cld_frac_i, cld_frac_l) : Spack(1);
   const auto cld_frac_glaciated =
       (runtime_options.use_separate_ice_liq_frac) ? max(cld_frac_i - il_cldm, 0.0001) : Spack(1);
   Spack ratio;
 
   constexpr Scalar qtendsmall = C::QTENDSMALL;
-  Smask enforce_conservation =
-      sinks > sources && sinks >= qtendsmall && context; // determine if  conservation corrction is necessary
+  Smask enforce_conservation  = sinks > sources && sinks >= qtendsmall &&
+                               context; // determine if  conservation corrction is necessary
   Smask nothing_todo = !enforce_conservation && context;
 
   if (enforce_conservation.any()) {
@@ -52,7 +54,8 @@ KOKKOS_FUNCTION void Functions<S, D>::cloud_water_conservation(
   }
 
   if (nothing_todo.any()) {
-    ratio.set(nothing_todo, 1); // If not limiting sinks on qc then most likely did not run out of qc
+    ratio.set(nothing_todo,
+              1); // If not limiting sinks on qc then most likely did not run out of qc
   }
 
   // PMC: ratio is also frac of step w/ liq. thus we apply qc2qi_berg_tend for
@@ -69,9 +72,11 @@ KOKKOS_FUNCTION void Functions<S, D>::cloud_water_conservation(
   if (enforce_conservation.any()) {
     if (runtime_options.use_separate_ice_liq_frac) {
       qv2qi_vapdep_tend.set(enforce_conservation,
-                            qv2qi_vapdep_tend + qv2qi_vapdep_tend * (1 - ratio) * (il_cldm / cld_frac_glaciated));
+                            qv2qi_vapdep_tend +
+                                qv2qi_vapdep_tend * (1 - ratio) * (il_cldm / cld_frac_glaciated));
       qi2qv_sublim_tend.set(enforce_conservation,
-                            qi2qv_sublim_tend + qi2qv_sublim_tend * (1 - ratio) * (il_cldm / cld_frac_glaciated));
+                            qi2qv_sublim_tend +
+                                qi2qv_sublim_tend * (1 - ratio) * (il_cldm / cld_frac_glaciated));
     } else {
       qv2qi_vapdep_tend.set(enforce_conservation, qv2qi_vapdep_tend * (1 - ratio));
       qi2qv_sublim_tend.set(enforce_conservation, qi2qv_sublim_tend * (1 - ratio));
@@ -80,20 +85,21 @@ KOKKOS_FUNCTION void Functions<S, D>::cloud_water_conservation(
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::rain_water_conservation(const Spack &qr, const Spack &qc2qr_autoconv_tend,
-                                                              const Spack &qc2qr_accret_tend,
-                                                              const Spack &qi2qr_melt_tend,
-                                                              const Spack &qc2qr_ice_shed_tend, const Scalar dt,
-                                                              Spack &qr2qv_evap_tend, Spack &qr2qi_collect_tend,
-                                                              Spack &qr2qi_immers_freeze_tend, const Smask &context) {
-  const auto sinks   = (qr2qv_evap_tend + qr2qi_collect_tend + qr2qi_immers_freeze_tend) * dt; // Sinks of rain water
-  const auto sources = qr + (qc2qr_autoconv_tend + qc2qr_accret_tend + qi2qr_melt_tend + qc2qr_ice_shed_tend) *
-                                dt; // Sources of rain water
+KOKKOS_FUNCTION void Functions<S, D>::rain_water_conservation(
+    const Spack &qr, const Spack &qc2qr_autoconv_tend, const Spack &qc2qr_accret_tend,
+    const Spack &qi2qr_melt_tend, const Spack &qc2qr_ice_shed_tend, const Scalar dt,
+    Spack &qr2qv_evap_tend, Spack &qr2qi_collect_tend, Spack &qr2qi_immers_freeze_tend,
+    const Smask &context) {
+  const auto sinks =
+      (qr2qv_evap_tend + qr2qi_collect_tend + qr2qi_immers_freeze_tend) * dt; // Sinks of rain water
+  const auto sources =
+      qr + (qc2qr_autoconv_tend + qc2qr_accret_tend + qi2qr_melt_tend + qc2qr_ice_shed_tend) *
+               dt; // Sources of rain water
   Spack ratio;
 
   constexpr Scalar qtendsmall = C::QTENDSMALL;
-  Smask enforce_conservation =
-      sinks > sources && sinks >= qtendsmall && context; // determine if  conservation corrction is necessary
+  Smask enforce_conservation  = sinks > sources && sinks >= qtendsmall &&
+                               context; // determine if  conservation corrction is necessary
 
   if (enforce_conservation.any()) {
     ratio.set(enforce_conservation, sources / sinks);
@@ -105,26 +111,29 @@ KOKKOS_FUNCTION void Functions<S, D>::rain_water_conservation(const Spack &qr, c
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::ice_water_conservation(
-    const Spack &qi, const Spack &qv2qi_vapdep_tend, const Spack &qv2qi_nucleat_tend, const Spack &qc2qi_berg_tend,
-    const Spack &qr2qi_collect_tend, const Spack &qc2qi_collect_tend, const Spack &qr2qi_immers_freeze_tend,
-    const Spack &qc2qi_hetero_freeze_tend, const Scalar dt, Spack &qinuc_cnt, Spack &qcheti_cnt, Spack &qicnt,
-    Spack &qi2qv_sublim_tend, Spack &qi2qr_melt_tend, const bool &use_hetfrz_classnuc, const Smask &context) {
+    const Spack &qi, const Spack &qv2qi_vapdep_tend, const Spack &qv2qi_nucleat_tend,
+    const Spack &qc2qi_berg_tend, const Spack &qr2qi_collect_tend, const Spack &qc2qi_collect_tend,
+    const Spack &qr2qi_immers_freeze_tend, const Spack &qc2qi_hetero_freeze_tend, const Scalar dt,
+    Spack &qinuc_cnt, Spack &qcheti_cnt, Spack &qicnt, Spack &qi2qv_sublim_tend,
+    Spack &qi2qr_melt_tend, const bool &use_hetfrz_classnuc, const Smask &context) {
   const auto sinks = (qi2qv_sublim_tend + qi2qr_melt_tend) * dt; // Sinks of ice water
 
   Spack sources;
   if (use_hetfrz_classnuc) {
-    sources = qi + (qv2qi_vapdep_tend + qv2qi_nucleat_tend + qr2qi_collect_tend + qc2qi_collect_tend +
-                    qr2qi_immers_freeze_tend + qc2qi_berg_tend + qinuc_cnt + qcheti_cnt + qicnt) *
-                       dt; // Sources of ice water
+    sources =
+        qi + (qv2qi_vapdep_tend + qv2qi_nucleat_tend + qr2qi_collect_tend + qc2qi_collect_tend +
+              qr2qi_immers_freeze_tend + qc2qi_berg_tend + qinuc_cnt + qcheti_cnt + qicnt) *
+                 dt; // Sources of ice water
   } else {
-    sources = qi + (qv2qi_vapdep_tend + qv2qi_nucleat_tend + qr2qi_collect_tend + qc2qi_collect_tend +
-                    qr2qi_immers_freeze_tend + qc2qi_hetero_freeze_tend + qc2qi_berg_tend) *
-                       dt; // Sources of ice water
+    sources =
+        qi + (qv2qi_vapdep_tend + qv2qi_nucleat_tend + qr2qi_collect_tend + qc2qi_collect_tend +
+              qr2qi_immers_freeze_tend + qc2qi_hetero_freeze_tend + qc2qi_berg_tend) *
+                 dt; // Sources of ice water
   }
   Spack ratio;
   constexpr Scalar qtendsmall = C::QTENDSMALL;
-  Smask enforce_conservation =
-      sinks > sources && sinks >= qtendsmall && context; // determine if  conservation corrction is necessary
+  Smask enforce_conservation  = sinks > sources && sinks >= qtendsmall &&
+                               context; // determine if  conservation corrction is necessary
   if (enforce_conservation.any()) {
     ratio.set(enforce_conservation, sources / sinks);
     qi2qv_sublim_tend.set(enforce_conservation, qi2qv_sublim_tend * ratio);
diff --git i/components/eamxx/src/physics/p3/impl/p3_droplet_self_coll_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_droplet_self_coll_impl.hpp
index 2066981592..58d7bdadbf 100644
--- i/components/eamxx/src/physics/p3/impl/p3_droplet_self_coll_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_droplet_self_coll_impl.hpp
@@ -12,9 +12,10 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::droplet_self_collection(const Spack &, const Spack &, const Spack &qc_incld,
-                                                              const Spack &, const Spack &, const Spack &,
-                                                              Spack &nc_selfcollect_tend, const Smask &context) {
+KOKKOS_FUNCTION void
+Functions<S, D>::droplet_self_collection(const Spack &, const Spack &, const Spack &qc_incld,
+                                         const Spack &, const Spack &, const Spack &,
+                                         Spack &nc_selfcollect_tend, const Smask &context) {
   constexpr Scalar qsmall = C::QSMALL;
 
   const auto qc_not_small = (qc_incld >= qsmall) && context;
diff --git i/components/eamxx/src/physics/p3/impl/p3_dsd2_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_dsd2_impl.hpp
index 2acbe585db..2a203dab8f 100644
--- i/components/eamxx/src/physics/p3/impl/p3_dsd2_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_dsd2_impl.hpp
@@ -12,9 +12,10 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::get_cloud_dsd2(const Spack &qc, Spack &nc, Spack &mu_c, const Spack &rho,
-                                                     Spack &nu, const view_dnu_table &dnu, Spack &lamc, Spack &cdist,
-                                                     Spack &cdist1, const Smask &context) {
+KOKKOS_FUNCTION void
+Functions<S, D>::get_cloud_dsd2(const Spack &qc, Spack &nc, Spack &mu_c, const Spack &rho,
+                                Spack &nu, const view_dnu_table &dnu, Spack &lamc, Spack &cdist,
+                                Spack &cdist1, const Smask &context) {
   lamc.set(context, 0);
   cdist.set(context, 0);
   cdist1.set(context, 0);
@@ -60,7 +61,8 @@ KOKKOS_FUNCTION void Functions<S, D>::get_cloud_dsd2(const Spack &qc, Spack &nc,
     lamc.set(lamc_lt_min, lammin);
     lamc.set(lamc_gt_max, lammax);
 
-    nc.set(min_or_max, 6 * (lamc * lamc * lamc) * qc / (C::Pi * C::RHO_H2O * (mu_c + 3) * (mu_c + 2) * (mu_c + 1)));
+    nc.set(min_or_max, 6 * (lamc * lamc * lamc) * qc /
+                           (C::Pi * C::RHO_H2O * (mu_c + 3) * (mu_c + 2) * (mu_c + 1)));
 
     cdist.set(qc_gt_small, nc * (mu_c + 1) / lamc);
     cdist1.set(qc_gt_small, nc / tgamma(mu_c + 1));
@@ -68,8 +70,9 @@ KOKKOS_FUNCTION void Functions<S, D>::get_cloud_dsd2(const Spack &qc, Spack &nc,
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::get_rain_dsd2(const Spack &qr, Spack &nr, Spack &mu_r, Spack &lamr,
-                                                    const P3Runtime &runtime_options, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::get_rain_dsd2(const Spack &qr, Spack &nr, Spack &mu_r,
+                                                    Spack &lamr, const P3Runtime &runtime_options,
+                                                    const Smask &context) {
   constexpr auto nsmall = C::NSMALL;
   constexpr auto qsmall = C::QSMALL;
   constexpr auto cons1  = C::CONS1;
@@ -108,14 +111,17 @@ KOKKOS_FUNCTION void Functions<S, D>::get_rain_dsd2(const Spack &qr, Spack &nr,
     if (either.any()) {
       lamr.set(lt, lammin);
       lamr.set(gt, lammax);
-      ekat_masked_loop(either, s) { nr[s] = lamr[s] * lamr[s] * lamr[s] * qr[s] / mass_to_d3_factor[s]; }
+      ekat_masked_loop(either, s) {
+        nr[s] = lamr[s] * lamr[s] * lamr[s] * qr[s] / mass_to_d3_factor[s];
+      }
     }
   }
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::get_cdistr_logn0r(const Spack &qr, const Spack &nr, const Spack &mu_r,
-                                                        const Spack &lamr, Spack &cdistr, Spack &logn0r,
+KOKKOS_FUNCTION void Functions<S, D>::get_cdistr_logn0r(const Spack &qr, const Spack &nr,
+                                                        const Spack &mu_r, const Spack &lamr,
+                                                        Spack &cdistr, Spack &logn0r,
                                                         const Smask &context) {
   constexpr auto qsmall = C::QSMALL;
 
diff --git i/components/eamxx/src/physics/p3/impl/p3_evaporate_rain_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_evaporate_rain_impl.hpp
index da6264e07f..7c8fa891a9 100644
--- i/components/eamxx/src/physics/p3/impl/p3_evaporate_rain_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_evaporate_rain_impl.hpp
@@ -8,8 +8,8 @@ namespace scream {
 namespace p3 {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::rain_evap_tscale_weight(const Spack &dt_over_tau, Spack &weight,
-                                                              const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::rain_evap_tscale_weight(const Spack &dt_over_tau,
+                                                              Spack &weight, const Smask &context) {
   /*
     Returns weighting between 0 and 1 for how much of the instantaneous
     evaporation rate and how much of the equilibrium evaporation rate to
@@ -22,8 +22,9 @@ KOKKOS_FUNCTION void Functions<S, D>::rain_evap_tscale_weight(const Spack &dt_ov
 } // end tscale_weight
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::rain_evap_equilib_tend(const Spack &A_c, const Spack &ab, const Spack &tau_eff,
-                                                             const Spack &tau_r, Spack &tend, const Smask &context) {
+KOKKOS_FUNCTION void
+Functions<S, D>::rain_evap_equilib_tend(const Spack &A_c, const Spack &ab, const Spack &tau_eff,
+                                        const Spack &tau_r, Spack &tend, const Smask &context) {
   /*
     In equilibrium, the total evaporation must balance the tendency A_c from
     all other processes. The rain evaporation is the fraction (1/tau_r)/(1/tau_eff)
@@ -39,8 +40,9 @@ KOKKOS_FUNCTION void Functions<S, D>::rain_evap_equilib_tend(const Spack &A_c, c
 } // end equilib_tend
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::rain_evap_instant_tend(const Spack &ssat_r, const Spack &ab, const Spack &tau_r,
-                                                             Spack &tend, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::rain_evap_instant_tend(const Spack &ssat_r, const Spack &ab,
+                                                             const Spack &tau_r, Spack &tend,
+                                                             const Smask &context) {
   /*
     The instantaneous rain evap tendency is just the absolute supersaturation
     ssat_r divided by the supersaturation removal timescale for rain tau_r
@@ -53,13 +55,13 @@ KOKKOS_FUNCTION void Functions<S, D>::rain_evap_instant_tend(const Spack &ssat_r
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::evaporate_rain(const Spack &qr_incld, const Spack &qc_incld, const Spack &nr_incld,
-                                const Spack &qi_incld, const Spack &cld_frac_l, const Spack &cld_frac_r,
-                                const Spack &qv, const Spack &qv_prev, const Spack &qv_sat_l, const Spack &qv_sat_i,
-                                const Spack &ab, const Spack &abi, const Spack &epsr, const Spack &epsi_tot,
-                                const Spack &t_atm, const Spack &t_atm_prev, const Spack &dqsdt, const Scalar &dt,
-                                Spack &qr2qv_evap_tend, Spack &nr_evap_tend, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::evaporate_rain(
+    const Spack &qr_incld, const Spack &qc_incld, const Spack &nr_incld, const Spack &qi_incld,
+    const Spack &cld_frac_l, const Spack &cld_frac_r, const Spack &qv, const Spack &qv_prev,
+    const Spack &qv_sat_l, const Spack &qv_sat_i, const Spack &ab, const Spack &abi,
+    const Spack &epsr, const Spack &epsi_tot, const Spack &t_atm, const Spack &t_atm_prev,
+    const Spack &dqsdt, const Scalar &dt, Spack &qr2qv_evap_tend, Spack &nr_evap_tend,
+    const Smask &context) {
   /* Evaporation is basically (qv - sv_sat)/(tau_eff*ab) where tau_eff
      is the total effective supersaturation removal timescale
      and ab is the psychrometric correction for condensational heating
@@ -124,7 +126,8 @@ Functions<S, D>::evaporate_rain(const Spack &qr_incld, const Spack &qc_incld, co
     if (is_freezing.any()) {
       eps_eff.set(is_freezing, epsr + epsi_tot * (1 + (latvap + latice) * inv_cp * dqsdt) / abi);
       A_c.set(is_freezing, (qv - qv_prev) * inv_dt - dqsdt * (t_atm - t_atm_prev) * inv_dt -
-                               (qv_sat_l - qv_sat_i) * (1 + (latvap + latice) * inv_cp * dqsdt) / abi * epsi_tot);
+                               (qv_sat_l - qv_sat_i) * (1 + (latvap + latice) * inv_cp * dqsdt) /
+                                   abi * epsi_tot);
     }
     if (not_freezing.any()) {
       eps_eff.set(not_freezing, epsr);
@@ -152,7 +155,8 @@ Functions<S, D>::evaporate_rain(const Spack &qr_incld, const Spack &qc_incld, co
       rain_evap_equilib_tend(A_c, ab, tau_eff, tau_r, equilib_tend, is_rain_evap);
       rain_evap_instant_tend(ssat_r, ab, tau_r, instant_tend, is_rain_evap);
 
-      qr2qv_evap_tend.set(not_qr_tiny, instant_tend * tscale_weight + equilib_tend * (1 - tscale_weight));
+      qr2qv_evap_tend.set(not_qr_tiny,
+                          instant_tend * tscale_weight + equilib_tend * (1 - tscale_weight));
     }
 
     // Limit evap from exceeding saturation deficit. Analytic integration
diff --git i/components/eamxx/src/physics/p3/impl/p3_find_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_find_impl.hpp
index d8a5dfedc8..3d471b9be4 100644
--- i/components/eamxx/src/physics/p3/impl/p3_find_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_find_impl.hpp
@@ -12,8 +12,10 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION Int Functions<S, D>::find_bottom(const MemberType &team, const uview_1d<const Scalar> &v,
-                                                 const Scalar &small, const Int &kbot, const Int &ktop, const Int &kdir,
+KOKKOS_FUNCTION Int Functions<S, D>::find_bottom(const MemberType &team,
+                                                 const uview_1d<const Scalar> &v,
+                                                 const Scalar &small, const Int &kbot,
+                                                 const Int &ktop, const Int &kdir,
                                                  bool &log_present) {
   log_present = false;
   Int k_xbot  = 0;
@@ -52,8 +54,9 @@ KOKKOS_FUNCTION Int Functions<S, D>::find_bottom(const MemberType &team, const u
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION Int Functions<S, D>::find_top(const MemberType &team, const uview_1d<const Scalar> &v,
-                                              const Scalar &small, const Int &kbot, const Int &ktop, const Int &kdir,
+KOKKOS_FUNCTION Int Functions<S, D>::find_top(const MemberType &team,
+                                              const uview_1d<const Scalar> &v, const Scalar &small,
+                                              const Int &kbot, const Int &ktop, const Int &kdir,
                                               bool &log_present) {
   log_present = false;
   Int k_xtop  = 0;
diff --git i/components/eamxx/src/physics/p3/impl/p3_get_time_space_phys_variables_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_get_time_space_phys_variables_impl.hpp
index efc26c5f48..6c0817874d 100644
--- i/components/eamxx/src/physics/p3/impl/p3_get_time_space_phys_variables_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_get_time_space_phys_variables_impl.hpp
@@ -8,11 +8,10 @@ namespace scream {
 namespace p3 {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::get_time_space_phys_variables(const Spack &T_atm, const Spack &pres, const Spack &rho,
-                                               const Spack &qv_sat_l, const Spack &qv_sat_i, Spack &mu, Spack &dv,
-                                               Spack &sc, Spack &dqsdt, Spack &dqsidt, Spack &ab, Spack &abi,
-                                               Spack &kap, Spack &eii, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::get_time_space_phys_variables(
+    const Spack &T_atm, const Spack &pres, const Spack &rho, const Spack &qv_sat_l,
+    const Spack &qv_sat_i, Spack &mu, Spack &dv, Spack &sc, Spack &dqsdt, Spack &dqsidt, Spack &ab,
+    Spack &abi, Spack &kap, Spack &eii, const Smask &context) {
   // time/space varying physical variables
   mu.set(context, sp(1.496e-6) * pow(T_atm, sp(1.5)) / (T_atm + 120));
   dv.set(context, sp(8.794e-5) * pow(T_atm, sp(1.81)) / pres);
@@ -24,7 +23,8 @@ Functions<S, D>::get_time_space_phys_variables(const Spack &T_atm, const Spack &
   constexpr Scalar latice = C::LatIce;
   constexpr Scalar tval1  = 253.15;
   constexpr Scalar tval2  = 273.15;
-  constexpr Scalar dtval  = 20; // this is tval2-tval1, but specifying here as int to be BFB with F90.
+  constexpr Scalar dtval =
+      20; // this is tval2-tval1, but specifying here as int to be BFB with F90.
 
   const auto dum = 1 / (RV * square(T_atm));
   dqsdt.set(context, latvap * qv_sat_l * dum);
@@ -38,7 +38,8 @@ Functions<S, D>::get_time_space_phys_variables(const Spack &T_atm, const Spack &
   const auto t_lt_tval2 = T_atm < tval2;
 
   eii.set(t_lt_tval1 && context, sp(0.001));
-  eii.set(!t_lt_tval1 && t_lt_tval2 && context, sp(0.001) + (T_atm - sp(tval1)) * (sp(0.3) - sp(0.001)) / dtval);
+  eii.set(!t_lt_tval1 && t_lt_tval2 && context,
+          sp(0.001) + (T_atm - sp(tval1)) * (sp(0.3) - sp(0.001)) / dtval);
   eii.set(!t_lt_tval1 && !t_lt_tval2 && context, sp(0.3));
 }
 
diff --git i/components/eamxx/src/physics/p3/impl/p3_ice_classical_nucleation_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_ice_classical_nucleation_impl.hpp
index 6151fa625c..114158c134 100644
--- i/components/eamxx/src/physics/p3/impl/p3_ice_classical_nucleation_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_ice_classical_nucleation_impl.hpp
@@ -10,11 +10,10 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::ice_classical_nucleation(const Spack &frzimm, const Spack &frzcnt, const Spack &frzdep,
-                                          const Spack &rho, const Spack &qc_incld, const Spack &nc_incld,
-                                          const int Iflag, Spack &ncheti_cnt, Spack &qcheti_cnt, Spack &nicnt,
-                                          Spack &qicnt, Spack &ninuc_cnt, Spack &qinuc_cnt) {
+KOKKOS_FUNCTION void Functions<S, D>::ice_classical_nucleation(
+    const Spack &frzimm, const Spack &frzcnt, const Spack &frzdep, const Spack &rho,
+    const Spack &qc_incld, const Spack &nc_incld, const int Iflag, Spack &ncheti_cnt,
+    Spack &qcheti_cnt, Spack &nicnt, Spack &qicnt, Spack &ninuc_cnt, Spack &qinuc_cnt) {
   constexpr Scalar pi      = C::Pi;
   constexpr Scalar rho_h2o = C::RHO_H2O;
 
@@ -46,7 +45,8 @@ Functions<S, D>::ice_classical_nucleation(const Spack &frzimm, const Spack &frzc
     qinuc_cnt.set(mask, ninuc_cnt * mi0, Zero);
     break;
   default:
-    EKAT_KERNEL_ERROR_MSG("Error! Unhandled case in switch statement for Iflag in p3_CNT_couple_impl.hpp .\n");
+    EKAT_KERNEL_ERROR_MSG(
+        "Error! Unhandled case in switch statement for Iflag in p3_CNT_couple_impl.hpp .\n");
     break;
   }
 }
diff --git i/components/eamxx/src/physics/p3/impl/p3_ice_cldliq_wet_growth_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_ice_cldliq_wet_growth_impl.hpp
index 247cab5a0f..917016a23a 100644
--- i/components/eamxx/src/physics/p3/impl/p3_ice_cldliq_wet_growth_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_ice_cldliq_wet_growth_impl.hpp
@@ -10,10 +10,11 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::ice_cldliq_wet_growth(
-    const Spack &rho, const Spack &temp, const Spack &pres, const Spack &rhofaci, const Spack &table_val_qi2qr_melting,
-    const Spack &table_val_qi2qr_vent_melt, const Spack &dv, const Spack &kap, const Spack &mu, const Spack &sc,
-    const Spack &qv, const Spack &qc_incld, const Spack &qi_incld, const Spack &ni_incld, const Spack &qr_incld,
-    Smask &log_wetgrowth, Spack &qr2qi_collect_tend, Spack &qc2qi_collect_tend, Spack &qc_growth_rate,
+    const Spack &rho, const Spack &temp, const Spack &pres, const Spack &rhofaci,
+    const Spack &table_val_qi2qr_melting, const Spack &table_val_qi2qr_vent_melt, const Spack &dv,
+    const Spack &kap, const Spack &mu, const Spack &sc, const Spack &qv, const Spack &qc_incld,
+    const Spack &qi_incld, const Spack &ni_incld, const Spack &qr_incld, Smask &log_wetgrowth,
+    Spack &qr2qi_collect_tend, Spack &qc2qi_collect_tend, Spack &qc_growth_rate,
     Spack &nr_ice_shed_tend, Spack &qc2qr_ice_shed_tend, const Smask &context) {
   using physics = scream::physics::Functions<Scalar, Device>;
 
@@ -26,10 +27,11 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_cldliq_wet_growth(
   constexpr Scalar latvap = C::LatVap;
   constexpr Scalar latice = C::LatIce;
 
-  const auto t_is_negative                                  = temp < tmelt;
-  const auto qi_incld_ge_small                              = qi_incld >= qsmall;
-  const auto qc_qr_incld_ge_small                           = (qc_incld + qr_incld) >= sp(1.0e-6);
-  const auto qc2qi_collect_tend_qr2qi_collect_tend_ge_small = (qc2qi_collect_tend + qr2qi_collect_tend) >= sp(1.0e-10);
+  const auto t_is_negative        = temp < tmelt;
+  const auto qi_incld_ge_small    = qi_incld >= qsmall;
+  const auto qc_qr_incld_ge_small = (qc_incld + qr_incld) >= sp(1.0e-6);
+  const auto qc2qi_collect_tend_qr2qi_collect_tend_ge_small =
+      (qc2qi_collect_tend + qr2qi_collect_tend) >= sp(1.0e-10);
 
   const auto any_if     = qi_incld_ge_small && qc_qr_incld_ge_small && t_is_negative && context;
   const auto any_if_col = any_if && qc2qi_collect_tend_qr2qi_collect_tend_ge_small && context;
@@ -41,12 +43,14 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_cldliq_wet_growth(
   Spack dum1{0.};
 
   if (any_if.any()) {
-    qsat0 = physics::qv_sat_dry(zerodeg, pres, false, context, physics::MurphyKoop, "p3::ice_cldliq_wet_growth");
+    qsat0 = physics::qv_sat_dry(zerodeg, pres, false, context, physics::MurphyKoop,
+                                "p3::ice_cldliq_wet_growth");
 
-    qc_growth_rate.set(
-        any_if, ((table_val_qi2qr_melting + table_val_qi2qr_vent_melt * cbrt(sc) * sqrt(rhofaci * rho / mu)) * twopi *
-                 (rho * latvap * dv * (qsat0 - qv) - (temp - tmelt) * kap) / (latice + cpw * (temp - tmelt))) *
-                    ni_incld);
+    qc_growth_rate.set(any_if, ((table_val_qi2qr_melting +
+                                 table_val_qi2qr_vent_melt * cbrt(sc) * sqrt(rhofaci * rho / mu)) *
+                                twopi * (rho * latvap * dv * (qsat0 - qv) - (temp - tmelt) * kap) /
+                                (latice + cpw * (temp - tmelt))) *
+                                   ni_incld);
 
     qc_growth_rate.set(any_if, max(qc_growth_rate, zero));
 
@@ -59,11 +63,14 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_cldliq_wet_growth(
 
       dum1 = one / (qc2qi_collect_tend + qr2qi_collect_tend);
 
-      qc2qr_ice_shed_tend.set(any_if_col && dum_ge_small, qc2qr_ice_shed_tend + dum * qc2qi_collect_tend * dum1);
+      qc2qr_ice_shed_tend.set(any_if_col && dum_ge_small,
+                              qc2qr_ice_shed_tend + dum * qc2qi_collect_tend * dum1);
 
-      qc2qi_collect_tend.set(any_if_col && dum_ge_small, max(0, qc2qi_collect_tend - dum * qc2qi_collect_tend * dum1));
+      qc2qi_collect_tend.set(any_if_col && dum_ge_small,
+                             max(0, qc2qi_collect_tend - dum * qc2qi_collect_tend * dum1));
 
-      qr2qi_collect_tend.set(any_if_col && dum_ge_small, max(0, qr2qi_collect_tend - dum * qr2qi_collect_tend * dum1));
+      qr2qi_collect_tend.set(any_if_col && dum_ge_small,
+                             max(0, qr2qi_collect_tend - dum * qr2qi_collect_tend * dum1));
     }
 
     log_wetgrowth = any_if && dum_ge_small;
diff --git i/components/eamxx/src/physics/p3/impl/p3_ice_collection_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_ice_collection_impl.hpp
index 3a3b5a8041..9a6e879204 100644
--- i/components/eamxx/src/physics/p3/impl/p3_ice_collection_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_ice_collection_impl.hpp
@@ -7,12 +7,11 @@ namespace scream {
 namespace p3 {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::ice_cldliq_collection(const Spack &rho, const Spack &temp, const Spack &rhofaci,
-                                       const Spack &table_val_qc2qi_collect, const Spack &qi_incld,
-                                       const Spack &qc_incld, const Spack &ni_incld, const Spack &nc_incld,
-                                       Spack &qc2qi_collect_tend, Spack &nc_collect_tend, Spack &qc2qr_ice_shed_tend,
-                                       Spack &ncshdc, const P3Runtime &runtime_options, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::ice_cldliq_collection(
+    const Spack &rho, const Spack &temp, const Spack &rhofaci, const Spack &table_val_qc2qi_collect,
+    const Spack &qi_incld, const Spack &qc_incld, const Spack &ni_incld, const Spack &nc_incld,
+    Spack &qc2qi_collect_tend, Spack &nc_collect_tend, Spack &qc2qr_ice_shed_tend, Spack &ncshdc,
+    const P3Runtime &runtime_options, const Smask &context) {
   constexpr Scalar qsmall = C::QSMALL;
   constexpr Scalar tmelt  = C::Tmelt;
 
@@ -26,28 +25,29 @@ Functions<S, D>::ice_cldliq_collection(const Spack &rho, const Spack &temp, cons
   const Scalar cldliq_to_ice_collection_factor = runtime_options.cldliq_to_ice_collection_factor;
   constexpr auto inv_dropmass                  = C::ONE / C::dropmass;
 
-  qc2qi_collect_tend.set(both_ge_small && t_is_negative, rhofaci * table_val_qc2qi_collect * qc_incld *
-                                                             cldliq_to_ice_collection_factor * rho * ni_incld);
-  nc_collect_tend.set(both_ge_small,
-                      rhofaci * table_val_qc2qi_collect * nc_incld * cldliq_to_ice_collection_factor * rho * ni_incld);
+  qc2qi_collect_tend.set(both_ge_small && t_is_negative,
+                         rhofaci * table_val_qc2qi_collect * qc_incld *
+                             cldliq_to_ice_collection_factor * rho * ni_incld);
+  nc_collect_tend.set(both_ge_small, rhofaci * table_val_qc2qi_collect * nc_incld *
+                                         cldliq_to_ice_collection_factor * rho * ni_incld);
 
   // for T_atm > 273.15, assume cloud water is collected and shed as rain drops
   // sink for cloud water mass and number, note qcshed is source for rain mass
   qc2qr_ice_shed_tend.set(both_ge_small_pos_t, rhofaci * table_val_qc2qi_collect * qc_incld *
-                                                   cldliq_to_ice_collection_factor * rho * ni_incld);
-  nc_collect_tend.set(both_ge_small_pos_t,
-                      rhofaci * table_val_qc2qi_collect * nc_incld * cldliq_to_ice_collection_factor * rho * ni_incld);
+                                                   cldliq_to_ice_collection_factor * rho *
+                                                   ni_incld);
+  nc_collect_tend.set(both_ge_small_pos_t, rhofaci * table_val_qc2qi_collect * nc_incld *
+                                               cldliq_to_ice_collection_factor * rho * ni_incld);
   // source for rain number, assume 1 mm drops are shed
   ncshdc.set(both_ge_small_pos_t, qc2qr_ice_shed_tend * inv_dropmass);
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::ice_rain_collection(const Spack &rho, const Spack &temp, const Spack &rhofaci,
-                                                          const Spack &logn0r, const Spack &table_val_nr_collect,
-                                                          const Spack &table_val_qr2qi_collect, const Spack &qi_incld,
-                                                          const Spack &ni_incld, const Spack &qr_incld,
-                                                          Spack &qr2qi_collect_tend, Spack &nr_collect_tend,
-                                                          const P3Runtime &runtime_options, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::ice_rain_collection(
+    const Spack &rho, const Spack &temp, const Spack &rhofaci, const Spack &logn0r,
+    const Spack &table_val_nr_collect, const Spack &table_val_qr2qi_collect, const Spack &qi_incld,
+    const Spack &ni_incld, const Spack &qr_incld, Spack &qr2qi_collect_tend, Spack &nr_collect_tend,
+    const P3Runtime &runtime_options, const Smask &context) {
   constexpr Scalar qsmall = C::QSMALL;
   constexpr Scalar tmelt  = C::Tmelt;
 
@@ -62,8 +62,9 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_rain_collection(const Spack &rho, cons
   const Scalar rain_to_ice_collection_factor = runtime_options.rain_to_ice_collection_factor;
 
   // note: table_val_qr2qi_collect and logn0r are already calculated as log_10
-  qr2qi_collect_tend.set(both_ge_small_neg_t, pow(ten, table_val_qr2qi_collect + logn0r) * rho * rhofaci *
-                                                  rain_to_ice_collection_factor * ni_incld);
+  qr2qi_collect_tend.set(both_ge_small_neg_t, pow(ten, table_val_qr2qi_collect + logn0r) * rho *
+                                                  rhofaci * rain_to_ice_collection_factor *
+                                                  ni_incld);
   nr_collect_tend.set(both_ge_small_neg_t, pow(ten, table_val_nr_collect + logn0r) * rho * rhofaci *
                                                rain_to_ice_collection_factor * ni_incld);
 
@@ -73,18 +74,19 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_rain_collection(const Spack &rho, cons
   // note that melting of ice number is scaled to the loss
   // rate of ice mass due to melting
   // collection of rain above freezing does not impact total rain mass
-  nr_collect_tend.set(both_ge_small && !t_is_negative, pow(ten, table_val_nr_collect + logn0r) * rho * rhofaci *
-                                                           rain_to_ice_collection_factor * ni_incld);
+  nr_collect_tend.set(both_ge_small && !t_is_negative,
+                      pow(ten, table_val_nr_collect + logn0r) * rho * rhofaci *
+                          rain_to_ice_collection_factor * ni_incld);
   // for now neglect shedding of ice collecting rain above freezing, since snow is
   // not expected to shed in these conditions (though more hevaily rimed ice would be
   // expected to lead to shedding)
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::ice_self_collection(const Spack &rho, const Spack &rhofaci, const Spack &table_val_ni_self_collect,
-                                     const Spack &eii, const Spack &qm_incld, const Spack &qi_incld,
-                                     const Spack &ni_incld, Spack &ni_selfcollect_tend, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::ice_self_collection(
+    const Spack &rho, const Spack &rhofaci, const Spack &table_val_ni_self_collect,
+    const Spack &eii, const Spack &qm_incld, const Spack &qi_incld, const Spack &ni_incld,
+    Spack &ni_selfcollect_tend, const Smask &context) {
   constexpr Scalar qsmall = C::QSMALL;
   constexpr Scalar zero   = C::ZERO;
 
@@ -101,8 +103,8 @@ Functions<S, D>::ice_self_collection(const Spack &rho, const Spack &rhofaci, con
 
   if (qi_incld_ge_small.any()) {
     // Determine additional collection efficiency factor to be applied to ice-ice collection.
-    // The computed values of qicol and nicol are multipiled by Eii_fact to gradually shut off collection
-    // if ice is highly rimed.
+    // The computed values of qicol and nicol are multipiled by Eii_fact to gradually shut off
+    // collection if ice is highly rimed.
     tmp1.set(qi_incld_ge_small && qm_incld_positive,
              qm_incld / qi_incld); // rime mass fraction
     tmp1_lt_six  = tmp1 < sp(0.6);
@@ -118,8 +120,8 @@ Functions<S, D>::ice_self_collection(const Spack &rho, const Spack &rhofaci, con
 
     Eii_fact.set(!qm_incld_positive && context, 1);
 
-    ni_selfcollect_tend.set(qi_incld_ge_small,
-                            table_val_ni_self_collect * rho * eii * Eii_fact * rhofaci * ni_incld * ni_incld);
+    ni_selfcollect_tend.set(qi_incld_ge_small, table_val_ni_self_collect * rho * eii * Eii_fact *
+                                                   rhofaci * ni_incld * ni_incld);
   }
 }
 
diff --git i/components/eamxx/src/physics/p3/impl/p3_ice_deposition_sublimation_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_ice_deposition_sublimation_impl.hpp
index 218d7dced4..70f2929dd9 100644
--- i/components/eamxx/src/physics/p3/impl/p3_ice_deposition_sublimation_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_ice_deposition_sublimation_impl.hpp
@@ -9,9 +9,10 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::ice_deposition_sublimation(
-    const Spack &qi_incld, const Spack &ni_incld, const Spack &T_atm, const Spack &qv_sat_l, const Spack &qv_sat_i,
-    const Spack &epsi, const Spack &abi, const Spack &qv, const Scalar &inv_dt, Spack &qv2qi_vapdep_tend,
-    Spack &qi2qv_sublim_tend, Spack &ni_sublim_tend, Spack &qc2qi_berg_tend, const Smask &context) {
+    const Spack &qi_incld, const Spack &ni_incld, const Spack &T_atm, const Spack &qv_sat_l,
+    const Spack &qv_sat_i, const Spack &epsi, const Spack &abi, const Spack &qv,
+    const Scalar &inv_dt, Spack &qv2qi_vapdep_tend, Spack &qi2qv_sublim_tend, Spack &ni_sublim_tend,
+    Spack &qc2qi_berg_tend, const Smask &context) {
   constexpr Scalar QSMALL     = C::QSMALL;
   constexpr Scalar T_zerodegc = C::T_zerodegc;
 
@@ -37,7 +38,8 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_deposition_sublimation(
     // SUBLIMATE WHERE qi_tend<0. MAKE POSITIVE TO MATCH CONVENTION
     const auto neg_qi_tend = (qi_tend < 0);
     qi2qv_sublim_tend.set(qi_incld_not_small && neg_qi_tend, -qi_tend);
-    ni_sublim_tend.set(qi_incld_not_small && neg_qi_tend, qi2qv_sublim_tend * (ni_incld / qi_incld));
+    ni_sublim_tend.set(qi_incld_not_small && neg_qi_tend,
+                       qi2qv_sublim_tend * (ni_incld / qi_incld));
 
     // DEPOSITION (FROM VAPOR OR LIQ) ONLY OCCURS BELOW FREEZING:
     const auto T_lt_frz = (T_atm < T_zerodegc);
@@ -45,9 +47,9 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_deposition_sublimation(
     // BERGERON OCCURS WHERE LIQUID IS PRESENT AND DEPOSITION FROM VAPOR OCCURS WHERE IT ISN'T.
     // IF ALL LIQUID IS CONSUMED PARTWAY THROUGH A STEP, BERGERON SHOULD BE ACTIVE FOR THE
     // FRACTION OF THE STEP WHEN LIQUID IS PRESENT AND DEPOSITION FROM VAPOR SHOULD BE ACTIVE FOR
-    // THE REST OF THE STEP. THE FRACTION OF THE STEP WITH LIQUID ISN'T KNOWN UNTIL THE 'CONSERVATION
-    // CHECKS' AT THE END OF THE STEP, SO WE COMPUTE BERGERON AND VAPOR DEPOSITION HERE ASSUMING
-    // LIQUID IS OR ISN'T PRESENT FOR THE WHOLE STEP (RESPECTIVELY).
+    // THE REST OF THE STEP. THE FRACTION OF THE STEP WITH LIQUID ISN'T KNOWN UNTIL THE
+    // 'CONSERVATION CHECKS' AT THE END OF THE STEP, SO WE COMPUTE BERGERON AND VAPOR DEPOSITION
+    // HERE ASSUMING LIQUID IS OR ISN'T PRESENT FOR THE WHOLE STEP (RESPECTIVELY).
 
     // VAPOR DEPOSITION
     qv2qi_vapdep_tend.set(qi_incld_not_small && T_lt_frz && !neg_qi_tend, qi_tend);
diff --git i/components/eamxx/src/physics/p3/impl/p3_ice_melting_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_ice_melting_impl.hpp
index 6b21d4b1f8..52f0836780 100644
--- i/components/eamxx/src/physics/p3/impl/p3_ice_melting_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_ice_melting_impl.hpp
@@ -9,12 +9,11 @@ namespace scream {
 namespace p3 {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::ice_melting(const Spack &rho, const Spack &T_atm, const Spack &pres,
-                                                  const Spack &rhofaci, const Spack &table_val_qi2qr_melting,
-                                                  const Spack &table_val_qi2qr_vent_melt, const Spack &dv,
-                                                  const Spack &sc, const Spack &mu, const Spack &kap, const Spack &qv,
-                                                  const Spack &qi_incld, const Spack &ni_incld, Spack &qi2qr_melt_tend,
-                                                  Spack &ni2nr_melt_tend, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::ice_melting(
+    const Spack &rho, const Spack &T_atm, const Spack &pres, const Spack &rhofaci,
+    const Spack &table_val_qi2qr_melting, const Spack &table_val_qi2qr_vent_melt, const Spack &dv,
+    const Spack &sc, const Spack &mu, const Spack &kap, const Spack &qv, const Spack &qi_incld,
+    const Spack &ni_incld, Spack &qi2qr_melt_tend, Spack &ni2nr_melt_tend, const Smask &context) {
   // Notes Left over from WRF Version:
   // need to add back accelerated melting due to collection of ice mass by rain (pracsw1)
   // note 'f1pr' values are normalized, so we need to multiply by N
@@ -34,18 +33,22 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_melting(const Spack &rho, const Spack
 
   if (has_melt_qi.any()) {
     //    Note that qsat0 should be with respect to liquid. Confirmed F90 code did this.
-    const auto qsat0 = physics::qv_sat_dry(Spack(Tmelt), pres, false, context, physics::MurphyKoop,
-                                           "p3::ice_melting"); //"false" here means NOT saturation w/ respect to ice.
+    const auto qsat0 = physics::qv_sat_dry(
+        Spack(Tmelt), pres, false, context, physics::MurphyKoop,
+        "p3::ice_melting"); //"false" here means NOT saturation w/ respect to ice.
 
     qi2qr_melt_tend.set(has_melt_qi,
-                        ((table_val_qi2qr_melting + table_val_qi2qr_vent_melt * cbrt(sc) * sqrt(rhofaci * rho / mu)) *
-                         ((T_atm - Tmelt) * kap - rho * latvap * dv * (qsat0 - qv)) * 2 * Pi / latice) *
+                        ((table_val_qi2qr_melting +
+                          table_val_qi2qr_vent_melt * cbrt(sc) * sqrt(rhofaci * rho / mu)) *
+                         ((T_atm - Tmelt) * kap - rho * latvap * dv * (qsat0 - qv)) * 2 * Pi /
+                         latice) *
                             ni_incld);
 
     // make sure qi2qr_melt_tend is always negative
     qi2qr_melt_tend = max(qi2qr_melt_tend, 0);
 
-    // Reduce nj in proportion to decrease in qi mass. Prev line makes sure it always has the right sign.
+    // Reduce nj in proportion to decrease in qi mass. Prev line makes sure it always has the right
+    // sign.
     ni2nr_melt_tend.set(has_melt_qi, qi2qr_melt_tend * (ni_incld / qi_incld));
   }
 }
diff --git i/components/eamxx/src/physics/p3/impl/p3_ice_nucleation_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_ice_nucleation_impl.hpp
index 380bf7de00..5a78af7828 100644
--- i/components/eamxx/src/physics/p3/impl/p3_ice_nucleation_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_ice_nucleation_impl.hpp
@@ -7,11 +7,11 @@ namespace scream {
 namespace p3 {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::ice_nucleation(const Spack &temp, const Spack &inv_rho, const Spack &ni, const Spack &ni_activated,
-                                const Spack &qv_supersat_i, const Scalar &inv_dt, const bool &do_predict_nc,
-                                const bool &do_prescribed_CCN, Spack &qv2qi_nucleat_tend, Spack &ni_nucleat_tend,
-                                const P3Runtime &runtime_options, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::ice_nucleation(
+    const Spack &temp, const Spack &inv_rho, const Spack &ni, const Spack &ni_activated,
+    const Spack &qv_supersat_i, const Scalar &inv_dt, const bool &do_predict_nc,
+    const bool &do_prescribed_CCN, Spack &qv2qi_nucleat_tend, Spack &ni_nucleat_tend,
+    const P3Runtime &runtime_options, const Smask &context) {
   constexpr Scalar nsmall   = C::NSMALL;
   constexpr Scalar tmelt    = C::Tmelt;
   constexpr Scalar T_icenuc = C::Tmelt - sp(15.0);
@@ -32,7 +32,8 @@ Functions<S, D>::ice_nucleation(const Spack &temp, const Spack &inv_rho, const S
   Spack dum{0.0}, N_nuc{0.0}, Q_nuc{0.0};
 
   if (any_if_not_log.any()) {
-    dum = sp(0.005) * exp(sp(deposition_nucleation_exponent) * (tmelt - temp)) * sp(1.0e3) * inv_rho;
+    dum =
+        sp(0.005) * exp(sp(deposition_nucleation_exponent) * (tmelt - temp)) * sp(1.0e3) * inv_rho;
 
     dum = min(dum, sp(1.0e5) * inv_rho);
 
diff --git i/components/eamxx/src/physics/p3/impl/p3_ice_relaxation_timescale_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_ice_relaxation_timescale_impl.hpp
index 271b11865a..5af44a7cb0 100644
--- i/components/eamxx/src/physics/p3/impl/p3_ice_relaxation_timescale_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_ice_relaxation_timescale_impl.hpp
@@ -7,11 +7,11 @@ namespace scream {
 namespace p3 {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::ice_relaxation_timescale(const Spack &rho, const Spack &temp, const Spack &rhofaci,
-                                          const Spack &table_val_qi2qr_melting, const Spack &table_val_qi2qr_vent_melt,
-                                          const Spack &dv, const Spack &mu, const Spack &sc, const Spack &qi_incld,
-                                          const Spack &ni_incld, Spack &epsi, Spack &epsi_tot, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::ice_relaxation_timescale(
+    const Spack &rho, const Spack &temp, const Spack &rhofaci, const Spack &table_val_qi2qr_melting,
+    const Spack &table_val_qi2qr_vent_melt, const Spack &dv, const Spack &mu, const Spack &sc,
+    const Spack &qi_incld, const Spack &ni_incld, Spack &epsi, Spack &epsi_tot,
+    const Smask &context) {
   constexpr Scalar qsmall = C::QSMALL;
   constexpr Scalar tmelt  = C::Tmelt;
   constexpr Scalar zero   = C::ZERO;
@@ -26,7 +26,8 @@ Functions<S, D>::ice_relaxation_timescale(const Spack &rho, const Spack &temp, c
    * calculate total inverse ice relaxation timescale combined for all ice categories
    * note 'f1pr' values are normalized, so we need to multiply by N
    */
-  epsi.set(any_if, ((table_val_qi2qr_melting + table_val_qi2qr_vent_melt * cbrt(sc) * sqrt(rhofaci * rho / mu)) *
+  epsi.set(any_if, ((table_val_qi2qr_melting +
+                     table_val_qi2qr_vent_melt * cbrt(sc) * sqrt(rhofaci * rho / mu)) *
                     sp(2.0) * pi * rho * dv) *
                        ni_incld);
 
diff --git i/components/eamxx/src/physics/p3/impl/p3_ice_sed_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_ice_sed_impl.hpp
index 71b69cbf49..116d3072b0 100644
--- i/components/eamxx/src/physics/p3/impl/p3_ice_sed_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_ice_sed_impl.hpp
@@ -13,8 +13,8 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION typename Functions<S, D>::Spack
-Functions<S, D>::calc_bulk_rho_rime(const Spack &qi_tot, Spack &qi_rim, Spack &bi_rim, const P3Runtime &runtime_options,
-                                    const Smask &context) {
+Functions<S, D>::calc_bulk_rho_rime(const Spack &qi_tot, Spack &qi_rim, Spack &bi_rim,
+                                    const P3Runtime &runtime_options, const Smask &context) {
   constexpr Scalar bsmall   = C::BSMALL;
   constexpr Scalar qsmall   = C::QSMALL;
   const Scalar min_rime_rho = runtime_options.min_rime_rho;
@@ -60,21 +60,25 @@ Functions<S, D>::calc_bulk_rho_rime(const Spack &qi_tot, Spack &qi_rim, Spack &b
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::ice_sedimentation(
-    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &rhofaci,
-    const uview_1d<const Spack> &cld_frac_i, const uview_1d<const Spack> &inv_dz, const MemberType &team,
-    const Workspace &workspace, const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
-    const Scalar &inv_dt, const uview_1d<Spack> &qi, const uview_1d<Spack> &qi_incld, const uview_1d<Spack> &ni,
-    const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &qm, const uview_1d<Spack> &qm_incld,
-    const uview_1d<Spack> &bm, const uview_1d<Spack> &bm_incld, const uview_1d<Spack> &qi_tend,
-    const uview_1d<Spack> &ni_tend, const view_ice_table &ice_table_vals, Scalar &precip_ice_surf,
+    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
+    const uview_1d<const Spack> &rhofaci, const uview_1d<const Spack> &cld_frac_i,
+    const uview_1d<const Spack> &inv_dz, const MemberType &team, const Workspace &workspace,
+    const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
+    const Scalar &inv_dt, const uview_1d<Spack> &qi, const uview_1d<Spack> &qi_incld,
+    const uview_1d<Spack> &ni, const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &qm,
+    const uview_1d<Spack> &qm_incld, const uview_1d<Spack> &bm, const uview_1d<Spack> &bm_incld,
+    const uview_1d<Spack> &qi_tend, const uview_1d<Spack> &ni_tend,
+    const view_ice_table &ice_table_vals, Scalar &precip_ice_surf,
     const P3Runtime &runtime_options) {
   // Get temporary workspaces needed for the ice-sed calculation
   uview_1d<Spack> V_qit, V_nit, flux_nit, flux_bir, flux_qir, flux_qit;
-  workspace.template take_many_contiguous_unsafe<6>({"V_qit", "V_nit", "flux_nit", "flux_bir", "flux_qir", "flux_qit"},
-                                                    {&V_qit, &V_nit, &flux_nit, &flux_bir, &flux_qir, &flux_qit});
+  workspace.template take_many_contiguous_unsafe<6>(
+      {"V_qit", "V_nit", "flux_nit", "flux_bir", "flux_qir", "flux_qit"},
+      {&V_qit, &V_nit, &flux_nit, &flux_bir, &flux_qir, &flux_qit});
 
   const view_1d_ptr_array<Spack, 4> fluxes_ptr = {&flux_qit, &flux_nit, &flux_qir, &flux_bir},
-                                    vs_ptr = {&V_qit, &V_nit, &V_qit, &V_qit}, qnr_ptr = {&qi, &ni, &qm, &bm};
+                                    vs_ptr     = {&V_qit, &V_nit, &V_qit, &V_qit},
+                                    qnr_ptr    = {&qi, &ni, &qm, &bm};
 
   // find top, determine qxpresent
   const auto sqi          = scalarize(qi);
@@ -120,29 +124,34 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_sedimentation(
               // impose lower limits to prevent log(<0)
               ni_incld(pk).set(qi_gt_small, max(ni_incld(pk), nsmall));
 
-              const auto rhop =
-                  calc_bulk_rho_rime(qi_incld(pk), qm_incld(pk), bm_incld(pk), runtime_options, qi_gt_small);
+              const auto rhop = calc_bulk_rho_rime(qi_incld(pk), qm_incld(pk), bm_incld(pk),
+                                                   runtime_options, qi_gt_small);
               qm(pk).set(qi_gt_small, qm_incld(pk) * cld_frac_i(pk));
               bm(pk).set(qi_gt_small, bm_incld(pk) * cld_frac_i(pk));
 
               TableIce tab;
               lookup_ice(qi_incld(pk), ni_incld(pk), qm_incld(pk), rhop, tab, qi_gt_small);
 
-              const auto table_val_ni_fallspd = apply_table_ice(0, ice_table_vals, tab, qi_gt_small);
-              const auto table_val_qi_fallspd = apply_table_ice(1, ice_table_vals, tab, qi_gt_small);
-              const auto table_val_ni_lammax  = apply_table_ice(6, ice_table_vals, tab, qi_gt_small);
-              const auto table_val_ni_lammin  = apply_table_ice(7, ice_table_vals, tab, qi_gt_small);
+              const auto table_val_ni_fallspd =
+                  apply_table_ice(0, ice_table_vals, tab, qi_gt_small);
+              const auto table_val_qi_fallspd =
+                  apply_table_ice(1, ice_table_vals, tab, qi_gt_small);
+              const auto table_val_ni_lammax = apply_table_ice(6, ice_table_vals, tab, qi_gt_small);
+              const auto table_val_ni_lammin = apply_table_ice(7, ice_table_vals, tab, qi_gt_small);
 
               // impose mean ice size bounds (i.e. apply lambda limiters)
-              // note that the Nmax and Nmin are normalized and thus need to be multiplied by existing N
+              // note that the Nmax and Nmin are normalized and thus need to be multiplied by
+              // existing N
               ni_incld(pk).set(qi_gt_small, min(ni_incld(pk), table_val_ni_lammax * ni_incld(pk)));
               ni_incld(pk).set(qi_gt_small, max(ni_incld(pk), table_val_ni_lammin * ni_incld(pk)));
               ni(pk).set(qi_gt_small, ni_incld(pk) * cld_frac_i(pk));
 
-              V_qit(pk).set(qi_gt_small, ice_sedimentation_factor * table_val_qi_fallspd *
-                                             rhofaci(pk)); // mass-weighted   fall speed (with density factor)
-              V_nit(pk).set(qi_gt_small, ice_sedimentation_factor * table_val_ni_fallspd *
-                                             rhofaci(pk)); // number-weighted fall speed (with density factor)
+              V_qit(pk).set(qi_gt_small,
+                            ice_sedimentation_factor * table_val_qi_fallspd *
+                                rhofaci(pk)); // mass-weighted   fall speed (with density factor)
+              V_nit(pk).set(qi_gt_small,
+                            ice_sedimentation_factor * table_val_ni_fallspd *
+                                rhofaci(pk)); // number-weighted fall speed (with density factor)
             }
             const auto Co_max_local = max(qi_gt_small, 0, V_qit(pk) * dt_left * inv_dz(pk));
             if (Co_max_local > lmax)
@@ -151,8 +160,8 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_sedimentation(
           Kokkos::Max<Scalar>(Co_max));
       team.team_barrier();
 
-      generalized_sedimentation<4>(rho, inv_rho, inv_dz, team, nk, k_qxtop, k_qxbot, kbot, kdir, Co_max, dt_left,
-                                   prt_accum, fluxes_ptr, vs_ptr, qnr_ptr);
+      generalized_sedimentation<4>(rho, inv_rho, inv_dz, team, nk, k_qxtop, k_qxbot, kbot, kdir,
+                                   Co_max, dt_left, prt_accum, fluxes_ptr, vs_ptr, qnr_ptr);
 
       // Update _incld values with end-of-step cell-ave values
       // No prob w/ div by cld_frac_i because set to min of 1e-4 in interface.
@@ -165,7 +174,8 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_sedimentation(
 
     } // end CFL substep loop
 
-    Kokkos::single(Kokkos::PerTeam(team), [&]() { precip_ice_surf += prt_accum * C::INV_RHO_H2O * inv_dt; });
+    Kokkos::single(Kokkos::PerTeam(team),
+                   [&]() { precip_ice_surf += prt_accum * C::INV_RHO_H2O * inv_dt; });
   }
 
   const Int nk_pack = ekat::npack<Spack>(nk);
@@ -174,14 +184,16 @@ KOKKOS_FUNCTION void Functions<S, D>::ice_sedimentation(
     ni_tend(pk) = (ni(pk) - ni_tend(pk)) * inv_dt; // Liq. # sedimentation tendency, measure
   });
 
-  workspace.template release_many_contiguous<6>({&V_qit, &V_nit, &flux_nit, &flux_bir, &flux_qir, &flux_qit});
+  workspace.template release_many_contiguous<6>(
+      {&V_qit, &V_nit, &flux_nit, &flux_bir, &flux_qir, &flux_qit});
 }
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::homogeneous_freezing(
-    const uview_1d<const Spack> &T_atm, const uview_1d<const Spack> &inv_exner, const MemberType &team, const Int &nk,
-    const Int &ktop, const Int &kbot, const Int &kdir, const uview_1d<Spack> &qc, const uview_1d<Spack> &nc,
-    const uview_1d<Spack> &qr, const uview_1d<Spack> &nr, const uview_1d<Spack> &qi, const uview_1d<Spack> &ni,
+    const uview_1d<const Spack> &T_atm, const uview_1d<const Spack> &inv_exner,
+    const MemberType &team, const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir,
+    const uview_1d<Spack> &qc, const uview_1d<Spack> &nc, const uview_1d<Spack> &qr,
+    const uview_1d<Spack> &nr, const uview_1d<Spack> &qi, const uview_1d<Spack> &ni,
     const uview_1d<Spack> &qm, const uview_1d<Spack> &bm, const uview_1d<Spack> &th_atm) {
   constexpr Scalar qsmall          = C::QSMALL;
   constexpr Scalar nsmall          = C::NSMALL;
diff --git i/components/eamxx/src/physics/p3/impl/p3_ice_supersat_conservation_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_ice_supersat_conservation_impl.hpp
index 1ea1c3fe4c..5e390e8b12 100644
--- i/components/eamxx/src/physics/p3/impl/p3_ice_supersat_conservation_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_ice_supersat_conservation_impl.hpp
@@ -13,9 +13,10 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::ice_supersat_conservation(
-    Spack &qv2qi_vapdep_tend, Spack &qv2qi_nucleat_tend, Spack &qinuc_cnt, const Spack &cld_frac_i, const Spack &qv,
-    const Spack &qv_sat_i, const Spack &t_atm, const Real &dt, const Spack &qi2qv_sublim_tend,
-    const Spack &qr2qv_evap_tend, const bool &use_hetfrz_classnuc, const Smask &context) {
+    Spack &qv2qi_vapdep_tend, Spack &qv2qi_nucleat_tend, Spack &qinuc_cnt, const Spack &cld_frac_i,
+    const Spack &qv, const Spack &qv_sat_i, const Spack &t_atm, const Real &dt,
+    const Spack &qi2qv_sublim_tend, const Spack &qr2qv_evap_tend, const bool &use_hetfrz_classnuc,
+    const Smask &context) {
   constexpr Scalar qsmall     = C::QSMALL;
   constexpr Scalar cp         = C::CP;
   constexpr Scalar rv         = C::RH2O;
diff --git i/components/eamxx/src/physics/p3/impl/p3_impose_max_total_ni_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_impose_max_total_ni_impl.hpp
index 32efb36c81..2dde4349f7 100644
--- i/components/eamxx/src/physics/p3/impl/p3_impose_max_total_ni_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_impose_max_total_ni_impl.hpp
@@ -7,8 +7,9 @@ namespace scream {
 namespace p3 {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::impose_max_total_ni(Spack &ni_local, const Scalar &max_total_ni,
-                                                          const Spack &inv_rho_local, const Smask &context) {
+KOKKOS_FUNCTION void
+Functions<S, D>::impose_max_total_ni(Spack &ni_local, const Scalar &max_total_ni,
+                                     const Spack &inv_rho_local, const Smask &context) {
   //--------------------------------------------------------------------------------
   // Impose maximum total ice number concentration (total of all ice categories).
   // If the sum of all ni(:) exceeds maximum allowable, each category to preserve
diff --git i/components/eamxx/src/physics/p3/impl/p3_incloud_mixingratios_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_incloud_mixingratios_impl.hpp
index f1969ffb64..13fcfaa976 100644
--- i/components/eamxx/src/physics/p3/impl/p3_incloud_mixingratios_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_incloud_mixingratios_impl.hpp
@@ -8,10 +8,11 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::calculate_incloud_mixingratios(
-    const Spack &qc, const Spack &qr, const Spack &qi, const Spack &qm, const Spack &nc, const Spack &nr,
-    const Spack &ni, const Spack &bm, const Spack &inv_cld_frac_l, const Spack &inv_cld_frac_i,
-    const Spack &inv_cld_frac_r, Spack &qc_incld, Spack &qr_incld, Spack &qi_incld, Spack &qm_incld, Spack &nc_incld,
-    Spack &nr_incld, Spack &ni_incld, Spack &bm_incld, const Smask &context) {
+    const Spack &qc, const Spack &qr, const Spack &qi, const Spack &qm, const Spack &nc,
+    const Spack &nr, const Spack &ni, const Spack &bm, const Spack &inv_cld_frac_l,
+    const Spack &inv_cld_frac_i, const Spack &inv_cld_frac_r, Spack &qc_incld, Spack &qr_incld,
+    Spack &qi_incld, Spack &qm_incld, Spack &nc_incld, Spack &nr_incld, Spack &ni_incld,
+    Spack &bm_incld, const Smask &context) {
   constexpr Scalar qsmall        = C::QSMALL;
   constexpr Scalar incloud_limit = C::incloud_limit;
   constexpr Scalar precip_limit  = C::precip_limit;
@@ -52,9 +53,9 @@ KOKKOS_FUNCTION void Functions<S, D>::calculate_incloud_mixingratios(
   qr_incld.set(not_qr_ge_qsmall, 0);
   nr_incld.set(not_qr_ge_qsmall, 0);
 
-  const auto any_gt_limit =
-      (qc_incld > incloud_limit || qi_incld > incloud_limit || qr_incld > precip_limit || bm_incld > incloud_limit) &&
-      context;
+  const auto any_gt_limit = (qc_incld > incloud_limit || qi_incld > incloud_limit ||
+                             qr_incld > precip_limit || bm_incld > incloud_limit) &&
+                            context;
 
   qc_incld.set(any_gt_limit, min(qc_incld, incloud_limit));
   qi_incld.set(any_gt_limit, min(qi_incld, incloud_limit));
diff --git i/components/eamxx/src/physics/p3/impl/p3_init_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_init_impl.hpp
index ea692f61e3..d28bb2c312 100644
--- i/components/eamxx/src/physics/p3/impl/p3_init_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_init_impl.hpp
@@ -13,9 +13,9 @@ namespace p3 {
 namespace {
 
 template <typename S, typename IceT, typename CollT>
-void read_ice_lookup_tables(const bool masterproc, const char *p3_lookup_base, const char *p3_version,
-                            IceT &ice_table_vals, CollT &collect_table_vals, int densize, int rimsize, int isize,
-                            int rcollsize) {
+void read_ice_lookup_tables(const bool masterproc, const char *p3_lookup_base,
+                            const char *p3_version, IceT &ice_table_vals, CollT &collect_table_vals,
+                            int densize, int rimsize, int isize, int rcollsize) {
   using DeviceIcetable = typename IceT::non_const_type;
   using DeviceColtable = typename CollT::non_const_type;
 
@@ -41,8 +41,8 @@ void read_ice_lookup_tables(const bool masterproc, const char *p3_lookup_base, c
   std::string version, version_val;
   in >> version >> version_val;
   EKAT_REQUIRE_MSG(version == "VERSION", "Bad " << filename << ", expected VERSION X.Y.Z header");
-  EKAT_REQUIRE_MSG(version_val == p3_version,
-                   "Bad " << filename << ", expected version " << p3_version << ", but got " << version_val);
+  EKAT_REQUIRE_MSG(version_val == p3_version, "Bad " << filename << ", expected version "
+                                                     << p3_version << ", but got " << version_val);
 
   // read tables
   double dum_s;
@@ -83,8 +83,8 @@ void read_ice_lookup_tables(const bool masterproc, const char *p3_lookup_base, c
 }
 
 template <typename S, typename C, typename MuRT, typename VNT, typename VMT, typename RevapT>
-void compute_tables(const bool masterproc, MuRT &mu_r_table_vals, VNT &vn_table_vals, VMT &vm_table_vals,
-                    RevapT &revap_table_vals) {
+void compute_tables(const bool masterproc, MuRT &mu_r_table_vals, VNT &vn_table_vals,
+                    VMT &vm_table_vals, RevapT &revap_table_vals) {
   using c = scream::physics::Constants<S>;
 
   int ii, jj, kk;
@@ -121,8 +121,9 @@ void compute_tables(const bool masterproc, MuRT &mu_r_table_vals, VNT &vn_table_
 
   // AaronDonahue: Switching to table ver 4 means switching to a constand mu_r,
   // so this section is commented out.
-  Kokkos::deep_copy(mu_r_table_vals_h,
-                    1); // mu_r_constant =1. In other places, this is runtime_options.constant_mu_rain
+  Kokkos::deep_copy(
+      mu_r_table_vals_h,
+      1); // mu_r_constant =1. In other places, this is runtime_options.constant_mu_rain
 
   static constexpr S thrd  = 1. / 3;
   static constexpr S small = 1.e-30;
@@ -173,10 +174,14 @@ void compute_tables(const bool masterproc, MuRT &mu_r_table_vals, VNT &vn_table_
 
         // note: factor of 4.*mu_r is non-answer changing and only needed to
         //       prevent underflow/overflow errors, same with 3.*mu_r for dum5
-        dum1 += vt * std::pow(10, mu_r * std::log10(dia) + 4 * mu_r) * std::exp(-lamr * dia) * dd * 1.e-6;
-        dum2 += std::pow(10, mu_r * std::log10(dia) + 4 * mu_r) * std::exp(-lamr * dia) * dd * 1.e-6;
-        dum3 += vt * std::pow(10, (mu_r + 3) * std::log10(dia) + 4 * mu_r) * std::exp(-lamr * dia) * dd * 1.e-6;
-        dum4 += std::pow(10, (mu_r + 3) * std::log10(dia) + 4 * mu_r) * std::exp(-lamr * dia) * dd * 1.e-6;
+        dum1 += vt * std::pow(10, mu_r * std::log10(dia) + 4 * mu_r) * std::exp(-lamr * dia) * dd *
+                1.e-6;
+        dum2 +=
+            std::pow(10, mu_r * std::log10(dia) + 4 * mu_r) * std::exp(-lamr * dia) * dd * 1.e-6;
+        dum3 += vt * std::pow(10, (mu_r + 3) * std::log10(dia) + 4 * mu_r) * std::exp(-lamr * dia) *
+                dd * 1.e-6;
+        dum4 += std::pow(10, (mu_r + 3) * std::log10(dia) + 4 * mu_r) * std::exp(-lamr * dia) * dd *
+                1.e-6;
         dum5 += std::pow(vt * dia, 0.5) * std::pow(10, (mu_r + 1) * std::log10(dia) + 3 * mu_r) *
                 std::exp(-lamr * dia) * dd * 1.e-6;
       }
@@ -185,9 +190,10 @@ void compute_tables(const bool masterproc, MuRT &mu_r_table_vals, VNT &vn_table_
       dum4 = std::max(dum4, small); // to prevent divide-by-zero below
       dum5 = std::max(dum5, small); // to prevent log10-of-zero below
 
-      vn_table_vals_h(jj - 1, ii - 1)    = dum1 / dum2;
-      vm_table_vals_h(jj - 1, ii - 1)    = dum3 / dum4;
-      revap_table_vals_h(jj - 1, ii - 1) = std::pow(10, std::log10(dum5) + (mu_r + 1) * std::log10(lamr) - (3 * mu_r));
+      vn_table_vals_h(jj - 1, ii - 1) = dum1 / dum2;
+      vm_table_vals_h(jj - 1, ii - 1) = dum3 / dum4;
+      revap_table_vals_h(jj - 1, ii - 1) =
+          std::pow(10, std::log10(dum5) + (mu_r + 1) * std::log10(lamr) - (3 * mu_r));
     }
   }
 
@@ -202,7 +208,8 @@ void compute_tables(const bool masterproc, MuRT &mu_r_table_vals, VNT &vn_table_
   revap_table_vals = revap_table_vals_nc;
 }
 
-template <bool IsRead, typename S> static void action(const ekat::FILEPtr &fid, S *data, const size_t size) {
+template <bool IsRead, typename S>
+static void action(const ekat::FILEPtr &fid, S *data, const size_t size) {
   if constexpr (IsRead) {
     ekat::read(data, size, fid);
   } else {
@@ -211,10 +218,11 @@ template <bool IsRead, typename S> static void action(const ekat::FILEPtr &fid,
 }
 
 template <bool IsRead, typename MuRT, typename VNT, typename VMT, typename RevapT>
-void io_impl(const bool masterproc, const char *dir, MuRT &mu_r_table_vals, VNT &vn_table_vals, VMT &vm_table_vals,
-             RevapT &revap_table_vals) {
+void io_impl(const bool masterproc, const char *dir, MuRT &mu_r_table_vals, VNT &vn_table_vals,
+             VMT &vm_table_vals, RevapT &revap_table_vals) {
   if (masterproc) {
-    std::cout << (IsRead ? "Reading" : "Writing") << " lookup (non-ice) tables in dir " << dir << std::endl;
+    std::cout << (IsRead ? "Reading" : "Writing") << " lookup (non-ice) tables in dir " << dir
+              << std::endl;
   }
 
   std::string extension =
@@ -261,8 +269,8 @@ void io_impl(const bool masterproc, const char *dir, MuRT &mu_r_table_vals, VNT
 }
 
 template <typename MuRT, typename VNT, typename VMT, typename RevapT>
-void read_computed_tables(const bool masterproc, const char *dir, MuRT &mu_r_table_vals, VNT &vn_table_vals,
-                          VMT &vm_table_vals, RevapT &revap_table_vals) {
+void read_computed_tables(const bool masterproc, const char *dir, MuRT &mu_r_table_vals,
+                          VNT &vn_table_vals, VMT &vm_table_vals, RevapT &revap_table_vals) {
   using MuRT_NC   = typename MuRT::non_const_type;
   using VNT_NC    = typename VNT::non_const_type;
   using VMT_NC    = typename VMT::non_const_type;
@@ -273,7 +281,8 @@ void read_computed_tables(const bool masterproc, const char *dir, MuRT &mu_r_tab
   VMT_NC vm_table_vals_nc("vm_table_vals");
   RevapT_NC revap_table_vals_nc("revap_table_vals");
 
-  io_impl<true>(masterproc, dir, mu_r_table_vals_nc, vn_table_vals_nc, vm_table_vals_nc, revap_table_vals_nc);
+  io_impl<true>(masterproc, dir, mu_r_table_vals_nc, vn_table_vals_nc, vm_table_vals_nc,
+                revap_table_vals_nc);
 
   mu_r_table_vals  = mu_r_table_vals_nc;
   vn_table_vals    = vn_table_vals_nc;
@@ -283,7 +292,8 @@ void read_computed_tables(const bool masterproc, const char *dir, MuRT &mu_r_tab
 
 template <typename MuRT, typename VNT, typename VMT, typename RevapT>
 void write_computed_tables(const bool masterproc, const char *dir, const MuRT &mu_r_table_vals,
-                           const VNT &vn_table_vals, const VMT &vm_table_vals, const RevapT &revap_table_vals) {
+                           const VNT &vn_table_vals, const VMT &vm_table_vals,
+                           const RevapT &revap_table_vals) {
   io_impl<false>(masterproc, dir, mu_r_table_vals, vn_table_vals, vm_table_vals, revap_table_vals);
 }
 
@@ -317,23 +327,27 @@ template <typename S, typename DnuT> void compute_dnu(DnuT &dnu_table_vals) {
  * this file, #include p3_functions.hpp instead.
  */
 template <typename S, typename D>
-typename Functions<S, D>::P3LookupTables Functions<S, D>::p3_init(const bool write_tables, const bool masterproc) {
+typename Functions<S, D>::P3LookupTables Functions<S, D>::p3_init(const bool write_tables,
+                                                                  const bool masterproc) {
   P3LookupTables lookup_tables; // This struct could be our global singleton
   auto version           = P3C::p3_version;
   auto p3_lookup_base    = P3C::p3_lookup_base;
   static const char *dir = SCREAM_DATA_DIR "/tables";
   // p3_init_a (reads ice_table, collect_table)
   read_ice_lookup_tables<S>(masterproc, p3_lookup_base, version, lookup_tables.ice_table_vals,
-                            lookup_tables.collect_table_vals, P3C::densize, P3C::rimsize, P3C::isize, P3C::rcollsize);
+                            lookup_tables.collect_table_vals, P3C::densize, P3C::rimsize,
+                            P3C::isize, P3C::rcollsize);
   if (write_tables) {
     // p3_init_b (computes tables mu_r_table, revap_table, vn_table, vm_table)
     compute_tables<S, P3C>(masterproc, lookup_tables.mu_r_table_vals, lookup_tables.vn_table_vals,
                            lookup_tables.vm_table_vals, lookup_tables.revap_table_vals);
-    write_computed_tables(masterproc, dir, lookup_tables.mu_r_table_vals, lookup_tables.vn_table_vals,
-                          lookup_tables.vm_table_vals, lookup_tables.revap_table_vals);
+    write_computed_tables(masterproc, dir, lookup_tables.mu_r_table_vals,
+                          lookup_tables.vn_table_vals, lookup_tables.vm_table_vals,
+                          lookup_tables.revap_table_vals);
   } else {
-    read_computed_tables(masterproc, dir, lookup_tables.mu_r_table_vals, lookup_tables.vn_table_vals,
-                         lookup_tables.vm_table_vals, lookup_tables.revap_table_vals);
+    read_computed_tables(masterproc, dir, lookup_tables.mu_r_table_vals,
+                         lookup_tables.vn_table_vals, lookup_tables.vm_table_vals,
+                         lookup_tables.revap_table_vals);
   }
   // dnu is always computed/hardcoded
   compute_dnu<S>(lookup_tables.dnu_table_vals);
diff --git i/components/eamxx/src/physics/p3/impl/p3_main_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_main_impl.hpp
index 9f502adbb8..61f9bb1bf0 100644
--- i/components/eamxx/src/physics/p3/impl/p3_main_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_main_impl.hpp
@@ -19,13 +19,15 @@ template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::p3_main_init(
     const MemberType &team, const Int &nk_pack, const uview_1d<const Spack> &cld_frac_i,
     const uview_1d<const Spack> &cld_frac_l, const uview_1d<const Spack> &cld_frac_r,
-    const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &th_atm, const uview_1d<const Spack> &dz,
-    const uview_1d<Spack> &diag_equiv_reflectivity, const uview_1d<Spack> &ze_ice, const uview_1d<Spack> &ze_rain,
+    const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &th_atm,
+    const uview_1d<const Spack> &dz, const uview_1d<Spack> &diag_equiv_reflectivity,
+    const uview_1d<Spack> &ze_ice, const uview_1d<Spack> &ze_rain,
     const uview_1d<Spack> &diag_eff_radius_qc, const uview_1d<Spack> &diag_eff_radius_qi,
     const uview_1d<Spack> &diag_eff_radius_qr, const uview_1d<Spack> &inv_cld_frac_i,
-    const uview_1d<Spack> &inv_cld_frac_l, const uview_1d<Spack> &inv_cld_frac_r, const uview_1d<Spack> &exner,
-    const uview_1d<Spack> &T_atm, const uview_1d<Spack> &qv, const uview_1d<Spack> &inv_dz, Scalar &precip_liq_surf,
-    Scalar &precip_ice_surf, view_1d_ptr_array<Spack, 36> &zero_init) {
+    const uview_1d<Spack> &inv_cld_frac_l, const uview_1d<Spack> &inv_cld_frac_r,
+    const uview_1d<Spack> &exner, const uview_1d<Spack> &T_atm, const uview_1d<Spack> &qv,
+    const uview_1d<Spack> &inv_dz, Scalar &precip_liq_surf, Scalar &precip_ice_surf,
+    view_1d_ptr_array<Spack, 36> &zero_init) {
   precip_liq_surf = 0;
   precip_ice_surf = 0;
 
@@ -52,12 +54,11 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_init(
 }
 
 template <typename S, typename D>
-Int Functions<S, D>::p3_main_internal(const P3Runtime &runtime_options, const P3PrognosticState &prognostic_state,
-                                      const P3DiagnosticInputs &diagnostic_inputs,
-                                      const P3DiagnosticOutputs &diagnostic_outputs,
-                                      const P3Infrastructure &infrastructure, const P3HistoryOnly &history_only,
-                                      const P3LookupTables &lookup_tables, const WorkspaceManager &workspace_mgr,
-                                      Int nj, Int nk) {
+Int Functions<S, D>::p3_main_internal(
+    const P3Runtime &runtime_options, const P3PrognosticState &prognostic_state,
+    const P3DiagnosticInputs &diagnostic_inputs, const P3DiagnosticOutputs &diagnostic_outputs,
+    const P3Infrastructure &infrastructure, const P3HistoryOnly &history_only,
+    const P3LookupTables &lookup_tables, const WorkspaceManager &workspace_mgr, Int nj, Int nk) {
   using ExeSpace        = typename KT::ExeSpace;
   using ScratchViewType = Kokkos::View<bool *, typename ExeSpace::scratch_memory_space>;
 
@@ -100,8 +101,8 @@ Int Functions<S, D>::p3_main_internal(const P3Runtime &runtime_options, const P3
             nc_incld, nr_incld, ni_incld, bm_incld,         // In cloud number concentrations
 
             // Other
-            inv_dz, inv_rho, ze_ice, ze_rain, prec, rho, rhofacr, rhofaci, acn, qv_sat_l, qv_sat_i, sup, qv_supersat_i,
-            tmparr1, exner, diag_vm_qi, diag_diam_qi, pratot, prctot,
+            inv_dz, inv_rho, ze_ice, ze_rain, prec, rho, rhofacr, rhofaci, acn, qv_sat_l, qv_sat_i,
+            sup, qv_supersat_i, tmparr1, exner, diag_vm_qi, diag_diam_qi, pratot, prctot,
 
             // p3_tend_out, may not need these
             qtend_ignore, ntend_ignore,
@@ -198,50 +199,50 @@ Int Functions<S, D>::p3_main_internal(const P3Runtime &runtime_options, const P3
 
         // Get single-column subviews of all inputs, shouldn't need any i-indexing
         // after this.
-        const auto opres                = ekat::subview(diagnostic_inputs.pres, i);
-        const auto odz                  = ekat::subview(diagnostic_inputs.dz, i);
-        const auto onc_nuceat_tend      = ekat::subview(diagnostic_inputs.nc_nuceat_tend, i);
-        const auto onccn_prescribed     = ekat::subview(diagnostic_inputs.nccn, i);
-        const auto oni_activated        = ekat::subview(diagnostic_inputs.ni_activated, i);
-        const auto oinv_qc_relvar       = ekat::subview(diagnostic_inputs.inv_qc_relvar, i);
-        const auto odpres               = ekat::subview(diagnostic_inputs.dpres, i);
-        const auto oinv_exner           = ekat::subview(diagnostic_inputs.inv_exner, i);
-        const auto ocld_frac_i          = ekat::subview(diagnostic_inputs.cld_frac_i, i);
-        const auto ocld_frac_l          = ekat::subview(diagnostic_inputs.cld_frac_l, i);
-        const auto ocld_frac_r          = ekat::subview(diagnostic_inputs.cld_frac_r, i);
-        const auto ocol_location        = ekat::subview(infrastructure.col_location, i);
-        const auto oqc                  = ekat::subview(prognostic_state.qc, i);
-        const auto onc                  = ekat::subview(prognostic_state.nc, i);
-        const auto oqr                  = ekat::subview(prognostic_state.qr, i);
-        const auto onr                  = ekat::subview(prognostic_state.nr, i);
-        const auto oqi                  = ekat::subview(prognostic_state.qi, i);
-        const auto oqm                  = ekat::subview(prognostic_state.qm, i);
-        const auto oni                  = ekat::subview(prognostic_state.ni, i);
-        const auto obm                  = ekat::subview(prognostic_state.bm, i);
-        const auto oqv                  = ekat::subview(prognostic_state.qv, i);
-        const auto oth                  = ekat::subview(prognostic_state.th, i);
-        const auto odiag_eff_radius_qc  = ekat::subview(diagnostic_outputs.diag_eff_radius_qc, i);
-        const auto odiag_eff_radius_qi  = ekat::subview(diagnostic_outputs.diag_eff_radius_qi, i);
-        const auto odiag_eff_radius_qr  = ekat::subview(diagnostic_outputs.diag_eff_radius_qr, i);
-        const auto oqv2qi_depos_tend    = ekat::subview(diagnostic_outputs.qv2qi_depos_tend, i);
-        const auto orho_qi              = ekat::subview(diagnostic_outputs.rho_qi, i);
-        const auto oprecip_liq_flux     = ekat::subview(diagnostic_outputs.precip_liq_flux, i);
-        const auto oprecip_ice_flux     = ekat::subview(diagnostic_outputs.precip_ice_flux, i);
-        const auto oprecip_total_tend   = ekat::subview(diagnostic_outputs.precip_total_tend, i);
-        const auto onevapr              = ekat::subview(diagnostic_outputs.nevapr, i);
-        const auto odiag_equiv_refl     = ekat::subview(diagnostic_outputs.diag_equiv_reflectivity, i);
-        const auto oliq_ice_exchange    = ekat::subview(history_only.liq_ice_exchange, i);
-        const auto ovap_liq_exchange    = ekat::subview(history_only.vap_liq_exchange, i);
-        const auto ovap_ice_exchange    = ekat::subview(history_only.vap_ice_exchange, i);
-        const auto oqr2qv_evap          = ekat::subview(history_only.qr2qv_evap, i);
-        const auto oqi2qv_sublim        = ekat::subview(history_only.qi2qv_sublim, i);
-        const auto oqc2qr_accret        = ekat::subview(history_only.qc2qr_accret, i);
-        const auto oqc2qr_autoconv      = ekat::subview(history_only.qc2qr_autoconv, i);
-        const auto oqv2qi_vapdep        = ekat::subview(history_only.qv2qi_vapdep, i);
-        const auto oqc2qi_berg          = ekat::subview(history_only.qc2qi_berg, i);
-        const auto oqc2qr_ice_shed      = ekat::subview(history_only.qc2qr_ice_shed, i);
-        const auto oqc2qi_collect       = ekat::subview(history_only.qc2qi_collect, i);
-        const auto oqr2qi_collect       = ekat::subview(history_only.qr2qi_collect, i);
+        const auto opres               = ekat::subview(diagnostic_inputs.pres, i);
+        const auto odz                 = ekat::subview(diagnostic_inputs.dz, i);
+        const auto onc_nuceat_tend     = ekat::subview(diagnostic_inputs.nc_nuceat_tend, i);
+        const auto onccn_prescribed    = ekat::subview(diagnostic_inputs.nccn, i);
+        const auto oni_activated       = ekat::subview(diagnostic_inputs.ni_activated, i);
+        const auto oinv_qc_relvar      = ekat::subview(diagnostic_inputs.inv_qc_relvar, i);
+        const auto odpres              = ekat::subview(diagnostic_inputs.dpres, i);
+        const auto oinv_exner          = ekat::subview(diagnostic_inputs.inv_exner, i);
+        const auto ocld_frac_i         = ekat::subview(diagnostic_inputs.cld_frac_i, i);
+        const auto ocld_frac_l         = ekat::subview(diagnostic_inputs.cld_frac_l, i);
+        const auto ocld_frac_r         = ekat::subview(diagnostic_inputs.cld_frac_r, i);
+        const auto ocol_location       = ekat::subview(infrastructure.col_location, i);
+        const auto oqc                 = ekat::subview(prognostic_state.qc, i);
+        const auto onc                 = ekat::subview(prognostic_state.nc, i);
+        const auto oqr                 = ekat::subview(prognostic_state.qr, i);
+        const auto onr                 = ekat::subview(prognostic_state.nr, i);
+        const auto oqi                 = ekat::subview(prognostic_state.qi, i);
+        const auto oqm                 = ekat::subview(prognostic_state.qm, i);
+        const auto oni                 = ekat::subview(prognostic_state.ni, i);
+        const auto obm                 = ekat::subview(prognostic_state.bm, i);
+        const auto oqv                 = ekat::subview(prognostic_state.qv, i);
+        const auto oth                 = ekat::subview(prognostic_state.th, i);
+        const auto odiag_eff_radius_qc = ekat::subview(diagnostic_outputs.diag_eff_radius_qc, i);
+        const auto odiag_eff_radius_qi = ekat::subview(diagnostic_outputs.diag_eff_radius_qi, i);
+        const auto odiag_eff_radius_qr = ekat::subview(diagnostic_outputs.diag_eff_radius_qr, i);
+        const auto oqv2qi_depos_tend   = ekat::subview(diagnostic_outputs.qv2qi_depos_tend, i);
+        const auto orho_qi             = ekat::subview(diagnostic_outputs.rho_qi, i);
+        const auto oprecip_liq_flux    = ekat::subview(diagnostic_outputs.precip_liq_flux, i);
+        const auto oprecip_ice_flux    = ekat::subview(diagnostic_outputs.precip_ice_flux, i);
+        const auto oprecip_total_tend  = ekat::subview(diagnostic_outputs.precip_total_tend, i);
+        const auto onevapr             = ekat::subview(diagnostic_outputs.nevapr, i);
+        const auto odiag_equiv_refl  = ekat::subview(diagnostic_outputs.diag_equiv_reflectivity, i);
+        const auto oliq_ice_exchange = ekat::subview(history_only.liq_ice_exchange, i);
+        const auto ovap_liq_exchange = ekat::subview(history_only.vap_liq_exchange, i);
+        const auto ovap_ice_exchange = ekat::subview(history_only.vap_ice_exchange, i);
+        const auto oqr2qv_evap       = ekat::subview(history_only.qr2qv_evap, i);
+        const auto oqi2qv_sublim     = ekat::subview(history_only.qi2qv_sublim, i);
+        const auto oqc2qr_accret     = ekat::subview(history_only.qc2qr_accret, i);
+        const auto oqc2qr_autoconv   = ekat::subview(history_only.qc2qr_autoconv, i);
+        const auto oqv2qi_vapdep     = ekat::subview(history_only.qv2qi_vapdep, i);
+        const auto oqc2qi_berg       = ekat::subview(history_only.qc2qi_berg, i);
+        const auto oqc2qr_ice_shed   = ekat::subview(history_only.qc2qr_ice_shed, i);
+        const auto oqc2qi_collect    = ekat::subview(history_only.qc2qi_collect, i);
+        const auto oqr2qi_collect    = ekat::subview(history_only.qr2qi_collect, i);
         const auto oqc2qi_hetero_freeze = ekat::subview(history_only.qc2qi_hetero_freeze, i);
         const auto oqr2qi_immers_freeze = ekat::subview(history_only.qr2qi_immers_freeze, i);
         const auto oqi2qr_melt          = ekat::subview(history_only.qi2qr_melt, i);
@@ -254,7 +255,8 @@ Int Functions<S, D>::p3_main_internal(const P3Runtime &runtime_options, const P3
         // Inputs for the heteogeneous freezing
         const auto ohetfrz_immersion_nucleation_tend =
             ekat::subview(diagnostic_inputs.hetfrz_immersion_nucleation_tend, i);
-        const auto ohetfrz_contact_nucleation_tend = ekat::subview(diagnostic_inputs.hetfrz_contact_nucleation_tend, i);
+        const auto ohetfrz_contact_nucleation_tend =
+            ekat::subview(diagnostic_inputs.hetfrz_contact_nucleation_tend, i);
         const auto ohetfrz_deposition_nucleation_tend =
             ekat::subview(diagnostic_inputs.hetfrz_deposition_nucleation_tend, i);
 
@@ -302,16 +304,19 @@ Int Functions<S, D>::p3_main_internal(const P3Runtime &runtime_options, const P3
                                                   &oprecip_ice_flux};
 
         // initialize
-        p3_main_init(team, nk_pack, ocld_frac_i, ocld_frac_l, ocld_frac_r, oinv_exner, oth, odz, odiag_equiv_refl,
-                     ze_ice, ze_rain, odiag_eff_radius_qc, odiag_eff_radius_qi, odiag_eff_radius_qr, inv_cld_frac_i,
-                     inv_cld_frac_l, inv_cld_frac_r, exner, T_atm, oqv, inv_dz, diagnostic_outputs.precip_liq_surf(i),
+        p3_main_init(team, nk_pack, ocld_frac_i, ocld_frac_l, ocld_frac_r, oinv_exner, oth, odz,
+                     odiag_equiv_refl, ze_ice, ze_rain, odiag_eff_radius_qc, odiag_eff_radius_qi,
+                     odiag_eff_radius_qr, inv_cld_frac_i, inv_cld_frac_l, inv_cld_frac_r, exner,
+                     T_atm, oqv, inv_dz, diagnostic_outputs.precip_liq_surf(i),
                      diagnostic_outputs.precip_ice_surf(i), zero_init);
 
-        p3_main_part1(team, nk, infrastructure.predictNc, infrastructure.prescribedCCN, infrastructure.dt, opres,
-                      odpres, odz, onc_nuceat_tend, onccn_prescribed, oinv_exner, exner, inv_cld_frac_l, inv_cld_frac_i,
-                      inv_cld_frac_r, T_atm, rho, inv_rho, qv_sat_l, qv_sat_i, qv_supersat_i, rhofacr, rhofaci, acn,
-                      oqv, oth, oqc, onc, oqr, onr, oqi, oni, oqm, obm, qc_incld, qr_incld, qi_incld, qm_incld,
-                      nc_incld, nr_incld, ni_incld, bm_incld, nucleationPossible, hydrometeorsPresent, runtime_options);
+        p3_main_part1(team, nk, infrastructure.predictNc, infrastructure.prescribedCCN,
+                      infrastructure.dt, opres, odpres, odz, onc_nuceat_tend, onccn_prescribed,
+                      oinv_exner, exner, inv_cld_frac_l, inv_cld_frac_i, inv_cld_frac_r, T_atm, rho,
+                      inv_rho, qv_sat_l, qv_sat_i, qv_supersat_i, rhofacr, rhofaci, acn, oqv, oth,
+                      oqc, onc, oqr, onr, oqi, oni, oqm, obm, qc_incld, qr_incld, qi_incld,
+                      qm_incld, nc_incld, nr_incld, ni_incld, bm_incld, nucleationPossible,
+                      hydrometeorsPresent, runtime_options);
 
         // There might not be any work to do for this team
         if (!(nucleationPossible || hydrometeorsPresent)) {
@@ -321,23 +326,27 @@ Int Functions<S, D>::p3_main_internal(const P3Runtime &runtime_options, const P3
         // ------------------------------------------------------------------------------------------
         // main k-loop (for processes):
 
-        p3_main_part2(team, nk_pack, runtime_options.max_total_ni, infrastructure.predictNc,
-                      infrastructure.prescribedCCN, infrastructure.dt, inv_dt, ohetfrz_immersion_nucleation_tend,
-                      ohetfrz_contact_nucleation_tend, ohetfrz_deposition_nucleation_tend, lookup_tables.dnu_table_vals,
-                      lookup_tables.ice_table_vals, lookup_tables.collect_table_vals, lookup_tables.revap_table_vals,
-                      opres, odpres, odz, onc_nuceat_tend, oinv_exner, exner, inv_cld_frac_l, inv_cld_frac_i,
-                      inv_cld_frac_r, oni_activated, oinv_qc_relvar, ocld_frac_i, ocld_frac_l, ocld_frac_r, oqv_prev,
-                      ot_prev, T_atm, rho, inv_rho, qv_sat_l, qv_sat_i, qv_supersat_i, rhofacr, rhofaci, acn, oqv, oth,
-                      oqc, onc, oqr, onr, oqi, oni, oqm, obm, qc_incld, qr_incld, qi_incld, qm_incld, nc_incld,
-                      nr_incld, ni_incld, bm_incld, mu_c, nu, lamc, cdist, cdist1, cdistr, mu_r, lamr, logn0r,
-                      oqv2qi_depos_tend, oprecip_total_tend, onevapr, qr_evap_tend, ovap_liq_exchange,
-                      ovap_ice_exchange, oliq_ice_exchange, oqr2qv_evap, oqi2qv_sublim, oqc2qr_accret, oqc2qr_autoconv,
-                      oqv2qi_vapdep, oqc2qi_berg, oqc2qr_ice_shed, oqc2qi_collect, oqr2qi_collect, oqc2qi_hetero_freeze,
-                      oqr2qi_immers_freeze, oqi2qr_melt, pratot, prctot, hydrometeorsPresent, nk, runtime_options);
+        p3_main_part2(
+            team, nk_pack, runtime_options.max_total_ni, infrastructure.predictNc,
+            infrastructure.prescribedCCN, infrastructure.dt, inv_dt,
+            ohetfrz_immersion_nucleation_tend, ohetfrz_contact_nucleation_tend,
+            ohetfrz_deposition_nucleation_tend, lookup_tables.dnu_table_vals,
+            lookup_tables.ice_table_vals, lookup_tables.collect_table_vals,
+            lookup_tables.revap_table_vals, opres, odpres, odz, onc_nuceat_tend, oinv_exner, exner,
+            inv_cld_frac_l, inv_cld_frac_i, inv_cld_frac_r, oni_activated, oinv_qc_relvar,
+            ocld_frac_i, ocld_frac_l, ocld_frac_r, oqv_prev, ot_prev, T_atm, rho, inv_rho, qv_sat_l,
+            qv_sat_i, qv_supersat_i, rhofacr, rhofaci, acn, oqv, oth, oqc, onc, oqr, onr, oqi, oni,
+            oqm, obm, qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld,
+            bm_incld, mu_c, nu, lamc, cdist, cdist1, cdistr, mu_r, lamr, logn0r, oqv2qi_depos_tend,
+            oprecip_total_tend, onevapr, qr_evap_tend, ovap_liq_exchange, ovap_ice_exchange,
+            oliq_ice_exchange, oqr2qv_evap, oqi2qv_sublim, oqc2qr_accret, oqc2qr_autoconv,
+            oqv2qi_vapdep, oqc2qi_berg, oqc2qr_ice_shed, oqc2qi_collect, oqr2qi_collect,
+            oqc2qi_hetero_freeze, oqr2qi_immers_freeze, oqi2qr_melt, pratot, prctot,
+            hydrometeorsPresent, nk, runtime_options);
 
         // NOTE: At this point, it is possible to have negative (but small) nc, nr, ni.  This is not
-        //       a problem; those values get clipped to zero in the sedimentation section (if necessary).
-        //       (This is not done above simply for efficiency purposes.)
+        //       a problem; those values get clipped to zero in the sedimentation section (if
+        //       necessary). (This is not done above simply for efficiency purposes.)
 
         if (!hydrometeorsPresent)
           return;
@@ -351,26 +360,30 @@ Int Functions<S, D>::p3_main_internal(const P3Runtime &runtime_options, const P3
 
         // Cloud sedimentation:  (adaptive substepping)
 
-        cloud_sedimentation(qc_incld, rho, inv_rho, ocld_frac_l, acn, inv_dz, lookup_tables.dnu_table_vals, team,
-                            workspace, nk, ktop, kbot, kdir, infrastructure.dt, inv_dt, infrastructure.predictNc, oqc,
-                            onc, nc_incld, mu_c, lamc, oqc_sed, ntend_ignore, diagnostic_outputs.precip_liq_surf(i));
+        cloud_sedimentation(qc_incld, rho, inv_rho, ocld_frac_l, acn, inv_dz,
+                            lookup_tables.dnu_table_vals, team, workspace, nk, ktop, kbot, kdir,
+                            infrastructure.dt, inv_dt, infrastructure.predictNc, oqc, onc, nc_incld,
+                            mu_c, lamc, oqc_sed, ntend_ignore,
+                            diagnostic_outputs.precip_liq_surf(i));
 
         // Rain sedimentation:  (adaptive substepping)
         rain_sedimentation(rho, inv_rho, rhofacr, ocld_frac_r, inv_dz, qr_incld, team, workspace,
-                           lookup_tables.vn_table_vals, lookup_tables.vm_table_vals, nk, ktop, kbot, kdir,
-                           infrastructure.dt, inv_dt, oqr, onr, nr_incld, mu_r, lamr, oprecip_liq_flux, oqr_sed,
-                           ntend_ignore, diagnostic_outputs.precip_liq_surf(i), runtime_options);
+                           lookup_tables.vn_table_vals, lookup_tables.vm_table_vals, nk, ktop, kbot,
+                           kdir, infrastructure.dt, inv_dt, oqr, onr, nr_incld, mu_r, lamr,
+                           oprecip_liq_flux, oqr_sed, ntend_ignore,
+                           diagnostic_outputs.precip_liq_surf(i), runtime_options);
 
         // Ice sedimentation:  (adaptive substepping)
-        ice_sedimentation(rho, inv_rho, rhofaci, ocld_frac_i, inv_dz, team, workspace, nk, ktop, kbot, kdir,
-                          infrastructure.dt, inv_dt, oqi, qi_incld, oni, ni_incld, oqm, qm_incld, obm, bm_incld,
-                          oqi_sed, ntend_ignore, lookup_tables.ice_table_vals, diagnostic_outputs.precip_ice_surf(i),
+        ice_sedimentation(rho, inv_rho, rhofaci, ocld_frac_i, inv_dz, team, workspace, nk, ktop,
+                          kbot, kdir, infrastructure.dt, inv_dt, oqi, qi_incld, oni, ni_incld, oqm,
+                          qm_incld, obm, bm_incld, oqi_sed, ntend_ignore,
+                          lookup_tables.ice_table_vals, diagnostic_outputs.precip_ice_surf(i),
                           runtime_options);
 
         // homogeneous freezing of cloud and rain
         if (do_ice_production) {
-          homogeneous_freezing(T_atm, oinv_exner, team, nk, ktop, kbot, kdir, oqc, onc, oqr, onr, oqi, oni, oqm, obm,
-                               oth);
+          homogeneous_freezing(T_atm, oinv_exner, team, nk, ktop, kbot, kdir, oqc, onc, oqr, onr,
+                               oqi, oni, oqm, obm, oth);
         }
 
         //
@@ -378,10 +391,11 @@ Int Functions<S, D>::p3_main_internal(const P3Runtime &runtime_options, const P3
         // and compute diagnostic fields for output
         //
         p3_main_part3(team, nk_pack, runtime_options.max_total_ni, lookup_tables.dnu_table_vals,
-                      lookup_tables.ice_table_vals, oinv_exner, ocld_frac_l, ocld_frac_r, ocld_frac_i, rho, inv_rho,
-                      rhofaci, oqv, oth, oqc, onc, oqr, onr, oqi, oni, oqm, obm, mu_c, nu, lamc, mu_r, lamr,
-                      ovap_liq_exchange, ze_rain, ze_ice, diag_vm_qi, odiag_eff_radius_qi, diag_diam_qi, orho_qi,
-                      odiag_equiv_refl, odiag_eff_radius_qc, odiag_eff_radius_qr, runtime_options);
+                      lookup_tables.ice_table_vals, oinv_exner, ocld_frac_l, ocld_frac_r,
+                      ocld_frac_i, rho, inv_rho, rhofaci, oqv, oth, oqc, onc, oqr, onr, oqi, oni,
+                      oqm, obm, mu_c, nu, lamc, mu_r, lamr, ovap_liq_exchange, ze_rain, ze_ice,
+                      diag_vm_qi, odiag_eff_radius_qi, diag_diam_qi, orho_qi, odiag_equiv_refl,
+                      odiag_eff_radius_qc, odiag_eff_radius_qr, runtime_options);
 
     //
     // merge ice categories with similar properties
@@ -392,9 +406,11 @@ Int Functions<S, D>::p3_main_internal(const P3Runtime &runtime_options, const P3
     // PMC nCat deleted nCat>1 stuff
 
 #ifndef NDEBUG
-        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nk_pack), [&](Int k) { tmparr1(k) = oth(k) * exner(k); });
+        Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nk_pack),
+                             [&](Int k) { tmparr1(k) = oth(k) * exner(k); });
 
-        check_values(oqv, tmparr1, ktop, kbot, infrastructure.it, debug_ABORT, 900, team, ocol_location);
+        check_values(oqv, tmparr1, ktop, kbot, infrastructure.it, debug_ABORT, 900, team,
+                     ocol_location);
 #endif
       });
   Kokkos::fence();
@@ -405,20 +421,23 @@ Int Functions<S, D>::p3_main_internal(const P3Runtime &runtime_options, const P3
 }
 
 template <typename S, typename D>
-Int Functions<S, D>::p3_main(const P3Runtime &runtime_options, const P3PrognosticState &prognostic_state,
-                             const P3DiagnosticInputs &diagnostic_inputs, const P3DiagnosticOutputs &diagnostic_outputs,
-                             const P3Infrastructure &infrastructure, const P3HistoryOnly &history_only,
-                             const P3LookupTables &lookup_tables,
+Int Functions<S, D>::p3_main(const P3Runtime &runtime_options,
+                             const P3PrognosticState &prognostic_state,
+                             const P3DiagnosticInputs &diagnostic_inputs,
+                             const P3DiagnosticOutputs &diagnostic_outputs,
+                             const P3Infrastructure &infrastructure,
+                             const P3HistoryOnly &history_only, const P3LookupTables &lookup_tables,
 #ifdef SCREAM_P3_SMALL_KERNELS
                              const P3Temporaries &temporaries,
 #endif
                              const WorkspaceManager &workspace_mgr, Int nj, Int nk) {
 #ifdef SCREAM_P3_SMALL_KERNELS
-  return p3_main_internal_disp(runtime_options, prognostic_state, diagnostic_inputs, diagnostic_outputs, infrastructure,
-                               history_only, lookup_tables, temporaries, workspace_mgr, nj, nk);
+  return p3_main_internal_disp(runtime_options, prognostic_state, diagnostic_inputs,
+                               diagnostic_outputs, infrastructure, history_only, lookup_tables,
+                               temporaries, workspace_mgr, nj, nk);
 #else
-  return p3_main_internal(runtime_options, prognostic_state, diagnostic_inputs, diagnostic_outputs, infrastructure,
-                          history_only, lookup_tables, workspace_mgr, nj, nk);
+  return p3_main_internal(runtime_options, prognostic_state, diagnostic_inputs, diagnostic_outputs,
+                          infrastructure, history_only, lookup_tables, workspace_mgr, nj, nk);
 #endif
 }
 } // namespace p3
diff --git i/components/eamxx/src/physics/p3/impl/p3_main_impl_part1.hpp w/components/eamxx/src/physics/p3/impl/p3_main_impl_part1.hpp
index 81dcdac89b..d8a0bfabec 100644
--- i/components/eamxx/src/physics/p3/impl/p3_main_impl_part1.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_main_impl_part1.hpp
@@ -17,21 +17,24 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::p3_main_part1(
-    const MemberType &team, const Int &nk, const bool &predictNc, const bool &do_prescribed_CCN, const Scalar &dt,
-    const uview_1d<const Spack> &pres, const uview_1d<const Spack> &dpres, const uview_1d<const Spack> &dz,
-    const uview_1d<const Spack> &nc_nuceat_tend, const uview_1d<const Spack> &nccn_prescribed,
-    const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &exner,
-    const uview_1d<const Spack> &inv_cld_frac_l, const uview_1d<const Spack> &inv_cld_frac_i,
-    const uview_1d<const Spack> &inv_cld_frac_r, const uview_1d<Spack> &T_atm, const uview_1d<Spack> &rho,
-    const uview_1d<Spack> &inv_rho, const uview_1d<Spack> &qv_sat_l, const uview_1d<Spack> &qv_sat_i,
-    const uview_1d<Spack> &qv_supersat_i, const uview_1d<Spack> &rhofacr, const uview_1d<Spack> &rhofaci,
-    const uview_1d<Spack> &acn, const uview_1d<Spack> &qv, const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc,
-    const uview_1d<Spack> &nc, const uview_1d<Spack> &qr, const uview_1d<Spack> &nr, const uview_1d<Spack> &qi,
-    const uview_1d<Spack> &ni, const uview_1d<Spack> &qm, const uview_1d<Spack> &bm, const uview_1d<Spack> &qc_incld,
-    const uview_1d<Spack> &qr_incld, const uview_1d<Spack> &qi_incld, const uview_1d<Spack> &qm_incld,
-    const uview_1d<Spack> &nc_incld, const uview_1d<Spack> &nr_incld, const uview_1d<Spack> &ni_incld,
-    const uview_1d<Spack> &bm_incld, bool &nucleationPossible, bool &hydrometeorsPresent,
-    const P3Runtime &runtime_options) {
+    const MemberType &team, const Int &nk, const bool &predictNc, const bool &do_prescribed_CCN,
+    const Scalar &dt, const uview_1d<const Spack> &pres, const uview_1d<const Spack> &dpres,
+    const uview_1d<const Spack> &dz, const uview_1d<const Spack> &nc_nuceat_tend,
+    const uview_1d<const Spack> &nccn_prescribed, const uview_1d<const Spack> &inv_exner,
+    const uview_1d<const Spack> &exner, const uview_1d<const Spack> &inv_cld_frac_l,
+    const uview_1d<const Spack> &inv_cld_frac_i, const uview_1d<const Spack> &inv_cld_frac_r,
+    const uview_1d<Spack> &T_atm, const uview_1d<Spack> &rho, const uview_1d<Spack> &inv_rho,
+    const uview_1d<Spack> &qv_sat_l, const uview_1d<Spack> &qv_sat_i,
+    const uview_1d<Spack> &qv_supersat_i, const uview_1d<Spack> &rhofacr,
+    const uview_1d<Spack> &rhofaci, const uview_1d<Spack> &acn, const uview_1d<Spack> &qv,
+    const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc, const uview_1d<Spack> &nc,
+    const uview_1d<Spack> &qr, const uview_1d<Spack> &nr, const uview_1d<Spack> &qi,
+    const uview_1d<Spack> &ni, const uview_1d<Spack> &qm, const uview_1d<Spack> &bm,
+    const uview_1d<Spack> &qc_incld, const uview_1d<Spack> &qr_incld,
+    const uview_1d<Spack> &qi_incld, const uview_1d<Spack> &qm_incld,
+    const uview_1d<Spack> &nc_incld, const uview_1d<Spack> &nr_incld,
+    const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &bm_incld, bool &nucleationPossible,
+    bool &hydrometeorsPresent, const P3Runtime &runtime_options) {
   // Get access to saturation functions
   using physics = scream::physics::Functions<Scalar, Device>;
 
@@ -68,12 +71,12 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part1(
     const auto range_pack = ekat::range<IntSmallPack>(k * Spack::n);
     const auto range_mask = range_pack < nk;
 
-    rho(k)     = dpres(k) / dz(k) / g;
-    inv_rho(k) = 1 / rho(k);
-    qv_sat_l(k) =
-        physics::qv_sat_dry(T_atm(k), pres(k), false, range_mask, physics::MurphyKoop, "p3::p3_main_part1 (liquid)");
-    qv_sat_i(k) =
-        physics::qv_sat_dry(T_atm(k), pres(k), true, range_mask, physics::MurphyKoop, "p3::p3_main_part1 (ice)");
+    rho(k)      = dpres(k) / dz(k) / g;
+    inv_rho(k)  = 1 / rho(k);
+    qv_sat_l(k) = physics::qv_sat_dry(T_atm(k), pres(k), false, range_mask, physics::MurphyKoop,
+                                      "p3::p3_main_part1 (liquid)");
+    qv_sat_i(k) = physics::qv_sat_dry(T_atm(k), pres(k), true, range_mask, physics::MurphyKoop,
+                                      "p3::p3_main_part1 (ice)");
 
     qv_supersat_i(k) = qv(k) / qv_sat_i(k) - 1;
 
@@ -96,9 +99,9 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part1(
     nc(k).set(drymass, 0);
     if (not_drymass.any()) {
       hydrometeorsPresent = true; // updated further down
-      // Apply droplet activation here (before other microphysical processes) for consistency with qc increase by
-      // saturation adjustment already applied in macrophysics. If prescribed drop number is used, this is also a good
-      // place to prescribe that value
+      // Apply droplet activation here (before other microphysical processes) for consistency with
+      // qc increase by saturation adjustment already applied in macrophysics. If prescribed drop
+      // number is used, this is also a good place to prescribe that value
 
       if (do_prescribed_CCN) {
         // the SPA equation is of the form:
@@ -155,9 +158,10 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part1(
 
     T_atm(k) = th_atm(k) * exner(k);
 
-    calculate_incloud_mixingratios(qc(k), qr(k), qi(k), qm(k), nc(k), nr(k), ni(k), bm(k), inv_cld_frac_l(k),
-                                   inv_cld_frac_i(k), inv_cld_frac_r(k), qc_incld(k), qr_incld(k), qi_incld(k),
-                                   qm_incld(k), nc_incld(k), nr_incld(k), ni_incld(k), bm_incld(k));
+    calculate_incloud_mixingratios(qc(k), qr(k), qi(k), qm(k), nc(k), nr(k), ni(k), bm(k),
+                                   inv_cld_frac_l(k), inv_cld_frac_i(k), inv_cld_frac_r(k),
+                                   qc_incld(k), qr_incld(k), qi_incld(k), qm_incld(k), nc_incld(k),
+                                   nr_incld(k), ni_incld(k), bm_incld(k));
   });
   team.team_barrier();
 }
diff --git i/components/eamxx/src/physics/p3/impl/p3_main_impl_part2.hpp w/components/eamxx/src/physics/p3/impl/p3_main_impl_part2.hpp
index d68db9672d..d2a6fe1cb9 100644
--- i/components/eamxx/src/physics/p3/impl/p3_main_impl_part2.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_main_impl_part2.hpp
@@ -23,33 +23,39 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
     const uview_1d<const Spack> &hetfrz_contact_nucleation_tend,
     const uview_1d<const Spack> &hetfrz_deposition_nucleation_tend, const view_dnu_table &dnu,
     const view_ice_table &ice_table_vals, const view_collect_table &collect_table_vals,
-    const view_2d_table &revap_table_vals, const uview_1d<const Spack> &pres, const uview_1d<const Spack> &dpres,
-    const uview_1d<const Spack> &dz, const uview_1d<const Spack> &nc_nuceat_tend,
-    const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &exner,
-    const uview_1d<const Spack> &inv_cld_frac_l, const uview_1d<const Spack> &inv_cld_frac_i,
-    const uview_1d<const Spack> &inv_cld_frac_r, const uview_1d<const Spack> &ni_activated,
-    const uview_1d<const Spack> &inv_qc_relvar, const uview_1d<const Spack> &cld_frac_i,
-    const uview_1d<const Spack> &cld_frac_l, const uview_1d<const Spack> &cld_frac_r,
-    const uview_1d<const Spack> &qv_prev, const uview_1d<const Spack> &t_prev, const uview_1d<Spack> &T_atm,
-    const uview_1d<Spack> &rho, const uview_1d<Spack> &inv_rho, const uview_1d<Spack> &qv_sat_l,
-    const uview_1d<Spack> &qv_sat_i, const uview_1d<Spack> &qv_supersat_i, const uview_1d<Spack> &rhofacr,
-    const uview_1d<Spack> &rhofaci, const uview_1d<Spack> &acn, const uview_1d<Spack> &qv,
-    const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc, const uview_1d<Spack> &nc, const uview_1d<Spack> &qr,
-    const uview_1d<Spack> &nr, const uview_1d<Spack> &qi, const uview_1d<Spack> &ni, const uview_1d<Spack> &qm,
+    const view_2d_table &revap_table_vals, const uview_1d<const Spack> &pres,
+    const uview_1d<const Spack> &dpres, const uview_1d<const Spack> &dz,
+    const uview_1d<const Spack> &nc_nuceat_tend, const uview_1d<const Spack> &inv_exner,
+    const uview_1d<const Spack> &exner, const uview_1d<const Spack> &inv_cld_frac_l,
+    const uview_1d<const Spack> &inv_cld_frac_i, const uview_1d<const Spack> &inv_cld_frac_r,
+    const uview_1d<const Spack> &ni_activated, const uview_1d<const Spack> &inv_qc_relvar,
+    const uview_1d<const Spack> &cld_frac_i, const uview_1d<const Spack> &cld_frac_l,
+    const uview_1d<const Spack> &cld_frac_r, const uview_1d<const Spack> &qv_prev,
+    const uview_1d<const Spack> &t_prev, const uview_1d<Spack> &T_atm, const uview_1d<Spack> &rho,
+    const uview_1d<Spack> &inv_rho, const uview_1d<Spack> &qv_sat_l,
+    const uview_1d<Spack> &qv_sat_i, const uview_1d<Spack> &qv_supersat_i,
+    const uview_1d<Spack> &rhofacr, const uview_1d<Spack> &rhofaci, const uview_1d<Spack> &acn,
+    const uview_1d<Spack> &qv, const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc,
+    const uview_1d<Spack> &nc, const uview_1d<Spack> &qr, const uview_1d<Spack> &nr,
+    const uview_1d<Spack> &qi, const uview_1d<Spack> &ni, const uview_1d<Spack> &qm,
     const uview_1d<Spack> &bm, const uview_1d<Spack> &qc_incld, const uview_1d<Spack> &qr_incld,
-    const uview_1d<Spack> &qi_incld, const uview_1d<Spack> &qm_incld, const uview_1d<Spack> &nc_incld,
-    const uview_1d<Spack> &nr_incld, const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &bm_incld,
-    const uview_1d<Spack> &mu_c, const uview_1d<Spack> &nu, const uview_1d<Spack> &lamc, const uview_1d<Spack> &cdist,
+    const uview_1d<Spack> &qi_incld, const uview_1d<Spack> &qm_incld,
+    const uview_1d<Spack> &nc_incld, const uview_1d<Spack> &nr_incld,
+    const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &bm_incld, const uview_1d<Spack> &mu_c,
+    const uview_1d<Spack> &nu, const uview_1d<Spack> &lamc, const uview_1d<Spack> &cdist,
     const uview_1d<Spack> &cdist1, const uview_1d<Spack> &cdistr, const uview_1d<Spack> &mu_r,
-    const uview_1d<Spack> &lamr, const uview_1d<Spack> &logn0r, const uview_1d<Spack> &qv2qi_depos_tend,
-    const uview_1d<Spack> &precip_total_tend, const uview_1d<Spack> &nevapr, const uview_1d<Spack> &qr_evap_tend,
+    const uview_1d<Spack> &lamr, const uview_1d<Spack> &logn0r,
+    const uview_1d<Spack> &qv2qi_depos_tend, const uview_1d<Spack> &precip_total_tend,
+    const uview_1d<Spack> &nevapr, const uview_1d<Spack> &qr_evap_tend,
     const uview_1d<Spack> &vap_liq_exchange, const uview_1d<Spack> &vap_ice_exchange,
-    const uview_1d<Spack> &liq_ice_exchange, const uview_1d<Spack> &qr2qv_evap, const uview_1d<Spack> &qi2qv_sublim,
-    const uview_1d<Spack> &qc2qr_accret, const uview_1d<Spack> &qc2qr_autoconv, const uview_1d<Spack> &qv2qi_vapdep,
-    const uview_1d<Spack> &qc2qi_berg, const uview_1d<Spack> &qc2qr_ice_shed, const uview_1d<Spack> &qc2qi_collect,
-    const uview_1d<Spack> &qr2qi_collect, const uview_1d<Spack> &qc2qi_hetero_freeze,
-    const uview_1d<Spack> &qr2qi_immers_freeze, const uview_1d<Spack> &qi2qr_melt, const uview_1d<Spack> &pratot,
-    const uview_1d<Spack> &prctot, bool &hydrometeorsPresent, const Int &nk, const P3Runtime &runtime_options) {
+    const uview_1d<Spack> &liq_ice_exchange, const uview_1d<Spack> &qr2qv_evap,
+    const uview_1d<Spack> &qi2qv_sublim, const uview_1d<Spack> &qc2qr_accret,
+    const uview_1d<Spack> &qc2qr_autoconv, const uview_1d<Spack> &qv2qi_vapdep,
+    const uview_1d<Spack> &qc2qi_berg, const uview_1d<Spack> &qc2qr_ice_shed,
+    const uview_1d<Spack> &qc2qi_collect, const uview_1d<Spack> &qr2qi_collect,
+    const uview_1d<Spack> &qc2qi_hetero_freeze, const uview_1d<Spack> &qr2qi_immers_freeze,
+    const uview_1d<Spack> &qi2qr_melt, const uview_1d<Spack> &pratot, const uview_1d<Spack> &prctot,
+    bool &hydrometeorsPresent, const Int &nk, const P3Runtime &runtime_options) {
   constexpr Scalar qsmall     = C::QSMALL;
   constexpr Scalar nsmall     = C::NSMALL;
   constexpr Scalar T_zerodegc = C::T_zerodegc;
@@ -74,7 +80,8 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
     const auto range_pack = ekat::range<IntSmallPack>(k * Spack::n);
     const auto range_mask = range_pack < nk;
 
-    // if relatively dry and no hydrometeors at this level, skip to end of k-loop (i.e. skip this level)
+    // if relatively dry and no hydrometeors at this level, skip to end of k-loop (i.e. skip this
+    // level)
     const auto skip_all = (!range_mask || (qc(k) < qsmall && qr(k) < qsmall && qi(k) < qsmall &&
                                            T_atm(k) < T_zerodegc && qv_supersat_i(k) < -0.05));
 
@@ -83,7 +90,8 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
     }
     const auto not_skip_all = !skip_all;
 
-    // All microphysics tendencies will be computed as IN-CLOUD, they will be mapped back to cell-average later.
+    // All microphysics tendencies will be computed as IN-CLOUD, they will be mapped back to
+    // cell-average later.
 
     Spack
         // initialize warm-phase process rates
@@ -91,33 +99,36 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
         qr2qv_evap_tend(0),     // rain evaporation
         qc2qr_autoconv_tend(0), // cloud droplet autoconversion to rain
         nc_accret_tend(0),      // change in cloud droplet number from accretion by rain
-        nc_selfcollect_tend(0), // change in cloud droplet number from self-collection  (Not in paper?)
+        nc_selfcollect_tend(
+            0), // change in cloud droplet number from self-collection  (Not in paper?)
         nc2nr_autoconv_tend(0), // change in cloud droplet number from autoconversion
         nr_selfcollect_tend(0), // change in rain number from self-collection  (Not in paper?)
         nr_evap_tend(0),        // change in rain number from evaporation
         ncautr(0),              // change in rain number from autoconversion of cloud water
 
         // initialize ice-phase  process rates
-        qi2qv_sublim_tend(0),        // sublimation of ice
-        nr_ice_shed_tend(0),         // source for rain number from collision of rain/ice above freezing and shedding
+        qi2qv_sublim_tend(0), // sublimation of ice
+        nr_ice_shed_tend(
+            0), // source for rain number from collision of rain/ice above freezing and shedding
         qc2qi_hetero_freeze_tend(0), // immersion freezing droplets
         qr2qi_collect_tend(0),       // collection rain mass by ice
-        qc2qr_ice_shed_tend(0), // source for rain mass due to cloud water/ice collision above freezing and shedding or
-                                // wet growth and shedding
-        qi2qr_melt_tend(0),     // melting of ice
-        qc2qi_collect_tend(0),  // collection of cloud water by ice
+        qc2qr_ice_shed_tend(0),      // source for rain mass due to cloud water/ice collision above
+                                // freezing and shedding or wet growth and shedding
+        qi2qr_melt_tend(0),          // melting of ice
+        qc2qi_collect_tend(0),       // collection of cloud water by ice
         qr2qi_immers_freeze_tend(0), // immersion freezing rain
         qv2qi_nucleat_tend(0),       // deposition/condensation freezing nuc
         ni2nr_melt_tend(0),          // melting of ice
         nc_collect_tend(0),          // change in cloud droplet number from collection by ice
-        ncshdc(0), // source for rain number due to cloud water/ice collision above freezing  and shedding (combined
-                   // with NRSHD in the paper)
+        ncshdc(0), // source for rain number due to cloud water/ice collision above freezing  and
+                   // shedding (combined with NRSHD in the paper)
         nc2ni_immers_freeze_tend(0), // immersion freezing droplets
         nr_collect_tend(0),          // change in rain number from collection by ice
-        ni_selfcollect_tend(0),      // change in ice number from collection within a category (Not in paper?)
-        ni_nucleat_tend(0),          // change in ice number from deposition/cond-freezing nucleation
-        qv2qi_vapdep_tend(0),        // vapor deposition
-        qc2qi_berg_tend(0),          // Bergeron process
+        ni_selfcollect_tend(
+            0), // change in ice number from collection within a category (Not in paper?)
+        ni_nucleat_tend(0),   // change in ice number from deposition/cond-freezing nucleation
+        qv2qi_vapdep_tend(0), // vapor deposition
+        qc2qi_berg_tend(0),   // Bergeron process
         nr2ni_immers_freeze_tend(0), // immersion freezing rain
         ni_sublim_tend(0),           // change in ice number from sublimation
         qc_growth_rate(0),           // wet growth rate
@@ -140,19 +151,29 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
         // For a more in depth reference to where these came from consult the file
         // "create_p3_lookupTable_1.F90-v4.1".  All line numbers below reference this
         // file.
-        table_val_qi_fallspd(0),       // mass-weighted fallspeed              See lines  731 -  808  ums
-        table_val_ni_self_collect(0),  // ice collection within a category     See lines  809 -  928  nagg
-        table_val_qc2qi_collect(0),    // collection of cloud water by ice     See lines  929 - 1009  nrwat
-        table_val_qi2qr_melting(0),    // melting                              See lines 1212 - 1279  vdep
-        table_val_ice_eff_radius(0),   // effective radius                     See lines 1281 - 1356  eff
-        table_val_nr_collect(0),       // collection of rain number by ice     See lines 1010 - 1209  nrrain
-        table_val_qr2qi_collect(0),    // collection of rain mass by ice       See lines 1010 - 1209  qrrain
-        table_val_ni_lammax(0),        // minimum ice number (lambda limiter)  See lines  704 -  705  nlarge
-        table_val_ni_lammin(0),        // maximum ice number (lambda limiter)  See lines  704 -  705  nsmall
-        table_val_ice_reflectivity(0), // reflectivity                         See lines  731 -  808  refl
-        table_val_qi2qr_vent_melt(0),  // melting (ventilation term)           See lines 1212 - 1279  vdep1
-        table_val_ice_mean_diam(0),    // mass-weighted mean diameter          See lines 1212 - 1279  dmm
-        table_val_ice_bulk_dens(0),    // mass-weighted mean particle density  See lines 1212 - 1279  rhomm
+        table_val_qi_fallspd(0), // mass-weighted fallspeed              See lines  731 -  808  ums
+        table_val_ni_self_collect(
+            0), // ice collection within a category     See lines  809 -  928  nagg
+        table_val_qc2qi_collect(
+            0), // collection of cloud water by ice     See lines  929 - 1009  nrwat
+        table_val_qi2qr_melting(
+            0), // melting                              See lines 1212 - 1279  vdep
+        table_val_ice_eff_radius(
+            0), // effective radius                     See lines 1281 - 1356  eff
+        table_val_nr_collect(
+            0), // collection of rain number by ice     See lines 1010 - 1209  nrrain
+        table_val_qr2qi_collect(
+            0), // collection of rain mass by ice       See lines 1010 - 1209  qrrain
+        table_val_ni_lammax(0), // minimum ice number (lambda limiter)  See lines  704 -  705 nlarge
+        table_val_ni_lammin(0), // maximum ice number (lambda limiter)  See lines  704 -  705 nsmall
+        table_val_ice_reflectivity(
+            0), // reflectivity                         See lines  731 -  808  refl
+        table_val_qi2qr_vent_melt(
+            0), // melting (ventilation term)           See lines 1212 - 1279  vdep1
+        table_val_ice_mean_diam(
+            0), // mass-weighted mean diameter          See lines 1212 - 1279  dmm
+        table_val_ice_bulk_dens(
+            0), // mass-weighted mean particle density  See lines 1212 - 1279  rhomm
 
         // TODO(doc)
         vtrmi1(0),         // TODO(doc)
@@ -160,25 +181,28 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
         epsi(0),           // TODO(doc)
         epsr(0),           // TODO(doc)
         epsc(0),           // TODO(doc)
-        epsi_tot(0);       // inverse supersaturation relaxation timescale for combined ice categories
+        epsi_tot(0); // inverse supersaturation relaxation timescale for combined ice categories
 
     Smask wetgrowth(false);
 
-    // skip micro process calculations except nucleation/acvtivation if there no hydrometeors are present
-    const auto skip_micro     = skip_all || !(qc_incld(k) >= qsmall || qr_incld(k) >= qsmall || qi_incld(k) >= qsmall);
+    // skip micro process calculations except nucleation/acvtivation if there no hydrometeors are
+    // present
+    const auto skip_micro =
+        skip_all || !(qc_incld(k) >= qsmall || qr_incld(k) >= qsmall || qi_incld(k) >= qsmall);
     const auto not_skip_micro = !skip_micro;
 
     if (not_skip_micro.any()) {
       // time/space varying physical variables
-      get_time_space_phys_variables(T_atm(k), pres(k), rho(k), qv_sat_l(k), qv_sat_i(k), mu, dv, sc, dqsdt, dqsidt, ab,
-                                    abi, kap, eii, not_skip_micro);
+      get_time_space_phys_variables(T_atm(k), pres(k), rho(k), qv_sat_l(k), qv_sat_i(k), mu, dv, sc,
+                                    dqsdt, dqsidt, ab, abi, kap, eii, not_skip_micro);
 
-      get_cloud_dsd2(qc_incld(k), nc_incld(k), mu_c(k), rho(k), nu(k), dnu, lamc(k), cdist(k), cdist1(k),
-                     not_skip_micro);
+      get_cloud_dsd2(qc_incld(k), nc_incld(k), mu_c(k), rho(k), nu(k), dnu, lamc(k), cdist(k),
+                     cdist1(k), not_skip_micro);
       nc(k).set(not_skip_micro, nc_incld(k) * cld_frac_l(k));
 
       get_rain_dsd2(qr_incld(k), nr_incld(k), mu_r(k), lamr(k), runtime_options, not_skip_micro);
-      get_cdistr_logn0r(qr_incld(k), nr_incld(k), mu_r(k), lamr(k), cdistr(k), logn0r(k), not_skip_micro);
+      get_cdistr_logn0r(qr_incld(k), nr_incld(k), mu_r(k), lamr(k), cdistr(k), logn0r(k),
+                        not_skip_micro);
       nr(k).set(not_skip_micro, nr_incld(k) * cld_frac_r(k));
 
       impose_max_total_ni(ni_incld(k), max_total_ni, inv_rho(k), not_skip_micro);
@@ -190,7 +214,8 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
         ni_incld(k).set(qi_gt_small, max(ni_incld(k), nsmall));
         nr_incld(k).set(qi_gt_small, max(nr_incld(k), nsmall));
 
-        const auto rhop = calc_bulk_rho_rime(qi_incld(k), qm_incld(k), bm_incld(k), runtime_options, qi_gt_small);
+        const auto rhop =
+            calc_bulk_rho_rime(qi_incld(k), qm_incld(k), bm_incld(k), runtime_options, qi_gt_small);
         qm(k).set(qi_gt_small, qm_incld(k) * cld_frac_i(k));
         bm(k).set(qi_gt_small, bm_incld(k) * cld_frac_i(k));
 
@@ -201,20 +226,27 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
         lookup_rain(qr_incld(k), nr_incld(k), table_rain, qi_gt_small);
 
         // call to lookup table interpolation subroutines to get process rates
-        table_val_qi_fallspd.set(qi_gt_small, apply_table_ice(1, ice_table_vals, table_ice, qi_gt_small));
-        table_val_ni_self_collect.set(qi_gt_small, apply_table_ice(2, ice_table_vals, table_ice, qi_gt_small));
-        table_val_qc2qi_collect.set(qi_gt_small, apply_table_ice(3, ice_table_vals, table_ice, qi_gt_small));
-        table_val_qi2qr_melting.set(qi_gt_small, apply_table_ice(4, ice_table_vals, table_ice, qi_gt_small));
-        table_val_ni_lammax.set(qi_gt_small, apply_table_ice(6, ice_table_vals, table_ice, qi_gt_small));
-        table_val_ni_lammin.set(qi_gt_small, apply_table_ice(7, ice_table_vals, table_ice, qi_gt_small));
-        table_val_qi2qr_vent_melt.set(qi_gt_small, apply_table_ice(9, ice_table_vals, table_ice, qi_gt_small));
+        table_val_qi_fallspd.set(qi_gt_small,
+                                 apply_table_ice(1, ice_table_vals, table_ice, qi_gt_small));
+        table_val_ni_self_collect.set(qi_gt_small,
+                                      apply_table_ice(2, ice_table_vals, table_ice, qi_gt_small));
+        table_val_qc2qi_collect.set(qi_gt_small,
+                                    apply_table_ice(3, ice_table_vals, table_ice, qi_gt_small));
+        table_val_qi2qr_melting.set(qi_gt_small,
+                                    apply_table_ice(4, ice_table_vals, table_ice, qi_gt_small));
+        table_val_ni_lammax.set(qi_gt_small,
+                                apply_table_ice(6, ice_table_vals, table_ice, qi_gt_small));
+        table_val_ni_lammin.set(qi_gt_small,
+                                apply_table_ice(7, ice_table_vals, table_ice, qi_gt_small));
+        table_val_qi2qr_vent_melt.set(qi_gt_small,
+                                      apply_table_ice(9, ice_table_vals, table_ice, qi_gt_small));
 
         // ice-rain collection processes
         const auto qr_gt_small = qr_incld(k) >= qsmall && qi_gt_small;
-        table_val_nr_collect.set(qr_gt_small,
-                                 apply_table_coll(0, collect_table_vals, table_ice, table_rain, qi_gt_small));
-        table_val_qr2qi_collect.set(qr_gt_small,
-                                    apply_table_coll(1, collect_table_vals, table_ice, table_rain, qi_gt_small));
+        table_val_nr_collect.set(qr_gt_small, apply_table_coll(0, collect_table_vals, table_ice,
+                                                               table_rain, qi_gt_small));
+        table_val_qr2qi_collect.set(qr_gt_small, apply_table_coll(1, collect_table_vals, table_ice,
+                                                                  table_rain, qi_gt_small));
 
         // adjust Ni if needed to make sure mean size is in bounds (i.e. apply lambda limiters)
         // note that the Nmax and Nmin are normalized and thus need to be multiplied by existing N
@@ -232,64 +264,71 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
 
       if (do_ice_production) {
         // collection of droplets
-        ice_cldliq_collection(rho(k), T_atm(k), rhofaci(k), table_val_qc2qi_collect, qi_incld(k), qc_incld(k),
-                              ni_incld(k), nc_incld(k), qc2qi_collect_tend, nc_collect_tend, qc2qr_ice_shed_tend,
-                              ncshdc, runtime_options, not_skip_micro);
+        ice_cldliq_collection(rho(k), T_atm(k), rhofaci(k), table_val_qc2qi_collect, qi_incld(k),
+                              qc_incld(k), ni_incld(k), nc_incld(k), qc2qi_collect_tend,
+                              nc_collect_tend, qc2qr_ice_shed_tend, ncshdc, runtime_options,
+                              not_skip_micro);
 
         // collection of rain
-        ice_rain_collection(rho(k), T_atm(k), rhofaci(k), logn0r(k), table_val_nr_collect, table_val_qr2qi_collect,
-                            qi_incld(k), ni_incld(k), qr_incld(k), qr2qi_collect_tend, nr_collect_tend, runtime_options,
-                            not_skip_micro);
+        ice_rain_collection(rho(k), T_atm(k), rhofaci(k), logn0r(k), table_val_nr_collect,
+                            table_val_qr2qi_collect, qi_incld(k), ni_incld(k), qr_incld(k),
+                            qr2qi_collect_tend, nr_collect_tend, runtime_options, not_skip_micro);
 
         // collection between ice categories
 
         // PMC nCat deleted lots of stuff here.
 
         // self-collection of ice
-        ice_self_collection(rho(k), rhofaci(k), table_val_ni_self_collect, eii, qm_incld(k), qi_incld(k), ni_incld(k),
-                            ni_selfcollect_tend, not_skip_micro);
+        ice_self_collection(rho(k), rhofaci(k), table_val_ni_self_collect, eii, qm_incld(k),
+                            qi_incld(k), ni_incld(k), ni_selfcollect_tend, not_skip_micro);
       }
 
       // melting
-      ice_melting(rho(k), T_atm(k), pres(k), rhofaci(k), table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv, sc, mu,
-                  kap, qv(k), qi_incld(k), ni_incld(k), qi2qr_melt_tend, ni2nr_melt_tend, not_skip_micro);
+      ice_melting(rho(k), T_atm(k), pres(k), rhofaci(k), table_val_qi2qr_melting,
+                  table_val_qi2qr_vent_melt, dv, sc, mu, kap, qv(k), qi_incld(k), ni_incld(k),
+                  qi2qr_melt_tend, ni2nr_melt_tend, not_skip_micro);
 
       if (do_ice_production) {
         // calculate wet growth
-        ice_cldliq_wet_growth(rho(k), T_atm(k), pres(k), rhofaci(k), table_val_qi2qr_melting, table_val_qi2qr_vent_melt,
-                              dv, kap, mu, sc, qv(k), qc_incld(k), qi_incld(k), ni_incld(k), qr_incld(k), wetgrowth,
-                              qr2qi_collect_tend, qc2qi_collect_tend, qc_growth_rate, nr_ice_shed_tend,
+        ice_cldliq_wet_growth(rho(k), T_atm(k), pres(k), rhofaci(k), table_val_qi2qr_melting,
+                              table_val_qi2qr_vent_melt, dv, kap, mu, sc, qv(k), qc_incld(k),
+                              qi_incld(k), ni_incld(k), qr_incld(k), wetgrowth, qr2qi_collect_tend,
+                              qc2qi_collect_tend, qc_growth_rate, nr_ice_shed_tend,
                               qc2qr_ice_shed_tend, not_skip_micro);
       }
 
       // calculate total inverse ice relaxation timescale combined for all ice
       // categories note 'f1pr' values are normalized, so we need to multiply
       // by N
-      ice_relaxation_timescale(rho(k), T_atm(k), rhofaci(k), table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv, mu,
-                               sc, qi_incld(k), ni_incld(k), epsi, epsi_tot, not_skip_micro);
+      ice_relaxation_timescale(rho(k), T_atm(k), rhofaci(k), table_val_qi2qr_melting,
+                               table_val_qi2qr_vent_melt, dv, mu, sc, qi_incld(k), ni_incld(k),
+                               epsi, epsi_tot, not_skip_micro);
 
       // calculate rime density
-      calc_rime_density(T_atm(k), rhofaci(k), table_val_qi_fallspd, acn(k), lamc(k), mu_c(k), qc_incld(k),
-                        qc2qi_collect_tend, vtrmi1, rho_qm_cloud, not_skip_micro);
+      calc_rime_density(T_atm(k), rhofaci(k), table_val_qi_fallspd, acn(k), lamc(k), mu_c(k),
+                        qc_incld(k), qc2qi_collect_tend, vtrmi1, rho_qm_cloud, not_skip_micro);
 
       if (do_ice_production) {
         // contact and immersion freezing droplets
         if (use_hetfrz_classnuc) {
-          ice_classical_nucleation(hetfrz_immersion_nucleation_tend(k), hetfrz_contact_nucleation_tend(k),
-                                   hetfrz_deposition_nucleation_tend(k), rho(k), qc_incld(k), nc_incld(k), 1,
-                                   ncheti_cnt, qcheti_cnt, nicnt, qicnt, ninuc_cnt, qinuc_cnt);
-          ice_classical_nucleation(hetfrz_immersion_nucleation_tend(k), hetfrz_contact_nucleation_tend(k),
-                                   hetfrz_deposition_nucleation_tend(k), rho(k), qc_incld(k), nc_incld(k), 2,
-                                   ncheti_cnt, qcheti_cnt, nicnt, qicnt, ninuc_cnt, qinuc_cnt);
+          ice_classical_nucleation(
+              hetfrz_immersion_nucleation_tend(k), hetfrz_contact_nucleation_tend(k),
+              hetfrz_deposition_nucleation_tend(k), rho(k), qc_incld(k), nc_incld(k), 1, ncheti_cnt,
+              qcheti_cnt, nicnt, qicnt, ninuc_cnt, qinuc_cnt);
+          ice_classical_nucleation(
+              hetfrz_immersion_nucleation_tend(k), hetfrz_contact_nucleation_tend(k),
+              hetfrz_deposition_nucleation_tend(k), rho(k), qc_incld(k), nc_incld(k), 2, ncheti_cnt,
+              qcheti_cnt, nicnt, qicnt, ninuc_cnt, qinuc_cnt);
         } else {
-          cldliq_immersion_freezing(T_atm(k), lamc(k), mu_c(k), cdist1(k), qc_incld(k), inv_qc_relvar(k),
-                                    qc2qi_hetero_freeze_tend, nc2ni_immers_freeze_tend, runtime_options,
-                                    not_skip_micro);
+          cldliq_immersion_freezing(T_atm(k), lamc(k), mu_c(k), cdist1(k), qc_incld(k),
+                                    inv_qc_relvar(k), qc2qi_hetero_freeze_tend,
+                                    nc2ni_immers_freeze_tend, runtime_options, not_skip_micro);
         }
 
         // for future: get rid of log statements below for rain freezing
-        rain_immersion_freezing(T_atm(k), lamr(k), mu_r(k), cdistr(k), qr_incld(k), qr2qi_immers_freeze_tend,
-                                nr2ni_immers_freeze_tend, runtime_options, not_skip_micro);
+        rain_immersion_freezing(T_atm(k), lamr(k), mu_r(k), cdistr(k), qr_incld(k),
+                                qr2qi_immers_freeze_tend, nr2ni_immers_freeze_tend, runtime_options,
+                                not_skip_micro);
         //  rime splintering (Hallet-Mossop 1974)
         // PMC comment: Morrison and Milbrandt 2015 part 1 and 2016 part 3 both
         // say that Hallet-Mossop should be neglected if 1 category to
@@ -301,100 +340,114 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
       //    (use semi-analytic formulation)
 
       //  calculate rain evaporation including ventilation
-      calc_liq_relaxation_timescale(revap_table_vals, rho(k), f1r, f2r, dv, mu, sc, mu_r(k), lamr(k), cdistr(k),
-                                    cdist(k), qr_incld(k), qc_incld(k), epsr, epsc, not_skip_micro);
+      calc_liq_relaxation_timescale(revap_table_vals, rho(k), f1r, f2r, dv, mu, sc, mu_r(k),
+                                    lamr(k), cdistr(k), cdist(k), qr_incld(k), qc_incld(k), epsr,
+                                    epsc, not_skip_micro);
 
-      evaporate_rain(qr_incld(k), qc_incld(k), nr_incld(k), qi_incld(k), cld_frac_l(k), cld_frac_r(k), qv(k),
-                     qv_prev(k), qv_sat_l(k), qv_sat_i(k), ab, abi, epsr, epsi_tot, T_atm(k), t_prev(k), dqsdt, dt,
-                     qr2qv_evap_tend, nr_evap_tend, not_skip_micro);
+      evaporate_rain(qr_incld(k), qc_incld(k), nr_incld(k), qi_incld(k), cld_frac_l(k),
+                     cld_frac_r(k), qv(k), qv_prev(k), qv_sat_l(k), qv_sat_i(k), ab, abi, epsr,
+                     epsi_tot, T_atm(k), t_prev(k), dqsdt, dt, qr2qv_evap_tend, nr_evap_tend,
+                     not_skip_micro);
 
       if (do_ice_production) {
-        ice_deposition_sublimation(qi_incld(k), ni_incld(k), T_atm(k), qv_sat_l(k), qv_sat_i(k), epsi, abi, qv(k),
-                                   inv_dt, qv2qi_vapdep_tend, qi2qv_sublim_tend, ni_sublim_tend, qc2qi_berg_tend,
-                                   not_skip_micro);
+        ice_deposition_sublimation(qi_incld(k), ni_incld(k), T_atm(k), qv_sat_l(k), qv_sat_i(k),
+                                   epsi, abi, qv(k), inv_dt, qv2qi_vapdep_tend, qi2qv_sublim_tend,
+                                   ni_sublim_tend, qc2qi_berg_tend, not_skip_micro);
       }
     }
 
     // deposition/condensation-freezing nucleation
     if (do_ice_production) {
-      ice_nucleation(T_atm(k), inv_rho(k), ni(k), ni_activated(k), qv_supersat_i(k), inv_dt, predictNc,
-                     do_prescribed_CCN, qv2qi_nucleat_tend, ni_nucleat_tend, runtime_options, not_skip_all);
+      ice_nucleation(T_atm(k), inv_rho(k), ni(k), ni_activated(k), qv_supersat_i(k), inv_dt,
+                     predictNc, do_prescribed_CCN, qv2qi_nucleat_tend, ni_nucleat_tend,
+                     runtime_options, not_skip_all);
     }
 
     // cloud water autoconversion
     // NOTE: cloud_water_autoconversion must be called before droplet_self_collection
-    cloud_water_autoconversion(rho(k), qc_incld(k), nc_incld(k), inv_qc_relvar(k), qc2qr_autoconv_tend,
-                               nc2nr_autoconv_tend, ncautr, runtime_options, not_skip_all);
+    cloud_water_autoconversion(rho(k), qc_incld(k), nc_incld(k), inv_qc_relvar(k),
+                               qc2qr_autoconv_tend, nc2nr_autoconv_tend, ncautr, runtime_options,
+                               not_skip_all);
 
     // self-collection of droplets
-    droplet_self_collection(rho(k), inv_rho(k), qc_incld(k), mu_c(k), nu(k), nc2nr_autoconv_tend, nc_selfcollect_tend,
-                            not_skip_all);
+    droplet_self_collection(rho(k), inv_rho(k), qc_incld(k), mu_c(k), nu(k), nc2nr_autoconv_tend,
+                            nc_selfcollect_tend, not_skip_all);
 
     // accretion of cloud by rain
-    cloud_rain_accretion(rho(k), inv_rho(k), qc_incld(k), nc_incld(k), qr_incld(k), inv_qc_relvar(k), qc2qr_accret_tend,
-                         nc_accret_tend, runtime_options, not_skip_all);
+    cloud_rain_accretion(rho(k), inv_rho(k), qc_incld(k), nc_incld(k), qr_incld(k),
+                         inv_qc_relvar(k), qc2qr_accret_tend, nc_accret_tend, runtime_options,
+                         not_skip_all);
 
     // self-collection and breakup of rain
     // (breakup following modified Verlinde and Cotton scheme)
-    rain_self_collection(rho(k), qr_incld(k), nr_incld(k), nr_selfcollect_tend, runtime_options, not_skip_all);
+    rain_self_collection(rho(k), qr_incld(k), nr_incld(k), nr_selfcollect_tend, runtime_options,
+                         not_skip_all);
 
     // Here we map the microphysics tendency rates back to CELL-AVERAGE quantities for updating
     // cell-average quantities.
-    back_to_cell_average(cld_frac_l(k), cld_frac_r(k), cld_frac_i(k), qc2qr_accret_tend, qr2qv_evap_tend,
-                         qc2qr_autoconv_tend, nc_accret_tend, nc_selfcollect_tend, nc2nr_autoconv_tend,
-                         nr_selfcollect_tend, nr_evap_tend, ncautr, qi2qv_sublim_tend, nr_ice_shed_tend,
-                         qc2qi_hetero_freeze_tend, qr2qi_collect_tend, qc2qr_ice_shed_tend, qi2qr_melt_tend,
-                         qc2qi_collect_tend, qr2qi_immers_freeze_tend, ni2nr_melt_tend, nc_collect_tend, ncshdc,
-                         nc2ni_immers_freeze_tend, nr_collect_tend, ni_selfcollect_tend, qv2qi_vapdep_tend,
-                         nr2ni_immers_freeze_tend, ni_sublim_tend, qv2qi_nucleat_tend, ni_nucleat_tend, qc2qi_berg_tend,
-                         ncheti_cnt, qcheti_cnt, nicnt, qicnt, ninuc_cnt, qinuc_cnt, not_skip_all, runtime_options);
+    back_to_cell_average(
+        cld_frac_l(k), cld_frac_r(k), cld_frac_i(k), qc2qr_accret_tend, qr2qv_evap_tend,
+        qc2qr_autoconv_tend, nc_accret_tend, nc_selfcollect_tend, nc2nr_autoconv_tend,
+        nr_selfcollect_tend, nr_evap_tend, ncautr, qi2qv_sublim_tend, nr_ice_shed_tend,
+        qc2qi_hetero_freeze_tend, qr2qi_collect_tend, qc2qr_ice_shed_tend, qi2qr_melt_tend,
+        qc2qi_collect_tend, qr2qi_immers_freeze_tend, ni2nr_melt_tend, nc_collect_tend, ncshdc,
+        nc2ni_immers_freeze_tend, nr_collect_tend, ni_selfcollect_tend, qv2qi_vapdep_tend,
+        nr2ni_immers_freeze_tend, ni_sublim_tend, qv2qi_nucleat_tend, ni_nucleat_tend,
+        qc2qi_berg_tend, ncheti_cnt, qcheti_cnt, nicnt, qicnt, ninuc_cnt, qinuc_cnt, not_skip_all,
+        runtime_options);
 
     //
     // conservation of water
     //
 
-    // don't bother checking vapor since all sinks already have limits imposed and the sum, therefore,
-    // cannot possibly overdeplete qv [PMC: the above argument makes no sense to me. I think we don't
-    // check qv because it is typically much greater than zero so seldom goes negative (and if it does
-    // catastrophic failure is appropriate)]
+    // don't bother checking vapor since all sinks already have limits imposed and the sum,
+    // therefore, cannot possibly overdeplete qv [PMC: the above argument makes no sense to me. I
+    // think we don't check qv because it is typically much greater than zero so seldom goes
+    // negative (and if it does catastrophic failure is appropriate)]
 
     if (use_separate_ice_liq_frac) {
       // cloud
-      cloud_water_conservation(qc(k), dt, qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend,
-                               qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend, qc2qi_berg_tend, qi2qv_sublim_tend,
-                               qv2qi_vapdep_tend, qcheti_cnt, qicnt, use_hetfrz_classnuc, not_skip_all, cld_frac_l(k),
+      cloud_water_conservation(qc(k), dt, qc2qr_autoconv_tend, qc2qr_accret_tend,
+                               qc2qi_collect_tend, qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend,
+                               qc2qi_berg_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qcheti_cnt,
+                               qicnt, use_hetfrz_classnuc, not_skip_all, cld_frac_l(k),
                                cld_frac_i(k), runtime_options);
     } else {
       // cloud
-      cloud_water_conservation(qc(k), dt, qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend,
-                               qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend, qc2qi_berg_tend, qi2qv_sublim_tend,
-                               qv2qi_vapdep_tend, qcheti_cnt, qicnt, use_hetfrz_classnuc, not_skip_all);
+      cloud_water_conservation(qc(k), dt, qc2qr_autoconv_tend, qc2qr_accret_tend,
+                               qc2qi_collect_tend, qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend,
+                               qc2qi_berg_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qcheti_cnt,
+                               qicnt, use_hetfrz_classnuc, not_skip_all);
     }
 
     // rain
-    rain_water_conservation(qr(k), qc2qr_autoconv_tend, qc2qr_accret_tend, qi2qr_melt_tend, qc2qr_ice_shed_tend, dt,
-                            qr2qv_evap_tend, qr2qi_collect_tend, qr2qi_immers_freeze_tend, not_skip_all);
+    rain_water_conservation(qr(k), qc2qr_autoconv_tend, qc2qr_accret_tend, qi2qr_melt_tend,
+                            qc2qr_ice_shed_tend, dt, qr2qv_evap_tend, qr2qi_collect_tend,
+                            qr2qi_immers_freeze_tend, not_skip_all);
 
     // ice
-    ice_water_conservation(qi(k), qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend, qr2qi_collect_tend,
-                           qc2qi_collect_tend, qr2qi_immers_freeze_tend, qc2qi_hetero_freeze_tend, dt, qinuc_cnt,
-                           qcheti_cnt, qicnt, qi2qv_sublim_tend, qi2qr_melt_tend, use_hetfrz_classnuc, not_skip_all);
+    ice_water_conservation(qi(k), qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend,
+                           qr2qi_collect_tend, qc2qi_collect_tend, qr2qi_immers_freeze_tend,
+                           qc2qi_hetero_freeze_tend, dt, qinuc_cnt, qcheti_cnt, qicnt,
+                           qi2qv_sublim_tend, qi2qr_melt_tend, use_hetfrz_classnuc, not_skip_all);
 
-    nc_conservation(nc(k), nc_selfcollect_tend, dt, nc_collect_tend, nc2ni_immers_freeze_tend, nc_accret_tend,
-                    nc2nr_autoconv_tend, ncheti_cnt, nicnt, use_hetfrz_classnuc, not_skip_all);
-    nr_conservation(nr(k), ni2nr_melt_tend, nr_ice_shed_tend, ncshdc, nc2nr_autoconv_tend, dt, nmltratio,
-                    nr_collect_tend, nr2ni_immers_freeze_tend, nr_selfcollect_tend, nr_evap_tend, not_skip_all);
-    ni_conservation(ni(k), ni_nucleat_tend, nr2ni_immers_freeze_tend, nc2ni_immers_freeze_tend, ncheti_cnt, nicnt,
-                    ninuc_cnt, dt, ni2nr_melt_tend, ni_sublim_tend, ni_selfcollect_tend, use_hetfrz_classnuc,
+    nc_conservation(nc(k), nc_selfcollect_tend, dt, nc_collect_tend, nc2ni_immers_freeze_tend,
+                    nc_accret_tend, nc2nr_autoconv_tend, ncheti_cnt, nicnt, use_hetfrz_classnuc,
                     not_skip_all);
+    nr_conservation(nr(k), ni2nr_melt_tend, nr_ice_shed_tend, ncshdc, nc2nr_autoconv_tend, dt,
+                    nmltratio, nr_collect_tend, nr2ni_immers_freeze_tend, nr_selfcollect_tend,
+                    nr_evap_tend, not_skip_all);
+    ni_conservation(ni(k), ni_nucleat_tend, nr2ni_immers_freeze_tend, nc2ni_immers_freeze_tend,
+                    ncheti_cnt, nicnt, ninuc_cnt, dt, ni2nr_melt_tend, ni_sublim_tend,
+                    ni_selfcollect_tend, use_hetfrz_classnuc, not_skip_all);
 
     // make sure procs don't inappropriately push qv beyond ice saturation
-    ice_supersat_conservation(qv2qi_vapdep_tend, qv2qi_nucleat_tend, qinuc_cnt, cld_frac_i(k), qv(k), qv_sat_i(k),
-                              th_atm(k) / inv_exner(k), dt, qi2qv_sublim_tend, qr2qv_evap_tend, use_hetfrz_classnuc,
-                              not_skip_all);
+    ice_supersat_conservation(qv2qi_vapdep_tend, qv2qi_nucleat_tend, qinuc_cnt, cld_frac_i(k),
+                              qv(k), qv_sat_i(k), th_atm(k) / inv_exner(k), dt, qi2qv_sublim_tend,
+                              qr2qv_evap_tend, use_hetfrz_classnuc, not_skip_all);
     // make sure procs don't inappropriately push qv beyond liquid saturation
-    prevent_liq_supersaturation(pres(k), T_atm(k), qv(k), dt, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qi2qv_sublim_tend,
-                                qr2qv_evap_tend, not_skip_all);
+    prevent_liq_supersaturation(pres(k), T_atm(k), qv(k), dt, qv2qi_vapdep_tend, qv2qi_nucleat_tend,
+                                qi2qv_sublim_tend, qr2qv_evap_tend, not_skip_all);
 
     //---------------------------------------------------------------------------------
     // update prognostic microphysics and thermodynamics variables
@@ -402,33 +455,40 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
 
     //-- ice-phase dependent processes:
     update_prognostic_ice(
-        qc2qi_hetero_freeze_tend, qc2qi_collect_tend, qc2qr_ice_shed_tend, nc_collect_tend, nc2ni_immers_freeze_tend,
-        ncshdc, qr2qi_collect_tend, nr_collect_tend, qr2qi_immers_freeze_tend, nr2ni_immers_freeze_tend,
-        nr_ice_shed_tend, qi2qr_melt_tend, ni2nr_melt_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qv2qi_nucleat_tend,
-        ni_nucleat_tend, ni_selfcollect_tend, ni_sublim_tend, qc2qi_berg_tend, inv_exner(k), predictNc, wetgrowth, dt,
-        nmltratio, rho_qm_cloud, ncheti_cnt, nicnt, ninuc_cnt, qcheti_cnt, qicnt, qinuc_cnt, th_atm(k), qv(k), qi(k),
-        ni(k), qm(k), bm(k), qc(k), nc(k), qr(k), nr(k), use_hetfrz_classnuc, not_skip_all);
+        qc2qi_hetero_freeze_tend, qc2qi_collect_tend, qc2qr_ice_shed_tend, nc_collect_tend,
+        nc2ni_immers_freeze_tend, ncshdc, qr2qi_collect_tend, nr_collect_tend,
+        qr2qi_immers_freeze_tend, nr2ni_immers_freeze_tend, nr_ice_shed_tend, qi2qr_melt_tend,
+        ni2nr_melt_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qv2qi_nucleat_tend, ni_nucleat_tend,
+        ni_selfcollect_tend, ni_sublim_tend, qc2qi_berg_tend, inv_exner(k), predictNc, wetgrowth,
+        dt, nmltratio, rho_qm_cloud, ncheti_cnt, nicnt, ninuc_cnt, qcheti_cnt, qicnt, qinuc_cnt,
+        th_atm(k), qv(k), qi(k), ni(k), qm(k), bm(k), qc(k), nc(k), qr(k), nr(k),
+        use_hetfrz_classnuc, not_skip_all);
 
     //-- warm-phase only processes:
-    update_prognostic_liquid(qc2qr_accret_tend, nc_accret_tend, qc2qr_autoconv_tend, nc2nr_autoconv_tend, ncautr,
-                             nc_selfcollect_tend, qr2qv_evap_tend, nr_evap_tend, nr_selfcollect_tend, predictNc,
-                             do_prescribed_CCN, inv_rho(k), inv_exner(k), dt, th_atm(k), qv(k), qc(k), nc(k), qr(k),
+    update_prognostic_liquid(qc2qr_accret_tend, nc_accret_tend, qc2qr_autoconv_tend,
+                             nc2nr_autoconv_tend, ncautr, nc_selfcollect_tend, qr2qv_evap_tend,
+                             nr_evap_tend, nr_selfcollect_tend, predictNc, do_prescribed_CCN,
+                             inv_rho(k), inv_exner(k), dt, th_atm(k), qv(k), qc(k), nc(k), qr(k),
                              nr(k), not_skip_all);
 
     // AaronDonahue - Add extra variables needed from microphysics by E3SM:
     if (use_hetfrz_classnuc) {
-      qv2qi_depos_tend(k).set(not_skip_all, qv2qi_vapdep_tend - qi2qv_sublim_tend + qv2qi_nucleat_tend + qinuc_cnt);
+      qv2qi_depos_tend(k).set(not_skip_all, qv2qi_vapdep_tend - qi2qv_sublim_tend +
+                                                qv2qi_nucleat_tend + qinuc_cnt);
     } else {
-      qv2qi_depos_tend(k).set(not_skip_all, qv2qi_vapdep_tend - qi2qv_sublim_tend + qv2qi_nucleat_tend);
+      qv2qi_depos_tend(k).set(not_skip_all,
+                              qv2qi_vapdep_tend - qi2qv_sublim_tend + qv2qi_nucleat_tend);
     }
-    precip_total_tend(k).set(not_skip_all,
-                             qc2qr_accret_tend + qc2qr_autoconv_tend + qc2qr_ice_shed_tend + qc2qi_collect_tend);
+    precip_total_tend(k).set(not_skip_all, qc2qr_accret_tend + qc2qr_autoconv_tend +
+                                               qc2qr_ice_shed_tend + qc2qi_collect_tend);
     nevapr(k).set(not_skip_all, qi2qv_sublim_tend + qr2qv_evap_tend);
     qr_evap_tend(k).set(not_skip_all, qr2qv_evap_tend);
-    vap_ice_exchange(k).set(not_skip_all, qv2qi_vapdep_tend - qi2qv_sublim_tend + qv2qi_nucleat_tend);
+    vap_ice_exchange(k).set(not_skip_all,
+                            qv2qi_vapdep_tend - qi2qv_sublim_tend + qv2qi_nucleat_tend);
     vap_liq_exchange(k).set(not_skip_all, -qr2qv_evap_tend);
-    liq_ice_exchange(k).set(not_skip_all, qc2qi_hetero_freeze_tend + qr2qi_immers_freeze_tend - qi2qr_melt_tend +
-                                              qc2qi_berg_tend + qc2qi_collect_tend + qr2qi_collect_tend);
+    liq_ice_exchange(k).set(not_skip_all, qc2qi_hetero_freeze_tend + qr2qi_immers_freeze_tend -
+                                              qi2qr_melt_tend + qc2qi_berg_tend +
+                                              qc2qi_collect_tend + qr2qi_collect_tend);
 
     // set tendencies if extra_p3_diags is true
     if (extra_p3_diags) {
@@ -489,15 +549,17 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part2(
     prctot(k).set(not_skip_all, qc2qr_autoconv_tend); // cloud drop autoconversion to rain
 
     // impose_max_total_ni is meant to operate on in-cloud vals. ni_incld is an output of
-    // calculate_incloud_mixingratios below but we need to generate it earlier for impose_max_total_ni
+    // calculate_incloud_mixingratios below but we need to generate it earlier for
+    // impose_max_total_ni
     ni_incld(k).set(not_skip_all, ni(k) / cld_frac_i(k));
     impose_max_total_ni(ni_incld(k), max_total_ni, inv_rho(k), not_skip_all);
     ni(k).set(not_skip_all, ni_incld(k) * cld_frac_i(k));
 
     // Recalculate in-cloud values for sedimentation
-    calculate_incloud_mixingratios(qc(k), qr(k), qi(k), qm(k), nc(k), nr(k), ni(k), bm(k), inv_cld_frac_l(k),
-                                   inv_cld_frac_i(k), inv_cld_frac_r(k), qc_incld(k), qr_incld(k), qi_incld(k),
-                                   qm_incld(k), nc_incld(k), nr_incld(k), ni_incld(k), bm_incld(k), not_skip_all);
+    calculate_incloud_mixingratios(qc(k), qr(k), qi(k), qm(k), nc(k), nr(k), ni(k), bm(k),
+                                   inv_cld_frac_l(k), inv_cld_frac_i(k), inv_cld_frac_r(k),
+                                   qc_incld(k), qr_incld(k), qi_incld(k), qm_incld(k), nc_incld(k),
+                                   nr_incld(k), ni_incld(k), bm_incld(k), not_skip_all);
   });
   team.team_barrier();
 }
diff --git i/components/eamxx/src/physics/p3/impl/p3_main_impl_part3.hpp w/components/eamxx/src/physics/p3/impl/p3_main_impl_part3.hpp
index e6c40a9cc3..55393a78f4 100644
--- i/components/eamxx/src/physics/p3/impl/p3_main_impl_part3.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_main_impl_part3.hpp
@@ -17,16 +17,19 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::p3_main_part3(
-    const MemberType &team, const Int &nk_pack, const Scalar &max_total_ni, const view_dnu_table &dnu,
-    const view_ice_table &ice_table_vals, const uview_1d<const Spack> &inv_exner,
-    const uview_1d<const Spack> &cld_frac_l, const uview_1d<const Spack> &cld_frac_r,
-    const uview_1d<const Spack> &cld_frac_i, const uview_1d<Spack> &rho, const uview_1d<Spack> &inv_rho,
-    const uview_1d<Spack> &rhofaci, const uview_1d<Spack> &qv, const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc,
-    const uview_1d<Spack> &nc, const uview_1d<Spack> &qr, const uview_1d<Spack> &nr, const uview_1d<Spack> &qi,
-    const uview_1d<Spack> &ni, const uview_1d<Spack> &qm, const uview_1d<Spack> &bm, const uview_1d<Spack> &mu_c,
-    const uview_1d<Spack> &nu, const uview_1d<Spack> &lamc, const uview_1d<Spack> &mu_r, const uview_1d<Spack> &lamr,
-    const uview_1d<Spack> &vap_liq_exchange, const uview_1d<Spack> &ze_rain, const uview_1d<Spack> &ze_ice,
-    const uview_1d<Spack> &diag_vm_qi, const uview_1d<Spack> &diag_eff_radius_qi, const uview_1d<Spack> &diag_diam_qi,
+    const MemberType &team, const Int &nk_pack, const Scalar &max_total_ni,
+    const view_dnu_table &dnu, const view_ice_table &ice_table_vals,
+    const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &cld_frac_l,
+    const uview_1d<const Spack> &cld_frac_r, const uview_1d<const Spack> &cld_frac_i,
+    const uview_1d<Spack> &rho, const uview_1d<Spack> &inv_rho, const uview_1d<Spack> &rhofaci,
+    const uview_1d<Spack> &qv, const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc,
+    const uview_1d<Spack> &nc, const uview_1d<Spack> &qr, const uview_1d<Spack> &nr,
+    const uview_1d<Spack> &qi, const uview_1d<Spack> &ni, const uview_1d<Spack> &qm,
+    const uview_1d<Spack> &bm, const uview_1d<Spack> &mu_c, const uview_1d<Spack> &nu,
+    const uview_1d<Spack> &lamc, const uview_1d<Spack> &mu_r, const uview_1d<Spack> &lamr,
+    const uview_1d<Spack> &vap_liq_exchange, const uview_1d<Spack> &ze_rain,
+    const uview_1d<Spack> &ze_ice, const uview_1d<Spack> &diag_vm_qi,
+    const uview_1d<Spack> &diag_eff_radius_qi, const uview_1d<Spack> &diag_diam_qi,
     const uview_1d<Spack> &rho_qi, const uview_1d<Spack> &diag_equiv_reflectivity,
     const uview_1d<Spack> &diag_eff_radius_qc, const uview_1d<Spack> &diag_eff_radius_qr,
     const P3Runtime &runtime_options) {
@@ -37,8 +40,9 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part3(
   constexpr Scalar latice = C::LatIce;
 
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nk_pack), [&](Int k) {
-    Spack ignore1(0), ignore2(0), table_val_qi_fallspd(0), table_val_ice_eff_radius(0), table_val_ni_lammax(0),
-        table_val_ni_lammin(0), table_val_ice_reflectivity(0), table_val_ice_mean_diam(0), table_val_ice_bulk_dens(0);
+    Spack ignore1(0), ignore2(0), table_val_qi_fallspd(0), table_val_ice_eff_radius(0),
+        table_val_ni_lammax(0), table_val_ni_lammin(0), table_val_ice_reflectivity(0),
+        table_val_ice_mean_diam(0), table_val_ice_bulk_dens(0);
 
     // Cloud
     {
@@ -47,10 +51,13 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part3(
       const auto qc_incld    = qc(k) / cld_frac_l(k);
       auto nc_incld          = nc(k) / cld_frac_l(k);
 
-      get_cloud_dsd2(qc_incld, nc_incld, mu_c(k), rho(k), nu(k), dnu, lamc(k), ignore1, ignore2, qc_gt_small);
+      get_cloud_dsd2(qc_incld, nc_incld, mu_c(k), rho(k), nu(k), dnu, lamc(k), ignore1, ignore2,
+                     qc_gt_small);
 
       if (qc_gt_small.any()) {
-        nc(k).set(qc_gt_small, nc_incld * cld_frac_l(k)); // cld_dsd2 might have changed incld nc... need consistency.
+        nc(k).set(qc_gt_small,
+                  nc_incld *
+                      cld_frac_l(k)); // cld_dsd2 might have changed incld nc... need consistency.
         diag_eff_radius_qc(k).set(qc_gt_small, sp(0.5) * (mu_c(k) + 3) / lamc(k));
       }
       if (qc_small.any()) {
@@ -67,17 +74,21 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part3(
       const auto qr_gt_small = qr(k) >= qsmall;
       const auto qr_small    = !qr_gt_small;
       const auto qr_incld    = qr(k) / cld_frac_r(k);
-      auto nr_incld          = nr(k) / cld_frac_r(k); // nr_incld is updated in get_rain_dsd2 but isn't used again
+      auto nr_incld =
+          nr(k) / cld_frac_r(k); // nr_incld is updated in get_rain_dsd2 but isn't used again
 
       get_rain_dsd2(qr_incld, nr_incld, mu_r(k), lamr(k), runtime_options, qr_gt_small);
 
       // Note that integrating over the drop-size PDF as done here should only be done to in-cloud
-      // quantities but radar reflectivity is likely meant to be a cell ave. Thus nr in the next line
-      // really should be cld_frac_r * nr/cld_frac_r. Not doing that since cld_frac_r cancels out.
+      // quantities but radar reflectivity is likely meant to be a cell ave. Thus nr in the next
+      // line really should be cld_frac_r * nr/cld_frac_r. Not doing that since cld_frac_r cancels
+      // out.
       if (qr_gt_small.any()) {
-        nr(k).set(qr_gt_small, nr_incld * cld_frac_r(k)); // rain_dsd2 might have changed incld nr... need consistency.
-        ze_rain(k).set(qr_gt_small, nr(k) * (mu_r(k) + 6) * (mu_r(k) + 5) * (mu_r(k) + 4) * (mu_r(k) + 3) *
-                                        (mu_r(k) + 2) * (mu_r(k) + 1) /
+        nr(k).set(qr_gt_small,
+                  nr_incld *
+                      cld_frac_r(k)); // rain_dsd2 might have changed incld nr... need consistency.
+        ze_rain(k).set(qr_gt_small, nr(k) * (mu_r(k) + 6) * (mu_r(k) + 5) * (mu_r(k) + 4) *
+                                        (mu_r(k) + 3) * (mu_r(k) + 2) * (mu_r(k) + 1) /
                                         pow(lamr(k), sp(6.0))); // once f90 is gone, 6 can be int
         ze_rain(k).set(qr_gt_small, max(ze_rain(k), sp(1.e-22)));
         diag_eff_radius_qr(k).set(qr_gt_small, sp(1.5) / lamr(k));
@@ -105,7 +116,8 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part3(
       auto qm_incld = qm(k) / cld_frac_i(k);
       auto bm_incld = bm(k) / cld_frac_i(k);
 
-      const auto rhop = calc_bulk_rho_rime(qi_incld, qm_incld, bm_incld, runtime_options, qi_gt_small);
+      const auto rhop =
+          calc_bulk_rho_rime(qi_incld, qm_incld, bm_incld, runtime_options, qi_gt_small);
       qm(k).set(qi_gt_small, qm_incld * cld_frac_i(k));
       bm(k).set(qi_gt_small, bm_incld * cld_frac_i(k));
 
@@ -114,13 +126,20 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part3(
       TableIce table_ice;
       lookup_ice(qi_incld, ni_incld, qm_incld, rhop, table_ice, qi_gt_small);
 
-      table_val_qi_fallspd.set(qi_gt_small, apply_table_ice(1, ice_table_vals, table_ice, qi_gt_small));
-      table_val_ice_eff_radius.set(qi_gt_small, apply_table_ice(5, ice_table_vals, table_ice, qi_gt_small));
-      table_val_ni_lammax.set(qi_gt_small, apply_table_ice(6, ice_table_vals, table_ice, qi_gt_small));
-      table_val_ni_lammin.set(qi_gt_small, apply_table_ice(7, ice_table_vals, table_ice, qi_gt_small));
-      table_val_ice_reflectivity.set(qi_gt_small, apply_table_ice(8, ice_table_vals, table_ice, qi_gt_small));
-      table_val_ice_mean_diam.set(qi_gt_small, apply_table_ice(10, ice_table_vals, table_ice, qi_gt_small));
-      table_val_ice_bulk_dens.set(qi_gt_small, apply_table_ice(11, ice_table_vals, table_ice, qi_gt_small));
+      table_val_qi_fallspd.set(qi_gt_small,
+                               apply_table_ice(1, ice_table_vals, table_ice, qi_gt_small));
+      table_val_ice_eff_radius.set(qi_gt_small,
+                                   apply_table_ice(5, ice_table_vals, table_ice, qi_gt_small));
+      table_val_ni_lammax.set(qi_gt_small,
+                              apply_table_ice(6, ice_table_vals, table_ice, qi_gt_small));
+      table_val_ni_lammin.set(qi_gt_small,
+                              apply_table_ice(7, ice_table_vals, table_ice, qi_gt_small));
+      table_val_ice_reflectivity.set(qi_gt_small,
+                                     apply_table_ice(8, ice_table_vals, table_ice, qi_gt_small));
+      table_val_ice_mean_diam.set(qi_gt_small,
+                                  apply_table_ice(10, ice_table_vals, table_ice, qi_gt_small));
+      table_val_ice_bulk_dens.set(qi_gt_small,
+                                  apply_table_ice(11, ice_table_vals, table_ice, qi_gt_small));
 
       // impose mean ice size bounds (i.e. apply lambda limiters)
       // note that the Nmax and Nmin are normalized and thus need to be multiplied by existing N
@@ -140,9 +159,11 @@ KOKKOS_FUNCTION void Functions<S, D>::p3_main_part3(
       rho_qi(k).set(qi_gt_small, table_val_ice_bulk_dens);
 
       // note factor of air density below is to convert from m^6/kg to m^6/m^3
-      ze_ice(k).set(qi_gt_small,
-                    ze_ice(k) + sp(0.1892) * table_val_ice_reflectivity * ni_incld *
-                                    rho(k)); // sum contribution from each ice category (note: 0.1892 = 0.176/0.93);
+      ze_ice(k).set(
+          qi_gt_small,
+          ze_ice(k) +
+              sp(0.1892) * table_val_ice_reflectivity * ni_incld *
+                  rho(k)); // sum contribution from each ice category (note: 0.1892 = 0.176/0.93);
       ze_ice(k).set(qi_gt_small, max(ze_ice(k), sp(1.e-22)));
 
       // above formula for ze only makes sense for in-cloud vals, but users expect cell-ave output.
diff --git i/components/eamxx/src/physics/p3/impl/p3_nc_conservation_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_nc_conservation_impl.hpp
index 7679d856bb..df5acb831a 100644
--- i/components/eamxx/src/physics/p3/impl/p3_nc_conservation_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_nc_conservation_impl.hpp
@@ -12,16 +12,16 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::nc_conservation(const Spack &nc, const Spack &nc_selfcollect_tend, const Real &dt,
-                                                      Spack &nc_collect_tend, Spack &nc2ni_immers_freeze_tend,
-                                                      Spack &nc_accret_tend, Spack &nc2nr_autoconv_tend,
-                                                      Spack &ncheti_cnt, Spack &nicnt, const bool &use_hetfrz_classnuc,
-                                                      const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::nc_conservation(
+    const Spack &nc, const Spack &nc_selfcollect_tend, const Real &dt, Spack &nc_collect_tend,
+    Spack &nc2ni_immers_freeze_tend, Spack &nc_accret_tend, Spack &nc2nr_autoconv_tend,
+    Spack &ncheti_cnt, Spack &nicnt, const bool &use_hetfrz_classnuc, const Smask &context) {
   Spack sink_nc;
   if (use_hetfrz_classnuc) {
     sink_nc = (nc_collect_tend + ncheti_cnt + nc_accret_tend + nc2nr_autoconv_tend + nicnt) * dt;
   } else {
-    sink_nc = (nc_collect_tend + nc2ni_immers_freeze_tend + nc_accret_tend + nc2nr_autoconv_tend) * dt;
+    sink_nc =
+        (nc_collect_tend + nc2ni_immers_freeze_tend + nc_accret_tend + nc2nr_autoconv_tend) * dt;
   }
   const auto source_nc = nc + nc_selfcollect_tend * dt;
   const auto mask      = sink_nc > source_nc && context;
diff --git i/components/eamxx/src/physics/p3/impl/p3_ni_conservation_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_ni_conservation_impl.hpp
index 0c84f156b1..aaf2469b33 100644
--- i/components/eamxx/src/physics/p3/impl/p3_ni_conservation_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_ni_conservation_impl.hpp
@@ -12,16 +12,17 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::ni_conservation(const Spack &ni, const Spack &ni_nucleat_tend, const Spack &nr2ni_immers_freeze_tend,
-                                 const Spack &nc2ni_immers_freeze_tend, const Spack &ncheti_cnt, const Spack &nicnt,
-                                 const Spack &ninuc_cnt, const Real &dt, Spack &ni2nr_melt_tend, Spack &ni_sublim_tend,
-                                 Spack &ni_selfcollect_tend, const bool &use_hetfrz_classnuc, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::ni_conservation(
+    const Spack &ni, const Spack &ni_nucleat_tend, const Spack &nr2ni_immers_freeze_tend,
+    const Spack &nc2ni_immers_freeze_tend, const Spack &ncheti_cnt, const Spack &nicnt,
+    const Spack &ninuc_cnt, const Real &dt, Spack &ni2nr_melt_tend, Spack &ni_sublim_tend,
+    Spack &ni_selfcollect_tend, const bool &use_hetfrz_classnuc, const Smask &context) {
   const auto sink_ni = (ni2nr_melt_tend + ni_sublim_tend + ni_selfcollect_tend) * dt;
 
   Spack source_ni;
   if (use_hetfrz_classnuc) {
-    source_ni = ni + (ni_nucleat_tend + nr2ni_immers_freeze_tend + ncheti_cnt + nicnt + ninuc_cnt) * dt;
+    source_ni =
+        ni + (ni_nucleat_tend + nr2ni_immers_freeze_tend + ncheti_cnt + nicnt + ninuc_cnt) * dt;
   } else {
     source_ni = ni + (ni_nucleat_tend + nr2ni_immers_freeze_tend + nc2ni_immers_freeze_tend) * dt;
   }
diff --git i/components/eamxx/src/physics/p3/impl/p3_nr_conservation_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_nr_conservation_impl.hpp
index ce2f7d85ce..94a3710758 100644
--- i/components/eamxx/src/physics/p3/impl/p3_nr_conservation_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_nr_conservation_impl.hpp
@@ -12,14 +12,16 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::nr_conservation(const Spack &nr, const Spack &ni2nr_melt_tend, const Spack &nr_ice_shed_tend,
-                                 const Spack &ncshdc, const Spack &nc2nr_autoconv_tend, const Real &dt,
-                                 const Real &nmltratio, Spack &nr_collect_tend, Spack &nr2ni_immers_freeze_tend,
-                                 Spack &nr_selfcollect_tend, Spack &nr_evap_tend, const Smask &context) {
-  const auto sink_nr   = (nr_collect_tend + nr2ni_immers_freeze_tend + nr_selfcollect_tend + nr_evap_tend) * dt;
-  const auto source_nr = nr + (ni2nr_melt_tend * nmltratio + nr_ice_shed_tend + ncshdc + nc2nr_autoconv_tend) * dt;
-  const auto mask      = sink_nr > source_nr && context;
+KOKKOS_FUNCTION void Functions<S, D>::nr_conservation(
+    const Spack &nr, const Spack &ni2nr_melt_tend, const Spack &nr_ice_shed_tend,
+    const Spack &ncshdc, const Spack &nc2nr_autoconv_tend, const Real &dt, const Real &nmltratio,
+    Spack &nr_collect_tend, Spack &nr2ni_immers_freeze_tend, Spack &nr_selfcollect_tend,
+    Spack &nr_evap_tend, const Smask &context) {
+  const auto sink_nr =
+      (nr_collect_tend + nr2ni_immers_freeze_tend + nr_selfcollect_tend + nr_evap_tend) * dt;
+  const auto source_nr =
+      nr + (ni2nr_melt_tend * nmltratio + nr_ice_shed_tend + ncshdc + nc2nr_autoconv_tend) * dt;
+  const auto mask = sink_nr > source_nr && context;
   if (mask.any()) {
     const auto ratio = source_nr / sink_nr;
     nr_collect_tend.set(mask, nr_collect_tend * ratio);
diff --git i/components/eamxx/src/physics/p3/impl/p3_prevent_liq_supersaturation_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_prevent_liq_supersaturation_impl.hpp
index de8a3d687a..3e71a3218f 100644
--- i/components/eamxx/src/physics/p3/impl/p3_prevent_liq_supersaturation_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_prevent_liq_supersaturation_impl.hpp
@@ -14,11 +14,12 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void
-Functions<S, D>::prevent_liq_supersaturation(const Spack &pres, const Spack &t_atm, const Spack &qv, const Scalar &dt,
-                                             const Spack &qv2qi_vapdep_tend, const Spack &qinuc,
-                                             Spack &qi2qv_sublim_tend, Spack &qr2qv_evap_tend, const Smask &context)
-// Note: context masks cells which are just padding for packs or which don't have any condensate worth
-// performing calculations on.
+Functions<S, D>::prevent_liq_supersaturation(const Spack &pres, const Spack &t_atm, const Spack &qv,
+                                             const Scalar &dt, const Spack &qv2qi_vapdep_tend,
+                                             const Spack &qinuc, Spack &qi2qv_sublim_tend,
+                                             Spack &qr2qv_evap_tend, const Smask &context)
+// Note: context masks cells which are just padding for packs or which don't have any condensate
+// worth performing calculations on.
 {
   using physics = scream::physics::Functions<Scalar, Device>;
 
@@ -31,7 +32,8 @@ Functions<S, D>::prevent_liq_supersaturation(const Spack &pres, const Spack &t_a
   Spack qv_sinks, qv_sources, qv_endstep, T_endstep, A, frac;
 
   qv_sources.set(context, qi2qv_sublim_tend + qr2qv_evap_tend);
-  const auto has_sources = (qv_sources >= qsmall && context); // if nothing to rescale, no point in calculations.
+  const auto has_sources =
+      (qv_sources >= qsmall && context); // if nothing to rescale, no point in calculations.
 
   if (not has_sources.any()) {
     return;
@@ -41,13 +43,14 @@ Functions<S, D>::prevent_liq_supersaturation(const Spack &pres, const Spack &t_a
 
   // Actual qv and T after microphys step
   qv_endstep.set(has_sources, qv - qv_sinks * dt + qv_sources * dt);
-  T_endstep.set(
-      has_sources,
-      t_atm + ((qv_sinks - qi2qv_sublim_tend) * (latvap + latice) * inv_cp - qr2qv_evap_tend * latvap * inv_cp) * dt);
+  T_endstep.set(has_sources, t_atm + ((qv_sinks - qi2qv_sublim_tend) * (latvap + latice) * inv_cp -
+                                      qr2qv_evap_tend * latvap * inv_cp) *
+                                         dt);
 
   // qv we would have at end of step if we were saturated with respect to liquid
-  const auto qsl = physics::qv_sat_dry(T_endstep, pres, false, has_sources, physics::MurphyKoop,
-                                       "p3::prevent_liq_supersaturation"); //"false" means NOT sat w/ respect to ice
+  const auto qsl = physics::qv_sat_dry(
+      T_endstep, pres, false, has_sources, physics::MurphyKoop,
+      "p3::prevent_liq_supersaturation"); //"false" means NOT sat w/ respect to ice
 
   // The balance we seek is:
   //  qv-qv_sinks*dt+qv_sources*frac*dt=qsl+dqsl_dT*(T correction due to conservation)
diff --git i/components/eamxx/src/physics/p3/impl/p3_rain_imm_freezing_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_rain_imm_freezing_impl.hpp
index 261151923a..3e635a8a6a 100644
--- i/components/eamxx/src/physics/p3/impl/p3_rain_imm_freezing_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_rain_imm_freezing_impl.hpp
@@ -12,11 +12,10 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::rain_immersion_freezing(const Spack &T_atm, const Spack &lamr, const Spack &mu_r,
-                                                              const Spack &cdistr, const Spack &qr_incld,
-                                                              Spack &qr2qi_immers_freeze_tend,
-                                                              Spack &nr2ni_immers_freeze_tend,
-                                                              const P3Runtime &runtime_options, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::rain_immersion_freezing(
+    const Spack &T_atm, const Spack &lamr, const Spack &mu_r, const Spack &cdistr,
+    const Spack &qr_incld, Spack &qr2qi_immers_freeze_tend, Spack &nr2ni_immers_freeze_tend,
+    const P3Runtime &runtime_options, const Smask &context) {
   constexpr Scalar qsmall     = C::QSMALL;
   constexpr Scalar T_rainfrz  = C::T_rainfrz;
   constexpr Scalar T_zerodegc = C::T_zerodegc;
@@ -27,12 +26,14 @@ KOKKOS_FUNCTION void Functions<S, D>::rain_immersion_freezing(const Spack &T_atm
 
   const auto qr_not_small_and_t_freezing = (qr_incld >= qsmall) && (T_atm <= T_rainfrz) && context;
   if (qr_not_small_and_t_freezing.any()) {
-    qr2qi_immers_freeze_tend.set(qr_not_small_and_t_freezing,
-                                 CONS6 * exp(log(cdistr) + log(tgamma(sp(7.) + mu_r)) - sp(6.) * log(lamr)) *
-                                     exp(immersion_freezing_exponent * (T_zerodegc - T_atm)));
-    nr2ni_immers_freeze_tend.set(qr_not_small_and_t_freezing,
-                                 CONS5 * exp(log(cdistr) + log(tgamma(sp(4.) + mu_r)) - sp(3.) * log(lamr)) *
-                                     exp(immersion_freezing_exponent * (T_zerodegc - T_atm)));
+    qr2qi_immers_freeze_tend.set(
+        qr_not_small_and_t_freezing,
+        CONS6 * exp(log(cdistr) + log(tgamma(sp(7.) + mu_r)) - sp(6.) * log(lamr)) *
+            exp(immersion_freezing_exponent * (T_zerodegc - T_atm)));
+    nr2ni_immers_freeze_tend.set(
+        qr_not_small_and_t_freezing,
+        CONS5 * exp(log(cdistr) + log(tgamma(sp(4.) + mu_r)) - sp(3.) * log(lamr)) *
+            exp(immersion_freezing_exponent * (T_zerodegc - T_atm)));
   }
 }
 
diff --git i/components/eamxx/src/physics/p3/impl/p3_rain_sed_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_rain_sed_impl.hpp
index 03411fca3b..fe7e5dce08 100644
--- i/components/eamxx/src/physics/p3/impl/p3_rain_sed_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_rain_sed_impl.hpp
@@ -12,11 +12,10 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::compute_rain_fall_velocity(const view_2d_table &vn_table_vals, const view_2d_table &vm_table_vals,
-                                            const Spack &qr_incld, const Spack &rhofacr, Spack &nr_incld, Spack &mu_r,
-                                            Spack &lamr, Spack &V_qr, Spack &V_nr, const P3Runtime &runtime_options,
-                                            const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::compute_rain_fall_velocity(
+    const view_2d_table &vn_table_vals, const view_2d_table &vm_table_vals, const Spack &qr_incld,
+    const Spack &rhofacr, Spack &nr_incld, Spack &mu_r, Spack &lamr, Spack &V_qr, Spack &V_nr,
+    const P3Runtime &runtime_options, const Smask &context) {
   Table3 table;
   get_rain_dsd2(qr_incld, nr_incld, mu_r, lamr, runtime_options, context);
 
@@ -31,20 +30,23 @@ Functions<S, D>::compute_rain_fall_velocity(const view_2d_table &vn_table_vals,
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::rain_sedimentation(
-    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &rhofacr,
-    const uview_1d<const Spack> &cld_frac_r, const uview_1d<const Spack> &inv_dz, const uview_1d<Spack> &qr_incld,
-    const MemberType &team, const Workspace &workspace, const view_2d_table &vn_table_vals,
-    const view_2d_table &vm_table_vals, const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir,
-    const Scalar &dt, const Scalar &inv_dt, const uview_1d<Spack> &qr, const uview_1d<Spack> &nr,
-    const uview_1d<Spack> &nr_incld, const uview_1d<Spack> &mu_r, const uview_1d<Spack> &lamr,
-    const uview_1d<Spack> &precip_liq_flux, const uview_1d<Spack> &qr_tend, const uview_1d<Spack> &nr_tend,
-    Scalar &precip_liq_surf, const P3Runtime &runtime_options) {
+    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
+    const uview_1d<const Spack> &rhofacr, const uview_1d<const Spack> &cld_frac_r,
+    const uview_1d<const Spack> &inv_dz, const uview_1d<Spack> &qr_incld, const MemberType &team,
+    const Workspace &workspace, const view_2d_table &vn_table_vals,
+    const view_2d_table &vm_table_vals, const Int &nk, const Int &ktop, const Int &kbot,
+    const Int &kdir, const Scalar &dt, const Scalar &inv_dt, const uview_1d<Spack> &qr,
+    const uview_1d<Spack> &nr, const uview_1d<Spack> &nr_incld, const uview_1d<Spack> &mu_r,
+    const uview_1d<Spack> &lamr, const uview_1d<Spack> &precip_liq_flux,
+    const uview_1d<Spack> &qr_tend, const uview_1d<Spack> &nr_tend, Scalar &precip_liq_surf,
+    const P3Runtime &runtime_options) {
   // Get temporary workspaces needed for the ice-sed calculation
   uview_1d<Spack> V_qr, V_nr, flux_qx, flux_nx;
   workspace.template take_many_contiguous_unsafe<4>({"V_qr", "V_nr", "flux_qx", "flux_nx"},
                                                     {&V_qr, &V_nr, &flux_qx, &flux_nx});
 
-  const view_1d_ptr_array<Spack, 2> fluxes_ptr = {&flux_qx, &flux_nx}, vs_ptr = {&V_qr, &V_nr}, qnr_ptr = {&qr, &nr};
+  const view_1d_ptr_array<Spack, 2> fluxes_ptr = {&flux_qx, &flux_nx}, vs_ptr = {&V_qr, &V_nr},
+                                    qnr_ptr = {&qr, &nr};
 
   const auto sflux_qx = scalarize(flux_qx);
 
@@ -85,8 +87,9 @@ KOKKOS_FUNCTION void Functions<S, D>::rain_sedimentation(
             const auto range_mask  = range_pack >= kmin_scalar && range_pack <= kmax_scalar;
             const auto qr_gt_small = range_mask && qr_incld(pk) > qsmall;
             if (qr_gt_small.any()) {
-              compute_rain_fall_velocity(vn_table_vals, vm_table_vals, qr_incld(pk), rhofacr(pk), nr_incld(pk),
-                                         mu_r(pk), lamr(pk), V_qr(pk), V_nr(pk), runtime_options, qr_gt_small);
+              compute_rain_fall_velocity(vn_table_vals, vm_table_vals, qr_incld(pk), rhofacr(pk),
+                                         nr_incld(pk), mu_r(pk), lamr(pk), V_qr(pk), V_nr(pk),
+                                         runtime_options, qr_gt_small);
 
               // in compute_rain_fall_velocity, get_rain_dsd2 keeps the drop-size
               // distribution within reasonable bounds by modifying nr_incld.
@@ -100,8 +103,8 @@ KOKKOS_FUNCTION void Functions<S, D>::rain_sedimentation(
           Kokkos::Max<Scalar>(Co_max));
       team.team_barrier();
 
-      generalized_sedimentation<2>(rho, inv_rho, inv_dz, team, nk, k_qxtop, k_qxbot, kbot, kdir, Co_max, dt_left,
-                                   prt_accum, fluxes_ptr, vs_ptr, qnr_ptr);
+      generalized_sedimentation<2>(rho, inv_rho, inv_dz, team, nk, k_qxtop, k_qxbot, kbot, kdir,
+                                   Co_max, dt_left, prt_accum, fluxes_ptr, vs_ptr, qnr_ptr);
 
       // Update _incld values with end-of-step cell-ave values
       // No prob w/ div by cld_frac_r because set to min of 1e-4 in interface.
@@ -125,7 +128,8 @@ KOKKOS_FUNCTION void Functions<S, D>::rain_sedimentation(
         precip_liq_flux(pk).set(range_mask, precip_liq_flux(pk) + flux_qx_pk);
       });
     }
-    Kokkos::single(Kokkos::PerTeam(team), [&]() { precip_liq_surf += prt_accum * C::INV_RHO_H2O * inv_dt; });
+    Kokkos::single(Kokkos::PerTeam(team),
+                   [&]() { precip_liq_surf += prt_accum * C::INV_RHO_H2O * inv_dt; });
   }
 
   const Int nk_pack = ekat::npack<Spack>(nk);
diff --git i/components/eamxx/src/physics/p3/impl/p3_rain_self_collection_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_rain_self_collection_impl.hpp
index ec92293edd..1664b503ec 100644
--- i/components/eamxx/src/physics/p3/impl/p3_rain_self_collection_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_rain_self_collection_impl.hpp
@@ -7,9 +7,10 @@ namespace scream {
 namespace p3 {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::rain_self_collection(const Spack &rho, const Spack &qr_incld,
-                                                           const Spack &nr_incld, Spack &nr_selfcollect_tend,
-                                                           const P3Runtime &runtime_options, const Smask &context) {
+KOKKOS_FUNCTION void
+Functions<S, D>::rain_self_collection(const Spack &rho, const Spack &qr_incld,
+                                      const Spack &nr_incld, Spack &nr_selfcollect_tend,
+                                      const P3Runtime &runtime_options, const Smask &context) {
   // ------------------------------------------------------
   // self-collection and breakup of rain
   // (breakup following modified Verlinde and Cotton scheme)
@@ -18,8 +19,9 @@ KOKKOS_FUNCTION void Functions<S, D>::rain_self_collection(const Spack &rho, con
   constexpr Scalar rho_h2o = C::RHO_H2O;
   constexpr Scalar pi      = C::Pi;
 
-  const Scalar rain_selfcollection_breakup_diameter = runtime_options.rain_selfcollection_breakup_diameter;
-  const Scalar rain_selfcollection_prefactor        = runtime_options.rain_selfcollection_prefactor;
+  const Scalar rain_selfcollection_breakup_diameter =
+      runtime_options.rain_selfcollection_breakup_diameter;
+  const Scalar rain_selfcollection_prefactor = runtime_options.rain_selfcollection_prefactor;
 
   const auto qr_incld_not_small = qr_incld >= qsmall && context;
 
@@ -39,7 +41,8 @@ KOKKOS_FUNCTION void Functions<S, D>::rain_self_collection(const Spack &rho, con
       dum.set(dum2_gt_dum1, 2 - exp(2300 * (dum2 - rain_selfcollection_breakup_diameter)));
     }
 
-    nr_selfcollect_tend.set(qr_incld_not_small, dum * rain_selfcollection_prefactor * nr_incld * qr_incld * rho);
+    nr_selfcollect_tend.set(qr_incld_not_small,
+                            dum * rain_selfcollection_prefactor * nr_incld * qr_incld * rho);
   }
 }
 
diff --git i/components/eamxx/src/physics/p3/impl/p3_subgrid_variance_scaling_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_subgrid_variance_scaling_impl.hpp
index 63dd7552ab..a97e4290d3 100644
--- i/components/eamxx/src/physics/p3/impl/p3_subgrid_variance_scaling_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_subgrid_variance_scaling_impl.hpp
@@ -7,8 +7,8 @@ namespace scream {
 namespace p3 {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION typename Functions<S, D>::Spack Functions<S, D>::subgrid_variance_scaling(const Spack &relvar,
-                                                                                          const Scalar &expon) {
+KOKKOS_FUNCTION typename Functions<S, D>::Spack
+Functions<S, D>::subgrid_variance_scaling(const Spack &relvar, const Scalar &expon) {
   /* We assume subgrid variations in qc follow a gamma distribution with inverse
      relative variance relvar = 1/(var(qc)/qc**2). In this case, if the tendency
      for a given process is of the form A*qc**expon for a local value of qc, then
@@ -35,8 +35,9 @@ KOKKOS_FUNCTION typename Functions<S, D>::Spack Functions<S, D>::subgrid_varianc
   // Check that expon >0.
   //============================================
   if (expon < 0.0){
-    const auto msg = "expon<0. This might be ok, but isn't unit tested and can drive subgrid_variance_scaling negative.
-  Be careful if you proceed."; EKAT_REQUIRE_MSG( condition, msg );
+    const auto msg = "expon<0. This might be ok, but isn't unit tested and can drive
+  subgrid_variance_scaling negative. Be careful if you proceed."; EKAT_REQUIRE_MSG( condition, msg
+  );
   }
 
   */
diff --git i/components/eamxx/src/physics/p3/impl/p3_table3_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_table3_impl.hpp
index 3047b057bc..8a06507460 100644
--- i/components/eamxx/src/physics/p3/impl/p3_table3_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_table3_impl.hpp
@@ -12,7 +12,8 @@ namespace p3 {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::lookup(const Spack &mu_r, const Spack &lamr, Table3 &tab, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::lookup(const Spack &mu_r, const Spack &lamr, Table3 &tab,
+                                             const Smask &context) {
   // find location in scaled mean size space
   const auto dum1    = (mu_r + 1) / lamr;
   const auto dum1_lt = context && (dum1 <= sp(195.e-6));
@@ -60,12 +61,13 @@ KOKKOS_FUNCTION void Functions<S, D>::lookup(const Spack &mu_r, const Spack &lam
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION typename Functions<S, D>::Spack Functions<S, D>::apply_table(const view_2d_table &table,
-                                                                             const Table3 &tab3) {
+KOKKOS_FUNCTION typename Functions<S, D>::Spack
+Functions<S, D>::apply_table(const view_2d_table &table, const Table3 &tab3) {
   const auto rdumii_m_dumii = tab3.rdumii - Spack(tab3.dumii);
   const auto t_im1_jm1      = index(table, tab3.dumii - 1, tab3.dumjj - 1);
   // Linear interpolant.
-  const auto dum1    = (t_im1_jm1 + rdumii_m_dumii * (index(table, tab3.dumii, tab3.dumjj - 1) - t_im1_jm1));
+  const auto dum1 =
+      (t_im1_jm1 + rdumii_m_dumii * (index(table, tab3.dumii, tab3.dumjj - 1) - t_im1_jm1));
   const auto t_im1_j = index(table, tab3.dumii - 1, tab3.dumjj);
   // Linear interpolant.
   const auto dum2 = (t_im1_j + rdumii_m_dumii * (index(table, tab3.dumii, tab3.dumjj) - t_im1_j));
@@ -75,8 +77,8 @@ KOKKOS_FUNCTION typename Functions<S, D>::Spack Functions<S, D>::apply_table(con
 
 template <typename S, typename D>
 void Functions<S, D>::get_global_tables(view_2d_table &vn_table_vals, view_2d_table &vm_table_vals,
-                                        view_2d_table &revap_table_vals, view_1d_table &mu_r_table_vals,
-                                        view_dnu_table &dnu) {
+                                        view_2d_table &revap_table_vals,
+                                        view_1d_table &mu_r_table_vals, view_dnu_table &dnu) {
   auto tables      = p3_init();
   vn_table_vals    = tables.vn_table_vals;
   vm_table_vals    = tables.vm_table_vals;
diff --git i/components/eamxx/src/physics/p3/impl/p3_table_ice_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_table_ice_impl.hpp
index 3e6f411dfc..d22dbb9174 100644
--- i/components/eamxx/src/physics/p3/impl/p3_table_ice_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_table_ice_impl.hpp
@@ -22,8 +22,9 @@ void Functions<S, D>::get_global_ice_lookup_tables(view_ice_table &ice_table_val
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::lookup_ice(const Spack &qi, const Spack &ni, const Spack &qm, const Spack &rhop,
-                                                 TableIce &tab, const Smask &context) {
+KOKKOS_FUNCTION void Functions<S, D>::lookup_ice(const Spack &qi, const Spack &ni, const Spack &qm,
+                                                 const Spack &rhop, TableIce &tab,
+                                                 const Smask &context) {
   // find index for qi (normalized ice mass mixing ratio = qi/ni)
   //   dum1 = (log10(qi)+16.)/0.70757  !orig
   //   dum1 = (log10(qi)+16.)*1.41328
@@ -113,8 +114,8 @@ KOKKOS_FUNCTION void Functions<S, D>::lookup_rain(const Spack &qr, const Spack &
 
 template <typename S, typename D>
 KOKKOS_FUNCTION typename Functions<S, D>::Spack
-Functions<S, D>::apply_table_ice(const int &idx, const view_ice_table &ice_table_vals, const TableIce &tab,
-                                 const Smask &context) {
+Functions<S, D>::apply_table_ice(const int &idx, const view_ice_table &ice_table_vals,
+                                 const TableIce &tab, const Smask &context) {
   using ekat::index;
 
   Spack proc;
@@ -127,14 +128,15 @@ Functions<S, D>::apply_table_ice(const int &idx, const view_ice_table &ice_table
 
   // first interpolate for current rimed fraction index
   auto iproc1 = index(ice_table_vals, tab.dumjj, tab.dumii, tab.dumi, idxpk) +
-                (tab.dum1 - Spack(tab.dumi) - 1) * (index(ice_table_vals, tab.dumjj, tab.dumii, tab.dumi + 1, idxpk) -
-                                                    index(ice_table_vals, tab.dumjj, tab.dumii, tab.dumi, idxpk));
+                (tab.dum1 - Spack(tab.dumi) - 1) *
+                    (index(ice_table_vals, tab.dumjj, tab.dumii, tab.dumi + 1, idxpk) -
+                     index(ice_table_vals, tab.dumjj, tab.dumii, tab.dumi, idxpk));
 
   // linearly interpolate to get process rates for rimed fraction index + 1
-  auto gproc1 =
-      index(ice_table_vals, tab.dumjj, tab.dumii + 1, tab.dumi, idxpk) +
-      (tab.dum1 - Spack(tab.dumi) - 1) * (index(ice_table_vals, tab.dumjj, tab.dumii + 1, tab.dumi + 1, idxpk) -
-                                          index(ice_table_vals, tab.dumjj, tab.dumii + 1, tab.dumi, idxpk));
+  auto gproc1 = index(ice_table_vals, tab.dumjj, tab.dumii + 1, tab.dumi, idxpk) +
+                (tab.dum1 - Spack(tab.dumi) - 1) *
+                    (index(ice_table_vals, tab.dumjj, tab.dumii + 1, tab.dumi + 1, idxpk) -
+                     index(ice_table_vals, tab.dumjj, tab.dumii + 1, tab.dumi, idxpk));
 
   const auto tmp1 = iproc1 + (tab.dum4 - Spack(tab.dumii) - 1) * (gproc1 - iproc1);
 
@@ -143,15 +145,16 @@ Functions<S, D>::apply_table_ice(const int &idx, const view_ice_table &ice_table
   // first interpolate for current rimed fraction index
 
   iproc1 = index(ice_table_vals, tab.dumjj + 1, tab.dumii, tab.dumi, idxpk) +
-           (tab.dum1 - Spack(tab.dumi) - 1) * (index(ice_table_vals, tab.dumjj + 1, tab.dumii, tab.dumi + 1, idxpk) -
-                                               index(ice_table_vals, tab.dumjj + 1, tab.dumii, tab.dumi, idxpk));
+           (tab.dum1 - Spack(tab.dumi) - 1) *
+               (index(ice_table_vals, tab.dumjj + 1, tab.dumii, tab.dumi + 1, idxpk) -
+                index(ice_table_vals, tab.dumjj + 1, tab.dumii, tab.dumi, idxpk));
 
   // linearly interpolate to get process rates for rimed fraction index + 1
 
-  gproc1 =
-      index(ice_table_vals, tab.dumjj + 1, tab.dumii + 1, tab.dumi, idxpk) +
-      (tab.dum1 - Spack(tab.dumi) - 1) * (index(ice_table_vals, tab.dumjj + 1, tab.dumii + 1, tab.dumi + 1, idxpk) -
-                                          index(ice_table_vals, tab.dumjj + 1, tab.dumii + 1, tab.dumi, idxpk));
+  gproc1 = index(ice_table_vals, tab.dumjj + 1, tab.dumii + 1, tab.dumi, idxpk) +
+           (tab.dum1 - Spack(tab.dumi) - 1) *
+               (index(ice_table_vals, tab.dumjj + 1, tab.dumii + 1, tab.dumi + 1, idxpk) -
+                index(ice_table_vals, tab.dumjj + 1, tab.dumii + 1, tab.dumi, idxpk));
 
   const auto tmp2 = iproc1 + (tab.dum4 - Spack(tab.dumii) - 1) * (gproc1 - iproc1);
 
@@ -162,8 +165,8 @@ Functions<S, D>::apply_table_ice(const int &idx, const view_ice_table &ice_table
 
 template <typename S, typename D>
 KOKKOS_FUNCTION typename Functions<S, D>::Spack
-Functions<S, D>::apply_table_coll(const int &idx, const view_collect_table &collect_table_vals, const TableIce &ti,
-                                  const TableRain &tr, const Smask &context) {
+Functions<S, D>::apply_table_coll(const int &idx, const view_collect_table &collect_table_vals,
+                                  const TableIce &ti, const TableRain &tr, const Smask &context) {
   using ekat::index;
 
   Spack proc;
@@ -175,24 +178,25 @@ Functions<S, D>::apply_table_coll(const int &idx, const view_collect_table &coll
   // current density index
 
   // current rime fraction index
-  auto dproc1 =
-      index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi, tr.dumj, idxpk) +
-      (ti.dum1 - Spack(ti.dumi) - 1) * (index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi + 1, tr.dumj, idxpk) -
-                                        index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi, tr.dumj, idxpk));
+  auto dproc1 = index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi, tr.dumj, idxpk) +
+                (ti.dum1 - Spack(ti.dumi) - 1) *
+                    (index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi + 1, tr.dumj, idxpk) -
+                     index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi, tr.dumj, idxpk));
 
   auto dproc2 =
       index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi, tr.dumj + 1, idxpk) +
-      (ti.dum1 - Spack(ti.dumi) - 1) * (index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi + 1, tr.dumj + 1, idxpk) -
-                                        index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi, tr.dumj + 1, idxpk));
+      (ti.dum1 - Spack(ti.dumi) - 1) *
+          (index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi + 1, tr.dumj + 1, idxpk) -
+           index(collect_table_vals, ti.dumjj, ti.dumii, ti.dumi, tr.dumj + 1, idxpk));
 
   auto iproc1 = dproc1 + (tr.dum3 - Spack(tr.dumj) - 1) * (dproc2 - dproc1);
 
   // rime fraction index + 1
 
-  dproc1 =
-      index(collect_table_vals, ti.dumjj, ti.dumii + 1, ti.dumi, tr.dumj, idxpk) +
-      (ti.dum1 - Spack(ti.dumi) - 1) * (index(collect_table_vals, ti.dumjj, ti.dumii + 1, ti.dumi + 1, tr.dumj, idxpk) -
-                                        index(collect_table_vals, ti.dumjj, ti.dumii + 1, ti.dumi, tr.dumj, idxpk));
+  dproc1 = index(collect_table_vals, ti.dumjj, ti.dumii + 1, ti.dumi, tr.dumj, idxpk) +
+           (ti.dum1 - Spack(ti.dumi) - 1) *
+               (index(collect_table_vals, ti.dumjj, ti.dumii + 1, ti.dumi + 1, tr.dumj, idxpk) -
+                index(collect_table_vals, ti.dumjj, ti.dumii + 1, ti.dumi, tr.dumj, idxpk));
 
   dproc2 = index(collect_table_vals, ti.dumjj, ti.dumii + 1, ti.dumi, tr.dumj + 1, idxpk) +
            (ti.dum1 - Spack(ti.dumi) - 1) *
@@ -206,10 +210,10 @@ Functions<S, D>::apply_table_coll(const int &idx, const view_collect_table &coll
 
   // current rime fraction index
 
-  dproc1 =
-      index(collect_table_vals, ti.dumjj + 1, ti.dumii, ti.dumi, tr.dumj, idxpk) +
-      (ti.dum1 - Spack(ti.dumi) - 1) * (index(collect_table_vals, ti.dumjj + 1, ti.dumii, ti.dumi + 1, tr.dumj, idxpk) -
-                                        index(collect_table_vals, ti.dumjj + 1, ti.dumii, ti.dumi, tr.dumj, idxpk));
+  dproc1 = index(collect_table_vals, ti.dumjj + 1, ti.dumii, ti.dumi, tr.dumj, idxpk) +
+           (ti.dum1 - Spack(ti.dumi) - 1) *
+               (index(collect_table_vals, ti.dumjj + 1, ti.dumii, ti.dumi + 1, tr.dumj, idxpk) -
+                index(collect_table_vals, ti.dumjj + 1, ti.dumii, ti.dumi, tr.dumj, idxpk));
 
   dproc2 = index(collect_table_vals, ti.dumjj + 1, ti.dumii, ti.dumi, tr.dumj + 1, idxpk) +
            (ti.dum1 - Spack(ti.dumi) - 1) *
@@ -225,10 +229,11 @@ Functions<S, D>::apply_table_coll(const int &idx, const view_collect_table &coll
                (index(collect_table_vals, ti.dumjj + 1, ti.dumii + 1, ti.dumi + 1, tr.dumj, idxpk) -
                 index(collect_table_vals, ti.dumjj + 1, ti.dumii + 1, ti.dumi, tr.dumj, idxpk));
 
-  dproc2 = index(collect_table_vals, ti.dumjj + 1, ti.dumii + 1, ti.dumi, tr.dumj + 1, idxpk) +
-           (ti.dum1 - Spack(ti.dumi) - 1) *
-               (index(collect_table_vals, ti.dumjj + 1, ti.dumii + 1, ti.dumi + 1, tr.dumj + 1, idxpk) -
-                index(collect_table_vals, ti.dumjj + 1, ti.dumii + 1, ti.dumi, tr.dumj + 1, idxpk));
+  dproc2 =
+      index(collect_table_vals, ti.dumjj + 1, ti.dumii + 1, ti.dumi, tr.dumj + 1, idxpk) +
+      (ti.dum1 - Spack(ti.dumi) - 1) *
+          (index(collect_table_vals, ti.dumjj + 1, ti.dumii + 1, ti.dumi + 1, tr.dumj + 1, idxpk) -
+           index(collect_table_vals, ti.dumjj + 1, ti.dumii + 1, ti.dumi, tr.dumj + 1, idxpk));
 
   gproc1          = dproc1 + (tr.dum3 - Spack(tr.dumj) - 1) * (dproc2 - dproc1);
   const auto tmp2 = iproc1 + (ti.dum4 - Spack(ti.dumii) - 1) * (gproc1 - iproc1);
diff --git i/components/eamxx/src/physics/p3/impl/p3_update_prognostics_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_update_prognostics_impl.hpp
index 2cd5194ebb..3259e655d9 100644
--- i/components/eamxx/src/physics/p3/impl/p3_update_prognostics_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_update_prognostics_impl.hpp
@@ -8,15 +8,17 @@ namespace p3 {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::update_prognostic_ice(
-    const Spack &qc2qi_hetero_freeze_tend, const Spack &qc2qi_collect_tend, const Spack &qc2qr_ice_shed_tend,
-    const Spack &nc_collect_tend, const Spack &nc2ni_immers_freeze_tend, const Spack &ncshdc,
-    const Spack &qr2qi_collect_tend, const Spack &nr_collect_tend, const Spack &qr2qi_immers_freeze_tend,
-    const Spack &nr2ni_immers_freeze_tend, const Spack &nr_ice_shed_tend, const Spack &qi2qr_melt_tend,
-    const Spack &ni2nr_melt_tend, const Spack &qi2qv_sublim_tend, const Spack &qv2qi_vapdep_tend,
-    const Spack &qv2qi_nucleat_tend, const Spack &ni_nucleat_tend, const Spack &ni_selfcollect_tend,
-    const Spack &ni_sublim_tend, const Spack &qc2qi_berg_tend, const Spack &inv_exner, const bool do_predict_nc,
-    const Smask &log_wetgrowth, const Scalar dt, const Scalar &nmltratio, const Spack &rho_qm_cloud, Spack &ncheti_cnt,
-    Spack &nicnt, Spack &ninuc_cnt, Spack &qcheti_cnt, Spack &qicnt, Spack &qinuc_cnt, Spack &th_atm, Spack &qv,
+    const Spack &qc2qi_hetero_freeze_tend, const Spack &qc2qi_collect_tend,
+    const Spack &qc2qr_ice_shed_tend, const Spack &nc_collect_tend,
+    const Spack &nc2ni_immers_freeze_tend, const Spack &ncshdc, const Spack &qr2qi_collect_tend,
+    const Spack &nr_collect_tend, const Spack &qr2qi_immers_freeze_tend,
+    const Spack &nr2ni_immers_freeze_tend, const Spack &nr_ice_shed_tend,
+    const Spack &qi2qr_melt_tend, const Spack &ni2nr_melt_tend, const Spack &qi2qv_sublim_tend,
+    const Spack &qv2qi_vapdep_tend, const Spack &qv2qi_nucleat_tend, const Spack &ni_nucleat_tend,
+    const Spack &ni_selfcollect_tend, const Spack &ni_sublim_tend, const Spack &qc2qi_berg_tend,
+    const Spack &inv_exner, const bool do_predict_nc, const Smask &log_wetgrowth, const Scalar dt,
+    const Scalar &nmltratio, const Spack &rho_qm_cloud, Spack &ncheti_cnt, Spack &nicnt,
+    Spack &ninuc_cnt, Spack &qcheti_cnt, Spack &qicnt, Spack &qinuc_cnt, Spack &th_atm, Spack &qv,
     Spack &qi, Spack &ni, Spack &qm, Spack &bm, Spack &qc, Spack &nc, Spack &qr, Spack &nr,
     const bool &use_hetfrz_classnuc, const Smask &context) {
   constexpr Scalar QSMALL          = C::QSMALL;
@@ -25,9 +27,13 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostic_ice(
   constexpr Scalar latice          = C::LatIce;
 
   if (use_hetfrz_classnuc) {
-    qc.set(context, qc + (-qcheti_cnt - qicnt - qc2qi_collect_tend - qc2qr_ice_shed_tend - qc2qi_berg_tend) * dt);
+    qc.set(context,
+           qc + (-qcheti_cnt - qicnt - qc2qi_collect_tend - qc2qr_ice_shed_tend - qc2qi_berg_tend) *
+                    dt);
   } else {
-    qc.set(context, qc + (-qc2qi_hetero_freeze_tend - qc2qi_collect_tend - qc2qr_ice_shed_tend - qc2qi_berg_tend) * dt);
+    qc.set(context, qc + (-qc2qi_hetero_freeze_tend - qc2qi_collect_tend - qc2qr_ice_shed_tend -
+                          qc2qi_berg_tend) *
+                             dt);
   }
 
   if (do_predict_nc) {
@@ -38,13 +44,15 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostic_ice(
     }
   }
 
-  qr.set(context, qr + (-qr2qi_collect_tend + qi2qr_melt_tend - qr2qi_immers_freeze_tend + qc2qr_ice_shed_tend) * dt);
+  qr.set(context, qr + (-qr2qi_collect_tend + qi2qr_melt_tend - qr2qi_immers_freeze_tend +
+                        qc2qr_ice_shed_tend) *
+                           dt);
 
   // apply factor to source for rain number from melting of ice, (ad-hoc
   //  but accounts for rapid evaporation of small melting ice particles)
-  nr.set(context,
-         nr + (-nr_collect_tend - nr2ni_immers_freeze_tend + nmltratio * ni2nr_melt_tend + nr_ice_shed_tend + ncshdc) *
-                  dt);
+  nr.set(context, nr + (-nr_collect_tend - nr2ni_immers_freeze_tend + nmltratio * ni2nr_melt_tend +
+                        nr_ice_shed_tend + ncshdc) *
+                           dt);
 
   const auto qi_not_small = qi >= QSMALL && context;
 
@@ -55,8 +63,11 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostic_ice(
   }
 
   if (use_hetfrz_classnuc) {
-    const auto dum = (qr2qi_collect_tend + qc2qi_collect_tend + qr2qi_immers_freeze_tend + qcheti_cnt + qicnt) * dt;
-    qi.set(context, qi + (qv2qi_vapdep_tend + qv2qi_nucleat_tend + qc2qi_berg_tend + qinuc_cnt) * dt + dum);
+    const auto dum =
+        (qr2qi_collect_tend + qc2qi_collect_tend + qr2qi_immers_freeze_tend + qcheti_cnt + qicnt) *
+        dt;
+    qi.set(context,
+           qi + (qv2qi_vapdep_tend + qv2qi_nucleat_tend + qc2qi_berg_tend + qinuc_cnt) * dt + dum);
     qm.set(context, qm + dum);
     bm.set(context, bm + (qr2qi_collect_tend * INV_RHO_RIMEMAX + qc2qi_collect_tend / rho_qm_cloud +
                           (qr2qi_immers_freeze_tend + qcheti_cnt + qicnt) * INV_RHO_RIMEMAX) *
@@ -65,8 +76,9 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostic_ice(
                           nr2ni_immers_freeze_tend + ncheti_cnt + nicnt + ninuc_cnt) *
                              dt);
   } else {
-    const auto dum =
-        (qr2qi_collect_tend + qc2qi_collect_tend + qr2qi_immers_freeze_tend + qc2qi_hetero_freeze_tend) * dt;
+    const auto dum = (qr2qi_collect_tend + qc2qi_collect_tend + qr2qi_immers_freeze_tend +
+                      qc2qi_hetero_freeze_tend) *
+                     dt;
     qi.set(context, qi + (qv2qi_vapdep_tend + qv2qi_nucleat_tend + qc2qi_berg_tend) * dt + dum);
     qm.set(context, qm + dum);
     bm.set(context, bm + (qr2qi_collect_tend * INV_RHO_RIMEMAX + qc2qi_collect_tend / rho_qm_cloud +
@@ -101,19 +113,23 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostic_ice(
 
   constexpr Scalar INV_CP = C::INV_CP;
   if (use_hetfrz_classnuc) {
-    qv.set(context, qv + (-qv2qi_vapdep_tend + qi2qv_sublim_tend - qv2qi_nucleat_tend - qinuc_cnt) * dt);
-    th_atm.set(context, th_atm + inv_exner *
-                                     ((qv2qi_vapdep_tend - qi2qv_sublim_tend + qv2qi_nucleat_tend + qinuc_cnt) *
-                                          (latvap + latice) * INV_CP +
-                                      (qr2qi_collect_tend + qc2qi_collect_tend + qcheti_cnt + qicnt +
-                                       qr2qi_immers_freeze_tend - qi2qr_melt_tend + qc2qi_berg_tend) *
-                                          latice * INV_CP) *
-                                     dt);
+    qv.set(context,
+           qv + (-qv2qi_vapdep_tend + qi2qv_sublim_tend - qv2qi_nucleat_tend - qinuc_cnt) * dt);
+    th_atm.set(context,
+               th_atm +
+                   inv_exner *
+                       ((qv2qi_vapdep_tend - qi2qv_sublim_tend + qv2qi_nucleat_tend + qinuc_cnt) *
+                            (latvap + latice) * INV_CP +
+                        (qr2qi_collect_tend + qc2qi_collect_tend + qcheti_cnt + qicnt +
+                         qr2qi_immers_freeze_tend - qi2qr_melt_tend + qc2qi_berg_tend) *
+                            latice * INV_CP) *
+                       dt);
   } else {
     qv.set(context, qv + (-qv2qi_vapdep_tend + qi2qv_sublim_tend - qv2qi_nucleat_tend) * dt);
     th_atm.set(context,
                th_atm + inv_exner *
-                            ((qv2qi_vapdep_tend - qi2qv_sublim_tend + qv2qi_nucleat_tend) * (latvap + latice) * INV_CP +
+                            ((qv2qi_vapdep_tend - qi2qv_sublim_tend + qv2qi_nucleat_tend) *
+                                 (latvap + latice) * INV_CP +
                              (qr2qi_collect_tend + qc2qi_collect_tend + qc2qi_hetero_freeze_tend +
                               qr2qi_immers_freeze_tend - qi2qr_melt_tend + qc2qi_berg_tend) *
                                  latice * INV_CP) *
@@ -125,9 +141,10 @@ template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::update_prognostic_liquid(
     const Spack &qc2qr_accret_tend, const Spack &nc_accret_tend, const Spack &qc2qr_autoconv_tend,
     const Spack &nc2nr_autoconv_tend, const Spack &ncautr, const Spack &nc_selfcollect_tend,
-    const Spack &qr2qv_evap_tend, const Spack &nr_evap_tend, const Spack &nr_selfcollect_tend, const bool do_predict_nc,
-    const bool do_prescribed_CCN, const Spack &inv_rho, const Spack &inv_exner, const Scalar dt, Spack &th_atm,
-    Spack &qv, Spack &qc, Spack &nc, Spack &qr, Spack &nr, const Smask &context) {
+    const Spack &qr2qv_evap_tend, const Spack &nr_evap_tend, const Spack &nr_selfcollect_tend,
+    const bool do_predict_nc, const bool do_prescribed_CCN, const Spack &inv_rho,
+    const Spack &inv_exner, const Scalar dt, Spack &th_atm, Spack &qv, Spack &qc, Spack &nc,
+    Spack &qr, Spack &nr, const Smask &context) {
   constexpr Scalar NCCNST = C::NCCNST;
   constexpr int IPARAM    = C::IPARAM;
   constexpr Scalar INV_CP = C::INV_CP;
diff --git i/components/eamxx/src/physics/p3/impl/p3_upwind_impl.hpp w/components/eamxx/src/physics/p3/impl/p3_upwind_impl.hpp
index ca94d7540b..d6c480518d 100644
--- i/components/eamxx/src/physics/p3/impl/p3_upwind_impl.hpp
+++ w/components/eamxx/src/physics/p3/impl/p3_upwind_impl.hpp
@@ -14,10 +14,10 @@ namespace p3 {
 template <typename S, typename D>
 template <Int kdir, int nfield>
 KOKKOS_FUNCTION void Functions<S, D>::calc_first_order_upwind_step(
-    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &inv_dz,
-    const MemberType &team, const Int &nk, const Int &k_bot, const Int &k_top, const Scalar &dt_sub,
-    const view_1d_ptr_array<Spack, nfield> &flux, const view_1d_ptr_array<Spack, nfield> &V,
-    const view_1d_ptr_array<Spack, nfield> &r) {
+    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
+    const uview_1d<const Spack> &inv_dz, const MemberType &team, const Int &nk, const Int &k_bot,
+    const Int &k_top, const Scalar &dt_sub, const view_1d_ptr_array<Spack, nfield> &flux,
+    const view_1d_ptr_array<Spack, nfield> &V, const view_1d_ptr_array<Spack, nfield> &r) {
   const Int kmin_scalar = (kdir == 1 ? k_bot : k_top);
   const Int kmax_scalar = (kdir == 1 ? k_top : k_bot);
   Int kmin              = kmin_scalar / Spack::n,
@@ -50,8 +50,9 @@ KOKKOS_FUNCTION void Functions<S, D>::calc_first_order_upwind_step(
     }
     for (int f = 0; f < nfield; ++f) {
       // compute flux divergence
-      const auto flux_pkdir = (kdir == -1) ? shift_right(0, (*flux[f])(k)) : shift_left(0, (*flux[f])(k));
-      const auto fluxdiv    = (flux_pkdir - (*flux[f])(k)) * inv_dz(k);
+      const auto flux_pkdir =
+          (kdir == -1) ? shift_right(0, (*flux[f])(k)) : shift_left(0, (*flux[f])(k));
+      const auto fluxdiv = (flux_pkdir - (*flux[f])(k)) * inv_dz(k);
 
       // update prognostic variables
       (*r[f])(k) += fluxdiv * dt_sub * inv_rho(k);
@@ -79,9 +80,10 @@ KOKKOS_FUNCTION void Functions<S, D>::calc_first_order_upwind_step(
 template <typename S, typename D>
 template <int nfield>
 KOKKOS_FUNCTION void Functions<S, D>::generalized_sedimentation(
-    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &inv_dz,
-    const MemberType &team, const Int &nk, const Int &k_qxtop, Int &k_qxbot, const Int &kbot, const Int &kdir,
-    const Scalar &Co_max, Scalar &dt_left, Scalar &prt_accum, const view_1d_ptr_array<Spack, nfield> &fluxes,
+    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
+    const uview_1d<const Spack> &inv_dz, const MemberType &team, const Int &nk, const Int &k_qxtop,
+    Int &k_qxbot, const Int &kbot, const Int &kdir, const Scalar &Co_max, Scalar &dt_left,
+    Scalar &prt_accum, const view_1d_ptr_array<Spack, nfield> &fluxes,
     const view_1d_ptr_array<Spack, nfield> &Vs, // (behaviorally const)
     const view_1d_ptr_array<Spack, nfield> &rs) {
   // compute dt_sub
@@ -92,7 +94,8 @@ KOKKOS_FUNCTION void Functions<S, D>::generalized_sedimentation(
   // Move bottom cell down by 1 if not at ground already
   const Int k_temp = (k_qxbot == kbot) ? k_qxbot : k_qxbot - kdir;
 
-  calc_first_order_upwind_step<nfield>(rho, inv_rho, inv_dz, team, nk, k_temp, k_qxtop, kdir, dt_sub, fluxes, Vs, rs);
+  calc_first_order_upwind_step<nfield>(rho, inv_rho, inv_dz, team, nk, k_temp, k_qxtop, kdir,
+                                       dt_sub, fluxes, Vs, rs);
   team.team_barrier();
 
   // accumulated precip during time step
@@ -110,21 +113,25 @@ KOKKOS_FUNCTION void Functions<S, D>::generalized_sedimentation(
 template <typename S, typename D>
 template <int nfield>
 KOKKOS_FUNCTION void Functions<S, D>::calc_first_order_upwind_step(
-    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &inv_dz,
-    const MemberType &team, const Int &nk, const Int &k_bot, const Int &k_top, const Int &kdir, const Scalar &dt_sub,
+    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
+    const uview_1d<const Spack> &inv_dz, const MemberType &team, const Int &nk, const Int &k_bot,
+    const Int &k_top, const Int &kdir, const Scalar &dt_sub,
     const view_1d_ptr_array<Spack, nfield> &flux, const view_1d_ptr_array<Spack, nfield> &V,
     const view_1d_ptr_array<Spack, nfield> &r) {
   if (kdir == 1)
-    calc_first_order_upwind_step<1, nfield>(rho, inv_rho, inv_dz, team, nk, k_bot, k_top, dt_sub, flux, V, r);
+    calc_first_order_upwind_step<1, nfield>(rho, inv_rho, inv_dz, team, nk, k_bot, k_top, dt_sub,
+                                            flux, V, r);
   else
-    calc_first_order_upwind_step<-1, nfield>(rho, inv_rho, inv_dz, team, nk, k_bot, k_top, dt_sub, flux, V, r);
+    calc_first_order_upwind_step<-1, nfield>(rho, inv_rho, inv_dz, team, nk, k_bot, k_top, dt_sub,
+                                             flux, V, r);
 }
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::calc_first_order_upwind_step(
-    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &inv_dz,
-    const MemberType &team, const Int &nk, const Int &k_bot, const Int &k_top, const Int &kdir, const Scalar &dt_sub,
-    const uview_1d<Spack> &flux, const uview_1d<const Spack> &V, const uview_1d<Spack> &r) {
+    const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
+    const uview_1d<const Spack> &inv_dz, const MemberType &team, const Int &nk, const Int &k_bot,
+    const Int &k_top, const Int &kdir, const Scalar &dt_sub, const uview_1d<Spack> &flux,
+    const uview_1d<const Spack> &V, const uview_1d<Spack> &r) {
   // B/c automatic casting to const does not work in the nested data
   // view_1d_ptr_array (C++ does not provide all legal const casts automatically
   // in nested data structures), we are not enforcing const in the array
@@ -133,11 +140,11 @@ KOKKOS_FUNCTION void Functions<S, D>::calc_first_order_upwind_step(
   // cast here.
   const auto V_nonconst = uview_1d<Spack>(const_cast<Spack *>(V.data()), V.extent_int(0));
   if (kdir == 1)
-    calc_first_order_upwind_step<1, 1>(rho, inv_rho, inv_dz, team, nk, k_bot, k_top, dt_sub, {&flux}, {&V_nonconst},
-                                       {&r});
+    calc_first_order_upwind_step<1, 1>(rho, inv_rho, inv_dz, team, nk, k_bot, k_top, dt_sub,
+                                       {&flux}, {&V_nonconst}, {&r});
   else
-    calc_first_order_upwind_step<-1, 1>(rho, inv_rho, inv_dz, team, nk, k_bot, k_top, dt_sub, {&flux}, {&V_nonconst},
-                                        {&r});
+    calc_first_order_upwind_step<-1, 1>(rho, inv_rho, inv_dz, team, nk, k_bot, k_top, dt_sub,
+                                        {&flux}, {&V_nonconst}, {&r});
 }
 
 } // namespace p3
diff --git i/components/eamxx/src/physics/p3/p3_functions.hpp w/components/eamxx/src/physics/p3/p3_functions.hpp
index 29d5128bf8..2ac8f12b95 100644
--- i/components/eamxx/src/physics/p3/p3_functions.hpp
+++ w/components/eamxx/src/physics/p3/p3_functions.hpp
@@ -43,8 +43,9 @@ template <typename ScalarT, typename DeviceT> struct Functions {
       dnusize = 16,
     };
 
-    static constexpr ScalarT lookup_table_1a_dum1_c = 4.135985029041767e+00; // 1.0/(0.1*log10(261.7))
-    static constexpr const char *p3_lookup_base     = SCREAM_DATA_DIR "/tables/p3_lookup_table_1.dat-v";
+    static constexpr ScalarT lookup_table_1a_dum1_c =
+        4.135985029041767e+00; // 1.0/(0.1*log10(261.7))
+    static constexpr const char *p3_lookup_base = SCREAM_DATA_DIR "/tables/p3_lookup_table_1.dat-v";
 
     static constexpr const char *p3_version =
         "4.1.1"; // TODO: Change this so that the table version and table path is a runtime option.
@@ -81,18 +82,20 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   using view_2d_table = typename KT::template view_2d_table<Scalar, C::VTABLE_DIM0, C::VTABLE_DIM1>;
 
   // ice lookup table values
-  using view_ice_table =
-      typename KT::template view<const Scalar[P3C::densize][P3C::rimsize][P3C::isize][P3C::ice_table_size]>;
+  using view_ice_table = typename KT::template view<
+      const Scalar[P3C::densize][P3C::rimsize][P3C::isize][P3C::ice_table_size]>;
 
   // ice lookup table values for ice-rain collision/collection
-  using view_collect_table = typename KT::template view<
-      const Scalar[P3C::densize][P3C::rimsize][P3C::isize][P3C::rcollsize][P3C::collect_table_size]>;
+  using view_collect_table =
+      typename KT::template view<const Scalar[P3C::densize][P3C::rimsize][P3C::isize]
+                                             [P3C::rcollsize][P3C::collect_table_size]>;
 
   // droplet spectral shape parameter for mass spectra, used for Seifert and Beheng (2001)
   // warm rain autoconversion/accretion option only (iparam = 1)
   using view_dnu_table = typename KT::template view_1d_table<Scalar, P3C::dnusize>;
 
-  template <typename S, int N> using view_1d_ptr_array = typename KT::template view_1d_ptr_carray<S, N>;
+  template <typename S, int N>
+  using view_1d_ptr_array = typename KT::template view_1d_ptr_carray<S, N>;
 
   template <typename S> using uview_1d = typename ekat::template Unmanaged<view_1d<S>>;
   template <typename S> using uview_2d = typename ekat::template Unmanaged<view_2d<S>>;
@@ -134,18 +137,21 @@ template <typename ScalarT, typename DeviceT> struct Functions {
     bool extra_p3_diags                         = false;
 
     void load_runtime_options_from_file(ekat::ParameterList &params) {
-      max_total_ni               = params.get<double>("max_total_ni", max_total_ni);
-      autoconversion_prefactor   = params.get<double>("autoconversion_prefactor", autoconversion_prefactor);
-      autoconversion_qc_exponent = params.get<double>("autoconversion_qc_exponent", autoconversion_qc_exponent);
-      autoconversion_nc_exponent = params.get<double>("autoconversion_nc_exponent", autoconversion_nc_exponent);
-      autoconversion_radius      = params.get<double>("autoconversion_radius", autoconversion_radius);
-      accretion_prefactor        = params.get<double>("accretion_prefactor", accretion_prefactor);
-      accretion_qc_exponent      = params.get<double>("accretion_qc_exponent", accretion_qc_exponent);
-      accretion_qr_exponent      = params.get<double>("accretion_qr_exponent", accretion_qr_exponent);
+      max_total_ni = params.get<double>("max_total_ni", max_total_ni);
+      autoconversion_prefactor =
+          params.get<double>("autoconversion_prefactor", autoconversion_prefactor);
+      autoconversion_qc_exponent =
+          params.get<double>("autoconversion_qc_exponent", autoconversion_qc_exponent);
+      autoconversion_nc_exponent =
+          params.get<double>("autoconversion_nc_exponent", autoconversion_nc_exponent);
+      autoconversion_radius = params.get<double>("autoconversion_radius", autoconversion_radius);
+      accretion_prefactor   = params.get<double>("accretion_prefactor", accretion_prefactor);
+      accretion_qc_exponent = params.get<double>("accretion_qc_exponent", accretion_qc_exponent);
+      accretion_qr_exponent = params.get<double>("accretion_qr_exponent", accretion_qr_exponent);
       rain_selfcollection_prefactor =
           params.get<double>("rain_selfcollection_prefactor", rain_selfcollection_prefactor);
-      rain_selfcollection_breakup_diameter =
-          params.get<double>("rain_selfcollection_breakup_diameter", rain_selfcollection_breakup_diameter);
+      rain_selfcollection_breakup_diameter = params.get<double>(
+          "rain_selfcollection_breakup_diameter", rain_selfcollection_breakup_diameter);
       constant_mu_rain       = params.get<double>("constant_mu_rain", constant_mu_rain);
       spa_ccn_to_nc_factor   = params.get<double>("spa_ccn_to_nc_factor", spa_ccn_to_nc_factor);
       spa_ccn_to_nc_exponent = params.get<double>("spa_ccn_to_nc_exponent", spa_ccn_to_nc_exponent);
@@ -153,19 +159,22 @@ template <typename ScalarT, typename DeviceT> struct Functions {
           params.get<double>("cldliq_to_ice_collection_factor", cldliq_to_ice_collection_factor);
       rain_to_ice_collection_factor =
           params.get<double>("rain_to_ice_collection_factor", rain_to_ice_collection_factor);
-      min_rime_rho                = params.get<double>("min_rime_rho", min_rime_rho);
-      max_rime_rho                = params.get<double>("max_rime_rho", max_rime_rho);
-      immersion_freezing_exponent = params.get<double>("immersion_freezing_exponent", immersion_freezing_exponent);
+      min_rime_rho = params.get<double>("min_rime_rho", min_rime_rho);
+      max_rime_rho = params.get<double>("max_rime_rho", max_rime_rho);
+      immersion_freezing_exponent =
+          params.get<double>("immersion_freezing_exponent", immersion_freezing_exponent);
       deposition_nucleation_exponent =
           params.get<double>("deposition_nucleation_exponent", deposition_nucleation_exponent);
-      ice_sedimentation_factor  = params.get<double>("ice_sedimentation_factor", ice_sedimentation_factor);
-      do_ice_production         = params.get<bool>("do_ice_production", do_ice_production);
-      set_cld_frac_l_to_one     = params.get<bool>("set_cld_frac_l_to_one", set_cld_frac_l_to_one);
-      set_cld_frac_i_to_one     = params.get<bool>("set_cld_frac_i_to_one", set_cld_frac_i_to_one);
-      set_cld_frac_r_to_one     = params.get<bool>("set_cld_frac_r_to_one", set_cld_frac_r_to_one);
-      use_hetfrz_classnuc       = params.get<bool>("use_hetfrz_classnuc", use_hetfrz_classnuc);
-      use_separate_ice_liq_frac = params.get<bool>("use_separate_ice_liq_frac", use_separate_ice_liq_frac);
-      extra_p3_diags            = params.get<bool>("extra_p3_diags", extra_p3_diags);
+      ice_sedimentation_factor =
+          params.get<double>("ice_sedimentation_factor", ice_sedimentation_factor);
+      do_ice_production     = params.get<bool>("do_ice_production", do_ice_production);
+      set_cld_frac_l_to_one = params.get<bool>("set_cld_frac_l_to_one", set_cld_frac_l_to_one);
+      set_cld_frac_i_to_one = params.get<bool>("set_cld_frac_i_to_one", set_cld_frac_i_to_one);
+      set_cld_frac_r_to_one = params.get<bool>("set_cld_frac_r_to_one", set_cld_frac_r_to_one);
+      use_hetfrz_classnuc   = params.get<bool>("use_hetfrz_classnuc", use_hetfrz_classnuc);
+      use_separate_ice_liq_frac =
+          params.get<bool>("use_separate_ice_liq_frac", use_separate_ice_liq_frac);
+      extra_p3_diags = params.get<bool>("extra_p3_diags", extra_p3_diags);
     }
   };
 
@@ -387,44 +396,49 @@ template <typename ScalarT, typename DeviceT> struct Functions {
 
   // Call to get global tables
   static void get_global_tables(view_2d_table &vn_table_vals, view_2d_table &vm_table_vals,
-                                view_2d_table &revap_table_vals, view_1d_table &mu_r_table_vals, view_dnu_table &dnu);
+                                view_2d_table &revap_table_vals, view_1d_table &mu_r_table_vals,
+                                view_dnu_table &dnu);
 
-  static void get_global_ice_lookup_tables(view_ice_table &ice_table_vals, view_collect_table &collect_table_vals);
+  static void get_global_ice_lookup_tables(view_ice_table &ice_table_vals,
+                                           view_collect_table &collect_table_vals);
 
   static P3LookupTables p3_init(const bool write_tables = false, const bool masterproc = false);
 
   // Map (mu_r, lamr) to Table3 data.
   KOKKOS_FUNCTION
-  static void lookup(const Spack &mu_r, const Spack &lamr, Table3 &tab, const Smask &context = Smask(true));
+  static void lookup(const Spack &mu_r, const Spack &lamr, Table3 &tab,
+                     const Smask &context = Smask(true));
 
   // Converts quantities to cell averages
   KOKKOS_FUNCTION
-  static void back_to_cell_average(const Spack &cld_frac_l, const Spack &cld_frac_r, const Spack &cld_frac_i,
-                                   Spack &qc2qr_accret_tend, Spack &qr2qv_evap_tend, Spack &qc2qr_autoconv_tend,
-                                   Spack &nc_accret_tend, Spack &nc_selfcollect_tend, Spack &nc2nr_autoconv_tend,
-                                   Spack &nr_selfcollect_tend, Spack &nr_evap_tend, Spack &ncautr,
-                                   Spack &qi2qv_sublim_tend, Spack &nr_ice_shed_tend, Spack &qc2qi_hetero_freeze_tend,
-                                   Spack &qr2qi_collect_tend, Spack &qc2qr_ice_shed_tend, Spack &qi2qr_melt_tend,
-                                   Spack &qc2qi_collect_tend, Spack &qr2qi_immers_freeze_tend, Spack &ni2nr_melt_tend,
-                                   Spack &nc_collect_tend, Spack &ncshdc, Spack &nc2ni_immers_freeze_tend,
-                                   Spack &nr_collect_tend, Spack &ni_selfcollect_tend, Spack &qv2qi_vapdep_tend,
-                                   Spack &nr2ni_immers_freeze_tend, Spack &ni_sublim_tend, Spack &qv2qi_nucleat_tend,
-                                   Spack &ni_nucleat_tend, Spack &qc2qi_berg_tend, Spack &ncheti_cnt, Spack &qcheti_cnt,
-                                   Spack &nicnt, Spack &qicnt, Spack &ninuc_cnt, Spack &qinuc_cnt,
-                                   const Smask &context = Smask(true), const P3Runtime &runtime_options = {});
+  static void back_to_cell_average(
+      const Spack &cld_frac_l, const Spack &cld_frac_r, const Spack &cld_frac_i,
+      Spack &qc2qr_accret_tend, Spack &qr2qv_evap_tend, Spack &qc2qr_autoconv_tend,
+      Spack &nc_accret_tend, Spack &nc_selfcollect_tend, Spack &nc2nr_autoconv_tend,
+      Spack &nr_selfcollect_tend, Spack &nr_evap_tend, Spack &ncautr, Spack &qi2qv_sublim_tend,
+      Spack &nr_ice_shed_tend, Spack &qc2qi_hetero_freeze_tend, Spack &qr2qi_collect_tend,
+      Spack &qc2qr_ice_shed_tend, Spack &qi2qr_melt_tend, Spack &qc2qi_collect_tend,
+      Spack &qr2qi_immers_freeze_tend, Spack &ni2nr_melt_tend, Spack &nc_collect_tend,
+      Spack &ncshdc, Spack &nc2ni_immers_freeze_tend, Spack &nr_collect_tend,
+      Spack &ni_selfcollect_tend, Spack &qv2qi_vapdep_tend, Spack &nr2ni_immers_freeze_tend,
+      Spack &ni_sublim_tend, Spack &qv2qi_nucleat_tend, Spack &ni_nucleat_tend,
+      Spack &qc2qi_berg_tend, Spack &ncheti_cnt, Spack &qcheti_cnt, Spack &nicnt, Spack &qicnt,
+      Spack &ninuc_cnt, Spack &qinuc_cnt, const Smask &context = Smask(true),
+      const P3Runtime &runtime_options = {});
 
   //------------------------------------------------------------------------------------------!
   // Finds indices in 3D ice (only) lookup table
   // ------------------------------------------------------------------------------------------!
   KOKKOS_FUNCTION
-  static void lookup_ice(const Spack &qi, const Spack &ni, const Spack &qm, const Spack &rhop, TableIce &tab,
-                         const Smask &context = Smask(true));
+  static void lookup_ice(const Spack &qi, const Spack &ni, const Spack &qm, const Spack &rhop,
+                         TableIce &tab, const Smask &context = Smask(true));
 
   //------------------------------------------------------------------------------------------!
   // Finds indices in 3D rain lookup table
   //------------------------------------------------------------------------------------------!
   KOKKOS_FUNCTION
-  static void lookup_rain(const Spack &qr, const Spack &nr, TableRain &tab, const Smask &context = Smask(true));
+  static void lookup_rain(const Spack &qr, const Spack &nr, TableRain &tab,
+                          const Smask &context = Smask(true));
 
   // Apply Table3 data to the table to return a value. This performs bilinear
   // interpolation within the quad given by {tab.dumii, tab.dumjj} x {t.dumii+1,
@@ -434,13 +448,14 @@ template <typename ScalarT, typename DeviceT> struct Functions {
 
   // Apply TableIce data to the ice tables to return a value.
   KOKKOS_FUNCTION
-  static Spack apply_table_ice(const int &index, const view_ice_table &ice_table_vals, const TableIce &tab,
-                               const Smask &context = Smask(true));
+  static Spack apply_table_ice(const int &index, const view_ice_table &ice_table_vals,
+                               const TableIce &tab, const Smask &context = Smask(true));
 
   // Interpolates lookup table values for rain/ice collection processes
   KOKKOS_FUNCTION
-  static Spack apply_table_coll(const int &index, const view_collect_table &collect_table_vals, const TableIce &ti,
-                                const TableRain &tr, const Smask &context = Smask(true));
+  static Spack apply_table_coll(const int &index, const view_collect_table &collect_table_vals,
+                                const TableIce &ti, const TableRain &tr,
+                                const Smask &context = Smask(true));
 
   // -- Sedimentation time step
 
@@ -462,8 +477,9 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   KOKKOS_FUNCTION static void
   calc_first_order_upwind_step(const uview_1d<const Spack> &rho,
                                const uview_1d<const Spack> &inv_rho, // 1/rho
-                               const uview_1d<const Spack> &inv_dz, const MemberType &team, const Int &nk,
-                               const Int &k_bot, const Int &k_top, const Int &kdir, const Scalar &dt_sub,
+                               const uview_1d<const Spack> &inv_dz, const MemberType &team,
+                               const Int &nk, const Int &k_bot, const Int &k_top, const Int &kdir,
+                               const Scalar &dt_sub,
                                const view_1d_ptr_array<Spack, nfield> &flux, // workspace
                                const view_1d_ptr_array<Spack, nfield> &V,    // (behaviorally const)
                                const view_1d_ptr_array<Spack, nfield> &r);   // in/out
@@ -472,126 +488,137 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   KOKKOS_FUNCTION
   static void calc_first_order_upwind_step(const uview_1d<const Spack> &rho,
                                            const uview_1d<const Spack> &inv_rho, // 1/rho
-                                           const uview_1d<const Spack> &inv_dz, const MemberType &team, const Int &nk,
-                                           const Int &k_bot, const Int &k_top, const Int &kdir, const Scalar &dt_sub,
-                                           const uview_1d<Spack> &flux, const uview_1d<const Spack> &V,
+                                           const uview_1d<const Spack> &inv_dz,
+                                           const MemberType &team, const Int &nk, const Int &k_bot,
+                                           const Int &k_top, const Int &kdir, const Scalar &dt_sub,
+                                           const uview_1d<Spack> &flux,
+                                           const uview_1d<const Spack> &V,
                                            const uview_1d<Spack> &r);
 
   // This is the main routine. It can be called by the user if kdir is known at
   // compile time. So far it is not, so the above versions are called instead.
   template <Int kdir, int nfield>
   KOKKOS_FUNCTION static void calc_first_order_upwind_step(
-      const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &inv_dz,
-      const MemberType &team, const Int &nk, const Int &k_bot, const Int &k_top, const Scalar &dt_sub,
-      const view_1d_ptr_array<Spack, nfield> &flux, const view_1d_ptr_array<Spack, nfield> &V, // (behaviorally const)
+      const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
+      const uview_1d<const Spack> &inv_dz, const MemberType &team, const Int &nk, const Int &k_bot,
+      const Int &k_top, const Scalar &dt_sub, const view_1d_ptr_array<Spack, nfield> &flux,
+      const view_1d_ptr_array<Spack, nfield> &V, // (behaviorally const)
       const view_1d_ptr_array<Spack, nfield> &r);
 
   template <int nfield>
   KOKKOS_FUNCTION static void
   generalized_sedimentation(const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
-                            const uview_1d<const Spack> &inv_dz, const MemberType &team, const Int &nk,
-                            const Int &k_qxtop, Int &k_qxbot, const Int &kbot, const Int &kdir, const Scalar &Co_max,
-                            Scalar &dt_left, Scalar &prt_accum, const view_1d_ptr_array<Spack, nfield> &fluxes,
+                            const uview_1d<const Spack> &inv_dz, const MemberType &team,
+                            const Int &nk, const Int &k_qxtop, Int &k_qxbot, const Int &kbot,
+                            const Int &kdir, const Scalar &Co_max, Scalar &dt_left,
+                            Scalar &prt_accum, const view_1d_ptr_array<Spack, nfield> &fluxes,
                             const view_1d_ptr_array<Spack, nfield> &Vs, // (behaviorally const)
                             const view_1d_ptr_array<Spack, nfield> &rs);
 
   // Cloud sedimentation
   KOKKOS_FUNCTION
-  static void cloud_sedimentation(const uview_1d<Spack> &qc_incld, const uview_1d<const Spack> &rho,
-                                  const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &cld_frac_l,
-                                  const uview_1d<const Spack> &acn, const uview_1d<const Spack> &inv_dz,
-                                  const view_dnu_table &dnu, const MemberType &team, const Workspace &workspace,
-                                  const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
-                                  const Scalar &inv_dt, const bool &do_predict_nc, const uview_1d<Spack> &qc,
-                                  const uview_1d<Spack> &nc, const uview_1d<Spack> &nc_incld,
-                                  const uview_1d<Spack> &mu_c, const uview_1d<Spack> &lamc,
-                                  const uview_1d<Spack> &qc_tend, const uview_1d<Spack> &nc_tend,
-                                  Scalar &precip_liq_surf);
+  static void cloud_sedimentation(
+      const uview_1d<Spack> &qc_incld, const uview_1d<const Spack> &rho,
+      const uview_1d<const Spack> &inv_rho, const uview_1d<const Spack> &cld_frac_l,
+      const uview_1d<const Spack> &acn, const uview_1d<const Spack> &inv_dz,
+      const view_dnu_table &dnu, const MemberType &team, const Workspace &workspace, const Int &nk,
+      const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt, const Scalar &inv_dt,
+      const bool &do_predict_nc, const uview_1d<Spack> &qc, const uview_1d<Spack> &nc,
+      const uview_1d<Spack> &nc_incld, const uview_1d<Spack> &mu_c, const uview_1d<Spack> &lamc,
+      const uview_1d<Spack> &qc_tend, const uview_1d<Spack> &nc_tend, Scalar &precip_liq_surf);
 
 #ifdef SCREAM_P3_SMALL_KERNELS
   static void cloud_sedimentation_disp(
-      const uview_2d<Spack> &qc_incld, const uview_2d<const Spack> &rho, const uview_2d<const Spack> &inv_rho,
-      const uview_2d<const Spack> &cld_frac_l, const uview_2d<const Spack> &acn, const uview_2d<const Spack> &inv_dz,
-      const view_dnu_table &dnu, const WorkspaceManager &workspace_mgr, const Int &nj, const Int &nk, const Int &ktop,
-      const Int &kbot, const Int &kdir, const Scalar &dt, const Scalar &inv_dt, const bool &do_predict_nc,
-      const uview_2d<Spack> &qc, const uview_2d<Spack> &nc, const uview_2d<Spack> &nc_incld,
-      const uview_2d<Spack> &mu_c, const uview_2d<Spack> &lamc, const uview_2d<Spack> &qc_tend,
-      const uview_2d<Spack> &nc_tend, const uview_1d<Scalar> &precip_liq_surf,
-      const uview_1d<bool> &is_nucleat_possible, const uview_1d<bool> &is_hydromet_present);
+      const uview_2d<Spack> &qc_incld, const uview_2d<const Spack> &rho,
+      const uview_2d<const Spack> &inv_rho, const uview_2d<const Spack> &cld_frac_l,
+      const uview_2d<const Spack> &acn, const uview_2d<const Spack> &inv_dz,
+      const view_dnu_table &dnu, const WorkspaceManager &workspace_mgr, const Int &nj,
+      const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
+      const Scalar &inv_dt, const bool &do_predict_nc, const uview_2d<Spack> &qc,
+      const uview_2d<Spack> &nc, const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &mu_c,
+      const uview_2d<Spack> &lamc, const uview_2d<Spack> &qc_tend, const uview_2d<Spack> &nc_tend,
+      const uview_1d<Scalar> &precip_liq_surf, const uview_1d<bool> &is_nucleat_possible,
+      const uview_1d<bool> &is_hydromet_present);
 #endif
 
   // TODO: comment
   KOKKOS_FUNCTION
-  static void rain_sedimentation(const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
-                                 const uview_1d<const Spack> &rhofacr, const uview_1d<const Spack> &cld_frac_r,
-                                 const uview_1d<const Spack> &inv_dz, const uview_1d<Spack> &qr_incld,
-                                 const MemberType &team, const Workspace &workspace, const view_2d_table &vn_table_vals,
-                                 const view_2d_table &vm_table_vals, const Int &nk, const Int &ktop, const Int &kbot,
-                                 const Int &kdir, const Scalar &dt, const Scalar &inv_dt, const uview_1d<Spack> &qr,
-                                 const uview_1d<Spack> &nr, const uview_1d<Spack> &nr_incld,
-                                 const uview_1d<Spack> &mu_r, const uview_1d<Spack> &lamr,
-                                 const uview_1d<Spack> &precip_liq_flux, const uview_1d<Spack> &qr_tend,
-                                 const uview_1d<Spack> &nr_tend, Scalar &precip_liq_surf,
-                                 const P3Runtime &runtime_options);
+  static void rain_sedimentation(
+      const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
+      const uview_1d<const Spack> &rhofacr, const uview_1d<const Spack> &cld_frac_r,
+      const uview_1d<const Spack> &inv_dz, const uview_1d<Spack> &qr_incld, const MemberType &team,
+      const Workspace &workspace, const view_2d_table &vn_table_vals,
+      const view_2d_table &vm_table_vals, const Int &nk, const Int &ktop, const Int &kbot,
+      const Int &kdir, const Scalar &dt, const Scalar &inv_dt, const uview_1d<Spack> &qr,
+      const uview_1d<Spack> &nr, const uview_1d<Spack> &nr_incld, const uview_1d<Spack> &mu_r,
+      const uview_1d<Spack> &lamr, const uview_1d<Spack> &precip_liq_flux,
+      const uview_1d<Spack> &qr_tend, const uview_1d<Spack> &nr_tend, Scalar &precip_liq_surf,
+      const P3Runtime &runtime_options);
 
 #ifdef SCREAM_P3_SMALL_KERNELS
   static void rain_sedimentation_disp(
-      const uview_2d<const Spack> &rho, const uview_2d<const Spack> &inv_rho, const uview_2d<const Spack> &rhofacr,
-      const uview_2d<const Spack> &cld_frac_r, const uview_2d<const Spack> &inv_dz, const uview_2d<Spack> &qr_incld,
-      const WorkspaceManager &workspace_mgr, const view_2d_table &vn_table_vals, const view_2d_table &vm_table_vals,
-      const Int &nj, const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
-      const Scalar &inv_dt, const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &nr_incld,
-      const uview_2d<Spack> &mu_r, const uview_2d<Spack> &lamr, const uview_2d<Spack> &precip_liq_flux,
-      const uview_2d<Spack> &qr_tend, const uview_2d<Spack> &nr_tend, const uview_1d<Scalar> &precip_liq_surf,
+      const uview_2d<const Spack> &rho, const uview_2d<const Spack> &inv_rho,
+      const uview_2d<const Spack> &rhofacr, const uview_2d<const Spack> &cld_frac_r,
+      const uview_2d<const Spack> &inv_dz, const uview_2d<Spack> &qr_incld,
+      const WorkspaceManager &workspace_mgr, const view_2d_table &vn_table_vals,
+      const view_2d_table &vm_table_vals, const Int &nj, const Int &nk, const Int &ktop,
+      const Int &kbot, const Int &kdir, const Scalar &dt, const Scalar &inv_dt,
+      const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &nr_incld,
+      const uview_2d<Spack> &mu_r, const uview_2d<Spack> &lamr,
+      const uview_2d<Spack> &precip_liq_flux, const uview_2d<Spack> &qr_tend,
+      const uview_2d<Spack> &nr_tend, const uview_1d<Scalar> &precip_liq_surf,
       const uview_1d<bool> &is_nucleat_possible, const uview_1d<bool> &is_hydromet_present,
       const P3Runtime &runtime_options);
 #endif
 
   // TODO: comment
   KOKKOS_FUNCTION
-  static void ice_sedimentation(const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
-                                const uview_1d<const Spack> &rhofaci, const uview_1d<const Spack> &cld_frac_i,
-                                const uview_1d<const Spack> &inv_dz, const MemberType &team, const Workspace &workspace,
-                                const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
-                                const Scalar &inv_dt, const uview_1d<Spack> &qi, const uview_1d<Spack> &qi_incld,
-                                const uview_1d<Spack> &ni, const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &qm,
-                                const uview_1d<Spack> &qm_incld, const uview_1d<Spack> &bm,
-                                const uview_1d<Spack> &bm_incld, const uview_1d<Spack> &qi_tend,
-                                const uview_1d<Spack> &ni_tend, const view_ice_table &ice_table_vals,
-                                Scalar &precip_ice_surf, const P3Runtime &runtime_options);
+  static void ice_sedimentation(
+      const uview_1d<const Spack> &rho, const uview_1d<const Spack> &inv_rho,
+      const uview_1d<const Spack> &rhofaci, const uview_1d<const Spack> &cld_frac_i,
+      const uview_1d<const Spack> &inv_dz, const MemberType &team, const Workspace &workspace,
+      const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
+      const Scalar &inv_dt, const uview_1d<Spack> &qi, const uview_1d<Spack> &qi_incld,
+      const uview_1d<Spack> &ni, const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &qm,
+      const uview_1d<Spack> &qm_incld, const uview_1d<Spack> &bm, const uview_1d<Spack> &bm_incld,
+      const uview_1d<Spack> &qi_tend, const uview_1d<Spack> &ni_tend,
+      const view_ice_table &ice_table_vals, Scalar &precip_ice_surf,
+      const P3Runtime &runtime_options);
 
 #ifdef SCREAM_P3_SMALL_KERNELS
-  static void ice_sedimentation_disp(const uview_2d<const Spack> &rho, const uview_2d<const Spack> &inv_rho,
-                                     const uview_2d<const Spack> &rhofaci, const uview_2d<const Spack> &cld_frac_i,
-                                     const uview_2d<const Spack> &inv_dz, const WorkspaceManager &workspace_mgr,
-                                     const Int &nj, const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir,
-                                     const Scalar &dt, const Scalar &inv_dt, const uview_2d<Spack> &qi,
-                                     const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &ni,
-                                     const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &qm,
-                                     const uview_2d<Spack> &qm_incld, const uview_2d<Spack> &bm,
-                                     const uview_2d<Spack> &bm_incld, const uview_2d<Spack> &qi_tend,
-                                     const uview_2d<Spack> &ni_tend, const view_ice_table &ice_table_vals,
-                                     const uview_1d<Scalar> &precip_ice_surf, const uview_1d<bool> &is_nucleat_possible,
-                                     const uview_1d<bool> &is_hydromet_present, const P3Runtime &runtime_options);
+  static void ice_sedimentation_disp(
+      const uview_2d<const Spack> &rho, const uview_2d<const Spack> &inv_rho,
+      const uview_2d<const Spack> &rhofaci, const uview_2d<const Spack> &cld_frac_i,
+      const uview_2d<const Spack> &inv_dz, const WorkspaceManager &workspace_mgr, const Int &nj,
+      const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const Scalar &dt,
+      const Scalar &inv_dt, const uview_2d<Spack> &qi, const uview_2d<Spack> &qi_incld,
+      const uview_2d<Spack> &ni, const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &qm,
+      const uview_2d<Spack> &qm_incld, const uview_2d<Spack> &bm, const uview_2d<Spack> &bm_incld,
+      const uview_2d<Spack> &qi_tend, const uview_2d<Spack> &ni_tend,
+      const view_ice_table &ice_table_vals, const uview_1d<Scalar> &precip_ice_surf,
+      const uview_1d<bool> &is_nucleat_possible, const uview_1d<bool> &is_hydromet_present,
+      const P3Runtime &runtime_options);
 #endif
 
   // homogeneous freezing of cloud and rain
   KOKKOS_FUNCTION
-  static void homogeneous_freezing(const uview_1d<const Spack> &T_atm, const uview_1d<const Spack> &inv_exner,
-                                   const MemberType &team, const Int &nk, const Int &ktop, const Int &kbot,
-                                   const Int &kdir, const uview_1d<Spack> &qc, const uview_1d<Spack> &nc,
-                                   const uview_1d<Spack> &qr, const uview_1d<Spack> &nr, const uview_1d<Spack> &qi,
-                                   const uview_1d<Spack> &ni, const uview_1d<Spack> &qm, const uview_1d<Spack> &bm,
+  static void homogeneous_freezing(const uview_1d<const Spack> &T_atm,
+                                   const uview_1d<const Spack> &inv_exner, const MemberType &team,
+                                   const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir,
+                                   const uview_1d<Spack> &qc, const uview_1d<Spack> &nc,
+                                   const uview_1d<Spack> &qr, const uview_1d<Spack> &nr,
+                                   const uview_1d<Spack> &qi, const uview_1d<Spack> &ni,
+                                   const uview_1d<Spack> &qm, const uview_1d<Spack> &bm,
                                    const uview_1d<Spack> &th_atm);
 
 #ifdef SCREAM_P3_SMALL_KERNELS
-  static void homogeneous_freezing_disp(const uview_2d<const Spack> &T_atm, const uview_2d<const Spack> &inv_exner,
-                                        const Int &nj, const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir,
-                                        const uview_2d<Spack> &qc, const uview_2d<Spack> &nc, const uview_2d<Spack> &qr,
-                                        const uview_2d<Spack> &nr, const uview_2d<Spack> &qi, const uview_2d<Spack> &ni,
-                                        const uview_2d<Spack> &qm, const uview_2d<Spack> &bm,
-                                        const uview_2d<Spack> &th_atm, const uview_1d<bool> &is_nucleat_possible,
-                                        const uview_1d<bool> &is_hydromet_present);
+  static void homogeneous_freezing_disp(
+      const uview_2d<const Spack> &T_atm, const uview_2d<const Spack> &inv_exner, const Int &nj,
+      const Int &nk, const Int &ktop, const Int &kbot, const Int &kdir, const uview_2d<Spack> &qc,
+      const uview_2d<Spack> &nc, const uview_2d<Spack> &qr, const uview_2d<Spack> &nr,
+      const uview_2d<Spack> &qi, const uview_2d<Spack> &ni, const uview_2d<Spack> &qm,
+      const uview_2d<Spack> &bm, const uview_2d<Spack> &th_atm,
+      const uview_1d<bool> &is_nucleat_possible, const uview_1d<bool> &is_hydromet_present);
 #endif
 
   // -- Find layers
@@ -599,35 +626,39 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   // Find the bottom and top of the mixing ratio, e.g., qr. It's worth casing
   // these out in two ways: 1 thread/column vs many, and by kdir.
   KOKKOS_FUNCTION
-  static Int find_bottom(const MemberType &team, const uview_1d<const Scalar> &v, const Scalar &small, const Int &kbot,
-                         const Int &ktop, const Int &kdir, bool &log_present);
+  static Int find_bottom(const MemberType &team, const uview_1d<const Scalar> &v,
+                         const Scalar &small, const Int &kbot, const Int &ktop, const Int &kdir,
+                         bool &log_present);
 
   KOKKOS_FUNCTION
-  static Int find_top(const MemberType &team, const uview_1d<const Scalar> &v, const Scalar &small, const Int &kbot,
-                      const Int &ktop, const Int &kdir, bool &log_present);
+  static Int find_top(const MemberType &team, const uview_1d<const Scalar> &v, const Scalar &small,
+                      const Int &kbot, const Int &ktop, const Int &kdir, bool &log_present);
 
   KOKKOS_FUNCTION
-  static void cloud_water_conservation(const Spack &qc, const Scalar dt, Spack &qc2qr_autoconv_tend,
-                                       Spack &qc2qr_accret_tend, Spack &qc2qi_collect_tend,
-                                       Spack &qc2qi_hetero_freeze_tend, Spack &qc2qr_ice_shed_tend,
-                                       Spack &qc2qi_berg_tend, Spack &qi2qv_sublim_tend, Spack &qv2qi_vapdep_tend,
-                                       Spack &qcheti_cnt, Spack &qicnt, const bool &use_hetfrz_classnuc,
-                                       const Smask &context = Smask(true), const Spack &cld_frac_l = Spack(),
-                                       const Spack &cld_frac_i = Spack(), const P3Runtime &runtime_options = {});
+  static void cloud_water_conservation(
+      const Spack &qc, const Scalar dt, Spack &qc2qr_autoconv_tend, Spack &qc2qr_accret_tend,
+      Spack &qc2qi_collect_tend, Spack &qc2qi_hetero_freeze_tend, Spack &qc2qr_ice_shed_tend,
+      Spack &qc2qi_berg_tend, Spack &qi2qv_sublim_tend, Spack &qv2qi_vapdep_tend, Spack &qcheti_cnt,
+      Spack &qicnt, const bool &use_hetfrz_classnuc, const Smask &context = Smask(true),
+      const Spack &cld_frac_l = Spack(), const Spack &cld_frac_i = Spack(),
+      const P3Runtime &runtime_options = {});
 
   KOKKOS_FUNCTION
-  static void rain_water_conservation(const Spack &qr, const Spack &qc2qr_autoconv_tend, const Spack &qc2qr_accret_tend,
-                                      const Spack &qi2qr_melt_tend, const Spack &qc2qr_ice_shed_tend, const Scalar dt,
+  static void rain_water_conservation(const Spack &qr, const Spack &qc2qr_autoconv_tend,
+                                      const Spack &qc2qr_accret_tend, const Spack &qi2qr_melt_tend,
+                                      const Spack &qc2qr_ice_shed_tend, const Scalar dt,
                                       Spack &qr2qv_evap_tend, Spack &qr2qi_collect_tend,
-                                      Spack &qr2qi_immers_freeze_tend, const Smask &context = Smask(true));
+                                      Spack &qr2qi_immers_freeze_tend,
+                                      const Smask &context = Smask(true));
 
   KOKKOS_FUNCTION
-  static void ice_water_conservation(const Spack &qi, const Spack &qv2qi_vapdep_tend, const Spack &qv2qi_nucleat_tend,
-                                     const Spack &qc2qi_berg_tend, const Spack &qr2qi_collect_tend,
-                                     const Spack &qc2qi_collect_tend, const Spack &qr2qi_immers_freeze_tend,
-                                     const Spack &qc2qi_hetero_freeze_tend, const Scalar dt, Spack &qinuc_cnt,
-                                     Spack &qcheti_cnt, Spack &qicnt, Spack &qi2qv_sublim_tend, Spack &qi2qr_melt_tend,
-                                     const bool &use_hetfrz_classnuc, const Smask &context = Smask(true));
+  static void ice_water_conservation(
+      const Spack &qi, const Spack &qv2qi_vapdep_tend, const Spack &qv2qi_nucleat_tend,
+      const Spack &qc2qi_berg_tend, const Spack &qr2qi_collect_tend,
+      const Spack &qc2qi_collect_tend, const Spack &qr2qi_immers_freeze_tend,
+      const Spack &qc2qi_hetero_freeze_tend, const Scalar dt, Spack &qinuc_cnt, Spack &qcheti_cnt,
+      Spack &qicnt, Spack &qi2qv_sublim_tend, Spack &qi2qr_melt_tend,
+      const bool &use_hetfrz_classnuc, const Smask &context = Smask(true));
 
   // TODO: comment
   KOKKOS_FUNCTION
@@ -637,60 +668,70 @@ template <typename ScalarT, typename DeviceT> struct Functions {
 
   // Computes and returns rain size distribution parameters
   KOKKOS_FUNCTION
-  static void get_rain_dsd2(const Spack &qr, Spack &nr, Spack &mu_r, Spack &lamr, const P3Runtime &runtime_options,
-                            const Smask &context = Smask(true));
+  static void get_rain_dsd2(const Spack &qr, Spack &nr, Spack &mu_r, Spack &lamr,
+                            const P3Runtime &runtime_options, const Smask &context = Smask(true));
 
   // Computes and returns additional rain size distribution parameters
   KOKKOS_FUNCTION
-  static void get_cdistr_logn0r(const Spack &qr, const Spack &nr, const Spack &mu_r, const Spack &lamr, Spack &cdistr,
-                                Spack &logn0r, const Smask &context = Smask(true));
+  static void get_cdistr_logn0r(const Spack &qr, const Spack &nr, const Spack &mu_r,
+                                const Spack &lamr, Spack &cdistr, Spack &logn0r,
+                                const Smask &context = Smask(true));
 
   // Calculates rime density
   KOKKOS_FUNCTION
-  static void calc_rime_density(const Spack &T_atm, const Spack &rhofaci, const Spack &table_val_qi_fallspd,
-                                const Spack &acn, const Spack &lamc, const Spack &mu_c, const Spack &qc_incld,
+  static void calc_rime_density(const Spack &T_atm, const Spack &rhofaci,
+                                const Spack &table_val_qi_fallspd, const Spack &acn,
+                                const Spack &lamc, const Spack &mu_c, const Spack &qc_incld,
                                 const Spack &qc2qi_collect_tend, Spack &vtrmi1, Spack &rho_qm_cloud,
                                 const Smask &context = Smask(true));
 
   // Computes contact and immersion freezing droplets
   KOKKOS_FUNCTION
-  static void cldliq_immersion_freezing(const Spack &T_atm, const Spack &lamc, const Spack &mu_c, const Spack &cdist1,
-                                        const Spack &qc_incld, const Spack &inv_qc_relvar,
-                                        Spack &qc2qi_hetero_freeze_tend, Spack &nc2ni_immers_freeze_tend,
-                                        const P3Runtime &runtime_options, const Smask &context = Smask(true));
+  static void cldliq_immersion_freezing(const Spack &T_atm, const Spack &lamc, const Spack &mu_c,
+                                        const Spack &cdist1, const Spack &qc_incld,
+                                        const Spack &inv_qc_relvar, Spack &qc2qi_hetero_freeze_tend,
+                                        Spack &nc2ni_immers_freeze_tend,
+                                        const P3Runtime &runtime_options,
+                                        const Smask &context = Smask(true));
 
   // Computes the immersion freezing of rain
   KOKKOS_FUNCTION
-  static void rain_immersion_freezing(const Spack &T_atm, const Spack &lamr, const Spack &mu_r, const Spack &cdistr,
-                                      const Spack &qr_incld, Spack &qr2qi_immers_freeze_tend,
-                                      Spack &nr2ni_immers_freeze_tend, const P3Runtime &runtime_options,
+  static void rain_immersion_freezing(const Spack &T_atm, const Spack &lamr, const Spack &mu_r,
+                                      const Spack &cdistr, const Spack &qr_incld,
+                                      Spack &qr2qi_immers_freeze_tend,
+                                      Spack &nr2ni_immers_freeze_tend,
+                                      const P3Runtime &runtime_options,
                                       const Smask &context = Smask(true));
 
   //
   KOKKOS_FUNCTION
-  static void ice_classical_nucleation(const Spack &frzimm, const Spack &frzcnt, const Spack &frzdep, const Spack &rho,
-                                       const Spack &qc_incld, const Spack &nc_incld, const int Iflag, Spack &ncheti_cnt,
-                                       Spack &qcheti_cnt, Spack &nicnt, Spack &qucnt, Spack &ninuc_cnt,
-                                       Spack &qinuc_cnt);
+  static void ice_classical_nucleation(const Spack &frzimm, const Spack &frzcnt,
+                                       const Spack &frzdep, const Spack &rho, const Spack &qc_incld,
+                                       const Spack &nc_incld, const int Iflag, Spack &ncheti_cnt,
+                                       Spack &qcheti_cnt, Spack &nicnt, Spack &qucnt,
+                                       Spack &ninuc_cnt, Spack &qinuc_cnt);
 
   // Computes droplet self collection
   KOKKOS_FUNCTION
-  static void droplet_self_collection(const Spack &rho, const Spack &inv_rho, const Spack &qc_incld, const Spack &mu_c,
-                                      const Spack &nu, const Spack &nc2nr_autoconv_tend, Spack &nc_selfcollect_tend,
+  static void droplet_self_collection(const Spack &rho, const Spack &inv_rho, const Spack &qc_incld,
+                                      const Spack &mu_c, const Spack &nu,
+                                      const Spack &nc2nr_autoconv_tend, Spack &nc_selfcollect_tend,
                                       const Smask &context = Smask(true));
 
   // Computes the accretion of clouds by rain
   KOKKOS_FUNCTION
-  static void cloud_rain_accretion(const Spack &rho, const Spack &inv_rho, const Spack &qc_incld, const Spack &nc_incld,
-                                   const Spack &qr_incld, const Spack &inv_qc_relvar, Spack &qc2qr_accret_tend,
+  static void cloud_rain_accretion(const Spack &rho, const Spack &inv_rho, const Spack &qc_incld,
+                                   const Spack &nc_incld, const Spack &qr_incld,
+                                   const Spack &inv_qc_relvar, Spack &qc2qr_accret_tend,
                                    Spack &nc_accret_tend, const P3Runtime &runtime_options,
                                    const Smask &context = Smask(true));
 
   // Computes cloud water autoconversion process rate
   KOKKOS_FUNCTION
-  static void cloud_water_autoconversion(const Spack &rho, const Spack &qc_incld, const Spack &nc_incld,
-                                         const Spack &inv_qc_relvar, Spack &qc2qr_autoconv_tend,
-                                         Spack &nc2nr_autoconv_tend, Spack &ncautr, const P3Runtime &runtime_options,
+  static void cloud_water_autoconversion(const Spack &rho, const Spack &qc_incld,
+                                         const Spack &nc_incld, const Spack &inv_qc_relvar,
+                                         Spack &qc2qr_autoconv_tend, Spack &nc2nr_autoconv_tend,
+                                         Spack &ncautr, const P3Runtime &runtime_options,
                                          const Smask &context = Smask(true));
 
   // Computes rain self collection process rate
@@ -701,22 +742,25 @@ template <typename ScalarT, typename DeviceT> struct Functions {
 
   // Impose maximum ice number
   KOKKOS_FUNCTION
-  static void impose_max_total_ni(Spack &ni_local, const Scalar &max_total_ni, const Spack &inv_rho_local,
-                                  const Smask &context = Smask(true));
+  static void impose_max_total_ni(Spack &ni_local, const Scalar &max_total_ni,
+                                  const Spack &inv_rho_local, const Smask &context = Smask(true));
 
   //--------------------------------------------------------------------------------
   //  Calculates and returns the bulk rime density from the prognostic ice variables
   //  and adjusts qm and bm appropriately.
   //--------------------------------------------------------------------------------
   KOKKOS_FUNCTION
-  static Spack calc_bulk_rho_rime(const Spack &qi_tot, Spack &qi_rim, Spack &bi_rim, const P3Runtime &runtime_options,
+  static Spack calc_bulk_rho_rime(const Spack &qi_tot, Spack &qi_rim, Spack &bi_rim,
+                                  const P3Runtime &runtime_options,
                                   const Smask &context = Smask(true));
 
   // TODO - comment
   KOKKOS_FUNCTION
-  static void compute_rain_fall_velocity(const view_2d_table &vn_table_vals, const view_2d_table &vm_table_vals,
-                                         const Spack &qr_incld, const Spack &rhofacr, Spack &nr_incld, Spack &mu_r,
-                                         Spack &lamr, Spack &V_qr, Spack &V_nr, const P3Runtime &runtime_options,
+  static void compute_rain_fall_velocity(const view_2d_table &vn_table_vals,
+                                         const view_2d_table &vm_table_vals, const Spack &qr_incld,
+                                         const Spack &rhofacr, Spack &nr_incld, Spack &mu_r,
+                                         Spack &lamr, Spack &V_qr, Spack &V_nr,
+                                         const P3Runtime &runtime_options,
                                          const Smask &context = Smask(true));
 
   //---------------------------------------------------------------------------------
@@ -725,267 +769,304 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   //-- ice-phase dependent processes:
   KOKKOS_FUNCTION
   static void update_prognostic_ice(
-      const Spack &qc2qi_hetero_freeze_tend, const Spack &qc2qi_collect_tend, const Spack &qc2qr_ice_shed_tend,
-      const Spack &nc_collect_tend, const Spack &nc2ni_immers_freeze_tend, const Spack &ncshdc,
-      const Spack &qr2qi_collect_tend, const Spack &nr_collect_tend, const Spack &qr2qi_immers_freeze_tend,
-      const Spack &nr2ni_immers_freeze_tend, const Spack &nr_ice_shed_tend, const Spack &qi2qr_melt_tend,
-      const Spack &ni2nr_melt_tend, const Spack &qi2qv_sublim_tend, const Spack &qv2qi_vapdep_tend,
-      const Spack &qv2qi_nucleat_tend, const Spack &ni_nucleat_tend, const Spack &ni_selfcollect_tend,
-      const Spack &ni_sublim_tend, const Spack &qc2qi_berg_tend, const Spack &inv_exner, const bool do_predict_nc,
-      const Smask &log_wetgrowth, const Scalar dt, const Scalar &nmltratio, const Spack &rho_qm_cloud,
-      Spack &ncheti_cnt, Spack &nicnt, Spack &ninuc_cnt, Spack &qcheti_cnt, Spack &qicnt, Spack &qinuc_cnt,
-      Spack &th_atm, Spack &qv, Spack &qi, Spack &ni, Spack &qm, Spack &bm, Spack &qc, Spack &nc, Spack &qr, Spack &nr,
+      const Spack &qc2qi_hetero_freeze_tend, const Spack &qc2qi_collect_tend,
+      const Spack &qc2qr_ice_shed_tend, const Spack &nc_collect_tend,
+      const Spack &nc2ni_immers_freeze_tend, const Spack &ncshdc, const Spack &qr2qi_collect_tend,
+      const Spack &nr_collect_tend, const Spack &qr2qi_immers_freeze_tend,
+      const Spack &nr2ni_immers_freeze_tend, const Spack &nr_ice_shed_tend,
+      const Spack &qi2qr_melt_tend, const Spack &ni2nr_melt_tend, const Spack &qi2qv_sublim_tend,
+      const Spack &qv2qi_vapdep_tend, const Spack &qv2qi_nucleat_tend, const Spack &ni_nucleat_tend,
+      const Spack &ni_selfcollect_tend, const Spack &ni_sublim_tend, const Spack &qc2qi_berg_tend,
+      const Spack &inv_exner, const bool do_predict_nc, const Smask &log_wetgrowth, const Scalar dt,
+      const Scalar &nmltratio, const Spack &rho_qm_cloud, Spack &ncheti_cnt, Spack &nicnt,
+      Spack &ninuc_cnt, Spack &qcheti_cnt, Spack &qicnt, Spack &qinuc_cnt, Spack &th_atm, Spack &qv,
+      Spack &qi, Spack &ni, Spack &qm, Spack &bm, Spack &qc, Spack &nc, Spack &qr, Spack &nr,
       const bool &use_hetfrz_classnuc, const Smask &context = Smask(true));
 
   // TODO (comments)
   KOKKOS_FUNCTION
   static void get_time_space_phys_variables(const Spack &T_atm, const Spack &pres, const Spack &rho,
-                                            const Spack &qv_sat_l, const Spack &qv_sat_i, Spack &mu, Spack &dv,
-                                            Spack &sc, Spack &dqsdt, Spack &dqsidt, Spack &ab, Spack &abi, Spack &kap,
-                                            Spack &eii, const Smask &context = Smask(true));
+                                            const Spack &qv_sat_l, const Spack &qv_sat_i, Spack &mu,
+                                            Spack &dv, Spack &sc, Spack &dqsdt, Spack &dqsidt,
+                                            Spack &ab, Spack &abi, Spack &kap, Spack &eii,
+                                            const Smask &context = Smask(true));
 
   // TODO (comments)
   KOKKOS_FUNCTION
   static void ice_cldliq_collection(const Spack &rho, const Spack &temp, const Spack &rhofaci,
-                                    const Spack &table_val_qc2qi_collect, const Spack &qi_incld, const Spack &qc_incld,
-                                    const Spack &ni_incld, const Spack &nc_incld, Spack &qc2qi_collect_tend,
-                                    Spack &nc_collect_tend, Spack &qc2qr_ice_shed_tend, Spack &ncshdc,
-                                    const P3Runtime &runtime_options, const Smask &context = Smask(true));
+                                    const Spack &table_val_qc2qi_collect, const Spack &qi_incld,
+                                    const Spack &qc_incld, const Spack &ni_incld,
+                                    const Spack &nc_incld, Spack &qc2qi_collect_tend,
+                                    Spack &nc_collect_tend, Spack &qc2qr_ice_shed_tend,
+                                    Spack &ncshdc, const P3Runtime &runtime_options,
+                                    const Smask &context = Smask(true));
 
   // TODO (comments)
   KOKKOS_FUNCTION
-  static void ice_rain_collection(const Spack &rho, const Spack &temp, const Spack &rhofaci, const Spack &logn0r,
-                                  const Spack &table_val_nr_collect, const Spack &table_val_qr2qi_collect,
-                                  const Spack &qi_incld, const Spack &ni_incld, const Spack &qr_incld,
-                                  Spack &qr2qi_collect_tend, Spack &nr_collect_tend, const P3Runtime &runtime_options,
+  static void ice_rain_collection(const Spack &rho, const Spack &temp, const Spack &rhofaci,
+                                  const Spack &logn0r, const Spack &table_val_nr_collect,
+                                  const Spack &table_val_qr2qi_collect, const Spack &qi_incld,
+                                  const Spack &ni_incld, const Spack &qr_incld,
+                                  Spack &qr2qi_collect_tend, Spack &nr_collect_tend,
+                                  const P3Runtime &runtime_options,
                                   const Smask &context = Smask(true));
 
   // TODO (comments)
   KOKKOS_FUNCTION
-  static void ice_self_collection(const Spack &rho, const Spack &rhofaci, const Spack &table_val_ni_self_collect,
-                                  const Spack &eii, const Spack &qm_incld, const Spack &qi_incld, const Spack &ni_incld,
-                                  Spack &ni_selfcollect_tend, const Smask &context = Smask(true));
+  static void ice_self_collection(const Spack &rho, const Spack &rhofaci,
+                                  const Spack &table_val_ni_self_collect, const Spack &eii,
+                                  const Spack &qm_incld, const Spack &qi_incld,
+                                  const Spack &ni_incld, Spack &ni_selfcollect_tend,
+                                  const Smask &context = Smask(true));
 
   // helper fn for evaporate_rain
   KOKKOS_FUNCTION
-  static void rain_evap_tscale_weight(const Spack &dt_over_tau, Spack &weight, const Smask &context = Smask(true));
+  static void rain_evap_tscale_weight(const Spack &dt_over_tau, Spack &weight,
+                                      const Smask &context = Smask(true));
 
   // helper fn for evaporate_rain
   KOKKOS_FUNCTION
-  static void rain_evap_equilib_tend(const Spack &A_c, const Spack &ab, const Spack &tau_eff, const Spack &tau_r,
-                                     Spack &tend, const Smask &context = Smask(true));
-
-  // helper fn for evaporate_rain
-  KOKKOS_FUNCTION
-  static void rain_evap_instant_tend(const Spack &ssat_r, const Spack &ab, const Spack &tau_r, Spack &tend,
+  static void rain_evap_equilib_tend(const Spack &A_c, const Spack &ab, const Spack &tau_eff,
+                                     const Spack &tau_r, Spack &tend,
                                      const Smask &context = Smask(true));
 
+  // helper fn for evaporate_rain
+  KOKKOS_FUNCTION
+  static void rain_evap_instant_tend(const Spack &ssat_r, const Spack &ab, const Spack &tau_r,
+                                     Spack &tend, const Smask &context = Smask(true));
+
   // TODO (comments)
   KOKKOS_FUNCTION
-  static void evaporate_rain(const Spack &qr_incld, const Spack &qc_incld, const Spack &nr_incld, const Spack &qi_incld,
-                             const Spack &cld_frac_l, const Spack &cld_frac_r, const Spack &qv, const Spack &qv_prev,
-                             const Spack &qv_sat_l, const Spack &qv_sat_i, const Spack &ab, const Spack &abi,
-                             const Spack &epsr, const Spack &epsi_tot, const Spack &t, const Spack &t_prev,
-                             const Spack &dqsdt, const Scalar &dt, Spack &qr2qv_evap_tend, Spack &nr_evap_tend,
+  static void evaporate_rain(const Spack &qr_incld, const Spack &qc_incld, const Spack &nr_incld,
+                             const Spack &qi_incld, const Spack &cld_frac_l,
+                             const Spack &cld_frac_r, const Spack &qv, const Spack &qv_prev,
+                             const Spack &qv_sat_l, const Spack &qv_sat_i, const Spack &ab,
+                             const Spack &abi, const Spack &epsr, const Spack &epsi_tot,
+                             const Spack &t, const Spack &t_prev, const Spack &dqsdt,
+                             const Scalar &dt, Spack &qr2qv_evap_tend, Spack &nr_evap_tend,
                              const Smask &context = Smask(true));
 
   // get number and mass tendencies due to melting ice
   KOKKOS_FUNCTION
-  static void ice_melting(const Spack &rho, const Spack &T_atm, const Spack &pres, const Spack &rhofaci,
-                          const Spack &table_val_qi2qr_melting, const Spack &table_val_qi2qr_vent_melt, const Spack &dv,
-                          const Spack &sc, const Spack &mu, const Spack &kap, const Spack &qv, const Spack &qi_incld,
+  static void ice_melting(const Spack &rho, const Spack &T_atm, const Spack &pres,
+                          const Spack &rhofaci, const Spack &table_val_qi2qr_melting,
+                          const Spack &table_val_qi2qr_vent_melt, const Spack &dv, const Spack &sc,
+                          const Spack &mu, const Spack &kap, const Spack &qv, const Spack &qi_incld,
                           const Spack &ni_incld, Spack &qi2qr_melt_tend, Spack &ni2nr_melt_tend,
                           const Smask &context = Smask(true));
 
   // liquid-phase dependent processes:
   KOKKOS_FUNCTION
-  static void update_prognostic_liquid(const Spack &qc2qr_accret_tend, const Spack &nc_accret_tend,
-                                       const Spack &qc2qr_autoconv_tend, const Spack &nc2nr_autoconv_tend,
-                                       const Spack &ncautr, const Spack &nc_selfcollect_tend,
-                                       const Spack &qr2qv_evap_tend, const Spack &nr_evap_tend,
-                                       const Spack &nr_selfcollect_tend, const bool do_predict_nc,
-                                       const bool do_prescribed_CCN, const Spack &inv_rho, const Spack &inv_exner,
-                                       const Scalar dt, Spack &th_atm, Spack &qv, Spack &qc, Spack &nc, Spack &qr,
-                                       Spack &nr, const Smask &context = Smask(true));
+  static void update_prognostic_liquid(
+      const Spack &qc2qr_accret_tend, const Spack &nc_accret_tend, const Spack &qc2qr_autoconv_tend,
+      const Spack &nc2nr_autoconv_tend, const Spack &ncautr, const Spack &nc_selfcollect_tend,
+      const Spack &qr2qv_evap_tend, const Spack &nr_evap_tend, const Spack &nr_selfcollect_tend,
+      const bool do_predict_nc, const bool do_prescribed_CCN, const Spack &inv_rho,
+      const Spack &inv_exner, const Scalar dt, Spack &th_atm, Spack &qv, Spack &qc, Spack &nc,
+      Spack &qr, Spack &nr, const Smask &context = Smask(true));
 
   // compute deposition onto ice or sublimation from ice
   KOKKOS_FUNCTION
-  static void ice_deposition_sublimation(const Spack &qi_incld, const Spack &ni_incld, const Spack &t_atm,
-                                         const Spack &qv_sat_l, const Spack &qv_sat_i, const Spack &epsi,
-                                         const Spack &abi, const Spack &qv, const Scalar &inv_dt, Spack &qidep,
-                                         Spack &qi2qv_sublim_tend, Spack &ni_sublim_tend, Spack &qiberg,
-                                         const Smask &context = Smask(true));
+  static void ice_deposition_sublimation(const Spack &qi_incld, const Spack &ni_incld,
+                                         const Spack &t_atm, const Spack &qv_sat_l,
+                                         const Spack &qv_sat_i, const Spack &epsi, const Spack &abi,
+                                         const Spack &qv, const Scalar &inv_dt, Spack &qidep,
+                                         Spack &qi2qv_sublim_tend, Spack &ni_sublim_tend,
+                                         Spack &qiberg, const Smask &context = Smask(true));
 
   KOKKOS_FUNCTION
   static void ice_relaxation_timescale(const Spack &rho, const Spack &temp, const Spack &rhofaci,
-                                       const Spack &table_val_qi2qr_melting, const Spack &table_val_qi2qr_vent_melt,
-                                       const Spack &dv, const Spack &mu, const Spack &sc, const Spack &qi_incld,
+                                       const Spack &table_val_qi2qr_melting,
+                                       const Spack &table_val_qi2qr_vent_melt, const Spack &dv,
+                                       const Spack &mu, const Spack &sc, const Spack &qi_incld,
                                        const Spack &ni_incld, Spack &epsi, Spack &epsi_tot,
                                        const Smask &context = Smask(true));
 
   KOKKOS_FUNCTION
-  static void calc_liq_relaxation_timescale(const view_2d_table &revap_table_vals, const Spack &rho, const Scalar &f1r,
-                                            const Scalar &f2r, const Spack &dv, const Spack &mu, const Spack &sc,
-                                            const Spack &mu_r, const Spack &lamr, const Spack &cdistr,
-                                            const Spack &cdist, const Spack &qr_incld, const Spack &qc_incld,
-                                            Spack &epsr, Spack &epsc, const Smask &context = Smask(true));
+  static void calc_liq_relaxation_timescale(const view_2d_table &revap_table_vals, const Spack &rho,
+                                            const Scalar &f1r, const Scalar &f2r, const Spack &dv,
+                                            const Spack &mu, const Spack &sc, const Spack &mu_r,
+                                            const Spack &lamr, const Spack &cdistr,
+                                            const Spack &cdist, const Spack &qr_incld,
+                                            const Spack &qc_incld, Spack &epsr, Spack &epsc,
+                                            const Smask &context = Smask(true));
 
   // ice nucleation
   KOKKOS_FUNCTION
-  static void ice_nucleation(const Spack &temp, const Spack &inv_rho, const Spack &ni, const Spack &ni_activated,
-                             const Spack &qv_supersat_i, const Scalar &inv_dt, const bool &do_predict_nc,
-                             const bool &do_prescribed_CCN, Spack &qv2qi_nucleat_tend, Spack &ni_nucleat_tend,
-                             const P3Runtime &runtime_options, const Smask &context = Smask(true));
+  static void ice_nucleation(const Spack &temp, const Spack &inv_rho, const Spack &ni,
+                             const Spack &ni_activated, const Spack &qv_supersat_i,
+                             const Scalar &inv_dt, const bool &do_predict_nc,
+                             const bool &do_prescribed_CCN, Spack &qv2qi_nucleat_tend,
+                             Spack &ni_nucleat_tend, const P3Runtime &runtime_options,
+                             const Smask &context = Smask(true));
 
   KOKKOS_FUNCTION
   static Spack subgrid_variance_scaling(const Spack &relvar, const Scalar &expon);
 
   KOKKOS_FUNCTION
-  static void ice_cldliq_wet_growth(const Spack &rho, const Spack &temp, const Spack &pres, const Spack &rhofaci,
-                                    const Spack &table_val_qi2qr_melting, const Spack &table_val_qi2qr_vent_melt,
-                                    const Spack &dv, const Spack &kap, const Spack &mu, const Spack &sc,
-                                    const Spack &qv, const Spack &qc_incld, const Spack &qi_incld,
-                                    const Spack &ni_incld, const Spack &qr_incld, Smask &log_wetgrowth,
-                                    Spack &qr2qi_collect_tend, Spack &qc2qi_collect_tend, Spack &qc_growth_rate,
-                                    Spack &nr_ice_shed_tend, Spack &qc2qr_ice_shed_tend,
-                                    const Smask &context = Smask(true));
+  static void ice_cldliq_wet_growth(
+      const Spack &rho, const Spack &temp, const Spack &pres, const Spack &rhofaci,
+      const Spack &table_val_qi2qr_melting, const Spack &table_val_qi2qr_vent_melt, const Spack &dv,
+      const Spack &kap, const Spack &mu, const Spack &sc, const Spack &qv, const Spack &qc_incld,
+      const Spack &qi_incld, const Spack &ni_incld, const Spack &qr_incld, Smask &log_wetgrowth,
+      Spack &qr2qi_collect_tend, Spack &qc2qi_collect_tend, Spack &qc_growth_rate,
+      Spack &nr_ice_shed_tend, Spack &qc2qr_ice_shed_tend, const Smask &context = Smask(true));
 
   KOKKOS_FUNCTION
-  static void check_values(const uview_1d<const Spack> &qv, const uview_1d<const Spack> &temp, const Int &ktop,
-                           const Int &kbot, const Int &timestepcount, const bool &force_abort, const Int &source_ind,
-                           const MemberType &team, const uview_1d<const Scalar> &col_loc);
+  static void check_values(const uview_1d<const Spack> &qv, const uview_1d<const Spack> &temp,
+                           const Int &ktop, const Int &kbot, const Int &timestepcount,
+                           const bool &force_abort, const Int &source_ind, const MemberType &team,
+                           const uview_1d<const Scalar> &col_loc);
 
 #ifdef SCREAM_P3_SMALL_KERNELS
-  static void check_values_disp(const uview_2d<const Spack> &qv, const uview_2d<const Spack> &temp, const Int &ktop,
-                                const Int &kbot, const Int &timestepcount, const bool &force_abort,
-                                const Int &source_ind, const uview_2d<const Scalar> &col_loc, const Int &nj,
+  static void check_values_disp(const uview_2d<const Spack> &qv, const uview_2d<const Spack> &temp,
+                                const Int &ktop, const Int &kbot, const Int &timestepcount,
+                                const bool &force_abort, const Int &source_ind,
+                                const uview_2d<const Scalar> &col_loc, const Int &nj,
                                 const Int &nk);
 #endif
 
   KOKKOS_FUNCTION
-  static void calculate_incloud_mixingratios(const Spack &qc, const Spack &qr, const Spack &qi, const Spack &qm,
-                                             const Spack &nc, const Spack &nr, const Spack &ni, const Spack &bm,
-                                             const Spack &inv_cld_frac_l, const Spack &inv_cld_frac_i,
-                                             const Spack &inv_cld_frac_r, Spack &qc_incld, Spack &qr_incld,
-                                             Spack &qi_incld, Spack &qm_incld, Spack &nc_incld, Spack &nr_incld,
-                                             Spack &ni_incld, Spack &bm_incld, const Smask &context = Smask(true));
+  static void calculate_incloud_mixingratios(
+      const Spack &qc, const Spack &qr, const Spack &qi, const Spack &qm, const Spack &nc,
+      const Spack &nr, const Spack &ni, const Spack &bm, const Spack &inv_cld_frac_l,
+      const Spack &inv_cld_frac_i, const Spack &inv_cld_frac_r, Spack &qc_incld, Spack &qr_incld,
+      Spack &qi_incld, Spack &qm_incld, Spack &nc_incld, Spack &nr_incld, Spack &ni_incld,
+      Spack &bm_incld, const Smask &context = Smask(true));
 
   //
   // main P3 functions
   //
 
   KOKKOS_FUNCTION
-  static void p3_main_init(const MemberType &team, const Int &nk_pack, const uview_1d<const Spack> &cld_frac_i,
-                           const uview_1d<const Spack> &cld_frac_l, const uview_1d<const Spack> &cld_frac_r,
-                           const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &th_atm,
-                           const uview_1d<const Spack> &dz, const uview_1d<Spack> &diag_equiv_reflectivity,
-                           const uview_1d<Spack> &ze_ice, const uview_1d<Spack> &ze_rain,
-                           const uview_1d<Spack> &diag_eff_radius_qc, const uview_1d<Spack> &diag_eff_radius_qi,
-                           const uview_1d<Spack> &diag_eff_radius_qr, const uview_1d<Spack> &inv_cld_frac_i,
-                           const uview_1d<Spack> &inv_cld_frac_l, const uview_1d<Spack> &inv_cld_frac_r,
-                           const uview_1d<Spack> &exner, const uview_1d<Spack> &T_atm, const uview_1d<Spack> &qv,
-                           const uview_1d<Spack> &inv_dz, Scalar &precip_liq_surf, Scalar &precip_ice_surf,
-                           view_1d_ptr_array<Spack, 36> &zero_init);
+  static void
+  p3_main_init(const MemberType &team, const Int &nk_pack, const uview_1d<const Spack> &cld_frac_i,
+               const uview_1d<const Spack> &cld_frac_l, const uview_1d<const Spack> &cld_frac_r,
+               const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &th_atm,
+               const uview_1d<const Spack> &dz, const uview_1d<Spack> &diag_equiv_reflectivity,
+               const uview_1d<Spack> &ze_ice, const uview_1d<Spack> &ze_rain,
+               const uview_1d<Spack> &diag_eff_radius_qc, const uview_1d<Spack> &diag_eff_radius_qi,
+               const uview_1d<Spack> &diag_eff_radius_qr, const uview_1d<Spack> &inv_cld_frac_i,
+               const uview_1d<Spack> &inv_cld_frac_l, const uview_1d<Spack> &inv_cld_frac_r,
+               const uview_1d<Spack> &exner, const uview_1d<Spack> &T_atm,
+               const uview_1d<Spack> &qv, const uview_1d<Spack> &inv_dz, Scalar &precip_liq_surf,
+               Scalar &precip_ice_surf, view_1d_ptr_array<Spack, 36> &zero_init);
 
 #ifdef SCREAM_P3_SMALL_KERNELS
   static void p3_main_init_disp(
       const Int &nj, const Int &nk_pack, const uview_2d<const Spack> &cld_frac_i,
       const uview_2d<const Spack> &cld_frac_l, const uview_2d<const Spack> &cld_frac_r,
-      const uview_2d<const Spack> &inv_exner, const uview_2d<const Spack> &th_atm, const uview_2d<const Spack> &dz,
-      const uview_2d<Spack> &diag_equiv_reflectivity, const uview_2d<Spack> &ze_ice, const uview_2d<Spack> &ze_rain,
+      const uview_2d<const Spack> &inv_exner, const uview_2d<const Spack> &th_atm,
+      const uview_2d<const Spack> &dz, const uview_2d<Spack> &diag_equiv_reflectivity,
+      const uview_2d<Spack> &ze_ice, const uview_2d<Spack> &ze_rain,
       const uview_2d<Spack> &diag_eff_radius_qc, const uview_2d<Spack> &diag_eff_radius_qi,
       const uview_2d<Spack> &diag_eff_radius_qr, const uview_2d<Spack> &inv_cld_frac_i,
-      const uview_2d<Spack> &inv_cld_frac_l, const uview_2d<Spack> &inv_cld_frac_r, const uview_2d<Spack> &exner,
-      const uview_2d<Spack> &T_atm, const uview_2d<Spack> &qv, const uview_2d<Spack> &inv_dz,
-      const uview_1d<Scalar> &precip_liq_surf, const uview_1d<Scalar> &precip_ice_surf, const uview_2d<Spack> &mu_r,
+      const uview_2d<Spack> &inv_cld_frac_l, const uview_2d<Spack> &inv_cld_frac_r,
+      const uview_2d<Spack> &exner, const uview_2d<Spack> &T_atm, const uview_2d<Spack> &qv,
+      const uview_2d<Spack> &inv_dz, const uview_1d<Scalar> &precip_liq_surf,
+      const uview_1d<Scalar> &precip_ice_surf, const uview_2d<Spack> &mu_r,
       const uview_2d<Spack> &lamr, const uview_2d<Spack> &logn0r, const uview_2d<Spack> &nu,
       const uview_2d<Spack> &cdist, const uview_2d<Spack> &cdist1, const uview_2d<Spack> &cdistr,
-      const uview_2d<Spack> &qc_incld, const uview_2d<Spack> &qr_incld, const uview_2d<Spack> &qi_incld,
-      const uview_2d<Spack> &qm_incld, const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &nr_incld,
-      const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &bm_incld, const uview_2d<Spack> &inv_rho,
-      const uview_2d<Spack> &prec, const uview_2d<Spack> &rho, const uview_2d<Spack> &rhofacr,
-      const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &acn, const uview_2d<Spack> &qv_sat_l,
-      const uview_2d<Spack> &qv_sat_i, const uview_2d<Spack> &sup, const uview_2d<Spack> &qv_supersat_i,
-      const uview_2d<Spack> &qtend_ignore, const uview_2d<Spack> &ntend_ignore, const uview_2d<Spack> &mu_c,
-      const uview_2d<Spack> &lamc, const uview_2d<Spack> &rho_qi, const uview_2d<Spack> &qv2qi_depos_tend,
-      const uview_2d<Spack> &precip_total_tend, const uview_2d<Spack> &nevapr, const uview_2d<Spack> &precip_liq_flux,
-      const uview_2d<Spack> &precip_ice_flux);
+      const uview_2d<Spack> &qc_incld, const uview_2d<Spack> &qr_incld,
+      const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld,
+      const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &nr_incld,
+      const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &bm_incld,
+      const uview_2d<Spack> &inv_rho, const uview_2d<Spack> &prec, const uview_2d<Spack> &rho,
+      const uview_2d<Spack> &rhofacr, const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &acn,
+      const uview_2d<Spack> &qv_sat_l, const uview_2d<Spack> &qv_sat_i, const uview_2d<Spack> &sup,
+      const uview_2d<Spack> &qv_supersat_i, const uview_2d<Spack> &qtend_ignore,
+      const uview_2d<Spack> &ntend_ignore, const uview_2d<Spack> &mu_c, const uview_2d<Spack> &lamc,
+      const uview_2d<Spack> &rho_qi, const uview_2d<Spack> &qv2qi_depos_tend,
+      const uview_2d<Spack> &precip_total_tend, const uview_2d<Spack> &nevapr,
+      const uview_2d<Spack> &precip_liq_flux, const uview_2d<Spack> &precip_ice_flux);
 #endif
 
   KOKKOS_FUNCTION
-  static void p3_main_part1(const MemberType &team, const Int &nk, const bool &do_predict_nc,
-                            const bool &do_prescribed_CCN, const Scalar &dt, const uview_1d<const Spack> &pres,
-                            const uview_1d<const Spack> &dpres, const uview_1d<const Spack> &dz,
-                            const uview_1d<const Spack> &nc_nuceat_tend, const uview_1d<const Spack> &nccn_prescribed,
-                            const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &exner,
-                            const uview_1d<const Spack> &inv_cld_frac_l, const uview_1d<const Spack> &inv_cld_frac_i,
-                            const uview_1d<const Spack> &inv_cld_frac_r, const uview_1d<Spack> &T_atm,
-                            const uview_1d<Spack> &rho, const uview_1d<Spack> &inv_rho, const uview_1d<Spack> &qv_sat_l,
-                            const uview_1d<Spack> &qv_sat_i, const uview_1d<Spack> &qv_supersat_i,
-                            const uview_1d<Spack> &rhofacr, const uview_1d<Spack> &rhofaci, const uview_1d<Spack> &acn,
-                            const uview_1d<Spack> &qv, const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc,
-                            const uview_1d<Spack> &nc, const uview_1d<Spack> &qr, const uview_1d<Spack> &nr,
-                            const uview_1d<Spack> &qi, const uview_1d<Spack> &ni, const uview_1d<Spack> &qm,
-                            const uview_1d<Spack> &bm, const uview_1d<Spack> &qc_incld, const uview_1d<Spack> &qr_incld,
-                            const uview_1d<Spack> &qi_incld, const uview_1d<Spack> &qm_incld,
-                            const uview_1d<Spack> &nc_incld, const uview_1d<Spack> &nr_incld,
-                            const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &bm_incld, bool &is_nucleat_possible,
-                            bool &is_hydromet_present, const P3Runtime &runtime_options);
+  static void p3_main_part1(
+      const MemberType &team, const Int &nk, const bool &do_predict_nc,
+      const bool &do_prescribed_CCN, const Scalar &dt, const uview_1d<const Spack> &pres,
+      const uview_1d<const Spack> &dpres, const uview_1d<const Spack> &dz,
+      const uview_1d<const Spack> &nc_nuceat_tend, const uview_1d<const Spack> &nccn_prescribed,
+      const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &exner,
+      const uview_1d<const Spack> &inv_cld_frac_l, const uview_1d<const Spack> &inv_cld_frac_i,
+      const uview_1d<const Spack> &inv_cld_frac_r, const uview_1d<Spack> &T_atm,
+      const uview_1d<Spack> &rho, const uview_1d<Spack> &inv_rho, const uview_1d<Spack> &qv_sat_l,
+      const uview_1d<Spack> &qv_sat_i, const uview_1d<Spack> &qv_supersat_i,
+      const uview_1d<Spack> &rhofacr, const uview_1d<Spack> &rhofaci, const uview_1d<Spack> &acn,
+      const uview_1d<Spack> &qv, const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc,
+      const uview_1d<Spack> &nc, const uview_1d<Spack> &qr, const uview_1d<Spack> &nr,
+      const uview_1d<Spack> &qi, const uview_1d<Spack> &ni, const uview_1d<Spack> &qm,
+      const uview_1d<Spack> &bm, const uview_1d<Spack> &qc_incld, const uview_1d<Spack> &qr_incld,
+      const uview_1d<Spack> &qi_incld, const uview_1d<Spack> &qm_incld,
+      const uview_1d<Spack> &nc_incld, const uview_1d<Spack> &nr_incld,
+      const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &bm_incld, bool &is_nucleat_possible,
+      bool &is_hydromet_present, const P3Runtime &runtime_options);
 
 #ifdef SCREAM_P3_SMALL_KERNELS
   static void p3_main_part1_disp(
-      const Int &nj, const Int &nk, const bool &do_predict_nc, const bool &do_prescribed_CCN, const Scalar &dt,
-      const uview_2d<const Spack> &pres, const uview_2d<const Spack> &dpres, const uview_2d<const Spack> &dz,
-      const uview_2d<const Spack> &nc_nuceat_tend, const uview_2d<const Spack> &nccn_prescribed,
-      const uview_2d<const Spack> &inv_exner, const uview_2d<const Spack> &exner,
-      const uview_2d<const Spack> &inv_cld_frac_l, const uview_2d<const Spack> &inv_cld_frac_i,
-      const uview_2d<const Spack> &inv_cld_frac_r, const uview_2d<Spack> &T_atm, const uview_2d<Spack> &rho,
-      const uview_2d<Spack> &inv_rho, const uview_2d<Spack> &qv_sat_l, const uview_2d<Spack> &qv_sat_i,
-      const uview_2d<Spack> &qv_supersat_i, const uview_2d<Spack> &rhofacr, const uview_2d<Spack> &rhofaci,
-      const uview_2d<Spack> &acn, const uview_2d<Spack> &qv, const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc,
-      const uview_2d<Spack> &nc, const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &qi,
-      const uview_2d<Spack> &ni, const uview_2d<Spack> &qm, const uview_2d<Spack> &bm, const uview_2d<Spack> &qc_incld,
-      const uview_2d<Spack> &qr_incld, const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld,
-      const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &nr_incld, const uview_2d<Spack> &ni_incld,
-      const uview_2d<Spack> &bm_incld, const uview_1d<bool> &is_nucleat_possible,
-      const uview_1d<bool> &is_hydromet_present, const P3Runtime &runtime_options);
+      const Int &nj, const Int &nk, const bool &do_predict_nc, const bool &do_prescribed_CCN,
+      const Scalar &dt, const uview_2d<const Spack> &pres, const uview_2d<const Spack> &dpres,
+      const uview_2d<const Spack> &dz, const uview_2d<const Spack> &nc_nuceat_tend,
+      const uview_2d<const Spack> &nccn_prescribed, const uview_2d<const Spack> &inv_exner,
+      const uview_2d<const Spack> &exner, const uview_2d<const Spack> &inv_cld_frac_l,
+      const uview_2d<const Spack> &inv_cld_frac_i, const uview_2d<const Spack> &inv_cld_frac_r,
+      const uview_2d<Spack> &T_atm, const uview_2d<Spack> &rho, const uview_2d<Spack> &inv_rho,
+      const uview_2d<Spack> &qv_sat_l, const uview_2d<Spack> &qv_sat_i,
+      const uview_2d<Spack> &qv_supersat_i, const uview_2d<Spack> &rhofacr,
+      const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &acn, const uview_2d<Spack> &qv,
+      const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc, const uview_2d<Spack> &nc,
+      const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &qi,
+      const uview_2d<Spack> &ni, const uview_2d<Spack> &qm, const uview_2d<Spack> &bm,
+      const uview_2d<Spack> &qc_incld, const uview_2d<Spack> &qr_incld,
+      const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld,
+      const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &nr_incld,
+      const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &bm_incld,
+      const uview_1d<bool> &is_nucleat_possible, const uview_1d<bool> &is_hydromet_present,
+      const P3Runtime &runtime_options);
 #endif
 
   KOKKOS_FUNCTION
   static void p3_main_part2(
-      const MemberType &team, const Int &nk_pack, const Scalar &max_total_ni, const bool &do_predict_nc,
-      const bool &do_prescribed_CCN, const Scalar &dt, const Scalar &inv_dt,
-      const uview_1d<const Spack> &ohetfrz_immersion_nucleation_tend,
+      const MemberType &team, const Int &nk_pack, const Scalar &max_total_ni,
+      const bool &do_predict_nc, const bool &do_prescribed_CCN, const Scalar &dt,
+      const Scalar &inv_dt, const uview_1d<const Spack> &ohetfrz_immersion_nucleation_tend,
       const uview_1d<const Spack> &ohetfrz_contact_nucleation_tend,
       const uview_1d<const Spack> &ohetfrz_deposition_nucleation_tend, const view_dnu_table &dnu,
       const view_ice_table &ice_table_vals, const view_collect_table &collect_table_vals,
-      const view_2d_table &revap_table_vals, const uview_1d<const Spack> &pres, const uview_1d<const Spack> &dpres,
-      const uview_1d<const Spack> &dz, const uview_1d<const Spack> &nc_nuceat_tend,
-      const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &exner,
-      const uview_1d<const Spack> &inv_cld_frac_l, const uview_1d<const Spack> &inv_cld_frac_i,
-      const uview_1d<const Spack> &inv_cld_frac_r, const uview_1d<const Spack> &ni_activated,
-      const uview_1d<const Spack> &inv_qc_relvar, const uview_1d<const Spack> &cld_frac_i,
-      const uview_1d<const Spack> &cld_frac_l, const uview_1d<const Spack> &cld_frac_r,
-      const uview_1d<const Spack> &qv_prev, const uview_1d<const Spack> &t_prev, const uview_1d<Spack> &T_atm,
-      const uview_1d<Spack> &rho, const uview_1d<Spack> &inv_rho, const uview_1d<Spack> &qv_sat_l,
-      const uview_1d<Spack> &qv_sat_i, const uview_1d<Spack> &qv_supersat_i, const uview_1d<Spack> &rhofacr,
-      const uview_1d<Spack> &rhofaci, const uview_1d<Spack> &acn, const uview_1d<Spack> &qv,
-      const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc, const uview_1d<Spack> &nc, const uview_1d<Spack> &qr,
-      const uview_1d<Spack> &nr, const uview_1d<Spack> &qi, const uview_1d<Spack> &ni, const uview_1d<Spack> &qm,
+      const view_2d_table &revap_table_vals, const uview_1d<const Spack> &pres,
+      const uview_1d<const Spack> &dpres, const uview_1d<const Spack> &dz,
+      const uview_1d<const Spack> &nc_nuceat_tend, const uview_1d<const Spack> &inv_exner,
+      const uview_1d<const Spack> &exner, const uview_1d<const Spack> &inv_cld_frac_l,
+      const uview_1d<const Spack> &inv_cld_frac_i, const uview_1d<const Spack> &inv_cld_frac_r,
+      const uview_1d<const Spack> &ni_activated, const uview_1d<const Spack> &inv_qc_relvar,
+      const uview_1d<const Spack> &cld_frac_i, const uview_1d<const Spack> &cld_frac_l,
+      const uview_1d<const Spack> &cld_frac_r, const uview_1d<const Spack> &qv_prev,
+      const uview_1d<const Spack> &t_prev, const uview_1d<Spack> &T_atm, const uview_1d<Spack> &rho,
+      const uview_1d<Spack> &inv_rho, const uview_1d<Spack> &qv_sat_l,
+      const uview_1d<Spack> &qv_sat_i, const uview_1d<Spack> &qv_supersat_i,
+      const uview_1d<Spack> &rhofacr, const uview_1d<Spack> &rhofaci, const uview_1d<Spack> &acn,
+      const uview_1d<Spack> &qv, const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc,
+      const uview_1d<Spack> &nc, const uview_1d<Spack> &qr, const uview_1d<Spack> &nr,
+      const uview_1d<Spack> &qi, const uview_1d<Spack> &ni, const uview_1d<Spack> &qm,
       const uview_1d<Spack> &bm, const uview_1d<Spack> &qc_incld, const uview_1d<Spack> &qr_incld,
-      const uview_1d<Spack> &qi_incld, const uview_1d<Spack> &qm_incld, const uview_1d<Spack> &nc_incld,
-      const uview_1d<Spack> &nr_incld, const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &bm_incld,
-      const uview_1d<Spack> &mu_c, const uview_1d<Spack> &nu, const uview_1d<Spack> &lamc, const uview_1d<Spack> &cdist,
+      const uview_1d<Spack> &qi_incld, const uview_1d<Spack> &qm_incld,
+      const uview_1d<Spack> &nc_incld, const uview_1d<Spack> &nr_incld,
+      const uview_1d<Spack> &ni_incld, const uview_1d<Spack> &bm_incld, const uview_1d<Spack> &mu_c,
+      const uview_1d<Spack> &nu, const uview_1d<Spack> &lamc, const uview_1d<Spack> &cdist,
       const uview_1d<Spack> &cdist1, const uview_1d<Spack> &cdistr, const uview_1d<Spack> &mu_r,
-      const uview_1d<Spack> &lamr, const uview_1d<Spack> &logn0r, const uview_1d<Spack> &qv2qi_depos_tend,
-      const uview_1d<Spack> &precip_total_tend, const uview_1d<Spack> &nevapr, const uview_1d<Spack> &qr_evap_tend,
+      const uview_1d<Spack> &lamr, const uview_1d<Spack> &logn0r,
+      const uview_1d<Spack> &qv2qi_depos_tend, const uview_1d<Spack> &precip_total_tend,
+      const uview_1d<Spack> &nevapr, const uview_1d<Spack> &qr_evap_tend,
       const uview_1d<Spack> &vap_liq_exchange, const uview_1d<Spack> &vap_ice_exchange,
-      const uview_1d<Spack> &liq_ice_exchange, const uview_1d<Spack> &qr2qv_evap, const uview_1d<Spack> &qi2qv_sublim,
-      const uview_1d<Spack> &qc2qr_accret, const uview_1d<Spack> &qc2qr_autoconv, const uview_1d<Spack> &qv2qi_vapdep,
-      const uview_1d<Spack> &qc2qi_berg, const uview_1d<Spack> &qc2qr_ice_shed, const uview_1d<Spack> &qc2qi_collect,
-      const uview_1d<Spack> &qr2qi_collect, const uview_1d<Spack> &qc2qi_hetero_freeze,
-      const uview_1d<Spack> &qr2qi_immers_freeze, const uview_1d<Spack> &qi2qr_melt, const uview_1d<Spack> &pratot,
-      const uview_1d<Spack> &prctot, bool &is_hydromet_present, const Int &nk, const P3Runtime &runtime_options);
+      const uview_1d<Spack> &liq_ice_exchange, const uview_1d<Spack> &qr2qv_evap,
+      const uview_1d<Spack> &qi2qv_sublim, const uview_1d<Spack> &qc2qr_accret,
+      const uview_1d<Spack> &qc2qr_autoconv, const uview_1d<Spack> &qv2qi_vapdep,
+      const uview_1d<Spack> &qc2qi_berg, const uview_1d<Spack> &qc2qr_ice_shed,
+      const uview_1d<Spack> &qc2qi_collect, const uview_1d<Spack> &qr2qi_collect,
+      const uview_1d<Spack> &qc2qi_hetero_freeze, const uview_1d<Spack> &qr2qi_immers_freeze,
+      const uview_1d<Spack> &qi2qr_melt, const uview_1d<Spack> &pratot,
+      const uview_1d<Spack> &prctot, bool &is_hydromet_present, const Int &nk,
+      const P3Runtime &runtime_options);
 
 #ifdef SCREAM_P3_SMALL_KERNELS
   static void p3_main_part2_disp(
@@ -995,75 +1076,87 @@ template <typename ScalarT, typename DeviceT> struct Functions {
       const uview_2d<const Spack> &hetfrz_contact_nucleation_tend,
       const uview_2d<const Spack> &hetfrz_deposition_nucleation_tend, const view_dnu_table &dnu,
       const view_ice_table &ice_table_vals, const view_collect_table &collect_table_vals,
-      const view_2d_table &revap_table_vals, const uview_2d<const Spack> &pres, const uview_2d<const Spack> &dpres,
-      const uview_2d<const Spack> &dz, const uview_2d<const Spack> &nc_nuceat_tend,
-      const uview_2d<const Spack> &inv_exner, const uview_2d<const Spack> &exner,
-      const uview_2d<const Spack> &inv_cld_frac_l, const uview_2d<const Spack> &inv_cld_frac_i,
-      const uview_2d<const Spack> &inv_cld_frac_r, const uview_2d<const Spack> &ni_activated,
-      const uview_2d<const Spack> &inv_qc_relvar, const uview_2d<const Spack> &cld_frac_i,
-      const uview_2d<const Spack> &cld_frac_l, const uview_2d<const Spack> &cld_frac_r,
-      const uview_2d<const Spack> &qv_prev, const uview_2d<const Spack> &t_prev, const uview_2d<Spack> &T_atm,
-      const uview_2d<Spack> &rho, const uview_2d<Spack> &inv_rho, const uview_2d<Spack> &qv_sat_l,
-      const uview_2d<Spack> &qv_sat_i, const uview_2d<Spack> &qv_supersat_i, const uview_2d<Spack> &rhofacr,
-      const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &acn, const uview_2d<Spack> &qv,
-      const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc, const uview_2d<Spack> &nc, const uview_2d<Spack> &qr,
-      const uview_2d<Spack> &nr, const uview_2d<Spack> &qi, const uview_2d<Spack> &ni, const uview_2d<Spack> &qm,
+      const view_2d_table &revap_table_vals, const uview_2d<const Spack> &pres,
+      const uview_2d<const Spack> &dpres, const uview_2d<const Spack> &dz,
+      const uview_2d<const Spack> &nc_nuceat_tend, const uview_2d<const Spack> &inv_exner,
+      const uview_2d<const Spack> &exner, const uview_2d<const Spack> &inv_cld_frac_l,
+      const uview_2d<const Spack> &inv_cld_frac_i, const uview_2d<const Spack> &inv_cld_frac_r,
+      const uview_2d<const Spack> &ni_activated, const uview_2d<const Spack> &inv_qc_relvar,
+      const uview_2d<const Spack> &cld_frac_i, const uview_2d<const Spack> &cld_frac_l,
+      const uview_2d<const Spack> &cld_frac_r, const uview_2d<const Spack> &qv_prev,
+      const uview_2d<const Spack> &t_prev, const uview_2d<Spack> &T_atm, const uview_2d<Spack> &rho,
+      const uview_2d<Spack> &inv_rho, const uview_2d<Spack> &qv_sat_l,
+      const uview_2d<Spack> &qv_sat_i, const uview_2d<Spack> &qv_supersat_i,
+      const uview_2d<Spack> &rhofacr, const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &acn,
+      const uview_2d<Spack> &qv, const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc,
+      const uview_2d<Spack> &nc, const uview_2d<Spack> &qr, const uview_2d<Spack> &nr,
+      const uview_2d<Spack> &qi, const uview_2d<Spack> &ni, const uview_2d<Spack> &qm,
       const uview_2d<Spack> &bm, const uview_2d<Spack> &qc_incld, const uview_2d<Spack> &qr_incld,
-      const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld, const uview_2d<Spack> &nc_incld,
-      const uview_2d<Spack> &nr_incld, const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &bm_incld,
-      const uview_2d<Spack> &mu_c, const uview_2d<Spack> &nu, const uview_2d<Spack> &lamc, const uview_2d<Spack> &cdist,
+      const uview_2d<Spack> &qi_incld, const uview_2d<Spack> &qm_incld,
+      const uview_2d<Spack> &nc_incld, const uview_2d<Spack> &nr_incld,
+      const uview_2d<Spack> &ni_incld, const uview_2d<Spack> &bm_incld, const uview_2d<Spack> &mu_c,
+      const uview_2d<Spack> &nu, const uview_2d<Spack> &lamc, const uview_2d<Spack> &cdist,
       const uview_2d<Spack> &cdist1, const uview_2d<Spack> &cdistr, const uview_2d<Spack> &mu_r,
-      const uview_2d<Spack> &lamr, const uview_2d<Spack> &logn0r, const uview_2d<Spack> &qv2qi_depos_tend,
-      const uview_2d<Spack> &precip_total_tend, const uview_2d<Spack> &nevapr, const uview_2d<Spack> &qr_evap_tend,
+      const uview_2d<Spack> &lamr, const uview_2d<Spack> &logn0r,
+      const uview_2d<Spack> &qv2qi_depos_tend, const uview_2d<Spack> &precip_total_tend,
+      const uview_2d<Spack> &nevapr, const uview_2d<Spack> &qr_evap_tend,
       const uview_2d<Spack> &vap_liq_exchange, const uview_2d<Spack> &vap_ice_exchange,
-      const uview_2d<Spack> &liq_ice_exchange, const uview_2d<Spack> &qr2qv_evap, const uview_2d<Spack> &qi2qv_sublim,
-      const uview_2d<Spack> &qc2qr_accret, const uview_2d<Spack> &qc2qr_autoconv, const uview_2d<Spack> &qv2qi_vapdep,
-      const uview_2d<Spack> &qc2qi_berg, const uview_2d<Spack> &qc2qr_ice_shed, const uview_2d<Spack> &qc2qi_collect,
-      const uview_2d<Spack> &qr2qi_collect, const uview_2d<Spack> &qc2qi_hetero_freeze,
-      const uview_2d<Spack> &qr2qi_immers_freeze, const uview_2d<Spack> &qi2qr_melt, const uview_2d<Spack> &pratot,
+      const uview_2d<Spack> &liq_ice_exchange, const uview_2d<Spack> &qr2qv_evap,
+      const uview_2d<Spack> &qi2qv_sublim, const uview_2d<Spack> &qc2qr_accret,
+      const uview_2d<Spack> &qc2qr_autoconv, const uview_2d<Spack> &qv2qi_vapdep,
+      const uview_2d<Spack> &qc2qi_berg, const uview_2d<Spack> &qc2qr_ice_shed,
+      const uview_2d<Spack> &qc2qi_collect, const uview_2d<Spack> &qr2qi_collect,
+      const uview_2d<Spack> &qc2qi_hetero_freeze, const uview_2d<Spack> &qr2qi_immers_freeze,
+      const uview_2d<Spack> &qi2qr_melt, const uview_2d<Spack> &pratot,
       const uview_2d<Spack> &prctot, const uview_1d<bool> &is_nucleat_possible,
       const uview_1d<bool> &is_hydromet_present, const P3Runtime &runtime_options);
 #endif
 
   KOKKOS_FUNCTION
-  static void p3_main_part3(const MemberType &team, const Int &nk_pack, const Scalar &max_total_ni,
-                            const view_dnu_table &dnu, const view_ice_table &ice_table_vals,
-                            const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &cld_frac_l,
-                            const uview_1d<const Spack> &cld_frac_r, const uview_1d<const Spack> &cld_frac_i,
-                            const uview_1d<Spack> &rho, const uview_1d<Spack> &inv_rho, const uview_1d<Spack> &rhofaci,
-                            const uview_1d<Spack> &qv, const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc,
-                            const uview_1d<Spack> &nc, const uview_1d<Spack> &qr, const uview_1d<Spack> &nr,
-                            const uview_1d<Spack> &qi, const uview_1d<Spack> &ni, const uview_1d<Spack> &qm,
-                            const uview_1d<Spack> &bm, const uview_1d<Spack> &mu_c, const uview_1d<Spack> &nu,
-                            const uview_1d<Spack> &lamc, const uview_1d<Spack> &mu_r, const uview_1d<Spack> &lamr,
-                            const uview_1d<Spack> &vap_liq_exchange, const uview_1d<Spack> &ze_rain,
-                            const uview_1d<Spack> &ze_ice, const uview_1d<Spack> &diag_vm_qi,
-                            const uview_1d<Spack> &diag_eff_radius_qi, const uview_1d<Spack> &diag_diam_qi,
-                            const uview_1d<Spack> &rho_qi, const uview_1d<Spack> &diag_equiv_reflectivity,
-                            const uview_1d<Spack> &diag_eff_radius_qc, const uview_1d<Spack> &diag_eff_radius_qr,
-                            const P3Runtime &runtime_options);
+  static void
+  p3_main_part3(const MemberType &team, const Int &nk_pack, const Scalar &max_total_ni,
+                const view_dnu_table &dnu, const view_ice_table &ice_table_vals,
+                const uview_1d<const Spack> &inv_exner, const uview_1d<const Spack> &cld_frac_l,
+                const uview_1d<const Spack> &cld_frac_r, const uview_1d<const Spack> &cld_frac_i,
+                const uview_1d<Spack> &rho, const uview_1d<Spack> &inv_rho,
+                const uview_1d<Spack> &rhofaci, const uview_1d<Spack> &qv,
+                const uview_1d<Spack> &th_atm, const uview_1d<Spack> &qc, const uview_1d<Spack> &nc,
+                const uview_1d<Spack> &qr, const uview_1d<Spack> &nr, const uview_1d<Spack> &qi,
+                const uview_1d<Spack> &ni, const uview_1d<Spack> &qm, const uview_1d<Spack> &bm,
+                const uview_1d<Spack> &mu_c, const uview_1d<Spack> &nu, const uview_1d<Spack> &lamc,
+                const uview_1d<Spack> &mu_r, const uview_1d<Spack> &lamr,
+                const uview_1d<Spack> &vap_liq_exchange, const uview_1d<Spack> &ze_rain,
+                const uview_1d<Spack> &ze_ice, const uview_1d<Spack> &diag_vm_qi,
+                const uview_1d<Spack> &diag_eff_radius_qi, const uview_1d<Spack> &diag_diam_qi,
+                const uview_1d<Spack> &rho_qi, const uview_1d<Spack> &diag_equiv_reflectivity,
+                const uview_1d<Spack> &diag_eff_radius_qc,
+                const uview_1d<Spack> &diag_eff_radius_qr, const P3Runtime &runtime_options);
 
 #ifdef SCREAM_P3_SMALL_KERNELS
   static void p3_main_part3_disp(
       const Int &nj, const Int &nk_pack, const Scalar &max_total_ni, const view_dnu_table &dnu,
       const view_ice_table &ice_table_vals, const uview_2d<const Spack> &inv_exner,
       const uview_2d<const Spack> &cld_frac_l, const uview_2d<const Spack> &cld_frac_r,
-      const uview_2d<const Spack> &cld_frac_i, const uview_2d<Spack> &rho, const uview_2d<Spack> &inv_rho,
-      const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &qv, const uview_2d<Spack> &th_atm,
-      const uview_2d<Spack> &qc, const uview_2d<Spack> &nc, const uview_2d<Spack> &qr, const uview_2d<Spack> &nr,
-      const uview_2d<Spack> &qi, const uview_2d<Spack> &ni, const uview_2d<Spack> &qm, const uview_2d<Spack> &bm,
-      const uview_2d<Spack> &mu_c, const uview_2d<Spack> &nu, const uview_2d<Spack> &lamc, const uview_2d<Spack> &mu_r,
-      const uview_2d<Spack> &lamr, const uview_2d<Spack> &vap_liq_exchange, const uview_2d<Spack> &ze_rain,
-      const uview_2d<Spack> &ze_ice, const uview_2d<Spack> &diag_vm_qi, const uview_2d<Spack> &diag_eff_radius_qi,
-      const uview_2d<Spack> &diag_diam_qi, const uview_2d<Spack> &rho_qi,
-      const uview_2d<Spack> &diag_equiv_reflectivity, const uview_2d<Spack> &diag_eff_radius_qc,
-      const uview_2d<Spack> &diag_eff_radius_qr, const uview_1d<bool> &is_nucleat_possible,
-      const uview_1d<bool> &is_hydromet_present, const P3Runtime &runtime_options);
+      const uview_2d<const Spack> &cld_frac_i, const uview_2d<Spack> &rho,
+      const uview_2d<Spack> &inv_rho, const uview_2d<Spack> &rhofaci, const uview_2d<Spack> &qv,
+      const uview_2d<Spack> &th_atm, const uview_2d<Spack> &qc, const uview_2d<Spack> &nc,
+      const uview_2d<Spack> &qr, const uview_2d<Spack> &nr, const uview_2d<Spack> &qi,
+      const uview_2d<Spack> &ni, const uview_2d<Spack> &qm, const uview_2d<Spack> &bm,
+      const uview_2d<Spack> &mu_c, const uview_2d<Spack> &nu, const uview_2d<Spack> &lamc,
+      const uview_2d<Spack> &mu_r, const uview_2d<Spack> &lamr,
+      const uview_2d<Spack> &vap_liq_exchange, const uview_2d<Spack> &ze_rain,
+      const uview_2d<Spack> &ze_ice, const uview_2d<Spack> &diag_vm_qi,
+      const uview_2d<Spack> &diag_eff_radius_qi, const uview_2d<Spack> &diag_diam_qi,
+      const uview_2d<Spack> &rho_qi, const uview_2d<Spack> &diag_equiv_reflectivity,
+      const uview_2d<Spack> &diag_eff_radius_qc, const uview_2d<Spack> &diag_eff_radius_qr,
+      const uview_1d<bool> &is_nucleat_possible, const uview_1d<bool> &is_hydromet_present,
+      const P3Runtime &runtime_options);
 #endif
 
   // Return microseconds elapsed
   static Int p3_main(const P3Runtime &runtime_options, const P3PrognosticState &prognostic_state,
-                     const P3DiagnosticInputs &diagnostic_inputs, const P3DiagnosticOutputs &diagnostic_outputs,
+                     const P3DiagnosticInputs &diagnostic_inputs,
+                     const P3DiagnosticOutputs &diagnostic_outputs,
                      const P3Infrastructure &infrastructure, const P3HistoryOnly &history_only,
                      const P3LookupTables &lookup_tables,
 #ifdef SCREAM_P3_SMALL_KERNELS
@@ -1073,54 +1166,65 @@ template <typename ScalarT, typename DeviceT> struct Functions {
                      Int nj,  // number of columns
                      Int nk); // number of vertical cells per column
 
-  static Int p3_main_internal(const P3Runtime &runtime_options, const P3PrognosticState &prognostic_state,
-                              const P3DiagnosticInputs &diagnostic_inputs,
-                              const P3DiagnosticOutputs &diagnostic_outputs, const P3Infrastructure &infrastructure,
-                              const P3HistoryOnly &history_only, const P3LookupTables &lookup_tables,
-                              const WorkspaceManager &workspace_mgr,
-                              Int nj,  // number of columns
-                              Int nk); // number of vertical cells per column
+  static Int
+  p3_main_internal(const P3Runtime &runtime_options, const P3PrognosticState &prognostic_state,
+                   const P3DiagnosticInputs &diagnostic_inputs,
+                   const P3DiagnosticOutputs &diagnostic_outputs,
+                   const P3Infrastructure &infrastructure, const P3HistoryOnly &history_only,
+                   const P3LookupTables &lookup_tables, const WorkspaceManager &workspace_mgr,
+                   Int nj,  // number of columns
+                   Int nk); // number of vertical cells per column
 
 #ifdef SCREAM_P3_SMALL_KERNELS
-  static Int p3_main_internal_disp(const P3Runtime &runtime_options, const P3PrognosticState &prognostic_state,
-                                   const P3DiagnosticInputs &diagnostic_inputs,
-                                   const P3DiagnosticOutputs &diagnostic_outputs,
-                                   const P3Infrastructure &infrastructure, const P3HistoryOnly &history_only,
-                                   const P3LookupTables &lookup_tables, const P3Temporaries &temporaries,
-                                   const WorkspaceManager &workspace_mgr,
-                                   Int nj,  // number of columns
-                                   Int nk); // number of vertical cells per column
+  static Int
+  p3_main_internal_disp(const P3Runtime &runtime_options, const P3PrognosticState &prognostic_state,
+                        const P3DiagnosticInputs &diagnostic_inputs,
+                        const P3DiagnosticOutputs &diagnostic_outputs,
+                        const P3Infrastructure &infrastructure, const P3HistoryOnly &history_only,
+                        const P3LookupTables &lookup_tables, const P3Temporaries &temporaries,
+                        const WorkspaceManager &workspace_mgr,
+                        Int nj,  // number of columns
+                        Int nk); // number of vertical cells per column
 #endif
 
   KOKKOS_FUNCTION
-  static void ice_supersat_conservation(Spack &qidep, Spack &qinuc, Spack &qinuc_cnt, const Spack &cld_frac_i,
-                                        const Spack &qv, const Spack &qv_sat_i, const Spack &t_atm, const Real &dt,
-                                        const Spack &qi2qv_sublim_tend, const Spack &qr2qv_evap_tend,
-                                        const bool &use_hetfrz_classnuc, const Smask &context = Smask(true));
+  static void ice_supersat_conservation(Spack &qidep, Spack &qinuc, Spack &qinuc_cnt,
+                                        const Spack &cld_frac_i, const Spack &qv,
+                                        const Spack &qv_sat_i, const Spack &t_atm, const Real &dt,
+                                        const Spack &qi2qv_sublim_tend,
+                                        const Spack &qr2qv_evap_tend,
+                                        const bool &use_hetfrz_classnuc,
+                                        const Smask &context = Smask(true));
 
   KOKKOS_FUNCTION
-  static void nc_conservation(const Spack &nc, const Spack &nc_selfcollect_tend, const Real &dt, Spack &nc_collect_tend,
-                              Spack &nc2ni_immers_freeze_tend, Spack &nc_accret_tend, Spack &nc2nr_autoconv_tend,
-                              Spack &ncheti_cnt, Spack &nicnt, const bool &use_hetfrz_classnuc,
+  static void nc_conservation(const Spack &nc, const Spack &nc_selfcollect_tend, const Real &dt,
+                              Spack &nc_collect_tend, Spack &nc2ni_immers_freeze_tend,
+                              Spack &nc_accret_tend, Spack &nc2nr_autoconv_tend, Spack &ncheti_cnt,
+                              Spack &nicnt, const bool &use_hetfrz_classnuc,
                               const Smask &context = Smask(true));
 
   KOKKOS_FUNCTION
-  static void nr_conservation(const Spack &nr, const Spack &ni2nr_melt_tend, const Spack &nr_ice_shed_tend,
-                              const Spack &ncshdc, const Spack &nc2nr_autoconv_tend, const Real &dt,
-                              const Real &nmltratio, Spack &nr_collect_tend, Spack &nr2ni_immers_freeze_tend,
-                              Spack &nr_selfcollect_tend, Spack &nr_evap_tend, const Smask &context = Smask(true));
+  static void nr_conservation(const Spack &nr, const Spack &ni2nr_melt_tend,
+                              const Spack &nr_ice_shed_tend, const Spack &ncshdc,
+                              const Spack &nc2nr_autoconv_tend, const Real &dt,
+                              const Real &nmltratio, Spack &nr_collect_tend,
+                              Spack &nr2ni_immers_freeze_tend, Spack &nr_selfcollect_tend,
+                              Spack &nr_evap_tend, const Smask &context = Smask(true));
 
   KOKKOS_FUNCTION
-  static void ni_conservation(const Spack &ni, const Spack &ni_nucleat_tend, const Spack &nr2ni_immers_freeze_tend,
-                              const Spack &nc2ni_immers_freeze_tend, const Spack &ncheti_cnt, const Spack &nicnt,
-                              const Spack &ninuc_cnt, const Real &dt, Spack &ni2nr_melt_tend, Spack &ni_sublim_tend,
+  static void ni_conservation(const Spack &ni, const Spack &ni_nucleat_tend,
+                              const Spack &nr2ni_immers_freeze_tend,
+                              const Spack &nc2ni_immers_freeze_tend, const Spack &ncheti_cnt,
+                              const Spack &nicnt, const Spack &ninuc_cnt, const Real &dt,
+                              Spack &ni2nr_melt_tend, Spack &ni_sublim_tend,
                               Spack &ni_selfcollect_tend, const bool &use_hetfrz_classnuc,
                               const Smask &context = Smask(true));
 
   KOKKOS_FUNCTION
-  static void prevent_liq_supersaturation(const Spack &pres, const Spack &t_atm, const Spack &qv, const Scalar &dt,
-                                          const Spack &qidep, const Spack &qinuc, Spack &qi2qv_sublim_tend,
-                                          Spack &qr2qv_evap_tend, const Smask &context = Smask(true));
+  static void prevent_liq_supersaturation(const Spack &pres, const Spack &t_atm, const Spack &qv,
+                                          const Scalar &dt, const Spack &qidep, const Spack &qinuc,
+                                          Spack &qi2qv_sublim_tend, Spack &qr2qv_evap_tend,
+                                          const Smask &context = Smask(true));
 }; // struct Functions
 
 template <typename ScalarT, typename DeviceT>
diff --git i/components/eamxx/src/physics/p3/tests/infra/p3_data.cpp w/components/eamxx/src/physics/p3/tests/infra/p3_data.cpp
index a9380900c3..62721b66cb 100644
--- i/components/eamxx/src/physics/p3/tests/infra/p3_data.cpp
+++ w/components/eamxx/src/physics/p3/tests/infra/p3_data.cpp
@@ -37,21 +37,21 @@ P3Data::P3Data(Int ncol_, Int nlev_) : ncol(ncol_), nlev(nlev_) {
   dpres           = Array2("pressure thickness, Pa", ncol, nlev);
   inv_exner       = Array2("Exner expression", ncol, nlev);
   // Out
-  precip_liq_surf                   = Array1("precipitation rate, liquid  m/s", ncol);
-  precip_ice_surf                   = Array1("precipitation rate, solid   m/s", ncol);
-  diag_eff_radius_qc                = Array2("effective radius, cloud, m", ncol, nlev);
-  diag_eff_radius_qi                = Array2("effective radius, ice, m", ncol, nlev);
-  diag_eff_radius_qr                = Array2("effective radius, rain, m", ncol, nlev);
-  rho_qi                            = Array2("bulk density of ice, kg/m", ncol, nlev);
-  qv2qi_depos_tend                  = Array2("qitend due to deposition/sublimation ", ncol, nlev);
-  precip_liq_flux                   = Array2("grid-box average rain flux (kg m^-2 s^-1), pverp", ncol, nlev + 1);
-  precip_ice_flux                   = Array2("grid-box average ice/snow flux (kg m^-2 s^-1), pverp", ncol, nlev + 1);
-  cld_frac_r                        = Array2("Rain cloud fraction", ncol, nlev);
-  cld_frac_l                        = Array2("Liquid cloud fraction", ncol, nlev);
-  cld_frac_i                        = Array2("Ice cloud fraction", ncol, nlev);
-  liq_ice_exchange                  = Array2("sum of liq-ice phase change tendenices", ncol, nlev);
-  vap_liq_exchange                  = Array2("sum of vap-liq phase change tendenices", ncol, nlev);
-  vap_ice_exchange                  = Array2("sum of vap-ice phase change tendenices", ncol, nlev);
+  precip_liq_surf    = Array1("precipitation rate, liquid  m/s", ncol);
+  precip_ice_surf    = Array1("precipitation rate, solid   m/s", ncol);
+  diag_eff_radius_qc = Array2("effective radius, cloud, m", ncol, nlev);
+  diag_eff_radius_qi = Array2("effective radius, ice, m", ncol, nlev);
+  diag_eff_radius_qr = Array2("effective radius, rain, m", ncol, nlev);
+  rho_qi             = Array2("bulk density of ice, kg/m", ncol, nlev);
+  qv2qi_depos_tend   = Array2("qitend due to deposition/sublimation ", ncol, nlev);
+  precip_liq_flux    = Array2("grid-box average rain flux (kg m^-2 s^-1), pverp", ncol, nlev + 1);
+  precip_ice_flux  = Array2("grid-box average ice/snow flux (kg m^-2 s^-1), pverp", ncol, nlev + 1);
+  cld_frac_r       = Array2("Rain cloud fraction", ncol, nlev);
+  cld_frac_l       = Array2("Liquid cloud fraction", ncol, nlev);
+  cld_frac_i       = Array2("Ice cloud fraction", ncol, nlev);
+  liq_ice_exchange = Array2("sum of liq-ice phase change tendenices", ncol, nlev);
+  vap_liq_exchange = Array2("sum of vap-liq phase change tendenices", ncol, nlev);
+  vap_ice_exchange = Array2("sum of vap-ice phase change tendenices", ncol, nlev);
   hetfrz_immersion_nucleation_tend  = Array2("hetfrz_immersion_nucleation_tend", ncol, nlev);
   hetfrz_contact_nucleation_tend    = Array2("hetfrz_contact_nucleation_tend", ncol, nlev);
   hetfrz_deposition_nucleation_tend = Array2("hetfrz_deposition_nucleation_tend", ncol, nlev);
diff --git i/components/eamxx/src/physics/p3/tests/infra/p3_data.hpp w/components/eamxx/src/physics/p3/tests/infra/p3_data.hpp
index 09db024264..1bb81e9482 100644
--- i/components/eamxx/src/physics/p3/tests/infra/p3_data.hpp
+++ w/components/eamxx/src/physics/p3/tests/infra/p3_data.hpp
@@ -28,13 +28,14 @@ struct P3Data {
   // In
   Real dt;
   Int it;
-  Array2 qv, th_atm, pres, dz, nc_nuceat_tend, nccn_prescribed, ni_activated, inv_qc_relvar, qc, nc, qr, nr, qi, ni, qm,
-      bm, dpres, inv_exner, qv_prev, t_prev;
-  Array2 hetfrz_immersion_nucleation_tend, hetfrz_contact_nucleation_tend, hetfrz_deposition_nucleation_tend;
+  Array2 qv, th_atm, pres, dz, nc_nuceat_tend, nccn_prescribed, ni_activated, inv_qc_relvar, qc, nc,
+      qr, nr, qi, ni, qm, bm, dpres, inv_exner, qv_prev, t_prev;
+  Array2 hetfrz_immersion_nucleation_tend, hetfrz_contact_nucleation_tend,
+      hetfrz_deposition_nucleation_tend;
   // Out
   Array1 precip_liq_surf, precip_ice_surf;
-  Array2 diag_eff_radius_qc, diag_eff_radius_qi, diag_eff_radius_qr, rho_qi, qv2qi_depos_tend, precip_liq_flux,
-      precip_ice_flux, cld_frac_r, cld_frac_l, cld_frac_i;
+  Array2 diag_eff_radius_qc, diag_eff_radius_qi, diag_eff_radius_qr, rho_qi, qv2qi_depos_tend,
+      precip_liq_flux, precip_ice_flux, cld_frac_r, cld_frac_l, cld_frac_i;
   Array3 p3_tend_out;
   Array2 liq_ice_exchange, vap_liq_exchange, vap_ice_exchange;
 
diff --git i/components/eamxx/src/physics/p3/tests/infra/p3_ic_cases.cpp w/components/eamxx/src/physics/p3/tests/infra/p3_ic_cases.cpp
index c75ab9d852..e4dfffea7f 100644
--- i/components/eamxx/src/physics/p3/tests/infra/p3_ic_cases.cpp
+++ w/components/eamxx/src/physics/p3/tests/infra/p3_ic_cases.cpp
@@ -88,7 +88,8 @@ P3Data::Ptr make_mixed(const Int ncol, const Int nlev) {
       T_atm(k) = 150 + 150 / double(nk) * k;
       if (i > 0)
         T_atm(k) += ((i % 3) - 0.5) / double(nk) * k;
-      d.th_atm(i, k) = T_atm(k) * std::pow(Real(consts::P0 / d.pres(i, k)), Real(consts::RD / consts::CP));
+      d.th_atm(i, k) =
+          T_atm(k) * std::pow(Real(consts::P0 / d.pres(i, k)), Real(consts::RD / consts::CP));
     }
 
     // The next section modifies inout variables to satisfy weird conditions
@@ -122,10 +123,12 @@ P3Data::Ptr make_mixed(const Int ncol, const Int nlev) {
     static constexpr double g = 9.8; // gravity, m/s^2
     for (k = 0; k < nk; ++k) {
       double plo, phi; // pressure at cell edges, Pa
-      plo              = (k == 0) ? std::max<double>(i, d.pres(i, 0) - 0.5 * (d.pres(i, 1) - d.pres(i, 0)) / (1 - 0))
-                                  : 0.5 * (d.pres(i, k - 1) + d.pres(i, k));
-      phi              = (k == nk - 1) ? d.pres(i, nk - 1) + 0.5 * (d.pres(i, nk - 1) - d.pres(i, nk - 2)) / (1 - 0)
-                                       : 0.5 * (d.pres(i, k) + d.pres(i, k + 1));
+      plo              = (k == 0)
+                             ? std::max<double>(i, d.pres(i, 0) - 0.5 * (d.pres(i, 1) - d.pres(i, 0)) / (1 - 0))
+                             : 0.5 * (d.pres(i, k - 1) + d.pres(i, k));
+      phi              = (k == nk - 1)
+                             ? d.pres(i, nk - 1) + 0.5 * (d.pres(i, nk - 1) - d.pres(i, nk - 2)) / (1 - 0)
+                             : 0.5 * (d.pres(i, k) + d.pres(i, k + 1));
       const auto dpres = phi - plo;
       d.dz(i, k)       = consts::RD * T_atm(k) / (g * d.pres(i, k)) * dpres;
     }
diff --git i/components/eamxx/src/physics/p3/tests/infra/p3_main_wrap.cpp w/components/eamxx/src/physics/p3/tests/infra/p3_main_wrap.cpp
index 2d173f9f5c..16e3f71c8e 100644
--- i/components/eamxx/src/physics/p3/tests/infra/p3_main_wrap.cpp
+++ w/components/eamxx/src/physics/p3/tests/infra/p3_main_wrap.cpp
@@ -14,15 +14,17 @@ namespace p3 {
 
 Int p3_main_wrap(const P3Data &d) {
   EKAT_REQUIRE_MSG(d.dt > 0, "invalid dt");
-  return p3_main_host(d.qc.data(), d.nc.data(), d.qr.data(), d.nr.data(), d.th_atm.data(), d.qv.data(), d.dt,
-                      d.qi.data(), d.qm.data(), d.ni.data(), d.bm.data(), d.pres.data(), d.dz.data(),
-                      d.nc_nuceat_tend.data(), d.nccn_prescribed.data(), d.ni_activated.data(), d.inv_qc_relvar.data(),
-                      d.it, d.precip_liq_surf.data(), d.precip_ice_surf.data(), 1, d.ncol, 1, d.nlev,
-                      d.diag_eff_radius_qc.data(), d.diag_eff_radius_qi.data(), d.diag_eff_radius_qr.data(),
-                      d.rho_qi.data(), d.do_predict_nc, d.do_prescribed_CCN, d.use_hetfrz_classnuc, d.dpres.data(),
-                      d.inv_exner.data(), d.qv2qi_depos_tend.data(), d.precip_liq_flux.data(), d.precip_ice_flux.data(),
-                      d.cld_frac_r.data(), d.cld_frac_l.data(), d.cld_frac_i.data(), d.liq_ice_exchange.data(),
-                      d.vap_liq_exchange.data(), d.vap_ice_exchange.data(), d.qv_prev.data(), d.t_prev.data());
+  return p3_main_host(d.qc.data(), d.nc.data(), d.qr.data(), d.nr.data(), d.th_atm.data(),
+                      d.qv.data(), d.dt, d.qi.data(), d.qm.data(), d.ni.data(), d.bm.data(),
+                      d.pres.data(), d.dz.data(), d.nc_nuceat_tend.data(), d.nccn_prescribed.data(),
+                      d.ni_activated.data(), d.inv_qc_relvar.data(), d.it, d.precip_liq_surf.data(),
+                      d.precip_ice_surf.data(), 1, d.ncol, 1, d.nlev, d.diag_eff_radius_qc.data(),
+                      d.diag_eff_radius_qi.data(), d.diag_eff_radius_qr.data(), d.rho_qi.data(),
+                      d.do_predict_nc, d.do_prescribed_CCN, d.use_hetfrz_classnuc, d.dpres.data(),
+                      d.inv_exner.data(), d.qv2qi_depos_tend.data(), d.precip_liq_flux.data(),
+                      d.precip_ice_flux.data(), d.cld_frac_r.data(), d.cld_frac_l.data(),
+                      d.cld_frac_i.data(), d.liq_ice_exchange.data(), d.vap_liq_exchange.data(),
+                      d.vap_ice_exchange.data(), d.qv_prev.data(), d.t_prev.data());
 }
 
 int test_p3_init() {
diff --git i/components/eamxx/src/physics/p3/tests/infra/p3_test_data.cpp w/components/eamxx/src/physics/p3/tests/infra/p3_test_data.cpp
index 787971344f..d39f3dda26 100644
--- i/components/eamxx/src/physics/p3/tests/infra/p3_test_data.cpp
+++ w/components/eamxx/src/physics/p3/tests/infra/p3_test_data.cpp
@@ -70,18 +70,22 @@ void CalcLiqRelaxationData::randomize(std::mt19937_64 &engine) {
   qc_incld = data_dist(engine);
 }
 
-CheckValuesData::CheckValuesData(Int kts_, Int kte_, Int timestepcount_, Int source_ind_, bool force_abort_)
+CheckValuesData::CheckValuesData(Int kts_, Int kte_, Int timestepcount_, Int source_ind_,
+                                 bool force_abort_)
     : PhysicsTestData({{(kte_ - kts_) + 1}}, {{&qv, &temp, &col_loc}}), kts(kts_), kte(kte_),
       timestepcount(timestepcount_), source_ind(source_ind_), force_abort(force_abort_) {
   EKAT_REQUIRE_MSG(nk() >= 3 || (kte == 1 && kts == 1), "nk too small to use for col_loc");
 }
 
-CalcUpwindData::CalcUpwindData(Int kts_, Int kte_, Int kdir_, Int kbot_, Int k_qxtop_, Int num_arrays_, Real dt_sub_)
+CalcUpwindData::CalcUpwindData(Int kts_, Int kte_, Int kdir_, Int kbot_, Int k_qxtop_,
+                               Int num_arrays_, Real dt_sub_)
     : PhysicsTestData({{(kte_ - kts_) + 1, num_arrays_}, {(kte_ - kts_) + 1}},
                       {{&vs, &qnx, &fluxes}, {&rho, &inv_rho, &inv_dz}}),
-      kts(kts_), kte(kte_), kdir(kdir_), kbot(kbot_), k_qxtop(k_qxtop_), num_arrays(num_arrays_), dt_sub(dt_sub_) {}
+      kts(kts_), kte(kte_), kdir(kdir_), kbot(kbot_), k_qxtop(k_qxtop_), num_arrays(num_arrays_),
+      dt_sub(dt_sub_) {}
 
-void CalcUpwindData::convert_to_ptr_arr(std::vector<Real *> &mem_space, Real **&fluxes_, Real **&vs_, Real **&qnx_) {
+void CalcUpwindData::convert_to_ptr_arr(std::vector<Real *> &mem_space, Real **&fluxes_,
+                                        Real **&vs_, Real **&qnx_) {
   mem_space.resize(num_arrays * 3);
   for (Int i = 0; i < num_arrays; ++i) {
     mem_space[i]                  = fluxes + (i * nk());
@@ -93,40 +97,44 @@ void CalcUpwindData::convert_to_ptr_arr(std::vector<Real *> &mem_space, Real **&
   qnx_    = mem_space.data() + num_arrays * 2;
 }
 
-GenSedData::GenSedData(Int kts_, Int kte_, Int kdir_, Int k_qxtop_, Int k_qxbot_, Int kbot_, Real Co_max_,
-                       Real dt_left_, Real prt_accum_, Int num_arrays_)
-    : CalcUpwindData(kts_, kte_, kdir_, kbot_, k_qxtop_, num_arrays_, 0.0), Co_max(Co_max_), k_qxbot(k_qxbot_),
-      dt_left(dt_left_), prt_accum(prt_accum_) {}
+GenSedData::GenSedData(Int kts_, Int kte_, Int kdir_, Int k_qxtop_, Int k_qxbot_, Int kbot_,
+                       Real Co_max_, Real dt_left_, Real prt_accum_, Int num_arrays_)
+    : CalcUpwindData(kts_, kte_, kdir_, kbot_, k_qxtop_, num_arrays_, 0.0), Co_max(Co_max_),
+      k_qxbot(k_qxbot_), dt_left(dt_left_), prt_accum(prt_accum_) {}
 
-CloudSedData::CloudSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_, Real inv_dt_,
-                           bool do_predict_nc_, Real precip_liq_surf_)
-    : PhysicsTestData({{(kte_ - kts_) + 1}}, {{&qc_incld, &rho, &inv_rho, &cld_frac_l, &acn, &inv_dz, &qc, &nc,
-                                               &nc_incld, &mu_c, &lamc, &qc_tend, &nc_tend}}),
+CloudSedData::CloudSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_,
+                           Real inv_dt_, bool do_predict_nc_, Real precip_liq_surf_)
+    : PhysicsTestData({{(kte_ - kts_) + 1}},
+                      {{&qc_incld, &rho, &inv_rho, &cld_frac_l, &acn, &inv_dz, &qc, &nc, &nc_incld,
+                        &mu_c, &lamc, &qc_tend, &nc_tend}}),
       kts(kts_), kte(kte_), ktop(ktop_), kbot(kbot_), kdir(kdir_), dt(dt_), inv_dt(inv_dt_),
       do_predict_nc(do_predict_nc_), precip_liq_surf(precip_liq_surf_) {}
 
 IceSedData::IceSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_, Real inv_dt_,
                        Real precip_ice_surf_)
-    : PhysicsTestData({{(kte_ - kts_) + 1}}, {{&rho, &inv_rho, &rhofaci, &cld_frac_i, &inv_dz, &qi, &qi_incld, &ni,
-                                               &ni_incld, &qm, &qm_incld, &bm, &bm_incld, &qi_tend, &ni_tend}}),
+    : PhysicsTestData({{(kte_ - kts_) + 1}},
+                      {{&rho, &inv_rho, &rhofaci, &cld_frac_i, &inv_dz, &qi, &qi_incld, &ni,
+                        &ni_incld, &qm, &qm_incld, &bm, &bm_incld, &qi_tend, &ni_tend}}),
       kts(kts_), kte(kte_), ktop(ktop_), kbot(kbot_), kdir(kdir_), dt(dt_), inv_dt(inv_dt_),
       precip_ice_surf(precip_ice_surf_) {}
 
-RainSedData::RainSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_, Real inv_dt_,
-                         Real precip_liq_surf_)
-    : PhysicsTestData({{(kte_ - kts_) + 2}}, // extra real at end for precip_liq_flux, so just add 1 to all
-                      {{&rho, &inv_rho, &rhofacr, &cld_frac_r, &inv_dz, &qr_incld, &qr, &nr, &nr_incld, &mu_r, &lamr,
-                        &qr_tend, &nr_tend, &precip_liq_flux}}),
+RainSedData::RainSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_,
+                         Real inv_dt_, Real precip_liq_surf_)
+    : PhysicsTestData(
+          {{(kte_ - kts_) + 2}}, // extra real at end for precip_liq_flux, so just add 1 to all
+          {{&rho, &inv_rho, &rhofacr, &cld_frac_r, &inv_dz, &qr_incld, &qr, &nr, &nr_incld, &mu_r,
+            &lamr, &qr_tend, &nr_tend, &precip_liq_flux}}),
       kts(kts_), kte(kte_), ktop(ktop_), kbot(kbot_), kdir(kdir_), dt(dt_), inv_dt(inv_dt_),
       precip_liq_surf(precip_liq_surf_) {}
 
-HomogeneousFreezingData::HomogeneousFreezingData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_)
-    : PhysicsTestData({{(kte_ - kts_) + 1}},
-                      {{&T_atm, &inv_exner, &latent_heat_fusion, &qc, &nc, &qr, &nr, &qi, &ni, &qm, &bm, &th_atm}}),
+HomogeneousFreezingData::HomogeneousFreezingData(Int kts_, Int kte_, Int ktop_, Int kbot_,
+                                                 Int kdir_)
+    : PhysicsTestData({{(kte_ - kts_) + 1}}, {{&T_atm, &inv_exner, &latent_heat_fusion, &qc, &nc,
+                                               &qr, &nr, &qi, &ni, &qm, &bm, &th_atm}}),
       kts(kts_), kte(kte_), ktop(ktop_), kbot(kbot_), kdir(kdir_) {}
 
-P3MainPart1Data::P3MainPart1Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int kdir_, bool do_predict_nc_,
-                                 bool do_prescribed_CCN_, Real dt_, bool, bool)
+P3MainPart1Data::P3MainPart1Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int kdir_,
+                                 bool do_predict_nc_, bool do_prescribed_CCN_, Real dt_, bool, bool)
     : PhysicsTestData({{(kte_ - kts_) + 1}}, {{&pres,
                                                &dpres,
                                                &dz,
@@ -172,8 +180,8 @@ P3MainPart1Data::P3MainPart1Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int k
 
 ///////////////////////////////////////////////////////////////////////////////
 
-P3MainPart2Data::P3MainPart2Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int kdir_, bool do_predict_nc_,
-                                 bool do_prescribed_CCN_, Real dt_, Real, bool)
+P3MainPart2Data::P3MainPart2Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int kdir_,
+                                 bool do_predict_nc_, bool do_prescribed_CCN_, Real dt_, Real, bool)
     : PhysicsTestData({{(kte_ - kts_) + 1}}, {{&pres,
                                                &dpres,
                                                &dz,
@@ -282,51 +290,53 @@ P3MainPart3Data::P3MainPart3Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int k
 
 ///////////////////////////////////////////////////////////////////////////////
 
-P3MainData::P3MainData(Int its_, Int ite_, Int kts_, Int kte_, Int it_, Real dt_, bool do_predict_nc_,
-                       bool do_prescribed_CCN_, Real)
-    : PhysicsTestData({{(ite_ - its_) + 1, (kte_ - kts_) + 1}, {(ite_ - its_) + 1, (kte_ - kts_) + 2}},
-                      {{&pres,
-                        &dz,
-                        &nc_nuceat_tend,
-                        &nccn_prescribed,
-                        &ni_activated,
-                        &dpres,
-                        &inv_exner,
-                        &cld_frac_i,
-                        &cld_frac_l,
-                        &cld_frac_r,
-                        &inv_qc_relvar,
-                        &qc,
-                        &nc,
-                        &qr,
-                        &nr,
-                        &qi,
-                        &qm,
-                        &ni,
-                        &bm,
-                        &qv,
-                        &th_atm,
-                        &qv_prev,
-                        &t_prev,
-                        &diag_eff_radius_qc,
-                        &diag_eff_radius_qi,
-                        &diag_eff_radius_qr,
-                        &rho_qi,
-                        &mu_c,
-                        &lamc,
-                        &qv2qi_depos_tend,
-                        &precip_total_tend,
-                        &nevapr,
-                        &qr_evap_tend,
-                        &liq_ice_exchange,
-                        &vap_liq_exchange,
-                        &vap_ice_exchange,
-                        &precip_liq_flux,
-                        &precip_ice_flux},
-                       {&precip_liq_surf, &precip_ice_surf}}), // these two are (ni, nk+1)
+P3MainData::P3MainData(Int its_, Int ite_, Int kts_, Int kte_, Int it_, Real dt_,
+                       bool do_predict_nc_, bool do_prescribed_CCN_, Real)
+    : PhysicsTestData(
+          {{(ite_ - its_) + 1, (kte_ - kts_) + 1}, {(ite_ - its_) + 1, (kte_ - kts_) + 2}},
+          {{&pres,
+            &dz,
+            &nc_nuceat_tend,
+            &nccn_prescribed,
+            &ni_activated,
+            &dpres,
+            &inv_exner,
+            &cld_frac_i,
+            &cld_frac_l,
+            &cld_frac_r,
+            &inv_qc_relvar,
+            &qc,
+            &nc,
+            &qr,
+            &nr,
+            &qi,
+            &qm,
+            &ni,
+            &bm,
+            &qv,
+            &th_atm,
+            &qv_prev,
+            &t_prev,
+            &diag_eff_radius_qc,
+            &diag_eff_radius_qi,
+            &diag_eff_radius_qr,
+            &rho_qi,
+            &mu_c,
+            &lamc,
+            &qv2qi_depos_tend,
+            &precip_total_tend,
+            &nevapr,
+            &qr_evap_tend,
+            &liq_ice_exchange,
+            &vap_liq_exchange,
+            &vap_ice_exchange,
+            &precip_liq_flux,
+            &precip_ice_flux},
+           {&precip_liq_surf, &precip_ice_surf}}), // these two are (ni, nk+1)
       its(its_), ite(ite_), kts(kts_), kte(kte_), it(it_), dt(dt_), do_predict_nc(do_predict_nc_),
-      do_prescribed_CCN(do_prescribed_CCN_), use_hetfrz_classnuc(false), hetfrz_immersion_nucleation_tend(nullptr),
-      hetfrz_contact_nucleation_tend(nullptr), hetfrz_deposition_nucleation_tend(nullptr) {}
+      do_prescribed_CCN(do_prescribed_CCN_), use_hetfrz_classnuc(false),
+      hetfrz_immersion_nucleation_tend(nullptr), hetfrz_contact_nucleation_tend(nullptr),
+      hetfrz_deposition_nucleation_tend(nullptr) {}
 
 void IceSupersatConservationData::randomize(std::mt19937_64 &engine) {
   std::uniform_real_distribution<Real> data_dist(0.0, 1.0);
@@ -397,7 +407,8 @@ void PreventLiqSupersaturationData::randomize(std::mt19937_64 &engine) {
   // Construct random input data
   using RPDF = std::uniform_real_distribution<Real>;
   RPDF pdf_qv(1e-5, 1e-3), pdf_pres(0.1, 102000), pdf_temp(200.0, 300.0),
-      // pdf_dt(0.1,300.), //since dt is Scalar, always gets set to 1st index of Pack... so can't use rand val here.
+      // pdf_dt(0.1,300.), //since dt is Scalar, always gets set to 1st index of Pack... so can't
+      // use rand val here.
       pdf_rate(0., 1e-3);
 
   Real cp = 1004; // approx cp is good enough for testing.
@@ -414,12 +425,12 @@ void PreventLiqSupersaturationData::randomize(std::mt19937_64 &engine) {
   qinuc = std::min(pdf_rate(engine), qv / dt - qidep); // don't let qidep+qinuc make qv neg
 
   // qv sources: don't let T go neg.
-  qi2qv_sublim_tend =
-      std::min(pdf_rate(engine), cp / latent_heat_sublim * t_atm / dt + qidep + qinuc); // don't let sublim make T neg.
+  qi2qv_sublim_tend = std::min(pdf_rate(engine), cp / latent_heat_sublim * t_atm / dt + qidep +
+                                                     qinuc); // don't let sublim make T neg.
 
-  qr2qv_evap_tend =
-      std::min(pdf_rate(engine), cp / latent_heat_vapor * t_atm / dt +
-                                     (qidep + qinuc - qi2qv_sublim_tend) * latent_heat_sublim / latent_heat_vapor);
+  qr2qv_evap_tend = std::min(pdf_rate(engine), cp / latent_heat_vapor * t_atm / dt +
+                                                   (qidep + qinuc - qi2qv_sublim_tend) *
+                                                       latent_heat_sublim / latent_heat_vapor);
 
   /*
   pres                     = data_dist(engine);
@@ -450,8 +461,9 @@ template <typename T> std::vector<T *> ptr_to_arr(T **data, int n) {
 }
 
 template <int N>
-void calc_first_order_upwind_step_host_impl(Int kts, Int kte, Int kdir, Int kbot, Int k_qxtop, Real dt_sub, Real *rho,
-                                            Real *inv_rho, Real *inv_dz, Real **fluxes, Real **vs, Real **qnx) {
+void calc_first_order_upwind_step_host_impl(Int kts, Int kte, Int kdir, Int kbot, Int k_qxtop,
+                                            Real dt_sub, Real *rho, Real *inv_rho, Real *inv_dz,
+                                            Real **fluxes, Real **vs, Real **qnx) {
   using P3F = Functions<Real, DefaultDevice>;
 
   using Spack             = typename P3F::Spack;
@@ -503,8 +515,8 @@ void calc_first_order_upwind_step_host_impl(Int kts, Int kte, Int kdir, Int kbot
           qnx_ptr[i]    = (uview_1d *)(&qnx_a[i]);
         }
         uview_1d urho_d(rho_d), uinv_rho_d(inv_rho_d), uinv_dz_d(inv_dz_d);
-        P3F::calc_first_order_upwind_step<N>(urho_d, uinv_rho_d, uinv_dz_d, team, nk, kbot, k_qxtop, kdir, dt_sub,
-                                             fluxes_ptr, vs_ptr, qnx_ptr);
+        P3F::calc_first_order_upwind_step<N>(urho_d, uinv_rho_d, uinv_dz_d, team, nk, kbot, k_qxtop,
+                                             kdir, dt_sub, fluxes_ptr, vs_ptr, qnx_ptr);
       });
 
   // Sync back to host
@@ -513,9 +525,10 @@ void calc_first_order_upwind_step_host_impl(Int kts, Int kte, Int kdir, Int kbot
 }
 
 template <int N>
-void generalized_sedimentation_host_impl(Int kts, Int kte, Int kdir, Int k_qxtop, Int *k_qxbot, Int kbot, Real Co_max,
-                                         Real *dt_left, Real *prt_accum, Real *inv_dz, Real *inv_rho, Real *rho,
-                                         Real **vs, Real **fluxes, Real **qnx) {
+void generalized_sedimentation_host_impl(Int kts, Int kte, Int kdir, Int k_qxtop, Int *k_qxbot,
+                                         Int kbot, Real Co_max, Real *dt_left, Real *prt_accum,
+                                         Real *inv_dz, Real *inv_rho, Real *rho, Real **vs,
+                                         Real **fluxes, Real **qnx) {
   using P3F = Functions<Real, DefaultDevice>;
 
   using Spack             = typename P3F::Spack;
@@ -583,8 +596,9 @@ void generalized_sedimentation_host_impl(Int kts, Int kte, Int kdir, Int k_qxtop
         Real dt_left_k   = scalars_d(1)[0];
         Int k_qxbot_k    = static_cast<int>(scalars_d(2)[0]);
 
-        P3F::generalized_sedimentation<N>(urho_d, uinv_rho_d, uinv_dz_d, team, nk, k_qxtop, k_qxbot_k, kbot, kdir,
-                                          Co_max, dt_left_k, prt_accum_k, fluxes_ptr, vs_ptr, qnx_ptr);
+        P3F::generalized_sedimentation<N>(urho_d, uinv_rho_d, uinv_dz_d, team, nk, k_qxtop,
+                                          k_qxbot_k, kbot, kdir, Co_max, dt_left_k, prt_accum_k,
+                                          fluxes_ptr, vs_ptr, qnx_ptr);
 
         scalars_d(0)[0] = prt_accum_k;
         scalars_d(1)[0] = dt_left_k;
@@ -602,43 +616,47 @@ void generalized_sedimentation_host_impl(Int kts, Int kte, Int kdir, Int k_qxtop
   *k_qxbot   = scalars[2] + 1;
 }
 
-void calc_first_order_upwind_step_host(Int kts, Int kte, Int kdir, Int kbot, Int k_qxtop, Real dt_sub, Real *rho,
-                                       Real *inv_rho, Real *inv_dz, Int num_arrays, Real **fluxes, Real **vs,
-                                       Real **qnx) {
+void calc_first_order_upwind_step_host(Int kts, Int kte, Int kdir, Int kbot, Int k_qxtop,
+                                       Real dt_sub, Real *rho, Real *inv_rho, Real *inv_dz,
+                                       Int num_arrays, Real **fluxes, Real **vs, Real **qnx) {
   if (num_arrays == 1) {
-    calc_first_order_upwind_step_host_impl<1>(kts, kte, kdir, kbot, k_qxtop, dt_sub, rho, inv_rho, inv_dz, fluxes, vs,
-                                              qnx);
+    calc_first_order_upwind_step_host_impl<1>(kts, kte, kdir, kbot, k_qxtop, dt_sub, rho, inv_rho,
+                                              inv_dz, fluxes, vs, qnx);
   } else if (num_arrays == 2) {
-    calc_first_order_upwind_step_host_impl<2>(kts, kte, kdir, kbot, k_qxtop, dt_sub, rho, inv_rho, inv_dz, fluxes, vs,
-                                              qnx);
+    calc_first_order_upwind_step_host_impl<2>(kts, kte, kdir, kbot, k_qxtop, dt_sub, rho, inv_rho,
+                                              inv_dz, fluxes, vs, qnx);
   } else if (num_arrays == 4) {
-    calc_first_order_upwind_step_host_impl<4>(kts, kte, kdir, kbot, k_qxtop, dt_sub, rho, inv_rho, inv_dz, fluxes, vs,
-                                              qnx);
+    calc_first_order_upwind_step_host_impl<4>(kts, kte, kdir, kbot, k_qxtop, dt_sub, rho, inv_rho,
+                                              inv_dz, fluxes, vs, qnx);
   } else {
-    EKAT_REQUIRE_MSG(false, "Unsupported num arrays in bridge calc_first_order_upwind_step_f: " << num_arrays);
+    EKAT_REQUIRE_MSG(
+        false, "Unsupported num arrays in bridge calc_first_order_upwind_step_f: " << num_arrays);
   }
 }
 
-void generalized_sedimentation_host(Int kts, Int kte, Int kdir, Int k_qxtop, Int *k_qxbot, Int kbot, Real Co_max,
-                                    Real *dt_left, Real *prt_accum, Real *inv_dz, Real *inv_rho, Real *rho,
-                                    Int num_arrays, Real **vs, Real **fluxes, Real **qnx) {
+void generalized_sedimentation_host(Int kts, Int kte, Int kdir, Int k_qxtop, Int *k_qxbot, Int kbot,
+                                    Real Co_max, Real *dt_left, Real *prt_accum, Real *inv_dz,
+                                    Real *inv_rho, Real *rho, Int num_arrays, Real **vs,
+                                    Real **fluxes, Real **qnx) {
   if (num_arrays == 1) {
-    generalized_sedimentation_host_impl<1>(kts, kte, kdir, k_qxtop, k_qxbot, kbot, Co_max, dt_left, prt_accum, inv_dz,
-                                           inv_rho, rho, vs, fluxes, qnx);
+    generalized_sedimentation_host_impl<1>(kts, kte, kdir, k_qxtop, k_qxbot, kbot, Co_max, dt_left,
+                                           prt_accum, inv_dz, inv_rho, rho, vs, fluxes, qnx);
   } else if (num_arrays == 2) {
-    generalized_sedimentation_host_impl<2>(kts, kte, kdir, k_qxtop, k_qxbot, kbot, Co_max, dt_left, prt_accum, inv_dz,
-                                           inv_rho, rho, vs, fluxes, qnx);
+    generalized_sedimentation_host_impl<2>(kts, kte, kdir, k_qxtop, k_qxbot, kbot, Co_max, dt_left,
+                                           prt_accum, inv_dz, inv_rho, rho, vs, fluxes, qnx);
   } else if (num_arrays == 4) {
-    generalized_sedimentation_host_impl<4>(kts, kte, kdir, k_qxtop, k_qxbot, kbot, Co_max, dt_left, prt_accum, inv_dz,
-                                           inv_rho, rho, vs, fluxes, qnx);
+    generalized_sedimentation_host_impl<4>(kts, kte, kdir, k_qxtop, k_qxbot, kbot, Co_max, dt_left,
+                                           prt_accum, inv_dz, inv_rho, rho, vs, fluxes, qnx);
   } else {
-    EKAT_REQUIRE_MSG(false, "Unsupported num arrays in bridge calc_first_order_upwind_step_f: " << num_arrays);
+    EKAT_REQUIRE_MSG(
+        false, "Unsupported num arrays in bridge calc_first_order_upwind_step_f: " << num_arrays);
   }
 }
 
-void cloud_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *qc_incld, Real *rho, Real *inv_rho,
-                              Real *cld_frac_l, Real *acn, Real *inv_dz, Real dt, Real inv_dt, bool do_predict_nc,
-                              Real *qc, Real *nc, Real *nc_incld, Real *mu_c, Real *lamc, Real *precip_liq_surf,
+void cloud_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *qc_incld,
+                              Real *rho, Real *inv_rho, Real *cld_frac_l, Real *acn, Real *inv_dz,
+                              Real dt, Real inv_dt, bool do_predict_nc, Real *qc, Real *nc,
+                              Real *nc_incld, Real *mu_c, Real *lamc, Real *precip_liq_surf,
                               Real *qc_tend, Real *nc_tend) {
   using P3F = Functions<Real, DefaultDevice>;
 
@@ -664,12 +682,14 @@ void cloud_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Re
 
   std::vector<view_1d> temp_d(CloudSedData::NUM_ARRAYS);
 
-  ekat::host_to_device(
-      {qc_incld, rho, inv_rho, cld_frac_l, acn, inv_dz, qc, nc, nc_incld, mu_c, lamc, qc_tend, nc_tend}, nk, temp_d);
+  ekat::host_to_device({qc_incld, rho, inv_rho, cld_frac_l, acn, inv_dz, qc, nc, nc_incld, mu_c,
+                        lamc, qc_tend, nc_tend},
+                       nk, temp_d);
 
-  view_1d qc_incld_d(temp_d[0]), rho_d(temp_d[1]), inv_rho_d(temp_d[2]), cld_frac_l_d(temp_d[3]), acn_d(temp_d[4]),
-      inv_dz_d(temp_d[5]), qc_d(temp_d[6]), nc_d(temp_d[7]), nc_incld_d(temp_d[8]), mu_c_d(temp_d[9]),
-      lamc_d(temp_d[10]), qc_tend_d(temp_d[11]), nc_tend_d(temp_d[12]);
+  view_1d qc_incld_d(temp_d[0]), rho_d(temp_d[1]), inv_rho_d(temp_d[2]), cld_frac_l_d(temp_d[3]),
+      acn_d(temp_d[4]), inv_dz_d(temp_d[5]), qc_d(temp_d[6]), nc_d(temp_d[7]),
+      nc_incld_d(temp_d[8]), mu_c_d(temp_d[9]), lamc_d(temp_d[10]), qc_tend_d(temp_d[11]),
+      nc_tend_d(temp_d[12]);
 
   // Call core function from kernel
   auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(1, nk_pack);
@@ -677,9 +697,10 @@ void cloud_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Re
   Kokkos::parallel_reduce(
       policy,
       KOKKOS_LAMBDA(const MemberType &team, Real &precip_liq_surf_k) {
-        P3F::cloud_sedimentation(qc_incld_d, rho_d, inv_rho_d, cld_frac_l_d, acn_d, inv_dz_d, dnu, team,
-                                 wsm.get_workspace(team), nk, ktop, kbot, kdir, dt, inv_dt, do_predict_nc, qc_d, nc_d,
-                                 nc_incld_d, mu_c_d, lamc_d, qc_tend_d, nc_tend_d, precip_liq_surf_k);
+        P3F::cloud_sedimentation(qc_incld_d, rho_d, inv_rho_d, cld_frac_l_d, acn_d, inv_dz_d, dnu,
+                                 team, wsm.get_workspace(team), nk, ktop, kbot, kdir, dt, inv_dt,
+                                 do_predict_nc, qc_d, nc_d, nc_incld_d, mu_c_d, lamc_d, qc_tend_d,
+                                 nc_tend_d, precip_liq_surf_k);
       },
       *precip_liq_surf);
 
@@ -688,10 +709,11 @@ void cloud_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Re
   ekat::device_to_host({qc, nc, nc_incld, mu_c, lamc, qc_tend, nc_tend}, nk, inout_views);
 }
 
-void ice_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *rho, Real *inv_rho, Real *rhofaci,
-                            Real *cld_frac_i, Real *inv_dz, Real dt, Real inv_dt, Real *qi, Real *qi_incld, Real *ni,
-                            Real *qm, Real *qm_incld, Real *bm, Real *bm_incld, Real *ni_incld, Real *precip_ice_surf,
-                            Real *qi_tend, Real *ni_tend) {
+void ice_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *rho,
+                            Real *inv_rho, Real *rhofaci, Real *cld_frac_i, Real *inv_dz, Real dt,
+                            Real inv_dt, Real *qi, Real *qi_incld, Real *ni, Real *qm,
+                            Real *qm_incld, Real *bm, Real *bm_incld, Real *ni_incld,
+                            Real *precip_ice_surf, Real *qi_tend, Real *ni_tend) {
   using P3F = Functions<Real, DefaultDevice>;
 
   using Spack      = typename P3F::Spack;
@@ -714,13 +736,14 @@ void ice_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real
   // Set up views
   std::vector<view_1d> temp_d(IceSedData::NUM_ARRAYS);
 
-  ekat::host_to_device({rho, inv_rho, rhofaci, cld_frac_i, inv_dz, qi, qi_incld, ni, qm, qm_incld, bm, bm_incld,
-                        ni_incld, qi_tend, ni_tend},
+  ekat::host_to_device({rho, inv_rho, rhofaci, cld_frac_i, inv_dz, qi, qi_incld, ni, qm, qm_incld,
+                        bm, bm_incld, ni_incld, qi_tend, ni_tend},
                        nk, temp_d);
 
-  view_1d rho_d(temp_d[0]), inv_rho_d(temp_d[1]), rhofaci_d(temp_d[2]), cld_frac_i_d(temp_d[3]), inv_dz_d(temp_d[4]),
-      qi_d(temp_d[5]), qi_incld_d(temp_d[6]), ni_d(temp_d[7]), qm_d(temp_d[8]), qm_incld_d(temp_d[9]), bm_d(temp_d[10]),
-      bm_incld_d(temp_d[11]), ni_incld_d(temp_d[12]), qi_tend_d(temp_d[13]), ni_tend_d(temp_d[14]);
+  view_1d rho_d(temp_d[0]), inv_rho_d(temp_d[1]), rhofaci_d(temp_d[2]), cld_frac_i_d(temp_d[3]),
+      inv_dz_d(temp_d[4]), qi_d(temp_d[5]), qi_incld_d(temp_d[6]), ni_d(temp_d[7]), qm_d(temp_d[8]),
+      qm_incld_d(temp_d[9]), bm_d(temp_d[10]), bm_incld_d(temp_d[11]), ni_incld_d(temp_d[12]),
+      qi_tend_d(temp_d[13]), ni_tend_d(temp_d[14]);
 
   // Call core function from kernel
   auto ice_table_vals = P3F::p3_init().ice_table_vals;
@@ -730,9 +753,11 @@ void ice_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real
   Kokkos::parallel_reduce(
       policy,
       KOKKOS_LAMBDA(const MemberType &team, Real &precip_ice_surf_k) {
-        P3F::ice_sedimentation(rho_d, inv_rho_d, rhofaci_d, cld_frac_i_d, inv_dz_d, team, wsm.get_workspace(team), nk,
-                               ktop, kbot, kdir, dt, inv_dt, qi_d, qi_incld_d, ni_d, ni_incld_d, qm_d, qm_incld_d, bm_d,
-                               bm_incld_d, qi_tend_d, ni_tend_d, ice_table_vals, precip_ice_surf_k, P3F::P3Runtime());
+        P3F::ice_sedimentation(rho_d, inv_rho_d, rhofaci_d, cld_frac_i_d, inv_dz_d, team,
+                               wsm.get_workspace(team), nk, ktop, kbot, kdir, dt, inv_dt, qi_d,
+                               qi_incld_d, ni_d, ni_incld_d, qm_d, qm_incld_d, bm_d, bm_incld_d,
+                               qi_tend_d, ni_tend_d, ice_table_vals, precip_ice_surf_k,
+                               P3F::P3Runtime());
       },
       my_precip_ice_surf);
   *precip_ice_surf += my_precip_ice_surf;
@@ -740,12 +765,14 @@ void ice_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real
   // Sync back to host
   std::vector<view_1d> inout_views = {qi_d,       qi_incld_d, ni_d,       ni_incld_d, qm_d,
                                       qm_incld_d, bm_d,       bm_incld_d, qi_tend_d,  ni_tend_d};
-  ekat::device_to_host({qi, qi_incld, ni, ni_incld, qm, qm_incld, bm, bm_incld, qi_tend, ni_tend}, nk, inout_views);
+  ekat::device_to_host({qi, qi_incld, ni, ni_incld, qm, qm_incld, bm, bm_incld, qi_tend, ni_tend},
+                       nk, inout_views);
 }
 
-void rain_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *qr_incld, Real *rho, Real *inv_rho,
-                             Real *rhofacr, Real *cld_frac_r, Real *inv_dz, Real dt, Real inv_dt, Real *qr, Real *nr,
-                             Real *nr_incld, Real *mu_r, Real *lamr, Real *precip_liq_surf, Real *precip_liq_flux,
+void rain_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *qr_incld,
+                             Real *rho, Real *inv_rho, Real *rhofacr, Real *cld_frac_r,
+                             Real *inv_dz, Real dt, Real inv_dt, Real *qr, Real *nr, Real *nr_incld,
+                             Real *mu_r, Real *lamr, Real *precip_liq_surf, Real *precip_liq_flux,
                              Real *qr_tend, Real *nr_tend) {
   using P3F = Functions<Real, DefaultDevice>;
 
@@ -771,13 +798,14 @@ void rain_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Rea
   std::vector<size_t> sizes(RainSedData::NUM_ARRAYS, nk);
   sizes[RainSedData::NUM_ARRAYS - 1] = nk + 1;
 
-  ekat::host_to_device({qr_incld, rho, inv_rho, rhofacr, cld_frac_r, inv_dz, qr, nr, nr_incld, mu_r, lamr, qr_tend,
-                        nr_tend, precip_liq_flux},
+  ekat::host_to_device({qr_incld, rho, inv_rho, rhofacr, cld_frac_r, inv_dz, qr, nr, nr_incld, mu_r,
+                        lamr, qr_tend, nr_tend, precip_liq_flux},
                        sizes, temp_d);
 
-  view_1d qr_incld_d(temp_d[0]), rho_d(temp_d[1]), inv_rho_d(temp_d[2]), rhofacr_d(temp_d[3]), cld_frac_r_d(temp_d[4]),
-      inv_dz_d(temp_d[5]), qr_d(temp_d[6]), nr_d(temp_d[7]), nr_incld_d(temp_d[8]), mu_r_d(temp_d[9]),
-      lamr_d(temp_d[10]), qr_tend_d(temp_d[11]), nr_tend_d(temp_d[12]), precip_liq_flux_d(temp_d[13]);
+  view_1d qr_incld_d(temp_d[0]), rho_d(temp_d[1]), inv_rho_d(temp_d[2]), rhofacr_d(temp_d[3]),
+      cld_frac_r_d(temp_d[4]), inv_dz_d(temp_d[5]), qr_d(temp_d[6]), nr_d(temp_d[7]),
+      nr_incld_d(temp_d[8]), mu_r_d(temp_d[9]), lamr_d(temp_d[10]), qr_tend_d(temp_d[11]),
+      nr_tend_d(temp_d[12]), precip_liq_flux_d(temp_d[13]);
 
   // Call core function from kernel
   auto tables        = P3F::p3_init();
@@ -789,10 +817,11 @@ void rain_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Rea
   Kokkos::parallel_reduce(
       policy,
       KOKKOS_LAMBDA(const MemberType &team, Real &precip_liq_surf_k) {
-        P3F::rain_sedimentation(rho_d, inv_rho_d, rhofacr_d, cld_frac_r_d, inv_dz_d, qr_incld_d, team,
-                                wsm.get_workspace(team), vn_table_vals, vm_table_vals, nk, ktop, kbot, kdir, dt, inv_dt,
-                                qr_d, nr_d, nr_incld_d, mu_r_d, lamr_d, precip_liq_flux_d, qr_tend_d, nr_tend_d,
-                                precip_liq_surf_k, P3F::P3Runtime());
+        P3F::rain_sedimentation(rho_d, inv_rho_d, rhofacr_d, cld_frac_r_d, inv_dz_d, qr_incld_d,
+                                team, wsm.get_workspace(team), vn_table_vals, vm_table_vals, nk,
+                                ktop, kbot, kdir, dt, inv_dt, qr_d, nr_d, nr_incld_d, mu_r_d,
+                                lamr_d, precip_liq_flux_d, qr_tend_d, nr_tend_d, precip_liq_surf_k,
+                                P3F::P3Runtime());
       },
       my_precip_liq_surf);
   *precip_liq_surf += my_precip_liq_surf;
@@ -801,12 +830,15 @@ void rain_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Rea
   std::vector<size_t> sizes_out(8, nk);
   sizes_out[7] = nk + 1;
 
-  std::vector<view_1d> inout_views = {qr_d, nr_d, nr_incld_d, mu_r_d, lamr_d, qr_tend_d, nr_tend_d, precip_liq_flux_d};
-  ekat::device_to_host({qr, nr, nr_incld, mu_r, lamr, qr_tend, nr_tend, precip_liq_flux}, sizes_out, inout_views);
+  std::vector<view_1d> inout_views = {qr_d,   nr_d,      nr_incld_d, mu_r_d,
+                                      lamr_d, qr_tend_d, nr_tend_d,  precip_liq_flux_d};
+  ekat::device_to_host({qr, nr, nr_incld, mu_r, lamr, qr_tend, nr_tend, precip_liq_flux}, sizes_out,
+                       inout_views);
 }
 
-void homogeneous_freezing_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *T_atm, Real *inv_exner, Real *qc,
-                               Real *nc, Real *qr, Real *nr, Real *qi, Real *ni, Real *qm, Real *bm, Real *th_atm) {
+void homogeneous_freezing_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *T_atm,
+                               Real *inv_exner, Real *qc, Real *nc, Real *qr, Real *nr, Real *qi,
+                               Real *ni, Real *qm, Real *bm, Real *th_atm) {
   using P3F = Functions<Real, DefaultDevice>;
 
   using Spack      = typename P3F::Spack;
@@ -832,17 +864,18 @@ void homogeneous_freezing_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, R
   ekat::host_to_device({T_atm, inv_exner, qc, nc, qr, nr, qi, ni, qm, bm, th_atm}, nk, temp_d);
 
   int current_index = 0;
-  view_1d t_d(temp_d[current_index++]), inv_exner_d(temp_d[current_index++]), qc_d(temp_d[current_index++]),
-      nc_d(temp_d[current_index++]), qr_d(temp_d[current_index++]), nr_d(temp_d[current_index++]),
-      qi_d(temp_d[current_index++]), ni_d(temp_d[current_index++]), qm_d(temp_d[current_index++]),
-      bm_d(temp_d[current_index++]), th_atm_d(temp_d[current_index++]);
+  view_1d t_d(temp_d[current_index++]), inv_exner_d(temp_d[current_index++]),
+      qc_d(temp_d[current_index++]), nc_d(temp_d[current_index++]), qr_d(temp_d[current_index++]),
+      nr_d(temp_d[current_index++]), qi_d(temp_d[current_index++]), ni_d(temp_d[current_index++]),
+      qm_d(temp_d[current_index++]), bm_d(temp_d[current_index++]),
+      th_atm_d(temp_d[current_index++]);
 
   // Call core function from kernel
   auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(1, nk_pack);
   Kokkos::parallel_for(
       policy, KOKKOS_LAMBDA(const MemberType &team) {
-        P3F::homogeneous_freezing(t_d, inv_exner_d, team, nk, ktop, kbot, kdir, qc_d, nc_d, qr_d, nr_d, qi_d, ni_d,
-                                  qm_d, bm_d, th_atm_d);
+        P3F::homogeneous_freezing(t_d, inv_exner_d, team, nk, ktop, kbot, kdir, qc_d, nc_d, qr_d,
+                                  nr_d, qi_d, ni_d, qm_d, bm_d, th_atm_d);
       });
 
   // Sync back to host
@@ -851,8 +884,8 @@ void homogeneous_freezing_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, R
   ekat::device_to_host({qc, nc, qr, nr, qi, ni, qm, bm, th_atm}, nk, inout_views);
 }
 
-void check_values_host(Real *qv, Real *temp, Int kstart, Int kend, Int timestepcount, bool force_abort, Int source_ind,
-                       Real *col_loc) {
+void check_values_host(Real *qv, Real *temp, Int kstart, Int kend, Int timestepcount,
+                       bool force_abort, Int source_ind, Real *col_loc) {
   using P3F        = Functions<Real, DefaultDevice>;
   using Spack      = typename P3F::Spack;
   using view_1d    = typename P3F::view_1d<Spack>;
@@ -861,7 +894,8 @@ void check_values_host(Real *qv, Real *temp, Int kstart, Int kend, Int timestepc
   using ExeSpace   = typename KT::ExeSpace;
   using MemberType = typename P3F::MemberType;
 
-  EKAT_REQUIRE_MSG(kend > kstart, "ktop must be larger than kstart, kstart, kend " << kend << kstart);
+  EKAT_REQUIRE_MSG(kend > kstart,
+                   "ktop must be larger than kstart, kstart, kend " << kend << kstart);
 
   kstart -= 1;
   kend -= 1;
@@ -877,18 +911,21 @@ void check_values_host(Real *qv, Real *temp, Int kstart, Int kend, Int timestepc
   auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(1, nk_pack);
   Kokkos::parallel_for(
       policy, KOKKOS_LAMBDA(const MemberType &team) {
-        P3F::check_values(qv_d, temp_d, kstart, kend, timestepcount, force_abort, source_ind, team, ucol_loc_d);
+        P3F::check_values(qv_d, temp_d, kstart, kend, timestepcount, force_abort, source_ind, team,
+                          ucol_loc_d);
       });
 }
 
-void p3_main_part1_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_predict_nc, bool do_prescribed_CCN,
-                        Real dt, Real *pres, Real *dpres, Real *dz, Real *nc_nuceat_tend, Real *nccn_prescribed,
-                        Real *inv_exner, Real *exner, Real *inv_cld_frac_l, Real *inv_cld_frac_i, Real *inv_cld_frac_r,
-                        Real *T_atm, Real *rho, Real *inv_rho, Real *qv_sat_l, Real *qv_sat_i, Real *qv_supersat_i,
-                        Real *rhofacr, Real *rhofaci, Real *acn, Real *qv, Real *th_atm, Real *qc, Real *nc, Real *qr,
-                        Real *nr, Real *qi, Real *ni, Real *qm, Real *bm, Real *qc_incld, Real *qr_incld,
-                        Real *qi_incld, Real *qm_incld, Real *nc_incld, Real *nr_incld, Real *ni_incld, Real *bm_incld,
-                        bool *is_nucleat_possible, bool *is_hydromet_present) {
+void p3_main_part1_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_predict_nc,
+                        bool do_prescribed_CCN, Real dt, Real *pres, Real *dpres, Real *dz,
+                        Real *nc_nuceat_tend, Real *nccn_prescribed, Real *inv_exner, Real *exner,
+                        Real *inv_cld_frac_l, Real *inv_cld_frac_i, Real *inv_cld_frac_r,
+                        Real *T_atm, Real *rho, Real *inv_rho, Real *qv_sat_l, Real *qv_sat_i,
+                        Real *qv_supersat_i, Real *rhofacr, Real *rhofaci, Real *acn, Real *qv,
+                        Real *th_atm, Real *qc, Real *nc, Real *qr, Real *nr, Real *qi, Real *ni,
+                        Real *qm, Real *bm, Real *qc_incld, Real *qr_incld, Real *qi_incld,
+                        Real *qm_incld, Real *nc_incld, Real *nr_incld, Real *ni_incld,
+                        Real *bm_incld, bool *is_nucleat_possible, bool *is_hydromet_present) {
   using P3F = Functions<Real, DefaultDevice>;
 
   using Spack      = typename P3F::Spack;
@@ -951,13 +988,15 @@ void p3_main_part1_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_
                         nccn_prescribed},
                        nk, temp_d);
 
-  view_1d pres_d(temp_d[0]), dpres_d(temp_d[1]), dz_d(temp_d[2]), nc_nuceat_tend_d(temp_d[3]), inv_exner_d(temp_d[4]),
-      exner_d(temp_d[5]), inv_cld_frac_l_d(temp_d[6]), inv_cld_frac_i_d(temp_d[7]), inv_cld_frac_r_d(temp_d[8]),
-      t_d(temp_d[9]), rho_d(temp_d[10]), inv_rho_d(temp_d[11]), qv_sat_l_d(temp_d[12]), qv_sat_i_d(temp_d[13]),
-      qv_supersat_i_d(temp_d[14]), rhofacr_d(temp_d[15]), rhofaci_d(temp_d[16]), acn_d(temp_d[17]), qv_d(temp_d[18]),
-      th_atm_d(temp_d[19]), qc_d(temp_d[20]), nc_d(temp_d[21]), qr_d(temp_d[22]), nr_d(temp_d[23]), qi_d(temp_d[24]),
-      ni_d(temp_d[25]), qm_d(temp_d[26]), bm_d(temp_d[27]), qc_incld_d(temp_d[28]), qr_incld_d(temp_d[29]),
-      qi_incld_d(temp_d[30]), qm_incld_d(temp_d[31]), nc_incld_d(temp_d[32]), nr_incld_d(temp_d[33]),
+  view_1d pres_d(temp_d[0]), dpres_d(temp_d[1]), dz_d(temp_d[2]), nc_nuceat_tend_d(temp_d[3]),
+      inv_exner_d(temp_d[4]), exner_d(temp_d[5]), inv_cld_frac_l_d(temp_d[6]),
+      inv_cld_frac_i_d(temp_d[7]), inv_cld_frac_r_d(temp_d[8]), t_d(temp_d[9]), rho_d(temp_d[10]),
+      inv_rho_d(temp_d[11]), qv_sat_l_d(temp_d[12]), qv_sat_i_d(temp_d[13]),
+      qv_supersat_i_d(temp_d[14]), rhofacr_d(temp_d[15]), rhofaci_d(temp_d[16]), acn_d(temp_d[17]),
+      qv_d(temp_d[18]), th_atm_d(temp_d[19]), qc_d(temp_d[20]), nc_d(temp_d[21]), qr_d(temp_d[22]),
+      nr_d(temp_d[23]), qi_d(temp_d[24]), ni_d(temp_d[25]), qm_d(temp_d[26]), bm_d(temp_d[27]),
+      qc_incld_d(temp_d[28]), qr_incld_d(temp_d[29]), qi_incld_d(temp_d[30]),
+      qm_incld_d(temp_d[31]), nc_incld_d(temp_d[32]), nr_incld_d(temp_d[33]),
       ni_incld_d(temp_d[34]), bm_incld_d(temp_d[35]), nccn_prescribed_d(temp_d[36]);
 
   // Call core function from kernel
@@ -965,20 +1004,22 @@ void p3_main_part1_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_
   auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(1, nk_pack);
   Kokkos::parallel_for(
       policy, KOKKOS_LAMBDA(const MemberType &team) {
-        P3F::p3_main_part1(team, nk, do_predict_nc, do_prescribed_CCN, dt, pres_d, dpres_d, dz_d, nc_nuceat_tend_d,
-                           nccn_prescribed_d, inv_exner_d, exner_d, inv_cld_frac_l_d, inv_cld_frac_i_d,
-                           inv_cld_frac_r_d, t_d, rho_d, inv_rho_d, qv_sat_l_d, qv_sat_i_d, qv_supersat_i_d, rhofacr_d,
-                           rhofaci_d, acn_d, qv_d, th_atm_d, qc_d, nc_d, qr_d, nr_d, qi_d, ni_d, qm_d, bm_d, qc_incld_d,
-                           qr_incld_d, qi_incld_d, qm_incld_d, nc_incld_d, nr_incld_d, ni_incld_d, bm_incld_d,
-                           bools_d(0), bools_d(1), P3F::P3Runtime());
+        P3F::p3_main_part1(team, nk, do_predict_nc, do_prescribed_CCN, dt, pres_d, dpres_d, dz_d,
+                           nc_nuceat_tend_d, nccn_prescribed_d, inv_exner_d, exner_d,
+                           inv_cld_frac_l_d, inv_cld_frac_i_d, inv_cld_frac_r_d, t_d, rho_d,
+                           inv_rho_d, qv_sat_l_d, qv_sat_i_d, qv_supersat_i_d, rhofacr_d, rhofaci_d,
+                           acn_d, qv_d, th_atm_d, qc_d, nc_d, qr_d, nr_d, qi_d, ni_d, qm_d, bm_d,
+                           qc_incld_d, qr_incld_d, qi_incld_d, qm_incld_d, nc_incld_d, nr_incld_d,
+                           ni_incld_d, bm_incld_d, bools_d(0), bools_d(1), P3F::P3Runtime());
       });
 
   // Sync back to host
-  std::vector<view_1d> inout_views = {t_d,        rho_d,      inv_rho_d,  qv_sat_l_d, qv_sat_i_d, qv_supersat_i_d,
-                                      rhofacr_d,  rhofaci_d,  acn_d,      qv_d,       th_atm_d,   qc_d,
-                                      nc_d,       qr_d,       nr_d,       qi_d,       ni_d,       qm_d,
-                                      bm_d,       qc_incld_d, qr_incld_d, qi_incld_d, qm_incld_d, nc_incld_d,
-                                      nr_incld_d, ni_incld_d, bm_incld_d};
+  std::vector<view_1d> inout_views = {
+      t_d,        rho_d,      inv_rho_d,  qv_sat_l_d, qv_sat_i_d, qv_supersat_i_d,
+      rhofacr_d,  rhofaci_d,  acn_d,      qv_d,       th_atm_d,   qc_d,
+      nc_d,       qr_d,       nr_d,       qi_d,       ni_d,       qm_d,
+      bm_d,       qc_incld_d, qr_incld_d, qi_incld_d, qm_incld_d, nc_incld_d,
+      nr_incld_d, ni_incld_d, bm_incld_d};
 
   ekat::device_to_host({T_atm,    rho,      inv_rho,  qv_sat_l, qv_sat_i, qv_supersat_i,
                         rhofacr,  rhofaci,  acn,      qv,       th_atm,   qc,
@@ -994,23 +1035,24 @@ void p3_main_part1_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_
   *is_hydromet_present = bools_h(1);
 }
 
-void p3_main_part2_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_predict_nc, bool do_prescribed_CCN,
-                        Real dt, Real inv_dt, const Real *hetfrz_immersion_nucleation_tend,
-                        const Real *hetfrz_contact_nucleation_tend, const Real *hetfrz_deposition_nucleation_tend,
-                        Real *pres, Real *dpres, Real *dz, Real *nc_nuceat_tend, Real *inv_exner, Real *exner,
-                        Real *inv_cld_frac_l, Real *inv_cld_frac_i, Real *inv_cld_frac_r, Real *ni_activated,
-                        Real *inv_qc_relvar, Real *cld_frac_i, Real *cld_frac_l, Real *cld_frac_r, Real *qv_prev,
-                        Real *t_prev, Real *T_atm, Real *rho, Real *inv_rho, Real *qv_sat_l, Real *qv_sat_i,
-                        Real *qv_supersat_i, Real *rhofacr, Real *rhofaci, Real *acn, Real *qv, Real *th_atm, Real *qc,
-                        Real *nc, Real *qr, Real *nr, Real *qi, Real *ni, Real *qm, Real *bm, Real *qc_incld,
-                        Real *qr_incld, Real *qi_incld, Real *qm_incld, Real *nc_incld, Real *nr_incld, Real *ni_incld,
-                        Real *bm_incld, Real *mu_c, Real *nu, Real *lamc, Real *cdist, Real *cdist1, Real *cdistr,
-                        Real *mu_r, Real *lamr, Real *logn0r, Real *qv2qi_depos_tend, Real *precip_total_tend,
-                        Real *nevapr, Real *qr_evap_tend, Real *vap_liq_exchange, Real *vap_ice_exchange,
-                        Real *liq_ice_exchange, Real *qr2qv_evap, Real *qi2qv_sublim, Real *qc2qr_accret,
-                        Real *qc2qr_autoconv, Real *qv2qi_vapdep, Real *qc2qi_berg, Real *qc2qr_ice_shed,
-                        Real *qc2qi_collect, Real *qr2qi_collect, Real *qc2qi_hetero_freeze, Real *qr2qi_immers_freeze,
-                        Real *qi2qr_melt, Real *pratot, Real *prctot, bool *is_hydromet_present) {
+void p3_main_part2_host(
+    Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_predict_nc, bool do_prescribed_CCN,
+    Real dt, Real inv_dt, const Real *hetfrz_immersion_nucleation_tend,
+    const Real *hetfrz_contact_nucleation_tend, const Real *hetfrz_deposition_nucleation_tend,
+    Real *pres, Real *dpres, Real *dz, Real *nc_nuceat_tend, Real *inv_exner, Real *exner,
+    Real *inv_cld_frac_l, Real *inv_cld_frac_i, Real *inv_cld_frac_r, Real *ni_activated,
+    Real *inv_qc_relvar, Real *cld_frac_i, Real *cld_frac_l, Real *cld_frac_r, Real *qv_prev,
+    Real *t_prev, Real *T_atm, Real *rho, Real *inv_rho, Real *qv_sat_l, Real *qv_sat_i,
+    Real *qv_supersat_i, Real *rhofacr, Real *rhofaci, Real *acn, Real *qv, Real *th_atm, Real *qc,
+    Real *nc, Real *qr, Real *nr, Real *qi, Real *ni, Real *qm, Real *bm, Real *qc_incld,
+    Real *qr_incld, Real *qi_incld, Real *qm_incld, Real *nc_incld, Real *nr_incld, Real *ni_incld,
+    Real *bm_incld, Real *mu_c, Real *nu, Real *lamc, Real *cdist, Real *cdist1, Real *cdistr,
+    Real *mu_r, Real *lamr, Real *logn0r, Real *qv2qi_depos_tend, Real *precip_total_tend,
+    Real *nevapr, Real *qr_evap_tend, Real *vap_liq_exchange, Real *vap_ice_exchange,
+    Real *liq_ice_exchange, Real *qr2qv_evap, Real *qi2qv_sublim, Real *qc2qr_accret,
+    Real *qc2qr_autoconv, Real *qv2qi_vapdep, Real *qc2qi_berg, Real *qc2qr_ice_shed,
+    Real *qc2qi_collect, Real *qr2qi_collect, Real *qc2qi_hetero_freeze, Real *qr2qi_immers_freeze,
+    Real *qi2qr_melt, Real *pratot, Real *prctot, bool *is_hydromet_present) {
   using P3F = Functions<Real, DefaultDevice>;
 
   using Spack      = typename P3F::Spack;
@@ -1038,9 +1080,10 @@ void p3_main_part2_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_
   hetfrz_immersion_nucleation_tend  = hetfrz_0.data();
   hetfrz_contact_nucleation_tend    = hetfrz_1.data();
   hetfrz_deposition_nucleation_tend = hetfrz_2.data();
-  std::vector<Real> qr2qv_evap_v(nk, 0), qi2qv_sublim_v(nk, 0), qc2qr_accret_v(nk, 0), qc2qr_autoconv_v(nk, 0),
-      qv2qi_vapdep_v(nk, 0), qc2qi_berg_v(nk, 0), qc2qr_ice_shed_v(nk, 0), qc2qi_collect_v(nk, 0),
-      qr2qi_collect_v(nk, 0), qc2qi_hetero_freeze_v(nk, 0), qr2qi_immers_freeze_v(nk, 0), qi2qr_melt_v(nk, 0);
+  std::vector<Real> qr2qv_evap_v(nk, 0), qi2qv_sublim_v(nk, 0), qc2qr_accret_v(nk, 0),
+      qc2qr_autoconv_v(nk, 0), qv2qi_vapdep_v(nk, 0), qc2qi_berg_v(nk, 0), qc2qr_ice_shed_v(nk, 0),
+      qc2qi_collect_v(nk, 0), qr2qi_collect_v(nk, 0), qc2qi_hetero_freeze_v(nk, 0),
+      qr2qi_immers_freeze_v(nk, 0), qi2qr_melt_v(nk, 0);
   qr2qv_evap          = qr2qv_evap_v.data();
   qi2qv_sublim        = qi2qv_sublim_v.data();
   qc2qr_accret        = qc2qr_accret_v.data();
@@ -1136,29 +1179,36 @@ void p3_main_part2_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_
   view_1d hetfrz_immersion_nucleation_tend_d(temp_d[current_index++]),
       hetfrz_contact_nucleation_tend_d(temp_d[current_index++]),
       hetfrz_deposition_nucleation_tend_d(temp_d[current_index++]), pres_d(temp_d[current_index++]),
-      dpres_d(temp_d[current_index++]), dz_d(temp_d[current_index++]), nc_nuceat_tend_d(temp_d[current_index++]),
-      inv_exner_d(temp_d[current_index++]), exner_d(temp_d[current_index++]), inv_cld_frac_l_d(temp_d[current_index++]),
+      dpres_d(temp_d[current_index++]), dz_d(temp_d[current_index++]),
+      nc_nuceat_tend_d(temp_d[current_index++]), inv_exner_d(temp_d[current_index++]),
+      exner_d(temp_d[current_index++]), inv_cld_frac_l_d(temp_d[current_index++]),
       inv_cld_frac_i_d(temp_d[current_index++]), inv_cld_frac_r_d(temp_d[current_index++]),
       ni_activated_d(temp_d[current_index++]), inv_qc_relvar_d(temp_d[current_index++]),
       cld_frac_i_d(temp_d[current_index++]), cld_frac_l_d(temp_d[current_index++]),
-      cld_frac_r_d(temp_d[current_index++]), t_d(temp_d[current_index++]), rho_d(temp_d[current_index++]),
-      inv_rho_d(temp_d[current_index++]), qv_sat_l_d(temp_d[current_index++]), qv_sat_i_d(temp_d[current_index++]),
-      qv_supersat_i_d(temp_d[current_index++]), rhofacr_d(temp_d[current_index++]), rhofaci_d(temp_d[current_index++]),
-      acn_d(temp_d[current_index++]), qv_d(temp_d[current_index++]), th_atm_d(temp_d[current_index++]),
+      cld_frac_r_d(temp_d[current_index++]), t_d(temp_d[current_index++]),
+      rho_d(temp_d[current_index++]), inv_rho_d(temp_d[current_index++]),
+      qv_sat_l_d(temp_d[current_index++]), qv_sat_i_d(temp_d[current_index++]),
+      qv_supersat_i_d(temp_d[current_index++]), rhofacr_d(temp_d[current_index++]),
+      rhofaci_d(temp_d[current_index++]), acn_d(temp_d[current_index++]),
+      qv_d(temp_d[current_index++]), th_atm_d(temp_d[current_index++]),
       qc_d(temp_d[current_index++]), nc_d(temp_d[current_index++]), qr_d(temp_d[current_index++]),
       nr_d(temp_d[current_index++]), qi_d(temp_d[current_index++]), ni_d(temp_d[current_index++]),
-      qm_d(temp_d[current_index++]), bm_d(temp_d[current_index++]), qc_incld_d(temp_d[current_index++]),
-      qr_incld_d(temp_d[current_index++]), qi_incld_d(temp_d[current_index++]), qm_incld_d(temp_d[current_index++]),
-      nc_incld_d(temp_d[current_index++]), nr_incld_d(temp_d[current_index++]), ni_incld_d(temp_d[current_index++]),
-      bm_incld_d(temp_d[current_index++]), mu_c_d(temp_d[current_index++]), nu_d(temp_d[current_index++]),
-      lamc_d(temp_d[current_index++]), cdist_d(temp_d[current_index++]), cdist1_d(temp_d[current_index++]),
-      cdistr_d(temp_d[current_index++]), mu_r_d(temp_d[current_index++]), lamr_d(temp_d[current_index++]),
+      qm_d(temp_d[current_index++]), bm_d(temp_d[current_index++]),
+      qc_incld_d(temp_d[current_index++]), qr_incld_d(temp_d[current_index++]),
+      qi_incld_d(temp_d[current_index++]), qm_incld_d(temp_d[current_index++]),
+      nc_incld_d(temp_d[current_index++]), nr_incld_d(temp_d[current_index++]),
+      ni_incld_d(temp_d[current_index++]), bm_incld_d(temp_d[current_index++]),
+      mu_c_d(temp_d[current_index++]), nu_d(temp_d[current_index++]),
+      lamc_d(temp_d[current_index++]), cdist_d(temp_d[current_index++]),
+      cdist1_d(temp_d[current_index++]), cdistr_d(temp_d[current_index++]),
+      mu_r_d(temp_d[current_index++]), lamr_d(temp_d[current_index++]),
       logn0r_d(temp_d[current_index++]), qv2qi_depos_tend_d(temp_d[current_index++]),
       precip_total_tend_d(temp_d[current_index++]), nevapr_d(temp_d[current_index++]),
       qr_evap_tend_d(temp_d[current_index++]), vap_liq_exchange_d(temp_d[current_index++]),
       vap_ice_exchange_d(temp_d[current_index++]), liq_ice_exchange_d(temp_d[current_index++]),
-      pratot_d(temp_d[current_index++]), prctot_d(temp_d[current_index++]), qv_prev_d(temp_d[current_index++]),
-      t_prev_d(temp_d[current_index++]), qr2qv_evap_d(temp_d[current_index++]), qi2qv_sublim_d(temp_d[current_index++]),
+      pratot_d(temp_d[current_index++]), prctot_d(temp_d[current_index++]),
+      qv_prev_d(temp_d[current_index++]), t_prev_d(temp_d[current_index++]),
+      qr2qv_evap_d(temp_d[current_index++]), qi2qv_sublim_d(temp_d[current_index++]),
       qc2qr_accret_d(temp_d[current_index++]), qc2qr_autoconv_d(temp_d[current_index++]),
       qv2qi_vapdep_d(temp_d[current_index++]), qc2qi_berg_d(temp_d[current_index++]),
       qc2qr_ice_shed_d(temp_d[current_index++]), qc2qi_collect_d(temp_d[current_index++]),
@@ -1177,17 +1227,20 @@ void p3_main_part2_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_
       policy, KOKKOS_LAMBDA(const MemberType &team) {
         P3F::p3_main_part2(
             team, nk_pack, max_total_ni, do_predict_nc, do_prescribed_CCN, dt, inv_dt,
-            hetfrz_immersion_nucleation_tend_d, hetfrz_contact_nucleation_tend_d, hetfrz_deposition_nucleation_tend_d,
-            dnu, ice_table_vals, collect_table_vals, revap_table_vals, pres_d, dpres_d, dz_d, nc_nuceat_tend_d,
-            inv_exner_d, exner_d, inv_cld_frac_l_d, inv_cld_frac_i_d, inv_cld_frac_r_d, ni_activated_d, inv_qc_relvar_d,
-            cld_frac_i_d, cld_frac_l_d, cld_frac_r_d, qv_prev_d, t_prev_d, t_d, rho_d, inv_rho_d, qv_sat_l_d,
-            qv_sat_i_d, qv_supersat_i_d, rhofacr_d, rhofaci_d, acn_d, qv_d, th_atm_d, qc_d, nc_d, qr_d, nr_d, qi_d,
-            ni_d, qm_d, bm_d, qc_incld_d, qr_incld_d, qi_incld_d, qm_incld_d, nc_incld_d, nr_incld_d, ni_incld_d,
-            bm_incld_d, mu_c_d, nu_d, lamc_d, cdist_d, cdist1_d, cdistr_d, mu_r_d, lamr_d, logn0r_d, qv2qi_depos_tend_d,
-            precip_total_tend_d, nevapr_d, qr_evap_tend_d, vap_liq_exchange_d, vap_ice_exchange_d, liq_ice_exchange_d,
-            qr2qv_evap_d, qi2qv_sublim_d, qc2qr_accret_d, qc2qr_autoconv_d, qv2qi_vapdep_d, qc2qi_berg_d,
-            qc2qr_ice_shed_d, qc2qi_collect_d, qr2qi_collect_d, qc2qi_hetero_freeze_d, qr2qi_immers_freeze_d,
-            qi2qr_melt_d, pratot_d, prctot_d, bools_d(0), nk, P3F::P3Runtime());
+            hetfrz_immersion_nucleation_tend_d, hetfrz_contact_nucleation_tend_d,
+            hetfrz_deposition_nucleation_tend_d, dnu, ice_table_vals, collect_table_vals,
+            revap_table_vals, pres_d, dpres_d, dz_d, nc_nuceat_tend_d, inv_exner_d, exner_d,
+            inv_cld_frac_l_d, inv_cld_frac_i_d, inv_cld_frac_r_d, ni_activated_d, inv_qc_relvar_d,
+            cld_frac_i_d, cld_frac_l_d, cld_frac_r_d, qv_prev_d, t_prev_d, t_d, rho_d, inv_rho_d,
+            qv_sat_l_d, qv_sat_i_d, qv_supersat_i_d, rhofacr_d, rhofaci_d, acn_d, qv_d, th_atm_d,
+            qc_d, nc_d, qr_d, nr_d, qi_d, ni_d, qm_d, bm_d, qc_incld_d, qr_incld_d, qi_incld_d,
+            qm_incld_d, nc_incld_d, nr_incld_d, ni_incld_d, bm_incld_d, mu_c_d, nu_d, lamc_d,
+            cdist_d, cdist1_d, cdistr_d, mu_r_d, lamr_d, logn0r_d, qv2qi_depos_tend_d,
+            precip_total_tend_d, nevapr_d, qr_evap_tend_d, vap_liq_exchange_d, vap_ice_exchange_d,
+            liq_ice_exchange_d, qr2qv_evap_d, qi2qv_sublim_d, qc2qr_accret_d, qc2qr_autoconv_d,
+            qv2qi_vapdep_d, qc2qi_berg_d, qc2qr_ice_shed_d, qc2qi_collect_d, qr2qi_collect_d,
+            qc2qi_hetero_freeze_d, qr2qi_immers_freeze_d, qi2qr_melt_d, pratot_d, prctot_d,
+            bools_d(0), nk, P3F::P3Runtime());
       });
 
   // Sync back to host. Skip intent in variables.
@@ -1314,12 +1367,14 @@ void p3_main_part2_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_
   *is_hydromet_present = bools_h(0);
 }
 
-void p3_main_part3_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, Real *inv_exner, Real *cld_frac_l,
-                        Real *cld_frac_r, Real *cld_frac_i, Real *rho, Real *inv_rho, Real *rhofaci, Real *qv,
-                        Real *th_atm, Real *qc, Real *nc, Real *qr, Real *nr, Real *qi, Real *ni, Real *qm, Real *bm,
-                        Real *mu_c, Real *nu, Real *lamc, Real *mu_r, Real *lamr, Real *vap_liq_exchange, Real *ze_rain,
-                        Real *ze_ice, Real *diag_vm_qi, Real *diag_eff_radius_qi, Real *diag_diam_qi, Real *rho_qi,
-                        Real *diag_equiv_reflectivity, Real *diag_eff_radius_qc, Real *diag_eff_radius_qr) {
+void p3_main_part3_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, Real *inv_exner,
+                        Real *cld_frac_l, Real *cld_frac_r, Real *cld_frac_i, Real *rho,
+                        Real *inv_rho, Real *rhofaci, Real *qv, Real *th_atm, Real *qc, Real *nc,
+                        Real *qr, Real *nr, Real *qi, Real *ni, Real *qm, Real *bm, Real *mu_c,
+                        Real *nu, Real *lamc, Real *mu_r, Real *lamr, Real *vap_liq_exchange,
+                        Real *ze_rain, Real *ze_ice, Real *diag_vm_qi, Real *diag_eff_radius_qi,
+                        Real *diag_diam_qi, Real *rho_qi, Real *diag_equiv_reflectivity,
+                        Real *diag_eff_radius_qc, Real *diag_eff_radius_qr) {
   using P3F = Functions<Real, DefaultDevice>;
 
   using Spack      = typename P3F::Spack;
@@ -1379,16 +1434,19 @@ void p3_main_part3_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, Real *in
 
   int current_index = 0;
   view_1d inv_exner_d(temp_d[current_index++]), cld_frac_l_d(temp_d[current_index++]),
-      cld_frac_r_d(temp_d[current_index++]), cld_frac_i_d(temp_d[current_index++]), rho_d(temp_d[current_index++]),
-      inv_rho_d(temp_d[current_index++]), rhofaci_d(temp_d[current_index++]), qv_d(temp_d[current_index++]),
-      th_atm_d(temp_d[current_index++]), qc_d(temp_d[current_index++]), nc_d(temp_d[current_index++]),
-      qr_d(temp_d[current_index++]), nr_d(temp_d[current_index++]), qi_d(temp_d[current_index++]),
-      ni_d(temp_d[current_index++]), qm_d(temp_d[current_index++]), bm_d(temp_d[current_index++]),
-      mu_c_d(temp_d[current_index++]), nu_d(temp_d[current_index++]), lamc_d(temp_d[current_index++]),
-      mu_r_d(temp_d[current_index++]), lamr_d(temp_d[current_index++]), vap_liq_exchange_d(temp_d[current_index++]),
-      ze_rain_d(temp_d[current_index++]), ze_ice_d(temp_d[current_index++]), diag_vm_qi_d(temp_d[current_index++]),
-      diag_eff_radius_qi_d(temp_d[current_index++]), diag_diam_qi_d(temp_d[current_index++]),
-      rho_qi_d(temp_d[current_index++]), diag_equiv_reflectivity_d(temp_d[current_index++]),
+      cld_frac_r_d(temp_d[current_index++]), cld_frac_i_d(temp_d[current_index++]),
+      rho_d(temp_d[current_index++]), inv_rho_d(temp_d[current_index++]),
+      rhofaci_d(temp_d[current_index++]), qv_d(temp_d[current_index++]),
+      th_atm_d(temp_d[current_index++]), qc_d(temp_d[current_index++]),
+      nc_d(temp_d[current_index++]), qr_d(temp_d[current_index++]), nr_d(temp_d[current_index++]),
+      qi_d(temp_d[current_index++]), ni_d(temp_d[current_index++]), qm_d(temp_d[current_index++]),
+      bm_d(temp_d[current_index++]), mu_c_d(temp_d[current_index++]), nu_d(temp_d[current_index++]),
+      lamc_d(temp_d[current_index++]), mu_r_d(temp_d[current_index++]),
+      lamr_d(temp_d[current_index++]), vap_liq_exchange_d(temp_d[current_index++]),
+      ze_rain_d(temp_d[current_index++]), ze_ice_d(temp_d[current_index++]),
+      diag_vm_qi_d(temp_d[current_index++]), diag_eff_radius_qi_d(temp_d[current_index++]),
+      diag_diam_qi_d(temp_d[current_index++]), rho_qi_d(temp_d[current_index++]),
+      diag_equiv_reflectivity_d(temp_d[current_index++]),
       diag_eff_radius_qc_d(temp_d[current_index++]), diag_eff_radius_qr_d(temp_d[current_index++]);
 
   // Call core function from kernel
@@ -1398,11 +1456,13 @@ void p3_main_part3_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, Real *in
   auto policy               = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(1, nk_pack);
   Kokkos::parallel_for(
       policy, KOKKOS_LAMBDA(const MemberType &team) {
-        P3F::p3_main_part3(team, nk_pack, max_total_ni, dnu, ice_table_vals, inv_exner_d, cld_frac_l_d, cld_frac_r_d,
-                           cld_frac_i_d, rho_d, inv_rho_d, rhofaci_d, qv_d, th_atm_d, qc_d, nc_d, qr_d, nr_d, qi_d,
-                           ni_d, qm_d, bm_d, mu_c_d, nu_d, lamc_d, mu_r_d, lamr_d, vap_liq_exchange_d, ze_rain_d,
-                           ze_ice_d, diag_vm_qi_d, diag_eff_radius_qi_d, diag_diam_qi_d, rho_qi_d,
-                           diag_equiv_reflectivity_d, diag_eff_radius_qc_d, diag_eff_radius_qr_d, P3F::P3Runtime());
+        P3F::p3_main_part3(team, nk_pack, max_total_ni, dnu, ice_table_vals, inv_exner_d,
+                           cld_frac_l_d, cld_frac_r_d, cld_frac_i_d, rho_d, inv_rho_d, rhofaci_d,
+                           qv_d, th_atm_d, qc_d, nc_d, qr_d, nr_d, qi_d, ni_d, qm_d, bm_d, mu_c_d,
+                           nu_d, lamc_d, mu_r_d, lamr_d, vap_liq_exchange_d, ze_rain_d, ze_ice_d,
+                           diag_vm_qi_d, diag_eff_radius_qi_d, diag_diam_qi_d, rho_qi_d,
+                           diag_equiv_reflectivity_d, diag_eff_radius_qc_d, diag_eff_radius_qr_d,
+                           P3F::P3Runtime());
       });
 
   // Sync back to host
@@ -1466,14 +1526,16 @@ void p3_main_part3_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, Real *in
                        nk, inout_views);
 }
 
-Int p3_main_host(Real *qc, Real *nc, Real *qr, Real *nr, Real *th_atm, Real *qv, Real dt, Real *qi, Real *qm, Real *ni,
-                 Real *bm, Real *pres, Real *dz, Real *nc_nuceat_tend, Real *nccn_prescribed, Real *ni_activated,
-                 Real *inv_qc_relvar, Int it, Real *precip_liq_surf, Real *precip_ice_surf, Int its, Int ite, Int kts,
-                 Int kte, Real *diag_eff_radius_qc, Real *diag_eff_radius_qi, Real *diag_eff_radius_qr, Real *rho_qi,
-                 bool do_predict_nc, bool do_prescribed_CCN, bool use_hetfrz_classnuc, Real *dpres, Real *inv_exner,
-                 Real *qv2qi_depos_tend, Real *precip_liq_flux, Real *precip_ice_flux, Real *cld_frac_r,
-                 Real *cld_frac_l, Real *cld_frac_i, Real *liq_ice_exchange, Real *vap_liq_exchange,
-                 Real *vap_ice_exchange, Real *qv_prev, Real *t_prev) {
+Int p3_main_host(Real *qc, Real *nc, Real *qr, Real *nr, Real *th_atm, Real *qv, Real dt, Real *qi,
+                 Real *qm, Real *ni, Real *bm, Real *pres, Real *dz, Real *nc_nuceat_tend,
+                 Real *nccn_prescribed, Real *ni_activated, Real *inv_qc_relvar, Int it,
+                 Real *precip_liq_surf, Real *precip_ice_surf, Int its, Int ite, Int kts, Int kte,
+                 Real *diag_eff_radius_qc, Real *diag_eff_radius_qi, Real *diag_eff_radius_qr,
+                 Real *rho_qi, bool do_predict_nc, bool do_prescribed_CCN, bool use_hetfrz_classnuc,
+                 Real *dpres, Real *inv_exner, Real *qv2qi_depos_tend, Real *precip_liq_flux,
+                 Real *precip_ice_flux, Real *cld_frac_r, Real *cld_frac_l, Real *cld_frac_i,
+                 Real *liq_ice_exchange, Real *vap_liq_exchange, Real *vap_ice_exchange,
+                 Real *qv_prev, Real *t_prev) {
   using P3F = Functions<Real, DefaultDevice>;
 
   using Spack    = typename P3F::Spack;
@@ -1553,21 +1615,23 @@ Int p3_main_host(Real *qc, Real *nc, Real *qr, Real *nr, Real *th_atm, Real *qv,
 
   int counter = 0;
   view_2d pres_d(temp_d[counter++]), // 0
-      dz_d(temp_d[counter++]), nc_nuceat_tend_d(temp_d[counter++]), nccn_prescribed_d(temp_d[counter++]),
-      ni_activated_d(temp_d[counter++]),
+      dz_d(temp_d[counter++]), nc_nuceat_tend_d(temp_d[counter++]),
+      nccn_prescribed_d(temp_d[counter++]), ni_activated_d(temp_d[counter++]),
       dpres_d(temp_d[counter++]), // 5
-      inv_exner_d(temp_d[counter++]), cld_frac_i_d(temp_d[counter++]), cld_frac_l_d(temp_d[counter++]),
-      cld_frac_r_d(temp_d[counter++]),
+      inv_exner_d(temp_d[counter++]), cld_frac_i_d(temp_d[counter++]),
+      cld_frac_l_d(temp_d[counter++]), cld_frac_r_d(temp_d[counter++]),
       inv_qc_relvar_d(temp_d[counter++]), // 10
-      qc_d(temp_d[counter++]), nc_d(temp_d[counter++]), qr_d(temp_d[counter++]), nr_d(temp_d[counter++]),
+      qc_d(temp_d[counter++]), nc_d(temp_d[counter++]), qr_d(temp_d[counter++]),
+      nr_d(temp_d[counter++]),
       qi_d(temp_d[counter++]), // 15
-      qm_d(temp_d[counter++]), ni_d(temp_d[counter++]), bm_d(temp_d[counter++]), qv_d(temp_d[counter++]),
+      qm_d(temp_d[counter++]), ni_d(temp_d[counter++]), bm_d(temp_d[counter++]),
+      qv_d(temp_d[counter++]),
       th_atm_d(temp_d[counter++]), // 20
-      qv_prev_d(temp_d[counter++]), t_prev_d(temp_d[counter++]), diag_eff_radius_qc_d(temp_d[counter++]),
-      diag_eff_radius_qi_d(temp_d[counter++]),
+      qv_prev_d(temp_d[counter++]), t_prev_d(temp_d[counter++]),
+      diag_eff_radius_qc_d(temp_d[counter++]), diag_eff_radius_qi_d(temp_d[counter++]),
       diag_eff_radius_qr_d(temp_d[counter++]), // 25
-      rho_qi_d(temp_d[counter++]), qv2qi_depos_tend_d(temp_d[counter++]), liq_ice_exchange_d(temp_d[counter++]),
-      vap_liq_exchange_d(temp_d[counter++]),
+      rho_qi_d(temp_d[counter++]), qv2qi_depos_tend_d(temp_d[counter++]),
+      liq_ice_exchange_d(temp_d[counter++]), vap_liq_exchange_d(temp_d[counter++]),
       vap_ice_exchange_d(temp_d[counter++]), // 30
       precip_liq_flux_d(temp_d[counter++]),
       precip_ice_flux_d(temp_d[counter++]), // 35
@@ -1632,7 +1696,8 @@ Int p3_main_host(Real *qc, Real *nc, Real *qr, Real *nr, Real *th_atm, Real *qv,
   view_2d qr_sedim_d(view[16]);
   view_2d qi_sedim_d(view[17]);
 
-  // Special cases: precip_liq_surf=1d<scalar>(ni), precip_ice_surf=1d<scalar>(ni), col_location=2d<scalar>(nj, 3)
+  // Special cases: precip_liq_surf=1d<scalar>(ni), precip_ice_surf=1d<scalar>(ni),
+  // col_location=2d<scalar>(nj, 3)
   sview_1d precip_liq_surf_d("precip_liq_surf_d", nj), precip_ice_surf_d("precip_ice_surf_d", nj);
   sview_2d col_location_d("col_location_d", nj, 3);
 
@@ -1675,7 +1740,8 @@ Int p3_main_host(Real *qc, Real *nc, Real *qr, Real *nr, Real *th_atm, Real *qv,
       qv2qi_depos_tend_d,   precip_liq_surf_d,    precip_ice_surf_d, diag_eff_radius_qc_d,
       diag_eff_radius_qi_d, diag_eff_radius_qr_d, rho_qi_d,          precip_liq_flux_d,
       precip_ice_flux_d,    precip_total_tend_d,  nevapr_d,          diag_equiv_reflectivity_d};
-  P3F::P3Infrastructure infrastructure{dt, it, its, ite, kts, kte, do_predict_nc, do_prescribed_CCN, col_location_d};
+  P3F::P3Infrastructure infrastructure{
+      dt, it, its, ite, kts, kte, do_predict_nc, do_prescribed_CCN, col_location_d};
   P3F::P3HistoryOnly history_only{
       liq_ice_exchange_d,
       vap_liq_exchange_d,
@@ -1700,23 +1766,28 @@ Int p3_main_host(Real *qc, Real *nc, Real *qr, Real *nr, Real *th_atm, Real *qv,
   const Int nk_pack = ekat::npack<Spack>(nk);
 #ifdef SCREAM_P3_SMALL_KERNELS
   view_2d mu_r("mu_r", nj, nk_pack), T_atm("T_atm", nj, nk_pack), lamr("lamr", nj, nk_pack),
-      logn0r("logn0r", nj, nk_pack), nu("nu", nj, nk_pack), cdist("cdist", nj, nk_pack), cdist1("cdist1", nj, nk_pack),
-      cdistr("cdistr", nj, nk_pack), inv_cld_frac_i("inv_cld_frac_i", nj, nk_pack),
-      inv_cld_frac_l("inv_cld_frac_l", nj, nk_pack), inv_cld_frac_r("inv_cld_frac_r", nj, nk_pack),
-      qc_incld("qc_incld", nj, nk_pack), qr_incld("qr_incld", nj, nk_pack), qi_incld("qi_incld", nj, nk_pack),
-      qm_incld("qm_incld", nj, nk_pack), nc_incld("nc_incld", nj, nk_pack), nr_incld("nr_incld", nj, nk_pack),
-      ni_incld("ni_incld", nj, nk_pack), bm_incld("bm_incld", nj, nk_pack), inv_dz("inv_dz", nj, nk_pack),
-      inv_rho("inv_rho", nj, nk_pack), ze_ice("ze_ice", nj, nk_pack), ze_rain("ze_rain", nj, nk_pack),
-      prec("prec", nj, nk_pack), rho("rho", nj, nk_pack), rhofacr("rhofacr", nj, nk_pack),
-      rhofaci("rhofaci", nj, nk_pack), acn("acn", nj, nk_pack), qv_sat_l("qv_sat", nj, nk_pack),
-      qv_sat_i("qv_sat_i", nj, nk_pack), sup("sup", nj, nk_pack), qv_supersat_i("qv_supersat", nj, nk_pack),
-      tmparr2("tmparr2", nj, nk_pack), exner("exner", nj, nk_pack), diag_vm_qi("diag_vm_qi", nj, nk_pack),
-      diag_diam_qi("diag_diam_qi", nj, nk_pack), pratot("pratot", nj, nk_pack), prctot("prctot", nj, nk_pack),
-      qtend_ignore("qtend_ignore", nj, nk_pack), ntend_ignore("ntend_ignore", nj, nk_pack), mu_c("mu_c", nj, nk_pack),
-      lamc("lamc", nj, nk_pack), qr_evap_tend("qr_evap_tend", nj, nk_pack), v_qc("v_qc", nj, nk_pack),
-      v_nc("v_nc", nj, nk_pack), flux_qx("flux_qx", nj, nk_pack), flux_nx("flux_nx", nj, nk_pack),
-      v_qit("v_qit", nj, nk_pack), v_nit("v_nit", nj, nk_pack), flux_nit("flux_nit", nj, nk_pack),
-      flux_bir("flux_bir", nj, nk_pack), flux_qir("flux_qir", nj, nk_pack), flux_qit("flux_qit", nj, nk_pack),
+      logn0r("logn0r", nj, nk_pack), nu("nu", nj, nk_pack), cdist("cdist", nj, nk_pack),
+      cdist1("cdist1", nj, nk_pack), cdistr("cdistr", nj, nk_pack),
+      inv_cld_frac_i("inv_cld_frac_i", nj, nk_pack), inv_cld_frac_l("inv_cld_frac_l", nj, nk_pack),
+      inv_cld_frac_r("inv_cld_frac_r", nj, nk_pack), qc_incld("qc_incld", nj, nk_pack),
+      qr_incld("qr_incld", nj, nk_pack), qi_incld("qi_incld", nj, nk_pack),
+      qm_incld("qm_incld", nj, nk_pack), nc_incld("nc_incld", nj, nk_pack),
+      nr_incld("nr_incld", nj, nk_pack), ni_incld("ni_incld", nj, nk_pack),
+      bm_incld("bm_incld", nj, nk_pack), inv_dz("inv_dz", nj, nk_pack),
+      inv_rho("inv_rho", nj, nk_pack), ze_ice("ze_ice", nj, nk_pack),
+      ze_rain("ze_rain", nj, nk_pack), prec("prec", nj, nk_pack), rho("rho", nj, nk_pack),
+      rhofacr("rhofacr", nj, nk_pack), rhofaci("rhofaci", nj, nk_pack), acn("acn", nj, nk_pack),
+      qv_sat_l("qv_sat", nj, nk_pack), qv_sat_i("qv_sat_i", nj, nk_pack), sup("sup", nj, nk_pack),
+      qv_supersat_i("qv_supersat", nj, nk_pack), tmparr2("tmparr2", nj, nk_pack),
+      exner("exner", nj, nk_pack), diag_vm_qi("diag_vm_qi", nj, nk_pack),
+      diag_diam_qi("diag_diam_qi", nj, nk_pack), pratot("pratot", nj, nk_pack),
+      prctot("prctot", nj, nk_pack), qtend_ignore("qtend_ignore", nj, nk_pack),
+      ntend_ignore("ntend_ignore", nj, nk_pack), mu_c("mu_c", nj, nk_pack),
+      lamc("lamc", nj, nk_pack), qr_evap_tend("qr_evap_tend", nj, nk_pack),
+      v_qc("v_qc", nj, nk_pack), v_nc("v_nc", nj, nk_pack), flux_qx("flux_qx", nj, nk_pack),
+      flux_nx("flux_nx", nj, nk_pack), v_qit("v_qit", nj, nk_pack), v_nit("v_nit", nj, nk_pack),
+      flux_nit("flux_nit", nj, nk_pack), flux_bir("flux_bir", nj, nk_pack),
+      flux_qir("flux_qir", nj, nk_pack), flux_qit("flux_qit", nj, nk_pack),
       v_qr("v_qr", nj, nk_pack), v_nr("v_nr", nj, nk_pack);
 
   P3F::P3Temporaries temporaries{mu_r,
@@ -1784,12 +1855,12 @@ Int p3_main_host(Real *qc, Real *nc, Real *qr, Real *nr, Real *th_atm, Real *qv,
   const auto policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(nj, nk_pack);
   ekat::WorkspaceManager<Spack, KT::Device> workspace_mgr(nk_pack, 52, policy);
 
-  auto elapsed_microsec =
-      P3F::p3_main(runtime_options, prog_state, diag_inputs, diag_outputs, infrastructure, history_only, lookup_tables,
+  auto elapsed_microsec = P3F::p3_main(runtime_options, prog_state, diag_inputs, diag_outputs,
+                                       infrastructure, history_only, lookup_tables,
 #ifdef SCREAM_P3_SMALL_KERNELS
-                   temporaries,
+                                       temporaries,
 #endif
-                   workspace_mgr, nj, nk);
+                                       workspace_mgr, nj, nk);
 
   Kokkos::parallel_for(
       nj, KOKKOS_LAMBDA(const Int &i) {
diff --git i/components/eamxx/src/physics/p3/tests/infra/p3_test_data.hpp w/components/eamxx/src/physics/p3/tests/infra/p3_test_data.hpp
index 96e76f6497..d10c47b282 100644
--- i/components/eamxx/src/physics/p3/tests/infra/p3_test_data.hpp
+++ w/components/eamxx/src/physics/p3/tests/infra/p3_test_data.hpp
@@ -79,10 +79,11 @@ struct BackToCellAverageData {
 
   // in/out
   Real qc2qr_accret_tend, qr2qv_evap_tend, qc2qr_autoconv_tend, nc_accret_tend, nc_selfcollect_tend,
-      nc2nr_autoconv_tend, nr_selfcollect_tend, nr_evap_tend, ncautr, qcnuc, nc_nuceat_tend, qi2qv_sublim_tend,
-      nr_ice_shed_tend, qc2qi_hetero_freeze_tend, qr2qi_collect_tend, qc2qr_ice_shed_tend, qi2qr_melt_tend,
-      qc2qi_collect_tend, qr2qi_immers_freeze_tend, ni2nr_melt_tend, nc_collect_tend, ncshdc, nc2ni_immers_freeze_tend,
-      nr_collect_tend, ni_selfcollect_tend, qv2qi_vapdep_tend, nr2ni_immers_freeze_tend, ni_sublim_tend,
+      nc2nr_autoconv_tend, nr_selfcollect_tend, nr_evap_tend, ncautr, qcnuc, nc_nuceat_tend,
+      qi2qv_sublim_tend, nr_ice_shed_tend, qc2qi_hetero_freeze_tend, qr2qi_collect_tend,
+      qc2qr_ice_shed_tend, qi2qr_melt_tend, qc2qi_collect_tend, qr2qi_immers_freeze_tend,
+      ni2nr_melt_tend, nc_collect_tend, ncshdc, nc2ni_immers_freeze_tend, nr_collect_tend,
+      ni_selfcollect_tend, qv2qi_vapdep_tend, nr2ni_immers_freeze_tend, ni_sublim_tend,
       qv2qi_nucleat_tend, ni_nucleat_tend, qc2qi_berg_tend;
   Real ncheti_cnt = 0, qcheti_cnt = 0, nicnt = 0, qicnt = 0, ninuc_cnt = 0, qinuc_cnt = 0;
   bool use_hetfrz_classnuc = false, context = true;
@@ -90,13 +91,15 @@ struct BackToCellAverageData {
   // This populates all fields with test data within [0,1].
   void randomize(std::mt19937_64 &engine);
 
-  PTD_RW_SCALARS_ONLY(31, qc2qr_accret_tend, qr2qv_evap_tend, qc2qr_autoconv_tend, nc_accret_tend, nc_selfcollect_tend,
-                      nc2nr_autoconv_tend, nr_selfcollect_tend, nr_evap_tend, ncautr, qcnuc, nc_nuceat_tend,
-                      qi2qv_sublim_tend, nr_ice_shed_tend, qc2qi_hetero_freeze_tend, qr2qi_collect_tend,
-                      qc2qr_ice_shed_tend, qi2qr_melt_tend, qc2qi_collect_tend, qr2qi_immers_freeze_tend,
-                      ni2nr_melt_tend, nc_collect_tend, ncshdc, nc2ni_immers_freeze_tend, nr_collect_tend,
-                      ni_selfcollect_tend, qv2qi_vapdep_tend, nr2ni_immers_freeze_tend, ni_sublim_tend,
-                      qv2qi_nucleat_tend, ni_nucleat_tend, qc2qi_berg_tend);
+  PTD_RW_SCALARS_ONLY(31, qc2qr_accret_tend, qr2qv_evap_tend, qc2qr_autoconv_tend, nc_accret_tend,
+                      nc_selfcollect_tend, nc2nr_autoconv_tend, nr_selfcollect_tend, nr_evap_tend,
+                      ncautr, qcnuc, nc_nuceat_tend, qi2qv_sublim_tend, nr_ice_shed_tend,
+                      qc2qi_hetero_freeze_tend, qr2qi_collect_tend, qc2qr_ice_shed_tend,
+                      qi2qr_melt_tend, qc2qi_collect_tend, qr2qi_immers_freeze_tend,
+                      ni2nr_melt_tend, nc_collect_tend, ncshdc, nc2ni_immers_freeze_tend,
+                      nr_collect_tend, ni_selfcollect_tend, qv2qi_vapdep_tend,
+                      nr2ni_immers_freeze_tend, ni_sublim_tend, qv2qi_nucleat_tend, ni_nucleat_tend,
+                      qc2qi_berg_tend);
 };
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -106,13 +109,14 @@ struct CloudWaterConservationData {
   Real qc, dt;
 
   // output
-  Real qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend, qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend,
-      qc2qi_berg_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend;
+  Real qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend, qc2qi_hetero_freeze_tend,
+      qc2qr_ice_shed_tend, qc2qi_berg_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend;
   Real qcheti_cnt = 0, qicnt = 0;
   bool use_hetfrz_classnuc = false, context = true;
 
-  PTD_RW_SCALARS_ONLY(8, qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend, qc2qi_hetero_freeze_tend,
-                      qc2qr_ice_shed_tend, qc2qi_berg_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend);
+  PTD_RW_SCALARS_ONLY(8, qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend,
+                      qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend, qc2qi_berg_tend,
+                      qi2qv_sublim_tend, qv2qi_vapdep_tend);
 };
 
 struct RainWaterConservationData {
@@ -127,8 +131,8 @@ struct RainWaterConservationData {
 
 struct IceWaterConservationData {
   // inputs
-  Real qi, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend, qr2qi_collect_tend, qc2qi_collect_tend,
-      qr2qi_immers_freeze_tend, qc2qi_hetero_freeze_tend, dt;
+  Real qi, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend, qr2qi_collect_tend,
+      qc2qi_collect_tend, qr2qi_immers_freeze_tend, qc2qi_hetero_freeze_tend, dt;
   // output
   Real qi2qv_sublim_tend, qi2qr_melt_tend;
 
@@ -238,8 +242,8 @@ struct ImposeMaxTotalNiData {
 
 struct IceMeltingData {
   // inputs
-  Real rho, T_atm, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, latent_heat_vapor,
-      latent_heat_fusion, dv, sc, mu, kap, qv, qi_incld, ni_incld;
+  Real rho, T_atm, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt,
+      latent_heat_vapor, latent_heat_fusion, dv, sc, mu, kap, qv, qi_incld, ni_incld;
 
   // output
   Real qi2qr_melt_tend, ni2nr_melt_tend;
@@ -294,13 +298,15 @@ struct CalcUpwindData : public PhysicsTestData {
   // Outputs
   Real *fluxes; // num_arrays x nk
 
-  CalcUpwindData(Int kts_, Int kte_, Int kdir_, Int kbot_, Int k_qxtop_, Int num_arrays_, Real dt_sub_);
+  CalcUpwindData(Int kts_, Int kte_, Int kdir_, Int kbot_, Int k_qxtop_, Int num_arrays_,
+                 Real dt_sub_);
 
   PTD_STD_DEF(CalcUpwindData, 7, kts, kte, kdir, kbot, k_qxtop, num_arrays, dt_sub);
 
   Int nk() const { return (kte - kts) + 1; }
 
-  void convert_to_ptr_arr(std::vector<Real *> &mem_space, Real **&fluxes_, Real **&vs_, Real **&qnx_);
+  void convert_to_ptr_arr(std::vector<Real *> &mem_space, Real **&fluxes_, Real **&vs_,
+                          Real **&qnx_);
 };
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -313,13 +319,15 @@ struct GenSedData : public CalcUpwindData {
   Int k_qxbot;
   Real dt_left, prt_accum;
 
-  GenSedData(Int kts_, Int kte_, Int kdir_, Int k_qxtop_, Int k_qxbot_, Int kbot_, Real Co_max_, Real dt_left_,
-             Real prt_accum_, Int num_arrays_);
+  GenSedData(Int kts_, Int kte_, Int kdir_, Int k_qxtop_, Int k_qxbot_, Int kbot_, Real Co_max_,
+             Real dt_left_, Real prt_accum_, Int num_arrays_);
 
   PTD_DATA_COPY_CTOR(GenSedData, 10);
-  PTD_ASSIGN_OP(GenSedData, 11, kts, kte, kdir, kbot, k_qxtop, num_arrays, dt_sub, Co_max, k_qxbot, dt_left, prt_accum);
+  PTD_ASSIGN_OP(GenSedData, 11, kts, kte, kdir, kbot, k_qxtop, num_arrays, dt_sub, Co_max, k_qxbot,
+                dt_left, prt_accum);
   PTD_RW();
-  PTD_RW_SCALARS(11, kts, kte, kdir, kbot, k_qxtop, num_arrays, dt_sub, Co_max, k_qxbot, dt_left, prt_accum);
+  PTD_RW_SCALARS(11, kts, kte, kdir, kbot, k_qxtop, num_arrays, dt_sub, Co_max, k_qxbot, dt_left,
+                 prt_accum);
 };
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -337,10 +345,11 @@ struct CloudSedData : public PhysicsTestData {
   Real *qc, *nc, *nc_incld, *mu_c, *lamc, *qc_tend, *nc_tend;
   Real precip_liq_surf;
 
-  CloudSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_, Real inv_dt_, bool do_predict_nc_,
-               Real precip_liq_surf_);
+  CloudSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_, Real inv_dt_,
+               bool do_predict_nc_, Real precip_liq_surf_);
 
-  PTD_STD_DEF(CloudSedData, 9, kts, kte, ktop, kbot, kdir, dt, inv_dt, do_predict_nc, precip_liq_surf);
+  PTD_STD_DEF(CloudSedData, 9, kts, kte, ktop, kbot, kdir, dt, inv_dt, do_predict_nc,
+              precip_liq_surf);
 
   Int nk() const { return (kte - kts) + 1; }
 };
@@ -359,7 +368,8 @@ struct IceSedData : public PhysicsTestData {
   Real *qi, *qi_incld, *ni, *ni_incld, *qm, *qm_incld, *bm, *bm_incld, *qi_tend, *ni_tend;
   Real precip_ice_surf;
 
-  IceSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_, Real inv_dt_, Real precip_ice_surf_);
+  IceSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_, Real inv_dt_,
+             Real precip_ice_surf_);
 
   PTD_STD_DEF(IceSedData, 8, kts, kte, ktop, kbot, kdir, dt, inv_dt, precip_ice_surf);
 
@@ -381,7 +391,8 @@ struct RainSedData : public PhysicsTestData {
   Real *precip_liq_flux; // has special size (nk+1)
   Real precip_liq_surf;
 
-  RainSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_, Real inv_dt_, Real precip_liq_surf_);
+  RainSedData(Int kts_, Int kte_, Int ktop_, Int kbot_, Int kdir_, Real dt_, Real inv_dt_,
+              Real precip_liq_surf_);
 
   PTD_STD_DEF(RainSedData, 8, kts, kte, ktop, kbot, kdir, dt, inv_dt, precip_liq_surf);
 
@@ -453,10 +464,12 @@ struct GetTimeSpacePhysVarsData {
 
 struct P3UpdatePrognosticIceData {
   // Inputs
-  Real qc2qi_hetero_freeze_tend, qc2qi_collect_tend, qc2qr_ice_shed_tend, nc_collect_tend, nc2ni_immers_freeze_tend,
-      ncshdc, qr2qi_collect_tend, nr_collect_tend, qr2qi_immers_freeze_tend, nr2ni_immers_freeze_tend, nr_ice_shed_tend,
-      qi2qr_melt_tend, ni2nr_melt_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qv2qi_nucleat_tend, ni_nucleat_tend,
-      ni_selfcollect_tend, ni_sublim_tend, qc2qi_berg_tend, inv_exner, latent_heat_sublim, latent_heat_fusion;
+  Real qc2qi_hetero_freeze_tend, qc2qi_collect_tend, qc2qr_ice_shed_tend, nc_collect_tend,
+      nc2ni_immers_freeze_tend, ncshdc, qr2qi_collect_tend, nr_collect_tend,
+      qr2qi_immers_freeze_tend, nr2ni_immers_freeze_tend, nr_ice_shed_tend, qi2qr_melt_tend,
+      ni2nr_melt_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qv2qi_nucleat_tend, ni_nucleat_tend,
+      ni_selfcollect_tend, ni_sublim_tend, qc2qi_berg_tend, inv_exner, latent_heat_sublim,
+      latent_heat_fusion;
   bool do_predict_nc, log_wetgrowth;
   Real dt, nmltratio, rho_qm_cloud;
   Real ncheti_cnt = 0, nicnt = 0, ninuc_cnt = 0, qcheti_cnt = 0, qicnt = 0, qinuc_cnt = 0;
@@ -472,8 +485,8 @@ struct P3UpdatePrognosticIceData {
 
 struct EvapRainData {
   // Inputs
-  Real qr_incld, qc_incld, nr_incld, qi_incld, cld_frac_l, cld_frac_r, qv, qv_prev, qv_sat_l, qv_sat_i, ab, abi, epsr,
-      epsi_tot, t, t_prev, latent_heat_sublim, dqsdt, dt;
+  Real qr_incld, qc_incld, nr_incld, qi_incld, cld_frac_l, cld_frac_r, qv, qv_prev, qv_sat_l,
+      qv_sat_i, ab, abi, epsr, epsi_tot, t, t_prev, latent_heat_sublim, dqsdt, dt;
 
   // Outs
   Real qr2qv_evap_tend, nr_evap_tend;
@@ -485,8 +498,8 @@ struct EvapRainData {
 
 struct P3UpdatePrognosticLiqData {
   // Inputs
-  Real qc2qr_accret_tend, nc_accret_tend, qc2qr_autoconv_tend, nc2nr_autoconv_tend, ncautr, nc_selfcollect_tend,
-      qr2qv_evap_tend, nr_evap_tend, nr_selfcollect_tend;
+  Real qc2qr_accret_tend, nc_accret_tend, qc2qr_autoconv_tend, nc2nr_autoconv_tend, ncautr,
+      nc_selfcollect_tend, qr2qv_evap_tend, nr_evap_tend, nr_selfcollect_tend;
 
   bool do_predict_nc, do_prescribed_CCN;
 
@@ -548,7 +561,8 @@ struct IceSelfCollectionData {
 
 struct IceRelaxationData {
   // Inputs
-  Real rho, temp, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv, mu, sc, qi_incld, ni_incld;
+  Real rho, temp, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv, mu, sc, qi_incld,
+      ni_incld;
 
   // Outputs
   Real epsi, epsi_tot;
@@ -583,17 +597,18 @@ struct IceNucleationData {
 
 struct IceWetGrowthData {
   // Inputs
-  Real rho, temp, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, latent_heat_vapor,
-      latent_heat_fusion, dv, kap, mu, sc, qv, qc_incld;
+  Real rho, temp, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt,
+      latent_heat_vapor, latent_heat_fusion, dv, kap, mu, sc, qv, qc_incld;
   Real qi_incld, ni_incld, qr_incld;
 
   // In/Outs
   bool log_wetgrowth;
 
-  Real qr2qi_collect_tend, qc2qi_collect_tend, qc_growth_rate, nr_ice_shed_tend, qc2qr_ice_shed_tend;
+  Real qr2qi_collect_tend, qc2qi_collect_tend, qc_growth_rate, nr_ice_shed_tend,
+      qc2qr_ice_shed_tend;
 
-  PTD_RW_SCALARS_ONLY(6, log_wetgrowth, qr2qi_collect_tend, qc2qi_collect_tend, qc_growth_rate, nr_ice_shed_tend,
-                      qc2qr_ice_shed_tend);
+  PTD_RW_SCALARS_ONLY(6, log_wetgrowth, qr2qi_collect_tend, qc2qi_collect_tend, qc_growth_rate,
+                      nr_ice_shed_tend, qc2qr_ice_shed_tend);
 };
 
 struct CheckValuesData : public PhysicsTestData {
@@ -622,7 +637,8 @@ struct IncloudMixingData {
   // Outputs
   Real qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld, bm_incld;
 
-  PTD_RW_SCALARS_ONLY(8, qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld, bm_incld);
+  PTD_RW_SCALARS_ONLY(8, qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld,
+                      bm_incld);
 };
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -634,19 +650,20 @@ struct P3MainPart1Data : public PhysicsTestData {
   Int kts, kte, kbot, ktop, kdir;
   bool do_predict_nc, do_prescribed_CCN;
   Real dt;
-  Real *pres, *dpres, *dz, *nc_nuceat_tend, *inv_exner, *exner, *inv_cld_frac_l, *inv_cld_frac_i, *inv_cld_frac_r,
-      *latent_heat_vapor, *latent_heat_sublim, *latent_heat_fusion, *nccn_prescribed;
+  Real *pres, *dpres, *dz, *nc_nuceat_tend, *inv_exner, *exner, *inv_cld_frac_l, *inv_cld_frac_i,
+      *inv_cld_frac_r, *latent_heat_vapor, *latent_heat_sublim, *latent_heat_fusion,
+      *nccn_prescribed;
 
   // In/out
-  Real *T_atm, *rho, *inv_rho, *qv_sat_l, *qv_sat_i, *qv_supersat_i, *rhofacr, *rhofaci, *acn, *qv, *th_atm, *qc, *nc,
-      *qr, *nr, *qi, *ni, *qm, *bm, *qc_incld, *qr_incld, *qi_incld, *qm_incld, *nc_incld, *nr_incld, *ni_incld,
-      *bm_incld;
+  Real *T_atm, *rho, *inv_rho, *qv_sat_l, *qv_sat_i, *qv_supersat_i, *rhofacr, *rhofaci, *acn, *qv,
+      *th_atm, *qc, *nc, *qr, *nr, *qi, *ni, *qm, *bm, *qc_incld, *qr_incld, *qi_incld, *qm_incld,
+      *nc_incld, *nr_incld, *ni_incld, *bm_incld;
 
   // Output
   bool is_nucleat_possible, is_hydromet_present;
 
-  P3MainPart1Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int kdir_, bool do_predict_nc_, bool do_prescribed_CCN_,
-                  Real dt_, bool = false, bool = false);
+  P3MainPart1Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int kdir_, bool do_predict_nc_,
+                  bool do_prescribed_CCN_, Real dt_, bool = false, bool = false);
 
   PTD_STD_DEF(P3MainPart1Data, 10, kts, kte, kbot, ktop, kdir, do_predict_nc, do_prescribed_CCN, dt,
               is_nucleat_possible, is_hydromet_present);
@@ -663,23 +680,25 @@ struct P3MainPart2Data : public PhysicsTestData {
   Int kts, kte, kbot, ktop, kdir;
   bool do_predict_nc, do_prescribed_CCN;
   Real dt, inv_dt;
-  Real *pres, *dpres, *dz, *nc_nuceat_tend, *inv_exner, *exner, *inv_cld_frac_l, *inv_cld_frac_i, *inv_cld_frac_r,
-      *ni_activated, *inv_qc_relvar, *cld_frac_i, *cld_frac_l, *cld_frac_r, *qv_prev, *t_prev;
+  Real *pres, *dpres, *dz, *nc_nuceat_tend, *inv_exner, *exner, *inv_cld_frac_l, *inv_cld_frac_i,
+      *inv_cld_frac_r, *ni_activated, *inv_qc_relvar, *cld_frac_i, *cld_frac_l, *cld_frac_r,
+      *qv_prev, *t_prev;
 
   // In/out
-  Real *T_atm, *rho, *inv_rho, *qv_sat_l, *qv_sat_i, *qv_supersat_i, *rhofacr, *rhofaci, *acn, *qv, *th_atm, *qc, *nc,
-      *qr, *nr, *qi, *ni, *qm, *bm, *latent_heat_vapor, *latent_heat_sublim, *latent_heat_fusion, *qc_incld, *qr_incld,
-      *qi_incld, *qm_incld, *nc_incld, *nr_incld, *ni_incld, *bm_incld, *mu_c, *nu, *lamc, *cdist, *cdist1, *cdistr,
-      *mu_r, *lamr, *logn0r, *qv2qi_depos_tend, *precip_total_tend, *nevapr, *qr_evap_tend, *vap_liq_exchange,
+  Real *T_atm, *rho, *inv_rho, *qv_sat_l, *qv_sat_i, *qv_supersat_i, *rhofacr, *rhofaci, *acn, *qv,
+      *th_atm, *qc, *nc, *qr, *nr, *qi, *ni, *qm, *bm, *latent_heat_vapor, *latent_heat_sublim,
+      *latent_heat_fusion, *qc_incld, *qr_incld, *qi_incld, *qm_incld, *nc_incld, *nr_incld,
+      *ni_incld, *bm_incld, *mu_c, *nu, *lamc, *cdist, *cdist1, *cdistr, *mu_r, *lamr, *logn0r,
+      *qv2qi_depos_tend, *precip_total_tend, *nevapr, *qr_evap_tend, *vap_liq_exchange,
       *vap_ice_exchange, *liq_ice_exchange, *pratot, *prctot;
 
   bool is_hydromet_present;
 
-  P3MainPart2Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int kdir_, bool do_predict_nc_, bool do_prescribed_CCN,
-                  Real dt_, Real = 0., bool = false);
+  P3MainPart2Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int kdir_, bool do_predict_nc_,
+                  bool do_prescribed_CCN, Real dt_, Real = 0., bool = false);
 
-  PTD_STD_DEF(P3MainPart2Data, 10, kts, kte, kbot, ktop, kdir, do_predict_nc, do_prescribed_CCN, dt, inv_dt,
-              is_hydromet_present);
+  PTD_STD_DEF(P3MainPart2Data, 10, kts, kte, kbot, ktop, kdir, do_predict_nc, do_prescribed_CCN, dt,
+              inv_dt, is_hydromet_present);
 
   Int nk() const { return (kte - kts) + 1; }
 };
@@ -694,9 +713,10 @@ struct P3MainPart3Data : public PhysicsTestData {
   Real *inv_exner, *cld_frac_l, *cld_frac_r, *cld_frac_i;
 
   // In/out
-  Real *rho, *inv_rho, *rhofaci, *qv, *th_atm, *qc, *nc, *qr, *nr, *qi, *ni, *qm, *bm, *latent_heat_vapor,
-      *latent_heat_sublim, *mu_c, *nu, *lamc, *mu_r, *lamr, *vap_liq_exchange, *ze_rain, *ze_ice, *diag_vm_qi,
-      *diag_eff_radius_qi, *diag_diam_qi, *rho_qi, *diag_equiv_reflectivity, *diag_eff_radius_qc, *diag_eff_radius_qr;
+  Real *rho, *inv_rho, *rhofaci, *qv, *th_atm, *qc, *nc, *qr, *nr, *qi, *ni, *qm, *bm,
+      *latent_heat_vapor, *latent_heat_sublim, *mu_c, *nu, *lamc, *mu_r, *lamr, *vap_liq_exchange,
+      *ze_rain, *ze_ice, *diag_vm_qi, *diag_eff_radius_qi, *diag_diam_qi, *rho_qi,
+      *diag_equiv_reflectivity, *diag_eff_radius_qc, *diag_eff_radius_qr;
 
   P3MainPart3Data(Int kts_, Int kte_, Int kbot_, Int ktop_, Int kdir_);
 
@@ -713,26 +733,29 @@ struct P3MainData : public PhysicsTestData {
 
   // Inputs
   Int its, ite, kts, kte, it;
-  Real *pres, *dz, *nc_nuceat_tend, *nccn_prescribed, *ni_activated, *dpres, *inv_exner, *cld_frac_i, *cld_frac_l,
-      *cld_frac_r, *inv_qc_relvar, *qv_prev, *t_prev;
+  Real *pres, *dz, *nc_nuceat_tend, *nccn_prescribed, *ni_activated, *dpres, *inv_exner,
+      *cld_frac_i, *cld_frac_l, *cld_frac_r, *inv_qc_relvar, *qv_prev, *t_prev;
   Real dt;
   bool do_predict_nc, do_prescribed_CCN;
   bool use_hetfrz_classnuc = false;
-  Real *hetfrz_immersion_nucleation_tend, *hetfrz_contact_nucleation_tend, *hetfrz_deposition_nucleation_tend;
+  Real *hetfrz_immersion_nucleation_tend, *hetfrz_contact_nucleation_tend,
+      *hetfrz_deposition_nucleation_tend;
 
   // In/out
   Real *qc, *nc, *qr, *nr, *qi, *qm, *ni, *bm, *qv, *th_atm;
 
   // Out
-  Real *diag_eff_radius_qc, *diag_eff_radius_qi, *diag_eff_radius_qr, *rho_qi, *mu_c, *lamc, *qv2qi_depos_tend,
-      *precip_total_tend, *nevapr, *qr_evap_tend, *liq_ice_exchange, *vap_liq_exchange, *vap_ice_exchange,
-      *precip_liq_flux, *precip_ice_flux, *precip_liq_surf, *precip_ice_surf;
+  Real *diag_eff_radius_qc, *diag_eff_radius_qi, *diag_eff_radius_qr, *rho_qi, *mu_c, *lamc,
+      *qv2qi_depos_tend, *precip_total_tend, *nevapr, *qr_evap_tend, *liq_ice_exchange,
+      *vap_liq_exchange, *vap_ice_exchange, *precip_liq_flux, *precip_ice_flux, *precip_liq_surf,
+      *precip_ice_surf;
   Real elapsed_s;
 
-  P3MainData(Int its_, Int ite_, Int kts_, Int kte_, Int it_, Real dt_, bool do_predict_nc_, bool do_prescribed_CCN_,
-             Real = 0.);
+  P3MainData(Int its_, Int ite_, Int kts_, Int kte_, Int it_, Real dt_, bool do_predict_nc_,
+             bool do_prescribed_CCN_, Real = 0.);
 
-  PTD_STD_DEF(P3MainData, 9, its, ite, kts, kte, it, dt, do_predict_nc, do_prescribed_CCN, elapsed_s);
+  PTD_STD_DEF(P3MainData, 9, its, ite, kts, kte, it, dt, do_predict_nc, do_prescribed_CCN,
+              elapsed_s);
 };
 
 struct IceSupersatConservationData {
@@ -761,7 +784,8 @@ struct NcConservationData {
 
   void randomize(std::mt19937_64 &engine);
 
-  PTD_RW_SCALARS_ONLY(4, nc_collect_tend, nc2ni_immers_freeze_tend, nc_accret_tend, nc2nr_autoconv_tend);
+  PTD_RW_SCALARS_ONLY(4, nc_collect_tend, nc2ni_immers_freeze_tend, nc_accret_tend,
+                      nc2nr_autoconv_tend);
 };
 
 struct NrConservationData {
@@ -773,7 +797,8 @@ struct NrConservationData {
 
   void randomize(std::mt19937_64 &engine);
 
-  PTD_RW_SCALARS_ONLY(4, nr_collect_tend, nr2ni_immers_freeze_tend, nr_selfcollect_tend, nr_evap_tend);
+  PTD_RW_SCALARS_ONLY(4, nr_collect_tend, nr2ni_immers_freeze_tend, nr_selfcollect_tend,
+                      nr_evap_tend);
 };
 
 struct NiConservationData {
@@ -809,77 +834,89 @@ struct PreventLiqSupersaturationData {
  * then sync back to host and unpack. These are used by the BFB unit tests.
  */
 
-void calc_first_order_upwind_step_host(Int kts, Int kte, Int kdir, Int kbot, Int k_qxtop, Real dt_sub, Real *rho,
-                                       Real *inv_rho, Real *inv_dz, Int num_arrays, Real **fluxes, Real **vs,
-                                       Real **qnx);
+void calc_first_order_upwind_step_host(Int kts, Int kte, Int kdir, Int kbot, Int k_qxtop,
+                                       Real dt_sub, Real *rho, Real *inv_rho, Real *inv_dz,
+                                       Int num_arrays, Real **fluxes, Real **vs, Real **qnx);
 
-void generalized_sedimentation_host(Int kts, Int kte, Int kdir, Int k_qxtop, Int *k_qxbot, Int kbot, Real Co_max,
-                                    Real *dt_left, Real *prt_accum, Real *inv_dz, Real *inv_rho, Real *rho,
-                                    Int num_arrays, Real **vs, Real **fluxes, Real **qnx);
+void generalized_sedimentation_host(Int kts, Int kte, Int kdir, Int k_qxtop, Int *k_qxbot, Int kbot,
+                                    Real Co_max, Real *dt_left, Real *prt_accum, Real *inv_dz,
+                                    Real *inv_rho, Real *rho, Int num_arrays, Real **vs,
+                                    Real **fluxes, Real **qnx);
 
-void cloud_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *qc_incld, Real *rho, Real *inv_rho,
-                              Real *cld_frac_l, Real *acn, Real *inv_dz, Real dt, Real inv_dt, bool do_predict_nc,
-                              Real *qc, Real *nc, Real *nc_incld, Real *mu_c, Real *lamc, Real *precip_liq_surf,
+void cloud_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *qc_incld,
+                              Real *rho, Real *inv_rho, Real *cld_frac_l, Real *acn, Real *inv_dz,
+                              Real dt, Real inv_dt, bool do_predict_nc, Real *qc, Real *nc,
+                              Real *nc_incld, Real *mu_c, Real *lamc, Real *precip_liq_surf,
                               Real *qc_tend, Real *nc_tend);
 
-void ice_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *rho, Real *inv_rho, Real *rhofaci,
-                            Real *cld_frac_i, Real *inv_dz, Real dt, Real inv_dt, Real *qi, Real *qi_incld, Real *ni,
-                            Real *qm, Real *qm_incld, Real *bm, Real *bm_incld, Real *ni_incld, Real *precip_ice_surf,
-                            Real *qi_tend, Real *ni_tend);
+void ice_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *rho,
+                            Real *inv_rho, Real *rhofaci, Real *cld_frac_i, Real *inv_dz, Real dt,
+                            Real inv_dt, Real *qi, Real *qi_incld, Real *ni, Real *qm,
+                            Real *qm_incld, Real *bm, Real *bm_incld, Real *ni_incld,
+                            Real *precip_ice_surf, Real *qi_tend, Real *ni_tend);
 
-void rain_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *qr_incld, Real *rho, Real *inv_rho,
-                             Real *rhofacr, Real *cld_frac_r, Real *inv_dz, Real dt, Real inv_dt, Real *qr, Real *nr,
-                             Real *nr_incld, Real *mu_r, Real *lamr, Real *precip_liq_surf, Real *precip_liq_flux,
+void rain_sedimentation_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *qr_incld,
+                             Real *rho, Real *inv_rho, Real *rhofacr, Real *cld_frac_r,
+                             Real *inv_dz, Real dt, Real inv_dt, Real *qr, Real *nr, Real *nr_incld,
+                             Real *mu_r, Real *lamr, Real *precip_liq_surf, Real *precip_liq_flux,
                              Real *qr_tend, Real *nr_tend);
 
-void homogeneous_freezing_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *T_atm, Real *inv_exner, Real *qc,
-                               Real *nc, Real *qr, Real *nr, Real *qi, Real *ni, Real *qm, Real *bm, Real *th_atm);
+void homogeneous_freezing_host(Int kts, Int kte, Int ktop, Int kbot, Int kdir, Real *T_atm,
+                               Real *inv_exner, Real *qc, Real *nc, Real *qr, Real *nr, Real *qi,
+                               Real *ni, Real *qm, Real *bm, Real *th_atm);
 
-void check_values_host(Real *Qv, Real *temp, Int kstart, Int kend, Int timestepcount, bool force_abort, Int source_ind,
-                       Real *col_loc);
+void check_values_host(Real *Qv, Real *temp, Int kstart, Int kend, Int timestepcount,
+                       bool force_abort, Int source_ind, Real *col_loc);
 
-void p3_main_part1_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_predict_nc, bool do_prescribed_CCN,
-                        Real dt, Real *pres, Real *dpres, Real *dz, Real *nc_nuceat_tend, Real *nccn_prescribed,
-                        Real *inv_exner, Real *exner, Real *inv_cld_frac_l, Real *inv_cld_frac_i, Real *inv_cld_frac_r,
-                        Real *T_atm, Real *rho, Real *inv_rho, Real *qv_sat_l, Real *qv_sat_i, Real *qv_supersat_i,
-                        Real *rhofacr, Real *rhofaci, Real *acn, Real *qv, Real *th_atm, Real *qc, Real *nc, Real *qr,
-                        Real *nr, Real *qi, Real *ni, Real *qm, Real *bm, Real *qc_incld, Real *qr_incld,
-                        Real *qi_incld, Real *qm_incld, Real *nc_incld, Real *nr_incld, Real *ni_incld, Real *bm_incld,
-                        bool *is_nucleat_possible, bool *is_hydromet_present);
+void p3_main_part1_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_predict_nc,
+                        bool do_prescribed_CCN, Real dt, Real *pres, Real *dpres, Real *dz,
+                        Real *nc_nuceat_tend, Real *nccn_prescribed, Real *inv_exner, Real *exner,
+                        Real *inv_cld_frac_l, Real *inv_cld_frac_i, Real *inv_cld_frac_r,
+                        Real *T_atm, Real *rho, Real *inv_rho, Real *qv_sat_l, Real *qv_sat_i,
+                        Real *qv_supersat_i, Real *rhofacr, Real *rhofaci, Real *acn, Real *qv,
+                        Real *th_atm, Real *qc, Real *nc, Real *qr, Real *nr, Real *qi, Real *ni,
+                        Real *qm, Real *bm, Real *qc_incld, Real *qr_incld, Real *qi_incld,
+                        Real *qm_incld, Real *nc_incld, Real *nr_incld, Real *ni_incld,
+                        Real *bm_incld, bool *is_nucleat_possible, bool *is_hydromet_present);
 
-void p3_main_part2_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_predict_nc, bool do_prescribed_CCN,
-                        Real dt, Real inv_dt, const Real *hetfrz_immersion_nucleation_tend,
-                        const Real *hetfrz_contact_nucleation_tend, const Real *hetfrz_deposition_nucleation_tend,
-                        Real *pres, Real *dpres, Real *dz, Real *nc_nuceat_tend, Real *inv_exner, Real *exner,
-                        Real *inv_cld_frac_l, Real *inv_cld_frac_i, Real *inv_cld_frac_r, Real *ni_activated,
-                        Real *inv_qc_relvar, Real *cld_frac_i, Real *cld_frac_l, Real *cld_frac_r, Real *qv_prev,
-                        Real *t_prev, Real *T_atm, Real *rho, Real *inv_rho, Real *qv_sat_l, Real *qv_sat_i,
-                        Real *qv_supersat_i, Real *rhofacr, Real *rhofaci, Real *acn, Real *qv, Real *th_atm, Real *qc,
-                        Real *nc, Real *qr, Real *nr, Real *qi, Real *ni, Real *qm, Real *bm, Real *qc_incld,
-                        Real *qr_incld, Real *qi_incld, Real *qm_incld, Real *nc_incld, Real *nr_incld, Real *ni_incld,
-                        Real *bm_incld, Real *mu_c, Real *nu, Real *lamc, Real *cdist, Real *cdist1, Real *cdistr,
-                        Real *mu_r, Real *lamr, Real *logn0r, Real *qv2qi_depos_tend, Real *precip_total_tend,
-                        Real *nevapr, Real *qr_evap_tend, Real *vap_liq_exchange, Real *vap_ice_exchange,
-                        Real *liq_ice_exchange, Real *qr2qv_evap, Real *qi2qv_sublim, Real *qc2qr_accret,
-                        Real *qc2qr_autoconv, Real *qv2qi_vapdep, Real *qc2qi_berg, Real *qc2qr_ice_shed,
-                        Real *qc2qi_collect, Real *qr2qi_collect, Real *qc2qi_hetero_freeze, Real *qr2qi_immers_freeze,
-                        Real *qi2qr_melt, Real *pratot, Real *prctot, bool *is_hydromet_present);
+void p3_main_part2_host(
+    Int kts, Int kte, Int kbot, Int ktop, Int kdir, bool do_predict_nc, bool do_prescribed_CCN,
+    Real dt, Real inv_dt, const Real *hetfrz_immersion_nucleation_tend,
+    const Real *hetfrz_contact_nucleation_tend, const Real *hetfrz_deposition_nucleation_tend,
+    Real *pres, Real *dpres, Real *dz, Real *nc_nuceat_tend, Real *inv_exner, Real *exner,
+    Real *inv_cld_frac_l, Real *inv_cld_frac_i, Real *inv_cld_frac_r, Real *ni_activated,
+    Real *inv_qc_relvar, Real *cld_frac_i, Real *cld_frac_l, Real *cld_frac_r, Real *qv_prev,
+    Real *t_prev, Real *T_atm, Real *rho, Real *inv_rho, Real *qv_sat_l, Real *qv_sat_i,
+    Real *qv_supersat_i, Real *rhofacr, Real *rhofaci, Real *acn, Real *qv, Real *th_atm, Real *qc,
+    Real *nc, Real *qr, Real *nr, Real *qi, Real *ni, Real *qm, Real *bm, Real *qc_incld,
+    Real *qr_incld, Real *qi_incld, Real *qm_incld, Real *nc_incld, Real *nr_incld, Real *ni_incld,
+    Real *bm_incld, Real *mu_c, Real *nu, Real *lamc, Real *cdist, Real *cdist1, Real *cdistr,
+    Real *mu_r, Real *lamr, Real *logn0r, Real *qv2qi_depos_tend, Real *precip_total_tend,
+    Real *nevapr, Real *qr_evap_tend, Real *vap_liq_exchange, Real *vap_ice_exchange,
+    Real *liq_ice_exchange, Real *qr2qv_evap, Real *qi2qv_sublim, Real *qc2qr_accret,
+    Real *qc2qr_autoconv, Real *qv2qi_vapdep, Real *qc2qi_berg, Real *qc2qr_ice_shed,
+    Real *qc2qi_collect, Real *qr2qi_collect, Real *qc2qi_hetero_freeze, Real *qr2qi_immers_freeze,
+    Real *qi2qr_melt, Real *pratot, Real *prctot, bool *is_hydromet_present);
 
-void p3_main_part3_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, Real *inv_exner, Real *cld_frac_l,
-                        Real *cld_frac_r, Real *cld_frac_i, Real *rho, Real *inv_rho, Real *rhofaci, Real *qv,
-                        Real *th_atm, Real *qc, Real *nc, Real *qr, Real *nr, Real *qi, Real *ni, Real *qm, Real *bm,
-                        Real *mu_c, Real *nu, Real *lamc, Real *mu_r, Real *lamr, Real *vap_liq_exchange, Real *ze_rain,
-                        Real *ze_ice, Real *diag_vm_qi, Real *diag_eff_radius_qi, Real *diag_diam_qi, Real *rho_qi,
-                        Real *diag_equiv_reflectivity, Real *diag_eff_radius_qc, Real *diag_eff_radius_qr);
+void p3_main_part3_host(Int kts, Int kte, Int kbot, Int ktop, Int kdir, Real *inv_exner,
+                        Real *cld_frac_l, Real *cld_frac_r, Real *cld_frac_i, Real *rho,
+                        Real *inv_rho, Real *rhofaci, Real *qv, Real *th_atm, Real *qc, Real *nc,
+                        Real *qr, Real *nr, Real *qi, Real *ni, Real *qm, Real *bm, Real *mu_c,
+                        Real *nu, Real *lamc, Real *mu_r, Real *lamr, Real *vap_liq_exchange,
+                        Real *ze_rain, Real *ze_ice, Real *diag_vm_qi, Real *diag_eff_radius_qi,
+                        Real *diag_diam_qi, Real *rho_qi, Real *diag_equiv_reflectivity,
+                        Real *diag_eff_radius_qc, Real *diag_eff_radius_qr);
 
-Int p3_main_host(Real *qc, Real *nc, Real *qr, Real *nr, Real *th_atm, Real *qv, Real dt, Real *qi, Real *qm, Real *ni,
-                 Real *bm, Real *pres, Real *dz, Real *nc_nuceat_tend, Real *nccn_prescribed, Real *ni_activated,
-                 Real *inv_qc_relvar, Int it, Real *precip_liq_surf, Real *precip_ice_surf, Int its, Int ite, Int kts,
-                 Int kte, Real *diag_eff_radius_qc, Real *diag_eff_radius_qi, Real *diag_eff_radius_qr, Real *rho_qi,
-                 bool do_predict_nc, bool do_prescribed_CCN, bool use_hetfrz_classnuc, Real *dpres, Real *inv_exner,
-                 Real *qv2qi_depos_tend, Real *precip_liq_flux, Real *precip_ice_flux, Real *cld_frac_r,
-                 Real *cld_frac_l, Real *cld_frac_i, Real *liq_ice_exchange, Real *vap_liq_exchange,
-                 Real *vap_ice_exchange, Real *qv_prev, Real *t_prev);
+Int p3_main_host(Real *qc, Real *nc, Real *qr, Real *nr, Real *th_atm, Real *qv, Real dt, Real *qi,
+                 Real *qm, Real *ni, Real *bm, Real *pres, Real *dz, Real *nc_nuceat_tend,
+                 Real *nccn_prescribed, Real *ni_activated, Real *inv_qc_relvar, Int it,
+                 Real *precip_liq_surf, Real *precip_ice_surf, Int its, Int ite, Int kts, Int kte,
+                 Real *diag_eff_radius_qc, Real *diag_eff_radius_qi, Real *diag_eff_radius_qr,
+                 Real *rho_qi, bool do_predict_nc, bool do_prescribed_CCN, bool use_hetfrz_classnuc,
+                 Real *dpres, Real *inv_exner, Real *qv2qi_depos_tend, Real *precip_liq_flux,
+                 Real *precip_ice_flux, Real *cld_frac_r, Real *cld_frac_l, Real *cld_frac_i,
+                 Real *liq_ice_exchange, Real *vap_liq_exchange, Real *vap_ice_exchange,
+                 Real *qv_prev, Real *t_prev);
 
 } // namespace p3
 } // namespace scream
diff --git i/components/eamxx/src/physics/p3/tests/p3_autoconversion_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_autoconversion_unit_tests.cpp
index 4a4c296dc7..6fba4647c7 100644
--- i/components/eamxx/src/physics/p3/tests/p3_autoconversion_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_autoconversion_unit_tests.cpp
@@ -71,8 +71,8 @@ struct UnitWrap::UnitTest<D>::TestP3CloudWaterAutoconversion : public UnitWrap::
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack rho, inv_rho, qc_incld, nc_incld, qr_incld, mu_c, nu, qc2qr_autoconv_tend, nc2nr_autoconv_tend, ncautr,
-              inv_qc_relvar;
+          Spack rho, inv_rho, qc_incld, nc_incld, qr_incld, mu_c, nu, qc2qr_autoconv_tend,
+              nc2nr_autoconv_tend, ncautr, inv_qc_relvar;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             rho[s]                 = cwadc_device(vs).rho;
             qc_incld[s]            = cwadc_device(vs).qc_incld;
@@ -83,8 +83,8 @@ struct UnitWrap::UnitTest<D>::TestP3CloudWaterAutoconversion : public UnitWrap::
             ncautr[s]              = cwadc_device(vs).ncautr;
           }
 
-          Functions::cloud_water_autoconversion(rho, qc_incld, nc_incld, inv_qc_relvar, qc2qr_autoconv_tend,
-                                                nc2nr_autoconv_tend, ncautr,
+          Functions::cloud_water_autoconversion(rho, qc_incld, nc_incld, inv_qc_relvar,
+                                                qc2qr_autoconv_tend, nc2nr_autoconv_tend, ncautr,
                                                 p3::Functions<Real, DefaultDevice>::P3Runtime());
 
           // Copy results back into views
@@ -129,8 +129,9 @@ struct UnitWrap::UnitTest<D>::TestP3CloudWaterAutoconversion : public UnitWrap::
     for (int si = 0; si < Spack::n; ++si) {
       qc_incld[si] = 1e-6 * i * Spack::n + si;
     }
-    Functions::cloud_water_autoconversion(rho, qc_incld, nc_incld, inv_qc_relvar, qc2qr_autoconv_tend,
-                                          nc2nr_autoconv_tend, ncautr, p3::Functions<Real, DefaultDevice>::P3Runtime());
+    Functions::cloud_water_autoconversion(rho, qc_incld, nc_incld, inv_qc_relvar,
+                                          qc2qr_autoconv_tend, nc2nr_autoconv_tend, ncautr,
+                                          p3::Functions<Real, DefaultDevice>::P3Runtime());
     if ((qc2qr_autoconv_tend < 0.0).any()) {
       errors++;
     }
@@ -157,7 +158,8 @@ struct UnitWrap::UnitTest<D>::TestP3CloudWaterAutoconversion : public UnitWrap::
 namespace {
 
 TEST_CASE("p3_cloud_water_autoconversion_test", "[p3_cloud_water_autoconversion_test]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestP3CloudWaterAutoconversion;
+  using T = scream::p3::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestP3CloudWaterAutoconversion;
 
   T t;
   t.run_physics();
diff --git i/components/eamxx/src/physics/p3/tests/p3_back_to_cell_average_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_back_to_cell_average_unit_tests.cpp
index f5b76d32c8..e95a9b8ec0 100644
--- i/components/eamxx/src/physics/p3/tests/p3_back_to_cell_average_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_back_to_cell_average_unit_tests.cpp
@@ -17,7 +17,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestBackToCellAverage : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestBackToCellAverage : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys() {
     // TODO
@@ -36,7 +37,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestBackToCellAverage : publ
     // Sync to device.
     view_1d<BackToCellAverageData> device_data("back_to_cell_average", max_pack_size);
     const auto host_data = Kokkos::create_mirror_view(device_data);
-    std::copy(&back_to_cell_average_data[0], &back_to_cell_average_data[0] + max_pack_size, host_data.data());
+    std::copy(&back_to_cell_average_data[0], &back_to_cell_average_data[0] + max_pack_size,
+              host_data.data());
     Kokkos::deep_copy(device_data, host_data);
 
     // Read baseline data
@@ -52,13 +54,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestBackToCellAverage : publ
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack cld_frac_l, cld_frac_r, cld_frac_i, qc2qr_accret_tend, qr2qv_evap_tend, qc2qr_autoconv_tend,
-              nc_accret_tend, nc_selfcollect_tend, nc2nr_autoconv_tend, nr_selfcollect_tend, nr_evap_tend, ncautr,
-              qi2qv_sublim_tend, nr_ice_shed_tend, qc2qi_hetero_freeze_tend, qr2qi_collect_tend, qc2qr_ice_shed_tend,
-              qi2qr_melt_tend, qc2qi_collect_tend, qr2qi_immers_freeze_tend, ni2nr_melt_tend, nc_collect_tend, ncshdc,
-              nc2ni_immers_freeze_tend, nr_collect_tend, ni_selfcollect_tend, qv2qi_vapdep_tend,
-              nr2ni_immers_freeze_tend, ni_sublim_tend, qv2qi_nucleat_tend, ni_nucleat_tend, qc2qi_berg_tend,
-              ncheti_cnt, qcheti_cnt, nicnt, qicnt, ninuc_cnt, qinuc_cnt;
+          Spack cld_frac_l, cld_frac_r, cld_frac_i, qc2qr_accret_tend, qr2qv_evap_tend,
+              qc2qr_autoconv_tend, nc_accret_tend, nc_selfcollect_tend, nc2nr_autoconv_tend,
+              nr_selfcollect_tend, nr_evap_tend, ncautr, qi2qv_sublim_tend, nr_ice_shed_tend,
+              qc2qi_hetero_freeze_tend, qr2qi_collect_tend, qc2qr_ice_shed_tend, qi2qr_melt_tend,
+              qc2qi_collect_tend, qr2qi_immers_freeze_tend, ni2nr_melt_tend, nc_collect_tend,
+              ncshdc, nc2ni_immers_freeze_tend, nr_collect_tend, ni_selfcollect_tend,
+              qv2qi_vapdep_tend, nr2ni_immers_freeze_tend, ni_sublim_tend, qv2qi_nucleat_tend,
+              ni_nucleat_tend, qc2qi_berg_tend, ncheti_cnt, qcheti_cnt, nicnt, qicnt, ninuc_cnt,
+              qinuc_cnt;
           Smask context;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             cld_frac_l[s]               = device_data[s].cld_frac_l;
@@ -102,13 +106,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestBackToCellAverage : publ
             context.set(s, device_data[s].context);
           }
           Functions::back_to_cell_average(
-              cld_frac_l, cld_frac_r, cld_frac_i, qc2qr_accret_tend, qr2qv_evap_tend, qc2qr_autoconv_tend,
-              nc_accret_tend, nc_selfcollect_tend, nc2nr_autoconv_tend, nr_selfcollect_tend, nr_evap_tend, ncautr,
-              qi2qv_sublim_tend, nr_ice_shed_tend, qc2qi_hetero_freeze_tend, qr2qi_collect_tend, qc2qr_ice_shed_tend,
-              qi2qr_melt_tend, qc2qi_collect_tend, qr2qi_immers_freeze_tend, ni2nr_melt_tend, nc_collect_tend, ncshdc,
-              nc2ni_immers_freeze_tend, nr_collect_tend, ni_selfcollect_tend, qv2qi_vapdep_tend,
-              nr2ni_immers_freeze_tend, ni_sublim_tend, qv2qi_nucleat_tend, ni_nucleat_tend, qc2qi_berg_tend,
-              ncheti_cnt, qcheti_cnt, nicnt, qicnt, ninuc_cnt, qinuc_cnt, context);
+              cld_frac_l, cld_frac_r, cld_frac_i, qc2qr_accret_tend, qr2qv_evap_tend,
+              qc2qr_autoconv_tend, nc_accret_tend, nc_selfcollect_tend, nc2nr_autoconv_tend,
+              nr_selfcollect_tend, nr_evap_tend, ncautr, qi2qv_sublim_tend, nr_ice_shed_tend,
+              qc2qi_hetero_freeze_tend, qr2qi_collect_tend, qc2qr_ice_shed_tend, qi2qr_melt_tend,
+              qc2qi_collect_tend, qr2qi_immers_freeze_tend, ni2nr_melt_tend, nc_collect_tend,
+              ncshdc, nc2ni_immers_freeze_tend, nr_collect_tend, ni_selfcollect_tend,
+              qv2qi_vapdep_tend, nr2ni_immers_freeze_tend, ni_sublim_tend, qv2qi_nucleat_tend,
+              ni_nucleat_tend, qc2qi_berg_tend, ncheti_cnt, qcheti_cnt, nicnt, qicnt, ninuc_cnt,
+              qinuc_cnt, context);
 
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
@@ -152,29 +158,39 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestBackToCellAverage : publ
       for (Int s = 0; s < max_pack_size; ++s) {
         REQUIRE(back_to_cell_average_data[s].qc2qr_accret_tend == host_data[s].qc2qr_accret_tend);
         REQUIRE(back_to_cell_average_data[s].qr2qv_evap_tend == host_data[s].qr2qv_evap_tend);
-        REQUIRE(back_to_cell_average_data[s].qc2qr_autoconv_tend == host_data[s].qc2qr_autoconv_tend);
+        REQUIRE(back_to_cell_average_data[s].qc2qr_autoconv_tend ==
+                host_data[s].qc2qr_autoconv_tend);
         REQUIRE(back_to_cell_average_data[s].nc_accret_tend == host_data[s].nc_accret_tend);
-        REQUIRE(back_to_cell_average_data[s].nc_selfcollect_tend == host_data[s].nc_selfcollect_tend);
-        REQUIRE(back_to_cell_average_data[s].nc2nr_autoconv_tend == host_data[s].nc2nr_autoconv_tend);
-        REQUIRE(back_to_cell_average_data[s].nr_selfcollect_tend == host_data[s].nr_selfcollect_tend);
+        REQUIRE(back_to_cell_average_data[s].nc_selfcollect_tend ==
+                host_data[s].nc_selfcollect_tend);
+        REQUIRE(back_to_cell_average_data[s].nc2nr_autoconv_tend ==
+                host_data[s].nc2nr_autoconv_tend);
+        REQUIRE(back_to_cell_average_data[s].nr_selfcollect_tend ==
+                host_data[s].nr_selfcollect_tend);
         REQUIRE(back_to_cell_average_data[s].nr_evap_tend == host_data[s].nr_evap_tend);
         REQUIRE(back_to_cell_average_data[s].ncautr == host_data[s].ncautr);
         REQUIRE(back_to_cell_average_data[s].qi2qv_sublim_tend == host_data[s].qi2qv_sublim_tend);
         REQUIRE(back_to_cell_average_data[s].nr_ice_shed_tend == host_data[s].nr_ice_shed_tend);
-        REQUIRE(back_to_cell_average_data[s].qc2qi_hetero_freeze_tend == host_data[s].qc2qi_hetero_freeze_tend);
+        REQUIRE(back_to_cell_average_data[s].qc2qi_hetero_freeze_tend ==
+                host_data[s].qc2qi_hetero_freeze_tend);
         REQUIRE(back_to_cell_average_data[s].qr2qi_collect_tend == host_data[s].qr2qi_collect_tend);
-        REQUIRE(back_to_cell_average_data[s].qc2qr_ice_shed_tend == host_data[s].qc2qr_ice_shed_tend);
+        REQUIRE(back_to_cell_average_data[s].qc2qr_ice_shed_tend ==
+                host_data[s].qc2qr_ice_shed_tend);
         REQUIRE(back_to_cell_average_data[s].qi2qr_melt_tend == host_data[s].qi2qr_melt_tend);
         REQUIRE(back_to_cell_average_data[s].qc2qi_collect_tend == host_data[s].qc2qi_collect_tend);
-        REQUIRE(back_to_cell_average_data[s].qr2qi_immers_freeze_tend == host_data[s].qr2qi_immers_freeze_tend);
+        REQUIRE(back_to_cell_average_data[s].qr2qi_immers_freeze_tend ==
+                host_data[s].qr2qi_immers_freeze_tend);
         REQUIRE(back_to_cell_average_data[s].ni2nr_melt_tend == host_data[s].ni2nr_melt_tend);
         REQUIRE(back_to_cell_average_data[s].nc_collect_tend == host_data[s].nc_collect_tend);
         REQUIRE(back_to_cell_average_data[s].ncshdc == host_data[s].ncshdc);
-        REQUIRE(back_to_cell_average_data[s].nc2ni_immers_freeze_tend == host_data[s].nc2ni_immers_freeze_tend);
+        REQUIRE(back_to_cell_average_data[s].nc2ni_immers_freeze_tend ==
+                host_data[s].nc2ni_immers_freeze_tend);
         REQUIRE(back_to_cell_average_data[s].nr_collect_tend == host_data[s].nr_collect_tend);
-        REQUIRE(back_to_cell_average_data[s].ni_selfcollect_tend == host_data[s].ni_selfcollect_tend);
+        REQUIRE(back_to_cell_average_data[s].ni_selfcollect_tend ==
+                host_data[s].ni_selfcollect_tend);
         REQUIRE(back_to_cell_average_data[s].qv2qi_vapdep_tend == host_data[s].qv2qi_vapdep_tend);
-        REQUIRE(back_to_cell_average_data[s].nr2ni_immers_freeze_tend == host_data[s].nr2ni_immers_freeze_tend);
+        REQUIRE(back_to_cell_average_data[s].nr2ni_immers_freeze_tend ==
+                host_data[s].nr2ni_immers_freeze_tend);
         REQUIRE(back_to_cell_average_data[s].ni_sublim_tend == host_data[s].ni_sublim_tend);
         REQUIRE(back_to_cell_average_data[s].qv2qi_nucleat_tend == host_data[s].qv2qi_nucleat_tend);
         REQUIRE(back_to_cell_average_data[s].ni_nucleat_tend == host_data[s].ni_nucleat_tend);
diff --git i/components/eamxx/src/physics/p3/tests/p3_calc_liq_relaxation_timescale_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_calc_liq_relaxation_timescale_unit_tests.cpp
index 51be8d34f1..6bf44289ca 100644
--- i/components/eamxx/src/physics/p3/tests/p3_calc_liq_relaxation_timescale_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_calc_liq_relaxation_timescale_unit_tests.cpp
@@ -83,8 +83,9 @@ struct UnitWrap::UnitTest<D>::TestCalcLiqRelaxationTimescale : public UnitWrap::
           }
 
           Spack epsr{0.0}, epsc{0.0};
-          Functions::calc_liq_relaxation_timescale(revap_table_vals, rho, self_device(0).f1r, self_device(0).f2r, dv,
-                                                   mu, sc, mu_r, lamr, cdistr, cdist, qr_incld, qc_incld, epsr, epsc);
+          Functions::calc_liq_relaxation_timescale(revap_table_vals, rho, self_device(0).f1r,
+                                                   self_device(0).f2r, dv, mu, sc, mu_r, lamr,
+                                                   cdistr, cdist, qr_incld, qc_incld, epsr, epsc);
 
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             self_device(vs).epsr = epsr[s];
@@ -114,7 +115,8 @@ struct UnitWrap::UnitTest<D>::TestCalcLiqRelaxationTimescale : public UnitWrap::
 namespace {
 
 TEST_CASE("p3_calc_liq_relaxation_timescale", "[p3_functions]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCalcLiqRelaxationTimescale;
+  using T = scream::p3::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestCalcLiqRelaxationTimescale;
 
   T t;
   t.run_phys();
diff --git i/components/eamxx/src/physics/p3/tests/p3_calc_rime_density_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_calc_rime_density_unit_tests.cpp
index d962ec9cfe..895fb3db52 100644
--- i/components/eamxx/src/physics/p3/tests/p3_calc_rime_density_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_calc_rime_density_unit_tests.cpp
@@ -17,7 +17,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestCalcRimeDensity : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestCalcRimeDensity : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys() {
     // TODO
@@ -51,8 +52,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCalcRimeDensity : public
 
     CalcRimeDensityData calc_rime_density_data[max_pack_size] = {
         // T_atm, rhofaci, table_val_qi_fallspd1, acn, lamc, mu_c, qc_incld, qc2qi_collect_tend
-        {t_not_freezing, rhofaci1, table_val_qi_fallspd1, acn1, lamc1, mu_c1, qc_incld_small, qc2qi_collect_tend_small},
-        {t_not_freezing, rhofaci2, table_val_qi_fallspd2, acn2, lamc2, mu_c2, qc_incld_small, qc2qi_collect_tend_small},
+        {t_not_freezing, rhofaci1, table_val_qi_fallspd1, acn1, lamc1, mu_c1, qc_incld_small,
+         qc2qi_collect_tend_small},
+        {t_not_freezing, rhofaci2, table_val_qi_fallspd2, acn2, lamc2, mu_c2, qc_incld_small,
+         qc2qi_collect_tend_small},
 
         {t_not_freezing, rhofaci1, table_val_qi_fallspd1, acn1, lamc1, mu_c1, qc_incld_small,
          qc2qi_collect_tend_not_small},
@@ -69,14 +72,20 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCalcRimeDensity : public
         {t_not_freezing, rhofaci2, table_val_qi_fallspd2, acn2, lamc2, mu_c2, qc_incld_not_small,
          qc2qi_collect_tend_not_small},
 
-        {t_freezing, rhofaci1, table_val_qi_fallspd1, acn1, lamc1, mu_c1, qc_incld_small, qc2qi_collect_tend_small},
-        {t_freezing, rhofaci2, table_val_qi_fallspd2, acn2, lamc2, mu_c2, qc_incld_small, qc2qi_collect_tend_small},
+        {t_freezing, rhofaci1, table_val_qi_fallspd1, acn1, lamc1, mu_c1, qc_incld_small,
+         qc2qi_collect_tend_small},
+        {t_freezing, rhofaci2, table_val_qi_fallspd2, acn2, lamc2, mu_c2, qc_incld_small,
+         qc2qi_collect_tend_small},
 
-        {t_freezing, rhofaci1, table_val_qi_fallspd1, acn1, lamc1, mu_c1, qc_incld_small, qc2qi_collect_tend_not_small},
-        {t_freezing, rhofaci2, table_val_qi_fallspd2, acn2, lamc2, mu_c2, qc_incld_small, qc2qi_collect_tend_not_small},
+        {t_freezing, rhofaci1, table_val_qi_fallspd1, acn1, lamc1, mu_c1, qc_incld_small,
+         qc2qi_collect_tend_not_small},
+        {t_freezing, rhofaci2, table_val_qi_fallspd2, acn2, lamc2, mu_c2, qc_incld_small,
+         qc2qi_collect_tend_not_small},
 
-        {t_freezing, rhofaci1, table_val_qi_fallspd1, acn1, lamc1, mu_c1, qc_incld_not_small, qc2qi_collect_tend_small},
-        {t_freezing, rhofaci2, table_val_qi_fallspd2, acn2, lamc2, mu_c2, qc_incld_not_small, qc2qi_collect_tend_small},
+        {t_freezing, rhofaci1, table_val_qi_fallspd1, acn1, lamc1, mu_c1, qc_incld_not_small,
+         qc2qi_collect_tend_small},
+        {t_freezing, rhofaci2, table_val_qi_fallspd2, acn2, lamc2, mu_c2, qc_incld_not_small,
+         qc2qi_collect_tend_small},
 
         {t_freezing, rhofaci1, table_val_qi_fallspd1, acn1, lamc1, mu_c1, qc_incld_not_small,
          qc2qi_collect_tend_not_small},
@@ -87,7 +96,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCalcRimeDensity : public
     // Sync to device
     view_1d<CalcRimeDensityData> device_data("calc_rime_density", max_pack_size);
     const auto host_data = Kokkos::create_mirror_view(device_data);
-    std::copy(&calc_rime_density_data[0], &calc_rime_density_data[0] + max_pack_size, host_data.data());
+    std::copy(&calc_rime_density_data[0], &calc_rime_density_data[0] + max_pack_size,
+              host_data.data());
     Kokkos::deep_copy(device_data, host_data);
 
     // Read baseline data
@@ -118,8 +128,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCalcRimeDensity : public
           Spack vtrmi1{0.0};
           Spack rho_qm_cloud{0.0};
 
-          Functions::calc_rime_density(T_atm, rhofaci, table_val_qi_fallspd, acn, lamc, mu_c, qc_incld,
-                                       qc2qi_collect_tend, vtrmi1, rho_qm_cloud);
+          Functions::calc_rime_density(T_atm, rhofaci, table_val_qi_fallspd, acn, lamc, mu_c,
+                                       qc_incld, qc2qi_collect_tend, vtrmi1, rho_qm_cloud);
 
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
diff --git i/components/eamxx/src/physics/p3/tests/p3_check_values_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_check_values_unit_tests.cpp
index 2cdeb802b6..cc9fdb6348 100644
--- i/components/eamxx/src/physics/p3/tests/p3_check_values_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_check_values_unit_tests.cpp
@@ -18,7 +18,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestCheckValues : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestCheckValues : public UnitWrap::UnitTest<D>::Base {
 
   void run_check_values_bfb() {
     // This is not really a bfb test since no results are being checked.
@@ -38,7 +39,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCheckValues : public Uni
 
     // Get data from cxx
     for (auto &d : cvd_cxx) {
-      check_values_host(d.qv, d.temp, d.kts, d.kte, d.timestepcount, d.force_abort, d.source_ind, d.col_loc);
+      check_values_host(d.qv, d.temp, d.kts, d.kte, d.timestepcount, d.force_abort, d.source_ind,
+                        d.col_loc);
     }
   }
 
diff --git i/components/eamxx/src/physics/p3/tests/p3_cldliq_imm_freezing_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_cldliq_imm_freezing_unit_tests.cpp
index ad1d1294ff..8b262e8de4 100644
--- i/components/eamxx/src/physics/p3/tests/p3_cldliq_imm_freezing_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_cldliq_imm_freezing_unit_tests.cpp
@@ -17,7 +17,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestCldliqImmersionFreezing : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestCldliqImmersionFreezing : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys() {
     // TODO
@@ -61,7 +62,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCldliqImmersionFreezing
     // Sync to device
     view_1d<CldliqImmersionFreezingData> device_data("cldliq_imm_freezing", max_pack_size);
     const auto host_data = Kokkos::create_mirror_view(device_data);
-    std::copy(&cldliq_imm_freezing_data[0], &cldliq_imm_freezing_data[0] + max_pack_size, host_data.data());
+    std::copy(&cldliq_imm_freezing_data[0], &cldliq_imm_freezing_data[0] + max_pack_size,
+              host_data.data());
     Kokkos::deep_copy(device_data, host_data);
 
     // Read baseline data
@@ -107,8 +109,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCldliqImmersionFreezing
     // Validate results.
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
       for (Int s = 0; s < max_pack_size; ++s) {
-        REQUIRE(cldliq_imm_freezing_data[s].qc2qi_hetero_freeze_tend == host_data[s].qc2qi_hetero_freeze_tend);
-        REQUIRE(cldliq_imm_freezing_data[s].nc2ni_immers_freeze_tend == host_data[s].nc2ni_immers_freeze_tend);
+        REQUIRE(cldliq_imm_freezing_data[s].qc2qi_hetero_freeze_tend ==
+                host_data[s].qc2qi_hetero_freeze_tend);
+        REQUIRE(cldliq_imm_freezing_data[s].nc2ni_immers_freeze_tend ==
+                host_data[s].nc2ni_immers_freeze_tend);
       }
     } else if (this->m_baseline_action == GENERATE) {
       for (Int s = 0; s < max_pack_size; ++s) {
@@ -125,7 +129,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCldliqImmersionFreezing
 namespace {
 
 TEST_CASE("p3_cldliq_immersion_freezing", "[p3_functions]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCldliqImmersionFreezing;
+  using T =
+      scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCldliqImmersionFreezing;
 
   T t;
   t.run_phys();
diff --git i/components/eamxx/src/physics/p3/tests/p3_cloud_rain_acc_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_cloud_rain_acc_unit_tests.cpp
index efc3b4fed4..f704c02113 100644
--- i/components/eamxx/src/physics/p3/tests/p3_cloud_rain_acc_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_cloud_rain_acc_unit_tests.cpp
@@ -17,7 +17,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestCloudRainAccretion : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestCloudRainAccretion : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys() {
     // TODO
@@ -29,16 +30,19 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCloudRainAccretion : pub
     constexpr Scalar qsmall = C::QSMALL;
 
     constexpr Scalar rho1 = 4.056E-03, rho2 = 6.852E-02, rho3 = 8.852E-02, rho4 = 1.902E-01;
-    constexpr Scalar inv_rho1 = 1.0 / rho1, inv_rho2 = 1.0 / rho2, inv_rho3 = 1.0 / rho3, inv_rho4 = 1.0 / rho4;
+    constexpr Scalar inv_rho1 = 1.0 / rho1, inv_rho2 = 1.0 / rho2, inv_rho3 = 1.0 / rho3,
+                     inv_rho4           = 1.0 / rho4;
     constexpr Scalar qc_incld_small     = 0.9 * qsmall;
     constexpr Scalar qr_incld_small     = 0.9 * qsmall;
     constexpr Scalar qc_incld_not_small = 2.0 * qsmall;
     constexpr Scalar qr_incld_not_small = 2.0 * qsmall;
-    constexpr Scalar nc_incld1 = 9.952E+05, nc_incld2 = 9.952E+06, nc_incld3 = 1.734E+07, nc_incld4 = 9.952E+08;
+    constexpr Scalar nc_incld1 = 9.952E+05, nc_incld2 = 9.952E+06, nc_incld3 = 1.734E+07,
+                     nc_incld4         = 9.952E+08;
     constexpr Scalar inv_qc_relvar_val = 1;
 
     CloudRainAccretionData cloud_rain_acc_data[max_pack_size] = {
-        // rho, inv_rho, qc_incld, nc_incld, qr_incld, qc2qr_accret_tend, nc_accret_tend, inv_qc_relvar
+        // rho, inv_rho, qc_incld, nc_incld, qr_incld, qc2qr_accret_tend, nc_accret_tend,
+        // inv_qc_relvar
         {rho1, inv_rho1, qc_incld_small, nc_incld1, qr_incld_small, inv_qc_relvar_val},
         {rho2, inv_rho2, qc_incld_small, nc_incld2, qr_incld_small, inv_qc_relvar_val},
         {rho3, inv_rho3, qc_incld_small, nc_incld3, qr_incld_small, inv_qc_relvar_val},
@@ -91,8 +95,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCloudRainAccretion : pub
           Spack qc2qr_accret_tend{0.0};
           Spack nc_accret_tend{0.0};
 
-          Functions::cloud_rain_accretion(rho, inv_rho, qc_incld, nc_incld, qr_incld, inv_qc_relvar, qc2qr_accret_tend,
-                                          nc_accret_tend, p3::Functions<Real, DefaultDevice>::P3Runtime());
+          Functions::cloud_rain_accretion(rho, inv_rho, qc_incld, nc_incld, qr_incld, inv_qc_relvar,
+                                          qc2qr_accret_tend, nc_accret_tend,
+                                          p3::Functions<Real, DefaultDevice>::P3Runtime());
 
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
@@ -125,7 +130,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCloudRainAccretion : pub
 namespace {
 
 TEST_CASE("p3_cloud_rain_accretion", "[p3_functions]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCloudRainAccretion;
+  using T =
+      scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCloudRainAccretion;
 
   T t;
   t.run_phys();
diff --git i/components/eamxx/src/physics/p3/tests/p3_cloud_sed_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_cloud_sed_unit_tests.cpp
index 418574e43d..9b3df70b20 100644
--- i/components/eamxx/src/physics/p3/tests/p3_cloud_sed_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_cloud_sed_unit_tests.cpp
@@ -17,7 +17,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestCloudSed : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestCloudSed : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys() {
     // TODO
@@ -27,7 +28,7 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCloudSed : public UnitWr
     auto engine = Base::get_engine();
 
     CloudSedData csds_baseline[] = {
-        //         kts, kte, ktop, kbot, kdir,        dt,    inv_dt, do_predict_nc,     precip_liq_surf,
+        //         kts, kte, ktop, kbot, kdir,        dt,    inv_dt, do_predict_nc, precip_liq_surf,
         CloudSedData(1, 72, 27, 72, -1, 1.800E+03, 5.556E-04, false, 0.0),
         CloudSedData(1, 72, 72, 27, 1, 1.800E+03, 5.556E-04, false, 0.0),
         CloudSedData(1, 72, 27, 72, -1, 1.800E+03, 5.556E-04, true, 0.0),
@@ -45,8 +46,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCloudSed : public UnitWr
     // Create copies of data for use by cxx. Needs to happen before reads so that
     // inout data is in original state
     CloudSedData csds_cxx[num_runs] = {
-        CloudSedData(csds_baseline[0]), CloudSedData(csds_baseline[1]), CloudSedData(csds_baseline[2]),
-        CloudSedData(csds_baseline[3]), CloudSedData(csds_baseline[4]),
+        CloudSedData(csds_baseline[0]), CloudSedData(csds_baseline[1]),
+        CloudSedData(csds_baseline[2]), CloudSedData(csds_baseline[3]),
+        CloudSedData(csds_baseline[4]),
     };
 
     // Read baseline data
@@ -58,9 +60,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCloudSed : public UnitWr
 
     // Get data from cxx
     for (auto &d : csds_cxx) {
-      cloud_sedimentation_host(d.kts, d.kte, d.ktop, d.kbot, d.kdir, d.qc_incld, d.rho, d.inv_rho, d.cld_frac_l, d.acn,
-                               d.inv_dz, d.dt, d.inv_dt, d.do_predict_nc, d.qc, d.nc, d.nc_incld, d.mu_c, d.lamc,
-                               &d.precip_liq_surf, d.qc_tend, d.nc_tend);
+      cloud_sedimentation_host(d.kts, d.kte, d.ktop, d.kbot, d.kdir, d.qc_incld, d.rho, d.inv_rho,
+                               d.cld_frac_l, d.acn, d.inv_dz, d.dt, d.inv_dt, d.do_predict_nc, d.qc,
+                               d.nc, d.nc_incld, d.mu_c, d.lamc, &d.precip_liq_surf, d.qc_tend,
+                               d.nc_tend);
     }
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
diff --git i/components/eamxx/src/physics/p3/tests/p3_droplet_self_coll_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_droplet_self_coll_unit_tests.cpp
index 7ce41375e8..110bd01c8a 100644
--- i/components/eamxx/src/physics/p3/tests/p3_droplet_self_coll_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_droplet_self_coll_unit_tests.cpp
@@ -17,7 +17,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestDropletSelfCollection : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestDropletSelfCollection : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys() {
     // TODO
@@ -29,12 +30,14 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestDropletSelfCollection :
     constexpr Scalar qsmall = C::QSMALL;
 
     constexpr Scalar rho1 = 4.056E-03, rho2 = 6.852E-02, rho3 = 8.852E-02, rho4 = 1.902E-01;
-    constexpr Scalar inv_rho1 = 1.0 / rho1, inv_rho2 = 1.0 / rho2, inv_rho3 = 1.0 / rho3, inv_rho4 = 1.0 / rho4;
+    constexpr Scalar inv_rho1 = 1.0 / rho1, inv_rho2 = 1.0 / rho2, inv_rho3 = 1.0 / rho3,
+                     inv_rho4           = 1.0 / rho4;
     constexpr Scalar qc_incld_small     = 0.9 * qsmall;
     constexpr Scalar qr_incld_small     = 0.9 * qsmall;
     constexpr Scalar qc_incld_not_small = 2.0 * qsmall;
     constexpr Scalar qr_incld_not_small = 2.0 * qsmall;
-    constexpr Scalar nc_incld1 = 9.952E+05, nc_incld2 = 9.952E+06, nc_incld3 = 1.734E+07, nc_incld4 = 9.952E+08;
+    constexpr Scalar nc_incld1 = 9.952E+05, nc_incld2 = 9.952E+06, nc_incld3 = 1.734E+07,
+                     nc_incld4 = 9.952E+08;
 
     DropletSelfCollectionData droplet_self_coll_data[max_pack_size] = {
         // rho, inv_rho, qc_incld, mu_c, nu, nc2nr_autoconv_tend, nc_selfcollect_tend
@@ -61,7 +64,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestDropletSelfCollection :
     // Sync to device
     view_1d<DropletSelfCollectionData> device_data("droplet_self_coll", max_pack_size);
     const auto host_data = Kokkos::create_mirror_view(device_data);
-    std::copy(&droplet_self_coll_data[0], &droplet_self_coll_data[0] + max_pack_size, host_data.data());
+    std::copy(&droplet_self_coll_data[0], &droplet_self_coll_data[0] + max_pack_size,
+              host_data.data());
     Kokkos::deep_copy(device_data, host_data);
 
     // Read baseline data
@@ -121,7 +125,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestDropletSelfCollection :
 namespace {
 
 TEST_CASE("p3_droplet_self_collection", "[p3_functions]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDropletSelfCollection;
+  using T =
+      scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDropletSelfCollection;
 
   T t;
   t.run_phys();
diff --git i/components/eamxx/src/physics/p3/tests/p3_dsd2_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_dsd2_unit_tests.cpp
index d1dff015bd..0656c60a09 100644
--- i/components/eamxx/src/physics/p3/tests/p3_dsd2_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_dsd2_unit_tests.cpp
@@ -30,7 +30,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestDsd2 : public UnitWrap::
     view_2d_table revap_table_vals;
     view_1d_table mu_r_table_vals;
     view_dnu_table dnu;
-    Functions::get_global_tables(vn_table_vals, vm_table_vals, revap_table_vals, mu_r_table_vals, dnu);
+    Functions::get_global_tables(vn_table_vals, vm_table_vals, revap_table_vals, mu_r_table_vals,
+                                 dnu);
 
     // Load some lookup inputs, need at least one per pack value
     GetCloudDsd2Data gcdd[max_pack_size] = {
@@ -113,17 +114,18 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestDsd2 : public UnitWrap::
   void run_rain_bfb() {
     using KTH = KokkosTypes<HostDevice>;
 
-    GetRainDsd2Data grdd[max_pack_size] = {{0.100000E-01, 0.100000E+01}, {0.100000E-01, 0.100000E+01},
-                                           {0.156316E-03, 0.100000E+01}, {0.148647E-03, 0.100000E+01},
+    GetRainDsd2Data grdd[max_pack_size] = {
+        {0.100000E-01, 0.100000E+01}, {0.100000E-01, 0.100000E+01},
+        {0.156316E-03, 0.100000E+01}, {0.148647E-03, 0.100000E+01},
 
-                                           {0.100000E-01, 0.100000E+01}, {0.0, 0.100000E+01},
-                                           {0.156316E-03, 0.100000E+01}, {0.0, 0.100000E+01},
+        {0.100000E-01, 0.100000E+01}, {0.0, 0.100000E+01},
+        {0.156316E-03, 0.100000E+01}, {0.0, 0.100000E+01},
 
-                                           {0.100000E-01, 0.100000E+01}, {0.100000E-01, 0.100000E+01},
-                                           {0.156316E-03, 0.100000E+01}, {0.148647E-03, 0.100000E+01},
+        {0.100000E-01, 0.100000E+01}, {0.100000E-01, 0.100000E+01},
+        {0.156316E-03, 0.100000E+01}, {0.148647E-03, 0.100000E+01},
 
-                                           {0.100000E-01, 0.100000E+01}, {0.100000E-01, 0.100000E+01},
-                                           {0.156316E-03, 0.100000E+01}, {0.148647E-03, 0.100000E+01}};
+        {0.100000E-01, 0.100000E+01}, {0.100000E-01, 0.100000E+01},
+        {0.156316E-03, 0.100000E+01}, {0.148647E-03, 0.100000E+01}};
 
     // Sync to device
     KTH::view_1d<GetRainDsd2Data> grdd_host("grdd_host", max_pack_size);
@@ -151,7 +153,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestDsd2 : public UnitWrap::
           }
 
           Spack mu_r(0.0), lamr(0.0), cdistr(0.0), logn0r(0.0);
-          Functions::get_rain_dsd2(qr, nr, mu_r, lamr, p3::Functions<Real, DefaultDevice>::P3Runtime());
+          Functions::get_rain_dsd2(qr, nr, mu_r, lamr,
+                                   p3::Functions<Real, DefaultDevice>::P3Runtime());
           Functions::get_cdistr_logn0r(qr, nr, mu_r, lamr, cdistr, logn0r);
 
           // Copy results back into views
diff --git i/components/eamxx/src/physics/p3/tests/p3_evaporate_rain_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_evaporate_rain_unit_tests.cpp
index e4bf9d1271..cfd13251d2 100644
--- i/components/eamxx/src/physics/p3/tests/p3_evaporate_rain_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_evaporate_rain_unit_tests.cpp
@@ -12,7 +12,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestEvapSublPrecip : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestEvapSublPrecip : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
 
@@ -82,22 +83,24 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestEvapSublPrecip : public
     // if qr_incld is too small, evap rate should be zero.
     constexpr Scalar QSMALL = C::QSMALL;
     Functions::evaporate_rain(Spack(QSMALL / 2), qc_incld, nr_incld, qi_incld, // qr_incld->QSMALL/2
-                              cld_frac_l, cld_frac_r, qv, qv_prev, qv_sat_l, qv_sat_i, ab, abi, epsr, epsi_tot, t,
-                              t_prev, dqsdt, dt, qrtend, nrtend);
+                              cld_frac_l, cld_frac_r, qv, qv_prev, qv_sat_l, qv_sat_i, ab, abi,
+                              epsr, epsi_tot, t, t_prev, dqsdt, dt, qrtend, nrtend);
     REQUIRE(std::abs(qrtend[0]) < 1e-8);
     REQUIRE(std::abs(nrtend[0]) < 1e-8);
 
     // if qr_incld is small enough but not too small, evap rate should be qr_incld/dt.
     Spack qr_tiny = Spack(5e-13);
     Functions::evaporate_rain(qr_tiny, qc_incld, nr_incld, qi_incld, // qr_incld->_tiny
-                              cld_frac_l, cld_frac_r, qv, qv_prev, qv_sat_l, qv_sat_i, ab, abi, epsr, epsi_tot, t,
-                              t_prev, dqsdt, dt, qrtend, nrtend);
-    REQUIRE(std::abs(qrtend[0] - qr_tiny[0] / dt * (cld_frac_r[0] - cld_frac_l[0]) / cld_frac_r[0]) < 1e-8);
+                              cld_frac_l, cld_frac_r, qv, qv_prev, qv_sat_l, qv_sat_i, ab, abi,
+                              epsr, epsi_tot, t, t_prev, dqsdt, dt, qrtend, nrtend);
+    REQUIRE(std::abs(qrtend[0] -
+                     qr_tiny[0] / dt * (cld_frac_r[0] - cld_frac_l[0]) / cld_frac_r[0]) < 1e-8);
     REQUIRE(std::abs(nrtend[0] - qrtend[0] * nr_incld[0] / qr_tiny[0]) < 1e-8); // always true
     REQUIRE(nrtend[0] <= nr_incld[0] / dt); // keep end-of-step nr positive. Should always be true.
 
     // if no rainy areas outside cloud, don't evap
-    Functions::evaporate_rain(qr_incld, qc_incld, nr_incld, qi_incld, cld_frac_r, cld_frac_r, qv, qv_prev, qv_sat_l,
+    Functions::evaporate_rain(qr_incld, qc_incld, nr_incld, qi_incld, cld_frac_r, cld_frac_r, qv,
+                              qv_prev, qv_sat_l,
                               qv_sat_i, // cld_frac_l->_r
                               ab, abi, epsr, epsi_tot, t, t_prev, dqsdt, dt, qrtend, nrtend);
     REQUIRE(std::abs(qrtend[0]) < 1e-8);
@@ -106,16 +109,16 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestEvapSublPrecip : public
     // no evap if supersaturated
     Functions::evaporate_rain(qr_incld, qc_incld, nr_incld, qi_incld,
                               // set qv->qv_sat_l*2 in next line to ensure supersaturated.
-                              cld_frac_l, cld_frac_r, qv_sat_l * 2, qv_prev, qv_sat_l, qv_sat_i, ab, abi, epsr,
-                              epsi_tot, t, t_prev, dqsdt, dt, qrtend, nrtend);
+                              cld_frac_l, cld_frac_r, qv_sat_l * 2, qv_prev, qv_sat_l, qv_sat_i, ab,
+                              abi, epsr, epsi_tot, t, t_prev, dqsdt, dt, qrtend, nrtend);
     REQUIRE(std::abs(qrtend[0]) < 1e-8);
     REQUIRE(std::abs(nrtend[0]) < 1e-8);
 
     // for case with lots of evap, make sure doesn't overdeplete qr_incld
     Functions::evaporate_rain(qr_incld, qc_incld, nr_incld, qi_incld,
                               // qv -> qv*0.1 to encourage lots of rain evap
-                              cld_frac_l, cld_frac_r, qv * 0.1, qv_prev, qv_sat_l, qv_sat_i, ab, abi, epsr, epsi_tot, t,
-                              t_prev, dqsdt, dt, qrtend, nrtend);
+                              cld_frac_l, cld_frac_r, qv * 0.1, qv_prev, qv_sat_l, qv_sat_i, ab,
+                              abi, epsr, epsi_tot, t, t_prev, dqsdt, dt, qrtend, nrtend);
     REQUIRE(qrtend[0] <= qr_incld[0] / dt);
     REQUIRE(nrtend[0] <= nr_incld[0] / dt); // keep end-of-step nr positive. Should always be true.
 
@@ -126,68 +129,84 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestEvapSublPrecip : public
     constexpr Scalar latice = C::LatIce;
 
     // baseline generated data is input to the following
-    // This subroutine has 20 args, only 18 are supplied here for invoking it as last 2 are intent-outs
-    // note that dt is the same val for each row - this is needed since dt is a scalar and all rows are executed
-    // simultaneously on CPU in C++. row1: above freezing, should trigger row2: below freezing, should trigger but
-    // qr_incld small enough to evap all row3: supersaturated, shouldn't trigger row4: below freezing, should trigger
-    // row5: below freezing, should trigger
-    // row6: cld frac > rain area frac. shouldn't trigger.
-    // row7: qr_incld=0. shouldn't trigger.
-    // row8: above freezing, should trigger.
-    // rows 9-16: random junk but ensured cld_frac_r>cld_frac_l and subsaturated.
+    // This subroutine has 20 args, only 18 are supplied here for invoking it as last 2 are
+    // intent-outs note that dt is the same val for each row - this is needed since dt is a scalar
+    // and all rows are executed simultaneously on CPU in C++. row1: above freezing, should trigger
+    // row2: below freezing, should trigger but qr_incld small enough to evap all row3:
+    // supersaturated, shouldn't trigger row4: below freezing, should trigger row5: below freezing,
+    // should trigger row6: cld frac > rain area frac. shouldn't trigger. row7: qr_incld=0.
+    // shouldn't trigger. row8: above freezing, should trigger. rows 9-16: random junk but ensured
+    // cld_frac_r>cld_frac_l and subsaturated.
     EvapRainData espd[max_pack_size] = {
-        // qr_incld,     qc_incld,    nr_incld,    qi_incld,    cld_frac_l,  cld_frac_r,  qv,          qv_prev,
-        // qv_sat_l,    qv_sat_i,    ab,          abi,         epsr,        epsi_tot,    t,           t_prev,
+        // qr_incld,     qc_incld,    nr_incld,    qi_incld,    cld_frac_l,  cld_frac_r,  qv,
+        // qv_prev,
+        // qv_sat_l,    qv_sat_i,    ab,          abi,         epsr,        epsi_tot,    t, t_prev,
         // lat_ht_sublim, dqsdt,     dt
-        {4.634940e-03, 1.215335e-03, 6.073270e+07, 3.594486e-04, 6.134229e-01, 9.134229e-01, 2.747871e-03, 1.911238e-03,
-         5.913313e-03, 1.057645e-03, 1.782748e+00, 1.571392e+00, 3.868229e+02, 2.248689e+02, 3.101180e+02, 1.395063e+02,
-         latvap + latice, 5.494606e-03, 6.000000e+02},
-        {6.175320e-13, 4.432407e-03, 8.029967e+07, 1.905151e-03, 2.190099e-01, 7.031070e-01, 4.172977e-05, 7.315360e-03,
-         7.280063e-03, 1.378543e-03, 1.461443e+00, 1.507382e+00, 8.452377e+02, 1.971876e+02, 2.389249e+02, 1.497752e+02,
-         latvap + latice, 5.107905e-03, 6.000000e+02},
-        {4.519798e-03, 7.348916e-03, 7.420725e+07, 2.220971e-03, 1.882608e-01, 2.934182e-01, 4.957590e-03, 2.550256e-03,
-         3.136926e-03, 4.498115e-03, 1.433526e+00, 1.207516e+00, 9.716844e+02, 5.602546e+01, 1.389465e+02, 1.075863e+02,
-         latvap + latice, 6.771428e-03, 6.000000e+02},
-        {7.169182e-03, 6.657331e-03, 9.807967e+07, 7.981196e-03, 2.914473e-01, 6.375719e-01, 2.420032e-03, 1.223012e-03,
-         7.685516e-03, 5.207024e-03, 1.644865e+00, 1.433872e+00, 3.825069e+02, 6.550300e+02, 1.833466e+02, 1.741918e+02,
-         latvap + latice, 3.792982e-03, 6.000000e+02},
-        {1.103118e-03, 9.158125e-03, 3.136196e+07, 4.286154e-03, 2.699078e-01, 4.668103e-01, 9.645460e-03, 6.379119e-03,
-         8.283285e-03, 3.342400e-03, 1.546698e+00, 1.417916e+00, 9.289270e+02, 9.844129e+02, 2.543202e+02, 1.932996e+02,
-         latvap + latice, 2.693119e-03, 6.000000e+02},
-        {4.308000e-03, 8.168535e-03, 7.439969e+07, 5.131497e-03, 6.851225e-01, 3.298025e-01, 4.331812e-03, 2.814373e-03,
-         3.592807e-03, 1.527499e-03, 1.856943e+00, 1.003269e+00, 9.165690e+02, 9.379921e+02, 2.163204e+02, 3.165814e+02,
-         latvap + latice, 6.801393e-03, 6.000000e+02},
-        {0.000000e-00, 3.318968e-03, 4.664041e+07, 8.737282e-03, 2.585907e-01, 6.297295e-02, 8.747418e-03, 2.710437e-03,
-         2.164895e-03, 9.455725e-03, 1.241506e+00, 1.561393e+00, 2.492674e+02, 6.546182e+02, 2.228772e+02, 2.147968e+02,
-         latvap + latice, 5.903261e-03, 6.000000e+02},
-        {7.677170e-03, 6.069057e-05, 6.404241e+07, 3.094233e-03, 3.755403e-01, 5.026876e-01, 4.723817e-03, 1.204228e-03,
-         6.156526e-03, 8.194797e-03, 1.361509e+00, 1.772751e+00, 6.420537e+01, 4.043364e+02, 2.833110e+02, 3.314521e+02,
-         latvap + latice, 2.996696e-03, 6.000000e+02},
+        {4.634940e-03, 1.215335e-03, 6.073270e+07, 3.594486e-04, 6.134229e-01, 9.134229e-01,
+         2.747871e-03, 1.911238e-03, 5.913313e-03, 1.057645e-03, 1.782748e+00, 1.571392e+00,
+         3.868229e+02, 2.248689e+02, 3.101180e+02, 1.395063e+02, latvap + latice, 5.494606e-03,
+         6.000000e+02},
+        {6.175320e-13, 4.432407e-03, 8.029967e+07, 1.905151e-03, 2.190099e-01, 7.031070e-01,
+         4.172977e-05, 7.315360e-03, 7.280063e-03, 1.378543e-03, 1.461443e+00, 1.507382e+00,
+         8.452377e+02, 1.971876e+02, 2.389249e+02, 1.497752e+02, latvap + latice, 5.107905e-03,
+         6.000000e+02},
+        {4.519798e-03, 7.348916e-03, 7.420725e+07, 2.220971e-03, 1.882608e-01, 2.934182e-01,
+         4.957590e-03, 2.550256e-03, 3.136926e-03, 4.498115e-03, 1.433526e+00, 1.207516e+00,
+         9.716844e+02, 5.602546e+01, 1.389465e+02, 1.075863e+02, latvap + latice, 6.771428e-03,
+         6.000000e+02},
+        {7.169182e-03, 6.657331e-03, 9.807967e+07, 7.981196e-03, 2.914473e-01, 6.375719e-01,
+         2.420032e-03, 1.223012e-03, 7.685516e-03, 5.207024e-03, 1.644865e+00, 1.433872e+00,
+         3.825069e+02, 6.550300e+02, 1.833466e+02, 1.741918e+02, latvap + latice, 3.792982e-03,
+         6.000000e+02},
+        {1.103118e-03, 9.158125e-03, 3.136196e+07, 4.286154e-03, 2.699078e-01, 4.668103e-01,
+         9.645460e-03, 6.379119e-03, 8.283285e-03, 3.342400e-03, 1.546698e+00, 1.417916e+00,
+         9.289270e+02, 9.844129e+02, 2.543202e+02, 1.932996e+02, latvap + latice, 2.693119e-03,
+         6.000000e+02},
+        {4.308000e-03, 8.168535e-03, 7.439969e+07, 5.131497e-03, 6.851225e-01, 3.298025e-01,
+         4.331812e-03, 2.814373e-03, 3.592807e-03, 1.527499e-03, 1.856943e+00, 1.003269e+00,
+         9.165690e+02, 9.379921e+02, 2.163204e+02, 3.165814e+02, latvap + latice, 6.801393e-03,
+         6.000000e+02},
+        {0.000000e-00, 3.318968e-03, 4.664041e+07, 8.737282e-03, 2.585907e-01, 6.297295e-02,
+         8.747418e-03, 2.710437e-03, 2.164895e-03, 9.455725e-03, 1.241506e+00, 1.561393e+00,
+         2.492674e+02, 6.546182e+02, 2.228772e+02, 2.147968e+02, latvap + latice, 5.903261e-03,
+         6.000000e+02},
+        {7.677170e-03, 6.069057e-05, 6.404241e+07, 3.094233e-03, 3.755403e-01, 5.026876e-01,
+         4.723817e-03, 1.204228e-03, 6.156526e-03, 8.194797e-03, 1.361509e+00, 1.772751e+00,
+         6.420537e+01, 4.043364e+02, 2.833110e+02, 3.314521e+02, latvap + latice, 2.996696e-03,
+         6.000000e+02},
 
-        {9.999294e-03, 3.138400e-03, 2.355097e+07, 9.897893e-03, 7.667177e-01, 9.739270e-01, 4.221430e-03, 3.570130e-03,
-         8.370033e-03, 9.527208e-03, 1.597218e+00, 1.111438e+00, 7.832357e+02, 8.364566e+02, 2.854867e+02, 2.340771e+02,
-         latvap + latice, 7.235757e-03, 6.000000e+02},
-        {8.841793e-03, 3.530456e-03, 9.618284e+07, 9.311658e-03, 3.458590e-01, 6.978258e-01, 1.279864e-03, 4.652008e-03,
-         1.869728e-03, 8.931663e-03, 1.712564e+00, 1.223882e+00, 9.692403e+02, 2.358558e+02, 3.204043e+02, 1.827677e+02,
-         latvap + latice, 7.646405e-03, 6.000000e+02},
-        {1.425612e-03, 6.653411e-04, 2.843806e+07, 1.922560e-03, 9.100262e-01, 0.996264e-01, 8.973183e-04, 9.857420e-03,
-         6.221419e-03, 8.133433e-03, 1.815337e+00, 1.885506e+00, 5.508742e+02, 1.612139e+02, 2.798523e+02, 2.631136e+02,
-         latvap + latice, 4.148666e-03, 6.000000e+02},
-        {4.125177e-04, 4.056163e-03, 2.716439e+07, 6.484214e-03, 1.658752e-01, 2.859102e-01, 5.724081e-03, 6.282997e-03,
-         7.313187e-03, 6.049825e-03, 1.140910e+00, 1.145941e+00, 7.490652e+02, 5.011633e+02, 1.986541e+02, 2.745566e+02,
-         latvap + latice, 6.784784e-03, 6.000000e+02},
-        {5.010628e-03, 2.863789e-04, 8.953841e+07, 3.953058e-03, 1.135952e-01, 9.718675e-01, 1.846157e-03, 5.743094e-03,
-         2.842649e-03, 8.155366e-03, 1.227867e+00, 1.894249e+00, 1.161776e+02, 3.578576e+02, 1.240083e+02, 1.639791e+02,
-         latvap + latice, 4.497257e-03, 6.000000e+02},
-        {9.487866e-03, 6.584660e-03, 6.149682e+06, 9.413342e-03, 4.757261e-01, 6.503885e-01, 1.078922e-03, 3.489665e-03,
-         3.059596e-03, 9.285703e-03, 1.192620e+00, 1.967205e+00, 5.085628e+02, 3.741816e+01, 1.196252e+02, 2.904002e+02,
-         latvap + latice, 2.566077e-03, 6.000000e+02},
-        {3.241928e-03, 7.024929e-03, 2.212493e+07, 8.600485e-03, 3.963690e-01, 4.834201e-01, 3.736511e-03, 5.724475e-03,
-         4.790239e-03, 2.766218e-03, 1.151150e+00, 1.150516e+00, 2.089426e+02, 8.666450e+02, 1.898220e+02, 2.862496e+02,
-         latvap + latice, 7.039800e-03, 6.000000e+02},
-        {4.617594e-03, 3.157739e-03, 5.569465e+07, 8.221076e-03, 7.918279e-01, 9.995014e-01, 1.338309e-04, 1.319707e-03,
-         2.896082e-03, 4.359171e-03, 1.007827e+00, 1.812954e+00, 5.332209e+02, 2.973599e+02, 3.271466e+02, 2.622351e+02,
-         latvap + latice, 1.407429e-03, 6.000000e+02}};
+        {9.999294e-03, 3.138400e-03, 2.355097e+07, 9.897893e-03, 7.667177e-01, 9.739270e-01,
+         4.221430e-03, 3.570130e-03, 8.370033e-03, 9.527208e-03, 1.597218e+00, 1.111438e+00,
+         7.832357e+02, 8.364566e+02, 2.854867e+02, 2.340771e+02, latvap + latice, 7.235757e-03,
+         6.000000e+02},
+        {8.841793e-03, 3.530456e-03, 9.618284e+07, 9.311658e-03, 3.458590e-01, 6.978258e-01,
+         1.279864e-03, 4.652008e-03, 1.869728e-03, 8.931663e-03, 1.712564e+00, 1.223882e+00,
+         9.692403e+02, 2.358558e+02, 3.204043e+02, 1.827677e+02, latvap + latice, 7.646405e-03,
+         6.000000e+02},
+        {1.425612e-03, 6.653411e-04, 2.843806e+07, 1.922560e-03, 9.100262e-01, 0.996264e-01,
+         8.973183e-04, 9.857420e-03, 6.221419e-03, 8.133433e-03, 1.815337e+00, 1.885506e+00,
+         5.508742e+02, 1.612139e+02, 2.798523e+02, 2.631136e+02, latvap + latice, 4.148666e-03,
+         6.000000e+02},
+        {4.125177e-04, 4.056163e-03, 2.716439e+07, 6.484214e-03, 1.658752e-01, 2.859102e-01,
+         5.724081e-03, 6.282997e-03, 7.313187e-03, 6.049825e-03, 1.140910e+00, 1.145941e+00,
+         7.490652e+02, 5.011633e+02, 1.986541e+02, 2.745566e+02, latvap + latice, 6.784784e-03,
+         6.000000e+02},
+        {5.010628e-03, 2.863789e-04, 8.953841e+07, 3.953058e-03, 1.135952e-01, 9.718675e-01,
+         1.846157e-03, 5.743094e-03, 2.842649e-03, 8.155366e-03, 1.227867e+00, 1.894249e+00,
+         1.161776e+02, 3.578576e+02, 1.240083e+02, 1.639791e+02, latvap + latice, 4.497257e-03,
+         6.000000e+02},
+        {9.487866e-03, 6.584660e-03, 6.149682e+06, 9.413342e-03, 4.757261e-01, 6.503885e-01,
+         1.078922e-03, 3.489665e-03, 3.059596e-03, 9.285703e-03, 1.192620e+00, 1.967205e+00,
+         5.085628e+02, 3.741816e+01, 1.196252e+02, 2.904002e+02, latvap + latice, 2.566077e-03,
+         6.000000e+02},
+        {3.241928e-03, 7.024929e-03, 2.212493e+07, 8.600485e-03, 3.963690e-01, 4.834201e-01,
+         3.736511e-03, 5.724475e-03, 4.790239e-03, 2.766218e-03, 1.151150e+00, 1.150516e+00,
+         2.089426e+02, 8.666450e+02, 1.898220e+02, 2.862496e+02, latvap + latice, 7.039800e-03,
+         6.000000e+02},
+        {4.617594e-03, 3.157739e-03, 5.569465e+07, 8.221076e-03, 7.918279e-01, 9.995014e-01,
+         1.338309e-04, 1.319707e-03, 2.896082e-03, 4.359171e-03, 1.007827e+00, 1.812954e+00,
+         5.332209e+02, 2.973599e+02, 3.271466e+02, 2.622351e+02, latvap + latice, 1.407429e-03,
+         6.000000e+02}};
 
     // Sync to device
     view_1d<EvapRainData> espd_device("espd", max_pack_size);
@@ -210,8 +229,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestEvapSublPrecip : public
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack qr_incld, qc_incld, nr_incld, qi_incld, cld_frac_l, cld_frac_r, qv, qv_prev, qv_sat_l, qv_sat_i, ab,
-              abi, epsr, epsi_tot, t, t_prev, dqsdt;
+          Spack qr_incld, qc_incld, nr_incld, qi_incld, cld_frac_l, cld_frac_r, qv, qv_prev,
+              qv_sat_l, qv_sat_i, ab, abi, epsr, epsi_tot, t, t_prev, dqsdt;
 
           Scalar dt;
 
@@ -237,13 +256,13 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestEvapSublPrecip : public
             t_prev[s]     = espd_device(vs).t_prev;
             dqsdt[s]      = espd_device(vs).dqsdt;
             dt            = espd_device(vs).dt;
-            // qr2qv_evap_tend[s]       = espd_device(vs).qr2qv_evap_tend; //PMC shouldn't have to init output vars.
-            // nr_evap_tend[s]       = espd_device(vs).nr_evap_tend;
+            // qr2qv_evap_tend[s]       = espd_device(vs).qr2qv_evap_tend; //PMC shouldn't have to
+            // init output vars. nr_evap_tend[s]       = espd_device(vs).nr_evap_tend;
           }
 
-          Functions::evaporate_rain(qr_incld, qc_incld, nr_incld, qi_incld, cld_frac_l, cld_frac_r, qv, qv_prev,
-                                    qv_sat_l, qv_sat_i, ab, abi, epsr, epsi_tot, t, t_prev, dqsdt, dt, qr2qv_evap_tend,
-                                    nr_evap_tend);
+          Functions::evaporate_rain(qr_incld, qc_incld, nr_incld, qi_incld, cld_frac_l, cld_frac_r,
+                                    qv, qv_prev, qv_sat_l, qv_sat_i, ab, abi, epsr, epsi_tot, t,
+                                    t_prev, dqsdt, dt, qr2qv_evap_tend, nr_evap_tend);
 
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
diff --git i/components/eamxx/src/physics/p3/tests/p3_find_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_find_unit_tests.cpp
index 2a87fb6796..c33681d46d 100644
--- i/components/eamxx/src/physics/p3/tests/p3_find_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_find_unit_tests.cpp
@@ -56,7 +56,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestFind : public UnitWrap::
     Kokkos::deep_copy(qr_not_present, mirror_qrnp);
 
     for (int team_size : {1, max_threads}) {
-      const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_team_policy_force_team_size(1, team_size);
+      const auto policy =
+          ekat::ExeSpaceUtils<ExeSpace>::get_team_policy_force_team_size(1, team_size);
 
       int errs_for_this_ts = 0;
       Kokkos::parallel_reduce(
diff --git i/components/eamxx/src/physics/p3/tests/p3_ice_cldliq_wet_growth_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_ice_cldliq_wet_growth_unit_tests.cpp
index be51c0d1fd..f2f4b6716e 100644
--- i/components/eamxx/src/physics/p3/tests/p3_ice_cldliq_wet_growth_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_ice_cldliq_wet_growth_unit_tests.cpp
@@ -18,7 +18,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestIceCldliqWetGrowth : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestIceCldliqWetGrowth : public UnitWrap::UnitTest<D>::Base {
 
   void run_ice_cldliq_wet_growth_bfb() {
     using KTH = KokkosTypes<HostDevice>;
@@ -28,57 +29,73 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCldliqWetGrowth : pub
 
     IceWetGrowthData self[max_pack_size] = {
         // rho,temp,pres,rhofaci,table_val_qi2qr_melting,table_val_qi2qr_vent_melt,latent_heat_vapor,latent_heat_fusion,dv,kap,mu,sc,qv,qc_incld,qi_incld,ni_incld,qr_incld,log_wetgrowth,qr2qi_collect_tend,qc2qi_collect_tend,qc_growth_rate,nr_ice_shed_tend,qc2qr_ice_shed_tend
-        {4.056000E-03, 1.023000E+02, 1.201000E+02, 9.002000E-04, 8.215000E-04, 8.852000E-01, latvap,       latice,
-         5.100000E-03, 9.558000E-04, 1.213000E-03, 9.653000E-04, 1.023000E-01, 4.098000E-02, 2.098000E-02, 9.952000E+03,
-         1.023000E-05, false,        1.241456E-04, 9.021345E-02, 1.043000E-01, 1.921000E-02, 0.242000E-02},
-        {6.852000E-02, 1.120000E+02, 2.450000E+02, 9.321000E-04, 9.124000E-04, 8.852000E-01, latvap,       latice,
-         4.100000E-03, 9.558000E-04, 2.560000E-03, 1.764000E-03, 2.346000E-01, 5.632000E-02, 3.024000E-02, 9.952000E+03,
-         2.093000E-05, false,        2.341678E-04, 1.092432E-02, 2.903000E-01, 2.125000E-02, 0.342000E-02},
-        {8.852000E-02, 1.210000E+02, 3.420000E+02, 9.623000E-04, 9.432000E-04, 8.900000E-01, latvap,       latice,
-         3.100000E-03, 9.558000E-04, 3.211000E-03, 3.421000E-03, 3.421000E-01, 6.542000E-02, 4.567000E-02, 9.952000E+03,
-         3.091000E-05, false,        3.215234E-04, 2.098987E-02, 3.450000E-01, 3.490000E-02, 0.932000E-02},
-        {1.902000E-01, 1.326000E+02, 4.321000E+02, 9.982000E-04, 9.623000E-04, 9.900000E-01, latvap,       latice,
-         2.100000E-03, 9.558000E-04, 4.121000E-03, 4.569000E-03, 4.673000E-01, 7.902000E-02, 5.321000E-02, 9.952000E+03,
-         4.521000E-05, false,        4.675567E-04, 3.214982E-02, 4.290000E-01, 4.590000E-02, 1.025000E-01},
+        {4.056000E-03, 1.023000E+02, 1.201000E+02, 9.002000E-04, 8.215000E-04, 8.852000E-01,
+         latvap,       latice,       5.100000E-03, 9.558000E-04, 1.213000E-03, 9.653000E-04,
+         1.023000E-01, 4.098000E-02, 2.098000E-02, 9.952000E+03, 1.023000E-05, false,
+         1.241456E-04, 9.021345E-02, 1.043000E-01, 1.921000E-02, 0.242000E-02},
+        {6.852000E-02, 1.120000E+02, 2.450000E+02, 9.321000E-04, 9.124000E-04, 8.852000E-01,
+         latvap,       latice,       4.100000E-03, 9.558000E-04, 2.560000E-03, 1.764000E-03,
+         2.346000E-01, 5.632000E-02, 3.024000E-02, 9.952000E+03, 2.093000E-05, false,
+         2.341678E-04, 1.092432E-02, 2.903000E-01, 2.125000E-02, 0.342000E-02},
+        {8.852000E-02, 1.210000E+02, 3.420000E+02, 9.623000E-04, 9.432000E-04, 8.900000E-01,
+         latvap,       latice,       3.100000E-03, 9.558000E-04, 3.211000E-03, 3.421000E-03,
+         3.421000E-01, 6.542000E-02, 4.567000E-02, 9.952000E+03, 3.091000E-05, false,
+         3.215234E-04, 2.098987E-02, 3.450000E-01, 3.490000E-02, 0.932000E-02},
+        {1.902000E-01, 1.326000E+02, 4.321000E+02, 9.982000E-04, 9.623000E-04, 9.900000E-01,
+         latvap,       latice,       2.100000E-03, 9.558000E-04, 4.121000E-03, 4.569000E-03,
+         4.673000E-01, 7.902000E-02, 5.321000E-02, 9.952000E+03, 4.521000E-05, false,
+         4.675567E-04, 3.214982E-02, 4.290000E-01, 4.590000E-02, 1.025000E-01},
 
-        {2.201000E-01, 1.456000E+02, 5.670000E+02, 1.234000E-03, 9.723000E-04, 0.100000E+01, latvap,       latice,
-         1.100000E-03, 2.550008E-05, 4.980000E-03, 5.621000E-03, 5.420000E-01, 8.021000E-02, 6.902000E-02, 9.952000E+04,
-         5.678000E-05, false,        5.389236E-04, 4.125969E-02, 5.098000E-01, 5.921000E-02, 2.031000E-01},
-        {3.502000E-01, 1.780009E+02, 6.832000E+02, 1.562000E-03, 1.024000E-03, 0.100000E+01, latvap,       latice,
-         8.100000E-04, 2.558000E-05, 5.643000E-03, 7.367000E-03, 6.782000E-01, 9.253000E-02, 8.045000E-02, 9.952000E+04,
-         6.902000E-05, false,        6.432654E-04, 5.389457E-02, 6.723000E-01, 6.093000E-02, 4.098000E-01},
-        {4.852000E-01, 2.100009E+02, 7.090000E+02, 2.101000E-03, 1.235000E-03, 0.100000E+01, latvap,       latice,
-         4.100000E-04, 2.558000E-05, 7.892000E-03, 9.087000E-03, 8.213000E-01, 1.256000E-01, 9.134000E-02, 9.952000E+04,
-         8.367000E-05, false,        7.210983E-04, 6.476985E-02, 8.902000E-01, 8.345000E-02, 8.023000E-01},
-        {5.852000E-01, 2.310000E+02, 9.215000E+02, 2.312000E-03, 1.456000E-03, 0.100000E+01, latvap,       latice,
-         2.100000E-04, 2.558000E-05, 9.321000E-03, 1.245000E-02, 1.067000E-00, 2.347000E-01, 1.092000E-01, 9.952000E+04,
-         9.098000E-05, false,        8.543367E-04, 8.213186E-02, 9.021000E-01, 9.321000E-02, 9.098000E-01},
+        {2.201000E-01, 1.456000E+02, 5.670000E+02, 1.234000E-03, 9.723000E-04, 0.100000E+01,
+         latvap,       latice,       1.100000E-03, 2.550008E-05, 4.980000E-03, 5.621000E-03,
+         5.420000E-01, 8.021000E-02, 6.902000E-02, 9.952000E+04, 5.678000E-05, false,
+         5.389236E-04, 4.125969E-02, 5.098000E-01, 5.921000E-02, 2.031000E-01},
+        {3.502000E-01, 1.780009E+02, 6.832000E+02, 1.562000E-03, 1.024000E-03, 0.100000E+01,
+         latvap,       latice,       8.100000E-04, 2.558000E-05, 5.643000E-03, 7.367000E-03,
+         6.782000E-01, 9.253000E-02, 8.045000E-02, 9.952000E+04, 6.902000E-05, false,
+         6.432654E-04, 5.389457E-02, 6.723000E-01, 6.093000E-02, 4.098000E-01},
+        {4.852000E-01, 2.100009E+02, 7.090000E+02, 2.101000E-03, 1.235000E-03, 0.100000E+01,
+         latvap,       latice,       4.100000E-04, 2.558000E-05, 7.892000E-03, 9.087000E-03,
+         8.213000E-01, 1.256000E-01, 9.134000E-02, 9.952000E+04, 8.367000E-05, false,
+         7.210983E-04, 6.476985E-02, 8.902000E-01, 8.345000E-02, 8.023000E-01},
+        {5.852000E-01, 2.310000E+02, 9.215000E+02, 2.312000E-03, 1.456000E-03, 0.100000E+01,
+         latvap,       latice,       2.100000E-04, 2.558000E-05, 9.321000E-03, 1.245000E-02,
+         1.067000E-00, 2.347000E-01, 1.092000E-01, 9.952000E+04, 9.098000E-05, false,
+         8.543367E-04, 8.213186E-02, 9.021000E-01, 9.321000E-02, 9.098000E-01},
 
-        {6.852000E-01, 2.563000E+02, 1.089000E+03, 3.601000E-03, 1.864000E-03, 0.950000E+00, latvap,       latice,
-         9.952000E-05, 4.596000E-05, 1.453000E-02, 2.543000E-02, 2.345000E-00, 3.578000E-01, 2.873000E-01, 1.734000E+04,
-         1.023000E-04, false,        9.021215E-04, 9.023367E-02, 1.023000E-00, 1.056000E-01, 1.256000E-00},
-        {7.852000E-01, 2.789000E+02, 3.754000E+03, 3.891000E-03, 2.093000E-03, 0.950000E+00, latvap,       latice,
-         4.952000E-05, 4.596000E-05, 2.789000E-02, 4.367000E-02, 3.890000E-00, 4.980000E-01, 3.468000E-01, 1.734000E+04,
-         2.146000E-04, false,        1.043468E-05, 1.094854E-02, 2.012000E-00, 2.893000E-01, 2.903000E-00},
-        {8.852000E-01, 3.123000E+02, 8.902000E+03, 4.872000E-03, 2.345000E-03, 0.950000E+00, latvap,       latice,
-         1.952000E-05, 4.596000E-05, 4.256000E-02, 6.324000E-02, 4.120000E-00, 6.321000E-01, 4.890000E-01, 1.734000E+04,
-         4.321000E-04, false,        2.341763E-05, 2.126247E-03, 3.120000E-00, 3.456000E-01, 3.912000E-00},
-        {9.852000E-01, 4.981000E+02, 1.092000E+04, 5.210000E-03, 3.210000E-03, 0.950000E+00, latvap,       latice,
-         9.952000E-06, 4.596000E-05, 6.821000E-02, 8.789000E-02, 5.320000E-00, 7.982000E-01, 6.921000E-01, 1.734000E+04,
-         5.821000E-04, false,        3.901479E-05, 3.874763E-03, 5.902000E-00, 5.092000E-01, 4.821000E-00},
+        {6.852000E-01, 2.563000E+02, 1.089000E+03, 3.601000E-03, 1.864000E-03, 0.950000E+00,
+         latvap,       latice,       9.952000E-05, 4.596000E-05, 1.453000E-02, 2.543000E-02,
+         2.345000E-00, 3.578000E-01, 2.873000E-01, 1.734000E+04, 1.023000E-04, false,
+         9.021215E-04, 9.023367E-02, 1.023000E-00, 1.056000E-01, 1.256000E-00},
+        {7.852000E-01, 2.789000E+02, 3.754000E+03, 3.891000E-03, 2.093000E-03, 0.950000E+00,
+         latvap,       latice,       4.952000E-05, 4.596000E-05, 2.789000E-02, 4.367000E-02,
+         3.890000E-00, 4.980000E-01, 3.468000E-01, 1.734000E+04, 2.146000E-04, false,
+         1.043468E-05, 1.094854E-02, 2.012000E-00, 2.893000E-01, 2.903000E-00},
+        {8.852000E-01, 3.123000E+02, 8.902000E+03, 4.872000E-03, 2.345000E-03, 0.950000E+00,
+         latvap,       latice,       1.952000E-05, 4.596000E-05, 4.256000E-02, 6.324000E-02,
+         4.120000E-00, 6.321000E-01, 4.890000E-01, 1.734000E+04, 4.321000E-04, false,
+         2.341763E-05, 2.126247E-03, 3.120000E-00, 3.456000E-01, 3.912000E-00},
+        {9.852000E-01, 4.981000E+02, 1.092000E+04, 5.210000E-03, 3.210000E-03, 0.950000E+00,
+         latvap,       latice,       9.952000E-06, 4.596000E-05, 6.821000E-02, 8.789000E-02,
+         5.320000E-00, 7.982000E-01, 6.921000E-01, 1.734000E+04, 5.821000E-04, false,
+         3.901479E-05, 3.874763E-03, 5.902000E-00, 5.092000E-01, 4.821000E-00},
 
-        {1.002000E+01, 1.234000E+03, 2.125000E+04, 6.012000E-03, 5.902000E-03, 1.069000E+00, latvap,       latice,
-         6.952000E-06, 6.596000E-05, 8.472000E-02, 1.543000E-01, 6.012000E-00, 8.902000E-01, 9.210000E-01, 1.734000E+04,
-         6.921000E-04, false,        4.521923E-05, 4.592698E-03, 6.091000E-00, 6.743000E-01, 5.602000E-00},
-        {1.152000E+01, 2.120000E+03, 4.568000E+04, 6.342000E-03, 9.210000E-03, 1.069000E+00, latvap,       latice,
-         3.952000E-06, 6.596000E-05, 1.098000E-01, 3.456000E-01, 7.241000E-00, 9.102000E-01, 1.002000E-00, 1.734000E+04,
-         7.901000E-04, false,        5.236542E-05, 5.678873E-03, 7.231000E-00, 8.321000E-01, 6.092000E-00},
-        {1.252000E+01, 3.145000E+03, 8.213000E+04, 9.290000E-03, 1.034000E-02, 1.069000E+00, latvap,       latice,
-         1.952000E-06, 6.596000E-05, 2.340006E-01, 5.632000E-01, 8.452000E-00, 1.003000E-01, 2.145000E-00, 1.734000E+04,
-         9.212000E-04, false,        6.732276E-05, 7.321873E-03, 8.234000E-00, 9.023000E-01, 7.201000E-00},
-        {1.352000E+01, 4.742000E+03, 1.014000E+05, 1.234000E-02, 1.456000E-02, 1.069000E+00, latvap,       latice,
-         9.952000E-07, 6.596000E-05, 4.123000E-01, 6.128000E-01, 9.076000E-00, 2.831000E-01, 3.902000E-00, 1.734000E+04,
-         1.023000E-03, false,        7.902887E-05, 9.032908E-03, 9.021000E-00, 1.092000E-01, 8.096000E-00}};
+        {1.002000E+01, 1.234000E+03, 2.125000E+04, 6.012000E-03, 5.902000E-03, 1.069000E+00,
+         latvap,       latice,       6.952000E-06, 6.596000E-05, 8.472000E-02, 1.543000E-01,
+         6.012000E-00, 8.902000E-01, 9.210000E-01, 1.734000E+04, 6.921000E-04, false,
+         4.521923E-05, 4.592698E-03, 6.091000E-00, 6.743000E-01, 5.602000E-00},
+        {1.152000E+01, 2.120000E+03, 4.568000E+04, 6.342000E-03, 9.210000E-03, 1.069000E+00,
+         latvap,       latice,       3.952000E-06, 6.596000E-05, 1.098000E-01, 3.456000E-01,
+         7.241000E-00, 9.102000E-01, 1.002000E-00, 1.734000E+04, 7.901000E-04, false,
+         5.236542E-05, 5.678873E-03, 7.231000E-00, 8.321000E-01, 6.092000E-00},
+        {1.252000E+01, 3.145000E+03, 8.213000E+04, 9.290000E-03, 1.034000E-02, 1.069000E+00,
+         latvap,       latice,       1.952000E-06, 6.596000E-05, 2.340006E-01, 5.632000E-01,
+         8.452000E-00, 1.003000E-01, 2.145000E-00, 1.734000E+04, 9.212000E-04, false,
+         6.732276E-05, 7.321873E-03, 8.234000E-00, 9.023000E-01, 7.201000E-00},
+        {1.352000E+01, 4.742000E+03, 1.014000E+05, 1.234000E-02, 1.456000E-02, 1.069000E+00,
+         latvap,       latice,       9.952000E-07, 6.596000E-05, 4.123000E-01, 6.128000E-01,
+         9.076000E-00, 2.831000E-01, 3.902000E-00, 1.734000E+04, 1.023000E-03, false,
+         7.902887E-05, 9.032908E-03, 9.021000E-00, 1.092000E-01, 8.096000E-00}};
 
     // Sync to device
     KTH::view_1d<IceWetGrowthData> self_host("self_host", max_pack_size);
@@ -99,12 +116,13 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCldliqWetGrowth : pub
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack rho, temp, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv, kap, mu, sc, qv,
-              qc_incld, qi_incld, ni_incld, qr_incld;
+          Spack rho, temp, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv,
+              kap, mu, sc, qv, qc_incld, qi_incld, ni_incld, qr_incld;
 
           Smask log_wetgrowth;
 
-          Spack qr2qi_collect_tend, qc2qi_collect_tend, qc_growth_rate, nr_ice_shed_tend, qc2qr_ice_shed_tend;
+          Spack qr2qi_collect_tend, qc2qi_collect_tend, qc_growth_rate, nr_ice_shed_tend,
+              qc2qr_ice_shed_tend;
 
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             rho[s]                       = self_device(vs).rho;
@@ -130,10 +148,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCldliqWetGrowth : pub
             log_wetgrowth.set(s, self_device(vs).log_wetgrowth);
           }
 
-          Functions::ice_cldliq_wet_growth(rho, temp, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt,
-                                           dv, kap, mu, sc, qv, qc_incld, qi_incld, ni_incld, qr_incld, log_wetgrowth,
-                                           qr2qi_collect_tend, qc2qi_collect_tend, qc_growth_rate, nr_ice_shed_tend,
-                                           qc2qr_ice_shed_tend);
+          Functions::ice_cldliq_wet_growth(
+              rho, temp, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv, kap,
+              mu, sc, qv, qc_incld, qi_incld, ni_incld, qr_incld, log_wetgrowth, qr2qi_collect_tend,
+              qc2qi_collect_tend, qc_growth_rate, nr_ice_shed_tend, qc2qr_ice_shed_tend);
 
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             self_device(vs).log_wetgrowth       = log_wetgrowth[s];
@@ -149,7 +167,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCldliqWetGrowth : pub
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
       for (Int s = 0; s < max_pack_size; ++s) {
-        REQUIRE(static_cast<bool>(self[s].log_wetgrowth) == static_cast<bool>(self_host(s).log_wetgrowth));
+        REQUIRE(static_cast<bool>(self[s].log_wetgrowth) ==
+                static_cast<bool>(self_host(s).log_wetgrowth));
 
         REQUIRE(self[s].qr2qi_collect_tend == self_host(s).qr2qi_collect_tend);
         REQUIRE(self[s].qc2qi_collect_tend == self_host(s).qc2qi_collect_tend);
@@ -176,7 +195,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCldliqWetGrowth : pub
 namespace {
 
 TEST_CASE("p3_ice_cldliq_wet_growth", "[p3_functions]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestIceCldliqWetGrowth;
+  using T =
+      scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestIceCldliqWetGrowth;
 
   T t;
   t.run_ice_cldliq_wet_growth_phys();
diff --git i/components/eamxx/src/physics/p3/tests/p3_ice_collection_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_ice_collection_unit_tests.cpp
index 0809bae776..b11963a640 100644
--- i/components/eamxx/src/physics/p3/tests/p3_ice_collection_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_ice_collection_unit_tests.cpp
@@ -21,7 +21,8 @@ namespace unit_test {
 /*
  * Unit-tests for p3 ice collection functions.
  */
-template <typename D> struct UnitWrap::UnitTest<D>::TestIceCollection : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestIceCollection : public UnitWrap::UnitTest<D>::Base {
 
   void run_ice_cldliq_bfb() {
     // Read in tables
@@ -30,11 +31,12 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCollection : public U
     view_2d_table revap_table_vals;
     view_1d_table mu_r_table_vals;
     view_dnu_table dnu;
-    Functions::get_global_tables(vn_table_vals, vm_table_vals, revap_table_vals, mu_r_table_vals, dnu);
+    Functions::get_global_tables(vn_table_vals, vm_table_vals, revap_table_vals, mu_r_table_vals,
+                                 dnu);
 
     // Load some lookup inputs, need at least one per pack value
     IceCldliqCollectionData cldliq[max_pack_size] = {
-        //  rho      temp      rhofaci     table_val_qc2qi_collect     qi      qc           ni      nc
+        //  rho      temp      rhofaci     table_val_qc2qi_collect     qi      qc           ni nc
         {4.056E-03, 4.02E+01, 8.852E-01, 0.174E+00, 1.221E-14, 5.100E-03, 9.558E+04, 9.952E+05},
         {6.852E-02, 5.01E+01, 8.852E-01, 0.374E+00, 1.221E-15, 4.100E-15, 9.558E+04, 9.952E+05},
         {8.852E-02, 6.00E+01, 8.900E-01, 0.123E+00, 1.221E-12, 3.100E-03, 9.558E+04, 9.952E+05},
@@ -91,8 +93,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCollection : public U
           Spack qc2qr_ice_shed_tend{0.0};
           Spack ncshdc{0.0};
 
-          Functions::ice_cldliq_collection(rho, temp, rhofaci, table_val_qc2qi_collect, qi_incld, qc_incld, ni_incld,
-                                           nc_incld, qc2qi_collect_tend, nc_collect_tend, qc2qr_ice_shed_tend, ncshdc,
+          Functions::ice_cldliq_collection(rho, temp, rhofaci, table_val_qc2qi_collect, qi_incld,
+                                           qc_incld, ni_incld, nc_incld, qc2qi_collect_tend,
+                                           nc_collect_tend, qc2qr_ice_shed_tend, ncshdc,
                                            p3::Functions<Real, DefaultDevice>::P3Runtime());
 
           // Copy results back into views
@@ -130,27 +133,44 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCollection : public U
     using KTH = KokkosTypes<HostDevice>;
 
     IceRainCollectionData rain[max_pack_size] = {
-        //  rho      temp      rhofaci     logn0r     table_val_nr_collect    table_val_qr2qi_collect        qi      ni
+        //  rho      temp      rhofaci     logn0r     table_val_nr_collect table_val_qr2qi_collect
+        //  qi      ni
         //  qr (required)
-        {4.056E-03, 4.02E+01, 8.852E-01, 0.174E+00, 1.221E-14, 5.100E-03, 9.558E-04, 9.952E+02, 5.100E-03},
-        {6.852E-02, 5.01E+01, 8.852E-01, 0.374E+00, 1.221E-13, 4.100E-03, 9.558E-15, 9.952E+02, 5.100E-15},
-        {8.852E-02, 6.00E+01, 8.900E-01, 0.123E+00, 1.221E-12, 3.100E-03, 9.558E-04, 9.952E+02, 5.100E-03},
-        {1.902E-01, 1.00E+02, 8.900E-01, 0.123E+00, 1.221E-11, 2.100E-03, 9.558E-04, 9.952E+02, 5.100E-15},
+        {4.056E-03, 4.02E+01, 8.852E-01, 0.174E+00, 1.221E-14, 5.100E-03, 9.558E-04, 9.952E+02,
+         5.100E-03},
+        {6.852E-02, 5.01E+01, 8.852E-01, 0.374E+00, 1.221E-13, 4.100E-03, 9.558E-15, 9.952E+02,
+         5.100E-15},
+        {8.852E-02, 6.00E+01, 8.900E-01, 0.123E+00, 1.221E-12, 3.100E-03, 9.558E-04, 9.952E+02,
+         5.100E-03},
+        {1.902E-01, 1.00E+02, 8.900E-01, 0.123E+00, 1.221E-11, 2.100E-03, 9.558E-04, 9.952E+02,
+         5.100E-15},
 
-        {2.201E-01, 2.00E+02, 0.100E+01, 0.174E+00, 1.221E-10, 1.100E-03, 2.558E-05, 9.952E+02, 5.100E-15},
-        {3.502E-01, 3.00E+02, 0.100E+01, 0.374E+00, 1.221E-09, 8.100E-04, 2.558E-15, 9.952E+02, 5.100E-15},
-        {4.852E-01, 5.00E+02, 0.100E+01, 0.123E+00, 1.221E-08, 4.100E-04, 2.558E-05, 9.952E+02, 5.100E-03},
-        {5.852E-01, 8.00E+02, 0.100E+01, 0.123E+00, 1.221E-07, 2.100E-04, 2.558E-05, 9.952E+02, 5.100E-03},
+        {2.201E-01, 2.00E+02, 0.100E+01, 0.174E+00, 1.221E-10, 1.100E-03, 2.558E-05, 9.952E+02,
+         5.100E-15},
+        {3.502E-01, 3.00E+02, 0.100E+01, 0.374E+00, 1.221E-09, 8.100E-04, 2.558E-15, 9.952E+02,
+         5.100E-15},
+        {4.852E-01, 5.00E+02, 0.100E+01, 0.123E+00, 1.221E-08, 4.100E-04, 2.558E-05, 9.952E+02,
+         5.100E-03},
+        {5.852E-01, 8.00E+02, 0.100E+01, 0.123E+00, 1.221E-07, 2.100E-04, 2.558E-05, 9.952E+02,
+         5.100E-03},
 
-        {6.852E-01, 1.00E+03, 0.950E+00, 0.150E+00, 1.221E-06, 9.952E-05, 4.596E-05, 1.734E+03, 5.100E-15},
-        {7.852E-01, 2.00E+03, 0.950E+00, 0.374E+00, 1.221E-05, 4.952E-05, 4.596E-15, 1.734E+03, 5.100E-15},
-        {8.852E-01, 4.00E+03, 0.950E+00, 0.123E+00, 1.221E-04, 1.952E-05, 4.596E-05, 1.734E+03, 5.100E-03},
-        {9.852E-01, 6.00E+03, 0.950E+00, 0.123E+00, 1.221E-03, 9.952E-06, 4.596E-05, 1.734E+03, 5.100E-03},
+        {6.852E-01, 1.00E+03, 0.950E+00, 0.150E+00, 1.221E-06, 9.952E-05, 4.596E-05, 1.734E+03,
+         5.100E-15},
+        {7.852E-01, 2.00E+03, 0.950E+00, 0.374E+00, 1.221E-05, 4.952E-05, 4.596E-15, 1.734E+03,
+         5.100E-15},
+        {8.852E-01, 4.00E+03, 0.950E+00, 0.123E+00, 1.221E-04, 1.952E-05, 4.596E-05, 1.734E+03,
+         5.100E-03},
+        {9.852E-01, 6.00E+03, 0.950E+00, 0.123E+00, 1.221E-03, 9.952E-06, 4.596E-05, 1.734E+03,
+         5.100E-03},
 
-        {1.002E+01, 1.00E+04, 1.069E+00, 0.174E+00, 1.221E-02, 6.952E-06, 6.596E-05, 1.734E+03, 5.100E-15},
-        {1.152E+01, 2.00E+04, 1.069E+00, 0.374E+00, 1.221E-02, 3.952E-06, 6.596E-15, 1.734E+03, 5.100E-03},
-        {1.252E+01, 4.00E+04, 1.069E+00, 0.123E+00, 1.221E-02, 1.952E-06, 6.596E-05, 1.734E+03, 5.100E-15},
-        {1.352E+01, 8.00E+04, 1.069E+00, 0.123E+00, 1.221E-02, 9.952E-07, 6.596E-05, 1.734E+03, 5.100E-03}};
+        {1.002E+01, 1.00E+04, 1.069E+00, 0.174E+00, 1.221E-02, 6.952E-06, 6.596E-05, 1.734E+03,
+         5.100E-15},
+        {1.152E+01, 2.00E+04, 1.069E+00, 0.374E+00, 1.221E-02, 3.952E-06, 6.596E-15, 1.734E+03,
+         5.100E-03},
+        {1.252E+01, 4.00E+04, 1.069E+00, 0.123E+00, 1.221E-02, 1.952E-06, 6.596E-05, 1.734E+03,
+         5.100E-15},
+        {1.352E+01, 8.00E+04, 1.069E+00, 0.123E+00, 1.221E-02, 9.952E-07, 6.596E-05, 1.734E+03,
+         5.100E-03}};
 
     // Sync to device
     KTH::view_1d<IceRainCollectionData> rain_host("rain_host", max_pack_size);
@@ -171,7 +191,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCollection : public U
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack rho, temp, rhofaci, logn0r, table_val_nr_collect, table_val_qr2qi_collect, qi_incld, ni_incld, qr_incld;
+          Spack rho, temp, rhofaci, logn0r, table_val_nr_collect, table_val_qr2qi_collect, qi_incld,
+              ni_incld, qr_incld;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             rho[s]                     = rain_device(vs).rho;
             temp[s]                    = rain_device(vs).temp;
@@ -185,8 +206,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCollection : public U
           }
 
           Spack qr2qi_collect_tend(0.0), nr_collect_tend(0.0);
-          Functions::ice_rain_collection(rho, temp, rhofaci, logn0r, table_val_nr_collect, table_val_qr2qi_collect,
-                                         qi_incld, ni_incld, qr_incld, qr2qi_collect_tend, nr_collect_tend,
+          Functions::ice_rain_collection(rho, temp, rhofaci, logn0r, table_val_nr_collect,
+                                         table_val_qr2qi_collect, qi_incld, ni_incld, qr_incld,
+                                         qr2qi_collect_tend, nr_collect_tend,
                                          p3::Functions<Real, DefaultDevice>::P3Runtime());
 
           // Copy results back into views
@@ -272,8 +294,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceCollection : public U
           }
 
           Spack ni_selfcollect_tend{0.0};
-          Functions::ice_self_collection(rho, rhofaci, table_val_ni_self_collect, eii, qm_incld, qi_incld, ni_incld,
-                                         ni_selfcollect_tend);
+          Functions::ice_self_collection(rho, rhofaci, table_val_ni_self_collect, eii, qm_incld,
+                                         qi_incld, ni_incld, ni_selfcollect_tend);
 
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             self_device(vs).ni_selfcollect_tend = ni_selfcollect_tend[s];
diff --git i/components/eamxx/src/physics/p3/tests/p3_ice_deposition_sublimation_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_ice_deposition_sublimation_tests.cpp
index 7dc25be873..bda7338878 100644
--- i/components/eamxx/src/physics/p3/tests/p3_ice_deposition_sublimation_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_ice_deposition_sublimation_tests.cpp
@@ -12,7 +12,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestIceDepositionSublimation : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestIceDepositionSublimation : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     // Note that a lot of property tests are included in run_bfb for simplicity
@@ -31,38 +32,59 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceDepositionSublimation
     Spack qv2qi_vapdep_tend, qi2qv_sublim_tend, ni_sublim_tend, qc2qi_berg_tend;
 
     // CHECK THAT UNREASONABLY LARGE VAPOR DEPOSITION DOESN'T LEAVE QV SUBSATURATED WRT QI
-    Spack epsi_tmp = 1e6; // make 1/(sat removal timescale) huge so vapdep rate removes all supersat in 1 dt.
-    Functions::ice_deposition_sublimation(qi_incld, ni_incld, T_atm, qv_sat_l, qv_sat_i, epsi_tmp, abi, qv, inv_dt,
-                                          qv2qi_vapdep_tend, qi2qv_sublim_tend, ni_sublim_tend, qc2qi_berg_tend);
-    REQUIRE((qv2qi_vapdep_tend[0] == 0 || std::abs(qv2qi_vapdep_tend[0] - (qv[0] - qv_sat_i[0]) * inv_dt) < 1e-8));
+    Spack epsi_tmp =
+        1e6; // make 1/(sat removal timescale) huge so vapdep rate removes all supersat in 1 dt.
+    Functions::ice_deposition_sublimation(qi_incld, ni_incld, T_atm, qv_sat_l, qv_sat_i, epsi_tmp,
+                                          abi, qv, inv_dt, qv2qi_vapdep_tend, qi2qv_sublim_tend,
+                                          ni_sublim_tend, qc2qi_berg_tend);
+    REQUIRE((qv2qi_vapdep_tend[0] == 0 ||
+             std::abs(qv2qi_vapdep_tend[0] - (qv[0] - qv_sat_i[0]) * inv_dt) < 1e-8));
 
     // CHECK THAT HUGE SUBLIMATION DOESN'T LEAVE QV SUPERSATURATED WRT QI
     Spack qv_sat_i_tmp = 1e-2;
-    Functions::ice_deposition_sublimation(qi_incld, ni_incld, T_atm, qv_sat_l, qv_sat_i_tmp, epsi_tmp, abi, qv, inv_dt,
-                                          qv2qi_vapdep_tend, qi2qv_sublim_tend, ni_sublim_tend, qc2qi_berg_tend);
-    REQUIRE((qi2qv_sublim_tend[0] == 0 || std::abs(qi2qv_sublim_tend[0] - (qv_sat_i_tmp[0] - qv[0]) * inv_dt) < 1e-8));
+    Functions::ice_deposition_sublimation(qi_incld, ni_incld, T_atm, qv_sat_l, qv_sat_i_tmp,
+                                          epsi_tmp, abi, qv, inv_dt, qv2qi_vapdep_tend,
+                                          qi2qv_sublim_tend, ni_sublim_tend, qc2qi_berg_tend);
+    REQUIRE((qi2qv_sublim_tend[0] == 0 ||
+             std::abs(qi2qv_sublim_tend[0] - (qv_sat_i_tmp[0] - qv[0]) * inv_dt) < 1e-8));
 
     // CHECK BEHAVIOR AS DT->0?
   }
 
   void run_bfb() {
     IceDepositionSublimationData baseline_data[max_pack_size] = {
-        {1.0000E-04, 4.5010E+05, 2.8750E+02, 1.1279E-02, 1.1279E-02, 0.0000E+00, 3.3648E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.5370E+05, 2.8542E+02, 9.9759E-03, 9.9759E-03, 0.0000E+00, 3.1223E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.5742E+05, 2.8334E+02, 8.8076E-03, 8.8076E-03, 0.0000E+00, 2.9014E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.6125E+05, 2.8125E+02, 7.7615E-03, 7.7615E-03, 0.0000E+00, 2.7005E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.6521E+05, 2.7917E+02, 6.8265E-03, 6.8265E-03, 0.0000E+00, 2.5180E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.6930E+05, 2.7709E+02, 5.9921E-03, 5.9921E-03, 0.0000E+00, 2.3526E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.7353E+05, 2.7501E+02, 5.2488E-03, 5.2488E-03, 0.0000E+00, 2.2028E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.7790E+05, 2.7292E+02, 4.5879E-03, 4.5766E-03, 6.2108E-02, 2.0649E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.8241E+05, 2.7084E+02, 4.0015E-03, 3.9112E-03, 6.1911E-02, 1.9241E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.8709E+05, 2.6876E+02, 3.4821E-03, 3.3349E-03, 6.1708E-02, 1.8002E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.9193E+05, 2.6667E+02, 3.0231E-03, 2.8368E-03, 6.1502E-02, 1.6914E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 4.9695E+05, 2.6459E+02, 2.6183E-03, 2.4074E-03, 6.1290E-02, 1.5960E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 5.0216E+05, 2.6251E+02, 2.2621E-03, 2.0379E-03, 6.1073E-02, 1.5125E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 5.0756E+05, 2.6042E+02, 1.9495E-03, 1.7207E-03, 6.0850E-02, 1.4397E+00, 5.0000E-03, 1.666667e-02},
-        {5.1000E-03, 5.1317E+05, 2.5834E+02, 1.6757E-03, 1.4491E-03, 6.0620E-02, 1.3763E+00, 5.0000E-03, 1.666667e-02},
-        {5.0000E-08, 5.4479E+05, 2.4793E+02, 7.5430E-04, 5.8895E-04, 4.6769E-04, 1.1661E+00, 1.5278E-04, 1.666667e-02},
+        {1.0000E-04, 4.5010E+05, 2.8750E+02, 1.1279E-02, 1.1279E-02, 0.0000E+00, 3.3648E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.5370E+05, 2.8542E+02, 9.9759E-03, 9.9759E-03, 0.0000E+00, 3.1223E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.5742E+05, 2.8334E+02, 8.8076E-03, 8.8076E-03, 0.0000E+00, 2.9014E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.6125E+05, 2.8125E+02, 7.7615E-03, 7.7615E-03, 0.0000E+00, 2.7005E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.6521E+05, 2.7917E+02, 6.8265E-03, 6.8265E-03, 0.0000E+00, 2.5180E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.6930E+05, 2.7709E+02, 5.9921E-03, 5.9921E-03, 0.0000E+00, 2.3526E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.7353E+05, 2.7501E+02, 5.2488E-03, 5.2488E-03, 0.0000E+00, 2.2028E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.7790E+05, 2.7292E+02, 4.5879E-03, 4.5766E-03, 6.2108E-02, 2.0649E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.8241E+05, 2.7084E+02, 4.0015E-03, 3.9112E-03, 6.1911E-02, 1.9241E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.8709E+05, 2.6876E+02, 3.4821E-03, 3.3349E-03, 6.1708E-02, 1.8002E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.9193E+05, 2.6667E+02, 3.0231E-03, 2.8368E-03, 6.1502E-02, 1.6914E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 4.9695E+05, 2.6459E+02, 2.6183E-03, 2.4074E-03, 6.1290E-02, 1.5960E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 5.0216E+05, 2.6251E+02, 2.2621E-03, 2.0379E-03, 6.1073E-02, 1.5125E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 5.0756E+05, 2.6042E+02, 1.9495E-03, 1.7207E-03, 6.0850E-02, 1.4397E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.1000E-03, 5.1317E+05, 2.5834E+02, 1.6757E-03, 1.4491E-03, 6.0620E-02, 1.3763E+00,
+         5.0000E-03, 1.666667e-02},
+        {5.0000E-08, 5.4479E+05, 2.4793E+02, 7.5430E-04, 5.8895E-04, 4.6769E-04, 1.1661E+00,
+         1.5278E-04, 1.666667e-02},
     };
 
     // Generate random input data
@@ -71,8 +93,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceDepositionSublimation
     //  d.randomize();
     //}
 
-    // Create copies of data for use by cxx and sync it to device. Needs to happen before reads so that
-    // inout data is in original state
+    // Create copies of data for use by cxx and sync it to device. Needs to happen before reads so
+    // that inout data is in original state
     view_1d<IceDepositionSublimationData> cxx_device("cxx_device", max_pack_size);
     const auto cxx_host = Kokkos::create_mirror_view(cxx_device);
     std::copy(&baseline_data[0], &baseline_data[0] + max_pack_size, cxx_host.data());
@@ -108,8 +130,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceDepositionSublimation
           // Init outputs
           Spack ni_sublim_tend(0), qi2qv_sublim_tend(0), qc2qi_berg_tend(0), qv2qi_vapdep_tend(0);
 
-          Functions::ice_deposition_sublimation(qi_incld, ni_incld, T_atm, qv_sat_l, qv_sat_i, epsi, abi, qv, inv_dt,
-                                                qv2qi_vapdep_tend, qi2qv_sublim_tend, ni_sublim_tend, qc2qi_berg_tend);
+          Functions::ice_deposition_sublimation(qi_incld, ni_incld, T_atm, qv_sat_l, qv_sat_i, epsi,
+                                                abi, qv, inv_dt, qv2qi_vapdep_tend,
+                                                qi2qv_sublim_tend, ni_sublim_tend, qc2qi_berg_tend);
 
           // Copy spacks back into cxx_device view
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
@@ -139,9 +162,11 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceDepositionSublimation
         REQUIRE(d_cxx.qc2qi_berg_tend >= 0);
 
         // vapdep should only occur when qv>qv_sat_i
-        REQUIRE((d_cxx.qv2qi_vapdep_tend == 0 || d_cxx.qv + d_cxx.qv2qi_vapdep_tend * d_cxx.inv_dt >= d_cxx.qv_sat_i));
+        REQUIRE((d_cxx.qv2qi_vapdep_tend == 0 ||
+                 d_cxx.qv + d_cxx.qv2qi_vapdep_tend * d_cxx.inv_dt >= d_cxx.qv_sat_i));
         // sublim should only occur when qv<qv_sat_i
-        REQUIRE((d_cxx.qi2qv_sublim_tend == 0 || d_cxx.qv + d_cxx.qi2qv_sublim_tend * d_cxx.inv_dt <= d_cxx.qv_sat_i));
+        REQUIRE((d_cxx.qi2qv_sublim_tend == 0 ||
+                 d_cxx.qv + d_cxx.qi2qv_sublim_tend * d_cxx.inv_dt <= d_cxx.qv_sat_i));
 
         // if T>frz, berg and vapdep should be 0:
         REQUIRE((d_cxx.T_atm < C::T_zerodegc || d_cxx.qc2qi_berg_tend == 0));
@@ -162,14 +187,16 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceDepositionSublimation
 namespace {
 
 TEST_CASE("ice_deposition_sublimation_property", "[p3]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestIceDepositionSublimation;
+  using T = scream::p3::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestIceDepositionSublimation;
 
   T t;
   t.run_property();
 }
 
 TEST_CASE("ice_deposition_sublimation_bfb", "[p3]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestIceDepositionSublimation;
+  using T = scream::p3::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestIceDepositionSublimation;
 
   T t;
   t.run_bfb();
diff --git i/components/eamxx/src/physics/p3/tests/p3_ice_melting_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_ice_melting_unit_tests.cpp
index 602d25a477..d825fdcc1d 100644
--- i/components/eamxx/src/physics/p3/tests/p3_ice_melting_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_ice_melting_unit_tests.cpp
@@ -18,51 +18,55 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestP3IceMelting : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestP3IceMelting : public UnitWrap::UnitTest<D>::Base {
 
   void ice_melting_bfb() {
     constexpr Scalar latvap = C::LatVap;
     constexpr Scalar latice = C::LatIce;
 
-    // make array of input data (why not pass actual variables?). Copied 1st 4 rows 4x to fill pack size.
+    // make array of input data (why not pass actual variables?). Copied 1st 4 rows 4x to fill pack
+    // size.
     IceMeltingData IceMelt[max_pack_size] = {
-        // rho,     T_atm,        pres,     rhofaci,  table_val_qi2qr_melting,   table_val_qi2qr_vent_melt,
-        // latent_heat_vapor,     latent_heat_fusion,      dv,       sc,       mu,       kap,      qv, qi_incld,ni_incld
-        {0.117E+01, 0.299E+03, 0.101E+06, 0.829E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.263E-04, 0.601E+00,
-         0.185E-04, 0.261E-01, 0.160E-01, 0.510E-02, 0.195E-12},
-        {0.114E+01, 0.296E+03, 0.973E+05, 0.842E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.268E-04, 0.601E+00,
-         0.183E-04, 0.259E-01, 0.149E-01, 0.510E-02, 0.195E-12},
-        {0.977E+00, 0.287E+03, 0.809E+05, 0.913E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.306E-04, 0.599E+00,
-         0.179E-04, 0.253E-01, 0.827E-02, 0.000E+00, 0.000E+00},
-        {0.103E+01, 0.289E+03, 0.862E+05, 0.887E+00, 0.636E-03, 0.281E-04, latvap, latice, 0.291E-04, 0.600E+00,
-         0.180E-04, 0.254E-01, 0.107E-01, 0.510E-02, 0.336E+05},
+        // rho,     T_atm,        pres,     rhofaci,  table_val_qi2qr_melting,
+        // table_val_qi2qr_vent_melt,
+        // latent_heat_vapor,     latent_heat_fusion,      dv,       sc,       mu,       kap, qv,
+        // qi_incld,ni_incld
+        {0.117E+01, 0.299E+03, 0.101E+06, 0.829E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.263E-04, 0.601E+00, 0.185E-04, 0.261E-01, 0.160E-01, 0.510E-02, 0.195E-12},
+        {0.114E+01, 0.296E+03, 0.973E+05, 0.842E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.268E-04, 0.601E+00, 0.183E-04, 0.259E-01, 0.149E-01, 0.510E-02, 0.195E-12},
+        {0.977E+00, 0.287E+03, 0.809E+05, 0.913E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.306E-04, 0.599E+00, 0.179E-04, 0.253E-01, 0.827E-02, 0.000E+00, 0.000E+00},
+        {0.103E+01, 0.289E+03, 0.862E+05, 0.887E+00, 0.636E-03, 0.281E-04, latvap, latice,
+         0.291E-04, 0.600E+00, 0.180E-04, 0.254E-01, 0.107E-01, 0.510E-02, 0.336E+05},
 
-        {0.117E+01, 0.299E+03, 0.101E+06, 0.829E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.263E-04, 0.601E+00,
-         0.185E-04, 0.261E-01, 0.160E-01, 0.510E-02, 0.195E-12},
-        {0.114E+01, 0.296E+03, 0.973E+05, 0.842E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.268E-04, 0.601E+00,
-         0.183E-04, 0.259E-01, 0.149E-01, 0.510E-02, 0.195E-12},
-        {0.977E+00, 0.287E+03, 0.809E+05, 0.913E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.306E-04, 0.599E+00,
-         0.179E-04, 0.253E-01, 0.827E-02, 0.000E+00, 0.000E+00},
-        {0.103E+01, 0.289E+03, 0.862E+05, 0.887E+00, 0.636E-03, 0.281E-04, latvap, latice, 0.291E-04, 0.600E+00,
-         0.180E-04, 0.254E-01, 0.107E-01, 0.510E-02, 0.336E+05},
+        {0.117E+01, 0.299E+03, 0.101E+06, 0.829E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.263E-04, 0.601E+00, 0.185E-04, 0.261E-01, 0.160E-01, 0.510E-02, 0.195E-12},
+        {0.114E+01, 0.296E+03, 0.973E+05, 0.842E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.268E-04, 0.601E+00, 0.183E-04, 0.259E-01, 0.149E-01, 0.510E-02, 0.195E-12},
+        {0.977E+00, 0.287E+03, 0.809E+05, 0.913E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.306E-04, 0.599E+00, 0.179E-04, 0.253E-01, 0.827E-02, 0.000E+00, 0.000E+00},
+        {0.103E+01, 0.289E+03, 0.862E+05, 0.887E+00, 0.636E-03, 0.281E-04, latvap, latice,
+         0.291E-04, 0.600E+00, 0.180E-04, 0.254E-01, 0.107E-01, 0.510E-02, 0.336E+05},
 
-        {0.117E+01, 0.299E+03, 0.101E+06, 0.829E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.263E-04, 0.601E+00,
-         0.185E-04, 0.261E-01, 0.160E-01, 0.510E-02, 0.195E-12},
-        {0.114E+01, 0.296E+03, 0.973E+05, 0.842E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.268E-04, 0.601E+00,
-         0.183E-04, 0.259E-01, 0.149E-01, 0.510E-02, 0.195E-12},
-        {0.977E+00, 0.287E+03, 0.809E+05, 0.913E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.306E-04, 0.599E+00,
-         0.179E-04, 0.253E-01, 0.827E-02, 0.000E+00, 0.000E+00},
-        {0.103E+01, 0.289E+03, 0.862E+05, 0.887E+00, 0.636E-03, 0.281E-04, latvap, latice, 0.291E-04, 0.600E+00,
-         0.180E-04, 0.254E-01, 0.107E-01, 0.510E-02, 0.336E+05},
+        {0.117E+01, 0.299E+03, 0.101E+06, 0.829E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.263E-04, 0.601E+00, 0.185E-04, 0.261E-01, 0.160E-01, 0.510E-02, 0.195E-12},
+        {0.114E+01, 0.296E+03, 0.973E+05, 0.842E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.268E-04, 0.601E+00, 0.183E-04, 0.259E-01, 0.149E-01, 0.510E-02, 0.195E-12},
+        {0.977E+00, 0.287E+03, 0.809E+05, 0.913E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.306E-04, 0.599E+00, 0.179E-04, 0.253E-01, 0.827E-02, 0.000E+00, 0.000E+00},
+        {0.103E+01, 0.289E+03, 0.862E+05, 0.887E+00, 0.636E-03, 0.281E-04, latvap, latice,
+         0.291E-04, 0.600E+00, 0.180E-04, 0.254E-01, 0.107E-01, 0.510E-02, 0.336E+05},
 
-        {0.117E+01, 0.299E+03, 0.101E+06, 0.829E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.263E-04, 0.601E+00,
-         0.185E-04, 0.261E-01, 0.160E-01, 0.510E-02, 0.195E-12},
-        {0.114E+01, 0.296E+03, 0.973E+05, 0.842E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.268E-04, 0.601E+00,
-         0.183E-04, 0.259E-01, 0.149E-01, 0.510E-02, 0.195E-12},
-        {0.977E+00, 0.287E+03, 0.809E+05, 0.913E+00, 0.122E+01, 0.562E-01, latvap, latice, 0.306E-04, 0.599E+00,
-         0.179E-04, 0.253E-01, 0.827E-02, 0.000E+00, 0.000E+00},
-        {0.103E+01, 0.289E+03, 0.862E+05, 0.887E+00, 0.636E-03, 0.281E-04, latvap, latice, 0.291E-04, 0.600E+00,
-         0.180E-04, 0.254E-01, 0.107E-01, 0.510E-02, 0.336E+05}};
+        {0.117E+01, 0.299E+03, 0.101E+06, 0.829E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.263E-04, 0.601E+00, 0.185E-04, 0.261E-01, 0.160E-01, 0.510E-02, 0.195E-12},
+        {0.114E+01, 0.296E+03, 0.973E+05, 0.842E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.268E-04, 0.601E+00, 0.183E-04, 0.259E-01, 0.149E-01, 0.510E-02, 0.195E-12},
+        {0.977E+00, 0.287E+03, 0.809E+05, 0.913E+00, 0.122E+01, 0.562E-01, latvap, latice,
+         0.306E-04, 0.599E+00, 0.179E-04, 0.253E-01, 0.827E-02, 0.000E+00, 0.000E+00},
+        {0.103E+01, 0.289E+03, 0.862E+05, 0.887E+00, 0.636E-03, 0.281E-04, latvap, latice,
+         0.291E-04, 0.600E+00, 0.180E-04, 0.254E-01, 0.107E-01, 0.510E-02, 0.336E+05}};
 
     // Sync to device
     view_1d<IceMeltingData> IceMelt_device("IceMelt", max_pack_size);
@@ -84,8 +88,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3IceMelting : public Un
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack rho, T_atm, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv, sc, mu, kap, qv,
-              qi_incld, ni_incld, qi2qr_melt_tend, ni2nr_melt_tend;
+          Spack rho, T_atm, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv,
+              sc, mu, kap, qv, qi_incld, ni_incld, qi2qr_melt_tend, ni2nr_melt_tend;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             rho[s]                       = IceMelt_device(vs).rho;
             T_atm[s]                     = IceMelt_device(vs).T_atm;
@@ -104,8 +108,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3IceMelting : public Un
             ni2nr_melt_tend[s]           = IceMelt_device(vs).ni2nr_melt_tend;
           }
 
-          Functions::ice_melting(rho, T_atm, pres, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv, sc,
-                                 mu, kap, qv, qi_incld, ni_incld, qi2qr_melt_tend, ni2nr_melt_tend);
+          Functions::ice_melting(rho, T_atm, pres, rhofaci, table_val_qi2qr_melting,
+                                 table_val_qi2qr_vent_melt, dv, sc, mu, kap, qv, qi_incld, ni_incld,
+                                 qi2qr_melt_tend, ni2nr_melt_tend);
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             IceMelt_device(vs).qi2qr_melt_tend = qi2qr_melt_tend[s];
diff --git i/components/eamxx/src/physics/p3/tests/p3_ice_nucleation_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_ice_nucleation_unit_tests.cpp
index ed7947b2a6..2d9844a01d 100644
--- i/components/eamxx/src/physics/p3/tests/p3_ice_nucleation_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_ice_nucleation_unit_tests.cpp
@@ -18,7 +18,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestIceNucleation : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestIceNucleation : public UnitWrap::UnitTest<D>::Base {
 
   void run_ice_nucleation_bfb() {
     using KTH = KokkosTypes<HostDevice>;
@@ -30,30 +31,48 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceNucleation : public U
       for (bool do_prescribed_CCN : {false, true}) {
 
         IceNucleationData self[max_pack_size] = {
-            // temp,    inv_rho,   ni,     ni_activated,      qv_supersat_i,      inv_dt, do_predict_nc,
+            // temp,    inv_rho,   ni,     ni_activated,      qv_supersat_i,      inv_dt,
+            // do_predict_nc,
             // do_prescribed_CCN
-            {2.106E+02, 8.852E-01, 0.974E+04, 9.221E+03, 5.100E-01, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.052E+02, 8.852E-01, 0.874E+04, 8.221E+03, 4.100E-01, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.352E+02, 8.900E-01, 0.723E+04, 7.221E+03, 3.100E-01, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.212E+02, 9.900E-01, 0.623E+04, 6.221E+03, 2.100E-01, inv_dt, do_predict_nc, do_prescribed_CCN},
+            {2.106E+02, 8.852E-01, 0.974E+04, 9.221E+03, 5.100E-01, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.052E+02, 8.852E-01, 0.874E+04, 8.221E+03, 4.100E-01, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.352E+02, 8.900E-01, 0.723E+04, 7.221E+03, 3.100E-01, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.212E+02, 9.900E-01, 0.623E+04, 6.221E+03, 2.100E-01, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
 
-            {2.251E+02, 0.100E+01, 0.574E+04, 5.221E+03, 1.100E-01, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.710E+02, 0.100E+01, 0.474E+04, 4.221E+03, 8.100E-02, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.052E+02, 0.100E+01, 0.323E+04, 3.221E+03, 4.100E-02, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.502E+02, 0.100E+01, 0.223E+04, 2.221E+03, 2.100E-02, inv_dt, do_predict_nc, do_prescribed_CCN},
+            {2.251E+02, 0.100E+01, 0.574E+04, 5.221E+03, 1.100E-01, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.710E+02, 0.100E+01, 0.474E+04, 4.221E+03, 8.100E-02, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.052E+02, 0.100E+01, 0.323E+04, 3.221E+03, 4.100E-02, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.502E+02, 0.100E+01, 0.223E+04, 2.221E+03, 2.100E-02, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
 
-            {2.552E+02, 0.950E+00, 0.150E+04, 9.221E+02, 9.952E-02, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.452E+02, 0.950E+00, 0.974E+03, 8.221E+02, 4.952E-02, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.352E+02, 0.950E+00, 0.823E+03, 7.221E+02, 1.952E-02, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.252E+02, 0.950E+00, 0.723E+03, 6.221E+02, 9.952E-02, inv_dt, do_predict_nc, do_prescribed_CCN},
+            {2.552E+02, 0.950E+00, 0.150E+04, 9.221E+02, 9.952E-02, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.452E+02, 0.950E+00, 0.974E+03, 8.221E+02, 4.952E-02, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.352E+02, 0.950E+00, 0.823E+03, 7.221E+02, 1.952E-02, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.252E+02, 0.950E+00, 0.723E+03, 6.221E+02, 9.952E-02, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
 
-            {1.990E+02, 1.069E+00, 0.674E+03, 5.221E+01, 6.952E-01, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.952E+02, 1.069E+00, 0.574E+03, 4.221E+01, 3.952E-01, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.852E+02, 1.069E+00, 0.423E+03, 3.221E+01, 1.952E-01, inv_dt, do_predict_nc, do_prescribed_CCN},
-            {2.702E+02, 1.069E+00, 0.323E+03, 2.221E+01, 9.952E-01, inv_dt, do_predict_nc, do_prescribed_CCN}};
+            {1.990E+02, 1.069E+00, 0.674E+03, 5.221E+01, 6.952E-01, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.952E+02, 1.069E+00, 0.574E+03, 4.221E+01, 3.952E-01, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.852E+02, 1.069E+00, 0.423E+03, 3.221E+01, 1.952E-01, inv_dt, do_predict_nc,
+             do_prescribed_CCN},
+            {2.702E+02, 1.069E+00, 0.323E+03, 2.221E+01, 9.952E-01, inv_dt, do_predict_nc,
+             do_prescribed_CCN}};
 
         std::string root_name = "ice_nucleation";
-        std::string file_name = root_name + (do_predict_nc ? "1" : "0") + (do_prescribed_CCN ? "1" : "0");
+        std::string file_name =
+            root_name + (do_predict_nc ? "1" : "0") + (do_prescribed_CCN ? "1" : "0");
         if (this->m_baseline_action == COMPARE) {
           for (Int i = 0; i < max_pack_size; ++i) {
             self[i].read(Base::m_fid);
@@ -83,8 +102,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceNucleation : public U
               // outputs
               Spack qv2qi_nucleat_tend{0.0};
               Spack ni_nucleat_tend{0.0};
-              Functions::ice_nucleation(temp, inv_rho, ni, ni_activated, qv_supersat_i, self_device(0).inv_dt,
-                                        do_predict_nc, do_prescribed_CCN, qv2qi_nucleat_tend, ni_nucleat_tend,
+              Functions::ice_nucleation(temp, inv_rho, ni, ni_activated, qv_supersat_i,
+                                        self_device(0).inv_dt, do_predict_nc, do_prescribed_CCN,
+                                        qv2qi_nucleat_tend, ni_nucleat_tend,
                                         p3::Functions<Real, DefaultDevice>::P3Runtime());
 
               for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
diff --git i/components/eamxx/src/physics/p3/tests/p3_ice_relaxation_timescale_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_ice_relaxation_timescale_unit_tests.cpp
index a0b3c99eac..22756241d8 100644
--- i/components/eamxx/src/physics/p3/tests/p3_ice_relaxation_timescale_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_ice_relaxation_timescale_unit_tests.cpp
@@ -18,34 +18,52 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestIceRelaxationTimescale : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestIceRelaxationTimescale : public UnitWrap::UnitTest<D>::Base {
 
   void run_ice_relaxation_timescale_bfb() {
     using KTH = KokkosTypes<HostDevice>;
 
     IceRelaxationData self[max_pack_size] = {
 
-        // rho,     temp,    rhofaci,   table_val_qi2qr_melting,    table_val_qi2qr_vent_melt,     dv,       mu, sc,
+        // rho,     temp,    rhofaci,   table_val_qi2qr_melting,    table_val_qi2qr_vent_melt, dv,
+        // mu, sc,
         // qi_incld, ni_incld, epsi,epsi_tot
-        {4.056E-03, 1.021E+01, 8.852E-01, 0.174E+00, 0.021E+00, 1.221E-14, 5.100E-03, 9.558E-04, 1.234E-03, 9.952E+03},
-        {6.852E-02, 2.022E+01, 8.852E-01, 0.374E+00, 0.042E+00, 1.221E-13, 4.100E-03, 9.558E-04, 2.670E-03, 9.952E+03},
-        {8.852E-02, 3.086E+01, 8.900E-01, 0.123E+00, 0.081E+00, 1.221E-12, 3.100E-03, 9.558E-04, 3.451E-03, 9.952E+03},
-        {1.902E-01, 5.078E+01, 9.900E-01, 0.123E+00, 0.101E+00, 1.221E-11, 2.100E-03, 9.558E-04, 4.135E-03, 9.952E+03},
+        {4.056E-03, 1.021E+01, 8.852E-01, 0.174E+00, 0.021E+00, 1.221E-14, 5.100E-03, 9.558E-04,
+         1.234E-03, 9.952E+03},
+        {6.852E-02, 2.022E+01, 8.852E-01, 0.374E+00, 0.042E+00, 1.221E-13, 4.100E-03, 9.558E-04,
+         2.670E-03, 9.952E+03},
+        {8.852E-02, 3.086E+01, 8.900E-01, 0.123E+00, 0.081E+00, 1.221E-12, 3.100E-03, 9.558E-04,
+         3.451E-03, 9.952E+03},
+        {1.902E-01, 5.078E+01, 9.900E-01, 0.123E+00, 0.101E+00, 1.221E-11, 2.100E-03, 9.558E-04,
+         4.135E-03, 9.952E+03},
 
-        {2.201E-01, 1.300E+02, 0.100E+01, 0.174E+00, 0.112E+00, 1.221E-10, 1.100E-03, 2.558E-05, 5.672E-03, 9.952E+04},
-        {3.502E-01, 2.409E+02, 0.100E+01, 0.374E+00, 0.140E+00, 1.221E-09, 8.100E-04, 2.558E-05, 6.432E-03, 9.952E+04},
-        {4.852E-01, 3.490E+02, 0.100E+01, 0.123E+00, 0.210E+00, 1.221E-08, 4.100E-04, 2.558E-05, 7.412E-03, 9.952E+04},
-        {5.852E-01, 4.690E+02, 0.100E+01, 0.123E+00, 0.321E+00, 1.221E-07, 2.100E-04, 2.558E-05, 8.021E-03, 9.952E+04},
+        {2.201E-01, 1.300E+02, 0.100E+01, 0.174E+00, 0.112E+00, 1.221E-10, 1.100E-03, 2.558E-05,
+         5.672E-03, 9.952E+04},
+        {3.502E-01, 2.409E+02, 0.100E+01, 0.374E+00, 0.140E+00, 1.221E-09, 8.100E-04, 2.558E-05,
+         6.432E-03, 9.952E+04},
+        {4.852E-01, 3.490E+02, 0.100E+01, 0.123E+00, 0.210E+00, 1.221E-08, 4.100E-04, 2.558E-05,
+         7.412E-03, 9.952E+04},
+        {5.852E-01, 4.690E+02, 0.100E+01, 0.123E+00, 0.321E+00, 1.221E-07, 2.100E-04, 2.558E-05,
+         8.021E-03, 9.952E+04},
 
-        {6.852E-01, 5.021E+02, 0.950E+00, 0.150E+00, 0.432E+00, 1.221E-06, 9.952E-05, 4.596E-05, 9.834E-03, 1.734E+04},
-        {7.852E-01, 6.213E+02, 0.950E+00, 0.374E+00, 0.543E+00, 1.221E-05, 4.952E-05, 4.596E-05, 1.213E-02, 1.734E+04},
-        {8.852E-01, 7.012E+02, 0.950E+00, 0.123E+00, 0.671E+00, 1.221E-04, 1.952E-05, 4.596E-05, 1.346E-02, 1.734E+04},
-        {9.852E-01, 8.123E+02, 0.950E+00, 0.123E+00, 0.982E+00, 1.221E-03, 9.952E-06, 4.596E-05, 3.589E-02, 1.734E+04},
+        {6.852E-01, 5.021E+02, 0.950E+00, 0.150E+00, 0.432E+00, 1.221E-06, 9.952E-05, 4.596E-05,
+         9.834E-03, 1.734E+04},
+        {7.852E-01, 6.213E+02, 0.950E+00, 0.374E+00, 0.543E+00, 1.221E-05, 4.952E-05, 4.596E-05,
+         1.213E-02, 1.734E+04},
+        {8.852E-01, 7.012E+02, 0.950E+00, 0.123E+00, 0.671E+00, 1.221E-04, 1.952E-05, 4.596E-05,
+         1.346E-02, 1.734E+04},
+        {9.852E-01, 8.123E+02, 0.950E+00, 0.123E+00, 0.982E+00, 1.221E-03, 9.952E-06, 4.596E-05,
+         3.589E-02, 1.734E+04},
 
-        {1.002E+01, 9.321E+02, 1.069E+00, 0.174E+00, 1.201E+00, 1.221E-02, 6.952E-06, 6.596E-05, 6.982E-02, 1.734E+04},
-        {1.152E+01, 1.023E+03, 1.069E+00, 0.374E+00, 1.678E+00, 1.221E-02, 3.952E-06, 6.596E-05, 9.234E-02, 1.734E+04},
-        {1.252E+01, 2.012E+03, 1.069E+00, 0.123E+00, 2.312E+00, 1.221E-02, 1.952E-06, 6.596E-05, 2.345E-01, 1.734E+04},
-        {1.352E+01, 3.210E+03, 1.069E+00, 0.123E+00, 3.456E+00, 1.221E-02, 9.952E-07, 6.596E-05, 4.532E-01, 1.734E+04}};
+        {1.002E+01, 9.321E+02, 1.069E+00, 0.174E+00, 1.201E+00, 1.221E-02, 6.952E-06, 6.596E-05,
+         6.982E-02, 1.734E+04},
+        {1.152E+01, 1.023E+03, 1.069E+00, 0.374E+00, 1.678E+00, 1.221E-02, 3.952E-06, 6.596E-05,
+         9.234E-02, 1.734E+04},
+        {1.252E+01, 2.012E+03, 1.069E+00, 0.123E+00, 2.312E+00, 1.221E-02, 1.952E-06, 6.596E-05,
+         2.345E-01, 1.734E+04},
+        {1.352E+01, 3.210E+03, 1.069E+00, 0.123E+00, 3.456E+00, 1.221E-02, 9.952E-07, 6.596E-05,
+         4.532E-01, 1.734E+04}};
 
     // Read baseline data
     if (this->m_baseline_action == COMPARE) {
@@ -66,7 +84,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceRelaxationTimescale :
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack rho, temp, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv, mu, sc, qi_incld, ni_incld;
+          Spack rho, temp, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt, dv, mu, sc,
+              qi_incld, ni_incld;
 
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             rho[s]                       = self_device(vs).rho;
@@ -83,8 +102,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceRelaxationTimescale :
 
           Spack epsi{0.0};
           Spack epsi_tot{0.0};
-          Functions::ice_relaxation_timescale(rho, temp, rhofaci, table_val_qi2qr_melting, table_val_qi2qr_vent_melt,
-                                              dv, mu, sc, qi_incld, ni_incld, epsi, epsi_tot);
+          Functions::ice_relaxation_timescale(rho, temp, rhofaci, table_val_qi2qr_melting,
+                                              table_val_qi2qr_vent_melt, dv, mu, sc, qi_incld,
+                                              ni_incld, epsi, epsi_tot);
 
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             self_device(vs).epsi     = epsi[s];
@@ -118,7 +138,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceRelaxationTimescale :
 namespace {
 
 TEST_CASE("p3_ice_relaxation_timescale", "[p3_functions]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestIceRelaxationTimescale;
+  using T =
+      scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestIceRelaxationTimescale;
 
   T t;
   t.run_ice_relaxation_timescale_phys();
diff --git i/components/eamxx/src/physics/p3/tests/p3_ice_sed_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_ice_sed_unit_tests.cpp
index 0660d8c445..a5796476c8 100644
--- i/components/eamxx/src/physics/p3/tests/p3_ice_sed_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_ice_sed_unit_tests.cpp
@@ -17,7 +17,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestIceSed : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestIceSed : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys_calc_bulk_rhime() {
     // TODO
@@ -84,8 +85,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceSed : public UnitWrap
           }
 
           Smask gt_small(qi_tot > qsmall);
-          Spack rho_rime = Functions::calc_bulk_rho_rime(qi_tot, qi_rim, bi_rim,
-                                                         p3::Functions<Real, DefaultDevice>::P3Runtime(), gt_small);
+          Spack rho_rime = Functions::calc_bulk_rho_rime(
+              qi_tot, qi_rim, bi_rim, p3::Functions<Real, DefaultDevice>::P3Runtime(), gt_small);
 
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
@@ -148,9 +149,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceSed : public UnitWrap
 
     // Get data from cxx
     for (auto &d : isds_cxx) {
-      ice_sedimentation_host(d.kts, d.kte, d.ktop, d.kbot, d.kdir, d.rho, d.inv_rho, d.rhofaci, d.cld_frac_i, d.inv_dz,
-                             d.dt, d.inv_dt, d.qi, d.qi_incld, d.ni, d.qm, d.qm_incld, d.bm, d.bm_incld, d.ni_incld,
-                             &d.precip_ice_surf, d.qi_tend, d.ni_tend);
+      ice_sedimentation_host(d.kts, d.kte, d.ktop, d.kbot, d.kdir, d.rho, d.inv_rho, d.rhofaci,
+                             d.cld_frac_i, d.inv_dz, d.dt, d.inv_dt, d.qi, d.qi_incld, d.ni, d.qm,
+                             d.qm_incld, d.bm, d.bm_incld, d.ni_incld, &d.precip_ice_surf,
+                             d.qi_tend, d.ni_tend);
     }
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
@@ -197,7 +199,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceSed : public UnitWrap
     // Set up random input data
     for (auto &d : hfds_baseline) {
       const auto qsmall_r = std::make_pair(C::QSMALL / 2, C::QSMALL * 2);
-      d.randomize(engine, {{d.T_atm, {C::T_homogfrz - 10, C::T_homogfrz + 10}}, {d.qc, qsmall_r}, {d.qr, qsmall_r}});
+      d.randomize(engine, {{d.T_atm, {C::T_homogfrz - 10, C::T_homogfrz + 10}},
+                           {d.qc, qsmall_r},
+                           {d.qr, qsmall_r}});
 
       // C++ impl uses constants for latent_heat values. Manually set here
       // so F90 can match
@@ -224,8 +228,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceSed : public UnitWrap
 
     // Get data from cxx
     for (auto &d : hfds_cxx) {
-      homogeneous_freezing_host(d.kts, d.kte, d.ktop, d.kbot, d.kdir, d.T_atm, d.inv_exner, d.qc, d.nc, d.qr, d.nr,
-                                d.qi, d.ni, d.qm, d.bm, d.th_atm);
+      homogeneous_freezing_host(d.kts, d.kte, d.ktop, d.kbot, d.kdir, d.T_atm, d.inv_exner, d.qc,
+                                d.nc, d.qr, d.nr, d.qi, d.ni, d.qm, d.bm, d.th_atm);
     }
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
diff --git i/components/eamxx/src/physics/p3/tests/p3_ice_supersat_conservation_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_ice_supersat_conservation_tests.cpp
index 671f0fd2be..44fe30893c 100644
--- i/components/eamxx/src/physics/p3/tests/p3_ice_supersat_conservation_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_ice_supersat_conservation_tests.cpp
@@ -12,7 +12,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestIceSupersatConservation : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestIceSupersatConservation : public UnitWrap::UnitTest<D>::Base {
 
   void run_bfb() {
     constexpr Scalar latvap = C::LatVap;
@@ -32,8 +33,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceSupersatConservation
       d.latent_heat_sublim = latvap + latice;
     }
 
-    // Create copies of data for use by cxx and sync it to device. Needs to happen before reads so that
-    // inout data is in original state
+    // Create copies of data for use by cxx and sync it to device. Needs to happen before reads so
+    // that inout data is in original state
     view_1d<IceSupersatConservationData> cxx_device("cxx_device", max_pack_size);
     const auto cxx_host = Kokkos::create_mirror_view(cxx_device);
     std::copy(&baseline_data[0], &baseline_data[0] + max_pack_size, cxx_host.data());
@@ -52,7 +53,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceSupersatConservation
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack cld_frac_i, qidep, qinuc, qinuc_cnt, qv, qv_sat_i, t_atm, qi2qv_sublim_tend, qr2qv_evap_tend;
+          Spack cld_frac_i, qidep, qinuc, qinuc_cnt, qv, qv_sat_i, t_atm, qi2qv_sublim_tend,
+              qr2qv_evap_tend;
           Smask context;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             cld_frac_i[s]        = cxx_device(vs).cld_frac_i;
@@ -67,9 +69,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceSupersatConservation
             context.set(s, cxx_device(vs).context);
           }
           const bool use_hetfrz_classnuc = false;
-          Functions::ice_supersat_conservation(qidep, qinuc, qinuc_cnt, cld_frac_i, qv, qv_sat_i, t_atm,
-                                               cxx_device(offset).dt, qi2qv_sublim_tend, qr2qv_evap_tend,
-                                               use_hetfrz_classnuc, context);
+          Functions::ice_supersat_conservation(qidep, qinuc, qinuc_cnt, cld_frac_i, qv, qv_sat_i,
+                                               t_atm, cxx_device(offset).dt, qi2qv_sublim_tend,
+                                               qr2qv_evap_tend, use_hetfrz_classnuc, context);
 
           // Copy spacks back into cxx_device view
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
@@ -103,7 +105,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIceSupersatConservation
 namespace {
 
 TEST_CASE("ice_supersat_conservation_bfb", "[p3]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestIceSupersatConservation;
+  using T =
+      scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestIceSupersatConservation;
 
   T t;
   t.run_bfb();
diff --git i/components/eamxx/src/physics/p3/tests/p3_ice_tables_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_ice_tables_unit_tests.cpp
index 9d59cf9f22..9da9b8367f 100644
--- i/components/eamxx/src/physics/p3/tests/p3_ice_tables_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_ice_tables_unit_tests.cpp
@@ -21,7 +21,8 @@ namespace unit_test {
  * Unit-tests for p3 ice table functions.
  */
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestTableIce : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestTableIce : public UnitWrap::UnitTest<D>::Base {
 
   template <typename View> void init_table_linear_dimension(View &table, int linear_dimension) {
     // set up views
@@ -80,28 +81,32 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestTableIce : public UnitWr
         {0.971E-07, 0.657E+06, 0.971E-07, 0.200E+04}, {0.510E-02, 0.454E+06, 0.714E-05, 0.500E+02},
         {0.500E-07, 0.545E+06, 0.000E+00, 0.000E+00}, {0.136E-08, 0.487E+06, 0.811E-10, 0.500E+02}};
 
-    LookupIceDataB lidb[max_pack_size] = {
-        // qr,      nr
-        {0.263E-05, 0.100E+07}, {0.100E-01, 0.100E+07}, {0.000E+00, 0.100E-15}, {0.263E-05, 0.100E+07},
+    LookupIceDataB lidb[max_pack_size] = {// qr,      nr
+                                          {0.263E-05, 0.100E+07}, {0.100E-01, 0.100E+07},
+                                          {0.000E+00, 0.100E-15}, {0.263E-05, 0.100E+07},
 
-        {0.263E-05, 0.100E+07}, {0.100E-01, 0.100E+07}, {0.000E+00, 0.0},       {0.263E-05, 0.100E+07},
+                                          {0.263E-05, 0.100E+07}, {0.100E-01, 0.100E+07},
+                                          {0.000E+00, 0.0},       {0.263E-05, 0.100E+07},
 
-        {0.263E-05, 0.100E+07}, {0.100E-01, 0.100E+07}, {0.000E+00, 0.100E-15}, {0.263E-05, 0.100E+07},
+                                          {0.263E-05, 0.100E+07}, {0.100E-01, 0.100E+07},
+                                          {0.000E+00, 0.100E-15}, {0.263E-05, 0.100E+07},
 
-        {0.263E-05, 0.100E+07}, {0.100E-01, 0.100E+07}, {0.000E+00, 0.100E-15}, {0.263E-05, 0.100E+07}};
+                                          {0.263E-05, 0.100E+07}, {0.100E-01, 0.100E+07},
+                                          {0.000E+00, 0.100E-15}, {0.263E-05, 0.100E+07}};
 
     static constexpr Int access_table_index   = 2;
-    AccessLookupTableData altd[max_pack_size] = {{lid[0], access_table_index},  {lid[1], access_table_index},
-                                                 {lid[2], access_table_index},  {lid[3], access_table_index},
+    AccessLookupTableData altd[max_pack_size] = {
+        {lid[0], access_table_index},  {lid[1], access_table_index},
+        {lid[2], access_table_index},  {lid[3], access_table_index},
 
-                                                 {lid[4], access_table_index},  {lid[5], access_table_index},
-                                                 {lid[6], access_table_index},  {lid[7], access_table_index},
+        {lid[4], access_table_index},  {lid[5], access_table_index},
+        {lid[6], access_table_index},  {lid[7], access_table_index},
 
-                                                 {lid[8], access_table_index},  {lid[9], access_table_index},
-                                                 {lid[10], access_table_index}, {lid[11], access_table_index},
+        {lid[8], access_table_index},  {lid[9], access_table_index},
+        {lid[10], access_table_index}, {lid[11], access_table_index},
 
-                                                 {lid[12], access_table_index}, {lid[13], access_table_index},
-                                                 {lid[14], access_table_index}, {lid[15], access_table_index}};
+        {lid[12], access_table_index}, {lid[13], access_table_index},
+        {lid[14], access_table_index}, {lid[15], access_table_index}};
 
     AccessLookupTableCollData altcd[max_pack_size] = {
         {lid[0], lidb[0], access_table_index},   {lid[1], lidb[1], access_table_index},
@@ -159,9 +164,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestTableIce : public UnitWr
           Smask qiti_gt_small(qi > qsmall);
           Functions::lookup_ice(qi, ni, qm, rhop, ti, qiti_gt_small);
           Functions::lookup_rain(qr, nr, tr, qiti_gt_small);
-          Spack ice_result = Functions::apply_table_ice(access_table_index - 1, ice_table_vals, ti, qiti_gt_small);
-          Spack rain_result =
-              Functions::apply_table_coll(access_table_index - 1, collect_table_vals, ti, tr, qiti_gt_small);
+          Spack ice_result =
+              Functions::apply_table_ice(access_table_index - 1, ice_table_vals, ti, qiti_gt_small);
+          Spack rain_result = Functions::apply_table_coll(
+              access_table_index - 1, collect_table_vals, ti, tr, qiti_gt_small);
 
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             int_results(0, vs) = ti.dumi[s];
diff --git i/components/eamxx/src/physics/p3/tests/p3_incloud_mixingratios_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_incloud_mixingratios_unit_tests.cpp
index 31c44f0bbc..f036278258 100644
--- i/components/eamxx/src/physics/p3/tests/p3_incloud_mixingratios_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_incloud_mixingratios_unit_tests.cpp
@@ -18,7 +18,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestIncloudMixing : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestIncloudMixing : public UnitWrap::UnitTest<D>::Base {
 
   void run_incloud_mixing_bfb() {
     using KTH = KokkosTypes<HostDevice>;
@@ -26,20 +27,22 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIncloudMixing : public U
     constexpr Scalar qsmall = C::QSMALL;
     constexpr Scalar qc0 = 0.1 * qsmall, qc1 = 0.9 * qsmall, qc2 = 2. * qsmall, qc3 = 100. * qsmall;
     constexpr Scalar qr0 = 0.3 * qsmall, qr1 = 0.6 * qsmall, qr2 = 5. * qsmall, qr3 = 200. * qsmall;
-    constexpr Scalar qi0 = 0.1 * qsmall, qi1 = 0.5 * qsmall, qi2 = 12. * qsmall, qi3 = 300. * qsmall;
-    constexpr Scalar qm0 = 0.1 * qsmall, qm1 = 0.5 * qsmall, qm2 = 12. * qsmall, qm3 = 300. * qsmall;
+    constexpr Scalar qi0 = 0.1 * qsmall, qi1 = 0.5 * qsmall, qi2 = 12. * qsmall,
+                     qi3 = 300. * qsmall;
+    constexpr Scalar qm0 = 0.1 * qsmall, qm1 = 0.5 * qsmall, qm2 = 12. * qsmall,
+                     qm3 = 300. * qsmall;
 
     constexpr Scalar nc0 = 1.052E+05, nc1 = 4.952E+06, nc2 = 1.340E+07, nc3 = 9.652E+08;
     constexpr Scalar nr0 = 2.052E+05, nr1 = 5.952E+06, nr2 = 2.340E+07, nr3 = 8.652E+08;
     constexpr Scalar ni0 = 3.052E+05, ni1 = 6.952E+06, ni2 = 3.340E+07, ni3 = 7.652E+08;
     constexpr Scalar bm0 = 4.052E+05, bm1 = 7.952E+06, bm2 = 4.340E+07, bm3 = 6.652E+08;
 
-    constexpr Scalar inv_cld_frac_l0 = 1.052E+01, inv_cld_frac_l1 = 2.952E+02, inv_cld_frac_l2 = 1.340E+03,
-                     inv_cld_frac_l3 = 1.652E+04;
-    constexpr Scalar inv_cld_frac_i0 = 2.052E+01, inv_cld_frac_i1 = 4.952E+02, inv_cld_frac_i2 = 3.340E+03,
-                     inv_cld_frac_i3 = 2.652E+04;
-    constexpr Scalar inv_cld_frac_r0 = 3.052E+01, inv_cld_frac_r1 = 5.952E+02, inv_cld_frac_r2 = 3.340E+03,
-                     inv_cld_frac_r3 = 3.652E+04;
+    constexpr Scalar inv_cld_frac_l0 = 1.052E+01, inv_cld_frac_l1 = 2.952E+02,
+                     inv_cld_frac_l2 = 1.340E+03, inv_cld_frac_l3 = 1.652E+04;
+    constexpr Scalar inv_cld_frac_i0 = 2.052E+01, inv_cld_frac_i1 = 4.952E+02,
+                     inv_cld_frac_i2 = 3.340E+03, inv_cld_frac_i3 = 2.652E+04;
+    constexpr Scalar inv_cld_frac_r0 = 3.052E+01, inv_cld_frac_r1 = 5.952E+02,
+                     inv_cld_frac_r2 = 3.340E+03, inv_cld_frac_r3 = 3.652E+04;
 
     IncloudMixingData self[max_pack_size] = {
         // qc, qr, qi, qm, nc, nr, ni, bm, inv_cld_frac_l, inv_cld_frac_i, inv_cld_frac_r
@@ -61,7 +64,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIncloudMixing : public U
         {qc3, qr2, qi1, qm3, nc2, nr1, ni2, bm1, inv_cld_frac_l1, inv_cld_frac_i3, inv_cld_frac_r1},
         {qc2, qr3, qi2, qm2, nc3, nr2, ni1, bm2, inv_cld_frac_l3, inv_cld_frac_i1, inv_cld_frac_r2},
         {qc0, qr0, qi3, qm1, nc0, nr3, ni3, bm3, inv_cld_frac_l2, inv_cld_frac_i0, inv_cld_frac_r3},
-        {qc1, qr1, qi0, qm0, nc1, nr0, ni0, bm0, inv_cld_frac_l0, inv_cld_frac_i2, inv_cld_frac_r0}};
+        {qc1, qr1, qi0, qm0, nc1, nr0, ni0, bm0, inv_cld_frac_l0, inv_cld_frac_i2,
+         inv_cld_frac_r0}};
 
     // Sync to device
     KTH::view_1d<IncloudMixingData> self_host("self_host", max_pack_size);
@@ -100,9 +104,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestIncloudMixing : public U
           Spack qc_incld{0.}, qr_incld{0.}, qi_incld{0.}, qm_incld{0.};
           Spack nc_incld{0.}, nr_incld{0.}, ni_incld{0.}, bm_incld{0.};
 
-          Functions::calculate_incloud_mixingratios(qc, qr, qi, qm, nc, nr, ni, bm, inv_cld_frac_l, inv_cld_frac_i,
-                                                    inv_cld_frac_r, qc_incld, qr_incld, qi_incld, qm_incld, nc_incld,
-                                                    nr_incld, ni_incld, bm_incld);
+          Functions::calculate_incloud_mixingratios(
+              qc, qr, qi, qm, nc, nr, ni, bm, inv_cld_frac_l, inv_cld_frac_i, inv_cld_frac_r,
+              qc_incld, qr_incld, qi_incld, qm_incld, nc_incld, nr_incld, ni_incld, bm_incld);
 
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             self_device(vs).qc_incld = qc_incld[s];
diff --git i/components/eamxx/src/physics/p3/tests/p3_main_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_main_unit_tests.cpp
index f324684435..9b454fa3ef 100644
--- i/components/eamxx/src/physics/p3/tests/p3_main_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_main_unit_tests.cpp
@@ -17,7 +17,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys_p3_main_part1() {
     // TODO
@@ -45,8 +46,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap
   void run_bfb_p3_main_part1() {
     auto engine = Base::get_engine();
 
-    constexpr Scalar qsmall = C::QSMALL; // PMC wouldn't it make more sense to define qsmall at a higher level since
-                                         // used in part1, part2, and part3?
+    constexpr Scalar qsmall = C::QSMALL; // PMC wouldn't it make more sense to define qsmall at a
+                                         // higher level since used in part1, part2, and part3?
     constexpr Scalar T_zerodegc = C::T_zerodegc;
     constexpr Scalar sup_upper  = -0.05;
     constexpr Scalar sup_lower  = -0.1;
@@ -64,7 +65,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap
     static constexpr Int num_runs = sizeof(isds_baseline) / sizeof(P3MainPart1Data);
 
     for (auto &d : isds_baseline) {
-      const auto qsmall_r = std::make_pair(0, qsmall * 2); // PMC this range seems inappropriately small
+      const auto qsmall_r =
+          std::make_pair(0, qsmall * 2); // PMC this range seems inappropriately small
       d.randomize(engine, {{d.T_atm, {T_zerodegc - 10, T_zerodegc + 10}},
                            {d.qv_supersat_i, {sup_lower - .05, sup_upper + .05}},
                            {d.qc, qsmall_r},
@@ -98,12 +100,14 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap
 
     // Get data from cxx
     for (auto &d : isds_cxx) {
-      p3_main_part1_host(d.kts, d.kte, d.ktop, d.kbot, d.kdir, d.do_predict_nc, d.do_prescribed_CCN, d.dt, d.pres,
-                         d.dpres, d.dz, d.nc_nuceat_tend, d.nccn_prescribed, d.inv_exner, d.exner, d.inv_cld_frac_l,
-                         d.inv_cld_frac_i, d.inv_cld_frac_r, d.T_atm, d.rho, d.inv_rho, d.qv_sat_l, d.qv_sat_i,
-                         d.qv_supersat_i, d.rhofacr, d.rhofaci, d.acn, d.qv, d.th_atm, d.qc, d.nc, d.qr, d.nr, d.qi,
-                         d.ni, d.qm, d.bm, d.qc_incld, d.qr_incld, d.qi_incld, d.qm_incld, d.nc_incld, d.nr_incld,
-                         d.ni_incld, d.bm_incld, &d.is_nucleat_possible, &d.is_hydromet_present);
+      p3_main_part1_host(d.kts, d.kte, d.ktop, d.kbot, d.kdir, d.do_predict_nc, d.do_prescribed_CCN,
+                         d.dt, d.pres, d.dpres, d.dz, d.nc_nuceat_tend, d.nccn_prescribed,
+                         d.inv_exner, d.exner, d.inv_cld_frac_l, d.inv_cld_frac_i, d.inv_cld_frac_r,
+                         d.T_atm, d.rho, d.inv_rho, d.qv_sat_l, d.qv_sat_i, d.qv_supersat_i,
+                         d.rhofacr, d.rhofaci, d.acn, d.qv, d.th_atm, d.qc, d.nc, d.qr, d.nr, d.qi,
+                         d.ni, d.qm, d.bm, d.qc_incld, d.qr_incld, d.qi_incld, d.qm_incld,
+                         d.nc_incld, d.nr_incld, d.ni_incld, d.bm_incld, &d.is_nucleat_possible,
+                         &d.is_hydromet_present);
     }
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
@@ -170,9 +174,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap
     std::vector<Real> hetfrz_immersion_nucleation_tend(72, 0.0);
     std::vector<Real> hetfrz_contact_nucleation_tend(72, 0.0);
     std::vector<Real> hetfrz_deposition_nucleation_tend(72, 0.0);
-    std::vector<Real> qr2qv_evap(72, 0.0), qi2qv_sublim(72, 0.0), qc2qr_accret(72, 0.0), qc2qr_autoconv(72, 0.0),
-        qv2qi_vapdep(72, 0.0), qc2qi_berg(72, 0.0), qc2qr_ice_shed(72, 0.0), qc2qi_collect(72, 0.0),
-        qr2qi_collect(72, 0.0), qc2qi_hetero_freeze(72, 0.0), qr2qi_immers_freeze(72, 0.0), qi2qr_melt(72, 0.0);
+    std::vector<Real> qr2qv_evap(72, 0.0), qi2qv_sublim(72, 0.0), qc2qr_accret(72, 0.0),
+        qc2qr_autoconv(72, 0.0), qv2qi_vapdep(72, 0.0), qc2qi_berg(72, 0.0),
+        qc2qr_ice_shed(72, 0.0), qc2qi_collect(72, 0.0), qr2qi_collect(72, 0.0),
+        qc2qi_hetero_freeze(72, 0.0), qr2qi_immers_freeze(72, 0.0), qi2qr_melt(72, 0.0);
     static constexpr Int num_runs = sizeof(isds_baseline) / sizeof(P3MainPart2Data);
 
     for (auto &d : isds_baseline) {
@@ -212,18 +217,21 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap
     // Get data from cxx
     for (auto &d : isds_cxx) {
       p3_main_part2_host(
-          d.kts, d.kte, d.kbot, d.ktop, d.kdir, d.do_predict_nc, d.do_prescribed_CCN, d.dt, d.inv_dt,
-          hetfrz_immersion_nucleation_tend.data(), hetfrz_contact_nucleation_tend.data(),
-          hetfrz_deposition_nucleation_tend.data(), d.pres, d.dpres, d.dz, d.nc_nuceat_tend, d.inv_exner, d.exner,
-          d.inv_cld_frac_l, d.inv_cld_frac_i, d.inv_cld_frac_r, d.ni_activated, d.inv_qc_relvar, d.cld_frac_i,
-          d.cld_frac_l, d.cld_frac_r, d.qv_prev, d.t_prev, d.T_atm, d.rho, d.inv_rho, d.qv_sat_l, d.qv_sat_i,
-          d.qv_supersat_i, d.rhofacr, d.rhofaci, d.acn, d.qv, d.th_atm, d.qc, d.nc, d.qr, d.nr, d.qi, d.ni, d.qm, d.bm,
-          d.qc_incld, d.qr_incld, d.qi_incld, d.qm_incld, d.nc_incld, d.nr_incld, d.ni_incld, d.bm_incld, d.mu_c, d.nu,
-          d.lamc, d.cdist, d.cdist1, d.cdistr, d.mu_r, d.lamr, d.logn0r, d.qv2qi_depos_tend, d.precip_total_tend,
-          d.nevapr, d.qr_evap_tend, d.vap_liq_exchange, d.vap_ice_exchange, d.liq_ice_exchange, qr2qv_evap.data(),
-          qi2qv_sublim.data(), qc2qr_accret.data(), qc2qr_autoconv.data(), qv2qi_vapdep.data(), qc2qi_berg.data(),
-          qc2qr_ice_shed.data(), qc2qi_collect.data(), qr2qi_collect.data(), qc2qi_hetero_freeze.data(),
-          qr2qi_immers_freeze.data(), qi2qr_melt.data(), d.pratot, d.prctot, &d.is_hydromet_present);
+          d.kts, d.kte, d.kbot, d.ktop, d.kdir, d.do_predict_nc, d.do_prescribed_CCN, d.dt,
+          d.inv_dt, hetfrz_immersion_nucleation_tend.data(), hetfrz_contact_nucleation_tend.data(),
+          hetfrz_deposition_nucleation_tend.data(), d.pres, d.dpres, d.dz, d.nc_nuceat_tend,
+          d.inv_exner, d.exner, d.inv_cld_frac_l, d.inv_cld_frac_i, d.inv_cld_frac_r,
+          d.ni_activated, d.inv_qc_relvar, d.cld_frac_i, d.cld_frac_l, d.cld_frac_r, d.qv_prev,
+          d.t_prev, d.T_atm, d.rho, d.inv_rho, d.qv_sat_l, d.qv_sat_i, d.qv_supersat_i, d.rhofacr,
+          d.rhofaci, d.acn, d.qv, d.th_atm, d.qc, d.nc, d.qr, d.nr, d.qi, d.ni, d.qm, d.bm,
+          d.qc_incld, d.qr_incld, d.qi_incld, d.qm_incld, d.nc_incld, d.nr_incld, d.ni_incld,
+          d.bm_incld, d.mu_c, d.nu, d.lamc, d.cdist, d.cdist1, d.cdistr, d.mu_r, d.lamr, d.logn0r,
+          d.qv2qi_depos_tend, d.precip_total_tend, d.nevapr, d.qr_evap_tend, d.vap_liq_exchange,
+          d.vap_ice_exchange, d.liq_ice_exchange, qr2qv_evap.data(), qi2qv_sublim.data(),
+          qc2qr_accret.data(), qc2qr_autoconv.data(), qv2qi_vapdep.data(), qc2qi_berg.data(),
+          qc2qr_ice_shed.data(), qc2qi_collect.data(), qr2qi_collect.data(),
+          qc2qi_hetero_freeze.data(), qr2qi_immers_freeze.data(), qi2qr_melt.data(), d.pratot,
+          d.prctot, &d.is_hydromet_present);
     }
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
@@ -337,9 +345,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap
 
     // Get data from cxx
     for (auto &d : isds_cxx) {
-      p3_main_part3_host(d.kts, d.kte, d.kbot, d.ktop, d.kdir, d.inv_exner, d.cld_frac_l, d.cld_frac_r, d.cld_frac_i,
-                         d.rho, d.inv_rho, d.rhofaci, d.qv, d.th_atm, d.qc, d.nc, d.qr, d.nr, d.qi, d.ni, d.qm, d.bm,
-                         d.mu_c, d.nu, d.lamc, d.mu_r, d.lamr, d.vap_liq_exchange, d.ze_rain, d.ze_ice, d.diag_vm_qi,
+      p3_main_part3_host(d.kts, d.kte, d.kbot, d.ktop, d.kdir, d.inv_exner, d.cld_frac_l,
+                         d.cld_frac_r, d.cld_frac_i, d.rho, d.inv_rho, d.rhofaci, d.qv, d.th_atm,
+                         d.qc, d.nc, d.qr, d.nr, d.qi, d.ni, d.qm, d.bm, d.mu_c, d.nu, d.lamc,
+                         d.mu_r, d.lamr, d.vap_liq_exchange, d.ze_rain, d.ze_ice, d.diag_vm_qi,
                          d.diag_eff_radius_qi, d.diag_diam_qi, d.rho_qi, d.diag_equiv_reflectivity,
                          d.diag_eff_radius_qc, d.diag_eff_radius_qr);
     }
@@ -376,7 +385,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap
           REQUIRE(isds_baseline[i].diag_eff_radius_qi[k] == isds_cxx[i].diag_eff_radius_qi[k]);
           REQUIRE(isds_baseline[i].diag_diam_qi[k] == isds_cxx[i].diag_diam_qi[k]);
           REQUIRE(isds_baseline[i].rho_qi[k] == isds_cxx[i].rho_qi[k]);
-          REQUIRE(isds_baseline[i].diag_equiv_reflectivity[k] == isds_cxx[i].diag_equiv_reflectivity[k]);
+          REQUIRE(isds_baseline[i].diag_equiv_reflectivity[k] ==
+                  isds_cxx[i].diag_equiv_reflectivity[k]);
           REQUIRE(isds_baseline[i].diag_eff_radius_qc[k] == isds_cxx[i].diag_eff_radius_qc[k]);
           REQUIRE(isds_baseline[i].diag_eff_radius_qr[k] == isds_cxx[i].diag_eff_radius_qr[k]);
         }
@@ -400,29 +410,30 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap
     static constexpr Int num_runs = sizeof(isds_baseline) / sizeof(P3MainData);
 
     for (auto &d : isds_baseline) {
-      d.randomize(engine, {{d.pres, {1.00000000E+02, 9.87111111E+04}},
-                           {d.dz, {1.22776609E+02, 3.49039167E+04}},
-                           {d.nc_nuceat_tend, {0, 0}},
-                           {d.nccn_prescribed, {0, 0}},
-                           {d.ni_activated, {0, 0}},
-                           {d.dpres, {1.37888889E+03, 1.39888889E+03}},
-                           {d.inv_exner, {1.00371345E+00, 3.19721007E+00}},
-                           {d.cld_frac_i, {1, 1}},
-                           {d.cld_frac_l, {1, 1}},
-                           {d.cld_frac_r, {1, 1}},
-                           {d.inv_qc_relvar, {1, 1}},
-                           {d.qc, {0, 1.00000000E-04}},
-                           {d.nc, {1.00000000E+06, 1.00000000E+06}},
-                           {d.qr, {0, 1.00000000E-05}},
-                           {d.nr, {1.00000000E+06, 1.00000000E+06}},
-                           {d.qi, {0, 1.00000000E-04}},
-                           {d.qm, {0, 1.00000000E-04}},
-                           {d.ni, {1.00000000E+06, 1.00000000E+06}},
-                           {d.bm, {0, 1.00000000E-02}},
-                           {d.qv, {0, 5.00000000E-02}},
-                           {d.qv_prev, {0, 5.00000000E-02}},
-                           {d.th_atm, {6.72653866E+02, 1.07954335E+03}}, // PMC - this range seems insane
-                           {d.t_prev, {1.50000000E+02, 3.50000000E+02}}});
+      d.randomize(engine,
+                  {{d.pres, {1.00000000E+02, 9.87111111E+04}},
+                   {d.dz, {1.22776609E+02, 3.49039167E+04}},
+                   {d.nc_nuceat_tend, {0, 0}},
+                   {d.nccn_prescribed, {0, 0}},
+                   {d.ni_activated, {0, 0}},
+                   {d.dpres, {1.37888889E+03, 1.39888889E+03}},
+                   {d.inv_exner, {1.00371345E+00, 3.19721007E+00}},
+                   {d.cld_frac_i, {1, 1}},
+                   {d.cld_frac_l, {1, 1}},
+                   {d.cld_frac_r, {1, 1}},
+                   {d.inv_qc_relvar, {1, 1}},
+                   {d.qc, {0, 1.00000000E-04}},
+                   {d.nc, {1.00000000E+06, 1.00000000E+06}},
+                   {d.qr, {0, 1.00000000E-05}},
+                   {d.nr, {1.00000000E+06, 1.00000000E+06}},
+                   {d.qi, {0, 1.00000000E-04}},
+                   {d.qm, {0, 1.00000000E-04}},
+                   {d.ni, {1.00000000E+06, 1.00000000E+06}},
+                   {d.bm, {0, 1.00000000E-02}},
+                   {d.qv, {0, 5.00000000E-02}},
+                   {d.qv_prev, {0, 5.00000000E-02}},
+                   {d.th_atm, {6.72653866E+02, 1.07954335E+03}}, // PMC - this range seems insane
+                   {d.t_prev, {1.50000000E+02, 3.50000000E+02}}});
     }
 
     // Create copies of data for use by cxx. Needs to happen before reads so that
@@ -441,12 +452,14 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Main : public UnitWrap
 
     // Get data from cxx
     for (auto &d : isds_cxx) {
-      p3_main_host(d.qc, d.nc, d.qr, d.nr, d.th_atm, d.qv, d.dt, d.qi, d.qm, d.ni, d.bm, d.pres, d.dz, d.nc_nuceat_tend,
-                   d.nccn_prescribed, d.ni_activated, d.inv_qc_relvar, d.it, d.precip_liq_surf, d.precip_ice_surf,
-                   d.its, d.ite, d.kts, d.kte, d.diag_eff_radius_qc, d.diag_eff_radius_qi, d.diag_eff_radius_qr,
-                   d.rho_qi, d.do_predict_nc, d.do_prescribed_CCN, d.use_hetfrz_classnuc, d.dpres, d.inv_exner,
-                   d.qv2qi_depos_tend, d.precip_liq_flux, d.precip_ice_flux, d.cld_frac_r, d.cld_frac_l, d.cld_frac_i,
-                   d.liq_ice_exchange, d.vap_liq_exchange, d.vap_ice_exchange, d.qv_prev, d.t_prev);
+      p3_main_host(d.qc, d.nc, d.qr, d.nr, d.th_atm, d.qv, d.dt, d.qi, d.qm, d.ni, d.bm, d.pres,
+                   d.dz, d.nc_nuceat_tend, d.nccn_prescribed, d.ni_activated, d.inv_qc_relvar, d.it,
+                   d.precip_liq_surf, d.precip_ice_surf, d.its, d.ite, d.kts, d.kte,
+                   d.diag_eff_radius_qc, d.diag_eff_radius_qi, d.diag_eff_radius_qr, d.rho_qi,
+                   d.do_predict_nc, d.do_prescribed_CCN, d.use_hetfrz_classnuc, d.dpres,
+                   d.inv_exner, d.qv2qi_depos_tend, d.precip_liq_flux, d.precip_ice_flux,
+                   d.cld_frac_r, d.cld_frac_l, d.cld_frac_i, d.liq_ice_exchange, d.vap_liq_exchange,
+                   d.vap_ice_exchange, d.qv_prev, d.t_prev);
     }
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
diff --git i/components/eamxx/src/physics/p3/tests/p3_nc_conservation_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_nc_conservation_tests.cpp
index 1a5f7d20c9..3c895ff8d9 100644
--- i/components/eamxx/src/physics/p3/tests/p3_nc_conservation_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_nc_conservation_tests.cpp
@@ -12,7 +12,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestNcConservation : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestNcConservation : public UnitWrap::UnitTest<D>::Base {
 
   void run_bfb() {
     auto engine = Base::get_engine();
@@ -26,8 +27,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestNcConservation : public
       d.dt = baseline_data[0].dt; // Hold this fixed, this is not packed data
     }
 
-    // Create copies of data for use by cxx and sync it to device. Needs to happen before reads so that
-    // inout data is in original state
+    // Create copies of data for use by cxx and sync it to device. Needs to happen before reads so
+    // that inout data is in original state
     view_1d<NcConservationData> cxx_device("cxx_device", max_pack_size);
     const auto cxx_host = Kokkos::create_mirror_view(cxx_device);
     std::copy(&baseline_data[0], &baseline_data[0] + max_pack_size, cxx_host.data());
@@ -46,8 +47,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestNcConservation : public
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack nc, nc2ni_immers_freeze_tend, nc2nr_autoconv_tend, nc_accret_tend, nc_collect_tend, nc_selfcollect_tend,
-              ncheti_cnt, nicnt;
+          Spack nc, nc2ni_immers_freeze_tend, nc2nr_autoconv_tend, nc_accret_tend, nc_collect_tend,
+              nc_selfcollect_tend, ncheti_cnt, nicnt;
           Smask context;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             nc[s]                       = cxx_device(vs).nc;
@@ -61,9 +62,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestNcConservation : public
             context.set(s, cxx_device(vs).context);
           }
           const bool use_hetfrz_classnuc = false;
-          Functions::nc_conservation(nc, nc_selfcollect_tend, cxx_device(offset).dt, nc_collect_tend,
-                                     nc2ni_immers_freeze_tend, nc_accret_tend, nc2nr_autoconv_tend, ncheti_cnt, nicnt,
-                                     use_hetfrz_classnuc, context);
+          Functions::nc_conservation(nc, nc_selfcollect_tend, cxx_device(offset).dt,
+                                     nc_collect_tend, nc2ni_immers_freeze_tend, nc_accret_tend,
+                                     nc2nr_autoconv_tend, ncheti_cnt, nicnt, use_hetfrz_classnuc,
+                                     context);
 
           // Copy spacks back into cxx_device view
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
diff --git i/components/eamxx/src/physics/p3/tests/p3_ni_conservation_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_ni_conservation_tests.cpp
index 4079d8f7d9..2960d18ee5 100644
--- i/components/eamxx/src/physics/p3/tests/p3_ni_conservation_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_ni_conservation_tests.cpp
@@ -12,7 +12,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestNiConservation : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestNiConservation : public UnitWrap::UnitTest<D>::Base {
 
   void run_bfb() {
     auto engine = Base::get_engine();
@@ -26,8 +27,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestNiConservation : public
       d.dt = baseline_data[0].dt; // hold dt fixed, it is not packed data
     }
 
-    // Create copies of data for use by cxx and sync it to device. Needs to happen before reads so that
-    // inout data is in original state
+    // Create copies of data for use by cxx and sync it to device. Needs to happen before reads so
+    // that inout data is in original state
     view_1d<NiConservationData> cxx_device("cxx_device", max_pack_size);
     const auto cxx_host = Kokkos::create_mirror_view(cxx_device);
     std::copy(&baseline_data[0], &baseline_data[0] + max_pack_size, cxx_host.data());
@@ -46,8 +47,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestNiConservation : public
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack nc2ni_immers_freeze_tend, ni, ni2nr_melt_tend, ni_nucleat_tend, ni_selfcollect_tend, ni_sublim_tend,
-              nr2ni_immers_freeze_tend, ncheti_cnt, nicnt, ninuc_cnt;
+          Spack nc2ni_immers_freeze_tend, ni, ni2nr_melt_tend, ni_nucleat_tend, ni_selfcollect_tend,
+              ni_sublim_tend, nr2ni_immers_freeze_tend, ncheti_cnt, nicnt, ninuc_cnt;
           Smask context;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             nc2ni_immers_freeze_tend[s] = cxx_device(vs).nc2ni_immers_freeze_tend;
@@ -63,9 +64,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestNiConservation : public
             context.set(s, cxx_device(vs).context);
           }
           const bool use_hetfrz_classnuc = cxx_device(offset).use_hetfrz_classnuc;
-          Functions::ni_conservation(ni, ni_nucleat_tend, nr2ni_immers_freeze_tend, nc2ni_immers_freeze_tend,
-                                     ncheti_cnt, nicnt, ninuc_cnt, cxx_device(offset).dt, ni2nr_melt_tend,
-                                     ni_sublim_tend, ni_selfcollect_tend, use_hetfrz_classnuc, context);
+          Functions::ni_conservation(ni, ni_nucleat_tend, nr2ni_immers_freeze_tend,
+                                     nc2ni_immers_freeze_tend, ncheti_cnt, nicnt, ninuc_cnt,
+                                     cxx_device(offset).dt, ni2nr_melt_tend, ni_sublim_tend,
+                                     ni_selfcollect_tend, use_hetfrz_classnuc, context);
 
           // Copy spacks back into cxx_device view
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
diff --git i/components/eamxx/src/physics/p3/tests/p3_nr_conservation_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_nr_conservation_tests.cpp
index e09e136bbf..a283840fde 100644
--- i/components/eamxx/src/physics/p3/tests/p3_nr_conservation_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_nr_conservation_tests.cpp
@@ -12,7 +12,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestNrConservation : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestNrConservation : public UnitWrap::UnitTest<D>::Base {
 
   void run_bfb() {
     auto engine = Base::get_engine();
@@ -27,8 +28,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestNrConservation : public
       d.nmltratio = baseline_data[0].nmltratio; // hold nmltratio fixed, it is not packed data
     }
 
-    // Create copies of data for use by cxx and sync it to device. Needs to happen before reads so that
-    // inout data is in original state
+    // Create copies of data for use by cxx and sync it to device. Needs to happen before reads so
+    // that inout data is in original state
     view_1d<NrConservationData> cxx_device("cxx_device", max_pack_size);
     const auto cxx_host = Kokkos::create_mirror_view(cxx_device);
     std::copy(&baseline_data[0], &baseline_data[0] + max_pack_size, cxx_host.data());
@@ -47,8 +48,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestNrConservation : public
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack nc2nr_autoconv_tend, ncshdc, ni2nr_melt_tend, nr, nr2ni_immers_freeze_tend, nr_collect_tend,
-              nr_evap_tend, nr_ice_shed_tend, nr_selfcollect_tend;
+          Spack nc2nr_autoconv_tend, ncshdc, ni2nr_melt_tend, nr, nr2ni_immers_freeze_tend,
+              nr_collect_tend, nr_evap_tend, nr_ice_shed_tend, nr_selfcollect_tend;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             nc2nr_autoconv_tend[s]      = cxx_device(vs).nc2nr_autoconv_tend;
             ncshdc[s]                   = cxx_device(vs).ncshdc;
@@ -61,8 +62,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestNrConservation : public
             nr_selfcollect_tend[s]      = cxx_device(vs).nr_selfcollect_tend;
           }
 
-          Functions::nr_conservation(nr, ni2nr_melt_tend, nr_ice_shed_tend, ncshdc, nc2nr_autoconv_tend,
-                                     cxx_device(offset).dt, cxx_device(offset).nmltratio, nr_collect_tend,
+          Functions::nr_conservation(nr, ni2nr_melt_tend, nr_ice_shed_tend, ncshdc,
+                                     nc2nr_autoconv_tend, cxx_device(offset).dt,
+                                     cxx_device(offset).nmltratio, nr_collect_tend,
                                      nr2ni_immers_freeze_tend, nr_selfcollect_tend, nr_evap_tend);
 
           // Copy spacks back into cxx_device view
diff --git i/components/eamxx/src/physics/p3/tests/p3_prevent_liq_supersaturation_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_prevent_liq_supersaturation_tests.cpp
index 869c720173..84e44a584b 100644
--- i/components/eamxx/src/physics/p3/tests/p3_prevent_liq_supersaturation_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_prevent_liq_supersaturation_tests.cpp
@@ -13,11 +13,12 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestPreventLiqSupersaturation : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestPreventLiqSupersaturation : public UnitWrap::UnitTest<D>::Base {
 
   void run_property()
-  // Conceptual tests for prevent_liq_supersaturation. Note many conceptual tests make sense to run on
-  // random data, so are included in run_bfb rather than here.
+  // Conceptual tests for prevent_liq_supersaturation. Note many conceptual tests make sense to run
+  // on random data, so are included in run_bfb rather than here.
   {
 
     using physics = scream::physics::Functions<Scalar, Device>;
@@ -43,15 +44,17 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPreventLiqSupersaturatio
     Spack qi2qv_sublim_tend_tmp(1e-5);
     Spack qr2qv_evap_tend_tmp(1e-5);
 
-    // Next, confirm that initial data is subsaturated at beginning of step and supersaturated at end
+    // Next, confirm that initial data is subsaturated at beginning of step and supersaturated at
+    // end
     //(using code copied from prevent_liq_supersaturation_impl.hpp)
     Spack qv_sinks   = qidep + qinuc;
     Spack qv_sources = qi2qv_sublim_tend_tmp + qr2qv_evap_tend_tmp;
     Spack qv_endstep = qv - qv_sinks * dt + qv_sources * dt;
-    Spack T_endstep =
-        t_atm +
-        ((qv_sinks - qi2qv_sublim_tend_tmp) * (latvap + latice) * inv_cp - qr2qv_evap_tend_tmp * latvap * inv_cp) * dt;
-    Spack qsl = physics::qv_sat_dry(T_endstep, pres, false, context); //"false" means NOT sat w/ respect to ice
+    Spack T_endstep  = t_atm + ((qv_sinks - qi2qv_sublim_tend_tmp) * (latvap + latice) * inv_cp -
+                               qr2qv_evap_tend_tmp * latvap * inv_cp) *
+                                  dt;
+    Spack qsl = physics::qv_sat_dry(T_endstep, pres, false,
+                                    context); //"false" means NOT sat w/ respect to ice
     // just require index 0 since all entries are identical
 
     REQUIRE(qv[0] < qsl[0]);         // not a test of prevent_liq_supersat, just a sanity check that
@@ -66,10 +69,11 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPreventLiqSupersaturatio
     qv_sinks   = qidep + qinuc;
     qv_sources = qi2qv_sublim_tend_tmp + qr2qv_evap_tend_tmp;
     qv_endstep = qv - qv_sinks * dt + qv_sources * dt;
-    T_endstep =
-        t_atm +
-        ((qv_sinks - qi2qv_sublim_tend_tmp) * (latvap + latice) * inv_cp - qr2qv_evap_tend_tmp * latvap * inv_cp) * dt;
-    qsl = physics::qv_sat_dry(T_endstep, pres, false, context); //"false" means NOT sat w/ respect to ice
+    T_endstep  = t_atm + ((qv_sinks - qi2qv_sublim_tend_tmp) * (latvap + latice) * inv_cp -
+                         qr2qv_evap_tend_tmp * latvap * inv_cp) *
+                            dt;
+    qsl = physics::qv_sat_dry(T_endstep, pres, false,
+                              context); //"false" means NOT sat w/ respect to ice
     // just require index 0 since all entries are identical
 
     REQUIRE(qv_endstep[0] <= qsl[0]);
@@ -80,8 +84,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPreventLiqSupersaturatio
     Spack qi2qv_sublim_tend_tmp2(1e-4);
     Spack qr2qv_evap_tend_tmp2(1e-4);
 
-    Functions::prevent_liq_supersaturation(pres, t_atm, qv_tmp, dt, qidep, qinuc, qi2qv_sublim_tend_tmp2,
-                                           qr2qv_evap_tend_tmp2);
+    Functions::prevent_liq_supersaturation(pres, t_atm, qv_tmp, dt, qidep, qinuc,
+                                           qi2qv_sublim_tend_tmp2, qr2qv_evap_tend_tmp2);
     // just require index 0 since all entries are identical.
     REQUIRE(qi2qv_sublim_tend_tmp2[0] == 0);
     REQUIRE(qr2qv_evap_tend_tmp2[0] == 0);
@@ -129,7 +133,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPreventLiqSupersaturatio
       }
     }
 
-    // Get data from cxx. Run prevent_liq_supersaturation from a kernel and copy results back to host
+    // Get data from cxx. Run prevent_liq_supersaturation from a kernel and copy results back to
+    // host
     Kokkos::parallel_for(
         num_test_itrs, KOKKOS_LAMBDA(const Int &i) {
           const Int offset = i * Spack::n;
@@ -138,8 +143,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPreventLiqSupersaturatio
           Scalar dt;
           Spack pres, qi2qv_sublim_tend, qidep, qinuc, qr2qv_evap_tend, qv, t_atm;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
-            dt      = cxx_device(vs).dt; // dt is scalar but PreventLiqSupersaturationData has diff val for each row.
-            pres[s] = cxx_device(vs).pres;
+            dt = cxx_device(vs).dt; // dt is scalar but PreventLiqSupersaturationData has diff val
+                                    // for each row.
+            pres[s]              = cxx_device(vs).pres;
             qi2qv_sublim_tend[s] = cxx_device(vs).qi2qv_sublim_tend;
             qidep[s]             = cxx_device(vs).qidep;
             qinuc[s]             = cxx_device(vs).qinuc;
@@ -148,7 +154,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPreventLiqSupersaturatio
             t_atm[s]             = cxx_device(vs).t_atm;
           }
 
-          Functions::prevent_liq_supersaturation(pres, t_atm, qv, dt, qidep, qinuc, qi2qv_sublim_tend, qr2qv_evap_tend);
+          Functions::prevent_liq_supersaturation(pres, t_atm, qv, dt, qidep, qinuc,
+                                                 qi2qv_sublim_tend, qr2qv_evap_tend);
 
           // Copy spacks back into cxx_device view
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
@@ -190,14 +197,16 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPreventLiqSupersaturatio
 namespace {
 
 TEST_CASE("prevent_liq_supersaturation_property", "[p3]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPreventLiqSupersaturation;
+  using T = scream::p3::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestPreventLiqSupersaturation;
 
   T t;
   t.run_property();
 }
 
 TEST_CASE("prevent_liq_supersaturation_bfb", "[p3]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPreventLiqSupersaturation;
+  using T = scream::p3::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestPreventLiqSupersaturation;
 
   T t;
   t.run_bfb();
diff --git i/components/eamxx/src/physics/p3/tests/p3_rain_imm_freezing_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_rain_imm_freezing_unit_tests.cpp
index 6e97d75e96..05166f95a8 100644
--- i/components/eamxx/src/physics/p3/tests/p3_rain_imm_freezing_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_rain_imm_freezing_unit_tests.cpp
@@ -17,7 +17,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestRainImmersionFreezing : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestRainImmersionFreezing : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys() {
     // TODO
@@ -60,7 +61,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestRainImmersionFreezing :
     // Sync to device
     view_1d<RainImmersionFreezingData> device_data("rain_imm_freezing", max_pack_size);
     const auto host_data = Kokkos::create_mirror_view(device_data);
-    std::copy(&rain_imm_freezing_data[0], &rain_imm_freezing_data[0] + max_pack_size, host_data.data());
+    std::copy(&rain_imm_freezing_data[0], &rain_imm_freezing_data[0] + max_pack_size,
+              host_data.data());
     Kokkos::deep_copy(device_data, host_data);
 
     // Read baseline data
@@ -88,8 +90,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestRainImmersionFreezing :
           Spack qr2qi_immers_freeze_tend{0.0};
           Spack nr2ni_immers_freeze_tend{0.0};
 
-          Functions::rain_immersion_freezing(T_atm, lamr, mu_r, cdistr, qr_incld, qr2qi_immers_freeze_tend,
-                                             nr2ni_immers_freeze_tend, p3::Functions<Real, DefaultDevice>::P3Runtime());
+          Functions::rain_immersion_freezing(T_atm, lamr, mu_r, cdistr, qr_incld,
+                                             qr2qi_immers_freeze_tend, nr2ni_immers_freeze_tend,
+                                             p3::Functions<Real, DefaultDevice>::P3Runtime());
 
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
@@ -104,8 +107,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestRainImmersionFreezing :
     // Validate results.
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
       for (Int s = 0; s < max_pack_size; ++s) {
-        REQUIRE(rain_imm_freezing_data[s].qr2qi_immers_freeze_tend == host_data[s].qr2qi_immers_freeze_tend);
-        REQUIRE(rain_imm_freezing_data[s].nr2ni_immers_freeze_tend == host_data[s].nr2ni_immers_freeze_tend);
+        REQUIRE(rain_imm_freezing_data[s].qr2qi_immers_freeze_tend ==
+                host_data[s].qr2qi_immers_freeze_tend);
+        REQUIRE(rain_imm_freezing_data[s].nr2ni_immers_freeze_tend ==
+                host_data[s].nr2ni_immers_freeze_tend);
       }
     } else if (this->m_baseline_action == GENERATE) {
       for (Int s = 0; s < max_pack_size; ++s) {
@@ -122,7 +127,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestRainImmersionFreezing :
 namespace {
 
 TEST_CASE("p3_rain_immersion_freezing", "[p3_functions]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestRainImmersionFreezing;
+  using T =
+      scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestRainImmersionFreezing;
 
   T t;
   t.run_phys();
diff --git i/components/eamxx/src/physics/p3/tests/p3_rain_sed_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_rain_sed_unit_tests.cpp
index 039becf19f..7954af739a 100644
--- i/components/eamxx/src/physics/p3/tests/p3_rain_sed_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_rain_sed_unit_tests.cpp
@@ -18,7 +18,8 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestRainSed : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestRainSed : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys_rain_vel() {
     // TODO
@@ -40,7 +41,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestRainSed : public UnitWra
     view_2d_table revap_table_vals;
     view_1d_table mu_r_table_vals;
     view_dnu_table dnu;
-    Functions::get_global_tables(vn_table_vals, vm_table_vals, revap_table_vals, mu_r_table_vals, dnu);
+    Functions::get_global_tables(vn_table_vals, vm_table_vals, revap_table_vals, mu_r_table_vals,
+                                 dnu);
 
     // Load some lookup inputs, need at least one per pack value
     ComputeRainFallVelocityData crfv_baseline[max_pack_size] = {
@@ -87,8 +89,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestRainSed : public UnitWra
           }
 
           Spack mu_r(0), lamr(0), V_qr(0), V_nr(0);
-          Functions::compute_rain_fall_velocity(vn_table_vals, vm_table_vals, qr_incld, rhofacr, nr_incld, mu_r, lamr,
-                                                V_qr, V_nr, p3::Functions<Real, DefaultDevice>::P3Runtime());
+          Functions::compute_rain_fall_velocity(vn_table_vals, vm_table_vals, qr_incld, rhofacr,
+                                                nr_incld, mu_r, lamr, V_qr, V_nr,
+                                                p3::Functions<Real, DefaultDevice>::P3Runtime());
 
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
@@ -170,9 +173,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestRainSed : public UnitWra
 #if defined(SCREAM_FORCE_RUN_DIFF)
       inv_dt *= 2;
 #endif
-      rain_sedimentation_host(d.kts, d.kte, d.ktop, d.kbot, d.kdir, d.qr_incld, d.rho, d.inv_rho, d.rhofacr,
-                              d.cld_frac_r, d.inv_dz, d.dt, inv_dt, d.qr, d.nr, d.nr_incld, d.mu_r, d.lamr,
-                              &d.precip_liq_surf, d.precip_liq_flux, d.qr_tend, d.nr_tend);
+      rain_sedimentation_host(d.kts, d.kte, d.ktop, d.kbot, d.kdir, d.qr_incld, d.rho, d.inv_rho,
+                              d.rhofacr, d.cld_frac_r, d.inv_dz, d.dt, inv_dt, d.qr, d.nr,
+                              d.nr_incld, d.mu_r, d.lamr, &d.precip_liq_surf, d.precip_liq_flux,
+                              d.qr_tend, d.nr_tend);
     }
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
diff --git i/components/eamxx/src/physics/p3/tests/p3_rain_self_collection_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_rain_self_collection_tests.cpp
index 101999397d..8aa25cbd93 100644
--- i/components/eamxx/src/physics/p3/tests/p3_rain_self_collection_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_rain_self_collection_tests.cpp
@@ -21,7 +21,8 @@ namespace unit_test {
 /*
  * Unit-tests for p3 ice collection functions.
  */
-template <typename D> struct UnitWrap::UnitTest<D>::TestRainSelfCollection : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestRainSelfCollection : public UnitWrap::UnitTest<D>::Base {
 
   void run_rain_self_collection_bfb_tests() {
 
@@ -67,7 +68,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestRainSelfCollection : pub
             nr_selfcollect_tend_local[s] = dc_device(vs).nr_selfcollect_tend;
           }
 
-          Functions::rain_self_collection(rho_local, qr_incld_local, nr_incld_local, nr_selfcollect_tend_local,
+          Functions::rain_self_collection(rho_local, qr_incld_local, nr_incld_local,
+                                          nr_selfcollect_tend_local,
                                           p3::Functions<Real, DefaultDevice>::P3Runtime());
 
           // Copy results back into views
@@ -108,7 +110,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestRainSelfCollection : pub
 namespace {
 
 TEST_CASE("p3_rain_self_collection_test", "[p3_rain_self_collection_test") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestRainSelfCollection;
+  using T =
+      scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestRainSelfCollection;
 
   T t;
   t.run_bfb();
diff --git i/components/eamxx/src/physics/p3/tests/p3_run_and_cmp.cpp w/components/eamxx/src/physics/p3/tests/p3_run_and_cmp.cpp
index 32176f3420..93eb4be628 100644
--- i/components/eamxx/src/physics/p3/tests/p3_run_and_cmp.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_run_and_cmp.cpp
@@ -75,8 +75,8 @@ struct Baseline {
 
     for (int i = i_start; i < i_end; ++i) {   // predict_nc is false or true
       for (int j = j_start; j < j_end; ++j) { // prescribed_CCN is false or true
-        //                 initial condit,     repeat, nsteps, ncol, nlev, dt, prescribe or predict nc, prescribe CCN or
-        //                 not
+        //                 initial condit,     repeat, nsteps, ncol, nlev, dt, prescribe or predict
+        //                 nc, prescribe CCN or not
         params_.push_back({ic::Factory::mixed, repeat, nsteps, ncol, nlev, dt, i > 0, j > 0});
       }
     }
@@ -97,8 +97,9 @@ struct Baseline {
         P3F::p3_init();
 
         if (ps.repeat > 0 && r == -1) {
-          std::cout << "Running P3 with ni=" << d->ncol << ", nk=" << d->nlev << ", dt=" << d->dt << ", ts=" << d->it
-                    << ", predict_nc=" << d->do_predict_nc << ", prescribed_CCN=" << d->do_prescribed_CCN
+          std::cout << "Running P3 with ni=" << d->ncol << ", nk=" << d->nlev << ", dt=" << d->dt
+                    << ", ts=" << d->it << ", predict_nc=" << d->do_predict_nc
+                    << ", prescribed_CCN=" << d->do_prescribed_CCN
                     << ", small_packn=" << SCREAM_SMALL_PACK_SIZE << std::endl;
         }
 
@@ -139,7 +140,8 @@ struct Baseline {
         set_params(ps, *d);
         P3F::p3_init();
         for (int it = 0; it < ps.nsteps; it++) {
-          std::cout << "--- running case # " << case_num << ", timestep # " << it + 1 << " of " << ps.nsteps << " ---\n"
+          std::cout << "--- running case # " << case_num << ", timestep # " << it + 1 << " of "
+                    << ps.nsteps << " ---\n"
                     << std::flush;
           p3_main_wrap(*d);
         }
@@ -154,8 +156,8 @@ struct Baseline {
           set_params(ps, *d);
           P3F::p3_init();
           for (int it = 0; it < ps.nsteps; it++) {
-            std::cout << "--- checking case # " << case_num << ", timestep # " << it + 1 << " of " << ps.nsteps
-                      << " ---\n"
+            std::cout << "--- checking case # " << case_num << ", timestep # " << it + 1 << " of "
+                      << ps.nsteps << " ---\n"
                       << std::flush;
             read(fid, d_ref);
             p3_main_wrap(*d);
@@ -205,12 +207,13 @@ private:
       const auto &f = fdi.getfield(i);
       int dim, ds[3];
       ekat::read(&dim, 1, fid);
-      EKAT_REQUIRE_MSG(dim == f.dim, "For field " << f.name << " read expected dim " << f.dim << " but got " << dim);
+      EKAT_REQUIRE_MSG(dim == f.dim, "For field " << f.name << " read expected dim " << f.dim
+                                                  << " but got " << dim);
       ekat::read(ds, dim, fid);
       for (int i = 0; i < dim; ++i)
         EKAT_REQUIRE_MSG(ds[i] == f.extent[i], "For field " << f.name << " read expected dim " << i
-                                                            << " to have extent " << f.extent[i] << " but got "
-                                                            << ds[i]);
+                                                            << " to have extent " << f.extent[i]
+                                                            << " but got " << ds[i]);
       ekat::read(f.data, f.size, fid);
       // The code below is to force a result difference. This is used by the
       // scream/scripts internal testing to verify that various DIFFs are detected.
@@ -223,7 +226,9 @@ private:
   }
 };
 
-void expect_another_arg(int i, int argc) { EKAT_REQUIRE_MSG(i != argc - 1, "Expected another cmd-line arg."); }
+void expect_another_arg(int i, int argc) {
+  EKAT_REQUIRE_MSG(i != argc - 1, "Expected another cmd-line arg.");
+}
 
 } // namespace
 
@@ -243,7 +248,8 @@ int main(int argc, char **argv) {
                  "  -dt <seconds>       Length of timestep. Default=300.\n"
                  "  -i <cols>           Number of columns. Default=3.\n"
                  "  -k <nlev>           Number of vertical levels. Default=72.\n"
-                 "  -r <repeat>         Number of repetitions, implies timing run (generate + no I/O). Default=0.\n"
+                 "  -r <repeat>         Number of repetitions, implies timing run (generate + no "
+                 "I/O). Default=0.\n"
                  "  --predict-nc       yes|no|both. Default=both.\n"
                  "  --prescribed-ccn   yes|no|both. Default=both.\n";
     return 1;
@@ -318,7 +324,8 @@ int main(int argc, char **argv) {
       expect_another_arg(i, argc);
       ++i;
       prescribed_ccn = std::string(argv[i]);
-      EKAT_REQUIRE_MSG(prescribed_ccn == "yes" || prescribed_ccn == "no" || prescribed_ccn == "both",
+      EKAT_REQUIRE_MSG(prescribed_ccn == "yes" || prescribed_ccn == "no" ||
+                           prescribed_ccn == "both",
                        "Prescribed CCN option value must be one of yes|no|both");
     }
   }
diff --git i/components/eamxx/src/physics/p3/tests/p3_subgrid_variance_scaling_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_subgrid_variance_scaling_unit_tests.cpp
index f0ca8fc767..c95ba7949f 100644
--- i/components/eamxx/src/physics/p3/tests/p3_subgrid_variance_scaling_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_subgrid_variance_scaling_unit_tests.cpp
@@ -18,14 +18,16 @@ namespace scream {
 namespace p3 {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestP3SubgridVarianceScaling : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestP3SubgridVarianceScaling : public UnitWrap::UnitTest<D>::Base {
 
   //-----------------------------------------------------------------
   void run_bfb_tests() {
     // test that C++ and F90 implementations are BFB
 
     // Set of relvar values to loop over
-    Scalar relvars[16] = {0.1, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 6.5, 7.0, 8.0, 9.0, 9.1, 9.5, 9.8, 10.};
+    Scalar relvars[16] = {0.1, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0,
+                          6.5, 7.0, 8.0, 9.0, 9.1, 9.5, 9.8, 10.};
 
     // Set of exponents to loop over
     Scalar expons[3] = {1.0, 2.47, 0.1};
@@ -75,10 +77,13 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3SubgridVarianceScaling
   } // end function run_bfb_tests
 
   //-----------------------------------------------------------------
-  KOKKOS_FUNCTION static void subgrid_variance_scaling_linearity_test(const Scalar &relvar, int &errors) {
+  KOKKOS_FUNCTION static void subgrid_variance_scaling_linearity_test(const Scalar &relvar,
+                                                                      int &errors) {
     // If expon=1, subgrid_variance_scaling should be 1
 
-    Scalar tol = C::macheps * 1e3; // 1e3 is scale factor to make pass, essentially an estimate of numerical error
+    Scalar tol =
+        C::macheps *
+        1e3; // 1e3 is scale factor to make pass, essentially an estimate of numerical error
 
     // Get value from C++ code
     const Spack relvars(relvar);
@@ -96,7 +101,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3SubgridVarianceScaling
   KOKKOS_FUNCTION static void subgrid_variance_scaling_relvar1_test(int &errors) {
     // If relvar=1, subgrid_variance_scaling should be factorial(expon)
 
-    Scalar tol = C::macheps * 1e3; // 1e3 is scale factor to make pass, essentially an estimate of numerical error
+    Scalar tol =
+        C::macheps *
+        1e3; // 1e3 is scale factor to make pass, essentially an estimate of numerical error
 
     // Get value from C++ code
     const Spack ones(1);
@@ -116,9 +123,12 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3SubgridVarianceScaling
   KOKKOS_FUNCTION static void subgrid_variance_scaling_relvar3_test(int &errors) {
     // If expon=3, subgrid variance scaling should be relvar^3+3*relvar^2+2*relvar/relvar^3
 
-    Scalar tol = C::macheps * 100; // 100 is a fudge factor to make sure tests pass. 10 was too small for gnu on CPU.
+    Scalar tol =
+        C::macheps *
+        100; // 100 is a fudge factor to make sure tests pass. 10 was too small for gnu on CPU.
 
-    Real relvar_info[max_pack_size] = {0.1, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 6.5, 7.0, 8.0, 9.0, 9.1, 9.5, 9.8, 10.};
+    Real relvar_info[max_pack_size] = {0.1, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0,
+                                       6.5, 7.0, 8.0, 9.0, 9.1, 9.5, 9.8, 10.};
 
     for (Int s = 0; s < 16; ++s) {
       Spack relvars = Spack(relvar_info[s]);
@@ -132,8 +142,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3SubgridVarianceScaling
       // Expected relative discrepancy is relative condition # * tolerance
       // For expon=3, expected val is 1+3/relvar + 2/relvar**2.
       // Condition number is x*f'(x)/f(x) = (3*relvar + 4)/(relvar**2. + 3*relvar+2)
-      const Real cond_num = (3. * relvar_info[s] + 4.) / (std::pow(relvar_info[s], 2.0) + 3 * relvar_info[s] + 2.0);
-      const Real max_tol  = tol * cond_num;
+      const Real cond_num =
+          (3. * relvar_info[s] + 4.) / (std::pow(relvar_info[s], 2.0) + 3 * relvar_info[s] + 2.0);
+      const Real max_tol = tol * cond_num;
 
       if (std::abs(targ - c_scaling[0]) > max_tol * targ) {
         Kokkos::printf("When expon=3, subgrid_variance_scaling doesn't match analytic expectation. "
@@ -188,7 +199,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3SubgridVarianceScaling
 namespace {
 
 TEST_CASE("p3_subgrid_variance_scaling_test", "[p3_subgrid_variance_scaling_test]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestP3SubgridVarianceScaling;
+  using T = scream::p3::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestP3SubgridVarianceScaling;
 
   T t;
   t.run_bfb_tests();
diff --git i/components/eamxx/src/physics/p3/tests/p3_table3_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_table3_unit_tests.cpp
index 5df23fad47..696d5b754a 100644
--- i/components/eamxx/src/physics/p3/tests/p3_table3_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_table3_unit_tests.cpp
@@ -42,7 +42,8 @@ namespace unit_test {
 // tool is measuring the maximum slope magnitude as a function of mesh
 // refinement, where the mesh is a 1D mesh transecting the table domain.
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestTable3 : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestTable3 : public UnitWrap::UnitTest<D>::Base {
 
   KOKKOS_FUNCTION static Scalar calc_lamr(const Scalar &mu_r, const Scalar &alpha) {
     // Parameters for lower and upper bounds, derived above, multiplied by
@@ -55,7 +56,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestTable3 : public UnitWrap
   KOKKOS_FUNCTION static Scalar calc_mu_r(const Scalar &alpha) { return alpha * 10; }
 
   // Perform the table lookup and interpolation operations for (mu_r, lamr).
-  KOKKOS_FUNCTION static Spack interp(const view_2d_table &table, const Scalar &mu_r, const Scalar &lamr) {
+  KOKKOS_FUNCTION static Spack interp(const view_2d_table &table, const Scalar &mu_r,
+                                      const Scalar &lamr) {
     // Init the pack to all the same value, and compute in every pack slot.
     Spack mu_r_p(mu_r), lamr_p(lamr);
     Table3 t3;
@@ -71,7 +73,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestTable3 : public UnitWrap
     view_1d_table mu_r_table_vals;
     view_2d_table vn_table_vals, vm_table_vals, revap_table_vals;
     view_dnu_table dnu;
-    Functions::get_global_tables(vn_table_vals, vm_table_vals, revap_table_vals, mu_r_table_vals, dnu);
+    Functions::get_global_tables(vn_table_vals, vm_table_vals, revap_table_vals, mu_r_table_vals,
+                                 dnu);
 
     // Estimate two maximum slope magnitudes for two meshes, the second 10x
     // refined w.r.t. the first.
@@ -117,8 +120,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestTable3 : public UnitWrap
     const auto check_growth = [&](const std::string &label, const Scalar &growth) {
       bool bad_growth = growth > 1.1;
       if (bad_growth) {
-        std::cout << "Table3 FAIL: Slopes in the " << label << " direction are " << slopes[0] << " and " << slopes[1]
-                  << ", which grows by factor " << growth << ". Near 1 is good; near 10 is bad.\n";
+        std::cout << "Table3 FAIL: Slopes in the " << label << " direction are " << slopes[0]
+                  << " and " << slopes[1] << ", which grows by factor " << growth
+                  << ". Near 1 is good; near 10 is bad.\n";
       }
       REQUIRE(!bad_growth);
     };
diff --git i/components/eamxx/src/physics/p3/tests/p3_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_unit_tests.cpp
index 39b1ea89f7..9acc674bed 100644
--- i/components/eamxx/src/physics/p3/tests/p3_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_unit_tests.cpp
@@ -20,14 +20,15 @@ namespace unit_test {
 /*
  * Unit-tests for p3_functions.
  */
-template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestP3Conservation : public UnitWrap::UnitTest<D>::Base {
 
   void cloud_water_conservation_tests_device() {
 
     using KTH = KokkosTypes<HostDevice>;
 
-    CloudWaterConservationData cwdc[1] = {
-        {sp(1e-5), sp(1.1), sp(1e-4), 0.0, 0.0, 0.0, 0.0, 0.0, sp(1.0), sp(1.0), sp(1.0), sp(1.0), false, true}};
+    CloudWaterConservationData cwdc[1] = {{sp(1e-5), sp(1.1), sp(1e-4), 0.0, 0.0, 0.0, 0.0, 0.0,
+                                           sp(1.0), sp(1.0), sp(1.0), sp(1.0), false, true}};
 
     // Sync to device
     KTH::view_1d<CloudWaterConservationData> cwdc_host("cwdc_host", 1);
@@ -53,10 +54,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
           Spack qicnt(cwdc_device(0).qicnt);
           const bool use_hetfrz_classnuc = false;
           const Smask context(Smask(true));
-          Functions::cloud_water_conservation(qc, cwdc_device(0).dt, qc2qr_autoconv_tend, qc2qr_accret_tend,
-                                              qc2qi_collect_tend, qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend,
-                                              qc2qi_berg_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qcheti_cnt, qicnt,
-                                              use_hetfrz_classnuc, context);
+          Functions::cloud_water_conservation(
+              qc, cwdc_device(0).dt, qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend,
+              qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend, qc2qi_berg_tend, qi2qv_sublim_tend,
+              qv2qi_vapdep_tend, qcheti_cnt, qicnt, use_hetfrz_classnuc, context);
 
           cwdc_device(0).qc                       = qc[0];
           cwdc_device(0).qc2qr_autoconv_tend      = qc2qr_autoconv_tend[0];
@@ -75,7 +76,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
     Kokkos::deep_copy(cwdc_host, cwdc_device);
 
     const auto ratio = cwdc[0].qc / (cwdc[0].qc2qr_autoconv_tend * cwdc[0].dt);
-    REQUIRE(std::abs(cwdc_host(0).qc2qr_autoconv_tend - cwdc[0].qc2qr_autoconv_tend * ratio) <= C::macheps);
+    REQUIRE(std::abs(cwdc_host(0).qc2qr_autoconv_tend - cwdc[0].qc2qr_autoconv_tend * ratio) <=
+            C::macheps);
     REQUIRE(cwdc_host(0).qc2qr_accret_tend == 0.0);
     REQUIRE(cwdc_host(0).qc2qi_collect_tend == 0.0);
     REQUIRE(cwdc_host(0).qc2qi_hetero_freeze_tend == 0.0);
@@ -89,7 +91,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
   void rain_water_conservation_tests_device() {
     using KTH = KokkosTypes<HostDevice>;
 
-    RainWaterConservationData rwdc[1] = {{sp(1e-5), 0.0, 0.0, 0.0, 0.0, sp(1.1), sp(1e-4), 0.0, 0.0}};
+    RainWaterConservationData rwdc[1] = {
+        {sp(1e-5), 0.0, 0.0, 0.0, 0.0, sp(1.1), sp(1e-4), 0.0, 0.0}};
 
     // Sync to device
     KTH::view_1d<RainWaterConservationData> rwdc_host("rwdc_host", 1);
@@ -111,9 +114,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
           Spack qr2qi_collect_tend(rwdc_device(0).qr2qi_collect_tend);
           Spack qr2qi_immers_freeze_tend(rwdc_device(0).qr2qi_immers_freeze_tend);
 
-          Functions::rain_water_conservation(qr, qc2qr_autoconv_tend, qc2qr_accret_tend, qi2qr_melt_tend,
-                                             qc2qr_ice_shed_tend, rwdc_device(0).dt, qr2qv_evap_tend,
-                                             qr2qi_collect_tend, qr2qi_immers_freeze_tend);
+          Functions::rain_water_conservation(
+              qr, qc2qr_autoconv_tend, qc2qr_accret_tend, qi2qr_melt_tend, qc2qr_ice_shed_tend,
+              rwdc_device(0).dt, qr2qv_evap_tend, qr2qi_collect_tend, qr2qi_immers_freeze_tend);
 
           rwdc_device(0).qr                       = qr[0];
           rwdc_device(0).qc2qr_autoconv_tend      = qc2qr_autoconv_tend[0];
@@ -144,8 +147,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
 
   void ice_water_conservation_tests_device() {
     using KTH                        = KokkosTypes<HostDevice>;
-    IceWaterConservationData iwdc[1] = {
-        {sp(1e-5), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, sp(1.1), sp(1e-4), 0.0, 0.0, 0.0, 0.0, false, true}};
+    IceWaterConservationData iwdc[1] = {{sp(1e-5), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, sp(1.1),
+                                         sp(1e-4), 0.0, 0.0, 0.0, 0.0, false, true}};
 
     // Sync to device
     KTH::view_1d<IceWaterConservationData> iwdc_host("iwdc_host", 1);
@@ -174,10 +177,11 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
           const bool use_hetfrz_classnuc = false;
           const Smask context(Smask(true));
 
-          Functions::ice_water_conservation(qi, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend,
-                                            qr2qi_collect_tend, qc2qi_collect_tend, qr2qi_immers_freeze_tend,
-                                            qc2qi_hetero_freeze_tend, iwdc_device(0).dt, qinuc_cnt, qcheti_cnt, qicnt,
-                                            qi2qv_sublim_tend, qi2qr_melt_tend, use_hetfrz_classnuc, context);
+          Functions::ice_water_conservation(
+              qi, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend, qr2qi_collect_tend,
+              qc2qi_collect_tend, qr2qi_immers_freeze_tend, qc2qi_hetero_freeze_tend,
+              iwdc_device(0).dt, qinuc_cnt, qcheti_cnt, qicnt, qi2qv_sublim_tend, qi2qr_melt_tend,
+              use_hetfrz_classnuc, context);
 
           iwdc_device(0).qi                       = qi[0];
           iwdc_device(0).qv2qi_vapdep_tend        = qv2qi_vapdep_tend[0];
@@ -209,45 +213,57 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
 
     // These static asserts are important for many tests. If this test gets
     // removed, please put these lines in another test.
-    static_assert(Spack::n <= max_pack_size, "Unit testing infrastructure does not support this pack size (too big)");
-    static_assert(max_pack_size % Spack::n == 0,
-                  "Unit testing infrastructure does not support this pack size (does not evenly divide 16)");
+    static_assert(Spack::n <= max_pack_size,
+                  "Unit testing infrastructure does not support this pack size (too big)");
+    static_assert(
+        max_pack_size % Spack::n == 0,
+        "Unit testing infrastructure does not support this pack size (does not evenly divide 16)");
 
     CloudWaterConservationData cwdc[max_pack_size] = {
-        // qc, cwdc_device(0).dt, qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend, qc2qi_hetero_freeze_tend,
-        // qc2qr_ice_shed_tend, qc2qi_berg_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qcheti_cnt, qicnt,
+        // qc, cwdc_device(0).dt, qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend,
+        // qc2qi_hetero_freeze_tend,
+        // qc2qr_ice_shed_tend, qc2qi_berg_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qcheti_cnt,
+        // qicnt,
         // use_hetfrz_classnuc, context
-        {9.9999999999999995e-7, 1800.0, 1.5832574016248739e-12, 1.0630996907148179e-12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
-         0.0, 0.0, false, true},
-        {6.4285714285714288e-5, 1800.0, 5.0577951315583066e-7, 7.7585489624948031e-4, 1.5683327213659326e-4,
-         1.2893174331809564e-14, 0.0, 5.0463073442953805e-6, 0.0, 5.1387602886199180e-7, 0.0, 0.0, false, true},
+        {9.9999999999999995e-7, 1800.0, 1.5832574016248739e-12, 1.0630996907148179e-12, 0.0, 0.0,
+         0.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
+        {6.4285714285714288e-5, 1800.0, 5.0577951315583066e-7, 7.7585489624948031e-4,
+         1.5683327213659326e-4, 1.2893174331809564e-14, 0.0, 5.0463073442953805e-6, 0.0,
+         5.1387602886199180e-7, 0.0, 0.0, false, true},
         {0.0, 1800.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
-        {7.1428571428571434e-5, 1800.0, 5.1480988828550771e-7, 7.7585489624948031e-4, 1.5597668529004373e-4,
-         4.9926620576534573e-14, 0.0, 6.7718890050008472e-6, 0.0, 7.1052455549903861e-7, 0.0, 0.0, false, true},
+        {7.1428571428571434e-5, 1800.0, 5.1480988828550771e-7, 7.7585489624948031e-4,
+         1.5597668529004373e-4, 4.9926620576534573e-14, 0.0, 6.7718890050008472e-6, 0.0,
+         7.1052455549903861e-7, 0.0, 0.0, false, true},
 
-        {9.9999999999999995e-7, 1800.0, 1.5832574016248739e-12, 1.0630996907148179e-12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
-         0.0, 0.0, false, true},
-        {6.4285714285714288e-5, 1800.0, 5.0577951315583066e-7, 7.7585489624948031e-4, 1.5683327213659326e-4,
-         1.2893174331809564e-14, 0.0, 5.0463073442953805e-6, 0.0, 5.1387602886199180e-7, 0.0, 0.0, false, true},
+        {9.9999999999999995e-7, 1800.0, 1.5832574016248739e-12, 1.0630996907148179e-12, 0.0, 0.0,
+         0.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
+        {6.4285714285714288e-5, 1800.0, 5.0577951315583066e-7, 7.7585489624948031e-4,
+         1.5683327213659326e-4, 1.2893174331809564e-14, 0.0, 5.0463073442953805e-6, 0.0,
+         5.1387602886199180e-7, 0.0, 0.0, false, true},
         {0.0, 1800.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
-        {7.1428571428571434e-5, 1800.0, 5.1480988828550771e-7, 7.7585489624948031e-4, 1.5597668529004373e-4,
-         4.9926620576534573e-14, 0.0, 6.7718890050008472e-6, 0.0, 7.1052455549903861e-7, 0.0, 0.0, false, true},
+        {7.1428571428571434e-5, 1800.0, 5.1480988828550771e-7, 7.7585489624948031e-4,
+         1.5597668529004373e-4, 4.9926620576534573e-14, 0.0, 6.7718890050008472e-6, 0.0,
+         7.1052455549903861e-7, 0.0, 0.0, false, true},
 
-        {9.9999999999999995e-7, 1800.0, 1.5832574016248739e-12, 1.0630996907148179e-12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
-         0.0, 0.0, false, true},
-        {6.4285714285714288e-5, 1800.0, 5.0577951315583066e-7, 7.7585489624948031e-4, 1.5683327213659326e-4,
-         1.2893174331809564e-14, 0.0, 5.0463073442953805e-6, 0.0, 5.1387602886199180e-7, 0.0, 0.0, false, true},
+        {9.9999999999999995e-7, 1800.0, 1.5832574016248739e-12, 1.0630996907148179e-12, 0.0, 0.0,
+         0.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
+        {6.4285714285714288e-5, 1800.0, 5.0577951315583066e-7, 7.7585489624948031e-4,
+         1.5683327213659326e-4, 1.2893174331809564e-14, 0.0, 5.0463073442953805e-6, 0.0,
+         5.1387602886199180e-7, 0.0, 0.0, false, true},
         {0.0, 1800.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
-        {7.1428571428571434e-5, 1800.0, 5.1480988828550771e-7, 7.7585489624948031e-4, 1.5597668529004373e-4,
-         4.9926620576534573e-14, 0.0, 6.7718890050008472e-6, 0.0, 7.1052455549903861e-7, 0.0, 0.0, false, true},
+        {7.1428571428571434e-5, 1800.0, 5.1480988828550771e-7, 7.7585489624948031e-4,
+         1.5597668529004373e-4, 4.9926620576534573e-14, 0.0, 6.7718890050008472e-6, 0.0,
+         7.1052455549903861e-7, 0.0, 0.0, false, true},
 
-        {9.9999999999999995e-7, 1800.0, 1.5832574016248739e-12, 1.0630996907148179e-12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
-         0.0, 0.0, false, true},
-        {6.4285714285714288e-5, 1800.0, 5.0577951315583066e-7, 7.7585489624948031e-4, 1.5683327213659326e-4,
-         1.2893174331809564e-14, 0.0, 5.0463073442953805e-6, 0.0, 5.1387602886199180e-7, 0.0, 0.0, false, true},
+        {9.9999999999999995e-7, 1800.0, 1.5832574016248739e-12, 1.0630996907148179e-12, 0.0, 0.0,
+         0.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
+        {6.4285714285714288e-5, 1800.0, 5.0577951315583066e-7, 7.7585489624948031e-4,
+         1.5683327213659326e-4, 1.2893174331809564e-14, 0.0, 5.0463073442953805e-6, 0.0,
+         5.1387602886199180e-7, 0.0, 0.0, false, true},
         {0.0, 1800.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
-        {7.1428571428571434e-5, 1800.0, 5.1480988828550771e-7, 7.7585489624948031e-4, 1.5597668529004373e-4,
-         4.9926620576534573e-14, 0.0, 6.7718890050008472e-6, 0.0, 7.1052455549903861e-7, 0.0, 0.0, false, true}};
+        {7.1428571428571434e-5, 1800.0, 5.1480988828550771e-7, 7.7585489624948031e-4,
+         1.5597668529004373e-4, 4.9926620576534573e-14, 0.0, 6.7718890050008472e-6, 0.0,
+         7.1052455549903861e-7, 0.0, 0.0, false, true}};
 
     // Sync to device
     KTH::view_1d<CloudWaterConservationData> cwdc_host("cwdc_host", max_pack_size);
@@ -270,8 +286,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack qc, qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend, qc2qi_hetero_freeze_tend,
-              qc2qr_ice_shed_tend, qc2qi_berg_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qcheti_cnt, qicnt;
+          Spack qc, qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend,
+              qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend, qc2qi_berg_tend, qi2qv_sublim_tend,
+              qv2qi_vapdep_tend, qcheti_cnt, qicnt;
           Smask context;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             qc[s]                       = cwdc_device(vs).qc;
@@ -289,10 +306,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
           }
           const bool use_hetfrz_classnuc = false;
 
-          Functions::cloud_water_conservation(qc, cwdc_device(0).dt, qc2qr_autoconv_tend, qc2qr_accret_tend,
-                                              qc2qi_collect_tend, qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend,
-                                              qc2qi_berg_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qcheti_cnt, qicnt,
-                                              use_hetfrz_classnuc, context);
+          Functions::cloud_water_conservation(
+              qc, cwdc_device(0).dt, qc2qr_autoconv_tend, qc2qr_accret_tend, qc2qi_collect_tend,
+              qc2qi_hetero_freeze_tend, qc2qr_ice_shed_tend, qc2qi_berg_tend, qi2qv_sublim_tend,
+              qv2qi_vapdep_tend, qcheti_cnt, qicnt, use_hetfrz_classnuc, context);
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             cwdc_device(vs).qc                       = qc[s];
@@ -335,27 +352,41 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
     using KTH = KokkosTypes<HostDevice>;
 
     IceWaterConservationData iwdc[max_pack_size] = {
-        // qi, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend, qr2qi_collect_tend, qc2qi_collect_tend,
-        // qr2qi_immers_freeze_tend, qc2qi_hetero_freeze_tend, iwdc_device(0).dt, qi2qv_sublim_tend, qi2qr_melt_tend,
+        // qi, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend, qr2qi_collect_tend,
+        // qc2qi_collect_tend,
+        // qr2qi_immers_freeze_tend, qc2qi_hetero_freeze_tend, iwdc_device(0).dt, qi2qv_sublim_tend,
+        // qi2qr_melt_tend,
         // qinuc_cnt, qcheti_cnt, qicnt, use_hetfrz_classnuc, context
-        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 1.9205467584100191e-4, 0.0, 0.0, 0.0, false, true},
-        {5.0e-8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 1.8234653652173277e-7, 0.0, 0.0, 0.0, 0.0, false, true},
-        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 2.3237448636383435e-3, 0.0, 0.0, 0.0, false, true},
+        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 1.9205467584100191e-4, 0.0, 0.0,
+         0.0, false, true},
+        {5.0e-8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 1.8234653652173277e-7, 0.0, 0.0, 0.0,
+         0.0, false, true},
+        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 2.3237448636383435e-3, 0.0, 0.0,
+         0.0, false, true},
         {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
 
-        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 1.9205467584100191e-4, 0.0, 0.0, 0.0, false, true},
-        {5.0e-8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 1.8234653652173277e-7, 0.0, 0.0, 0.0, 0.0, false, true},
-        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 2.3237448636383435e-3, 0.0, 0.0, 0.0, false, true},
+        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 1.9205467584100191e-4, 0.0, 0.0,
+         0.0, false, true},
+        {5.0e-8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 1.8234653652173277e-7, 0.0, 0.0, 0.0,
+         0.0, false, true},
+        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 2.3237448636383435e-3, 0.0, 0.0,
+         0.0, false, true},
         {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
 
-        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 1.9205467584100191e-4, 0.0, 0.0, 0.0, false, true},
-        {5.0e-8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 1.8234653652173277e-7, 0.0, 0.0, 0.0, 0.0, false, true},
-        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 2.3237448636383435e-3, 0.0, 0.0, 0.0, false, true},
+        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 1.9205467584100191e-4, 0.0, 0.0,
+         0.0, false, true},
+        {5.0e-8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 1.8234653652173277e-7, 0.0, 0.0, 0.0,
+         0.0, false, true},
+        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 2.3237448636383435e-3, 0.0, 0.0,
+         0.0, false, true},
         {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true},
 
-        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 1.9205467584100191e-4, 0.0, 0.0, 0.0, false, true},
-        {5.0e-8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 1.8234653652173277e-7, 0.0, 0.0, 0.0, 0.0, false, true},
-        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 2.3237448636383435e-3, 0.0, 0.0, 0.0, false, true},
+        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 1.9205467584100191e-4, 0.0, 0.0,
+         0.0, false, true},
+        {5.0e-8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 1.8234653652173277e-7, 0.0, 0.0, 0.0,
+         0.0, false, true},
+        {1.0e-4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 2.3237448636383435e-3, 0.0, 0.0,
+         0.0, false, true},
         {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 0.0, 0.0, 0.0, 0.0, false, true}};
 
     // Sync to device
@@ -379,9 +410,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack qi, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend, qr2qi_collect_tend, qc2qi_collect_tend,
-              qr2qi_immers_freeze_tend, qc2qi_hetero_freeze_tend, qi2qv_sublim_tend, qi2qr_melt_tend, qinuc_cnt,
-              qcheti_cnt, qicnt;
+          Spack qi, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend, qr2qi_collect_tend,
+              qc2qi_collect_tend, qr2qi_immers_freeze_tend, qc2qi_hetero_freeze_tend,
+              qi2qv_sublim_tend, qi2qr_melt_tend, qinuc_cnt, qcheti_cnt, qicnt;
           Smask context;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             qi[s]                       = iwdc_device(vs).qi;
@@ -400,10 +431,11 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
             context.set(s, iwdc_device(vs).context);
           }
           const bool use_hetfrz_classnuc = false;
-          Functions::ice_water_conservation(qi, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend,
-                                            qr2qi_collect_tend, qc2qi_collect_tend, qr2qi_immers_freeze_tend,
-                                            qc2qi_hetero_freeze_tend, iwdc_device(0).dt, qinuc_cnt, qcheti_cnt, qicnt,
-                                            qi2qv_sublim_tend, qi2qr_melt_tend, use_hetfrz_classnuc, context);
+          Functions::ice_water_conservation(
+              qi, qv2qi_vapdep_tend, qv2qi_nucleat_tend, qc2qi_berg_tend, qr2qi_collect_tend,
+              qc2qi_collect_tend, qr2qi_immers_freeze_tend, qc2qi_hetero_freeze_tend,
+              iwdc_device(0).dt, qinuc_cnt, qcheti_cnt, qicnt, qi2qv_sublim_tend, qi2qr_melt_tend,
+              use_hetfrz_classnuc, context);
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             iwdc_device(vs).qi                       = qi[s];
@@ -448,39 +480,40 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
     using KTH = KokkosTypes<HostDevice>;
 
     RainWaterConservationData rwdc[max_pack_size] = {
-        // qr, qc2qr_autoconv_tend, qc2qr_accret_tend, qi2qr_melt_tend, qc2qr_ice_shed_tend, rwdc_device(0).dt,
+        // qr, qc2qr_autoconv_tend, qc2qr_accret_tend, qi2qr_melt_tend, qc2qr_ice_shed_tend,
+        // rwdc_device(0).dt,
         // qr2qv_evap_tend, qr2qi_collect_tend, qr2qi_immers_freeze_tend
         {0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 0.0, 0.0},
-        {3.6842105263157901e-6, 1.8910609577335389e-12, 6.5659507736611415e-9, 2.0267066625093075e-3,
-         1.3686661018890648e-9, 1800.0, 0.0, 0.0, 0.0},
-        {1.0000000000000001e-5, 1.3239078166546396e-11, 4.5967389456540289e-8, 0.0, 0.0, 1800.0, 0.0,
-         1.4619847302347994e-33, 1.3104200383028957e-8},
-        {8.9473684210526319e-6, 1.1338778389922441e-11, 3.9369360589471763e-8, 0.0, 0.0, 1800.0, 0.0,
-         1.4495908589465900e-33, 8.5051489557327688e-10},
+        {3.6842105263157901e-6, 1.8910609577335389e-12, 6.5659507736611415e-9,
+         2.0267066625093075e-3, 1.3686661018890648e-9, 1800.0, 0.0, 0.0, 0.0},
+        {1.0000000000000001e-5, 1.3239078166546396e-11, 4.5967389456540289e-8, 0.0, 0.0, 1800.0,
+         0.0, 1.4619847302347994e-33, 1.3104200383028957e-8},
+        {8.9473684210526319e-6, 1.1338778389922441e-11, 3.9369360589471763e-8, 0.0, 0.0, 1800.0,
+         0.0, 1.4495908589465900e-33, 8.5051489557327688e-10},
 
         {0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 0.0, 0.0},
-        {3.6842105263157901e-6, 1.8910609577335389e-12, 6.5659507736611415e-9, 2.0267066625093075e-3,
-         1.3686661018890648e-9, 1800.0, 0.0, 0.0, 0.0},
-        {1.0000000000000001e-5, 1.3239078166546396e-11, 4.5967389456540289e-8, 0.0, 0.0, 1800.0, 0.0,
-         1.4619847302347994e-33, 1.3104200383028957e-8},
-        {8.9473684210526319e-6, 1.1338778389922441e-11, 3.9369360589471763e-8, 0.0, 0.0, 1800.0, 0.0,
-         1.4495908589465900e-33, 8.5051489557327688e-10},
+        {3.6842105263157901e-6, 1.8910609577335389e-12, 6.5659507736611415e-9,
+         2.0267066625093075e-3, 1.3686661018890648e-9, 1800.0, 0.0, 0.0, 0.0},
+        {1.0000000000000001e-5, 1.3239078166546396e-11, 4.5967389456540289e-8, 0.0, 0.0, 1800.0,
+         0.0, 1.4619847302347994e-33, 1.3104200383028957e-8},
+        {8.9473684210526319e-6, 1.1338778389922441e-11, 3.9369360589471763e-8, 0.0, 0.0, 1800.0,
+         0.0, 1.4495908589465900e-33, 8.5051489557327688e-10},
 
         {0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 0.0, 0.0},
-        {3.6842105263157901e-6, 1.8910609577335389e-12, 6.5659507736611415e-9, 2.0267066625093075e-3,
-         1.3686661018890648e-9, 1800.0, 0.0, 0.0, 0.0},
-        {1.0000000000000001e-5, 1.3239078166546396e-11, 4.5967389456540289e-8, 0.0, 0.0, 1800.0, 0.0,
-         1.4619847302347994e-33, 1.3104200383028957e-8},
-        {8.9473684210526319e-6, 1.1338778389922441e-11, 3.9369360589471763e-8, 0.0, 0.0, 1800.0, 0.0,
-         1.4495908589465900e-33, 8.5051489557327688e-10},
+        {3.6842105263157901e-6, 1.8910609577335389e-12, 6.5659507736611415e-9,
+         2.0267066625093075e-3, 1.3686661018890648e-9, 1800.0, 0.0, 0.0, 0.0},
+        {1.0000000000000001e-5, 1.3239078166546396e-11, 4.5967389456540289e-8, 0.0, 0.0, 1800.0,
+         0.0, 1.4619847302347994e-33, 1.3104200383028957e-8},
+        {8.9473684210526319e-6, 1.1338778389922441e-11, 3.9369360589471763e-8, 0.0, 0.0, 1800.0,
+         0.0, 1.4495908589465900e-33, 8.5051489557327688e-10},
 
         {0.0, 0.0, 0.0, 0.0, 0.0, 1800.0, 0.0, 0.0, 0.0},
-        {3.6842105263157901e-6, 1.8910609577335389e-12, 6.5659507736611415e-9, 2.0267066625093075e-3,
-         1.3686661018890648e-9, 1800.0, 0.0, 0.0, 0.0},
-        {1.0000000000000001e-5, 1.3239078166546396e-11, 4.5967389456540289e-8, 0.0, 0.0, 1800.0, 0.0,
-         1.4619847302347994e-33, 1.3104200383028957e-8},
-        {8.9473684210526319e-6, 1.1338778389922441e-11, 3.9369360589471763e-8, 0.0, 0.0, 1800.0, 0.0,
-         1.4495908589465900e-33, 8.5051489557327688e-10}};
+        {3.6842105263157901e-6, 1.8910609577335389e-12, 6.5659507736611415e-9,
+         2.0267066625093075e-3, 1.3686661018890648e-9, 1800.0, 0.0, 0.0, 0.0},
+        {1.0000000000000001e-5, 1.3239078166546396e-11, 4.5967389456540289e-8, 0.0, 0.0, 1800.0,
+         0.0, 1.4619847302347994e-33, 1.3104200383028957e-8},
+        {8.9473684210526319e-6, 1.1338778389922441e-11, 3.9369360589471763e-8, 0.0, 0.0, 1800.0,
+         0.0, 1.4495908589465900e-33, 8.5051489557327688e-10}};
 
     // Sync to device
     KTH::view_1d<RainWaterConservationData> rwdc_host("rwdc_host", max_pack_size);
@@ -503,8 +536,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
           const Int offset = i * Spack::n;
 
           // Init pack inputs
-          Spack qr, qc2qr_autoconv_tend, qc2qr_accret_tend, qi2qr_melt_tend, qc2qr_ice_shed_tend, qr2qv_evap_tend,
-              qr2qi_collect_tend, qr2qi_immers_freeze_tend;
+          Spack qr, qc2qr_autoconv_tend, qc2qr_accret_tend, qi2qr_melt_tend, qc2qr_ice_shed_tend,
+              qr2qv_evap_tend, qr2qi_collect_tend, qr2qi_immers_freeze_tend;
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             qr[s]                       = rwdc_device(vs).qr;
             qc2qr_autoconv_tend[s]      = rwdc_device(vs).qc2qr_autoconv_tend;
@@ -516,9 +549,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
             qr2qi_immers_freeze_tend[s] = rwdc_device(vs).qr2qi_immers_freeze_tend;
           }
 
-          Functions::rain_water_conservation(qr, qc2qr_autoconv_tend, qc2qr_accret_tend, qi2qr_melt_tend,
-                                             qc2qr_ice_shed_tend, rwdc_device(0).dt, qr2qv_evap_tend,
-                                             qr2qi_collect_tend, qr2qi_immers_freeze_tend);
+          Functions::rain_water_conservation(
+              qr, qc2qr_autoconv_tend, qc2qr_accret_tend, qi2qr_melt_tend, qc2qr_ice_shed_tend,
+              rwdc_device(0).dt, qr2qv_evap_tend, qr2qi_collect_tend, qr2qi_immers_freeze_tend);
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
             rwdc_device(vs).qr                       = qr[s];
@@ -563,7 +596,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3Conservation : public
   }
 };
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestP3UpdatePrognosticIce : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestP3UpdatePrognosticIce : public UnitWrap::UnitTest<D>::Base {
   void update_prognostic_ice_unit_bfb_tests() {
 
     constexpr Scalar nmltratio   = C::nmltratio;
@@ -982,11 +1016,12 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3UpdatePrognosticIce :
 
           // Init pack inputs
           Spack qc2qi_hetero_freeze_tend, qc2qi_collect_tend, qc2qr_ice_shed_tend, nc_collect_tend,
-              nc2ni_immers_freeze_tend, ncshdc, qr2qi_collect_tend, nr_collect_tend, qr2qi_immers_freeze_tend,
-              nr2ni_immers_freeze_tend, nr_ice_shed_tend, qi2qr_melt_tend, ni2nr_melt_tend, qi2qv_sublim_tend,
-              qv2qi_vapdep_tend, qv2qi_nucleat_tend, ni_nucleat_tend, ni_selfcollect_tend, ni_sublim_tend,
-              qc2qi_berg_tend, inv_exner, rho_qm_cloud, ncheti_cnt, nicnt, ninuc_cnt, qcheti_cnt, qicnt, qinuc_cnt,
-              th_atm, qv, qc, nc, qr, nr, qi, ni, qm, bm;
+              nc2ni_immers_freeze_tend, ncshdc, qr2qi_collect_tend, nr_collect_tend,
+              qr2qi_immers_freeze_tend, nr2ni_immers_freeze_tend, nr_ice_shed_tend, qi2qr_melt_tend,
+              ni2nr_melt_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qv2qi_nucleat_tend,
+              ni_nucleat_tend, ni_selfcollect_tend, ni_sublim_tend, qc2qi_berg_tend, inv_exner,
+              rho_qm_cloud, ncheti_cnt, nicnt, ninuc_cnt, qcheti_cnt, qicnt, qinuc_cnt, th_atm, qv,
+              qc, nc, qr, nr, qi, ni, qm, bm;
           Scalar dt;
           Smask log_wetgrowth, context;
 
@@ -1041,12 +1076,13 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3UpdatePrognosticIce :
           const bool use_hetfrz_classnuc = false;
           Functions::update_prognostic_ice(
               qc2qi_hetero_freeze_tend, qc2qi_collect_tend, qc2qr_ice_shed_tend, nc_collect_tend,
-              nc2ni_immers_freeze_tend, ncshdc, qr2qi_collect_tend, nr_collect_tend, qr2qi_immers_freeze_tend,
-              nr2ni_immers_freeze_tend, nr_ice_shed_tend, qi2qr_melt_tend, ni2nr_melt_tend, qi2qv_sublim_tend,
-              qv2qi_vapdep_tend, qv2qi_nucleat_tend, ni_nucleat_tend, ni_selfcollect_tend, ni_sublim_tend,
-              qc2qi_berg_tend, inv_exner, do_predict_nc, log_wetgrowth, dt, pupidc_device(0).nmltratio, rho_qm_cloud,
-              ncheti_cnt, nicnt, ninuc_cnt, qcheti_cnt, qicnt, qinuc_cnt, th_atm, qv, qi, ni, qm, bm, qc, nc, qr, nr,
-              use_hetfrz_classnuc, context);
+              nc2ni_immers_freeze_tend, ncshdc, qr2qi_collect_tend, nr_collect_tend,
+              qr2qi_immers_freeze_tend, nr2ni_immers_freeze_tend, nr_ice_shed_tend, qi2qr_melt_tend,
+              ni2nr_melt_tend, qi2qv_sublim_tend, qv2qi_vapdep_tend, qv2qi_nucleat_tend,
+              ni_nucleat_tend, ni_selfcollect_tend, ni_sublim_tend, qc2qi_berg_tend, inv_exner,
+              do_predict_nc, log_wetgrowth, dt, pupidc_device(0).nmltratio, rho_qm_cloud,
+              ncheti_cnt, nicnt, ninuc_cnt, qcheti_cnt, qicnt, qinuc_cnt, th_atm, qv, qi, ni, qm,
+              bm, qc, nc, qr, nr, use_hetfrz_classnuc, context);
 
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
@@ -1091,14 +1127,16 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3UpdatePrognosticIce :
 
 }; // TestP3UpdatePrognosticIce
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestGetTimeSpacePhysVariables : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestGetTimeSpacePhysVariables : public UnitWrap::UnitTest<D>::Base {
   void get_time_space_phys_variables_unit_bfb_tests() {
     constexpr Scalar latvap = C::LatVap;
     constexpr Scalar latice = C::LatIce;
 
     // baseline generated data is input to the following
     GetTimeSpacePhysVarsData gtspvd[max_pack_size] = {
-        //        T_atm,       pres,        rho,       latent_heat_vapor,       latent_heat_sublim,        qv_sat_l,
+        //        T_atm,       pres,        rho,       latent_heat_vapor,       latent_heat_sublim,
+        //        qv_sat_l,
         //        qv_sat_i
         {2.9792E+02, 9.8711E+04, 1.1532E+00, latvap, latvap + latice, 2.0321E-02, 2.0321E-02},
         {2.9792E+02, 9.8711E+04, 1.1532E+00, latvap, latvap + latice, 2.0321E-02, 2.0321E-02},
@@ -1159,8 +1197,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestGetTimeSpacePhysVariable
             eii[s]    = gtspvd_device(vs).eii;
           }
 
-          Functions::get_time_space_phys_variables(T_atm, pres, rho, qv_sat_l, qv_sat_i, mu, dv, sc, dqsdt, dqsidt, ab,
-                                                   abi, kap, eii);
+          Functions::get_time_space_phys_variables(T_atm, pres, rho, qv_sat_l, qv_sat_i, mu, dv, sc,
+                                                   dqsdt, dqsidt, ab, abi, kap, eii);
 
           // Copy results back into views
           for (Int s = 0, vs = offset; s < Spack::n; ++s, ++vs) {
@@ -1208,7 +1246,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestGetTimeSpacePhysVariable
   void run_bfb() { get_time_space_phys_variables_unit_bfb_tests(); }
 }; // TestGetTimeSpacePhysVariables
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestP3UpdatePrognosticLiq : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestP3UpdatePrognosticLiq : public UnitWrap::UnitTest<D>::Base {
   void update_prognostic_liquid_unit_bfb_tests() {
     constexpr Scalar latvap = C::LatVap;
 
@@ -1302,8 +1341,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3UpdatePrognosticLiq :
 
           // Init pack inputs
           Spack qc2qr_accret_tend, nc_accret_tend, qc2qr_autoconv_tend, nc2nr_autoconv_tend, ncautr,
-              nc_selfcollect_tend, qr2qv_evap_tend, nr_evap_tend, nr_selfcollect_tend, inv_rho, inv_exner, th_atm, qv,
-              qc, nc, qr, nr;
+              nc_selfcollect_tend, qr2qv_evap_tend, nr_evap_tend, nr_selfcollect_tend, inv_rho,
+              inv_exner, th_atm, qv, qc, nc, qr, nr;
           bool do_predict_nc, do_prescribed_CCN;
           Scalar dt;
 
@@ -1333,10 +1372,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestP3UpdatePrognosticLiq :
             nr[s]     = pupldc_device(vs).nr;
           }
 
-          Functions::update_prognostic_liquid(qc2qr_accret_tend, nc_accret_tend, qc2qr_autoconv_tend,
-                                              nc2nr_autoconv_tend, ncautr, nc_selfcollect_tend, qr2qv_evap_tend,
-                                              nr_evap_tend, nr_selfcollect_tend, do_predict_nc, do_prescribed_CCN,
-                                              inv_rho, inv_exner, dt, th_atm, qv, qc, nc, qr, nr);
+          Functions::update_prognostic_liquid(
+              qc2qr_accret_tend, nc_accret_tend, qc2qr_autoconv_tend, nc2nr_autoconv_tend, ncautr,
+              nc_selfcollect_tend, qr2qv_evap_tend, nr_evap_tend, nr_selfcollect_tend,
+              do_predict_nc, do_prescribed_CCN, inv_rho, inv_exner, dt, th_atm, qv, qc, nc, qr, nr);
 
           // Copy results back into views
           pupldc_device(0).dt            = dt;
@@ -1478,28 +1517,32 @@ TEST_CASE("p3_conservation_test", "[p3_unit_tests]") {
 }
 
 TEST_CASE("p3_get_time_space_phys_variables_test", "[p3_unit_tests]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestGetTimeSpacePhysVariables;
+  using T = scream::p3::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestGetTimeSpacePhysVariables;
 
   T t;
   t.run_bfb();
 }
 
 TEST_CASE("p3_update_prognostic_ice_test", "[p3_unit_tests]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestP3UpdatePrognosticIce;
+  using T =
+      scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestP3UpdatePrognosticIce;
 
   T t;
   t.run_bfb();
 }
 
 TEST_CASE("p3_update_prognostic_liquid_test", "[p3_unit_tests]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestP3UpdatePrognosticLiq;
+  using T =
+      scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestP3UpdatePrognosticLiq;
 
   T t;
   t.run_bfb();
 }
 
 TEST_CASE("p3_impose_max_total_ni_test", "[p3_unit_tests]") {
-  using T = scream::p3::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestP3FunctionsImposeMaxTotalNi;
+  using T = scream::p3::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestP3FunctionsImposeMaxTotalNi;
 
   T t;
   t.run_bfb();
diff --git i/components/eamxx/src/physics/p3/tests/p3_upwind_unit_tests.cpp w/components/eamxx/src/physics/p3/tests/p3_upwind_unit_tests.cpp
index eee25a4b76..cb15c41f82 100644
--- i/components/eamxx/src/physics/p3/tests/p3_upwind_unit_tests.cpp
+++ w/components/eamxx/src/physics/p3/tests/p3_upwind_unit_tests.cpp
@@ -33,7 +33,8 @@ namespace unit_test {
 // profile should be nontrivial. Also, it is initialized so the first and last
 // cells in the domain are 0. This lets us check the restricted-domain usage of
 // the upwind routine in the first time step.
-template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys() {
     using ekat::repack;
@@ -50,7 +51,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap
       const Real dt = min_dz / max_speed;
 
       view_1d<Pack> rho("rho", npack), inv_rho("inv_rho", npack), inv_dz("inv_dz", npack);
-      const auto lrho = repack<SPS>(rho), linv_rho = repack<SPS>(inv_rho), linv_dz = repack<SPS>(inv_dz);
+      const auto lrho = repack<SPS>(rho), linv_rho = repack<SPS>(inv_rho),
+                 linv_dz = repack<SPS>(inv_dz);
 
       Kokkos::Array<view_1d<Pack>, nfield> flux, V, r;
       Kokkos::Array<uview_1d<Spack>, nfield> lflux, lV, lr;
@@ -93,7 +95,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap
           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, npack), set_fields);
           team.team_barrier();
         };
-        Kokkos::parallel_for(ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(1, npack), init_fields);
+        Kokkos::parallel_for(ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(1, npack),
+                             init_fields);
 
         const auto sflux = scalarize(flux[1]);
         for (Int time_step = 0; time_step < 2 * nk; ++time_step) {
@@ -105,7 +108,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap
             // Gather diagnostics: total mass and extremal mixing ratio values.
             const auto gather_diagnostics = [&](Scalar &mass, Scalar &r_min, Scalar &r_max) {
               mass                = 0;
-              const auto sum_mass = [&](const Int &k, Scalar &mass) { mass += srho(k) * sr(k) / sinv_dz(k); };
+              const auto sum_mass = [&](const Int &k, Scalar &mass) {
+                mass += srho(k) * sr(k) / sinv_dz(k);
+              };
               Kokkos::parallel_reduce(Kokkos::TeamVectorRange(team, nk), sum_mass, mass);
 
               const auto find_max_r = [&](const Int &k, Scalar &r_max) {
@@ -129,13 +134,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap
                 const auto mixing_ratio_true = sr(k) / sr0(k);
                 r_max                        = ekat::impl::max(mixing_ratio_true, r_max);
               };
-              Kokkos::parallel_reduce(Kokkos::TeamVectorRange(team, nk), find_max_r, Kokkos::Max<Scalar>(r_max));
+              Kokkos::parallel_reduce(Kokkos::TeamVectorRange(team, nk), find_max_r,
+                                      Kokkos::Max<Scalar>(r_max));
 
               const auto find_min_r = [&](const Int &k, Scalar &r_min) {
                 const auto mixing_ratio_true = sr(k) / sr0(k);
                 r_min                        = ekat::impl::min(mixing_ratio_true, r_min);
               };
-              Kokkos::parallel_reduce(Kokkos::TeamVectorRange(team, nk), find_min_r, Kokkos::Min<Scalar>(r_min));
+              Kokkos::parallel_reduce(Kokkos::TeamVectorRange(team, nk), find_min_r,
+                                      Kokkos::Min<Scalar>(r_min));
             };
 
             // Gather diagnostics before the step.
@@ -150,19 +157,19 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap
               // restricting the interval. But the IC for r[0] does not permit
               // it. Thus, make two calls to the upwind routine:
               //   1. Full domain for r[0].
-              Functions::calc_first_order_upwind_step(lrho, linv_rho, linv_dz, team, nk, k_bot, k_top, kdir, dt,
-                                                      lflux[0], lV[0], lr[0]);
+              Functions::calc_first_order_upwind_step(lrho, linv_rho, linv_dz, team, nk, k_bot,
+                                                      k_top, kdir, dt, lflux[0], lV[0], lr[0]);
               k_bot_lcl += kdir;
               k_top_lcl -= kdir;
               //   2. Restricted domain for r[1] in first time step only. Note
               // that the restriction is unnecesary but just here to test the
               // restriction code.
-              Functions::calc_first_order_upwind_step(lrho, linv_rho, linv_dz, team, nk, k_bot_lcl, k_top_lcl, kdir, dt,
-                                                      lflux[1], lV[1], lr[1]);
+              Functions::calc_first_order_upwind_step(lrho, linv_rho, linv_dz, team, nk, k_bot_lcl,
+                                                      k_top_lcl, kdir, dt, lflux[1], lV[1], lr[1]);
             } else {
-              Functions::template calc_first_order_upwind_step<nfield>(lrho, linv_rho, linv_dz, team, nk, k_bot_lcl,
-                                                                       k_top_lcl, kdir, dt, {&lflux[0], &lflux[1]},
-                                                                       {&lV[0], &lV[1]}, {&lr[0], &lr[1]});
+              Functions::template calc_first_order_upwind_step<nfield>(
+                  lrho, linv_rho, linv_dz, team, nk, k_bot_lcl, k_top_lcl, kdir, dt,
+                  {&lflux[0], &lflux[1]}, {&lV[0], &lV[1]}, {&lr[0], &lr[1]});
             }
             team.team_barrier();
 
@@ -185,7 +192,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap
               ++nerr;
           };
           Int lnerr;
-          Kokkos::parallel_reduce(ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(1, npack), step, lnerr);
+          Kokkos::parallel_reduce(ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(1, npack),
+                                  step, lnerr);
           nerr += lnerr;
           Kokkos::fence();
           REQUIRE(nerr == 0);
@@ -200,9 +208,12 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap
 
     CalcUpwindData cuds_baseline[] = {
         // kts, kte, kdir, kbot, k_qxtop, na,   dt_sub,
-        CalcUpwindData(1, 72, -1, 72, 36, 2, 1.833E+03), CalcUpwindData(1, 72, 1, 36, 72, 2, 1.833E+03),
-        CalcUpwindData(1, 72, -1, 72, 36, 4, 1.833E+03), CalcUpwindData(1, 72, -1, 72, 72, 2, 1.833E+03),
-        CalcUpwindData(1, 32, -1, 24, 8, 2, 1.833E+03),  CalcUpwindData(1, 32, 1, 7, 21, 1, 1.833E+03),
+        CalcUpwindData(1, 72, -1, 72, 36, 2, 1.833E+03),
+        CalcUpwindData(1, 72, 1, 36, 72, 2, 1.833E+03),
+        CalcUpwindData(1, 72, -1, 72, 36, 4, 1.833E+03),
+        CalcUpwindData(1, 72, -1, 72, 72, 2, 1.833E+03),
+        CalcUpwindData(1, 32, -1, 24, 8, 2, 1.833E+03),
+        CalcUpwindData(1, 32, 1, 7, 21, 1, 1.833E+03),
         CalcUpwindData(1, 32, -1, 21, 7, 1, 1.833E+03),
     };
 
@@ -216,8 +227,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap
     // Create copies of data for use by cxx. Needs to happen before reads so that
     // inout data is in original state
     CalcUpwindData cuds_cxx[num_runs] = {
-        CalcUpwindData(cuds_baseline[0]), CalcUpwindData(cuds_baseline[1]), CalcUpwindData(cuds_baseline[2]),
-        CalcUpwindData(cuds_baseline[3]), CalcUpwindData(cuds_baseline[4]), CalcUpwindData(cuds_baseline[5]),
+        CalcUpwindData(cuds_baseline[0]), CalcUpwindData(cuds_baseline[1]),
+        CalcUpwindData(cuds_baseline[2]), CalcUpwindData(cuds_baseline[3]),
+        CalcUpwindData(cuds_baseline[4]), CalcUpwindData(cuds_baseline[5]),
         CalcUpwindData(cuds_baseline[6]),
     };
 
@@ -233,8 +245,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap
     for (auto &d : cuds_cxx) {
       Real **fluxes, **vs, **qnx;
       d.convert_to_ptr_arr(tmp1, fluxes, vs, qnx);
-      calc_first_order_upwind_step_host(d.kts, d.kte, d.kdir, d.kbot, d.k_qxtop, d.dt_sub, d.rho, d.inv_rho, d.inv_dz,
-                                        d.num_arrays, fluxes, vs, qnx);
+      calc_first_order_upwind_step_host(d.kts, d.kte, d.kdir, d.kbot, d.k_qxtop, d.dt_sub, d.rho,
+                                        d.inv_rho, d.inv_dz, d.num_arrays, fluxes, vs, qnx);
     }
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
@@ -262,7 +274,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpwind : public UnitWrap
   }
 };
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestGenSed : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestGenSed : public UnitWrap::UnitTest<D>::Base {
 
   void run_phys() {
     // TODO
@@ -273,7 +286,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestGenSed : public UnitWrap
     auto engine = Base::get_engine();
 
     GenSedData gsds_baseline[] = {
-        //       kts, kte, kdir, k_qxtop, k_qxbot, kbot,     Co_max,   dt_left, prt_accum, num_arrays
+        //       kts, kte, kdir, k_qxtop, k_qxbot, kbot,     Co_max,   dt_left, prt_accum,
+        //       num_arrays
         GenSedData(1, 72, -1, 36, 72, 72, 9.196E-02, 1.818E+01, 4.959E-05, 2),
         GenSedData(1, 72, -1, 36, 57, 72, 4.196E-01, 1.418E+02, 4.959E-06, 1),
         GenSedData(1, 72, 1, 57, 37, 36, 4.196E-01, 1.418E+02, 4.959E-06, 1),
@@ -308,15 +322,17 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestGenSed : public UnitWrap
     for (auto &d : gsds_cxx) {
       Real **fluxes, **vs, **qnx;
       d.convert_to_ptr_arr(tmp1, fluxes, vs, qnx);
-      generalized_sedimentation_host(d.kts, d.kte, d.kdir, d.k_qxtop, &d.k_qxbot, d.kbot, d.Co_max, &d.dt_left,
-                                     &d.prt_accum, d.inv_dz, d.inv_rho, d.rho, d.num_arrays, fluxes, vs, qnx);
+      generalized_sedimentation_host(d.kts, d.kte, d.kdir, d.k_qxtop, &d.k_qxbot, d.kbot, d.Co_max,
+                                     &d.dt_left, &d.prt_accum, d.inv_dz, d.inv_rho, d.rho,
+                                     d.num_arrays, fluxes, vs, qnx);
     }
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
       for (Int i = 0; i < num_runs; ++i) {
         // Due to pack issues, we must restrict checks to the active k space
-        Int start = std::min(gsds_baseline[i].k_qxbot, gsds_baseline[i].k_qxtop) - 1; // 0-based indx
-        Int end   = std::max(gsds_baseline[i].k_qxbot, gsds_baseline[i].k_qxtop);     // 0-based indx
+        Int start =
+            std::min(gsds_baseline[i].k_qxbot, gsds_baseline[i].k_qxtop) - 1;   // 0-based indx
+        Int end = std::max(gsds_baseline[i].k_qxbot, gsds_baseline[i].k_qxtop); // 0-based indx
 
         Real **fluxesf90, **vsf90, **qnxf90, **fluxescxx, **vscxx, **qnxcxx;
         gsds_baseline[i].convert_to_ptr_arr(tmp1, fluxesf90, vsf90, qnxf90);
diff --git i/components/eamxx/src/physics/register_physics.hpp w/components/eamxx/src/physics/register_physics.hpp
index 8be22e4107..21b89207fe 100644
--- i/components/eamxx/src/physics/register_physics.hpp
+++ w/components/eamxx/src/physics/register_physics.hpp
@@ -73,8 +73,10 @@ inline void register_physics() {
   proc_factory.register_product("mam4_drydep", &create_atmosphere_process<MAMDryDep>);
   proc_factory.register_product("mam4_aci", &create_atmosphere_process<MAMAci>);
   proc_factory.register_product("mam4_wetscav", &create_atmosphere_process<MAMWetscav>);
-  proc_factory.register_product("mam4_srf_online_emiss", &create_atmosphere_process<MAMSrfOnlineEmiss>);
-  proc_factory.register_product("mam4_constituent_fluxes", &create_atmosphere_process<MAMConstituentFluxes>);
+  proc_factory.register_product("mam4_srf_online_emiss",
+                                &create_atmosphere_process<MAMSrfOnlineEmiss>);
+  proc_factory.register_product("mam4_constituent_fluxes",
+                                &create_atmosphere_process<MAMConstituentFluxes>);
 #endif
 #ifdef EAMXX_HAS_COSP
   proc_factory.register_product("Cosp", &create_atmosphere_process<Cosp>);
diff --git i/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_interface.cpp w/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_interface.cpp
index 921554f3d0..400c459c26 100644
--- i/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_interface.cpp
+++ w/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_interface.cpp
@@ -56,8 +56,9 @@ bool initialized_k = false;
 // local functions
 namespace {
 
-OpticalProps2str get_cloud_optics_sw(const int ncol, const int nlay, CloudOptics &cloud_optics, GasOpticsRRTMGP &kdist,
-                                     real2d &lwp, real2d &iwp, real2d &rel, real2d &rei) {
+OpticalProps2str get_cloud_optics_sw(const int ncol, const int nlay, CloudOptics &cloud_optics,
+                                     GasOpticsRRTMGP &kdist, real2d &lwp, real2d &iwp, real2d &rel,
+                                     real2d &rei) {
 
   // Initialize optics
   OpticalProps2str clouds;
@@ -80,8 +81,9 @@ OpticalProps2str get_cloud_optics_sw(const int ncol, const int nlay, CloudOptics
   return clouds;
 }
 
-OpticalProps1scl get_cloud_optics_lw(const int ncol, const int nlay, CloudOptics &cloud_optics, GasOpticsRRTMGP &kdist,
-                                     real2d &lwp, real2d &iwp, real2d &rel, real2d &rei) {
+OpticalProps1scl get_cloud_optics_lw(const int ncol, const int nlay, CloudOptics &cloud_optics,
+                                     GasOpticsRRTMGP &kdist, real2d &lwp, real2d &iwp, real2d &rel,
+                                     real2d &rei) {
 
   // Initialize optics
   OpticalProps1scl clouds;
@@ -104,12 +106,13 @@ OpticalProps1scl get_cloud_optics_lw(const int ncol, const int nlay, CloudOptics
   return clouds;
 }
 
-OpticalProps2str get_subsampled_clouds(const int ncol, const int nlay, const int nbnd, const int ngpt,
-                                       OpticalProps2str &cloud_optics, GasOpticsRRTMGP &kdist, real2d &cld,
-                                       real2d &p_lay) {
+OpticalProps2str get_subsampled_clouds(const int ncol, const int nlay, const int nbnd,
+                                       const int ngpt, OpticalProps2str &cloud_optics,
+                                       GasOpticsRRTMGP &kdist, real2d &cld, real2d &p_lay) {
   // Initialized subsampled optics
   OpticalProps2str subsampled_optics;
-  subsampled_optics.init(kdist.get_band_lims_wavenumber(), kdist.get_band_lims_gpoint(), "subsampled_optics");
+  subsampled_optics.init(kdist.get_band_lims_wavenumber(), kdist.get_band_lims_gpoint(),
+                         "subsampled_optics");
   subsampled_optics.alloc_2str(ncol, nlay);
   // Check that we do not have clouds with no optical properties; this would get corrected
   // when we assign optical props, but we want to use a "radiative cloud fraction"
@@ -129,8 +132,8 @@ OpticalProps2str get_subsampled_clouds(const int ncol, const int nlay, const int
   // Get subcolumn cloud mask; note that get_subcolumn_mask exposes overlap assumption as an option,
   // but the only currently supported options are 0 (trivial all-or-nothing cloud) or 1 (max-rand),
   // so overlap has not been exposed as an option beyond this subcolumn. In the future, we should
-  // support generalized overlap as well, with parameters derived from DPSCREAM simulations with very
-  // high resolution.
+  // support generalized overlap as well, with parameters derived from DPSCREAM simulations with
+  // very high resolution.
   int overlap = 1;
   // Get unique seeds for each column that are reproducible across different MPI rank layouts;
   // use decimal part of pressure for this, consistent with the implementation in EAM
@@ -158,12 +161,13 @@ OpticalProps2str get_subsampled_clouds(const int ncol, const int nlay, const int
   return subsampled_optics;
 }
 
-OpticalProps1scl get_subsampled_clouds(const int ncol, const int nlay, const int nbnd, const int ngpt,
-                                       OpticalProps1scl &cloud_optics, GasOpticsRRTMGP &kdist, real2d &cld,
-                                       real2d &p_lay) {
+OpticalProps1scl get_subsampled_clouds(const int ncol, const int nlay, const int nbnd,
+                                       const int ngpt, OpticalProps1scl &cloud_optics,
+                                       GasOpticsRRTMGP &kdist, real2d &cld, real2d &p_lay) {
   // Initialized subsampled optics
   OpticalProps1scl subsampled_optics;
-  subsampled_optics.init(kdist.get_band_lims_wavenumber(), kdist.get_band_lims_gpoint(), "subsampled_optics");
+  subsampled_optics.init(kdist.get_band_lims_wavenumber(), kdist.get_band_lims_gpoint(),
+                         "subsampled_optics");
   subsampled_optics.alloc_1scl(ncol, nlay);
   // Check that we do not have clouds with no optical properties; this would get corrected
   // when we assign optical props, but we want to use a "radiative cloud fraction"
@@ -187,8 +191,9 @@ OpticalProps1scl get_subsampled_clouds(const int ncol, const int nlay, const int
   // seed values for longwave and shortwave
   auto seeds = int1d("seeds", ncol);
   TIMED_KERNEL(parallel_for(
-      SimpleBounds<1>(ncol),
-      YAKL_LAMBDA(int icol) { seeds(icol) = 1e9 * (p_lay(icol, nlay - 1) - int(p_lay(icol, nlay - 1))); }));
+      SimpleBounds<1>(ncol), YAKL_LAMBDA(int icol) {
+        seeds(icol) = 1e9 * (p_lay(icol, nlay - 1) - int(p_lay(icol, nlay - 1)));
+      }));
   auto cldmask = get_subcolumn_mask(ncol, nlay, ngpt, cldfrac_rad, overlap, seeds);
   // Assign optical properties to subcolumns (note this implements MCICA)
   auto gpoint_bands = kdist.get_gpoint_bands();
@@ -212,8 +217,10 @@ OpticalProps1scl get_subsampled_clouds(const int ncol, const int nlay, const int
  * interface to radiation.
  */
 void rrtmgp_initialize(GasConcs &gas_concs, const std::string &coefficients_file_sw,
-                       const std::string &coefficients_file_lw, const std::string &cloud_optics_file_sw,
-                       const std::string &cloud_optics_file_lw, const std::shared_ptr<spdlog::logger> &logger) {
+                       const std::string &coefficients_file_lw,
+                       const std::string &cloud_optics_file_sw,
+                       const std::string &cloud_optics_file_lw,
+                       const std::shared_ptr<spdlog::logger> &logger) {
 
   // If we've already initialized, just exit
   if (initialized) {
@@ -247,17 +254,21 @@ void rrtmgp_finalize() {
   cloud_optics_lw.finalize(); //~CloudOptics();
 }
 
-void compute_band_by_band_surface_albedos(const int ncol, const int nswbands, real1d &sfc_alb_dir_vis,
-                                          real1d &sfc_alb_dir_nir, real1d &sfc_alb_dif_vis, real1d &sfc_alb_dif_nir,
+void compute_band_by_band_surface_albedos(const int ncol, const int nswbands,
+                                          real1d &sfc_alb_dir_vis, real1d &sfc_alb_dir_nir,
+                                          real1d &sfc_alb_dif_vis, real1d &sfc_alb_dif_nir,
                                           real2d &sfc_alb_dir, real2d &sfc_alb_dif) {
 
-  EKAT_ASSERT_MSG(initialized, "Error! rrtmgp_initialize must be called before GasOpticsRRTMGP object can be used.");
+  EKAT_ASSERT_MSG(
+      initialized,
+      "Error! rrtmgp_initialize must be called before GasOpticsRRTMGP object can be used.");
   auto wavenumber_limits = k_dist_sw.get_band_lims_wavenumber();
 
   EKAT_ASSERT_MSG(yakl::intrinsics::size(wavenumber_limits, 1) == 2,
                   "Error! 1st dimension for wavenumber_limits should be 2.");
   EKAT_ASSERT_MSG(yakl::intrinsics::size(wavenumber_limits, 2) == nswbands,
-                  "Error! 2nd dimension for wavenumber_limits should be " + std::to_string(nswbands) + " (nswbands).");
+                  "Error! 2nd dimension for wavenumber_limits should be " +
+                      std::to_string(nswbands) + " (nswbands).");
 
   // Loop over bands, and determine for each band whether it is broadly in the
   // visible or infrared part of the spectrum (visible or "not visible")
@@ -268,8 +279,10 @@ void compute_band_by_band_surface_albedos(const int ncol, const int nswbands, re
 
         // Wavenumber is in the visible if it is above the visible wavenumber
         // threshold, and in the infrared if it is below the threshold
-        const bool is_visible_wave1 = (wavenumber_limits(1, ibnd) > visible_wavenumber_threshold ? true : false);
-        const bool is_visible_wave2 = (wavenumber_limits(2, ibnd) > visible_wavenumber_threshold ? true : false);
+        const bool is_visible_wave1 =
+            (wavenumber_limits(1, ibnd) > visible_wavenumber_threshold ? true : false);
+        const bool is_visible_wave2 =
+            (wavenumber_limits(2, ibnd) > visible_wavenumber_threshold ? true : false);
 
         if (is_visible_wave1 && is_visible_wave2) {
 
@@ -294,17 +307,21 @@ void compute_band_by_band_surface_albedos(const int ncol, const int nswbands, re
       }));
 }
 
-void compute_broadband_surface_fluxes(const int ncol, const int ktop, const int nswbands, real3d &sw_bnd_flux_dir,
-                                      real3d &sw_bnd_flux_dif, real1d &sfc_flux_dir_vis, real1d &sfc_flux_dir_nir,
+void compute_broadband_surface_fluxes(const int ncol, const int ktop, const int nswbands,
+                                      real3d &sw_bnd_flux_dir, real3d &sw_bnd_flux_dif,
+                                      real1d &sfc_flux_dir_vis, real1d &sfc_flux_dir_nir,
                                       real1d &sfc_flux_dif_vis, real1d &sfc_flux_dif_nir) {
-  // Band 10 straddles the near-IR and visible, so divide contributions from band 10 between both broadband sums
-  // TODO: Hard-coding these band indices is really bad practice. If the bands ever were to change (like when
-  // the RRTMG bands were re-ordered for RRTMGP), we would be using the wrong bands for the IR and UV/VIS. This
-  // should be refactored to grab the correct bands by specifying appropriate wavenumber rather than index.
-  // sfc_flux_dir_nir(i) = sum(sw_bnd_flux_dir(i+1,kbot,1:9))   + 0.5 * sw_bnd_flux_dir(i+1,kbot,10);
-  // sfc_flux_dir_vis(i) = sum(sw_bnd_flux_dir(i+1,kbot,11:14)) + 0.5 * sw_bnd_flux_dir(i+1,kbot,10);
-  // sfc_flux_dif_nir(i) = sum(sw_bnd_flux_dif(i+1,kbot,1:9))   + 0.5 * sw_bnd_flux_dif(i+1,kbot,10);
-  // sfc_flux_dif_vis(i) = sum(sw_bnd_flux_dif(i+1,kbot,11:14)) + 0.5 * sw_bnd_flux_dif(i+1,kbot,10);
+  // Band 10 straddles the near-IR and visible, so divide contributions from band 10 between both
+  // broadband sums
+  // TODO: Hard-coding these band indices is really bad practice. If the bands ever were to change
+  // (like when the RRTMG bands were re-ordered for RRTMGP), we would be using the wrong bands for
+  // the IR and UV/VIS. This should be refactored to grab the correct bands by specifying
+  // appropriate wavenumber rather than index. sfc_flux_dir_nir(i) =
+  // sum(sw_bnd_flux_dir(i+1,kbot,1:9))   + 0.5 * sw_bnd_flux_dir(i+1,kbot,10); sfc_flux_dir_vis(i)
+  // = sum(sw_bnd_flux_dir(i+1,kbot,11:14)) + 0.5 * sw_bnd_flux_dir(i+1,kbot,10);
+  // sfc_flux_dif_nir(i) = sum(sw_bnd_flux_dif(i+1,kbot,1:9))   + 0.5 *
+  // sw_bnd_flux_dif(i+1,kbot,10); sfc_flux_dif_vis(i) = sum(sw_bnd_flux_dif(i+1,kbot,11:14)) + 0.5
+  // * sw_bnd_flux_dif(i+1,kbot,10);
 
   // Initialize sums over bands
   memset(sfc_flux_dir_nir, 0);
@@ -320,8 +337,10 @@ void compute_broadband_surface_fluxes(const int ncol, const int ktop, const int
         for (int ibnd = 1; ibnd <= nswbands; ++ibnd) {
           // Wavenumber is in the visible if it is above the visible wavenumber
           // threshold, and in the infrared if it is below the threshold
-          const bool is_visible_wave1 = (wavenumber_limits(1, ibnd) > visible_wavenumber_threshold ? true : false);
-          const bool is_visible_wave2 = (wavenumber_limits(2, ibnd) > visible_wavenumber_threshold ? true : false);
+          const bool is_visible_wave1 =
+              (wavenumber_limits(1, ibnd) > visible_wavenumber_threshold ? true : false);
+          const bool is_visible_wave2 =
+              (wavenumber_limits(2, ibnd) > visible_wavenumber_threshold ? true : false);
 
           if (is_visible_wave1 && is_visible_wave2) {
 
@@ -348,20 +367,21 @@ void compute_broadband_surface_fluxes(const int ncol, const int ktop, const int
       }));
 }
 
-void rrtmgp_main(const int ncol, const int nlay, real2d &p_lay, real2d &t_lay, real2d &p_lev, real2d &t_lev,
-                 GasConcs &gas_concs, real2d &sfc_alb_dir, real2d &sfc_alb_dif, real1d &mu0, real2d &lwp, real2d &iwp,
-                 real2d &rel, real2d &rei, real2d &cldfrac, real3d &aer_tau_sw, real3d &aer_ssa_sw, real3d &aer_asm_sw,
-                 real3d &aer_tau_lw, real3d &cld_tau_sw_bnd, real3d &cld_tau_lw_bnd, real3d &cld_tau_sw_gpt,
-                 real3d &cld_tau_lw_gpt, real2d &sw_flux_up, real2d &sw_flux_dn, real2d &sw_flux_dn_dir,
-                 real2d &lw_flux_up, real2d &lw_flux_dn, real2d &sw_clnclrsky_flux_up, real2d &sw_clnclrsky_flux_dn,
-                 real2d &sw_clnclrsky_flux_dn_dir, real2d &sw_clrsky_flux_up, real2d &sw_clrsky_flux_dn,
-                 real2d &sw_clrsky_flux_dn_dir, real2d &sw_clnsky_flux_up, real2d &sw_clnsky_flux_dn,
-                 real2d &sw_clnsky_flux_dn_dir, real2d &lw_clnclrsky_flux_up, real2d &lw_clnclrsky_flux_dn,
-                 real2d &lw_clrsky_flux_up, real2d &lw_clrsky_flux_dn, real2d &lw_clnsky_flux_up,
-                 real2d &lw_clnsky_flux_dn, real3d &sw_bnd_flux_up, real3d &sw_bnd_flux_dn, real3d &sw_bnd_flux_dn_dir,
-                 real3d &lw_bnd_flux_up, real3d &lw_bnd_flux_dn, const Real tsi_scaling,
-                 const std::shared_ptr<spdlog::logger> &logger, const bool extra_clnclrsky_diag,
-                 const bool extra_clnsky_diag) {
+void rrtmgp_main(
+    const int ncol, const int nlay, real2d &p_lay, real2d &t_lay, real2d &p_lev, real2d &t_lev,
+    GasConcs &gas_concs, real2d &sfc_alb_dir, real2d &sfc_alb_dif, real1d &mu0, real2d &lwp,
+    real2d &iwp, real2d &rel, real2d &rei, real2d &cldfrac, real3d &aer_tau_sw, real3d &aer_ssa_sw,
+    real3d &aer_asm_sw, real3d &aer_tau_lw, real3d &cld_tau_sw_bnd, real3d &cld_tau_lw_bnd,
+    real3d &cld_tau_sw_gpt, real3d &cld_tau_lw_gpt, real2d &sw_flux_up, real2d &sw_flux_dn,
+    real2d &sw_flux_dn_dir, real2d &lw_flux_up, real2d &lw_flux_dn, real2d &sw_clnclrsky_flux_up,
+    real2d &sw_clnclrsky_flux_dn, real2d &sw_clnclrsky_flux_dn_dir, real2d &sw_clrsky_flux_up,
+    real2d &sw_clrsky_flux_dn, real2d &sw_clrsky_flux_dn_dir, real2d &sw_clnsky_flux_up,
+    real2d &sw_clnsky_flux_dn, real2d &sw_clnsky_flux_dn_dir, real2d &lw_clnclrsky_flux_up,
+    real2d &lw_clnclrsky_flux_dn, real2d &lw_clrsky_flux_up, real2d &lw_clrsky_flux_dn,
+    real2d &lw_clnsky_flux_up, real2d &lw_clnsky_flux_dn, real3d &sw_bnd_flux_up,
+    real3d &sw_bnd_flux_dn, real3d &sw_bnd_flux_dn_dir, real3d &lw_bnd_flux_up,
+    real3d &lw_bnd_flux_dn, const Real tsi_scaling, const std::shared_ptr<spdlog::logger> &logger,
+    const bool extra_clnclrsky_diag, const bool extra_clnsky_diag) {
 
 #ifdef SCREAM_RRTMGP_DEBUG
   // Sanity check inputs, and possibly repair
@@ -438,8 +458,9 @@ void rrtmgp_main(const int ncol, const int nlay, real2d &p_lay, real2d &t_lay, r
   aerosol_lw.init(k_dist_lw.get_band_lims_wavenumber());
   aerosol_lw.alloc_1scl(ncol, nlay);
   TIMED_KERNEL(parallel_for(
-      SimpleBounds<3>(nlwbands, nlay, ncol),
-      YAKL_LAMBDA(int ibnd, int ilay, int icol) { aerosol_lw.tau(icol, ilay, ibnd) = aer_tau_lw(icol, ilay, ibnd); }));
+      SimpleBounds<3>(nlwbands, nlay, ncol), YAKL_LAMBDA(int ibnd, int ilay, int icol) {
+        aerosol_lw.tau(icol, ilay, ibnd) = aer_tau_lw(icol, ilay, ibnd);
+      }));
 
 #ifdef SCREAM_RRTMGP_DEBUG
   // Check aerosol optical properties
@@ -452,19 +473,23 @@ void rrtmgp_main(const int ncol, const int nlay, real2d &p_lay, real2d &t_lay, r
 #endif
 
   // Convert cloud physical properties to optical properties for input to RRTMGP
-  OpticalProps2str clouds_sw = get_cloud_optics_sw(ncol, nlay, cloud_optics_sw, k_dist_sw, lwp, iwp, rel, rei);
-  OpticalProps1scl clouds_lw = get_cloud_optics_lw(ncol, nlay, cloud_optics_lw, k_dist_lw, lwp, iwp, rel, rei);
+  OpticalProps2str clouds_sw =
+      get_cloud_optics_sw(ncol, nlay, cloud_optics_sw, k_dist_sw, lwp, iwp, rel, rei);
+  OpticalProps1scl clouds_lw =
+      get_cloud_optics_lw(ncol, nlay, cloud_optics_lw, k_dist_lw, lwp, iwp, rel, rei);
   clouds_sw.tau.deep_copy_to(cld_tau_sw_bnd);
   clouds_lw.tau.deep_copy_to(cld_tau_lw_bnd);
 
   // Do subcolumn sampling to map bands -> gpoints based on cloud fraction and overlap assumption;
   // This implements the Monte Carlo Independing Column Approximation by mapping only a single
   // subcolumn (cloud state) to each gpoint.
-  auto nswgpts       = k_dist_sw.get_ngpt();
-  auto clouds_sw_gpt = get_subsampled_clouds(ncol, nlay, nswbands, nswgpts, clouds_sw, k_dist_sw, cldfrac, p_lay);
+  auto nswgpts = k_dist_sw.get_ngpt();
+  auto clouds_sw_gpt =
+      get_subsampled_clouds(ncol, nlay, nswbands, nswgpts, clouds_sw, k_dist_sw, cldfrac, p_lay);
   // Longwave
-  auto nlwgpts       = k_dist_lw.get_ngpt();
-  auto clouds_lw_gpt = get_subsampled_clouds(ncol, nlay, nlwbands, nlwgpts, clouds_lw, k_dist_lw, cldfrac, p_lay);
+  auto nlwgpts = k_dist_lw.get_ngpt();
+  auto clouds_lw_gpt =
+      get_subsampled_clouds(ncol, nlay, nlwbands, nlwgpts, clouds_lw, k_dist_lw, cldfrac, p_lay);
 
   // Copy cloud properties to outputs (is this needed, or can we just use pointers?)
   // Alternatively, just compute and output a subcolumn cloud mask
@@ -479,11 +504,11 @@ void rrtmgp_main(const int ncol, const int nlay, real2d &p_lay, real2d &t_lay, r
 
 #ifdef SCREAM_RRTMGP_DEBUG
   // Perform checks on optics; these would be caught by RRTMGP_EXPENSIVE_CHECKS in the RRTMGP code,
-  // but we might want to provide additional debug info here. NOTE: we may actually want to move this
-  // up higher in the code, I think optical props should go up higher since optical props are kind of
-  // a parameterization of their own, and we might want to swap different choices. These checks go here
-  // only because we need to run them on computed optical props, so if the optical props themselves get
-  // computed up higher, then perform these checks higher as well
+  // but we might want to provide additional debug info here. NOTE: we may actually want to move
+  // this up higher in the code, I think optical props should go up higher since optical props are
+  // kind of a parameterization of their own, and we might want to swap different choices. These
+  // checks go here only because we need to run them on computed optical props, so if the optical
+  // props themselves get computed up higher, then perform these checks higher as well
   check_range(clouds_sw.tau, 0, std::numeric_limits<Real>::max(), "rrtmgp_main:clouds_sw.tau");
   check_range(clouds_sw.ssa, 0, 1, "rrtmgp_main:clouds_sw.ssa");
   check_range(clouds_sw.g, -1, 1, "rrtmgp_main:clouds_sw.g  ");
@@ -491,17 +516,18 @@ void rrtmgp_main(const int ncol, const int nlay, real2d &p_lay, real2d &t_lay, r
 #endif
 
   // Do shortwave
-  rrtmgp_sw(ncol, nlay, k_dist_sw, p_lay, t_lay, p_lev, t_lev, gas_concs, sfc_alb_dir, sfc_alb_dif, mu0, aerosol_sw,
-            clouds_sw_gpt, fluxes_sw, clnclrsky_fluxes_sw, clrsky_fluxes_sw, clnsky_fluxes_sw, tsi_scaling, logger,
-            extra_clnclrsky_diag, extra_clnsky_diag);
+  rrtmgp_sw(ncol, nlay, k_dist_sw, p_lay, t_lay, p_lev, t_lev, gas_concs, sfc_alb_dir, sfc_alb_dif,
+            mu0, aerosol_sw, clouds_sw_gpt, fluxes_sw, clnclrsky_fluxes_sw, clrsky_fluxes_sw,
+            clnsky_fluxes_sw, tsi_scaling, logger, extra_clnclrsky_diag, extra_clnsky_diag);
 
   // Do longwave
-  rrtmgp_lw(ncol, nlay, k_dist_lw, p_lay, t_lay, p_lev, t_lev, gas_concs, aerosol_lw, clouds_lw_gpt, fluxes_lw,
-            clnclrsky_fluxes_lw, clrsky_fluxes_lw, clnsky_fluxes_lw, extra_clnclrsky_diag, extra_clnsky_diag);
+  rrtmgp_lw(ncol, nlay, k_dist_lw, p_lay, t_lay, p_lev, t_lev, gas_concs, aerosol_lw, clouds_lw_gpt,
+            fluxes_lw, clnclrsky_fluxes_lw, clrsky_fluxes_lw, clnsky_fluxes_lw,
+            extra_clnclrsky_diag, extra_clnsky_diag);
 }
 
-int3d get_subcolumn_mask(const int ncol, const int nlay, const int ngpt, real2d &cldf, const int overlap_option,
-                         int1d &seeds) {
+int3d get_subcolumn_mask(const int ncol, const int nlay, const int ngpt, real2d &cldf,
+                         const int overlap_option, int1d &seeds) {
 
   // Routine will return subcolumn mask with values of 0 indicating no cloud, 1 indicating cloud
   auto subcolumn_mask = int3d("subcolumn_mask", ncol, nlay, ngpt);
@@ -538,10 +564,11 @@ int3d get_subcolumn_mask(const int ncol, const int nlay, const int ngpt, real2d
     TIMED_KERNEL(parallel_for(
         SimpleBounds<2>(ngpt, ncol), YAKL_LAMBDA(int igpt, int icol) {
           for (int ilay = 2; ilay <= nlay; ilay++) {
-            // Check cldx in level above and see if it satisfies conditions to create a cloudy subcolumn
+            // Check cldx in level above and see if it satisfies conditions to create a cloudy
+            // subcolumn
             if (cldx(icol, ilay - 1, igpt) > 1.0 - cldf(icol, ilay - 1)) {
-              // Cloudy subcolumn above, use same random number here so that clouds in these two adjacent
-              // layers are maximimally overlapped
+              // Cloudy subcolumn above, use same random number here so that clouds in these two
+              // adjacent layers are maximimally overlapped
               cldx(icol, ilay, igpt) = cldx(icol, ilay - 1, igpt);
             } else {
               // Cloud-less above, use new random number so that clouds are distributed
@@ -567,12 +594,13 @@ int3d get_subcolumn_mask(const int ncol, const int nlay, const int ngpt, real2d
   return subcolumn_mask;
 }
 
-void rrtmgp_sw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &p_lay, real2d &t_lay, real2d &p_lev,
-               real2d &t_lev, GasConcs &gas_concs, real2d &sfc_alb_dir, real2d &sfc_alb_dif, real1d &mu0,
-               OpticalProps2str &aerosol, OpticalProps2str &clouds, FluxesByband &fluxes,
-               FluxesBroadband &clnclrsky_fluxes, FluxesBroadband &clrsky_fluxes, FluxesBroadband &clnsky_fluxes,
-               const Real tsi_scaling, const std::shared_ptr<spdlog::logger> &logger, const bool extra_clnclrsky_diag,
-               const bool extra_clnsky_diag) {
+void rrtmgp_sw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &p_lay,
+               real2d &t_lay, real2d &p_lev, real2d &t_lev, GasConcs &gas_concs,
+               real2d &sfc_alb_dir, real2d &sfc_alb_dif, real1d &mu0, OpticalProps2str &aerosol,
+               OpticalProps2str &clouds, FluxesByband &fluxes, FluxesBroadband &clnclrsky_fluxes,
+               FluxesBroadband &clrsky_fluxes, FluxesBroadband &clnsky_fluxes,
+               const Real tsi_scaling, const std::shared_ptr<spdlog::logger> &logger,
+               const bool extra_clnclrsky_diag, const bool extra_clnsky_diag) {
 
   // Get problem sizes
   int nbnd = k_dist.get_nband();
@@ -643,7 +671,8 @@ void rrtmgp_sw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &
 
   // Subset mu0
   auto mu0_day = real1d("mu0_day", nday);
-  TIMED_KERNEL(parallel_for(SimpleBounds<1>(nday), YAKL_LAMBDA(int iday) { mu0_day(iday) = mu0(dayIndices(iday)); }));
+  TIMED_KERNEL(parallel_for(
+      SimpleBounds<1>(nday), YAKL_LAMBDA(int iday) { mu0_day(iday) = mu0(dayIndices(iday)); }));
 
   // subset state variables
   auto p_lay_day = real2d("p_lay_day", nday, nlay);
@@ -743,10 +772,11 @@ void rrtmgp_sw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &
   auto p_lay_host = p_lay.createHostCopy();
   bool top_at_1   = p_lay_host(1, 1) < p_lay_host(1, nlay);
 
-  k_dist.gas_optics(nday, nlay, top_at_1, p_lay_day, p_lev_day, t_lay_limited, gas_concs_day, optics, toa_flux);
+  k_dist.gas_optics(nday, nlay, top_at_1, p_lay_day, p_lev_day, t_lay_limited, gas_concs_day,
+                    optics, toa_flux);
   if (extra_clnsky_diag) {
-    k_dist.gas_optics(nday, nlay, top_at_1, p_lay_day, p_lev_day, t_lay_limited, gas_concs_day, optics_no_aerosols,
-                      toa_flux);
+    k_dist.gas_optics(nday, nlay, top_at_1, p_lay_day, p_lev_day, t_lay_limited, gas_concs_day,
+                      optics_no_aerosols, toa_flux);
   }
 
 #ifdef SCREAM_RRTMGP_DEBUG
@@ -758,8 +788,9 @@ void rrtmgp_sw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &
 
   // Apply tsi_scaling
   TIMED_KERNEL(parallel_for(
-      SimpleBounds<2>(ngpt, nday),
-      YAKL_LAMBDA(int igpt, int iday) { toa_flux(iday, igpt) = tsi_scaling * toa_flux(iday, igpt); }));
+      SimpleBounds<2>(ngpt, nday), YAKL_LAMBDA(int igpt, int iday) {
+        toa_flux(iday, igpt) = tsi_scaling * toa_flux(iday, igpt);
+      }));
 
   if (extra_clnclrsky_diag) {
     // Compute clear-clean-sky (just gas) fluxes on daytime columns
@@ -817,7 +848,8 @@ void rrtmgp_sw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &
     // First increment clouds in optics_no_aerosols
     clouds_day.increment(optics_no_aerosols);
     // Compute cleansky (gas + clouds) fluxes on daytime columns
-    rte_sw(optics_no_aerosols, top_at_1, mu0_day, toa_flux, sfc_alb_dir_T, sfc_alb_dif_T, fluxes_day);
+    rte_sw(optics_no_aerosols, top_at_1, mu0_day, toa_flux, sfc_alb_dir_T, sfc_alb_dif_T,
+           fluxes_day);
     // Expand daytime fluxes to all columns
     TIMED_KERNEL(parallel_for(
         SimpleBounds<2>(nlay + 1, nday), YAKL_LAMBDA(int ilev, int iday) {
@@ -829,10 +861,12 @@ void rrtmgp_sw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &
   }
 }
 
-void rrtmgp_lw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &p_lay, real2d &t_lay, real2d &p_lev,
-               real2d &t_lev, GasConcs &gas_concs, OpticalProps1scl &aerosol, OpticalProps1scl &clouds,
-               FluxesByband &fluxes, FluxesBroadband &clnclrsky_fluxes, FluxesBroadband &clrsky_fluxes,
-               FluxesBroadband &clnsky_fluxes, const bool extra_clnclrsky_diag, const bool extra_clnsky_diag) {
+void rrtmgp_lw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &p_lay,
+               real2d &t_lay, real2d &p_lev, real2d &t_lev, GasConcs &gas_concs,
+               OpticalProps1scl &aerosol, OpticalProps1scl &clouds, FluxesByband &fluxes,
+               FluxesBroadband &clnclrsky_fluxes, FluxesBroadband &clrsky_fluxes,
+               FluxesBroadband &clnsky_fluxes, const bool extra_clnclrsky_diag,
+               const bool extra_clnsky_diag) {
 
   // Problem size
   int nbnd = k_dist.get_nband();
@@ -886,7 +920,8 @@ void rrtmgp_lw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &
   auto p_lay_host = p_lay.createHostCopy();
   bool top_at_1   = p_lay_host(1, 1) < p_lay_host(1, nlay);
   TIMED_KERNEL(parallel_for(
-      SimpleBounds<1>(ncol), YAKL_LAMBDA(int icol) { t_sfc(icol) = t_lev(icol, merge(nlay + 1, 1, top_at_1)); }));
+      SimpleBounds<1>(ncol),
+      YAKL_LAMBDA(int icol) { t_sfc(icol) = t_lev(icol, merge(nlay + 1, 1, top_at_1)); }));
   memset(emis_sfc, 0.98_wp);
 
   // Get Gaussian quadrature weights
@@ -943,11 +978,11 @@ void rrtmgp_lw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &
   limit_to_bounds(t_lev, k_dist_lw.get_temp_min(), k_dist_lw.get_temp_max(), t_lev_limited);
 
   // Do gas optics
-  k_dist.gas_optics(ncol, nlay, top_at_1, p_lay, p_lev, t_lay_limited, t_sfc, gas_concs, optics, lw_sources, real2d(),
-                    t_lev_limited);
+  k_dist.gas_optics(ncol, nlay, top_at_1, p_lay, p_lev, t_lay_limited, t_sfc, gas_concs, optics,
+                    lw_sources, real2d(), t_lev_limited);
   if (extra_clnsky_diag) {
-    k_dist.gas_optics(ncol, nlay, top_at_1, p_lay, p_lev, t_lay_limited, t_sfc, gas_concs, optics_no_aerosols,
-                      lw_sources, real2d(), t_lev_limited);
+    k_dist.gas_optics(ncol, nlay, top_at_1, p_lay, p_lev, t_lay_limited, t_sfc, gas_concs,
+                      optics_no_aerosols, lw_sources, real2d(), t_lev_limited);
   }
 
 #ifdef SCREAM_RRTMGP_DEBUG
@@ -957,7 +992,8 @@ void rrtmgp_lw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &
 
   if (extra_clnclrsky_diag) {
     // Compute clean-clear-sky fluxes before we add in aerosols and clouds
-    rte_lw(max_gauss_pts, gauss_Ds, gauss_wts, optics, top_at_1, lw_sources, emis_sfc, clnclrsky_fluxes);
+    rte_lw(max_gauss_pts, gauss_Ds, gauss_wts, optics, top_at_1, lw_sources, emis_sfc,
+           clnclrsky_fluxes);
   }
 
   // Combine gas and aerosol optics
@@ -976,21 +1012,23 @@ void rrtmgp_lw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &
     // First increment clouds in optics_no_aerosols
     clouds.increment(optics_no_aerosols);
     // Compute clean-sky fluxes
-    rte_lw(max_gauss_pts, gauss_Ds, gauss_wts, optics_no_aerosols, top_at_1, lw_sources, emis_sfc, clnsky_fluxes);
+    rte_lw(max_gauss_pts, gauss_Ds, gauss_wts, optics_no_aerosols, top_at_1, lw_sources, emis_sfc,
+           clnsky_fluxes);
   }
 }
 
-void compute_cloud_area(int ncol, int nlay, int ngpt, const Real pmin, const Real pmax, const real2d &pmid,
-                        const real3d &cld_tau_gpt, real1d &cld_area) {
+void compute_cloud_area(int ncol, int nlay, int ngpt, const Real pmin, const Real pmax,
+                        const real2d &pmid, const real3d &cld_tau_gpt, real1d &cld_area) {
   // Subcolumn binary cld mask; if any layers with pressure between pmin and pmax are cloudy
   // then 2d subcol mask is 1, otherwise it is 0
   auto subcol_mask = real2d("subcol_mask", ncol, ngpt);
   memset(subcol_mask, 0);
   TIMED_KERNEL(yakl::fortran::parallel_for(
       SimpleBounds<3>(ngpt, nlay, ncol), YAKL_LAMBDA(int igpt, int ilay, int icol) {
-        // NOTE: using plev would need to assume level ordering (top to bottom or bottom to top), but
-        // using play/pmid does not
-        if (cld_tau_gpt(icol, ilay, igpt) > 0 && pmid(icol, ilay) >= pmin && pmid(icol, ilay) < pmax) {
+        // NOTE: using plev would need to assume level ordering (top to bottom or bottom to top),
+        // but using play/pmid does not
+        if (cld_tau_gpt(icol, ilay, igpt) > 0 && pmid(icol, ilay) >= pmin &&
+            pmid(icol, ilay) < pmax) {
           subcol_mask(icol, igpt) = 1;
         }
       }));
@@ -1006,9 +1044,13 @@ void compute_cloud_area(int ncol, int nlay, int ngpt, const Real pmin, const Rea
       }));
 }
 
-int get_wavelength_index_sw(double wavelength) { return get_wavelength_index(k_dist_sw, wavelength); }
+int get_wavelength_index_sw(double wavelength) {
+  return get_wavelength_index(k_dist_sw, wavelength);
+}
 
-int get_wavelength_index_lw(double wavelength) { return get_wavelength_index(k_dist_lw, wavelength); }
+int get_wavelength_index_lw(double wavelength) {
+  return get_wavelength_index(k_dist_lw, wavelength);
+}
 
 int get_wavelength_index(OpticalProps &kdist, double wavelength) {
   // Get wavelength bounds for all wavelength bands
@@ -1022,11 +1064,13 @@ int get_wavelength_index(OpticalProps &kdist, double wavelength) {
   TIMED_KERNEL(yakl::fortran::parallel_for(
       SimpleBounds<1>(nbnds), YAKL_LAMBDA(int ibnd) {
         if (wavelength_bounds(1, ibnd) < wavelength_bounds(2, ibnd)) {
-          if (wavelength_bounds(1, ibnd) <= wavelength * 1e2 && wavelength * 1e2 <= wavelength_bounds(2, ibnd)) {
+          if (wavelength_bounds(1, ibnd) <= wavelength * 1e2 &&
+              wavelength * 1e2 <= wavelength_bounds(2, ibnd)) {
             band_index = ibnd;
           }
         } else {
-          if (wavelength_bounds(1, ibnd) >= wavelength * 1e2 && wavelength * 1e2 >= wavelength_bounds(2, ibnd)) {
+          if (wavelength_bounds(1, ibnd) >= wavelength * 1e2 &&
+              wavelength * 1e2 >= wavelength_bounds(2, ibnd)) {
             band_index = ibnd;
           }
         }
@@ -1034,11 +1078,13 @@ int get_wavelength_index(OpticalProps &kdist, double wavelength) {
   return band_index.hostRead();
 }
 
-void compute_aerocom_cloudtop(int ncol, int nlay, const real2d &tmid, const real2d &pmid, const real2d &p_del,
-                              const real2d &z_del, const real2d &qc, const real2d &qi, const real2d &rel,
-                              const real2d &rei, const real2d &cldfrac_tot, const real2d &nc, real1d &T_mid_at_cldtop,
-                              real1d &p_mid_at_cldtop, real1d &cldfrac_ice_at_cldtop, real1d &cldfrac_liq_at_cldtop,
-                              real1d &cldfrac_tot_at_cldtop, real1d &cdnc_at_cldtop, real1d &eff_radius_qc_at_cldtop,
+void compute_aerocom_cloudtop(int ncol, int nlay, const real2d &tmid, const real2d &pmid,
+                              const real2d &p_del, const real2d &z_del, const real2d &qc,
+                              const real2d &qi, const real2d &rel, const real2d &rei,
+                              const real2d &cldfrac_tot, const real2d &nc, real1d &T_mid_at_cldtop,
+                              real1d &p_mid_at_cldtop, real1d &cldfrac_ice_at_cldtop,
+                              real1d &cldfrac_liq_at_cldtop, real1d &cldfrac_tot_at_cldtop,
+                              real1d &cdnc_at_cldtop, real1d &eff_radius_qc_at_cldtop,
                               real1d &eff_radius_qi_at_cldtop) {
   /* The goal of this routine is to calculate properties at cloud top
    * based on the AeroCom recommendation. See reference for routine
@@ -1072,14 +1118,16 @@ void compute_aerocom_cloudtop(int ncol, int nlay, const real2d &tmid, const real
         // highest is assumed to hav no clouds
         for (int ilay = 2; ilay <= nlay; ++ilay) {
           // Only do the calculation if certain conditions are met
-          if ((qc(icol, ilay) + qi(icol, ilay)) > q_threshold && (cldfrac_tot(icol, ilay) > cldfrac_tot_threshold)) {
+          if ((qc(icol, ilay) + qi(icol, ilay)) > q_threshold &&
+              (cldfrac_tot(icol, ilay) > cldfrac_tot_threshold)) {
             /* PART I: Probabilistically determining cloud top */
             // Populate aerocom_tmp as the clear-sky fraction
             // probability of this level, where aerocom_clr is that of
             // the previous level
-            auto aerocom_tmp = aerocom_clr(icol) *
-                               (1.0 - ekat::impl::max(cldfrac_tot(icol, ilay - 1), cldfrac_tot(icol, ilay))) /
-                               (1.0 - ekat::impl::min(cldfrac_tot(icol, ilay - 1), 1.0 - cldfrac_tot_threshold));
+            auto aerocom_tmp =
+                aerocom_clr(icol) *
+                (1.0 - ekat::impl::max(cldfrac_tot(icol, ilay - 1), cldfrac_tot(icol, ilay))) /
+                (1.0 - ekat::impl::min(cldfrac_tot(icol, ilay - 1), 1.0 - cldfrac_tot_threshold));
             // Temporary variable for probability "weights"
             auto aerocom_wts = aerocom_clr(icol) - aerocom_tmp;
             // Temporary variable for liquid "phase"
@@ -1100,8 +1148,8 @@ void compute_aerocom_cloudtop(int ncol, int nlay, const real2d &tmid, const real
             /* We need to convert nc from 1/mass to 1/volume first, and
              * from grid-mean to in-cloud, but after that, the
              * calculation follows the general logic */
-            auto cdnc =
-                nc(icol, ilay) * p_del(icol, ilay) / z_del(icol, ilay) / physconst::gravit / cldfrac_tot(icol, ilay);
+            auto cdnc = nc(icol, ilay) * p_del(icol, ilay) / z_del(icol, ilay) / physconst::gravit /
+                        cldfrac_tot(icol, ilay);
             cdnc_at_cldtop(icol) += cdnc * aerocom_phi * aerocom_wts;
             // eff_radius_qc_at_cldtop
             eff_radius_qc_at_cldtop(icol) += rel(icol, ilay) * aerocom_phi * aerocom_wts;
diff --git i/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_interface.hpp w/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_interface.hpp
index 9ec3f010e8..81399754d5 100644
--- i/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_interface.hpp
+++ w/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_interface.hpp
@@ -40,57 +40,67 @@ extern CloudOptics cloud_optics_lw;
 extern bool initialized;
 
 void rrtmgp_initialize(GasConcs &gas_concs, const std::string &coefficients_file_sw,
-                       const std::string &coefficients_file_lw, const std::string &cloud_optics_file_sw,
-                       const std::string &cloud_optics_file_lw, const std::shared_ptr<spdlog::logger> &logger);
+                       const std::string &coefficients_file_lw,
+                       const std::string &cloud_optics_file_sw,
+                       const std::string &cloud_optics_file_lw,
+                       const std::shared_ptr<spdlog::logger> &logger);
 
-void compute_band_by_band_surface_albedos(const int ncol, const int nswbands, real1d &sfc_alb_dir_vis,
-                                          real1d &sfc_alb_dir_nir, real1d &sfc_alb_dif_vis, real1d &sfc_alb_dif_nir,
+void compute_band_by_band_surface_albedos(const int ncol, const int nswbands,
+                                          real1d &sfc_alb_dir_vis, real1d &sfc_alb_dir_nir,
+                                          real1d &sfc_alb_dif_vis, real1d &sfc_alb_dif_nir,
                                           real2d &sfc_alb_dir, real2d &sfc_alb_dif);
 
-void compute_broadband_surface_fluxes(const int ncol, const int ktop, const int nswbands, real3d &sw_bnd_flux_dir,
-                                      real3d &sw_bnd_flux_dif, real1d &sfc_flux_dir_vis, real1d &sfc_flux_dir_nir,
+void compute_broadband_surface_fluxes(const int ncol, const int ktop, const int nswbands,
+                                      real3d &sw_bnd_flux_dir, real3d &sw_bnd_flux_dif,
+                                      real1d &sfc_flux_dir_vis, real1d &sfc_flux_dir_nir,
                                       real1d &sfc_flux_dif_vis, real1d &sfc_flux_dif_nir);
 
-void rrtmgp_main(const int ncol, const int nlay, real2d &p_lay, real2d &t_lay, real2d &p_lev, real2d &t_lev,
-                 GasConcs &gas_concs, real2d &sfc_alb_dir, real2d &sfc_alb_dif, real1d &mu0, real2d &lwp, real2d &iwp,
-                 real2d &rel, real2d &rei, real2d &cldfrac, real3d &aer_tau_sw, real3d &aer_ssa_sw, real3d &aer_asm_sw,
-                 real3d &aer_tau_lw, real3d &cld_tau_sw_bnd, real3d &cld_tau_lw_bnd, real3d &cld_tau_sw_gpt,
-                 real3d &cld_tau_lw_gpt, real2d &sw_flux_up, real2d &sw_flux_dn, real2d &sw_flux_dn_dir,
-                 real2d &lw_flux_up, real2d &lw_flux_dn, real2d &sw_clnclrsky_flux_up, real2d &sw_clnclrsky_flux_dn,
-                 real2d &sw_clnclrsky_flux_dn_dir, real2d &sw_clrsky_flux_up, real2d &sw_clrsky_flux_dn,
-                 real2d &sw_clrsky_flux_dn_dir, real2d &sw_clnsky_flux_up, real2d &sw_clnsky_flux_dn,
-                 real2d &sw_clnsky_flux_dn_dir, real2d &lw_clnclrsky_flux_up, real2d &lw_clnclrsky_flux_dn,
-                 real2d &lw_clrsky_flux_up, real2d &lw_clrsky_flux_dn, real2d &lw_clnsky_flux_up,
-                 real2d &lw_clnsky_flux_dn, real3d &sw_bnd_flux_up, real3d &sw_bnd_flux_dn, real3d &sw_bnd_flux_dn_dir,
-                 real3d &lw_bnd_flux_up, real3d &lw_bnd_flux_dn, const Real tsi_scaling,
-                 const std::shared_ptr<spdlog::logger> &logger, const bool extra_clnclrsky_diag = false,
-                 const bool extra_clnsky_diag = false);
+void rrtmgp_main(
+    const int ncol, const int nlay, real2d &p_lay, real2d &t_lay, real2d &p_lev, real2d &t_lev,
+    GasConcs &gas_concs, real2d &sfc_alb_dir, real2d &sfc_alb_dif, real1d &mu0, real2d &lwp,
+    real2d &iwp, real2d &rel, real2d &rei, real2d &cldfrac, real3d &aer_tau_sw, real3d &aer_ssa_sw,
+    real3d &aer_asm_sw, real3d &aer_tau_lw, real3d &cld_tau_sw_bnd, real3d &cld_tau_lw_bnd,
+    real3d &cld_tau_sw_gpt, real3d &cld_tau_lw_gpt, real2d &sw_flux_up, real2d &sw_flux_dn,
+    real2d &sw_flux_dn_dir, real2d &lw_flux_up, real2d &lw_flux_dn, real2d &sw_clnclrsky_flux_up,
+    real2d &sw_clnclrsky_flux_dn, real2d &sw_clnclrsky_flux_dn_dir, real2d &sw_clrsky_flux_up,
+    real2d &sw_clrsky_flux_dn, real2d &sw_clrsky_flux_dn_dir, real2d &sw_clnsky_flux_up,
+    real2d &sw_clnsky_flux_dn, real2d &sw_clnsky_flux_dn_dir, real2d &lw_clnclrsky_flux_up,
+    real2d &lw_clnclrsky_flux_dn, real2d &lw_clrsky_flux_up, real2d &lw_clrsky_flux_dn,
+    real2d &lw_clnsky_flux_up, real2d &lw_clnsky_flux_dn, real3d &sw_bnd_flux_up,
+    real3d &sw_bnd_flux_dn, real3d &sw_bnd_flux_dn_dir, real3d &lw_bnd_flux_up,
+    real3d &lw_bnd_flux_dn, const Real tsi_scaling, const std::shared_ptr<spdlog::logger> &logger,
+    const bool extra_clnclrsky_diag = false, const bool extra_clnsky_diag = false);
 
 void rrtmgp_finalize();
 
-void rrtmgp_sw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &p_lay, real2d &t_lay, real2d &p_lev,
-               real2d &t_lev, GasConcs &gas_concs, real2d &sfc_alb_dir, real2d &sfc_alb_dif, real1d &mu0,
-               OpticalProps2str &aerosol, OpticalProps2str &clouds, FluxesByband &fluxes,
-               FluxesBroadband &clnclrsky_fluxes, FluxesBroadband &clrsky_fluxes, FluxesBroadband &clnsky_fluxes,
-               const Real tsi_scaling, const std::shared_ptr<spdlog::logger> &logger, const bool extra_clnclrsky_diag,
+void rrtmgp_sw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &p_lay,
+               real2d &t_lay, real2d &p_lev, real2d &t_lev, GasConcs &gas_concs,
+               real2d &sfc_alb_dir, real2d &sfc_alb_dif, real1d &mu0, OpticalProps2str &aerosol,
+               OpticalProps2str &clouds, FluxesByband &fluxes, FluxesBroadband &clnclrsky_fluxes,
+               FluxesBroadband &clrsky_fluxes, FluxesBroadband &clnsky_fluxes,
+               const Real tsi_scaling, const std::shared_ptr<spdlog::logger> &logger,
+               const bool extra_clnclrsky_diag, const bool extra_clnsky_diag);
+
+void rrtmgp_lw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &p_lay,
+               real2d &t_lay, real2d &p_lev, real2d &t_lev, GasConcs &gas_concs,
+               OpticalProps1scl &aerosol, OpticalProps1scl &clouds, FluxesByband &fluxes,
+               FluxesBroadband &clnclrsky_fluxes, FluxesBroadband &clrsky_fluxes,
+               FluxesBroadband &clnsky_fluxes, const bool extra_clnclrsky_diag,
                const bool extra_clnsky_diag);
 
-void rrtmgp_lw(const int ncol, const int nlay, GasOpticsRRTMGP &k_dist, real2d &p_lay, real2d &t_lay, real2d &p_lev,
-               real2d &t_lev, GasConcs &gas_concs, OpticalProps1scl &aerosol, OpticalProps1scl &clouds,
-               FluxesByband &fluxes, FluxesBroadband &clnclrsky_fluxes, FluxesBroadband &clrsky_fluxes,
-               FluxesBroadband &clnsky_fluxes, const bool extra_clnclrsky_diag, const bool extra_clnsky_diag);
-
-int3d get_subcolumn_mask(const int ncol, const int nlay, const int ngpt, real2d &cldf, const int overlap_option,
-                         int1d &seeds);
+int3d get_subcolumn_mask(const int ncol, const int nlay, const int ngpt, real2d &cldf,
+                         const int overlap_option, int1d &seeds);
 
 void compute_cloud_area(int ncol, int nlay, int ngpt, Real pmin, Real pmax, const real2d &pmid,
                         const real3d &cld_tau_gpt, real1d &cld_area);
 
-void compute_aerocom_cloudtop(int ncol, int nlay, const real2d &tmid, const real2d &pmid, const real2d &p_del,
-                              const real2d &z_del, const real2d &qc, const real2d &qi, const real2d &rel,
-                              const real2d &rei, const real2d &cldfrac_tot, const real2d &nc, real1d &T_mid_at_cldtop,
-                              real1d &p_mid_at_cldtop, real1d &cldfrac_ice_at_cldtop, real1d &cldfrac_liq_at_cldtop,
-                              real1d &cldfrac_tot_at_cldtop, real1d &cdnc_at_cldtop, real1d &eff_radius_qc_at_cldtop,
+void compute_aerocom_cloudtop(int ncol, int nlay, const real2d &tmid, const real2d &pmid,
+                              const real2d &p_del, const real2d &z_del, const real2d &qc,
+                              const real2d &qi, const real2d &rel, const real2d &rei,
+                              const real2d &cldfrac_tot, const real2d &nc, real1d &T_mid_at_cldtop,
+                              real1d &p_mid_at_cldtop, real1d &cldfrac_ice_at_cldtop,
+                              real1d &cldfrac_liq_at_cldtop, real1d &cldfrac_tot_at_cldtop,
+                              real1d &cdnc_at_cldtop, real1d &eff_radius_qc_at_cldtop,
                               real1d &eff_radius_qi_at_cldtop);
 
 template <class T, int myMem, int myStyle>
@@ -109,8 +119,8 @@ void mixing_ratio_to_cloud_mass(yakl::Array<T, 2, myMem, myStyle> const &mixing_
         // in EAM, this is consistent with limits in MG2. Is this true for P3?
         if (cloud_fraction(icol, ilay) > 0) {
           // Compute layer-integrated cloud mass (per unit area)
-          auto incloud_mixing_ratio =
-              std::min(mixing_ratio(icol, ilay) / std::max(0.0001, cloud_fraction(icol, ilay)), 0.005);
+          auto incloud_mixing_ratio = std::min(
+              mixing_ratio(icol, ilay) / std::max(0.0001, cloud_fraction(icol, ilay)), 0.005);
           cloud_mass(icol, ilay) = incloud_mixing_ratio * dp(icol, ilay) / physconst::gravit;
         } else {
           cloud_mass(icol, ilay) = 0;
@@ -118,10 +128,12 @@ void mixing_ratio_to_cloud_mass(yakl::Array<T, 2, myMem, myStyle> const &mixing_
       }));
 }
 
-template <class S, class T> void limit_to_bounds(S const &arr_in, T const lower, T const upper, S &arr_out) {
+template <class S, class T>
+void limit_to_bounds(S const &arr_in, T const lower, T const upper, S &arr_out) {
   TIMED_KERNEL(yakl::c::parallel_for(
-      arr_in.totElems(),
-      YAKL_LAMBDA(int i) { arr_out.data()[i] = std::min(std::max(arr_in.data()[i], lower), upper); }));
+      arr_in.totElems(), YAKL_LAMBDA(int i) {
+        arr_out.data()[i] = std::min(std::max(arr_in.data()[i], lower), upper);
+      }));
 }
 
 int get_wavelength_index(OpticalProps &kdist, double wavelength);
@@ -131,7 +143,8 @@ int get_wavelength_index_lw(double wavelength);
 
 // New interface for Kokkos and flexible types
 #ifdef RRTMGP_ENABLE_KOKKOS
-template <typename RealT = Real, typename LayoutT = Kokkos::LayoutRight, typename DeviceT = DefaultDevice>
+template <typename RealT = Real, typename LayoutT = Kokkos::LayoutRight,
+          typename DeviceT = DefaultDevice>
 struct rrtmgp_interface {
 
   using MDRP = typename conv::MDRP<LayoutT>;
@@ -186,9 +199,12 @@ struct rrtmgp_interface {
   /*
    * Initialize data for RRTMGP driver. Increase multiplier to allocate more pool space.
    */
-  static void rrtmgp_initialize(const gas_concs_t &gas_concs, const std::string &coefficients_file_sw,
-                                const std::string &coefficients_file_lw, const std::string &cloud_optics_file_sw,
-                                const std::string &cloud_optics_file_lw, const std::shared_ptr<spdlog::logger> &logger,
+  static void rrtmgp_initialize(const gas_concs_t &gas_concs,
+                                const std::string &coefficients_file_sw,
+                                const std::string &coefficients_file_lw,
+                                const std::string &cloud_optics_file_sw,
+                                const std::string &cloud_optics_file_lw,
+                                const std::shared_ptr<spdlog::logger> &logger,
                                 const double multiplier = 1.0) {
     // If we've already initialized, just exit
     if (initialized_k) {
@@ -231,19 +247,21 @@ struct rrtmgp_interface {
   /*
    * Compute band-by-band surface albedos from broadband albedos.
    */
-  static void compute_band_by_band_surface_albedos(const int ncol, const int nswbands, const creal1dk &sfc_alb_dir_vis,
-                                                   const creal1dk &sfc_alb_dir_nir, const creal1dk &sfc_alb_dif_vis,
-                                                   const creal1dk &sfc_alb_dif_nir, const real2dk &sfc_alb_dir,
-                                                   const real2dk &sfc_alb_dif) {
-    EKAT_ASSERT_MSG(initialized_k,
-                    "Error! rrtmgp_initialize must be called before GasOpticsRRTMGP object can be used.");
+  static void compute_band_by_band_surface_albedos(
+      const int ncol, const int nswbands, const creal1dk &sfc_alb_dir_vis,
+      const creal1dk &sfc_alb_dir_nir, const creal1dk &sfc_alb_dif_vis,
+      const creal1dk &sfc_alb_dif_nir, const real2dk &sfc_alb_dir, const real2dk &sfc_alb_dif) {
+    EKAT_ASSERT_MSG(
+        initialized_k,
+        "Error! rrtmgp_initialize must be called before GasOpticsRRTMGP object can be used.");
     auto wavenumber_limits = k_dist_sw_k->get_band_lims_wavenumber();
 
     EKAT_ASSERT_MSG(wavenumber_limits.extent(0) == 2,
-                    "Error! 1st dimension for wavenumber_limits should be 2. It's " << wavenumber_limits.extent(0));
+                    "Error! 1st dimension for wavenumber_limits should be 2. It's "
+                        << wavenumber_limits.extent(0));
     EKAT_ASSERT_MSG(wavenumber_limits.extent(1) == static_cast<size_t>(nswbands),
-                    "Error! 2nd dimension for wavenumber_limits should be " + std::to_string(nswbands) +
-                        " (nswbands).");
+                    "Error! 2nd dimension for wavenumber_limits should be " +
+                        std::to_string(nswbands) + " (nswbands).");
 
     // Loop over bands, and determine for each band whether it is broadly in the
     // visible or infrared part of the spectrum (visible or "not visible")
@@ -254,8 +272,10 @@ struct rrtmgp_interface {
 
         // Wavenumber is in the visible if it is above the visible wavenumber
         // threshold, and in the infrared if it is below the threshold
-        const bool is_visible_wave1 = (wavenumber_limits(0, ibnd) > visible_wavenumber_threshold ? true : false);
-        const bool is_visible_wave2 = (wavenumber_limits(1, ibnd) > visible_wavenumber_threshold ? true : false);
+        const bool is_visible_wave1 =
+            (wavenumber_limits(0, ibnd) > visible_wavenumber_threshold ? true : false);
+        const bool is_visible_wave2 =
+            (wavenumber_limits(1, ibnd) > visible_wavenumber_threshold ? true : false);
 
         if (is_visible_wave1 && is_visible_wave2) {
           // Entire band is in the visible
@@ -278,17 +298,23 @@ struct rrtmgp_interface {
    * Compute broadband visible/UV and near-infrared surface fluxes.
    */
   static void compute_broadband_surface_fluxes(const int ncol, const int ktop, const int nswbands,
-                                               const real3dk &sw_bnd_flux_dir, const real3dk &sw_bnd_flux_dif,
-                                               const real1dk &sfc_flux_dir_vis, const real1dk &sfc_flux_dir_nir,
-                                               const real1dk &sfc_flux_dif_vis, const real1dk &sfc_flux_dif_nir) {
-    // Band 10 straddles the near-IR and visible, so divide contributions from band 10 between both broadband sums
-    // TODO: Hard-coding these band indices is really bad practice. If the bands ever were to change (like when
-    // the RRTMG bands were re-ordered for RRTMGP), we would be using the wrong bands for the IR and UV/VIS. This
-    // should be refactored to grab the correct bands by specifying appropriate wavenumber rather than index.
-    // sfc_flux_dir_nir(i) = sum(sw_bnd_flux_dir(i+1,kbot,1:9))   + 0.5 * sw_bnd_flux_dir(i+1,kbot,10);
-    // sfc_flux_dir_vis(i) = sum(sw_bnd_flux_dir(i+1,kbot,11:14)) + 0.5 * sw_bnd_flux_dir(i+1,kbot,10);
-    // sfc_flux_dif_nir(i) = sum(sw_bnd_flux_dif(i+1,kbot,1:9))   + 0.5 * sw_bnd_flux_dif(i+1,kbot,10);
-    // sfc_flux_dif_vis(i) = sum(sw_bnd_flux_dif(i+1,kbot,11:14)) + 0.5 * sw_bnd_flux_dif(i+1,kbot,10);
+                                               const real3dk &sw_bnd_flux_dir,
+                                               const real3dk &sw_bnd_flux_dif,
+                                               const real1dk &sfc_flux_dir_vis,
+                                               const real1dk &sfc_flux_dir_nir,
+                                               const real1dk &sfc_flux_dif_vis,
+                                               const real1dk &sfc_flux_dif_nir) {
+    // Band 10 straddles the near-IR and visible, so divide contributions from band 10 between both
+    // broadband sums
+    // TODO: Hard-coding these band indices is really bad practice. If the bands ever were to change
+    // (like when the RRTMG bands were re-ordered for RRTMGP), we would be using the wrong bands for
+    // the IR and UV/VIS. This should be refactored to grab the correct bands by specifying
+    // appropriate wavenumber rather than index. sfc_flux_dir_nir(i) =
+    // sum(sw_bnd_flux_dir(i+1,kbot,1:9))   + 0.5 * sw_bnd_flux_dir(i+1,kbot,10);
+    // sfc_flux_dir_vis(i) = sum(sw_bnd_flux_dir(i+1,kbot,11:14)) + 0.5 *
+    // sw_bnd_flux_dir(i+1,kbot,10); sfc_flux_dif_nir(i) = sum(sw_bnd_flux_dif(i+1,kbot,1:9))   +
+    // 0.5 * sw_bnd_flux_dif(i+1,kbot,10); sfc_flux_dif_vis(i) =
+    // sum(sw_bnd_flux_dif(i+1,kbot,11:14)) + 0.5 * sw_bnd_flux_dif(i+1,kbot,10);
 
     // Initialize sums over bands
     Kokkos::deep_copy(sfc_flux_dir_nir, 0);
@@ -304,8 +330,10 @@ struct rrtmgp_interface {
           for (int ibnd = 0; ibnd < nswbands; ++ibnd) {
             // Wavenumber is in the visible if it is above the visible wavenumber
             // threshold, and in the infrared if it is below the threshold
-            const bool is_visible_wave1 = (wavenumber_limits(0, ibnd) > visible_wavenumber_threshold ? true : false);
-            const bool is_visible_wave2 = (wavenumber_limits(1, ibnd) > visible_wavenumber_threshold ? true : false);
+            const bool is_visible_wave1 =
+                (wavenumber_limits(0, ibnd) > visible_wavenumber_threshold ? true : false);
+            const bool is_visible_wave2 =
+                (wavenumber_limits(1, ibnd) > visible_wavenumber_threshold ? true : false);
 
             if (is_visible_wave1 && is_visible_wave2) {
               // Entire band is in the visible
@@ -333,22 +361,26 @@ struct rrtmgp_interface {
    * screen and/or to file (or neither), depending on how it was set up.
    */
   static void
-  rrtmgp_main(const int ncol, const int nlay, const creal2dk &p_lay, const creal2dk &t_lay, const creal2dk &p_lev,
-              const creal2dk &t_lev, gas_concs_t &gas_concs, const creal2dk &sfc_alb_dir, const creal2dk &sfc_alb_dif,
-              const real1dk &mu0, const real2dk &lwp, const real2dk &iwp, const creal2dk &rel, const creal2dk &rei,
-              const real2dk &cldfrac, const real3dk &aer_tau_sw, const real3dk &aer_ssa_sw, const real3dk &aer_asm_sw,
-              const real3dk &aer_tau_lw, const real3dk &cld_tau_sw_bnd, const real3dk &cld_tau_lw_bnd,
-              const real3dk &cld_tau_sw_gpt, const real3dk &cld_tau_lw_gpt, const real2dk &sw_flux_up,
-              const real2dk &sw_flux_dn, const real2dk &sw_flux_dn_dir, const real2dk &lw_flux_up,
-              const real2dk &lw_flux_dn, const real2dk &sw_clnclrsky_flux_up, const real2dk &sw_clnclrsky_flux_dn,
+  rrtmgp_main(const int ncol, const int nlay, const creal2dk &p_lay, const creal2dk &t_lay,
+              const creal2dk &p_lev, const creal2dk &t_lev, gas_concs_t &gas_concs,
+              const creal2dk &sfc_alb_dir, const creal2dk &sfc_alb_dif, const real1dk &mu0,
+              const real2dk &lwp, const real2dk &iwp, const creal2dk &rel, const creal2dk &rei,
+              const real2dk &cldfrac, const real3dk &aer_tau_sw, const real3dk &aer_ssa_sw,
+              const real3dk &aer_asm_sw, const real3dk &aer_tau_lw, const real3dk &cld_tau_sw_bnd,
+              const real3dk &cld_tau_lw_bnd, const real3dk &cld_tau_sw_gpt,
+              const real3dk &cld_tau_lw_gpt, const real2dk &sw_flux_up, const real2dk &sw_flux_dn,
+              const real2dk &sw_flux_dn_dir, const real2dk &lw_flux_up, const real2dk &lw_flux_dn,
+              const real2dk &sw_clnclrsky_flux_up, const real2dk &sw_clnclrsky_flux_dn,
               const real2dk &sw_clnclrsky_flux_dn_dir, const real2dk &sw_clrsky_flux_up,
-              const real2dk &sw_clrsky_flux_dn, const real2dk &sw_clrsky_flux_dn_dir, const real2dk &sw_clnsky_flux_up,
-              const real2dk &sw_clnsky_flux_dn, const real2dk &sw_clnsky_flux_dn_dir,
-              const real2dk &lw_clnclrsky_flux_up, const real2dk &lw_clnclrsky_flux_dn,
-              const real2dk &lw_clrsky_flux_up, const real2dk &lw_clrsky_flux_dn, const real2dk &lw_clnsky_flux_up,
-              const real2dk &lw_clnsky_flux_dn, const real3dk &sw_bnd_flux_up, const real3dk &sw_bnd_flux_dn,
-              const real3dk &sw_bnd_flux_dn_dir, const real3dk &lw_bnd_flux_up, const real3dk &lw_bnd_flux_dn,
-              const Real tsi_scaling, const std::shared_ptr<spdlog::logger> &logger,
+              const real2dk &sw_clrsky_flux_dn, const real2dk &sw_clrsky_flux_dn_dir,
+              const real2dk &sw_clnsky_flux_up, const real2dk &sw_clnsky_flux_dn,
+              const real2dk &sw_clnsky_flux_dn_dir, const real2dk &lw_clnclrsky_flux_up,
+              const real2dk &lw_clnclrsky_flux_dn, const real2dk &lw_clrsky_flux_up,
+              const real2dk &lw_clrsky_flux_dn, const real2dk &lw_clnsky_flux_up,
+              const real2dk &lw_clnsky_flux_dn, const real3dk &sw_bnd_flux_up,
+              const real3dk &sw_bnd_flux_dn, const real3dk &sw_bnd_flux_dn_dir,
+              const real3dk &lw_bnd_flux_up, const real3dk &lw_bnd_flux_dn, const Real tsi_scaling,
+              const std::shared_ptr<spdlog::logger> &logger,
               const bool extra_clnclrsky_diag = false, const bool extra_clnsky_diag = false) {
     const int sw_nband = k_dist_sw_k->get_nband();
     const int lw_nband = k_dist_lw_k->get_nband();
@@ -357,10 +389,14 @@ struct rrtmgp_interface {
 
 #ifdef SCREAM_RRTMGP_DEBUG
     // Sanity check inputs, and possibly repair
-    check_range_k(t_lay, k_dist_sw_k->get_temp_min(), k_dist_sw_k->get_temp_max(), "rrtmgp_main::t_lay");
-    check_range_k(t_lev, k_dist_sw_k->get_temp_min(), k_dist_sw_k->get_temp_max(), "rrtmgp_main::t_lev");
-    check_range_k(p_lay, k_dist_sw_k->get_press_min(), k_dist_sw_k->get_press_max(), "rrtmgp_main::p_lay");
-    check_range_k(p_lev, k_dist_sw_k->get_press_min(), k_dist_sw_k->get_press_max(), "rrtmgp_main::p_lev");
+    check_range_k(t_lay, k_dist_sw_k->get_temp_min(), k_dist_sw_k->get_temp_max(),
+                  "rrtmgp_main::t_lay");
+    check_range_k(t_lev, k_dist_sw_k->get_temp_min(), k_dist_sw_k->get_temp_max(),
+                  "rrtmgp_main::t_lev");
+    check_range_k(p_lay, k_dist_sw_k->get_press_min(), k_dist_sw_k->get_press_max(),
+                  "rrtmgp_main::p_lay");
+    check_range_k(p_lev, k_dist_sw_k->get_press_min(), k_dist_sw_k->get_press_max(),
+                  "rrtmgp_main::p_lev");
     check_range_k(sfc_alb_dir, 0, 1, "rrtmgp_main::sfc_alb_dir");
     check_range_k(sfc_alb_dif, 0, 1, "rrtmgp_main::sfc_alb_dif");
     check_range_k(mu0, 0, 1, "rrtmgp_main::mu0");
@@ -449,21 +485,25 @@ struct rrtmgp_interface {
     // Setup aerosol optical properties
     optical_props2_t aerosol_sw;
     optical_props1_t aerosol_lw;
-    aerosol_sw.init_no_alloc(k_dist_sw_k->get_band_lims_wavenumber(), sw_band2gpt_mem, sw_gpt2band_mem);
+    aerosol_sw.init_no_alloc(k_dist_sw_k->get_band_lims_wavenumber(), sw_band2gpt_mem,
+                             sw_gpt2band_mem);
     aerosol_sw.alloc_2str_no_alloc(ncol, nlay, sw_tau_mem, sw_ssa_mem, sw_g_mem);
-    TIMED_KERNEL(FLATTEN_MD_KERNEL3(ncol, nlay, nswbands, icol, ilay, ibnd,
-                                    aerosol_sw.tau(icol, ilay, ibnd) = aer_tau_sw(icol, ilay, ibnd);
-                                    aerosol_sw.ssa(icol, ilay, ibnd) = aer_ssa_sw(icol, ilay, ibnd);
-                                    aerosol_sw.g(icol, ilay, ibnd)   = aer_asm_sw(icol, ilay, ibnd);));
-    aerosol_lw.init_no_alloc(k_dist_lw_k->get_band_lims_wavenumber(), lw_band2gpt_mem, lw_gpt2band_mem);
+    TIMED_KERNEL(
+        FLATTEN_MD_KERNEL3(ncol, nlay, nswbands, icol, ilay, ibnd,
+                           aerosol_sw.tau(icol, ilay, ibnd) = aer_tau_sw(icol, ilay, ibnd);
+                           aerosol_sw.ssa(icol, ilay, ibnd) = aer_ssa_sw(icol, ilay, ibnd);
+                           aerosol_sw.g(icol, ilay, ibnd)   = aer_asm_sw(icol, ilay, ibnd);));
+    aerosol_lw.init_no_alloc(k_dist_lw_k->get_band_lims_wavenumber(), lw_band2gpt_mem,
+                             lw_gpt2band_mem);
     aerosol_lw.alloc_1scl_no_alloc(ncol, nlay, lw_tau_mem);
-    TIMED_KERNEL(FLATTEN_MD_KERNEL3(ncol, nlay, nlwbands, icol, ilay, ibnd,
-                                    aerosol_lw.tau(icol, ilay, ibnd) = aer_tau_lw(icol, ilay, ibnd);));
+    TIMED_KERNEL(
+        FLATTEN_MD_KERNEL3(ncol, nlay, nlwbands, icol, ilay, ibnd,
+                           aerosol_lw.tau(icol, ilay, ibnd) = aer_tau_lw(icol, ilay, ibnd);));
 
 #ifdef SCREAM_RRTMGP_DEBUG
     // Check aerosol optical properties
-    // NOTE: these should already have been checked by precondition checks, but someday we might have
-    // non-trivial aerosol optics, so this is still good to do here.
+    // NOTE: these should already have been checked by precondition checks, but someday we might
+    // have non-trivial aerosol optics, so this is still good to do here.
     check_range_k(aerosol_sw.tau, 0, 1e3, "rrtmgp_main:aerosol_sw.tau");
     check_range_k(aerosol_sw.ssa, 0, 1, "rrtmgp_main:aerosol_sw.ssa"); //, "aerosol_optics_sw.ssa");
     check_range_k(aerosol_sw.g, -1, 1, "rrtmgp_main:aerosol_sw.g  ");  //, "aerosol_optics_sw.g"  );
@@ -471,41 +511,47 @@ struct rrtmgp_interface {
 #endif
 
     // Convert cloud physical properties to optical properties for input to RRTMGP
-    optical_props2_t clouds_sw =
-        get_cloud_optics_sw(ncol, nlay, *cloud_optics_sw_k, *k_dist_sw_k, lwp, iwp, rel, rei, sw_cloud_band2gpt_mem,
-                            sw_cloud_gpt2band_mem, sw_cloud_tau_mem, sw_cloud_ssa_mem, sw_cloud_g_mem);
-    optical_props1_t clouds_lw = get_cloud_optics_lw(ncol, nlay, *cloud_optics_lw_k, *k_dist_lw_k, lwp, iwp, rel, rei,
-                                                     lw_cloud_band2gpt_mem, lw_cloud_gpt2band_mem, lw_cloud_tau_mem);
+    optical_props2_t clouds_sw = get_cloud_optics_sw(
+        ncol, nlay, *cloud_optics_sw_k, *k_dist_sw_k, lwp, iwp, rel, rei, sw_cloud_band2gpt_mem,
+        sw_cloud_gpt2band_mem, sw_cloud_tau_mem, sw_cloud_ssa_mem, sw_cloud_g_mem);
+    optical_props1_t clouds_lw =
+        get_cloud_optics_lw(ncol, nlay, *cloud_optics_lw_k, *k_dist_lw_k, lwp, iwp, rel, rei,
+                            lw_cloud_band2gpt_mem, lw_cloud_gpt2band_mem, lw_cloud_tau_mem);
     Kokkos::deep_copy(cld_tau_sw_bnd, clouds_sw.tau);
     Kokkos::deep_copy(cld_tau_lw_bnd, clouds_lw.tau);
 
     // Do subcolumn sampling to map bands -> gpoints based on cloud fraction and overlap assumption;
     // This implements the Monte Carlo Independing Column Approximation by mapping only a single
     // subcolumn (cloud state) to each gpoint.
-    auto nswgpts       = k_dist_sw_k->get_ngpt();
-    auto clouds_sw_gpt = get_subsampled_clouds(ncol, nlay, nswbands, nswgpts, clouds_sw, *k_dist_sw_k, cldfrac, p_lay,
-                                               sw_subcloud_band2gpt_mem, sw_subcloud_gpt2band_mem, sw_subcloud_tau_mem,
-                                               sw_subcloud_ssa_mem, sw_subcloud_g_mem);
+    auto nswgpts = k_dist_sw_k->get_ngpt();
+    auto clouds_sw_gpt =
+        get_subsampled_clouds(ncol, nlay, nswbands, nswgpts, clouds_sw, *k_dist_sw_k, cldfrac,
+                              p_lay, sw_subcloud_band2gpt_mem, sw_subcloud_gpt2band_mem,
+                              sw_subcloud_tau_mem, sw_subcloud_ssa_mem, sw_subcloud_g_mem);
 
     // Longwave
     auto nlwgpts       = k_dist_lw_k->get_ngpt();
-    auto clouds_lw_gpt = get_subsampled_clouds(ncol, nlay, nlwbands, nlwgpts, clouds_lw, *k_dist_lw_k, cldfrac, p_lay,
-                                               lw_subcloud_band2gpt_mem, lw_subcloud_gpt2band_mem, lw_subcloud_tau_mem);
+    auto clouds_lw_gpt = get_subsampled_clouds(
+        ncol, nlay, nlwbands, nlwgpts, clouds_lw, *k_dist_lw_k, cldfrac, p_lay,
+        lw_subcloud_band2gpt_mem, lw_subcloud_gpt2band_mem, lw_subcloud_tau_mem);
 
     // Copy cloud properties to outputs (is this needed, or can we just use pointers?)
     // Alternatively, just compute and output a subcolumn cloud mask
     TIMED_KERNEL(FLATTEN_MD_KERNEL3(ncol, nlay, nswgpts, icol, ilay, igpt,
-                                    cld_tau_sw_gpt(icol, ilay, igpt) = clouds_sw_gpt.tau(icol, ilay, igpt);));
+                                    cld_tau_sw_gpt(icol, ilay, igpt) =
+                                        clouds_sw_gpt.tau(icol, ilay, igpt);));
     TIMED_KERNEL(FLATTEN_MD_KERNEL3(ncol, nlay, nlwgpts, icol, ilay, igpt,
-                                    cld_tau_lw_gpt(icol, ilay, igpt) = clouds_lw_gpt.tau(icol, ilay, igpt);));
+                                    cld_tau_lw_gpt(icol, ilay, igpt) =
+                                        clouds_lw_gpt.tau(icol, ilay, igpt);));
 
 #ifdef SCREAM_RRTMGP_DEBUG
-    // Perform checks on optics; these would be caught by RRTMGP_EXPENSIVE_CHECKS in the RRTMGP code,
-    // but we might want to provide additional debug info here. NOTE: we may actually want to move this
-    // up higher in the code, I think optical props should go up higher since optical props are kind of
-    // a parameterization of their own, and we might want to swap different choices. These checks go here
-    // only because we need to run them on computed optical props, so if the optical props themselves get
-    // computed up higher, then perform these checks higher as well
+    // Perform checks on optics; these would be caught by RRTMGP_EXPENSIVE_CHECKS in the RRTMGP
+    // code, but we might want to provide additional debug info here. NOTE: we may actually want to
+    // move this up higher in the code, I think optical props should go up higher since optical
+    // props are kind of a parameterization of their own, and we might want to swap different
+    // choices. These checks go here only because we need to run them on computed optical props, so
+    // if the optical props themselves get computed up higher, then perform these checks higher as
+    // well
     check_range_k(clouds_sw.tau, 0, std::numeric_limits<RealT>::max(), "rrtmgp_main:clouds_sw.tau");
     check_range_k(clouds_sw.ssa, 0, 1, "rrtmgp_main:clouds_sw.ssa");
     check_range_k(clouds_sw.g, -1, 1, "rrtmgp_main:clouds_sw.g  ");
@@ -513,13 +559,15 @@ struct rrtmgp_interface {
 #endif
 
     // Do shortwave
-    rrtmgp_sw(ncol, nlay, *k_dist_sw_k, p_lay, t_lay, p_lev, t_lev, gas_concs, sfc_alb_dir, sfc_alb_dif, mu0,
-              aerosol_sw, clouds_sw_gpt, fluxes_sw, clnclrsky_fluxes_sw, clrsky_fluxes_sw, clnsky_fluxes_sw,
-              tsi_scaling, logger, extra_clnclrsky_diag, extra_clnsky_diag);
+    rrtmgp_sw(ncol, nlay, *k_dist_sw_k, p_lay, t_lay, p_lev, t_lev, gas_concs, sfc_alb_dir,
+              sfc_alb_dif, mu0, aerosol_sw, clouds_sw_gpt, fluxes_sw, clnclrsky_fluxes_sw,
+              clrsky_fluxes_sw, clnsky_fluxes_sw, tsi_scaling, logger, extra_clnclrsky_diag,
+              extra_clnsky_diag);
 
     // Do longwave
-    rrtmgp_lw(ncol, nlay, *k_dist_lw_k, p_lay, t_lay, p_lev, t_lev, gas_concs, aerosol_lw, clouds_lw_gpt, fluxes_lw,
-              clnclrsky_fluxes_lw, clrsky_fluxes_lw, clnsky_fluxes_lw, extra_clnclrsky_diag, extra_clnsky_diag);
+    rrtmgp_lw(ncol, nlay, *k_dist_lw_k, p_lay, t_lay, p_lev, t_lev, gas_concs, aerosol_lw,
+              clouds_lw_gpt, fluxes_lw, clnclrsky_fluxes_lw, clrsky_fluxes_lw, clnsky_fluxes_lw,
+              extra_clnclrsky_diag, extra_clnsky_diag);
 
     pool_t::dealloc(sw_band2gpt_mem);
     pool_t::dealloc(sw_gpt2band_mem);
@@ -572,13 +620,14 @@ struct rrtmgp_interface {
    * Shortwave driver (called by rrtmgp_main)
    */
   static void rrtmgp_sw(const int ncol, const int nlay, gas_optics_t &k_dist, const creal2dk &p_lay,
-                        const creal2dk &t_lay, const creal2dk &p_lev, const creal2dk &t_lev, gas_concs_t &gas_concs,
-                        const creal2dk &sfc_alb_dir, const creal2dk &sfc_alb_dif, const real1dk &mu0,
-                        optical_props2_t &aerosol, optical_props2_t &clouds, fluxes_t &fluxes,
+                        const creal2dk &t_lay, const creal2dk &p_lev, const creal2dk &t_lev,
+                        gas_concs_t &gas_concs, const creal2dk &sfc_alb_dir,
+                        const creal2dk &sfc_alb_dif, const real1dk &mu0, optical_props2_t &aerosol,
+                        optical_props2_t &clouds, fluxes_t &fluxes,
                         fluxes_broadband_t &clnclrsky_fluxes, fluxes_broadband_t &clrsky_fluxes,
                         fluxes_broadband_t &clnsky_fluxes, const Real tsi_scaling,
-                        const std::shared_ptr<spdlog::logger> &logger, const bool extra_clnclrsky_diag,
-                        const bool extra_clnsky_diag) {
+                        const std::shared_ptr<spdlog::logger> &logger,
+                        const bool extra_clnclrsky_diag, const bool extra_clnsky_diag) {
     // Get problem sizes
     const int nbnd = k_dist.get_nband();
     const int ngpt = k_dist.get_ngpt();
@@ -603,12 +652,15 @@ struct rrtmgp_interface {
 
     // Reset fluxes to zero
     TIMED_KERNEL(FLATTEN_MD_KERNEL2(
-        ncol, nlay + 1, icol, ilev, flux_up(icol, ilev) = 0; flux_dn(icol, ilev) = 0; flux_dn_dir(icol, ilev) = 0;
-        clnclrsky_flux_up(icol, ilev) = 0; clnclrsky_flux_dn(icol, ilev) = 0; clnclrsky_flux_dn_dir(icol, ilev) = 0;
-        clrsky_flux_up(icol, ilev) = 0; clrsky_flux_dn(icol, ilev) = 0; clrsky_flux_dn_dir(icol, ilev) = 0;
-        clnsky_flux_up(icol, ilev) = 0; clnsky_flux_dn(icol, ilev) = 0; clnsky_flux_dn_dir(icol, ilev) = 0;));
-    TIMED_KERNEL(FLATTEN_MD_KERNEL3(ncol, nlay + 1, nbnd, icol, ilev, ibnd, bnd_flux_up(icol, ilev, ibnd) = 0;
-                                    bnd_flux_dn(icol, ilev, ibnd) = 0; bnd_flux_dn_dir(icol, ilev, ibnd) = 0;));
+        ncol, nlay + 1, icol, ilev, flux_up(icol, ilev) = 0; flux_dn(icol, ilev) = 0;
+        flux_dn_dir(icol, ilev) = 0; clnclrsky_flux_up(icol, ilev) = 0;
+        clnclrsky_flux_dn(icol, ilev) = 0; clnclrsky_flux_dn_dir(icol, ilev) = 0;
+        clrsky_flux_up(icol, ilev) = 0; clrsky_flux_dn(icol, ilev) = 0;
+        clrsky_flux_dn_dir(icol, ilev) = 0; clnsky_flux_up(icol, ilev) = 0;
+        clnsky_flux_dn(icol, ilev) = 0; clnsky_flux_dn_dir(icol, ilev) = 0;));
+    TIMED_KERNEL(FLATTEN_MD_KERNEL3(
+        ncol, nlay + 1, nbnd, icol, ilev, ibnd, bnd_flux_up(icol, ilev, ibnd) = 0;
+        bnd_flux_dn(icol, ilev, ibnd) = 0; bnd_flux_dn_dir(icol, ilev, ibnd) = 0;));
 
     // Get daytime indices
     auto dayIndices = pool_t::template alloc<int>(ncol);
@@ -687,12 +739,15 @@ struct rrtmgp_interface {
     auto sw_noaero_gpt2band_mem = pool_t::template alloc<int>(ngpt);
 
     // Subset mu0
-    TIMED_KERNEL(Kokkos::parallel_for(nday, KOKKOS_LAMBDA(int iday) { mu0_day(iday) = mu0(dayIndices(iday)); }));
+    TIMED_KERNEL(Kokkos::parallel_for(
+        nday, KOKKOS_LAMBDA(int iday) { mu0_day(iday) = mu0(dayIndices(iday)); }));
 
     // subset state variables
-    TIMED_KERNEL(FLATTEN_MD_KERNEL2(nday, nlay, iday, ilay, p_lay_day(iday, ilay) = p_lay(dayIndices(iday), ilay);
+    TIMED_KERNEL(FLATTEN_MD_KERNEL2(nday, nlay, iday, ilay,
+                                    p_lay_day(iday, ilay) = p_lay(dayIndices(iday), ilay);
                                     t_lay_day(iday, ilay) = t_lay(dayIndices(iday), ilay);));
-    TIMED_KERNEL(FLATTEN_MD_KERNEL2(nday, nlay + 1, iday, ilev, p_lev_day(iday, ilev) = p_lev(dayIndices(iday), ilev);
+    TIMED_KERNEL(FLATTEN_MD_KERNEL2(nday, nlay + 1, iday, ilev,
+                                    p_lev_day(iday, ilev) = p_lev(dayIndices(iday), ilev);
                                     t_lev_day(iday, ilev) = t_lev(dayIndices(iday), ilev);));
 
     // Subset gases
@@ -701,36 +756,40 @@ struct rrtmgp_interface {
     gas_concs_day.init_no_alloc(gas_names, nday, nlay, concs_mem);
     for (int igas = 0; igas < ngas; igas++) {
       gas_concs.get_vmr(gas_names[igas], vmr);
-      TIMED_KERNEL(FLATTEN_MD_KERNEL2(nday, nlay, iday, ilay, vmr_day(iday, ilay) = vmr(dayIndices(iday), ilay);));
+      TIMED_KERNEL(FLATTEN_MD_KERNEL2(nday, nlay, iday, ilay,
+                                      vmr_day(iday, ilay) = vmr(dayIndices(iday), ilay);));
       gas_concs_day.set_vmr(gas_names[igas], vmr_day);
     }
 
     // Subset aerosol optics
     optical_props2_t aerosol_day;
-    aerosol_day.init_no_alloc(k_dist.get_band_lims_wavenumber(), sw_aero_band2gpt_mem, sw_aero_gpt2band_mem);
+    aerosol_day.init_no_alloc(k_dist.get_band_lims_wavenumber(), sw_aero_band2gpt_mem,
+                              sw_aero_gpt2band_mem);
     aerosol_day.alloc_2str_no_alloc(nday, nlay, sw_aero_tau_mem, sw_aero_ssa_mem, sw_aero_g_mem);
-    TIMED_KERNEL(FLATTEN_MD_KERNEL3(nday, nlay, nbnd, iday, ilay, ibnd,
-                                    aerosol_day.tau(iday, ilay, ibnd) = aerosol.tau(dayIndices(iday), ilay, ibnd);
-                                    aerosol_day.ssa(iday, ilay, ibnd) = aerosol.ssa(dayIndices(iday), ilay, ibnd);
-                                    aerosol_day.g(iday, ilay, ibnd)   = aerosol.g(dayIndices(iday), ilay, ibnd);));
+    TIMED_KERNEL(FLATTEN_MD_KERNEL3(
+        nday, nlay, nbnd, iday, ilay, ibnd,
+        aerosol_day.tau(iday, ilay, ibnd) = aerosol.tau(dayIndices(iday), ilay, ibnd);
+        aerosol_day.ssa(iday, ilay, ibnd) = aerosol.ssa(dayIndices(iday), ilay, ibnd);
+        aerosol_day.g(iday, ilay, ibnd)   = aerosol.g(dayIndices(iday), ilay, ibnd);));
 
     // Subset cloud optics
     // TODO: nbnd -> ngpt once we pass sub-sampled cloud state
     optical_props2_t clouds_day;
-    clouds_day.init_no_alloc(k_dist.get_band_lims_wavenumber(), k_dist.get_band_lims_gpoint(), sw_cloud_band2gpt_mem,
-                             sw_cloud_gpt2band_mem);
+    clouds_day.init_no_alloc(k_dist.get_band_lims_wavenumber(), k_dist.get_band_lims_gpoint(),
+                             sw_cloud_band2gpt_mem, sw_cloud_gpt2band_mem);
     clouds_day.alloc_2str_no_alloc(nday, nlay, sw_cloud_tau_mem, sw_cloud_ssa_mem, sw_cloud_g_mem);
-    TIMED_KERNEL(FLATTEN_MD_KERNEL3(nday, nlay, ngpt, iday, ilay, igpt,
-                                    clouds_day.tau(iday, ilay, igpt) = clouds.tau(dayIndices(iday), ilay, igpt);
-                                    clouds_day.ssa(iday, ilay, igpt) = clouds.ssa(dayIndices(iday), ilay, igpt);
-                                    clouds_day.g(iday, ilay, igpt)   = clouds.g(dayIndices(iday), ilay, igpt);));
+    TIMED_KERNEL(FLATTEN_MD_KERNEL3(
+        nday, nlay, ngpt, iday, ilay, igpt,
+        clouds_day.tau(iday, ilay, igpt) = clouds.tau(dayIndices(iday), ilay, igpt);
+        clouds_day.ssa(iday, ilay, igpt) = clouds.ssa(dayIndices(iday), ilay, igpt);
+        clouds_day.g(iday, ilay, igpt)   = clouds.g(dayIndices(iday), ilay, igpt);));
 
     // RRTMGP assumes surface albedos have a screwy dimension ordering
     // for some strange reason, so we need to transpose these; also do
     // daytime subsetting in the same kernel
-    TIMED_KERNEL(
-        FLATTEN_MD_KERNEL2(nbnd, nday, ibnd, icol, sfc_alb_dir_T(ibnd, icol) = sfc_alb_dir(dayIndices(icol), ibnd);
-                           sfc_alb_dif_T(ibnd, icol) = sfc_alb_dif(dayIndices(icol), ibnd);));
+    TIMED_KERNEL(FLATTEN_MD_KERNEL2(
+        nbnd, nday, ibnd, icol, sfc_alb_dir_T(ibnd, icol) = sfc_alb_dir(dayIndices(icol), ibnd);
+        sfc_alb_dif_T(ibnd, icol) = sfc_alb_dif(dayIndices(icol), ibnd);));
 
     // Temporaries we need for daytime-only fluxes
     fluxes_t fluxes_day;
@@ -743,29 +802,32 @@ struct rrtmgp_interface {
 
     // Allocate space for optical properties
     optical_props2_t optics;
-    optics.alloc_2str_no_alloc(nday, nlay, k_dist, sw_optics_band2gpt_mem, sw_optics_gpt2band_mem, sw_optics_tau_mem,
-                               sw_optics_ssa_mem, sw_optics_g_mem);
+    optics.alloc_2str_no_alloc(nday, nlay, k_dist, sw_optics_band2gpt_mem, sw_optics_gpt2band_mem,
+                               sw_optics_tau_mem, sw_optics_ssa_mem, sw_optics_g_mem);
 
     optical_props2_t optics_no_aerosols;
     if (extra_clnsky_diag) {
       // Allocate space for optical properties (no aerosols)
-      optics_no_aerosols.alloc_2str_no_alloc(nday, nlay, k_dist, sw_noaero_band2gpt_mem, sw_noaero_gpt2band_mem,
-                                             sw_noaero_tau_mem, sw_noaero_ssa_mem, sw_noaero_g_mem);
+      optics_no_aerosols.alloc_2str_no_alloc(nday, nlay, k_dist, sw_noaero_band2gpt_mem,
+                                             sw_noaero_gpt2band_mem, sw_noaero_tau_mem,
+                                             sw_noaero_ssa_mem, sw_noaero_g_mem);
     }
 
     // Limit temperatures for gas optics look-up tables
-    limit_to_bounds_k(t_lay_day, k_dist_sw_k->get_temp_min(), k_dist_sw_k->get_temp_max(), t_lay_limited);
+    limit_to_bounds_k(t_lay_day, k_dist_sw_k->get_temp_min(), k_dist_sw_k->get_temp_max(),
+                      t_lay_limited);
 
     // Do gas optics
     bool top_at_1 = false;
     Kokkos::parallel_reduce(
-        1, KOKKOS_LAMBDA(int, bool &val) { val |= p_lay(0, 0) < p_lay(0, nlay - 1); }, Kokkos::LOr<bool>(top_at_1));
+        1, KOKKOS_LAMBDA(int, bool &val) { val |= p_lay(0, 0) < p_lay(0, nlay - 1); },
+        Kokkos::LOr<bool>(top_at_1));
 
-    k_dist.gas_optics(nday, nlay, top_at_1, p_lay_day, p_lev_day, t_lay_limited, gas_concs_day, col_gas, optics,
-                      toa_flux);
+    k_dist.gas_optics(nday, nlay, top_at_1, p_lay_day, p_lev_day, t_lay_limited, gas_concs_day,
+                      col_gas, optics, toa_flux);
     if (extra_clnsky_diag) {
-      k_dist.gas_optics(nday, nlay, top_at_1, p_lay_day, p_lev_day, t_lay_limited, gas_concs_day, col_gas,
-                        optics_no_aerosols, toa_flux);
+      k_dist.gas_optics(nday, nlay, top_at_1, p_lay_day, p_lev_day, t_lay_limited, gas_concs_day,
+                        col_gas, optics_no_aerosols, toa_flux);
     }
 
 #ifdef SCREAM_RRTMGP_DEBUG
@@ -776,17 +838,18 @@ struct rrtmgp_interface {
 #endif
 
     // Apply tsi_scaling
-    TIMED_KERNEL(
-        FLATTEN_MD_KERNEL2(nday, ngpt, iday, igpt, toa_flux(iday, igpt) = tsi_scaling * toa_flux(iday, igpt);));
+    TIMED_KERNEL(FLATTEN_MD_KERNEL2(nday, ngpt, iday, igpt,
+                                    toa_flux(iday, igpt) = tsi_scaling * toa_flux(iday, igpt);));
 
     if (extra_clnclrsky_diag) {
       // Compute clear-clean-sky (just gas) fluxes on daytime columns
       rte_sw(optics, top_at_1, mu0_day, toa_flux, sfc_alb_dir_T, sfc_alb_dif_T, fluxes_day);
       // Expand daytime fluxes to all columns
-      TIMED_KERNEL(FLATTEN_MD_KERNEL2(nday, nlay + 1, iday, ilev, const int icol = dayIndices(iday);
-                                      clnclrsky_flux_up(icol, ilev)     = flux_up_day(iday, ilev);
-                                      clnclrsky_flux_dn(icol, ilev)     = flux_dn_day(iday, ilev);
-                                      clnclrsky_flux_dn_dir(icol, ilev) = flux_dn_dir_day(iday, ilev);));
+      TIMED_KERNEL(
+          FLATTEN_MD_KERNEL2(nday, nlay + 1, iday, ilev, const int icol = dayIndices(iday);
+                             clnclrsky_flux_up(icol, ilev)     = flux_up_day(iday, ilev);
+                             clnclrsky_flux_dn(icol, ilev)     = flux_dn_day(iday, ilev);
+                             clnclrsky_flux_dn_dir(icol, ilev) = flux_dn_dir_day(iday, ilev);));
     }
 
     // Combine gas and aerosol optics
@@ -810,24 +873,28 @@ struct rrtmgp_interface {
     // Compute fluxes on daytime columns
     rte_sw(optics, top_at_1, mu0_day, toa_flux, sfc_alb_dir_T, sfc_alb_dif_T, fluxes_day);
     // Expand daytime fluxes to all columns
-    TIMED_KERNEL(FLATTEN_MD_KERNEL2(
-        nday, nlay + 1, iday, ilev, const int icol = dayIndices(iday); flux_up(icol, ilev) = flux_up_day(iday, ilev);
-        flux_dn(icol, ilev) = flux_dn_day(iday, ilev); flux_dn_dir(icol, ilev) = flux_dn_dir_day(iday, ilev);));
-    TIMED_KERNEL(FLATTEN_MD_KERNEL3(nday, nlay + 1, nbnd, iday, ilev, ibnd, const int icol = dayIndices(iday);
-                                    bnd_flux_up(icol, ilev, ibnd)     = bnd_flux_up_day(iday, ilev, ibnd);
-                                    bnd_flux_dn(icol, ilev, ibnd)     = bnd_flux_dn_day(iday, ilev, ibnd);
-                                    bnd_flux_dn_dir(icol, ilev, ibnd) = bnd_flux_dn_dir_day(iday, ilev, ibnd);));
+    TIMED_KERNEL(FLATTEN_MD_KERNEL2(nday, nlay + 1, iday, ilev, const int icol = dayIndices(iday);
+                                    flux_up(icol, ilev)     = flux_up_day(iday, ilev);
+                                    flux_dn(icol, ilev)     = flux_dn_day(iday, ilev);
+                                    flux_dn_dir(icol, ilev) = flux_dn_dir_day(iday, ilev);));
+    TIMED_KERNEL(FLATTEN_MD_KERNEL3(
+        nday, nlay + 1, nbnd, iday, ilev, ibnd, const int icol = dayIndices(iday);
+        bnd_flux_up(icol, ilev, ibnd)     = bnd_flux_up_day(iday, ilev, ibnd);
+        bnd_flux_dn(icol, ilev, ibnd)     = bnd_flux_dn_day(iday, ilev, ibnd);
+        bnd_flux_dn_dir(icol, ilev, ibnd) = bnd_flux_dn_dir_day(iday, ilev, ibnd);));
 
     if (extra_clnsky_diag) {
       // First increment clouds in optics_no_aerosols
       clouds_day.increment(optics_no_aerosols);
       // Compute cleansky (gas + clouds) fluxes on daytime columns
-      rte_sw(optics_no_aerosols, top_at_1, mu0_day, toa_flux, sfc_alb_dir_T, sfc_alb_dif_T, fluxes_day);
+      rte_sw(optics_no_aerosols, top_at_1, mu0_day, toa_flux, sfc_alb_dir_T, sfc_alb_dif_T,
+             fluxes_day);
       // Expand daytime fluxes to all columns
-      TIMED_KERNEL(FLATTEN_MD_KERNEL2(nday, nlay + 1, iday, ilev, const int icol = dayIndices(iday);
-                                      clnsky_flux_up(icol, ilev)     = flux_up_day(iday, ilev);
-                                      clnsky_flux_dn(icol, ilev)     = flux_dn_day(iday, ilev);
-                                      clnsky_flux_dn_dir(icol, ilev) = flux_dn_dir_day(iday, ilev);));
+      TIMED_KERNEL(
+          FLATTEN_MD_KERNEL2(nday, nlay + 1, iday, ilev, const int icol = dayIndices(iday);
+                             clnsky_flux_up(icol, ilev)     = flux_up_day(iday, ilev);
+                             clnsky_flux_dn(icol, ilev)     = flux_dn_day(iday, ilev);
+                             clnsky_flux_dn_dir(icol, ilev) = flux_dn_dir_day(iday, ilev);));
     }
 
     pool_t::dealloc(dayIndices);
@@ -888,11 +955,11 @@ struct rrtmgp_interface {
    * Longwave driver (called by rrtmgp_main)
    */
   static void rrtmgp_lw(const int ncol, const int nlay, gas_optics_t &k_dist, const creal2dk &p_lay,
-                        const creal2dk &t_lay, const creal2dk &p_lev, const creal2dk &t_lev, gas_concs_t &gas_concs,
-                        optical_props1_t &aerosol, optical_props1_t &clouds, fluxes_t &fluxes,
-                        fluxes_broadband_t &clnclrsky_fluxes, fluxes_broadband_t &clrsky_fluxes,
-                        fluxes_broadband_t &clnsky_fluxes, const bool extra_clnclrsky_diag,
-                        const bool extra_clnsky_diag) {
+                        const creal2dk &t_lay, const creal2dk &p_lev, const creal2dk &t_lev,
+                        gas_concs_t &gas_concs, optical_props1_t &aerosol, optical_props1_t &clouds,
+                        fluxes_t &fluxes, fluxes_broadband_t &clnclrsky_fluxes,
+                        fluxes_broadband_t &clrsky_fluxes, fluxes_broadband_t &clnsky_fluxes,
+                        const bool extra_clnclrsky_diag, const bool extra_clnsky_diag) {
     // Problem size
     int nbnd                    = k_dist.get_nband();
     int constexpr max_gauss_pts = 4;
@@ -932,36 +999,42 @@ struct rrtmgp_interface {
     auto &clnsky_flux_dn    = clnsky_fluxes.flux_dn;
 
     // Reset fluxes to zero
-    TIMED_KERNEL(FLATTEN_MD_KERNEL2(ncol, nlay + 1, icol, ilev, flux_up(icol, ilev) = 0; flux_dn(icol, ilev) = 0;
-                                    clnclrsky_flux_up(icol, ilev) = 0; clnclrsky_flux_dn(icol, ilev) = 0;
-                                    clrsky_flux_up(icol, ilev) = 0; clrsky_flux_dn(icol, ilev) = 0;
-                                    clnsky_flux_up(icol, ilev) = 0; clnsky_flux_dn(icol, ilev) = 0;));
-    TIMED_KERNEL(FLATTEN_MD_KERNEL3(ncol, nlay + 1, nbnd, icol, ilev, ibnd, bnd_flux_up(icol, ilev, ibnd) = 0;
+    TIMED_KERNEL(FLATTEN_MD_KERNEL2(
+        ncol, nlay + 1, icol, ilev, flux_up(icol, ilev) = 0; flux_dn(icol, ilev) = 0;
+        clnclrsky_flux_up(icol, ilev) = 0; clnclrsky_flux_dn(icol, ilev) = 0;
+        clrsky_flux_up(icol, ilev) = 0; clrsky_flux_dn(icol, ilev) = 0;
+        clnsky_flux_up(icol, ilev) = 0; clnsky_flux_dn(icol, ilev) = 0;));
+    TIMED_KERNEL(FLATTEN_MD_KERNEL3(ncol, nlay + 1, nbnd, icol, ilev, ibnd,
+                                    bnd_flux_up(icol, ilev, ibnd) = 0;
                                     bnd_flux_dn(icol, ilev, ibnd) = 0;));
 
     // Allocate space for optical properties
     optical_props1_t optics;
-    optics.alloc_1scl_no_alloc(ncol, nlay, k_dist, lw_optics_band2gpt_mem, lw_optics_gpt2band_mem, lw_optics_tau_mem);
+    optics.alloc_1scl_no_alloc(ncol, nlay, k_dist, lw_optics_band2gpt_mem, lw_optics_gpt2band_mem,
+                               lw_optics_tau_mem);
 
     optical_props1_t optics_no_aerosols;
     if (extra_clnsky_diag) {
       // Allocate space for optical properties (no aerosols)
-      optics_no_aerosols.alloc_1scl_no_alloc(ncol, nlay, k_dist, lw_noaero_band2gpt_mem, lw_noaero_gpt2band_mem,
-                                             lw_noaero_tau_mem);
+      optics_no_aerosols.alloc_1scl_no_alloc(ncol, nlay, k_dist, lw_noaero_band2gpt_mem,
+                                             lw_noaero_gpt2band_mem, lw_noaero_tau_mem);
     }
 
     // Boundary conditions
     source_func_t lw_sources;
-    lw_sources.alloc_no_alloc(ncol, nlay, k_dist, lw_source_band2gpt_mem, lw_source_gpt2band_mem, sfc_source_mem,
-                              lay_source_mem, lev_source_inc_mem, lev_source_dec_mem);
+    lw_sources.alloc_no_alloc(ncol, nlay, k_dist, lw_source_band2gpt_mem, lw_source_gpt2band_mem,
+                              sfc_source_mem, lay_source_mem, lev_source_inc_mem,
+                              lev_source_dec_mem);
 
     bool top_at_1 = false;
     Kokkos::parallel_reduce(
-        1, KOKKOS_LAMBDA(int, bool &val) { val |= p_lay(0, 0) < p_lay(0, nlay - 1); }, Kokkos::LOr<bool>(top_at_1));
+        1, KOKKOS_LAMBDA(int, bool &val) { val |= p_lay(0, 0) < p_lay(0, nlay - 1); },
+        Kokkos::LOr<bool>(top_at_1));
 
     // Surface temperature
     TIMED_KERNEL(Kokkos::parallel_for(
-        ncol, KOKKOS_LAMBDA(int icol) { t_sfc(icol) = t_lev(icol, conv::merge(nlay, 0, top_at_1)); }));
+        ncol,
+        KOKKOS_LAMBDA(int icol) { t_sfc(icol) = t_lev(icol, conv::merge(nlay, 0, top_at_1)); }));
     Kokkos::deep_copy(emis_sfc, 0.98);
 
     // Get Gaussian quadrature weights
@@ -969,16 +1042,18 @@ struct rrtmgp_interface {
     // Weights and angle secants for first order (k=1) Gaussian quadrature.
     //   Values from Table 2, Clough et al, 1992, doi:10.1029/92JD01419
     //   after Abramowitz & Stegun 1972, page 921
-    RealT gauss_Ds_host_raw[max_gauss_pts][max_gauss_pts] = {{1.66, 1.18350343, 1.09719858, 1.06056257},
-                                                             {0., 2.81649655, 1.69338507, 1.38282560},
-                                                             {0., 0., 4.70941630, 2.40148179},
-                                                             {0., 0., 0., 7.15513024}};
+    RealT gauss_Ds_host_raw[max_gauss_pts][max_gauss_pts] = {
+        {1.66, 1.18350343, 1.09719858, 1.06056257},
+        {0., 2.81649655, 1.69338507, 1.38282560},
+        {0., 0., 4.70941630, 2.40148179},
+        {0., 0., 0., 7.15513024}};
     hview_t<RealT **> gauss_Ds_host(&gauss_Ds_host_raw[0][0], max_gauss_pts, max_gauss_pts);
 
-    RealT gauss_wts_host_raw[max_gauss_pts][max_gauss_pts] = {{0.5, 0.3180413817, 0.2009319137, 0.1355069134},
-                                                              {0., 0.1819586183, 0.2292411064, 0.2034645680},
-                                                              {0., 0., 0.0698269799, 0.1298475476},
-                                                              {0., 0., 0., 0.0311809710}};
+    RealT gauss_wts_host_raw[max_gauss_pts][max_gauss_pts] = {
+        {0.5, 0.3180413817, 0.2009319137, 0.1355069134},
+        {0., 0.1819586183, 0.2292411064, 0.2034645680},
+        {0., 0., 0.0698269799, 0.1298475476},
+        {0., 0., 0., 0.0311809710}};
 
     hview_t<RealT **> gauss_wts_host(&gauss_wts_host_raw[0][0], max_gauss_pts, max_gauss_pts);
 
@@ -986,15 +1061,17 @@ struct rrtmgp_interface {
     Kokkos::deep_copy(gauss_wts, gauss_wts_host);
 
     // Limit temperatures for gas optics look-up tables
-    limit_to_bounds_k(t_lay, k_dist_lw_k->get_temp_min(), k_dist_lw_k->get_temp_max(), t_lay_limited);
-    limit_to_bounds_k(t_lev, k_dist_lw_k->get_temp_min(), k_dist_lw_k->get_temp_max(), t_lev_limited);
+    limit_to_bounds_k(t_lay, k_dist_lw_k->get_temp_min(), k_dist_lw_k->get_temp_max(),
+                      t_lay_limited);
+    limit_to_bounds_k(t_lev, k_dist_lw_k->get_temp_min(), k_dist_lw_k->get_temp_max(),
+                      t_lev_limited);
 
     // Do gas optics
-    k_dist.gas_optics(ncol, nlay, top_at_1, p_lay, p_lev, t_lay_limited, t_sfc, gas_concs, col_gas, optics, lw_sources,
-                      view_t<RealT **>(), t_lev_limited);
+    k_dist.gas_optics(ncol, nlay, top_at_1, p_lay, p_lev, t_lay_limited, t_sfc, gas_concs, col_gas,
+                      optics, lw_sources, view_t<RealT **>(), t_lev_limited);
     if (extra_clnsky_diag) {
-      k_dist.gas_optics(ncol, nlay, top_at_1, p_lay, p_lev, t_lay_limited, t_sfc, gas_concs, col_gas,
-                        optics_no_aerosols, lw_sources, view_t<RealT **>(), t_lev_limited);
+      k_dist.gas_optics(ncol, nlay, top_at_1, p_lay, p_lev, t_lay_limited, t_sfc, gas_concs,
+                        col_gas, optics_no_aerosols, lw_sources, view_t<RealT **>(), t_lev_limited);
     }
 
 #ifdef SCREAM_RRTMGP_DEBUG
@@ -1004,14 +1081,16 @@ struct rrtmgp_interface {
 
     if (extra_clnclrsky_diag) {
       // Compute clean-clear-sky fluxes before we add in aerosols and clouds
-      rte_lw(max_gauss_pts, gauss_Ds, gauss_wts, optics, top_at_1, lw_sources, emis_sfc, clnclrsky_fluxes);
+      rte_lw(max_gauss_pts, gauss_Ds, gauss_wts, optics, top_at_1, lw_sources, emis_sfc,
+             clnclrsky_fluxes);
     }
 
     // Combine gas and aerosol optics
     aerosol.increment(optics);
 
     // Compute clear-sky fluxes before we add in clouds
-    rte_lw(max_gauss_pts, gauss_Ds, gauss_wts, optics, top_at_1, lw_sources, emis_sfc, clrsky_fluxes);
+    rte_lw(max_gauss_pts, gauss_Ds, gauss_wts, optics, top_at_1, lw_sources, emis_sfc,
+           clrsky_fluxes);
 
     // Combine gas and cloud optics
     clouds.increment(optics);
@@ -1023,7 +1102,8 @@ struct rrtmgp_interface {
       // First increment clouds in optics_no_aerosols
       clouds.increment(optics_no_aerosols);
       // Compute clean-sky fluxes
-      rte_lw(max_gauss_pts, gauss_Ds, gauss_wts, optics_no_aerosols, top_at_1, lw_sources, emis_sfc, clnsky_fluxes);
+      rte_lw(max_gauss_pts, gauss_Ds, gauss_wts, optics_no_aerosols, top_at_1, lw_sources, emis_sfc,
+             clnsky_fluxes);
     }
 
     pool_t::dealloc(t_sfc);
@@ -1053,7 +1133,8 @@ struct rrtmgp_interface {
    */
   template <typename CldfT, typename SeedsT, typename SubcT>
   static void get_subcolumn_mask(const int ncol, const int nlay, const int ngpt, const CldfT &cldf,
-                                 const int overlap_option, const SeedsT &seeds, const SubcT &subcolumn_mask) {
+                                 const int overlap_option, const SeedsT &seeds,
+                                 const SubcT &subcolumn_mask) {
     // Subcolumn generators are a means for producing a variable x(i,j,k), where
     //
     //     c(i,j,k) = 1 for x(i,j,k) >  1 - cldf(i,j)
@@ -1099,17 +1180,18 @@ struct rrtmgp_interface {
       //       }
       //     }
       //   });
-      TIMED_KERNEL(
-          FLATTEN_MD_KERNEL3(ncol, nlay, ngpt, icol, ilay, igpt, conv::Random rand(seeds(icol) + ilay * ngpt + igpt);
-                             cldx(icol, ilay, igpt) = rand.genFP<RealT>();));
+      TIMED_KERNEL(FLATTEN_MD_KERNEL3(ncol, nlay, ngpt, icol, ilay, igpt,
+                                      conv::Random rand(seeds(icol) + ilay * ngpt + igpt);
+                                      cldx(icol, ilay, igpt) = rand.genFP<RealT>();));
 
       // Step down columns and apply algorithm from eq (14)
       TIMED_KERNEL(FLATTEN_MD_KERNEL2(
           ncol, ngpt, icol, igpt, for (int ilay = 1; ilay < nlay; ilay++) {
-            // Check cldx in level above and see if it satisfies conditions to create a cloudy subcolumn
+            // Check cldx in level above and see if it satisfies conditions to create a cloudy
+            // subcolumn
             if (cldx(icol, ilay - 1, igpt) > 1.0 - cldf(icol, ilay - 1)) {
-              // Cloudy subcolumn above, use same random number here so that clouds in these two adjacent
-              // layers are maximimally overlapped
+              // Cloudy subcolumn above, use same random number here so that clouds in these two
+              // adjacent layers are maximimally overlapped
               cldx(icol, ilay, igpt) = cldx(icol, ilay - 1, igpt);
             } else {
               // Cloud-less above, use new random number so that clouds are distributed
@@ -1125,9 +1207,9 @@ struct rrtmgp_interface {
     // Use cldx array to create subcolumn mask
     TIMED_KERNEL(FLATTEN_MD_KERNEL3(
         ncol, nlay, ngpt, icol, ilay, igpt,
-        if (cldx(icol, ilay, igpt) > 1.0 - cldf(icol, ilay)) { subcolumn_mask(icol, ilay, igpt) = 1; } else {
-          subcolumn_mask(icol, ilay, igpt) = 0;
-        }));
+        if (cldx(icol, ilay, igpt) > 1.0 - cldf(icol, ilay)) {
+          subcolumn_mask(icol, ilay, igpt) = 1;
+        } else { subcolumn_mask(icol, ilay, igpt) = 0; }));
 
     pool_t::dealloc(cldx);
   }
@@ -1135,18 +1217,18 @@ struct rrtmgp_interface {
   /*
    * Compute cloud area from 3d subcol cloud property
    */
-  static void compute_cloud_area(int ncol, int nlay, int ngpt, Real pmin, Real pmax, const creal2dk &pmid,
-                                 const real3dk &cld_tau_gpt, const real1dk &cld_area) {
+  static void compute_cloud_area(int ncol, int nlay, int ngpt, Real pmin, Real pmax,
+                                 const creal2dk &pmid, const real3dk &cld_tau_gpt,
+                                 const real1dk &cld_area) {
     // Subcolumn binary cld mask; if any layers with pressure between pmin and pmax are cloudy
     // then 2d subcol mask is 1, otherwise it is 0
     auto subcol_mask = pool_t::template alloc_and_init<RealT>(ncol, ngpt);
     TIMED_KERNEL(FLATTEN_MD_KERNEL3(
         ncol, nlay, ngpt, icol, ilay, igpt,
-        // NOTE: using plev would need to assume level ordering (top to bottom or bottom to top), but
-        // using play/pmid does not
-        if (cld_tau_gpt(icol, ilay, igpt) > 0 && pmid(icol, ilay) >= pmin && pmid(icol, ilay) < pmax) {
-          subcol_mask(icol, igpt) = 1;
-        }));
+        // NOTE: using plev would need to assume level ordering (top to bottom or bottom to top),
+        // but using play/pmid does not
+        if (cld_tau_gpt(icol, ilay, igpt) > 0 && pmid(icol, ilay) >= pmin &&
+            pmid(icol, ilay) < pmax) { subcol_mask(icol, igpt) = 1; }));
     // Compute average over subcols to get cloud area
     auto ngpt_inv = 1.0 / ngpt;
     Kokkos::deep_copy(cld_area, 0);
@@ -1164,14 +1246,14 @@ struct rrtmgp_interface {
   /*
    * Return select cloud-top diagnostics following AeroCom recommendation
    */
-  static void compute_aerocom_cloudtop(int ncol, int nlay, const creal2dk &tmid, const creal2dk &pmid,
-                                       const creal2dk &p_del, const real2dk &z_del, const creal2dk &qc,
-                                       const creal2dk &qi, const creal2dk &rel, const creal2dk &rei,
-                                       const real2dk &cldfrac_tot, const creal2dk &nc, const real1dk &T_mid_at_cldtop,
-                                       const real1dk &p_mid_at_cldtop, const real1dk &cldfrac_ice_at_cldtop,
-                                       const real1dk &cldfrac_liq_at_cldtop, const real1dk &cldfrac_tot_at_cldtop,
-                                       const real1dk &cdnc_at_cldtop, const real1dk &eff_radius_qc_at_cldtop,
-                                       const real1dk &eff_radius_qi_at_cldtop) {
+  static void compute_aerocom_cloudtop(
+      int ncol, int nlay, const creal2dk &tmid, const creal2dk &pmid, const creal2dk &p_del,
+      const real2dk &z_del, const creal2dk &qc, const creal2dk &qi, const creal2dk &rel,
+      const creal2dk &rei, const real2dk &cldfrac_tot, const creal2dk &nc,
+      const real1dk &T_mid_at_cldtop, const real1dk &p_mid_at_cldtop,
+      const real1dk &cldfrac_ice_at_cldtop, const real1dk &cldfrac_liq_at_cldtop,
+      const real1dk &cldfrac_tot_at_cldtop, const real1dk &cdnc_at_cldtop,
+      const real1dk &eff_radius_qc_at_cldtop, const real1dk &eff_radius_qi_at_cldtop) {
     /* The goal of this routine is to calculate properties at cloud top
      * based on the AeroCom recommendation. See reference for routine
      * get_subcolumn_mask above, where equation 14 is used for the
@@ -1209,14 +1291,16 @@ struct rrtmgp_interface {
           // highest is assumed to hav no clouds
           for (int ilay = 1; ilay < nlay; ++ilay) {
             // Only do the calculation if certain conditions are met
-            if ((qc(icol, ilay) + qi(icol, ilay)) > q_threshold && (cldfrac_tot(icol, ilay) > cldfrac_tot_threshold)) {
+            if ((qc(icol, ilay) + qi(icol, ilay)) > q_threshold &&
+                (cldfrac_tot(icol, ilay) > cldfrac_tot_threshold)) {
               /* PART I: Probabilistically determining cloud top */
               // Populate aerocom_tmp as the clear-sky fraction
               // probability of this level, where aerocom_clr is that of
               // the previous level
-              auto aerocom_tmp = aerocom_clr(icol) *
-                                 (1.0 - ekat::impl::max(cldfrac_tot(icol, ilay - 1), cldfrac_tot(icol, ilay))) /
-                                 (1.0 - ekat::impl::min(cldfrac_tot(icol, ilay - 1), 1.0 - cldfrac_tot_threshold));
+              auto aerocom_tmp =
+                  aerocom_clr(icol) *
+                  (1.0 - ekat::impl::max(cldfrac_tot(icol, ilay - 1), cldfrac_tot(icol, ilay))) /
+                  (1.0 - ekat::impl::min(cldfrac_tot(icol, ilay - 1), 1.0 - cldfrac_tot_threshold));
               // Temporary variable for probability "weights"
               auto aerocom_wts = aerocom_clr(icol) - aerocom_tmp;
               // Temporary variable for liquid "phase"
@@ -1237,8 +1321,8 @@ struct rrtmgp_interface {
               /* We need to convert nc from 1/mass to 1/volume first, and
                * from grid-mean to in-cloud, but after that, the
                * calculation follows the general logic */
-              auto cdnc =
-                  nc(icol, ilay) * p_del(icol, ilay) / z_del(icol, ilay) / physconst::gravit / cldfrac_tot(icol, ilay);
+              auto cdnc = nc(icol, ilay) * p_del(icol, ilay) / z_del(icol, ilay) /
+                          physconst::gravit / cldfrac_tot(icol, ilay);
               cdnc_at_cldtop(icol) += cdnc * aerocom_phi * aerocom_wts;
               // eff_radius_qc_at_cldtop
               eff_radius_qc_at_cldtop(icol) += rel(icol, ilay) * aerocom_phi * aerocom_wts;
@@ -1265,8 +1349,8 @@ struct rrtmgp_interface {
    * quantities).
    */
   template <class View1, class View2, class View3, class View4>
-  static void mixing_ratio_to_cloud_mass(View1 const &mixing_ratio, View2 const &cloud_fraction, View3 const &dp,
-                                         View4 const &cloud_mass) {
+  static void mixing_ratio_to_cloud_mass(View1 const &mixing_ratio, View2 const &cloud_fraction,
+                                         View3 const &dp, View4 const &cloud_mass) {
     int ncol        = mixing_ratio.extent(0);
     int nlay        = mixing_ratio.extent(1);
     using physconst = scream::physics::Constants<Real>;
@@ -1278,8 +1362,8 @@ struct rrtmgp_interface {
         // in EAM, this is consistent with limits in MG2. Is this true for P3?
         if (cloud_fraction(icol, ilay) > 0) {
           // Compute layer-integrated cloud mass (per unit area)
-          auto incloud_mixing_ratio =
-              std::min(mixing_ratio(icol, ilay) / std::max(0.0001, cloud_fraction(icol, ilay)), 0.005);
+          auto incloud_mixing_ratio = std::min(
+              mixing_ratio(icol, ilay) / std::max(0.0001, cloud_fraction(icol, ilay)), 0.005);
           cloud_mass(icol, ilay) = incloud_mixing_ratio * dp(icol, ilay) / physconst::gravit;
         } else { cloud_mass(icol, ilay) = 0; }));
   }
@@ -1290,22 +1374,27 @@ struct rrtmgp_interface {
    * property look-up tables, but could be used to limit other
    * fields as well.
    */
-  template <typename InT, typename T, typename OutT, typename std::enable_if<OutT::rank == 1>::type *dummy = nullptr>
+  template <typename InT, typename T, typename OutT,
+            typename std::enable_if<OutT::rank == 1>::type *dummy = nullptr>
   static void limit_to_bounds_k(InT const &arr_in, T const lower, T const upper, OutT &arr_out) {
     TIMED_KERNEL(Kokkos::parallel_for(
-        arr_out.size(), KOKKOS_LAMBDA(int i) { arr_out(i) = std::min(std::max(arr_in(i), lower), upper); }));
+        arr_out.size(),
+        KOKKOS_LAMBDA(int i) { arr_out(i) = std::min(std::max(arr_in(i), lower), upper); }));
   }
 
-  template <typename InT, typename T, typename OutT, typename std::enable_if<OutT::rank == 2>::type *dummy = nullptr>
+  template <typename InT, typename T, typename OutT,
+            typename std::enable_if<OutT::rank == 2>::type *dummy = nullptr>
   static void limit_to_bounds_k(InT const &arr_in, T const lower, T const upper, OutT &arr_out) {
     const int ex0 = (int)arr_out.extent(0);
     const int ex1 = (int)arr_out.extent(1);
-    TIMED_KERNEL(FLATTEN_MD_KERNEL2(ex0, ex1, i, j, arr_out(i, j) = std::min(std::max(arr_in(i, j), lower), upper);));
+    TIMED_KERNEL(FLATTEN_MD_KERNEL2(
+        ex0, ex1, i, j, arr_out(i, j) = std::min(std::max(arr_in(i, j), lower), upper);));
   }
 
   static int get_wavelength_index(optical_props_t &kdist, RealT wavelength) {
-    auto band_lims_wvn     = kdist.get_band_lims_wavenumber();
-    auto wavelength_bounds = pool_t::template alloc<RealT>(band_lims_wvn.extent(0), band_lims_wvn.extent(1));
+    auto band_lims_wvn = kdist.get_band_lims_wavenumber();
+    auto wavelength_bounds =
+        pool_t::template alloc<RealT>(band_lims_wvn.extent(0), band_lims_wvn.extent(1));
     // Get wavelength bounds for all wavelength bands
     kdist.get_band_lims_wavelength(wavelength_bounds);
 
@@ -1318,11 +1407,13 @@ struct rrtmgp_interface {
         nbnds,
         KOKKOS_LAMBDA(int ibnd, int &band_index_inner) {
           if (wavelength_bounds(0, ibnd) < wavelength_bounds(1, ibnd)) {
-            if (wavelength_bounds(0, ibnd) <= wavelength * 1e2 && wavelength * 1e2 <= wavelength_bounds(1, ibnd)) {
+            if (wavelength_bounds(0, ibnd) <= wavelength * 1e2 &&
+                wavelength * 1e2 <= wavelength_bounds(1, ibnd)) {
               band_index_inner = ibnd;
             }
           } else {
-            if (wavelength_bounds(0, ibnd) >= wavelength * 1e2 && wavelength * 1e2 >= wavelength_bounds(1, ibnd)) {
+            if (wavelength_bounds(0, ibnd) >= wavelength * 1e2 &&
+                wavelength * 1e2 >= wavelength_bounds(1, ibnd)) {
               band_index_inner = ibnd;
             }
           }
@@ -1340,11 +1431,12 @@ struct rrtmgp_interface {
     return get_wavelength_index(*k_dist_lw_k, wavelength);
   }
 
-  static optical_props2_t get_cloud_optics_sw(const int ncol, const int nlay, cloud_optics_t &cloud_optics,
-                                              gas_optics_t &kdist, const real2dk &lwp, const real2dk &iwp,
-                                              const creal2dk &rel, const creal2dk &rei, const int2dk &sw_band2gpt_mem,
-                                              const int1dk &sw_gpt2band_mem, const real3dk &sw_tau_mem,
-                                              const real3dk &sw_ssa_mem, const real3dk &sw_g_mem) {
+  static optical_props2_t
+  get_cloud_optics_sw(const int ncol, const int nlay, cloud_optics_t &cloud_optics,
+                      gas_optics_t &kdist, const real2dk &lwp, const real2dk &iwp,
+                      const creal2dk &rel, const creal2dk &rei, const int2dk &sw_band2gpt_mem,
+                      const int1dk &sw_gpt2band_mem, const real3dk &sw_tau_mem,
+                      const real3dk &sw_ssa_mem, const real3dk &sw_g_mem) {
 
     // Initialize optics
     optical_props2_t clouds;
@@ -1370,15 +1462,17 @@ struct rrtmgp_interface {
     return clouds;
   }
 
-  static optical_props1_t get_cloud_optics_lw(const int ncol, const int nlay, cloud_optics_t &cloud_optics,
-                                              gas_optics_t &kdist, const real2dk &lwp, const real2dk &iwp,
-                                              const creal2dk &rel, const creal2dk &rei, const int2dk &lw_band2gpt_mem,
-                                              const int1dk &lw_gpt2band_mem, const real3dk &lw_tau_mem) {
+  static optical_props1_t
+  get_cloud_optics_lw(const int ncol, const int nlay, cloud_optics_t &cloud_optics,
+                      gas_optics_t &kdist, const real2dk &lwp, const real2dk &iwp,
+                      const creal2dk &rel, const creal2dk &rei, const int2dk &lw_band2gpt_mem,
+                      const int1dk &lw_gpt2band_mem, const real3dk &lw_tau_mem) {
 
     // Initialize optics
     optical_props1_t clouds;
     clouds.init_no_alloc(kdist.get_band_lims_wavenumber(), lw_band2gpt_mem, lw_gpt2band_mem);
-    clouds.alloc_1scl_no_alloc(ncol, nlay, lw_tau_mem); // this is dumb, why do we need to init and alloc separately?!
+    clouds.alloc_1scl_no_alloc(
+        ncol, nlay, lw_tau_mem); // this is dumb, why do we need to init and alloc separately?!
 
     // Needed for consistency with all-sky example problem?
     cloud_optics.set_ice_roughness(2);
@@ -1399,15 +1493,16 @@ struct rrtmgp_interface {
     return clouds;
   }
 
-  static optical_props2_t get_subsampled_clouds(const int ncol, const int nlay, const int nbnd, const int ngpt,
-                                                optical_props2_t &cloud_optics, gas_optics_t &kdist, const real2dk &cld,
-                                                const creal2dk &p_lay, const int2dk &sw_band2gpt_mem,
-                                                const int1dk &sw_gpt2band_mem, const real3dk &sw_tau_mem,
-                                                const real3dk &sw_ssa_mem, const real3dk &sw_g_mem) {
+  static optical_props2_t
+  get_subsampled_clouds(const int ncol, const int nlay, const int nbnd, const int ngpt,
+                        optical_props2_t &cloud_optics, gas_optics_t &kdist, const real2dk &cld,
+                        const creal2dk &p_lay, const int2dk &sw_band2gpt_mem,
+                        const int1dk &sw_gpt2band_mem, const real3dk &sw_tau_mem,
+                        const real3dk &sw_ssa_mem, const real3dk &sw_g_mem) {
     // Initialized subsampled optics
     optical_props2_t subsampled_optics;
-    subsampled_optics.init_no_alloc(kdist.get_band_lims_wavenumber(), kdist.get_band_lims_gpoint(), sw_band2gpt_mem,
-                                    sw_gpt2band_mem, "subsampled_optics");
+    subsampled_optics.init_no_alloc(kdist.get_band_lims_wavenumber(), kdist.get_band_lims_gpoint(),
+                                    sw_band2gpt_mem, sw_gpt2band_mem, "subsampled_optics");
     subsampled_optics.alloc_2str_no_alloc(ncol, nlay, sw_tau_mem, sw_ssa_mem, sw_g_mem);
 
     // Subcolumn mask with values of 0 indicating no cloud, 1 indicating cloud
@@ -1416,32 +1511,36 @@ struct rrtmgp_interface {
     // Check that we do not have clouds with no optical properties; this would get corrected
     // when we assign optical props, but we want to use a "radiative cloud fraction"
     // for the subcolumn sampling too because otherwise we can get vertically-contiguous cloud
-    // mask profiles with no actual cloud properties in between, which would just further overestimate
-    // the vertical correlation of cloudy layers. I.e., cloudy layers might look maximally overlapped
-    // even when separated by layers with no cloud properties, when in fact those layers should be
-    // randomly overlapped.
+    // mask profiles with no actual cloud properties in between, which would just further
+    // overestimate the vertical correlation of cloudy layers. I.e., cloudy layers might look
+    // maximally overlapped even when separated by layers with no cloud properties, when in fact
+    // those layers should be randomly overlapped.
     auto cldfrac_rad = pool_t::template alloc_and_init<RealT>(ncol, nlay);
     TIMED_KERNEL(FLATTEN_MD_KERNEL3(
-        ncol, nlay, nbnd, icol, ilay, ibnd,
-        if (cloud_optics.tau(icol, ilay, ibnd) > 0) { cldfrac_rad(icol, ilay) = cld(icol, ilay); }));
+        ncol, nlay, nbnd, icol, ilay, ibnd, if (cloud_optics.tau(icol, ilay, ibnd) > 0) {
+          cldfrac_rad(icol, ilay) = cld(icol, ilay);
+        }));
 
-    // Get subcolumn cloud mask; note that get_subcolumn_mask exposes overlap assumption as an option,
-    // but the only currently supported options are 0 (trivial all-or-nothing cloud) or 1 (max-rand),
-    // so overlap has not been exposed as an option beyond this subcolumn. In the future, we should
-    // support generalized overlap as well, with parameters derived from DPSCREAM simulations with very
-    // high resolution.
+    // Get subcolumn cloud mask; note that get_subcolumn_mask exposes overlap assumption as an
+    // option, but the only currently supported options are 0 (trivial all-or-nothing cloud) or 1
+    // (max-rand), so overlap has not been exposed as an option beyond this subcolumn. In the
+    // future, we should support generalized overlap as well, with parameters derived from DPSCREAM
+    // simulations with very high resolution.
     int overlap = 1;
     // Get unique seeds for each column that are reproducible across different MPI rank layouts;
     // use decimal part of pressure for this, consistent with the implementation in EAM
     auto seeds = pool_t::template alloc<int>(ncol);
     TIMED_KERNEL(Kokkos::parallel_for(
-        ncol, KOKKOS_LAMBDA(int icol) { seeds(icol) = 1e9 * (p_lay(icol, nlay - 1) - int(p_lay(icol, nlay - 1))); }));
+        ncol, KOKKOS_LAMBDA(int icol) {
+          seeds(icol) = 1e9 * (p_lay(icol, nlay - 1) - int(p_lay(icol, nlay - 1)));
+        }));
     get_subcolumn_mask(ncol, nlay, ngpt, cldfrac_rad, overlap, seeds, cldmask);
 
     // Assign optical properties to subcolumns (note this implements MCICA)
     auto gpoint_bands = kdist.get_gpoint_bands();
     TIMED_KERNEL(FLATTEN_MD_KERNEL3(
-        ncol, nlay, ngpt, icol, ilay, igpt, auto ibnd = gpoint_bands(igpt); if (cldmask(icol, ilay, igpt) == 1) {
+        ncol, nlay, ngpt, icol, ilay, igpt, auto ibnd = gpoint_bands(igpt);
+        if (cldmask(icol, ilay, igpt) == 1) {
           subsampled_optics.tau(icol, ilay, igpt) = cloud_optics.tau(icol, ilay, ibnd);
           subsampled_optics.ssa(icol, ilay, igpt) = cloud_optics.ssa(icol, ilay, ibnd);
           subsampled_optics.g(icol, ilay, igpt)   = cloud_optics.g(icol, ilay, ibnd);
@@ -1458,15 +1557,16 @@ struct rrtmgp_interface {
     return subsampled_optics;
   }
 
-  static optical_props1_t get_subsampled_clouds(const int ncol, const int nlay, const int nbnd, const int ngpt,
-                                                optical_props1_t &cloud_optics, gas_optics_t &kdist, const real2dk &cld,
-                                                const creal2dk &p_lay, const int2dk &lw_band2gpt_mem,
-                                                const int1dk &lw_gpt2band_mem, const real3dk &lw_tau_mem) {
+  static optical_props1_t
+  get_subsampled_clouds(const int ncol, const int nlay, const int nbnd, const int ngpt,
+                        optical_props1_t &cloud_optics, gas_optics_t &kdist, const real2dk &cld,
+                        const creal2dk &p_lay, const int2dk &lw_band2gpt_mem,
+                        const int1dk &lw_gpt2band_mem, const real3dk &lw_tau_mem) {
 
     // Initialized subsampled optics
     optical_props1_t subsampled_optics;
-    subsampled_optics.init_no_alloc(kdist.get_band_lims_wavenumber(), kdist.get_band_lims_gpoint(), lw_band2gpt_mem,
-                                    lw_gpt2band_mem, "subsampled_optics");
+    subsampled_optics.init_no_alloc(kdist.get_band_lims_wavenumber(), kdist.get_band_lims_gpoint(),
+                                    lw_band2gpt_mem, lw_gpt2band_mem, "subsampled_optics");
     subsampled_optics.alloc_1scl_no_alloc(ncol, nlay, lw_tau_mem);
 
     // Subcolumn mask with values of 0 indicating no cloud, 1 indicating cloud
@@ -1475,27 +1575,31 @@ struct rrtmgp_interface {
     // Check that we do not have clouds with no optical properties; this would get corrected
     // when we assign optical props, but we want to use a "radiative cloud fraction"
     // for the subcolumn sampling too because otherwise we can get vertically-contiguous cloud
-    // mask profiles with no actual cloud properties in between, which would just further overestimate
-    // the vertical correlation of cloudy layers. I.e., cloudy layers might look maximally overlapped
-    // even when separated by layers with no cloud properties, when in fact those layers should be
-    // randomly overlapped.
+    // mask profiles with no actual cloud properties in between, which would just further
+    // overestimate the vertical correlation of cloudy layers. I.e., cloudy layers might look
+    // maximally overlapped even when separated by layers with no cloud properties, when in fact
+    // those layers should be randomly overlapped.
     auto cldfrac_rad = pool_t::template alloc_and_init<RealT>(ncol, nlay);
     TIMED_KERNEL(FLATTEN_MD_KERNEL3(
-        ncol, nlay, nbnd, icol, ilay, ibnd,
-        if (cloud_optics.tau(icol, ilay, ibnd) > 0) { cldfrac_rad(icol, ilay) = cld(icol, ilay); }));
+        ncol, nlay, nbnd, icol, ilay, ibnd, if (cloud_optics.tau(icol, ilay, ibnd) > 0) {
+          cldfrac_rad(icol, ilay) = cld(icol, ilay);
+        }));
     // Get subcolumn cloud mask
     int overlap = 1;
     // Get unique seeds for each column that are reproducible across different MPI rank layouts;
-    // use decimal part of pressure for this, consistent with the implementation in EAM; use different
-    // seed values for longwave and shortwave
+    // use decimal part of pressure for this, consistent with the implementation in EAM; use
+    // different seed values for longwave and shortwave
     auto seeds = pool_t::template alloc<int>(ncol);
     TIMED_KERNEL(Kokkos::parallel_for(
-        ncol, KOKKOS_LAMBDA(int icol) { seeds(icol) = 1e9 * (p_lay(icol, nlay - 2) - int(p_lay(icol, nlay - 2))); }));
+        ncol, KOKKOS_LAMBDA(int icol) {
+          seeds(icol) = 1e9 * (p_lay(icol, nlay - 2) - int(p_lay(icol, nlay - 2)));
+        }));
     get_subcolumn_mask(ncol, nlay, ngpt, cldfrac_rad, overlap, seeds, cldmask);
     // Assign optical properties to subcolumns (note this implements MCICA)
     auto gpoint_bands = kdist.get_gpoint_bands();
     TIMED_KERNEL(FLATTEN_MD_KERNEL3(
-        ncol, nlay, ngpt, icol, ilay, igpt, auto ibnd = gpoint_bands(igpt); if (cldmask(icol, ilay, igpt) == 1) {
+        ncol, nlay, ngpt, icol, ilay, igpt, auto ibnd = gpoint_bands(igpt);
+        if (cldmask(icol, ilay, igpt) == 1) {
           subsampled_optics.tau(icol, ilay, igpt) = cloud_optics.tau(icol, ilay, ibnd);
         } else { subsampled_optics.tau(icol, ilay, igpt) = 0; }));
 
diff --git i/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_process_interface.cpp w/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_process_interface.cpp
index 3004b7721a..6b7ce18b99 100644
--- i/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_process_interface.cpp
+++ w/components/eamxx/src/physics/rrtmgp/eamxx_rrtmgp_process_interface.cpp
@@ -29,7 +29,9 @@ struct ConvertToRrtmgpSubview {
   int beg;
   int ncol;
 
-  template <typename View> View subview1d(const View &v) const { return View(v, std::make_pair(beg, beg + ncol)); }
+  template <typename View> View subview1d(const View &v) const {
+    return View(v, std::make_pair(beg, beg + ncol));
+  }
 
   template <typename View> View subview2d_impl(const View &v, const int inner_dim) const {
     return View(v, std::make_pair(beg, beg + ncol), std::make_pair(0, inner_dim));
@@ -37,7 +39,8 @@ struct ConvertToRrtmgpSubview {
 
 #ifdef RRTMGP_LAYOUT_LEFT
   template <typename FieldView, typename BufferView>
-  BufferView subview2d(const FieldView &, const BufferView &buffer_view, const int inner_dim) const {
+  BufferView subview2d(const FieldView &, const BufferView &buffer_view,
+                       const int inner_dim) const {
     return BufferView(buffer_view, std::make_pair(0, ncol), Kokkos::ALL);
   }
 #else
@@ -150,7 +153,8 @@ void RRTMGPRadiation::set_grids(const std::shared_ptr<const GridsManager> grids_
   add_field<Required>("surf_lw_flux_up", scalar2d, W / (m * m), grid_name);
   // Set of required gas concentration fields
   for (auto &it : m_gas_names) {
-    // Add gas VOLUME mixing ratios (moles of gas / moles of air; what actually gets input to RRTMGP)
+    // Add gas VOLUME mixing ratios (moles of gas / moles of air; what actually gets input to
+    // RRTMGP)
     if (it == "o3") {
       // o3 is read from file, or computed by chemistry
       add_field<Required>(it + "_volume_mix_ratio", scalar3d_mid, mol / mol, grid_name);
@@ -266,7 +270,8 @@ void RRTMGPRadiation::set_grids(const std::shared_ptr<const GridsManager> grids_
       m_grid->set_geometry_data(bounds);
     }
 
-    // If no bounds were in the grid, the bands centerpoint likely wouldn't either. Still, let's check...
+    // If no bounds were in the grid, the bands centerpoint likely wouldn't either. Still, let's
+    // check...
     if (not m_grid->has_geometry_data(prefix + "bands")) {
       auto bounds   = m_grid->get_geometry_data(prefix + "band_bounds");
       auto bounds_h = bounds.get_view<const Real **, Host>();
@@ -283,20 +288,20 @@ void RRTMGPRadiation::set_grids(const std::shared_ptr<const GridsManager> grids_
 } // RRTMGPRadiation::set_grids
 
 size_t RRTMGPRadiation::requested_buffer_size_in_bytes() const {
-  const size_t interface_request = Buffer::num_1d_ncol * m_col_chunk_size +
-                                   Buffer::num_2d_nlay * m_col_chunk_size * m_nlay +
-                                   Buffer::num_2d_nlay_p1 * m_col_chunk_size * (m_nlay + 1) +
-                                   Buffer::num_2d_nswbands * m_col_chunk_size * m_nswbands +
-                                   Buffer::num_3d_nlev_nswbands * m_col_chunk_size * (m_nlay + 1) * m_nswbands +
-                                   Buffer::num_3d_nlev_nlwbands * m_col_chunk_size * (m_nlay + 1) * m_nlwbands +
-                                   Buffer::num_3d_nlay_nswbands * m_col_chunk_size * (m_nlay)*m_nswbands +
-                                   Buffer::num_3d_nlay_nlwbands * m_col_chunk_size * (m_nlay)*m_nlwbands +
-                                   Buffer::num_3d_nlay_nswgpts * m_col_chunk_size * (m_nlay)*m_nswgpts +
-                                   Buffer::num_3d_nlay_nlwgpts * m_col_chunk_size * (m_nlay)*m_nlwgpts *
+  const size_t interface_request =
+      Buffer::num_1d_ncol * m_col_chunk_size + Buffer::num_2d_nlay * m_col_chunk_size * m_nlay +
+      Buffer::num_2d_nlay_p1 * m_col_chunk_size * (m_nlay + 1) +
+      Buffer::num_2d_nswbands * m_col_chunk_size * m_nswbands +
+      Buffer::num_3d_nlev_nswbands * m_col_chunk_size * (m_nlay + 1) * m_nswbands +
+      Buffer::num_3d_nlev_nlwbands * m_col_chunk_size * (m_nlay + 1) * m_nlwbands +
+      Buffer::num_3d_nlay_nswbands * m_col_chunk_size * (m_nlay)*m_nswbands +
+      Buffer::num_3d_nlay_nlwbands * m_col_chunk_size * (m_nlay)*m_nlwbands +
+      Buffer::num_3d_nlay_nswgpts * m_col_chunk_size * (m_nlay)*m_nswgpts +
+      Buffer::num_3d_nlay_nlwgpts * m_col_chunk_size * (m_nlay)*m_nlwgpts *
 #if defined(RRTMGP_ENABLE_YAKL) && defined(RRTMGP_ENABLE_KOKKOS)
-                                       2;
+          2;
 #else
-                                       1;
+          1;
 #endif
 
   return interface_request * sizeof(Real);
@@ -313,21 +318,29 @@ void RRTMGPRadiation::init_buffers(const ATMBufferManager &buffer_manager) {
   // 1d arrays
   m_buffer.mu0 = decltype(m_buffer.mu0)("mu0", mem, m_col_chunk_size);
   mem += m_buffer.mu0.totElems();
-  m_buffer.sfc_alb_dir_vis = decltype(m_buffer.sfc_alb_dir_vis)("sfc_alb_dir_vis", mem, m_col_chunk_size);
+  m_buffer.sfc_alb_dir_vis =
+      decltype(m_buffer.sfc_alb_dir_vis)("sfc_alb_dir_vis", mem, m_col_chunk_size);
   mem += m_buffer.sfc_alb_dir_vis.totElems();
-  m_buffer.sfc_alb_dir_nir = decltype(m_buffer.sfc_alb_dir_nir)("sfc_alb_dir_nir", mem, m_col_chunk_size);
+  m_buffer.sfc_alb_dir_nir =
+      decltype(m_buffer.sfc_alb_dir_nir)("sfc_alb_dir_nir", mem, m_col_chunk_size);
   mem += m_buffer.sfc_alb_dir_nir.totElems();
-  m_buffer.sfc_alb_dif_vis = decltype(m_buffer.sfc_alb_dif_vis)("sfc_alb_dif_vis", mem, m_col_chunk_size);
+  m_buffer.sfc_alb_dif_vis =
+      decltype(m_buffer.sfc_alb_dif_vis)("sfc_alb_dif_vis", mem, m_col_chunk_size);
   mem += m_buffer.sfc_alb_dif_vis.totElems();
-  m_buffer.sfc_alb_dif_nir = decltype(m_buffer.sfc_alb_dif_nir)("sfc_alb_dif_nir", mem, m_col_chunk_size);
+  m_buffer.sfc_alb_dif_nir =
+      decltype(m_buffer.sfc_alb_dif_nir)("sfc_alb_dif_nir", mem, m_col_chunk_size);
   mem += m_buffer.sfc_alb_dif_nir.totElems();
-  m_buffer.sfc_flux_dir_vis = decltype(m_buffer.sfc_flux_dir_vis)("sfc_flux_dir_vis", mem, m_col_chunk_size);
+  m_buffer.sfc_flux_dir_vis =
+      decltype(m_buffer.sfc_flux_dir_vis)("sfc_flux_dir_vis", mem, m_col_chunk_size);
   mem += m_buffer.sfc_flux_dir_vis.totElems();
-  m_buffer.sfc_flux_dir_nir = decltype(m_buffer.sfc_flux_dir_nir)("sfc_flux_dir_nir", mem, m_col_chunk_size);
+  m_buffer.sfc_flux_dir_nir =
+      decltype(m_buffer.sfc_flux_dir_nir)("sfc_flux_dir_nir", mem, m_col_chunk_size);
   mem += m_buffer.sfc_flux_dir_nir.totElems();
-  m_buffer.sfc_flux_dif_vis = decltype(m_buffer.sfc_flux_dif_vis)("sfc_flux_dif_vis", mem, m_col_chunk_size);
+  m_buffer.sfc_flux_dif_vis =
+      decltype(m_buffer.sfc_flux_dif_vis)("sfc_flux_dif_vis", mem, m_col_chunk_size);
   mem += m_buffer.sfc_flux_dif_vis.totElems();
-  m_buffer.sfc_flux_dif_nir = decltype(m_buffer.sfc_flux_dif_nir)("sfc_flux_dif_nir", mem, m_col_chunk_size);
+  m_buffer.sfc_flux_dif_nir =
+      decltype(m_buffer.sfc_flux_dif_nir)("sfc_flux_dif_nir", mem, m_col_chunk_size);
   mem += m_buffer.sfc_flux_dif_nir.totElems();
   m_buffer.cosine_zenith = decltype(m_buffer.cosine_zenith)(mem, m_col_chunk_size);
   mem += m_buffer.cosine_zenith.size();
@@ -347,11 +360,14 @@ void RRTMGPRadiation::init_buffers(const ATMBufferManager &buffer_manager) {
   mem += m_buffer.nc.totElems();
   m_buffer.qi = decltype(m_buffer.qi)("qi", mem, m_col_chunk_size, m_nlay);
   mem += m_buffer.qi.totElems();
-  m_buffer.cldfrac_tot = decltype(m_buffer.cldfrac_tot)("cldfrac_tot", mem, m_col_chunk_size, m_nlay);
+  m_buffer.cldfrac_tot =
+      decltype(m_buffer.cldfrac_tot)("cldfrac_tot", mem, m_col_chunk_size, m_nlay);
   mem += m_buffer.cldfrac_tot.totElems();
-  m_buffer.eff_radius_qc = decltype(m_buffer.eff_radius_qc)("eff_radius_qc", mem, m_col_chunk_size, m_nlay);
+  m_buffer.eff_radius_qc =
+      decltype(m_buffer.eff_radius_qc)("eff_radius_qc", mem, m_col_chunk_size, m_nlay);
   mem += m_buffer.eff_radius_qc.totElems();
-  m_buffer.eff_radius_qi = decltype(m_buffer.eff_radius_qi)("eff_radius_qi", mem, m_col_chunk_size, m_nlay);
+  m_buffer.eff_radius_qi =
+      decltype(m_buffer.eff_radius_qi)("eff_radius_qi", mem, m_col_chunk_size, m_nlay);
   mem += m_buffer.eff_radius_qi.totElems();
   m_buffer.tmp2d = decltype(m_buffer.tmp2d)("tmp2d", mem, m_col_chunk_size, m_nlay);
   mem += m_buffer.tmp2d.totElems();
@@ -372,24 +388,29 @@ void RRTMGPRadiation::init_buffers(const ATMBufferManager &buffer_manager) {
   m_buffer.d_dz = decltype(m_buffer.d_dz)(mem, m_col_chunk_size, m_nlay);
   mem += m_buffer.d_dz.size();
   // 3d arrays
-  m_buffer.sw_flux_up = decltype(m_buffer.sw_flux_up)("sw_flux_up", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_flux_up =
+      decltype(m_buffer.sw_flux_up)("sw_flux_up", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_flux_up.totElems();
-  m_buffer.sw_flux_dn = decltype(m_buffer.sw_flux_dn)("sw_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_flux_dn =
+      decltype(m_buffer.sw_flux_dn)("sw_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_flux_dn.totElems();
-  m_buffer.sw_flux_dn_dir = decltype(m_buffer.sw_flux_dn_dir)("sw_flux_dn_dir", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_flux_dn_dir =
+      decltype(m_buffer.sw_flux_dn_dir)("sw_flux_dn_dir", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_flux_dn_dir.totElems();
-  m_buffer.lw_flux_up = decltype(m_buffer.lw_flux_up)("lw_flux_up", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.lw_flux_up =
+      decltype(m_buffer.lw_flux_up)("lw_flux_up", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_flux_up.totElems();
-  m_buffer.lw_flux_dn = decltype(m_buffer.lw_flux_dn)("lw_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.lw_flux_dn =
+      decltype(m_buffer.lw_flux_dn)("lw_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_flux_dn.totElems();
-  m_buffer.sw_clnclrsky_flux_up =
-      decltype(m_buffer.sw_clnclrsky_flux_up)("sw_clnclrsky_flux_up", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clnclrsky_flux_up = decltype(m_buffer.sw_clnclrsky_flux_up)(
+      "sw_clnclrsky_flux_up", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnclrsky_flux_up.totElems();
-  m_buffer.sw_clnclrsky_flux_dn =
-      decltype(m_buffer.sw_clnclrsky_flux_dn)("sw_clnclrsky_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clnclrsky_flux_dn = decltype(m_buffer.sw_clnclrsky_flux_dn)(
+      "sw_clnclrsky_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnclrsky_flux_dn.totElems();
-  m_buffer.sw_clnclrsky_flux_dn_dir =
-      decltype(m_buffer.sw_clnclrsky_flux_dn_dir)("sw_clnclrsky_flux_dn_dir", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clnclrsky_flux_dn_dir = decltype(m_buffer.sw_clnclrsky_flux_dn_dir)(
+      "sw_clnclrsky_flux_dn_dir", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnclrsky_flux_dn_dir.totElems();
   m_buffer.sw_clrsky_flux_up =
       decltype(m_buffer.sw_clrsky_flux_up)("sw_clrsky_flux_up", mem, m_col_chunk_size, m_nlay + 1);
@@ -397,8 +418,8 @@ void RRTMGPRadiation::init_buffers(const ATMBufferManager &buffer_manager) {
   m_buffer.sw_clrsky_flux_dn =
       decltype(m_buffer.sw_clrsky_flux_dn)("sw_clrsky_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clrsky_flux_dn.totElems();
-  m_buffer.sw_clrsky_flux_dn_dir =
-      decltype(m_buffer.sw_clrsky_flux_dn_dir)("sw_clrsky_flux_dn_dir", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clrsky_flux_dn_dir = decltype(m_buffer.sw_clrsky_flux_dn_dir)(
+      "sw_clrsky_flux_dn_dir", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clrsky_flux_dn_dir.totElems();
   m_buffer.sw_clnsky_flux_up =
       decltype(m_buffer.sw_clnsky_flux_up)("sw_clnsky_flux_up", mem, m_col_chunk_size, m_nlay + 1);
@@ -406,14 +427,14 @@ void RRTMGPRadiation::init_buffers(const ATMBufferManager &buffer_manager) {
   m_buffer.sw_clnsky_flux_dn =
       decltype(m_buffer.sw_clnsky_flux_dn)("sw_clnsky_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnsky_flux_dn.totElems();
-  m_buffer.sw_clnsky_flux_dn_dir =
-      decltype(m_buffer.sw_clnsky_flux_dn_dir)("sw_clnsky_flux_dn_dir", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clnsky_flux_dn_dir = decltype(m_buffer.sw_clnsky_flux_dn_dir)(
+      "sw_clnsky_flux_dn_dir", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnsky_flux_dn_dir.totElems();
-  m_buffer.lw_clnclrsky_flux_up =
-      decltype(m_buffer.lw_clnclrsky_flux_up)("lw_clnclrsky_flux_up", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.lw_clnclrsky_flux_up = decltype(m_buffer.lw_clnclrsky_flux_up)(
+      "lw_clnclrsky_flux_up", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_clnclrsky_flux_up.totElems();
-  m_buffer.lw_clnclrsky_flux_dn =
-      decltype(m_buffer.lw_clnclrsky_flux_dn)("lw_clnclrsky_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.lw_clnclrsky_flux_dn = decltype(m_buffer.lw_clnclrsky_flux_dn)(
+      "lw_clnclrsky_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_clnclrsky_flux_dn.totElems();
   m_buffer.lw_clrsky_flux_up =
       decltype(m_buffer.lw_clrsky_flux_up)("lw_clrsky_flux_up", mem, m_col_chunk_size, m_nlay + 1);
@@ -428,38 +449,44 @@ void RRTMGPRadiation::init_buffers(const ATMBufferManager &buffer_manager) {
       decltype(m_buffer.lw_clnsky_flux_dn)("lw_clnsky_flux_dn", mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_clnsky_flux_dn.totElems();
   // 3d arrays with nswbands dimension (shortwave fluxes by band)
-  m_buffer.sw_bnd_flux_up =
-      decltype(m_buffer.sw_bnd_flux_up)("sw_bnd_flux_up", mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
+  m_buffer.sw_bnd_flux_up = decltype(m_buffer.sw_bnd_flux_up)(
+      "sw_bnd_flux_up", mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
   mem += m_buffer.sw_bnd_flux_up.totElems();
-  m_buffer.sw_bnd_flux_dn =
-      decltype(m_buffer.sw_bnd_flux_dn)("sw_bnd_flux_dn", mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
+  m_buffer.sw_bnd_flux_dn = decltype(m_buffer.sw_bnd_flux_dn)(
+      "sw_bnd_flux_dn", mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
   mem += m_buffer.sw_bnd_flux_dn.totElems();
-  m_buffer.sw_bnd_flux_dir =
-      decltype(m_buffer.sw_bnd_flux_dir)("sw_bnd_flux_dir", mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
+  m_buffer.sw_bnd_flux_dir = decltype(m_buffer.sw_bnd_flux_dir)(
+      "sw_bnd_flux_dir", mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
   mem += m_buffer.sw_bnd_flux_dir.totElems();
-  m_buffer.sw_bnd_flux_dif =
-      decltype(m_buffer.sw_bnd_flux_dif)("sw_bnd_flux_dif", mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
+  m_buffer.sw_bnd_flux_dif = decltype(m_buffer.sw_bnd_flux_dif)(
+      "sw_bnd_flux_dif", mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
   mem += m_buffer.sw_bnd_flux_dif.totElems();
   // 3d arrays with nlwbands dimension (longwave fluxes by band)
-  m_buffer.lw_bnd_flux_up =
-      decltype(m_buffer.lw_bnd_flux_up)("lw_bnd_flux_up", mem, m_col_chunk_size, m_nlay + 1, m_nlwbands);
+  m_buffer.lw_bnd_flux_up = decltype(m_buffer.lw_bnd_flux_up)(
+      "lw_bnd_flux_up", mem, m_col_chunk_size, m_nlay + 1, m_nlwbands);
   mem += m_buffer.lw_bnd_flux_up.totElems();
-  m_buffer.lw_bnd_flux_dn =
-      decltype(m_buffer.lw_bnd_flux_dn)("lw_bnd_flux_dn", mem, m_col_chunk_size, m_nlay + 1, m_nlwbands);
+  m_buffer.lw_bnd_flux_dn = decltype(m_buffer.lw_bnd_flux_dn)(
+      "lw_bnd_flux_dn", mem, m_col_chunk_size, m_nlay + 1, m_nlwbands);
   mem += m_buffer.lw_bnd_flux_dn.totElems();
   // 2d arrays with extra nswbands dimension (surface albedos by band)
-  m_buffer.sfc_alb_dir = decltype(m_buffer.sfc_alb_dir)("sfc_alb_dir", mem, m_col_chunk_size, m_nswbands);
+  m_buffer.sfc_alb_dir =
+      decltype(m_buffer.sfc_alb_dir)("sfc_alb_dir", mem, m_col_chunk_size, m_nswbands);
   mem += m_buffer.sfc_alb_dir.totElems();
-  m_buffer.sfc_alb_dif = decltype(m_buffer.sfc_alb_dif)("sfc_alb_dif", mem, m_col_chunk_size, m_nswbands);
+  m_buffer.sfc_alb_dif =
+      decltype(m_buffer.sfc_alb_dif)("sfc_alb_dif", mem, m_col_chunk_size, m_nswbands);
   mem += m_buffer.sfc_alb_dif.totElems();
   // 3d arrays with extra band dimension (aerosol optics by band)
-  m_buffer.aero_tau_sw = decltype(m_buffer.aero_tau_sw)("aero_tau_sw", mem, m_col_chunk_size, m_nlay, m_nswbands);
+  m_buffer.aero_tau_sw =
+      decltype(m_buffer.aero_tau_sw)("aero_tau_sw", mem, m_col_chunk_size, m_nlay, m_nswbands);
   mem += m_buffer.aero_tau_sw.totElems();
-  m_buffer.aero_ssa_sw = decltype(m_buffer.aero_ssa_sw)("aero_ssa_sw", mem, m_col_chunk_size, m_nlay, m_nswbands);
+  m_buffer.aero_ssa_sw =
+      decltype(m_buffer.aero_ssa_sw)("aero_ssa_sw", mem, m_col_chunk_size, m_nlay, m_nswbands);
   mem += m_buffer.aero_ssa_sw.totElems();
-  m_buffer.aero_g_sw = decltype(m_buffer.aero_g_sw)("aero_g_sw", mem, m_col_chunk_size, m_nlay, m_nswbands);
+  m_buffer.aero_g_sw =
+      decltype(m_buffer.aero_g_sw)("aero_g_sw", mem, m_col_chunk_size, m_nlay, m_nswbands);
   mem += m_buffer.aero_g_sw.totElems();
-  m_buffer.aero_tau_lw = decltype(m_buffer.aero_tau_lw)("aero_tau_lw", mem, m_col_chunk_size, m_nlay, m_nlwbands);
+  m_buffer.aero_tau_lw =
+      decltype(m_buffer.aero_tau_lw)("aero_tau_lw", mem, m_col_chunk_size, m_nlay, m_nlwbands);
   mem += m_buffer.aero_tau_lw.totElems();
   // 3d arrays with extra ngpt dimension (cloud optics by gpoint; primarily for debugging)
   m_buffer.cld_tau_sw_gpt =
@@ -468,11 +495,11 @@ void RRTMGPRadiation::init_buffers(const ATMBufferManager &buffer_manager) {
   m_buffer.cld_tau_lw_gpt =
       decltype(m_buffer.cld_tau_lw_gpt)("cld_tau_lw_gpt", mem, m_col_chunk_size, m_nlay, m_nlwgpts);
   mem += m_buffer.cld_tau_lw_gpt.totElems();
-  m_buffer.cld_tau_sw_bnd =
-      decltype(m_buffer.cld_tau_sw_bnd)("cld_tau_sw_bnd", mem, m_col_chunk_size, m_nlay, m_nswbands);
+  m_buffer.cld_tau_sw_bnd = decltype(m_buffer.cld_tau_sw_bnd)("cld_tau_sw_bnd", mem,
+                                                              m_col_chunk_size, m_nlay, m_nswbands);
   mem += m_buffer.cld_tau_sw_bnd.totElems();
-  m_buffer.cld_tau_lw_bnd =
-      decltype(m_buffer.cld_tau_lw_bnd)("cld_tau_lw_bnd", mem, m_col_chunk_size, m_nlay, m_nlwbands);
+  m_buffer.cld_tau_lw_bnd = decltype(m_buffer.cld_tau_lw_bnd)("cld_tau_lw_bnd", mem,
+                                                              m_col_chunk_size, m_nlay, m_nlwbands);
   mem += m_buffer.cld_tau_lw_bnd.totElems();
 #endif
 
@@ -543,56 +570,77 @@ void RRTMGPRadiation::init_buffers(const ATMBufferManager &buffer_manager) {
   mem += m_buffer.sw_flux_up_k.size();
   m_buffer.sw_flux_dn_k = decltype(m_buffer.sw_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_flux_dn_k.size();
-  m_buffer.sw_flux_dn_dir_k = decltype(m_buffer.sw_flux_dn_dir_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_flux_dn_dir_k =
+      decltype(m_buffer.sw_flux_dn_dir_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_flux_dn_dir_k.size();
   m_buffer.lw_flux_up_k = decltype(m_buffer.lw_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_flux_up_k.size();
   m_buffer.lw_flux_dn_k = decltype(m_buffer.lw_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_flux_dn_k.size();
-  m_buffer.sw_clnclrsky_flux_up_k = decltype(m_buffer.sw_clnclrsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clnclrsky_flux_up_k =
+      decltype(m_buffer.sw_clnclrsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnclrsky_flux_up_k.size();
-  m_buffer.sw_clnclrsky_flux_dn_k = decltype(m_buffer.sw_clnclrsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clnclrsky_flux_dn_k =
+      decltype(m_buffer.sw_clnclrsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnclrsky_flux_dn_k.size();
   m_buffer.sw_clnclrsky_flux_dn_dir_k =
       decltype(m_buffer.sw_clnclrsky_flux_dn_dir_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnclrsky_flux_dn_dir_k.size();
-  m_buffer.sw_clrsky_flux_up_k = decltype(m_buffer.sw_clrsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clrsky_flux_up_k =
+      decltype(m_buffer.sw_clrsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clrsky_flux_up_k.size();
-  m_buffer.sw_clrsky_flux_dn_k = decltype(m_buffer.sw_clrsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clrsky_flux_dn_k =
+      decltype(m_buffer.sw_clrsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clrsky_flux_dn_k.size();
-  m_buffer.sw_clrsky_flux_dn_dir_k = decltype(m_buffer.sw_clrsky_flux_dn_dir_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clrsky_flux_dn_dir_k =
+      decltype(m_buffer.sw_clrsky_flux_dn_dir_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clrsky_flux_dn_dir_k.size();
-  m_buffer.sw_clnsky_flux_up_k = decltype(m_buffer.sw_clnsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clnsky_flux_up_k =
+      decltype(m_buffer.sw_clnsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnsky_flux_up_k.size();
-  m_buffer.sw_clnsky_flux_dn_k = decltype(m_buffer.sw_clnsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clnsky_flux_dn_k =
+      decltype(m_buffer.sw_clnsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnsky_flux_dn_k.size();
-  m_buffer.sw_clnsky_flux_dn_dir_k = decltype(m_buffer.sw_clnsky_flux_dn_dir_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.sw_clnsky_flux_dn_dir_k =
+      decltype(m_buffer.sw_clnsky_flux_dn_dir_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.sw_clnsky_flux_dn_dir_k.size();
-  m_buffer.lw_clnclrsky_flux_up_k = decltype(m_buffer.lw_clnclrsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.lw_clnclrsky_flux_up_k =
+      decltype(m_buffer.lw_clnclrsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_clnclrsky_flux_up_k.size();
-  m_buffer.lw_clnclrsky_flux_dn_k = decltype(m_buffer.lw_clnclrsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.lw_clnclrsky_flux_dn_k =
+      decltype(m_buffer.lw_clnclrsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_clnclrsky_flux_dn_k.size();
-  m_buffer.lw_clrsky_flux_up_k = decltype(m_buffer.lw_clrsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.lw_clrsky_flux_up_k =
+      decltype(m_buffer.lw_clrsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_clrsky_flux_up_k.size();
-  m_buffer.lw_clrsky_flux_dn_k = decltype(m_buffer.lw_clrsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.lw_clrsky_flux_dn_k =
+      decltype(m_buffer.lw_clrsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_clrsky_flux_dn_k.size();
-  m_buffer.lw_clnsky_flux_up_k = decltype(m_buffer.lw_clnsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.lw_clnsky_flux_up_k =
+      decltype(m_buffer.lw_clnsky_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_clnsky_flux_up_k.size();
-  m_buffer.lw_clnsky_flux_dn_k = decltype(m_buffer.lw_clnsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
+  m_buffer.lw_clnsky_flux_dn_k =
+      decltype(m_buffer.lw_clnsky_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1);
   mem += m_buffer.lw_clnsky_flux_dn_k.size();
   // 3d arrays with nswbands dimension (shortwave fluxes by band)
-  m_buffer.sw_bnd_flux_up_k = decltype(m_buffer.sw_bnd_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
+  m_buffer.sw_bnd_flux_up_k =
+      decltype(m_buffer.sw_bnd_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
   mem += m_buffer.sw_bnd_flux_up_k.size();
-  m_buffer.sw_bnd_flux_dn_k = decltype(m_buffer.sw_bnd_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
+  m_buffer.sw_bnd_flux_dn_k =
+      decltype(m_buffer.sw_bnd_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
   mem += m_buffer.sw_bnd_flux_dn_k.size();
-  m_buffer.sw_bnd_flux_dir_k = decltype(m_buffer.sw_bnd_flux_dir_k)(mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
+  m_buffer.sw_bnd_flux_dir_k =
+      decltype(m_buffer.sw_bnd_flux_dir_k)(mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
   mem += m_buffer.sw_bnd_flux_dir_k.size();
-  m_buffer.sw_bnd_flux_dif_k = decltype(m_buffer.sw_bnd_flux_dif_k)(mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
+  m_buffer.sw_bnd_flux_dif_k =
+      decltype(m_buffer.sw_bnd_flux_dif_k)(mem, m_col_chunk_size, m_nlay + 1, m_nswbands);
   mem += m_buffer.sw_bnd_flux_dif_k.size();
   // 3d arrays with nlwbands dimension (longwave fluxes by band)
-  m_buffer.lw_bnd_flux_up_k = decltype(m_buffer.lw_bnd_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1, m_nlwbands);
+  m_buffer.lw_bnd_flux_up_k =
+      decltype(m_buffer.lw_bnd_flux_up_k)(mem, m_col_chunk_size, m_nlay + 1, m_nlwbands);
   mem += m_buffer.lw_bnd_flux_up_k.size();
-  m_buffer.lw_bnd_flux_dn_k = decltype(m_buffer.lw_bnd_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1, m_nlwbands);
+  m_buffer.lw_bnd_flux_dn_k =
+      decltype(m_buffer.lw_bnd_flux_dn_k)(mem, m_col_chunk_size, m_nlay + 1, m_nlwbands);
   mem += m_buffer.lw_bnd_flux_dn_k.size();
   // 2d arrays with extra nswbands dimension (surface albedos by band)
   m_buffer.sfc_alb_dir_k = decltype(m_buffer.sfc_alb_dir_k)(mem, m_col_chunk_size, m_nswbands);
@@ -600,22 +648,29 @@ void RRTMGPRadiation::init_buffers(const ATMBufferManager &buffer_manager) {
   m_buffer.sfc_alb_dif_k = decltype(m_buffer.sfc_alb_dif_k)(mem, m_col_chunk_size, m_nswbands);
   mem += m_buffer.sfc_alb_dif_k.size();
   // 3d arrays with extra band dimension (aerosol optics by band)
-  m_buffer.aero_tau_sw_k = decltype(m_buffer.aero_tau_sw_k)(mem, m_col_chunk_size, m_nlay, m_nswbands);
+  m_buffer.aero_tau_sw_k =
+      decltype(m_buffer.aero_tau_sw_k)(mem, m_col_chunk_size, m_nlay, m_nswbands);
   mem += m_buffer.aero_tau_sw_k.size();
-  m_buffer.aero_ssa_sw_k = decltype(m_buffer.aero_ssa_sw_k)(mem, m_col_chunk_size, m_nlay, m_nswbands);
+  m_buffer.aero_ssa_sw_k =
+      decltype(m_buffer.aero_ssa_sw_k)(mem, m_col_chunk_size, m_nlay, m_nswbands);
   mem += m_buffer.aero_ssa_sw_k.size();
   m_buffer.aero_g_sw_k = decltype(m_buffer.aero_g_sw_k)(mem, m_col_chunk_size, m_nlay, m_nswbands);
   mem += m_buffer.aero_g_sw_k.size();
-  m_buffer.aero_tau_lw_k = decltype(m_buffer.aero_tau_lw_k)(mem, m_col_chunk_size, m_nlay, m_nlwbands);
+  m_buffer.aero_tau_lw_k =
+      decltype(m_buffer.aero_tau_lw_k)(mem, m_col_chunk_size, m_nlay, m_nlwbands);
   mem += m_buffer.aero_tau_lw_k.size();
   // 3d arrays with extra ngpt dimension (cloud optics by gpoint; primarily for debugging)
-  m_buffer.cld_tau_sw_gpt_k = decltype(m_buffer.cld_tau_sw_gpt_k)(mem, m_col_chunk_size, m_nlay, m_nswgpts);
+  m_buffer.cld_tau_sw_gpt_k =
+      decltype(m_buffer.cld_tau_sw_gpt_k)(mem, m_col_chunk_size, m_nlay, m_nswgpts);
   mem += m_buffer.cld_tau_sw_gpt_k.size();
-  m_buffer.cld_tau_lw_gpt_k = decltype(m_buffer.cld_tau_lw_gpt_k)(mem, m_col_chunk_size, m_nlay, m_nlwgpts);
+  m_buffer.cld_tau_lw_gpt_k =
+      decltype(m_buffer.cld_tau_lw_gpt_k)(mem, m_col_chunk_size, m_nlay, m_nlwgpts);
   mem += m_buffer.cld_tau_lw_gpt_k.size();
-  m_buffer.cld_tau_sw_bnd_k = decltype(m_buffer.cld_tau_sw_bnd_k)(mem, m_col_chunk_size, m_nlay, m_nswbands);
+  m_buffer.cld_tau_sw_bnd_k =
+      decltype(m_buffer.cld_tau_sw_bnd_k)(mem, m_col_chunk_size, m_nlay, m_nswbands);
   mem += m_buffer.cld_tau_sw_bnd_k.size();
-  m_buffer.cld_tau_lw_bnd_k = decltype(m_buffer.cld_tau_lw_bnd_k)(mem, m_col_chunk_size, m_nlay, m_nlwbands);
+  m_buffer.cld_tau_lw_bnd_k =
+      decltype(m_buffer.cld_tau_lw_bnd_k)(mem, m_col_chunk_size, m_nlay, m_nlwbands);
   mem += m_buffer.cld_tau_lw_bnd_k.size();
 #endif
 
@@ -681,15 +736,16 @@ void RRTMGPRadiation::initialize_impl(const RunType /* run_type */) {
   std::string cloud_optics_file_lw = m_params.get<std::string>("rrtmgp_cloud_optics_file_lw");
 #ifdef RRTMGP_ENABLE_YAKL
   m_gas_concs.init(gas_names_yakl_offset, m_col_chunk_size, m_nlay);
-  rrtmgp::rrtmgp_initialize(m_gas_concs, coefficients_file_sw, coefficients_file_lw, cloud_optics_file_sw,
-                            cloud_optics_file_lw, m_atm_logger);
+  rrtmgp::rrtmgp_initialize(m_gas_concs, coefficients_file_sw, coefficients_file_lw,
+                            cloud_optics_file_sw, cloud_optics_file_lw, m_atm_logger);
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
   const double multiplier = m_params.get<double>("pool_size_multiplier", 1.0);
 
   m_gas_concs_k.init(gas_names_yakl_offset, m_col_chunk_size, m_nlay);
-  interface_t::rrtmgp_initialize(m_gas_concs_k, coefficients_file_sw, coefficients_file_lw, cloud_optics_file_sw,
-                                 cloud_optics_file_lw, m_atm_logger, multiplier);
+  interface_t::rrtmgp_initialize(m_gas_concs_k, coefficients_file_sw, coefficients_file_lw,
+                                 cloud_optics_file_sw, cloud_optics_file_lw, m_atm_logger,
+                                 multiplier);
   VALIDATE_KOKKOS(m_gas_concs, m_gas_concs_k);
   VALIDATE_KOKKOS(rrtmgp::k_dist_sw, *interface_t::k_dist_sw_k);
   VALIDATE_KOKKOS(rrtmgp::k_dist_lw, *interface_t::k_dist_lw_k);
@@ -698,7 +754,8 @@ void RRTMGPRadiation::initialize_impl(const RunType /* run_type */) {
 #endif
 
   // Set property checks for fields in this process
-  add_invariant_check<FieldWithinIntervalCheck>(get_field_out("T_mid"), m_grid, 100.0, 500.0, false);
+  add_invariant_check<FieldWithinIntervalCheck>(get_field_out("T_mid"), m_grid, 100.0, 500.0,
+                                                false);
 
   // VMR of n2 and co is currently prescribed as a constant value, read from file
   if (has_computed_field("n2_volume_mix_ratio", m_grid->name())) {
@@ -872,24 +929,25 @@ void RRTMGPRadiation::run_impl(const double dt) {
 
       auto d_vmr = get_field_out(name + "_volume_mix_ratio").get_view<Real **>();
       if (name == "h2o") {
-        // h2o is (wet) mass mixing ratio in FM, otherwise known as "qv", which we've already read in above
-        // Convert to vmr
+        // h2o is (wet) mass mixing ratio in FM, otherwise known as "qv", which we've already read
+        // in above Convert to vmr
         const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(m_ncol, m_nlay);
         Kokkos::parallel_for(
             policy, KOKKOS_LAMBDA(const MemberType &team) {
               const int icol = team.league_rank();
               Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &k) {
-                d_vmr(icol, k) = PF::calculate_vmr_from_mmr(gas_mol_weights[igas], d_qv(icol, k), d_qv(icol, k));
+                d_vmr(icol, k) =
+                    PF::calculate_vmr_from_mmr(gas_mol_weights[igas], d_qv(icol, k), d_qv(icol, k));
               });
             });
         Kokkos::fence();
       } else {
         // This gives (dry) mass mixing ratios
-        scream::physics::trcmix(name, m_nlay, m_lat.get_view<const Real *>(), d_pmid, d_vmr, m_co2vmr, m_n2ovmr,
-                                m_ch4vmr, m_f11vmr, m_f12vmr);
+        scream::physics::trcmix(name, m_nlay, m_lat.get_view<const Real *>(), d_pmid, d_vmr,
+                                m_co2vmr, m_n2ovmr, m_ch4vmr, m_f11vmr, m_f12vmr);
         // Back out volume mixing ratios
         const auto air_mol_weight = PC::MWdry;
-        const auto policy         = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(m_ncol, m_nlay);
+        const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(m_ncol, m_nlay);
         Kokkos::parallel_for(
             policy, KOKKOS_LAMBDA(const MemberType &team) {
               const int i = team.league_rank();
@@ -904,8 +962,8 @@ void RRTMGPRadiation::run_impl(const double dt) {
     for (int ic = 0; ic < m_num_col_chunks; ++ic) {
       const int beg  = m_col_chunk_beg[ic];
       const int ncol = m_col_chunk_beg[ic + 1] - beg;
-      this->log(LogLevel::debug, "[RRTMGP::run_impl] Col chunk beg,end: " + std::to_string(beg) + ", " +
-                                     std::to_string(beg + ncol) + "\n");
+      this->log(LogLevel::debug, "[RRTMGP::run_impl] Col chunk beg,end: " + std::to_string(beg) +
+                                     ", " + std::to_string(beg + ncol) + "\n");
 
       // d_tint and d_dz are used in eamxx calls and therefore
       // must be layout right
@@ -917,8 +975,12 @@ void RRTMGPRadiation::run_impl(const double dt) {
           init_views,
           // Create YAKL arrays. RRTMGP expects YAKL arrays with styleFortran, i.e., data has ncol
           // as the fastest index. For this reason we must copy the data.
-          auto subview_1d = [&](const real1d v) -> real1d { return real1d(v.label(), v.myData, ncol); };
-          auto subview_2d = [&](const real2d v) -> real2d { return real2d(v.label(), v.myData, ncol, v.dimension[1]); };
+          auto subview_1d = [&](const real1d v) -> real1d {
+            return real1d(v.label(), v.myData, ncol);
+          };
+          auto subview_2d = [&](const real2d v) -> real2d {
+            return real2d(v.label(), v.myData, ncol, v.dimension[1]);
+          };
           auto subview_3d = [&](const real3d v) -> real3d {
             return real3d(v.label(), v.myData, ncol, v.dimension[1], v.dimension[2]);
           };
@@ -928,15 +990,19 @@ void RRTMGPRadiation::run_impl(const double dt) {
           auto p_del = subview_2d(m_buffer.p_del); auto t_lev = subview_2d(m_buffer.t_lev);
           auto mu0 = subview_1d(m_buffer.mu0); auto sfc_alb_dir = subview_2d(m_buffer.sfc_alb_dir);
           auto sfc_alb_dif                                      = subview_2d(m_buffer.sfc_alb_dif);
-          auto sfc_alb_dir_vis                                  = subview_1d(m_buffer.sfc_alb_dir_vis);
-          auto sfc_alb_dir_nir                                  = subview_1d(m_buffer.sfc_alb_dir_nir);
-          auto sfc_alb_dif_vis                                  = subview_1d(m_buffer.sfc_alb_dif_vis);
-          auto sfc_alb_dif_nir = subview_1d(m_buffer.sfc_alb_dif_nir); auto qc = subview_2d(m_buffer.qc);
-          auto nc = subview_2d(m_buffer.nc); auto qi = subview_2d(m_buffer.qi);
-          auto cldfrac_tot = subview_2d(m_buffer.cldfrac_tot); auto rel = subview_2d(m_buffer.eff_radius_qc);
-          auto rei = subview_2d(m_buffer.eff_radius_qi); auto sw_flux_up = subview_2d(m_buffer.sw_flux_up);
-          auto sw_flux_dn = subview_2d(m_buffer.sw_flux_dn); auto sw_flux_dn_dir = subview_2d(m_buffer.sw_flux_dn_dir);
-          auto lw_flux_up = subview_2d(m_buffer.lw_flux_up); auto lw_flux_dn = subview_2d(m_buffer.lw_flux_dn);
+          auto sfc_alb_dir_vis = subview_1d(m_buffer.sfc_alb_dir_vis);
+          auto sfc_alb_dir_nir = subview_1d(m_buffer.sfc_alb_dir_nir);
+          auto sfc_alb_dif_vis = subview_1d(m_buffer.sfc_alb_dif_vis);
+          auto sfc_alb_dif_nir = subview_1d(m_buffer.sfc_alb_dif_nir);
+          auto qc = subview_2d(m_buffer.qc); auto nc = subview_2d(m_buffer.nc);
+          auto qi = subview_2d(m_buffer.qi); auto cldfrac_tot = subview_2d(m_buffer.cldfrac_tot);
+          auto rel                                            = subview_2d(m_buffer.eff_radius_qc);
+          auto rei                                            = subview_2d(m_buffer.eff_radius_qi);
+          auto sw_flux_up                                     = subview_2d(m_buffer.sw_flux_up);
+          auto sw_flux_dn                                     = subview_2d(m_buffer.sw_flux_dn);
+          auto sw_flux_dn_dir                                 = subview_2d(m_buffer.sw_flux_dn_dir);
+          auto lw_flux_up                                     = subview_2d(m_buffer.lw_flux_up);
+          auto lw_flux_dn                                     = subview_2d(m_buffer.lw_flux_dn);
           auto sw_clnclrsky_flux_up     = subview_2d(m_buffer.sw_clnclrsky_flux_up);
           auto sw_clnclrsky_flux_dn     = subview_2d(m_buffer.sw_clnclrsky_flux_dn);
           auto sw_clnclrsky_flux_dn_dir = subview_2d(m_buffer.sw_clnclrsky_flux_dn_dir);
@@ -962,12 +1028,14 @@ void RRTMGPRadiation::run_impl(const double dt) {
           auto sfc_flux_dir_nir         = subview_1d(m_buffer.sfc_flux_dir_nir);
           auto sfc_flux_dif_vis         = subview_1d(m_buffer.sfc_flux_dif_vis);
           auto sfc_flux_dif_nir         = subview_1d(m_buffer.sfc_flux_dif_nir);
-          auto aero_tau_sw = subview_3d(m_buffer.aero_tau_sw); auto aero_ssa_sw = subview_3d(m_buffer.aero_ssa_sw);
-          auto aero_g_sw = subview_3d(m_buffer.aero_g_sw); auto aero_tau_lw = subview_3d(m_buffer.aero_tau_lw);
-          auto cld_tau_sw_bnd                                               = subview_3d(m_buffer.cld_tau_sw_bnd);
-          auto cld_tau_lw_bnd                                               = subview_3d(m_buffer.cld_tau_lw_bnd);
-          auto cld_tau_sw_gpt                                               = subview_3d(m_buffer.cld_tau_sw_gpt);
-          auto cld_tau_lw_gpt                                               = subview_3d(m_buffer.cld_tau_lw_gpt););
+          auto aero_tau_sw              = subview_3d(m_buffer.aero_tau_sw);
+          auto aero_ssa_sw              = subview_3d(m_buffer.aero_ssa_sw);
+          auto aero_g_sw                = subview_3d(m_buffer.aero_g_sw);
+          auto aero_tau_lw              = subview_3d(m_buffer.aero_tau_lw);
+          auto cld_tau_sw_bnd           = subview_3d(m_buffer.cld_tau_sw_bnd);
+          auto cld_tau_lw_bnd           = subview_3d(m_buffer.cld_tau_lw_bnd);
+          auto cld_tau_sw_gpt           = subview_3d(m_buffer.cld_tau_sw_gpt);
+          auto cld_tau_lw_gpt           = subview_3d(m_buffer.cld_tau_lw_gpt););
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
       ConvertToRrtmgpSubview conv = {beg, ncol};
@@ -984,55 +1052,68 @@ void RRTMGPRadiation::run_impl(const double dt) {
           auto p_del_k       = conv.subview2d(d_pdel, m_buffer.p_del_k, m_nlay);
           auto t_lev_k       = conv.subview2d(d_tint, m_buffer.t_lev_k, m_nlay + 1);
           auto sfc_alb_dir_k = m_buffer.sfc_alb_dir_k; auto sfc_alb_dif_k = m_buffer.sfc_alb_dif_k;
-          auto sfc_alb_dir_vis_k                                          = conv.subview1d(d_sfc_alb_dir_vis);
-          auto sfc_alb_dir_nir_k                                          = conv.subview1d(d_sfc_alb_dir_nir);
-          auto sfc_alb_dif_vis_k                                          = conv.subview1d(d_sfc_alb_dif_vis);
-          auto sfc_alb_dif_nir_k                                          = conv.subview1d(d_sfc_alb_dif_nir);
-          auto qc_k                                                       = conv.subview2d(d_qc, m_buffer.qc_k, m_nlay);
-          auto nc_k                                                       = conv.subview2d(d_nc, m_buffer.nc_k, m_nlay);
-          auto qi_k = conv.subview2d(d_qi, m_buffer.qi_k, m_nlay); auto cldfrac_tot_k = m_buffer.cldfrac_tot_k;
-          auto rel_k            = conv.subview2d(d_rel, m_buffer.eff_radius_qc_k, m_nlay);
-          auto rei_k            = conv.subview2d(d_rei, m_buffer.eff_radius_qi_k, m_nlay);
-          auto sw_flux_up_k     = conv.subview2d(d_sw_flux_up, m_buffer.sw_flux_up_k, m_nlay + 1);
-          auto sw_flux_dn_k     = conv.subview2d(d_sw_flux_dn, m_buffer.sw_flux_dn_k, m_nlay + 1);
-          auto sw_flux_dn_dir_k = conv.subview2d(d_sw_flux_dn_dir, m_buffer.sw_flux_dn_dir_k, m_nlay + 1);
-          auto lw_flux_up_k     = conv.subview2d(d_lw_flux_up, m_buffer.lw_flux_up_k, m_nlay + 1);
-          auto lw_flux_dn_k     = conv.subview2d(d_lw_flux_dn, m_buffer.lw_flux_dn_k, m_nlay + 1);
+          auto sfc_alb_dir_vis_k = conv.subview1d(d_sfc_alb_dir_vis);
+          auto sfc_alb_dir_nir_k = conv.subview1d(d_sfc_alb_dir_nir);
+          auto sfc_alb_dif_vis_k = conv.subview1d(d_sfc_alb_dif_vis);
+          auto sfc_alb_dif_nir_k = conv.subview1d(d_sfc_alb_dif_nir);
+          auto qc_k              = conv.subview2d(d_qc, m_buffer.qc_k, m_nlay);
+          auto nc_k              = conv.subview2d(d_nc, m_buffer.nc_k, m_nlay);
+          auto qi_k              = conv.subview2d(d_qi, m_buffer.qi_k, m_nlay);
+          auto cldfrac_tot_k     = m_buffer.cldfrac_tot_k;
+          auto rel_k             = conv.subview2d(d_rel, m_buffer.eff_radius_qc_k, m_nlay);
+          auto rei_k             = conv.subview2d(d_rei, m_buffer.eff_radius_qi_k, m_nlay);
+          auto sw_flux_up_k      = conv.subview2d(d_sw_flux_up, m_buffer.sw_flux_up_k, m_nlay + 1);
+          auto sw_flux_dn_k      = conv.subview2d(d_sw_flux_dn, m_buffer.sw_flux_dn_k, m_nlay + 1);
+          auto sw_flux_dn_dir_k =
+              conv.subview2d(d_sw_flux_dn_dir, m_buffer.sw_flux_dn_dir_k, m_nlay + 1);
+          auto lw_flux_up_k = conv.subview2d(d_lw_flux_up, m_buffer.lw_flux_up_k, m_nlay + 1);
+          auto lw_flux_dn_k = conv.subview2d(d_lw_flux_dn, m_buffer.lw_flux_dn_k, m_nlay + 1);
           auto sw_clnclrsky_flux_up_k =
               conv.subview2d(d_sw_clnclrsky_flux_up, m_buffer.sw_clnclrsky_flux_up_k, m_nlay + 1);
           auto sw_clnclrsky_flux_dn_k =
               conv.subview2d(d_sw_clnclrsky_flux_dn, m_buffer.sw_clnclrsky_flux_dn_k, m_nlay + 1);
-          auto sw_clnclrsky_flux_dn_dir_k =
-              conv.subview2d(d_sw_clnclrsky_flux_dn_dir, m_buffer.sw_clnclrsky_flux_dn_dir_k, m_nlay + 1);
-          auto sw_clrsky_flux_up_k = conv.subview2d(d_sw_clrsky_flux_up, m_buffer.sw_clrsky_flux_up_k, m_nlay + 1);
-          auto sw_clrsky_flux_dn_k = conv.subview2d(d_sw_clrsky_flux_dn, m_buffer.sw_clrsky_flux_dn_k, m_nlay + 1);
+          auto sw_clnclrsky_flux_dn_dir_k = conv.subview2d(
+              d_sw_clnclrsky_flux_dn_dir, m_buffer.sw_clnclrsky_flux_dn_dir_k, m_nlay + 1);
+          auto sw_clrsky_flux_up_k =
+              conv.subview2d(d_sw_clrsky_flux_up, m_buffer.sw_clrsky_flux_up_k, m_nlay + 1);
+          auto sw_clrsky_flux_dn_k =
+              conv.subview2d(d_sw_clrsky_flux_dn, m_buffer.sw_clrsky_flux_dn_k, m_nlay + 1);
           auto sw_clrsky_flux_dn_dir_k =
               conv.subview2d(d_sw_clrsky_flux_dn_dir, m_buffer.sw_clrsky_flux_dn_dir_k, m_nlay + 1);
-          auto sw_clnsky_flux_up_k = conv.subview2d(d_sw_clnsky_flux_up, m_buffer.sw_clnsky_flux_up_k, m_nlay + 1);
-          auto sw_clnsky_flux_dn_k = conv.subview2d(d_sw_clnsky_flux_dn, m_buffer.sw_clnsky_flux_dn_k, m_nlay + 1);
+          auto sw_clnsky_flux_up_k =
+              conv.subview2d(d_sw_clnsky_flux_up, m_buffer.sw_clnsky_flux_up_k, m_nlay + 1);
+          auto sw_clnsky_flux_dn_k =
+              conv.subview2d(d_sw_clnsky_flux_dn, m_buffer.sw_clnsky_flux_dn_k, m_nlay + 1);
           auto sw_clnsky_flux_dn_dir_k =
               conv.subview2d(d_sw_clnsky_flux_dn_dir, m_buffer.sw_clnsky_flux_dn_dir_k, m_nlay + 1);
           auto lw_clnclrsky_flux_up_k =
               conv.subview2d(d_lw_clnclrsky_flux_up, m_buffer.lw_clnclrsky_flux_up_k, m_nlay + 1);
           auto lw_clnclrsky_flux_dn_k =
               conv.subview2d(d_lw_clnclrsky_flux_dn, m_buffer.lw_clnclrsky_flux_dn_k, m_nlay + 1);
-          auto lw_clrsky_flux_up_k = conv.subview2d(d_lw_clrsky_flux_up, m_buffer.lw_clrsky_flux_up_k, m_nlay + 1);
-          auto lw_clrsky_flux_dn_k = conv.subview2d(d_lw_clrsky_flux_dn, m_buffer.lw_clrsky_flux_dn_k, m_nlay + 1);
-          auto lw_clnsky_flux_up_k = conv.subview2d(d_lw_clnsky_flux_up, m_buffer.lw_clnsky_flux_up_k, m_nlay + 1);
-          auto lw_clnsky_flux_dn_k = conv.subview2d(d_lw_clnsky_flux_dn, m_buffer.lw_clnsky_flux_dn_k, m_nlay + 1);
-          auto sw_bnd_flux_up_k = m_buffer.sw_bnd_flux_up_k; auto sw_bnd_flux_dn_k = m_buffer.sw_bnd_flux_dn_k;
-          auto sw_bnd_flux_dir_k = m_buffer.sw_bnd_flux_dir_k; auto sw_bnd_flux_dif_k = m_buffer.sw_bnd_flux_dif_k;
-          auto lw_bnd_flux_up_k = m_buffer.lw_bnd_flux_up_k; auto lw_bnd_flux_dn_k = m_buffer.lw_bnd_flux_dn_k;
-          auto sfc_flux_dir_vis_k                                                  = conv.subview1d(d_sfc_flux_dir_vis);
-          auto sfc_flux_dir_nir_k                                                  = conv.subview1d(d_sfc_flux_dir_nir);
-          auto sfc_flux_dif_vis_k                                                  = conv.subview1d(d_sfc_flux_dif_vis);
-          auto sfc_flux_dif_nir_k = conv.subview1d(d_sfc_flux_dif_nir); auto aero_tau_sw_k = m_buffer.aero_tau_sw_k;
-          auto aero_ssa_sw_k = m_buffer.aero_ssa_sw_k; auto aero_g_sw_k = m_buffer.aero_g_sw_k;
-          auto aero_tau_lw_k                                            = m_buffer.aero_tau_lw_k;
-          auto cld_tau_sw_bnd_k                                         = conv.subview3d(m_buffer.cld_tau_sw_bnd_k);
-          auto cld_tau_lw_bnd_k                                         = conv.subview3d(m_buffer.cld_tau_lw_bnd_k);
-          auto cld_tau_sw_gpt_k                                         = conv.subview3d(m_buffer.cld_tau_sw_gpt_k);
-          auto cld_tau_lw_gpt_k                                         = conv.subview3d(m_buffer.cld_tau_lw_gpt_k););
+          auto lw_clrsky_flux_up_k =
+              conv.subview2d(d_lw_clrsky_flux_up, m_buffer.lw_clrsky_flux_up_k, m_nlay + 1);
+          auto lw_clrsky_flux_dn_k =
+              conv.subview2d(d_lw_clrsky_flux_dn, m_buffer.lw_clrsky_flux_dn_k, m_nlay + 1);
+          auto lw_clnsky_flux_up_k =
+              conv.subview2d(d_lw_clnsky_flux_up, m_buffer.lw_clnsky_flux_up_k, m_nlay + 1);
+          auto lw_clnsky_flux_dn_k =
+              conv.subview2d(d_lw_clnsky_flux_dn, m_buffer.lw_clnsky_flux_dn_k, m_nlay + 1);
+          auto sw_bnd_flux_up_k   = m_buffer.sw_bnd_flux_up_k;
+          auto sw_bnd_flux_dn_k   = m_buffer.sw_bnd_flux_dn_k;
+          auto sw_bnd_flux_dir_k  = m_buffer.sw_bnd_flux_dir_k;
+          auto sw_bnd_flux_dif_k  = m_buffer.sw_bnd_flux_dif_k;
+          auto lw_bnd_flux_up_k   = m_buffer.lw_bnd_flux_up_k;
+          auto lw_bnd_flux_dn_k   = m_buffer.lw_bnd_flux_dn_k;
+          auto sfc_flux_dir_vis_k = conv.subview1d(d_sfc_flux_dir_vis);
+          auto sfc_flux_dir_nir_k = conv.subview1d(d_sfc_flux_dir_nir);
+          auto sfc_flux_dif_vis_k = conv.subview1d(d_sfc_flux_dif_vis);
+          auto sfc_flux_dif_nir_k = conv.subview1d(d_sfc_flux_dif_nir);
+          auto aero_tau_sw_k = m_buffer.aero_tau_sw_k; auto aero_ssa_sw_k = m_buffer.aero_ssa_sw_k;
+          auto aero_g_sw_k = m_buffer.aero_g_sw_k; auto aero_tau_lw_k = m_buffer.aero_tau_lw_k;
+          auto cld_tau_sw_bnd_k = conv.subview3d(m_buffer.cld_tau_sw_bnd_k);
+          auto cld_tau_lw_bnd_k = conv.subview3d(m_buffer.cld_tau_lw_bnd_k);
+          auto cld_tau_sw_gpt_k = conv.subview3d(m_buffer.cld_tau_sw_gpt_k);
+          auto cld_tau_lw_gpt_k = conv.subview3d(m_buffer.cld_tau_lw_gpt_k););
 #endif
 
       // Set gas concs to "view" only the first ncol columns
@@ -1066,157 +1147,169 @@ void RRTMGPRadiation::run_impl(const double dt) {
         Kokkos::deep_copy(d_mu0, h_mu0);
 
         const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(ncol, m_nlay);
-        TIMED_KERNEL(Kokkos::parallel_for(
-                         policy, KOKKOS_LAMBDA(const MemberType &team) {
-                           const int i    = team.league_rank();
-                           const int icol = i + beg;
+        TIMED_KERNEL(
+            Kokkos::parallel_for(
+                policy, KOKKOS_LAMBDA(const MemberType &team) {
+                  const int i    = team.league_rank();
+                  const int icol = i + beg;
 
-                           // Calculate dz
-                           const auto pseudo_density = ekat::subview(d_pdel, icol);
-                           const auto p_mid          = ekat::subview(d_pmid, icol);
-                           const auto T_mid          = ekat::subview(d_tmid, icol);
-                           const auto qv             = ekat::subview(d_qv, icol);
-                           const auto dz             = ekat::subview(d_dz, i);
-                           PF::calculate_dz<Real>(team, pseudo_density, p_mid, T_mid, qv, dz);
-                           team.team_barrier();
+                  // Calculate dz
+                  const auto pseudo_density = ekat::subview(d_pdel, icol);
+                  const auto p_mid          = ekat::subview(d_pmid, icol);
+                  const auto T_mid          = ekat::subview(d_tmid, icol);
+                  const auto qv             = ekat::subview(d_qv, icol);
+                  const auto dz             = ekat::subview(d_dz, i);
+                  PF::calculate_dz<Real>(team, pseudo_density, p_mid, T_mid, qv, dz);
+                  team.team_barrier();
 
-                           // Calculate T_int from longwave flux up from the surface, assuming
-                           // blackbody emission with emissivity of 1.
-                           // TODO: Does land model assume something other than emissivity of 1? If so
-                           // we should use that here rather than assuming perfect blackbody emission.
-                           // NOTE: RRTMGP can accept vertical ordering surface to toa, or toa to
-                           // surface. The input data for the standalone test is ordered surface to
-                           // toa, but SCREAM in general assumes data is toa to surface. We account
-                           // for this here by swapping bc_top and bc_bot in the case that the input
-                           // data is ordered surface to toa.
-                           const auto T_int  = ekat::subview(d_tint, i);
-                           const int itop    = (p_mid(0) < p_mid(nlay - 1)) ? 0 : nlay - 1;
-                           const Real bc_top = T_mid(itop);
-                           const Real bc_bot = sqrt(sqrt(d_surf_lw_flux_up(icol) / stebol));
-                           if (itop == 0) {
-                             CO::compute_interface_values_linear(team, nlay, T_mid, dz, bc_top, bc_bot, T_int);
-                           } else {
-                             CO::compute_interface_values_linear(team, nlay, T_mid, dz, bc_bot, bc_top, T_int);
-                           }
-                           team.team_barrier();
+                  // Calculate T_int from longwave flux up from the surface, assuming
+                  // blackbody emission with emissivity of 1.
+                  // TODO: Does land model assume something other than emissivity of 1? If so
+                  // we should use that here rather than assuming perfect blackbody emission.
+                  // NOTE: RRTMGP can accept vertical ordering surface to toa, or toa to
+                  // surface. The input data for the standalone test is ordered surface to
+                  // toa, but SCREAM in general assumes data is toa to surface. We account
+                  // for this here by swapping bc_top and bc_bot in the case that the input
+                  // data is ordered surface to toa.
+                  const auto T_int  = ekat::subview(d_tint, i);
+                  const int itop    = (p_mid(0) < p_mid(nlay - 1)) ? 0 : nlay - 1;
+                  const Real bc_top = T_mid(itop);
+                  const Real bc_bot = sqrt(sqrt(d_surf_lw_flux_up(icol) / stebol));
+                  if (itop == 0) {
+                    CO::compute_interface_values_linear(team, nlay, T_mid, dz, bc_top, bc_bot,
+                                                        T_int);
+                  } else {
+                    CO::compute_interface_values_linear(team, nlay, T_mid, dz, bc_bot, bc_top,
+                                                        T_int);
+                  }
+                  team.team_barrier();
 
 #ifdef RRTMGP_ENABLE_YAKL
-                           mu0(i + 1)             = d_mu0(i);
-                           sfc_alb_dir_vis(i + 1) = d_sfc_alb_dir_vis(icol);
-                           sfc_alb_dir_nir(i + 1) = d_sfc_alb_dir_nir(icol);
-                           sfc_alb_dif_vis(i + 1) = d_sfc_alb_dif_vis(icol);
-                           sfc_alb_dif_nir(i + 1) = d_sfc_alb_dif_nir(icol);
+                  mu0(i + 1)             = d_mu0(i);
+                  sfc_alb_dir_vis(i + 1) = d_sfc_alb_dir_vis(icol);
+                  sfc_alb_dir_nir(i + 1) = d_sfc_alb_dir_nir(icol);
+                  sfc_alb_dif_vis(i + 1) = d_sfc_alb_dif_vis(icol);
+                  sfc_alb_dif_nir(i + 1) = d_sfc_alb_dif_nir(icol);
 
-                           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &k) {
-                             p_lay(i + 1, k + 1) = d_pmid(icol, k);
-                             t_lay(i + 1, k + 1) = d_tmid(icol, k);
-                             z_del(i + 1, k + 1) = d_dz(i, k);
-                             p_del(i + 1, k + 1) = d_pdel(icol, k);
-                             qc(i + 1, k + 1)    = d_qc(icol, k);
-                             nc(i + 1, k + 1)    = d_nc(icol, k);
-                             qi(i + 1, k + 1)    = d_qi(icol, k);
-                             rel(i + 1, k + 1)   = d_rel(icol, k);
-                             rei(i + 1, k + 1)   = d_rei(icol, k);
-                             p_lev(i + 1, k + 1) = d_pint(icol, k);
-                             t_lev(i + 1, k + 1) = d_tint(i, k);
-                           });
+                  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &k) {
+                    p_lay(i + 1, k + 1) = d_pmid(icol, k);
+                    t_lay(i + 1, k + 1) = d_tmid(icol, k);
+                    z_del(i + 1, k + 1) = d_dz(i, k);
+                    p_del(i + 1, k + 1) = d_pdel(icol, k);
+                    qc(i + 1, k + 1)    = d_qc(icol, k);
+                    nc(i + 1, k + 1)    = d_nc(icol, k);
+                    qi(i + 1, k + 1)    = d_qi(icol, k);
+                    rel(i + 1, k + 1)   = d_rel(icol, k);
+                    rei(i + 1, k + 1)   = d_rei(icol, k);
+                    p_lev(i + 1, k + 1) = d_pint(icol, k);
+                    t_lev(i + 1, k + 1) = d_tint(i, k);
+                  });
 
-                           p_lev(i + 1, nlay + 1) = d_pint(icol, nlay);
-                           t_lev(i + 1, nlay + 1) = d_tint(i, nlay);
+                  p_lev(i + 1, nlay + 1) = d_pint(icol, nlay);
+                  t_lev(i + 1, nlay + 1) = d_tint(i, nlay);
 
-                           // Note that RRTMGP expects ordering (col,lay,bnd) but the FM keeps things in (col,bnd,lay)
-                           // order
-                           if (do_aerosol_rad) {
-                             Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nswbands * nlay), [&](const int &idx) {
-                               auto b                           = idx / nlay;
-                               auto k                           = idx % nlay;
-                               aero_tau_sw(i + 1, k + 1, b + 1) = d_aero_tau_sw(icol, b, k);
-                               aero_ssa_sw(i + 1, k + 1, b + 1) = d_aero_ssa_sw(icol, b, k);
-                               aero_g_sw(i + 1, k + 1, b + 1)   = d_aero_g_sw(icol, b, k);
-                             });
-                             Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlwbands * nlay), [&](const int &idx) {
-                               auto b                           = idx / nlay;
-                               auto k                           = idx % nlay;
-                               aero_tau_lw(i + 1, k + 1, b + 1) = d_aero_tau_lw(icol, b, k);
-                             });
-                           } else {
-                             Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nswbands * nlay), [&](const int &idx) {
-                               auto b                           = idx / nlay;
-                               auto k                           = idx % nlay;
-                               aero_tau_sw(i + 1, k + 1, b + 1) = 0;
-                               aero_ssa_sw(i + 1, k + 1, b + 1) = 0;
-                               aero_g_sw(i + 1, k + 1, b + 1)   = 0;
-                             });
-                             Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlwbands * nlay), [&](const int &idx) {
-                               auto b                           = idx / nlay;
-                               auto k                           = idx % nlay;
-                               aero_tau_lw(i + 1, k + 1, b + 1) = 0;
-                             });
-                           }
+                  // Note that RRTMGP expects ordering (col,lay,bnd) but the FM keeps things in
+                  // (col,bnd,lay) order
+                  if (do_aerosol_rad) {
+                    Kokkos::parallel_for(
+                        Kokkos::TeamVectorRange(team, nswbands * nlay), [&](const int &idx) {
+                          auto b                           = idx / nlay;
+                          auto k                           = idx % nlay;
+                          aero_tau_sw(i + 1, k + 1, b + 1) = d_aero_tau_sw(icol, b, k);
+                          aero_ssa_sw(i + 1, k + 1, b + 1) = d_aero_ssa_sw(icol, b, k);
+                          aero_g_sw(i + 1, k + 1, b + 1)   = d_aero_g_sw(icol, b, k);
+                        });
+                    Kokkos::parallel_for(
+                        Kokkos::TeamVectorRange(team, nlwbands * nlay), [&](const int &idx) {
+                          auto b                           = idx / nlay;
+                          auto k                           = idx % nlay;
+                          aero_tau_lw(i + 1, k + 1, b + 1) = d_aero_tau_lw(icol, b, k);
+                        });
+                  } else {
+                    Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nswbands * nlay),
+                                         [&](const int &idx) {
+                                           auto b                           = idx / nlay;
+                                           auto k                           = idx % nlay;
+                                           aero_tau_sw(i + 1, k + 1, b + 1) = 0;
+                                           aero_ssa_sw(i + 1, k + 1, b + 1) = 0;
+                                           aero_g_sw(i + 1, k + 1, b + 1)   = 0;
+                                         });
+                    Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlwbands * nlay),
+                                         [&](const int &idx) {
+                                           auto b                           = idx / nlay;
+                                           auto k                           = idx % nlay;
+                                           aero_tau_lw(i + 1, k + 1, b + 1) = 0;
+                                         });
+                  }
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
 #ifdef RRTMGP_LAYOUT_LEFT
-                           // Copy to layout left buffer views
-                           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &k) {
-                             p_lay_k(i, k) = d_pmid(icol, k);
-                             t_lay_k(i, k) = d_tmid(icol, k);
-                             z_del_k(i, k) = d_dz(i, k);
-                             p_del_k(i, k) = d_pdel(icol, k);
-                             qc_k(i, k)    = d_qc(icol, k);
-                             nc_k(i, k)    = d_nc(icol, k);
-                             qi_k(i, k)    = d_qi(icol, k);
-                             rel_k(i, k)   = d_rel(icol, k);
-                             rei_k(i, k)   = d_rei(icol, k);
-                             p_lev_k(i, k) = d_pint(icol, k);
-                             t_lev_k(i, k) = d_tint(i, k);
-                           });
+                  // Copy to layout left buffer views
+                  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &k) {
+                    p_lay_k(i, k) = d_pmid(icol, k);
+                    t_lay_k(i, k) = d_tmid(icol, k);
+                    z_del_k(i, k) = d_dz(i, k);
+                    p_del_k(i, k) = d_pdel(icol, k);
+                    qc_k(i, k)    = d_qc(icol, k);
+                    nc_k(i, k)    = d_nc(icol, k);
+                    qi_k(i, k)    = d_qi(icol, k);
+                    rel_k(i, k)   = d_rel(icol, k);
+                    rei_k(i, k)   = d_rei(icol, k);
+                    p_lev_k(i, k) = d_pint(icol, k);
+                    t_lev_k(i, k) = d_tint(i, k);
+                  });
 
-                           p_lev_k(i, nlay) = d_pint(icol, nlay);
-                           t_lev_k(i, nlay) = d_tint(i, nlay);
+                  p_lev_k(i, nlay) = d_pint(icol, nlay);
+                  t_lev_k(i, nlay) = d_tint(i, nlay);
 #endif
 
-                           // Note that RRTMGP expects ordering (col,lay,bnd) but the FM keeps things in (col,bnd,lay)
-                           // order
-                           if (do_aerosol_rad) {
-                             Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nswbands * nlay), [&](const int &idx) {
-                               auto b                 = idx / nlay;
-                               auto k                 = idx % nlay;
-                               aero_tau_sw_k(i, k, b) = d_aero_tau_sw(icol, b, k);
-                               aero_ssa_sw_k(i, k, b) = d_aero_ssa_sw(icol, b, k);
-                               aero_g_sw_k(i, k, b)   = d_aero_g_sw(icol, b, k);
-                             });
-                             Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlwbands * nlay), [&](const int &idx) {
-                               auto b                 = idx / nlay;
-                               auto k                 = idx % nlay;
-                               aero_tau_lw_k(i, k, b) = d_aero_tau_lw(icol, b, k);
-                             });
-                           } else {
-                             // cuda complains (in warning only) about these being not allowed...
-                             // Kokkos::deep_copy(aero_tau_sw_k, 0);
-                             // Kokkos::deep_copy(aero_ssa_sw_k, 0);
-                             // Kokkos::deep_copy(aero_g_sw_k  , 0);
-                             // Kokkos::deep_copy(aero_tau_lw_k, 0);
-                             // So, do the manual labor instead:
-                             Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nswbands * nlay), [&](const int &idx) {
-                               auto b                 = idx / nlay;
-                               auto k                 = idx % nlay;
-                               aero_tau_sw_k(i, k, b) = 0.0;
-                               aero_ssa_sw_k(i, k, b) = 0.0;
-                               aero_g_sw_k(i, k, b)   = 0.0;
-                             });
-                             Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlwbands * nlay), [&](const int &idx) {
-                               auto b                 = idx / nlay;
-                               auto k                 = idx % nlay;
-                               aero_tau_lw_k(i, k, b) = 0.0;
-                             });
-                           }
+                  // Note that RRTMGP expects ordering (col,lay,bnd) but the FM keeps things in
+                  // (col,bnd,lay) order
+                  if (do_aerosol_rad) {
+                    Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nswbands * nlay),
+                                         [&](const int &idx) {
+                                           auto b                 = idx / nlay;
+                                           auto k                 = idx % nlay;
+                                           aero_tau_sw_k(i, k, b) = d_aero_tau_sw(icol, b, k);
+                                           aero_ssa_sw_k(i, k, b) = d_aero_ssa_sw(icol, b, k);
+                                           aero_g_sw_k(i, k, b)   = d_aero_g_sw(icol, b, k);
+                                         });
+                    Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlwbands * nlay),
+                                         [&](const int &idx) {
+                                           auto b                 = idx / nlay;
+                                           auto k                 = idx % nlay;
+                                           aero_tau_lw_k(i, k, b) = d_aero_tau_lw(icol, b, k);
+                                         });
+                  } else {
+                    // cuda complains (in warning only) about these being not allowed...
+                    // Kokkos::deep_copy(aero_tau_sw_k, 0);
+                    // Kokkos::deep_copy(aero_ssa_sw_k, 0);
+                    // Kokkos::deep_copy(aero_g_sw_k  , 0);
+                    // Kokkos::deep_copy(aero_tau_lw_k, 0);
+                    // So, do the manual labor instead:
+                    Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nswbands * nlay),
+                                         [&](const int &idx) {
+                                           auto b                 = idx / nlay;
+                                           auto k                 = idx % nlay;
+                                           aero_tau_sw_k(i, k, b) = 0.0;
+                                           aero_ssa_sw_k(i, k, b) = 0.0;
+                                           aero_g_sw_k(i, k, b)   = 0.0;
+                                         });
+                    Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlwbands * nlay),
+                                         [&](const int &idx) {
+                                           auto b                 = idx / nlay;
+                                           auto k                 = idx % nlay;
+                                           aero_tau_lw_k(i, k, b) = 0.0;
+                                         });
+                  }
 #endif
-                         }););
+                }););
       }
       Kokkos::fence();
 #ifdef RRTMGP_ENABLE_KOKKOS
-      COMPARE_ALL_WRAP(std::vector<real3d>({aero_tau_sw, aero_ssa_sw, aero_g_sw, aero_tau_lw}),
-                       std::vector<real3dk>({aero_tau_sw_k, aero_ssa_sw_k, aero_g_sw_k, aero_tau_lw_k}));
+      COMPARE_ALL_WRAP(
+          std::vector<real3d>({aero_tau_sw, aero_ssa_sw, aero_g_sw, aero_tau_lw}),
+          std::vector<real3dk>({aero_tau_sw_k, aero_ssa_sw_k, aero_g_sw_k, aero_tau_lw_k}));
 #endif
 
       // Populate GasConcs object to pass to RRTMGP driver
@@ -1245,7 +1338,8 @@ void RRTMGPRadiation::run_impl(const double dt) {
               const int i    = team.league_rank();
               const int icol = i + beg;
               Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &k) {
-                tmp2d(i + 1, k + 1) = d_vmr(icol, k); // Note that for YAKL arrays i and k start with index 1
+                tmp2d(i + 1, k + 1) =
+                    d_vmr(icol, k); // Note that for YAKL arrays i and k start with index 1
               });
             });
         Kokkos::fence();
@@ -1361,14 +1455,14 @@ void RRTMGPRadiation::run_impl(const double dt) {
       // Compute band-by-band surface_albedos. This is needed since
       // the AD passes broadband albedos, but rrtmgp require band-by-band.
 #ifdef RRTMGP_ENABLE_YAKL
-      TIMED_KERNEL(rrtmgp::compute_band_by_band_surface_albedos(ncol, nswbands, sfc_alb_dir_vis, sfc_alb_dir_nir,
-                                                                sfc_alb_dif_vis, sfc_alb_dif_nir, sfc_alb_dir,
-                                                                sfc_alb_dif););
+      TIMED_KERNEL(rrtmgp::compute_band_by_band_surface_albedos(
+                       ncol, nswbands, sfc_alb_dir_vis, sfc_alb_dir_nir, sfc_alb_dif_vis,
+                       sfc_alb_dif_nir, sfc_alb_dir, sfc_alb_dif););
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
-      TIMED_KERNEL(interface_t::compute_band_by_band_surface_albedos(ncol, nswbands, sfc_alb_dir_vis_k,
-                                                                     sfc_alb_dir_nir_k, sfc_alb_dif_vis_k,
-                                                                     sfc_alb_dif_nir_k, sfc_alb_dir_k, sfc_alb_dif_k););
+      TIMED_KERNEL(interface_t::compute_band_by_band_surface_albedos(
+                       ncol, nswbands, sfc_alb_dir_vis_k, sfc_alb_dir_nir_k, sfc_alb_dif_vis_k,
+                       sfc_alb_dif_nir_k, sfc_alb_dir_k, sfc_alb_dif_k););
       COMPARE_ALL_WRAP(std::vector<real2d>({sfc_alb_dir, sfc_alb_dif}),
                        std::vector<real2dk>({sfc_alb_dir_k, sfc_alb_dif_k}));
 #endif
@@ -1377,28 +1471,32 @@ void RRTMGPRadiation::run_impl(const double dt) {
       // Run RRTMGP driver
 #ifdef RRTMGP_ENABLE_YAKL
       TIMED_KERNEL(
-          rrtmgp::rrtmgp_main(ncol, m_nlay, p_lay, t_lay, p_lev, t_lev, m_gas_concs, sfc_alb_dir, sfc_alb_dif, mu0, lwp,
-                              iwp, rel, rei, cldfrac_tot, aero_tau_sw, aero_ssa_sw, aero_g_sw, aero_tau_lw,
-                              cld_tau_sw_bnd, cld_tau_lw_bnd, cld_tau_sw_gpt, cld_tau_lw_gpt, sw_flux_up, sw_flux_dn,
-                              sw_flux_dn_dir, lw_flux_up, lw_flux_dn, sw_clnclrsky_flux_up, sw_clnclrsky_flux_dn,
-                              sw_clnclrsky_flux_dn_dir, sw_clrsky_flux_up, sw_clrsky_flux_dn, sw_clrsky_flux_dn_dir,
-                              sw_clnsky_flux_up, sw_clnsky_flux_dn, sw_clnsky_flux_dn_dir, lw_clnclrsky_flux_up,
-                              lw_clnclrsky_flux_dn, lw_clrsky_flux_up, lw_clrsky_flux_dn, lw_clnsky_flux_up,
-                              lw_clnsky_flux_dn, sw_bnd_flux_up, sw_bnd_flux_dn, sw_bnd_flux_dir, lw_bnd_flux_up,
-                              lw_bnd_flux_dn, eccf, m_atm_logger, m_extra_clnclrsky_diag, m_extra_clnsky_diag););
+          rrtmgp::rrtmgp_main(
+              ncol, m_nlay, p_lay, t_lay, p_lev, t_lev, m_gas_concs, sfc_alb_dir, sfc_alb_dif, mu0,
+              lwp, iwp, rel, rei, cldfrac_tot, aero_tau_sw, aero_ssa_sw, aero_g_sw, aero_tau_lw,
+              cld_tau_sw_bnd, cld_tau_lw_bnd, cld_tau_sw_gpt, cld_tau_lw_gpt, sw_flux_up,
+              sw_flux_dn, sw_flux_dn_dir, lw_flux_up, lw_flux_dn, sw_clnclrsky_flux_up,
+              sw_clnclrsky_flux_dn, sw_clnclrsky_flux_dn_dir, sw_clrsky_flux_up, sw_clrsky_flux_dn,
+              sw_clrsky_flux_dn_dir, sw_clnsky_flux_up, sw_clnsky_flux_dn, sw_clnsky_flux_dn_dir,
+              lw_clnclrsky_flux_up, lw_clnclrsky_flux_dn, lw_clrsky_flux_up, lw_clrsky_flux_dn,
+              lw_clnsky_flux_up, lw_clnsky_flux_dn, sw_bnd_flux_up, sw_bnd_flux_dn, sw_bnd_flux_dir,
+              lw_bnd_flux_up, lw_bnd_flux_dn, eccf, m_atm_logger, m_extra_clnclrsky_diag,
+              m_extra_clnsky_diag););
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
-      TIMED_KERNEL(interface_t::rrtmgp_main(
-                       ncol, m_nlay, p_lay_k, t_lay_k, p_lev_k, t_lev_k, m_gas_concs_k, sfc_alb_dir_k, sfc_alb_dif_k,
-                       d_mu0, lwp_k, iwp_k, rel_k, rei_k, cldfrac_tot_k, aero_tau_sw_k, aero_ssa_sw_k, aero_g_sw_k,
-                       aero_tau_lw_k, cld_tau_sw_bnd_k, cld_tau_lw_bnd_k, cld_tau_sw_gpt_k, cld_tau_lw_gpt_k,
-                       sw_flux_up_k, sw_flux_dn_k, sw_flux_dn_dir_k, lw_flux_up_k, lw_flux_dn_k, sw_clnclrsky_flux_up_k,
-                       sw_clnclrsky_flux_dn_k, sw_clnclrsky_flux_dn_dir_k, sw_clrsky_flux_up_k, sw_clrsky_flux_dn_k,
-                       sw_clrsky_flux_dn_dir_k, sw_clnsky_flux_up_k, sw_clnsky_flux_dn_k, sw_clnsky_flux_dn_dir_k,
-                       lw_clnclrsky_flux_up_k, lw_clnclrsky_flux_dn_k, lw_clrsky_flux_up_k, lw_clrsky_flux_dn_k,
-                       lw_clnsky_flux_up_k, lw_clnsky_flux_dn_k, sw_bnd_flux_up_k, sw_bnd_flux_dn_k, sw_bnd_flux_dir_k,
-                       lw_bnd_flux_up_k, lw_bnd_flux_dn_k, eccf, m_atm_logger, m_extra_clnclrsky_diag,
-                       m_extra_clnsky_diag););
+      TIMED_KERNEL(
+          interface_t::rrtmgp_main(
+              ncol, m_nlay, p_lay_k, t_lay_k, p_lev_k, t_lev_k, m_gas_concs_k, sfc_alb_dir_k,
+              sfc_alb_dif_k, d_mu0, lwp_k, iwp_k, rel_k, rei_k, cldfrac_tot_k, aero_tau_sw_k,
+              aero_ssa_sw_k, aero_g_sw_k, aero_tau_lw_k, cld_tau_sw_bnd_k, cld_tau_lw_bnd_k,
+              cld_tau_sw_gpt_k, cld_tau_lw_gpt_k, sw_flux_up_k, sw_flux_dn_k, sw_flux_dn_dir_k,
+              lw_flux_up_k, lw_flux_dn_k, sw_clnclrsky_flux_up_k, sw_clnclrsky_flux_dn_k,
+              sw_clnclrsky_flux_dn_dir_k, sw_clrsky_flux_up_k, sw_clrsky_flux_dn_k,
+              sw_clrsky_flux_dn_dir_k, sw_clnsky_flux_up_k, sw_clnsky_flux_dn_k,
+              sw_clnsky_flux_dn_dir_k, lw_clnclrsky_flux_up_k, lw_clnclrsky_flux_dn_k,
+              lw_clrsky_flux_up_k, lw_clrsky_flux_dn_k, lw_clnsky_flux_up_k, lw_clnsky_flux_dn_k,
+              sw_bnd_flux_up_k, sw_bnd_flux_dn_k, sw_bnd_flux_dir_k, lw_bnd_flux_up_k,
+              lw_bnd_flux_dn_k, eccf, m_atm_logger, m_extra_clnclrsky_diag, m_extra_clnsky_diag););
       COMPARE_ALL_WRAP(std::vector<real2d>({sw_flux_up,
                                             sw_flux_dn,
                                             sw_flux_dn_dir,
@@ -1439,45 +1537,51 @@ void RRTMGPRadiation::run_impl(const double dt) {
                                              lw_clrsky_flux_dn_k,
                                              lw_clnsky_flux_up_k,
                                              lw_clnsky_flux_dn_k}));
-      COMPARE_ALL_WRAP(
-          std::vector<real3d>({sw_bnd_flux_up, sw_bnd_flux_dn, sw_bnd_flux_dir, lw_bnd_flux_up, lw_bnd_flux_dn}),
-          std::vector<real3dk>(
-              {sw_bnd_flux_up_k, sw_bnd_flux_dn_k, sw_bnd_flux_dir_k, lw_bnd_flux_up_k, lw_bnd_flux_dn_k}));
+      COMPARE_ALL_WRAP(std::vector<real3d>({sw_bnd_flux_up, sw_bnd_flux_dn, sw_bnd_flux_dir,
+                                            lw_bnd_flux_up, lw_bnd_flux_dn}),
+                       std::vector<real3dk>({sw_bnd_flux_up_k, sw_bnd_flux_dn_k, sw_bnd_flux_dir_k,
+                                             lw_bnd_flux_up_k, lw_bnd_flux_dn_k}));
 #endif
 
       // Update heating tendency
 #ifdef RRTMGP_ENABLE_YAKL
       TIMED_INLINE_KERNEL(
-          heating_tendency, auto sw_heating = m_buffer.sw_heating; auto lw_heating = m_buffer.lw_heating;
+          heating_tendency, auto sw_heating = m_buffer.sw_heating;
+          auto lw_heating = m_buffer.lw_heating;
           rrtmgp::compute_heating_rate(sw_flux_up, sw_flux_dn, p_del, sw_heating);
           rrtmgp::compute_heating_rate(lw_flux_up, lw_flux_dn, p_del, lw_heating); {
-            const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(ncol, m_nlay);
+            const auto policy =
+                ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(ncol, m_nlay);
             Kokkos::parallel_for(
                 policy, KOKKOS_LAMBDA(const MemberType &team) {
                   const int idx  = team.league_rank();
                   const int icol = idx + beg;
                   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &ilay) {
-                    // Combine SW and LW heating into a net heating tendency; use d_rad_heating_pdel temporarily
-                    // Note that for YAKL arrays i and k start with index 1
-                    d_rad_heating_pdel(icol, ilay) = sw_heating(idx + 1, ilay + 1) + lw_heating(idx + 1, ilay + 1);
+                    // Combine SW and LW heating into a net heating tendency; use d_rad_heating_pdel
+                    // temporarily Note that for YAKL arrays i and k start with index 1
+                    d_rad_heating_pdel(icol, ilay) =
+                        sw_heating(idx + 1, ilay + 1) + lw_heating(idx + 1, ilay + 1);
                   });
                 });
           } Kokkos::fence(););
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
       TIMED_INLINE_KERNEL(
-          heating_tendency, auto sw_heating_k = m_buffer.sw_heating_k; auto lw_heating_k = m_buffer.lw_heating_k;
+          heating_tendency, auto sw_heating_k = m_buffer.sw_heating_k;
+          auto lw_heating_k = m_buffer.lw_heating_k;
           rrtmgp::compute_heating_rate(sw_flux_up_k, sw_flux_dn_k, p_del_k, sw_heating_k);
           rrtmgp::compute_heating_rate(lw_flux_up_k, lw_flux_dn_k, p_del_k, lw_heating_k); {
-            const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(ncol, m_nlay);
+            const auto policy =
+                ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(ncol, m_nlay);
             Kokkos::parallel_for(
                 policy, KOKKOS_LAMBDA(const MemberType &team) {
                   const int idx  = team.league_rank();
                   const int icol = idx + beg;
                   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &ilay) {
-                    // Combine SW and LW heating into a net heating tendency; use d_rad_heating_pdel temporarily
-                    // Note that for YAKL arrays i and k start with index 1
-                    d_rad_heating_pdel(icol, ilay) = sw_heating_k(idx, ilay) + lw_heating_k(idx, ilay);
+                    // Combine SW and LW heating into a net heating tendency; use d_rad_heating_pdel
+                    // temporarily Note that for YAKL arrays i and k start with index 1
+                    d_rad_heating_pdel(icol, ilay) =
+                        sw_heating_k(idx, ilay) + lw_heating_k(idx, ilay);
                   });
                 });
           } Kokkos::fence(););
@@ -1494,7 +1598,8 @@ void RRTMGPRadiation::run_impl(const double dt) {
           Kokkos::parallel_for(
               Kokkos::RangePolicy<ExeSpace>(0, nswbands * (nlay + 1) * ncol),
               KOKKOS_LAMBDA(const int idx) {
-                // CAREFUL: these are YAKL arrays, with "LayoutLeft". So make the indices stride accordingly, and add 1.
+                // CAREFUL: these are YAKL arrays, with "LayoutLeft". So make the indices stride
+                // accordingly, and add 1.
                 const int ibnd = (idx / ncol) / (nlay + 1) + 1;
                 const int ilev = (idx / ncol) % (nlay + 1) + 1;
                 const int icol = idx % ncol + 1;
@@ -1502,9 +1607,9 @@ void RRTMGPRadiation::run_impl(const double dt) {
                     sw_bnd_flux_dn(icol, ilev, ibnd) - sw_bnd_flux_dir(icol, ilev, ibnd);
               });
           // Compute surface fluxes
-          rrtmgp::compute_broadband_surface_fluxes(ncol, kbot, nswbands, sw_bnd_flux_dir, sw_bnd_flux_dif,
-                                                   sfc_flux_dir_vis, sfc_flux_dir_nir, sfc_flux_dif_vis,
-                                                   sfc_flux_dif_nir););
+          rrtmgp::compute_broadband_surface_fluxes(
+              ncol, kbot, nswbands, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis,
+              sfc_flux_dir_nir, sfc_flux_dif_vis, sfc_flux_dif_nir););
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
       const int kbot_k = nlay;
@@ -1514,7 +1619,8 @@ void RRTMGPRadiation::run_impl(const double dt) {
           Kokkos::parallel_for(
               Kokkos::RangePolicy<ExeSpace>(0, nswbands * (nlay + 1) * ncol),
               KOKKOS_LAMBDA(const int idx) {
-                // CAREFUL: these are YAKL arrays, with "LayoutLeft". So make the indices stride accordingly, and add 1.
+                // CAREFUL: these are YAKL arrays, with "LayoutLeft". So make the indices stride
+                // accordingly, and add 1.
                 const int ibnd = (idx / ncol) / (nlay + 1);
                 const int ilev = (idx / ncol) % (nlay + 1);
                 const int icol = idx % ncol;
@@ -1522,51 +1628,59 @@ void RRTMGPRadiation::run_impl(const double dt) {
                     sw_bnd_flux_dn_k(icol, ilev, ibnd) - sw_bnd_flux_dir_k(icol, ilev, ibnd);
               });
           // Compute surface fluxes
-          interface_t::compute_broadband_surface_fluxes(ncol, kbot_k, nswbands, sw_bnd_flux_dir_k, sw_bnd_flux_dif_k,
-                                                        sfc_flux_dir_vis_k, sfc_flux_dir_nir_k, sfc_flux_dif_vis_k,
-                                                        sfc_flux_dif_nir_k););
-      COMPARE_ALL_WRAP(
-          std::vector<real1d>({sfc_flux_dir_vis, sfc_flux_dir_nir, sfc_flux_dif_vis, sfc_flux_dif_nir}),
-          std::vector<real1dk>({sfc_flux_dir_vis_k, sfc_flux_dir_nir_k, sfc_flux_dif_vis_k, sfc_flux_dif_nir_k}));
+          interface_t::compute_broadband_surface_fluxes(
+              ncol, kbot_k, nswbands, sw_bnd_flux_dir_k, sw_bnd_flux_dif_k, sfc_flux_dir_vis_k,
+              sfc_flux_dir_nir_k, sfc_flux_dif_vis_k, sfc_flux_dif_nir_k););
+      COMPARE_ALL_WRAP(std::vector<real1d>({sfc_flux_dir_vis, sfc_flux_dir_nir, sfc_flux_dif_vis,
+                                            sfc_flux_dif_nir}),
+                       std::vector<real1dk>({sfc_flux_dir_vis_k, sfc_flux_dir_nir_k,
+                                             sfc_flux_dif_vis_k, sfc_flux_dif_nir_k}));
 #endif
 
       // Compute diagnostic total cloud area (vertically-projected cloud cover)
 #ifdef RRTMGP_ENABLE_YAKL
-      TIMED_KERNEL(real1d cldlow("cldlow", d_cldlow.data() + m_col_chunk_beg[ic], ncol);
-                   real1d cldmed("cldmed", d_cldmed.data() + m_col_chunk_beg[ic], ncol);
-                   real1d cldhgh("cldhgh", d_cldhgh.data() + m_col_chunk_beg[ic], ncol);
-                   real1d cldtot("cldtot", d_cldtot.data() + m_col_chunk_beg[ic], ncol);
-                   // NOTE: limits for low, mid, and high clouds are mostly taken from EAM F90 source, with the
-                   // exception that I removed the restriction on low clouds to be above (numerically lower pressures)
-                   // 1200 hPa, and on high clouds to be below (numerically high pressures) 50 hPa. This probably
-                   // does not matter in practice, as clouds probably should not be produced above 50 hPa and we
-                   // should not be encountering surface pressure above 1200 hPa, but in the event that things go off
-                   // the rails we might want to look at these still.
-                   rrtmgp::compute_cloud_area(ncol, nlay, nlwgpts, 700e2, std::numeric_limits<Real>::max(), p_lay,
-                                              cld_tau_lw_gpt, cldlow);
-                   rrtmgp::compute_cloud_area(ncol, nlay, nlwgpts, 400e2, 700e2, p_lay, cld_tau_lw_gpt, cldmed);
-                   rrtmgp::compute_cloud_area(ncol, nlay, nlwgpts, 0, 400e2, p_lay, cld_tau_lw_gpt, cldhgh);
-                   rrtmgp::compute_cloud_area(ncol, nlay, nlwgpts, 0, std::numeric_limits<Real>::max(), p_lay,
-                                              cld_tau_lw_gpt, cldtot););
+      TIMED_KERNEL(
+          real1d cldlow("cldlow", d_cldlow.data() + m_col_chunk_beg[ic], ncol);
+          real1d cldmed("cldmed", d_cldmed.data() + m_col_chunk_beg[ic], ncol);
+          real1d cldhgh("cldhgh", d_cldhgh.data() + m_col_chunk_beg[ic], ncol);
+          real1d cldtot("cldtot", d_cldtot.data() + m_col_chunk_beg[ic], ncol);
+          // NOTE: limits for low, mid, and high clouds are mostly taken from EAM F90 source, with
+          // the exception that I removed the restriction on low clouds to be above (numerically
+          // lower pressures) 1200 hPa, and on high clouds to be below (numerically high pressures)
+          // 50 hPa. This probably does not matter in practice, as clouds probably should not be
+          // produced above 50 hPa and we should not be encountering surface pressure above 1200
+          // hPa, but in the event that things go off the rails we might want to look at these
+          // still.
+          rrtmgp::compute_cloud_area(ncol, nlay, nlwgpts, 700e2, std::numeric_limits<Real>::max(),
+                                     p_lay, cld_tau_lw_gpt, cldlow);
+          rrtmgp::compute_cloud_area(ncol, nlay, nlwgpts, 400e2, 700e2, p_lay, cld_tau_lw_gpt,
+                                     cldmed);
+          rrtmgp::compute_cloud_area(ncol, nlay, nlwgpts, 0, 400e2, p_lay, cld_tau_lw_gpt, cldhgh);
+          rrtmgp::compute_cloud_area(ncol, nlay, nlwgpts, 0, std::numeric_limits<Real>::max(),
+                                     p_lay, cld_tau_lw_gpt, cldtot););
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
-      TIMED_KERNEL(
-          real1dk cldlow_k(d_cldlow.data() + m_col_chunk_beg[ic], ncol);
-          real1dk cldmed_k(d_cldmed.data() + m_col_chunk_beg[ic], ncol);
-          real1dk cldhgh_k(d_cldhgh.data() + m_col_chunk_beg[ic], ncol);
-          real1dk cldtot_k(d_cldtot.data() + m_col_chunk_beg[ic], ncol);
-          // NOTE: limits for low, mid, and high clouds are mostly taken from EAM F90 source, with the
-          // exception that I removed the restriction on low clouds to be above (numerically lower pressures)
-          // 1200 hPa, and on high clouds to be below (numerically high pressures) 50 hPa. This probably
-          // does not matter in practice, as clouds probably should not be produced above 50 hPa and we
-          // should not be encountering surface pressure above 1200 hPa, but in the event that things go off
-          // the rails we might want to look at these still.
-          interface_t::compute_cloud_area(ncol, nlay, nlwgpts, 700e2, std::numeric_limits<Real>::max(), p_lay_k,
-                                          cld_tau_lw_gpt_k, cldlow_k);
-          interface_t::compute_cloud_area(ncol, nlay, nlwgpts, 400e2, 700e2, p_lay_k, cld_tau_lw_gpt_k, cldmed_k);
-          interface_t::compute_cloud_area(ncol, nlay, nlwgpts, 0, 400e2, p_lay_k, cld_tau_lw_gpt_k, cldhgh_k);
-          interface_t::compute_cloud_area(ncol, nlay, nlwgpts, 0, std::numeric_limits<Real>::max(), p_lay_k,
-                                          cld_tau_lw_gpt_k, cldtot_k););
+      TIMED_KERNEL(real1dk cldlow_k(d_cldlow.data() + m_col_chunk_beg[ic], ncol);
+                   real1dk cldmed_k(d_cldmed.data() + m_col_chunk_beg[ic], ncol);
+                   real1dk cldhgh_k(d_cldhgh.data() + m_col_chunk_beg[ic], ncol);
+                   real1dk cldtot_k(d_cldtot.data() + m_col_chunk_beg[ic], ncol);
+                   // NOTE: limits for low, mid, and high clouds are mostly taken from EAM F90
+                   // source, with the exception that I removed the restriction on low clouds to be
+                   // above (numerically lower pressures) 1200 hPa, and on high clouds to be below
+                   // (numerically high pressures) 50 hPa. This probably does not matter in
+                   // practice, as clouds probably should not be produced above 50 hPa and we should
+                   // not be encountering surface pressure above 1200 hPa, but in the event that
+                   // things go off the rails we might want to look at these still.
+                   interface_t::compute_cloud_area(ncol, nlay, nlwgpts, 700e2,
+                                                   std::numeric_limits<Real>::max(), p_lay_k,
+                                                   cld_tau_lw_gpt_k, cldlow_k);
+                   interface_t::compute_cloud_area(ncol, nlay, nlwgpts, 400e2, 700e2, p_lay_k,
+                                                   cld_tau_lw_gpt_k, cldmed_k);
+                   interface_t::compute_cloud_area(ncol, nlay, nlwgpts, 0, 400e2, p_lay_k,
+                                                   cld_tau_lw_gpt_k, cldhgh_k);
+                   interface_t::compute_cloud_area(ncol, nlay, nlwgpts, 0,
+                                                   std::numeric_limits<Real>::max(), p_lay_k,
+                                                   cld_tau_lw_gpt_k, cldtot_k););
       COMPARE_ALL_WRAP(std::vector<real1d>({cldlow, cldmed, cldhgh, cldtot}),
                        std::vector<real1dk>({cldlow_k, cldmed_k, cldhgh_k, cldtot_k}));
 #endif
@@ -1582,23 +1696,29 @@ void RRTMGPRadiation::run_impl(const double dt) {
           auto idx_105 = rrtmgp::get_wavelength_index_lw(10.5e-6);
 
           // Compute cloud-top diagnostics following AeroCom recommendation
-          real1d T_mid_at_cldtop("T_mid_at_cldtop", d_T_mid_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
-          real1d p_mid_at_cldtop("p_mid_at_cldtop", d_p_mid_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
-          real1d cldfrac_ice_at_cldtop("cldfrac_ice_at_cldtop", d_cldfrac_ice_at_cldtop.data() + m_col_chunk_beg[ic],
-                                       ncol);
-          real1d cldfrac_liq_at_cldtop("cldfrac_liq_at_cldtop", d_cldfrac_liq_at_cldtop.data() + m_col_chunk_beg[ic],
-                                       ncol);
-          real1d cldfrac_tot_at_cldtop("cldfrac_tot_at_cldtop", d_cldfrac_tot_at_cldtop.data() + m_col_chunk_beg[ic],
-                                       ncol);
-          real1d cdnc_at_cldtop("cdnc_at_cldtop", d_cdnc_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
+          real1d T_mid_at_cldtop("T_mid_at_cldtop", d_T_mid_at_cldtop.data() + m_col_chunk_beg[ic],
+                                 ncol);
+          real1d p_mid_at_cldtop("p_mid_at_cldtop", d_p_mid_at_cldtop.data() + m_col_chunk_beg[ic],
+                                 ncol);
+          real1d cldfrac_ice_at_cldtop("cldfrac_ice_at_cldtop",
+                                       d_cldfrac_ice_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
+          real1d cldfrac_liq_at_cldtop("cldfrac_liq_at_cldtop",
+                                       d_cldfrac_liq_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
+          real1d cldfrac_tot_at_cldtop("cldfrac_tot_at_cldtop",
+                                       d_cldfrac_tot_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
+          real1d cdnc_at_cldtop("cdnc_at_cldtop", d_cdnc_at_cldtop.data() + m_col_chunk_beg[ic],
+                                ncol);
           real1d eff_radius_qc_at_cldtop("eff_radius_qc_at_cldtop",
-                                         d_eff_radius_qc_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
+                                         d_eff_radius_qc_at_cldtop.data() + m_col_chunk_beg[ic],
+                                         ncol);
           real1d eff_radius_qi_at_cldtop("eff_radius_qi_at_cldtop",
-                                         d_eff_radius_qi_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
+                                         d_eff_radius_qi_at_cldtop.data() + m_col_chunk_beg[ic],
+                                         ncol);
 
-          rrtmgp::compute_aerocom_cloudtop(ncol, nlay, t_lay, p_lay, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                           T_mid_at_cldtop, p_mid_at_cldtop, cldfrac_ice_at_cldtop,
-                                           cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop, cdnc_at_cldtop,
+          rrtmgp::compute_aerocom_cloudtop(ncol, nlay, t_lay, p_lay, p_del, z_del, qc, qi, rel, rei,
+                                           cldfrac_tot, nc, T_mid_at_cldtop, p_mid_at_cldtop,
+                                           cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
+                                           cldfrac_tot_at_cldtop, cdnc_at_cldtop,
                                            eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop););
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
@@ -1611,115 +1731,124 @@ void RRTMGPRadiation::run_impl(const double dt) {
 
           real1dk T_mid_at_cldtop_k(d_T_mid_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
           real1dk p_mid_at_cldtop_k(d_p_mid_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
-          real1dk cldfrac_ice_at_cldtop_k(d_cldfrac_ice_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
-          real1dk cldfrac_liq_at_cldtop_k(d_cldfrac_liq_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
-          real1dk cldfrac_tot_at_cldtop_k(d_cldfrac_tot_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
+          real1dk cldfrac_ice_at_cldtop_k(d_cldfrac_ice_at_cldtop.data() + m_col_chunk_beg[ic],
+                                          ncol);
+          real1dk cldfrac_liq_at_cldtop_k(d_cldfrac_liq_at_cldtop.data() + m_col_chunk_beg[ic],
+                                          ncol);
+          real1dk cldfrac_tot_at_cldtop_k(d_cldfrac_tot_at_cldtop.data() + m_col_chunk_beg[ic],
+                                          ncol);
           real1dk cdnc_at_cldtop_k(d_cdnc_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
-          real1dk eff_radius_qc_at_cldtop_k(d_eff_radius_qc_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
-          real1dk eff_radius_qi_at_cldtop_k(d_eff_radius_qi_at_cldtop.data() + m_col_chunk_beg[ic], ncol);
+          real1dk eff_radius_qc_at_cldtop_k(d_eff_radius_qc_at_cldtop.data() + m_col_chunk_beg[ic],
+                                            ncol);
+          real1dk eff_radius_qi_at_cldtop_k(d_eff_radius_qi_at_cldtop.data() + m_col_chunk_beg[ic],
+                                            ncol);
 
           interface_t::compute_aerocom_cloudtop(
-              ncol, nlay, t_lay_k, p_lay_k, p_del_k, z_del_k, qc_k, qi_k, rel_k, rei_k, cldfrac_tot_k, nc_k,
-              T_mid_at_cldtop_k, p_mid_at_cldtop_k, cldfrac_ice_at_cldtop_k, cldfrac_liq_at_cldtop_k,
-              cldfrac_tot_at_cldtop_k, cdnc_at_cldtop_k, eff_radius_qc_at_cldtop_k, eff_radius_qi_at_cldtop_k););
-      COMPARE_ALL_WRAP(std::vector<real1d>({T_mid_at_cldtop, p_mid_at_cldtop, cldfrac_ice_at_cldtop,
-                                            cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop, cdnc_at_cldtop,
-                                            eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop}),
-                       std::vector<real1dk>({T_mid_at_cldtop_k, p_mid_at_cldtop_k, cldfrac_ice_at_cldtop_k,
-                                             cldfrac_liq_at_cldtop_k, cldfrac_tot_at_cldtop_k, cdnc_at_cldtop_k,
-                                             eff_radius_qc_at_cldtop_k, eff_radius_qi_at_cldtop_k}));
+              ncol, nlay, t_lay_k, p_lay_k, p_del_k, z_del_k, qc_k, qi_k, rel_k, rei_k,
+              cldfrac_tot_k, nc_k, T_mid_at_cldtop_k, p_mid_at_cldtop_k, cldfrac_ice_at_cldtop_k,
+              cldfrac_liq_at_cldtop_k, cldfrac_tot_at_cldtop_k, cdnc_at_cldtop_k,
+              eff_radius_qc_at_cldtop_k, eff_radius_qi_at_cldtop_k););
+      COMPARE_ALL_WRAP(
+          std::vector<real1d>({T_mid_at_cldtop, p_mid_at_cldtop, cldfrac_ice_at_cldtop,
+                               cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop, cdnc_at_cldtop,
+                               eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop}),
+          std::vector<real1dk>({T_mid_at_cldtop_k, p_mid_at_cldtop_k, cldfrac_ice_at_cldtop_k,
+                                cldfrac_liq_at_cldtop_k, cldfrac_tot_at_cldtop_k, cdnc_at_cldtop_k,
+                                eff_radius_qc_at_cldtop_k, eff_radius_qi_at_cldtop_k}));
 #endif
 
       // Copy output data back to FieldManager
       const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(ncol, m_nlay);
 #ifdef RRTMGP_ENABLE_YAKL
-      TIMED_KERNEL(Kokkos::parallel_for(
-                       policy, KOKKOS_LAMBDA(const MemberType &team) {
-                         const int i              = team.league_rank();
-                         const int icol           = i + beg;
-                         d_sfc_flux_dir_nir(icol) = sfc_flux_dir_nir(i + 1);
-                         d_sfc_flux_dir_vis(icol) = sfc_flux_dir_vis(i + 1);
-                         d_sfc_flux_dif_nir(icol) = sfc_flux_dif_nir(i + 1);
-                         d_sfc_flux_dif_vis(icol) = sfc_flux_dif_vis(i + 1);
-                         d_sfc_flux_sw_net(icol)  = sw_flux_dn(i + 1, kbot) - sw_flux_up(i + 1, kbot);
-                         d_sfc_flux_lw_dn(icol)   = lw_flux_dn(i + 1, kbot);
-                         Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay + 1), [&](const int &k) {
-                           d_sw_flux_up(icol, k)               = sw_flux_up(i + 1, k + 1);
-                           d_sw_flux_dn(icol, k)               = sw_flux_dn(i + 1, k + 1);
-                           d_sw_flux_dn_dir(icol, k)           = sw_flux_dn_dir(i + 1, k + 1);
-                           d_lw_flux_up(icol, k)               = lw_flux_up(i + 1, k + 1);
-                           d_lw_flux_dn(icol, k)               = lw_flux_dn(i + 1, k + 1);
-                           d_sw_clnclrsky_flux_up(icol, k)     = sw_clnclrsky_flux_up(i + 1, k + 1);
-                           d_sw_clnclrsky_flux_dn(icol, k)     = sw_clnclrsky_flux_dn(i + 1, k + 1);
-                           d_sw_clnclrsky_flux_dn_dir(icol, k) = sw_clnclrsky_flux_dn_dir(i + 1, k + 1);
-                           d_sw_clrsky_flux_up(icol, k)        = sw_clrsky_flux_up(i + 1, k + 1);
-                           d_sw_clrsky_flux_dn(icol, k)        = sw_clrsky_flux_dn(i + 1, k + 1);
-                           d_sw_clrsky_flux_dn_dir(icol, k)    = sw_clrsky_flux_dn_dir(i + 1, k + 1);
-                           d_sw_clnsky_flux_up(icol, k)        = sw_clnsky_flux_up(i + 1, k + 1);
-                           d_sw_clnsky_flux_dn(icol, k)        = sw_clnsky_flux_dn(i + 1, k + 1);
-                           d_sw_clnsky_flux_dn_dir(icol, k)    = sw_clnsky_flux_dn_dir(i + 1, k + 1);
-                           d_lw_clnclrsky_flux_up(icol, k)     = lw_clnclrsky_flux_up(i + 1, k + 1);
-                           d_lw_clnclrsky_flux_dn(icol, k)     = lw_clnclrsky_flux_dn(i + 1, k + 1);
-                           d_lw_clrsky_flux_up(icol, k)        = lw_clrsky_flux_up(i + 1, k + 1);
-                           d_lw_clrsky_flux_dn(icol, k)        = lw_clrsky_flux_dn(i + 1, k + 1);
-                           d_lw_clnsky_flux_up(icol, k)        = lw_clnsky_flux_up(i + 1, k + 1);
-                           d_lw_clnsky_flux_dn(icol, k)        = lw_clnsky_flux_dn(i + 1, k + 1);
-                         });
-                         // Extract optical properties for COSP
-                         Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &k) {
-                           d_dtau067(icol, k) = cld_tau_sw_bnd(i + 1, k + 1, idx_067);
-                           d_dtau105(icol, k) = cld_tau_lw_bnd(i + 1, k + 1, idx_105);
-                         });
-                         if (d_sw_clrsky_flux_dn(icol, 0) > 0) {
-                           d_sunlit(icol) = 1.0;
-                         } else {
-                           d_sunlit(icol) = 0.0;
-                         }
-                       }););
+      TIMED_KERNEL(
+          Kokkos::parallel_for(
+              policy, KOKKOS_LAMBDA(const MemberType &team) {
+                const int i              = team.league_rank();
+                const int icol           = i + beg;
+                d_sfc_flux_dir_nir(icol) = sfc_flux_dir_nir(i + 1);
+                d_sfc_flux_dir_vis(icol) = sfc_flux_dir_vis(i + 1);
+                d_sfc_flux_dif_nir(icol) = sfc_flux_dif_nir(i + 1);
+                d_sfc_flux_dif_vis(icol) = sfc_flux_dif_vis(i + 1);
+                d_sfc_flux_sw_net(icol)  = sw_flux_dn(i + 1, kbot) - sw_flux_up(i + 1, kbot);
+                d_sfc_flux_lw_dn(icol)   = lw_flux_dn(i + 1, kbot);
+                Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay + 1), [&](const int &k) {
+                  d_sw_flux_up(icol, k)               = sw_flux_up(i + 1, k + 1);
+                  d_sw_flux_dn(icol, k)               = sw_flux_dn(i + 1, k + 1);
+                  d_sw_flux_dn_dir(icol, k)           = sw_flux_dn_dir(i + 1, k + 1);
+                  d_lw_flux_up(icol, k)               = lw_flux_up(i + 1, k + 1);
+                  d_lw_flux_dn(icol, k)               = lw_flux_dn(i + 1, k + 1);
+                  d_sw_clnclrsky_flux_up(icol, k)     = sw_clnclrsky_flux_up(i + 1, k + 1);
+                  d_sw_clnclrsky_flux_dn(icol, k)     = sw_clnclrsky_flux_dn(i + 1, k + 1);
+                  d_sw_clnclrsky_flux_dn_dir(icol, k) = sw_clnclrsky_flux_dn_dir(i + 1, k + 1);
+                  d_sw_clrsky_flux_up(icol, k)        = sw_clrsky_flux_up(i + 1, k + 1);
+                  d_sw_clrsky_flux_dn(icol, k)        = sw_clrsky_flux_dn(i + 1, k + 1);
+                  d_sw_clrsky_flux_dn_dir(icol, k)    = sw_clrsky_flux_dn_dir(i + 1, k + 1);
+                  d_sw_clnsky_flux_up(icol, k)        = sw_clnsky_flux_up(i + 1, k + 1);
+                  d_sw_clnsky_flux_dn(icol, k)        = sw_clnsky_flux_dn(i + 1, k + 1);
+                  d_sw_clnsky_flux_dn_dir(icol, k)    = sw_clnsky_flux_dn_dir(i + 1, k + 1);
+                  d_lw_clnclrsky_flux_up(icol, k)     = lw_clnclrsky_flux_up(i + 1, k + 1);
+                  d_lw_clnclrsky_flux_dn(icol, k)     = lw_clnclrsky_flux_dn(i + 1, k + 1);
+                  d_lw_clrsky_flux_up(icol, k)        = lw_clrsky_flux_up(i + 1, k + 1);
+                  d_lw_clrsky_flux_dn(icol, k)        = lw_clrsky_flux_dn(i + 1, k + 1);
+                  d_lw_clnsky_flux_up(icol, k)        = lw_clnsky_flux_up(i + 1, k + 1);
+                  d_lw_clnsky_flux_dn(icol, k)        = lw_clnsky_flux_dn(i + 1, k + 1);
+                });
+                // Extract optical properties for COSP
+                Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &k) {
+                  d_dtau067(icol, k) = cld_tau_sw_bnd(i + 1, k + 1, idx_067);
+                  d_dtau105(icol, k) = cld_tau_lw_bnd(i + 1, k + 1, idx_105);
+                });
+                if (d_sw_clrsky_flux_dn(icol, 0) > 0) {
+                  d_sunlit(icol) = 1.0;
+                } else {
+                  d_sunlit(icol) = 0.0;
+                }
+              }););
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
-      TIMED_KERNEL(Kokkos::parallel_for(
-                       policy, KOKKOS_LAMBDA(const MemberType &team) {
-                         const int i             = team.league_rank();
-                         const int icol          = i + beg;
-                         d_sfc_flux_sw_net(icol) = sw_flux_dn_k(i, kbot_k) - sw_flux_up_k(i, kbot_k);
-                         d_sfc_flux_lw_dn(icol)  = lw_flux_dn_k(i, kbot_k);
+      TIMED_KERNEL(
+          Kokkos::parallel_for(
+              policy, KOKKOS_LAMBDA(const MemberType &team) {
+                const int i             = team.league_rank();
+                const int icol          = i + beg;
+                d_sfc_flux_sw_net(icol) = sw_flux_dn_k(i, kbot_k) - sw_flux_up_k(i, kbot_k);
+                d_sfc_flux_lw_dn(icol)  = lw_flux_dn_k(i, kbot_k);
 #ifdef RRTMGP_LAYOUT_LEFT
-                         // Copy from layout left buffer views back to layout right fields
-                         Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay + 1), [&](const int &k) {
-                           d_sw_flux_up(icol, k)               = sw_flux_up_k(i, k);
-                           d_sw_flux_dn(icol, k)               = sw_flux_dn_k(i, k);
-                           d_sw_flux_dn_dir(icol, k)           = sw_flux_dn_dir_k(i, k);
-                           d_lw_flux_up(icol, k)               = lw_flux_up_k(i, k);
-                           d_lw_flux_dn(icol, k)               = lw_flux_dn_k(i, k);
-                           d_sw_clnclrsky_flux_up(icol, k)     = sw_clnclrsky_flux_up_k(i, k);
-                           d_sw_clnclrsky_flux_dn(icol, k)     = sw_clnclrsky_flux_dn_k(i, k);
-                           d_sw_clnclrsky_flux_dn_dir(icol, k) = sw_clnclrsky_flux_dn_dir_k(i, k);
-                           d_sw_clrsky_flux_up(icol, k)        = sw_clrsky_flux_up_k(i, k);
-                           d_sw_clrsky_flux_dn(icol, k)        = sw_clrsky_flux_dn_k(i, k);
-                           d_sw_clrsky_flux_dn_dir(icol, k)    = sw_clrsky_flux_dn_dir_k(i, k);
-                           d_sw_clnsky_flux_up(icol, k)        = sw_clnsky_flux_up_k(i, k);
-                           d_sw_clnsky_flux_dn(icol, k)        = sw_clnsky_flux_dn_k(i, k);
-                           d_sw_clnsky_flux_dn_dir(icol, k)    = sw_clnsky_flux_dn_dir_k(i, k);
-                           d_lw_clnclrsky_flux_up(icol, k)     = lw_clnclrsky_flux_up_k(i, k);
-                           d_lw_clnclrsky_flux_dn(icol, k)     = lw_clnclrsky_flux_dn_k(i, k);
-                           d_lw_clrsky_flux_up(icol, k)        = lw_clrsky_flux_up_k(i, k);
-                           d_lw_clrsky_flux_dn(icol, k)        = lw_clrsky_flux_dn_k(i, k);
-                           d_lw_clnsky_flux_up(icol, k)        = lw_clnsky_flux_up_k(i, k);
-                           d_lw_clnsky_flux_dn(icol, k)        = lw_clnsky_flux_dn_k(i, k);
-                         });
+                // Copy from layout left buffer views back to layout right fields
+                Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay + 1), [&](const int &k) {
+                  d_sw_flux_up(icol, k)               = sw_flux_up_k(i, k);
+                  d_sw_flux_dn(icol, k)               = sw_flux_dn_k(i, k);
+                  d_sw_flux_dn_dir(icol, k)           = sw_flux_dn_dir_k(i, k);
+                  d_lw_flux_up(icol, k)               = lw_flux_up_k(i, k);
+                  d_lw_flux_dn(icol, k)               = lw_flux_dn_k(i, k);
+                  d_sw_clnclrsky_flux_up(icol, k)     = sw_clnclrsky_flux_up_k(i, k);
+                  d_sw_clnclrsky_flux_dn(icol, k)     = sw_clnclrsky_flux_dn_k(i, k);
+                  d_sw_clnclrsky_flux_dn_dir(icol, k) = sw_clnclrsky_flux_dn_dir_k(i, k);
+                  d_sw_clrsky_flux_up(icol, k)        = sw_clrsky_flux_up_k(i, k);
+                  d_sw_clrsky_flux_dn(icol, k)        = sw_clrsky_flux_dn_k(i, k);
+                  d_sw_clrsky_flux_dn_dir(icol, k)    = sw_clrsky_flux_dn_dir_k(i, k);
+                  d_sw_clnsky_flux_up(icol, k)        = sw_clnsky_flux_up_k(i, k);
+                  d_sw_clnsky_flux_dn(icol, k)        = sw_clnsky_flux_dn_k(i, k);
+                  d_sw_clnsky_flux_dn_dir(icol, k)    = sw_clnsky_flux_dn_dir_k(i, k);
+                  d_lw_clnclrsky_flux_up(icol, k)     = lw_clnclrsky_flux_up_k(i, k);
+                  d_lw_clnclrsky_flux_dn(icol, k)     = lw_clnclrsky_flux_dn_k(i, k);
+                  d_lw_clrsky_flux_up(icol, k)        = lw_clrsky_flux_up_k(i, k);
+                  d_lw_clrsky_flux_dn(icol, k)        = lw_clrsky_flux_dn_k(i, k);
+                  d_lw_clnsky_flux_up(icol, k)        = lw_clnsky_flux_up_k(i, k);
+                  d_lw_clnsky_flux_dn(icol, k)        = lw_clnsky_flux_dn_k(i, k);
+                });
 #endif
-                         // Extract optical properties for COSP
-                         Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &k) {
-                           d_dtau067(icol, k) = cld_tau_sw_bnd_k(i, k, idx_067_k);
-                           d_dtau105(icol, k) = cld_tau_lw_bnd_k(i, k, idx_105_k);
-                         });
-                         if (d_sw_clrsky_flux_dn(icol, 0) > 0) {
-                           d_sunlit(icol) = 1.0;
-                         } else {
-                           d_sunlit(icol) = 0.0;
-                         }
-                       }););
+                // Extract optical properties for COSP
+                Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlay), [&](const int &k) {
+                  d_dtau067(icol, k) = cld_tau_sw_bnd_k(i, k, idx_067_k);
+                  d_dtau105(icol, k) = cld_tau_lw_bnd_k(i, k, idx_105_k);
+                });
+                if (d_sw_clrsky_flux_dn(icol, 0) > 0) {
+                  d_sunlit(icol) = 1.0;
+                } else {
+                  d_sunlit(icol) = 0.0;
+                }
+              }););
 #ifdef RRTMGP_ENABLE_YAKL
       // Sync back to gas_concs_k
       real3dk temp(gas_concs_k, std::make_pair(0, ncol), Kokkos::ALL, Kokkos::ALL);
@@ -1739,10 +1868,10 @@ void RRTMGPRadiation::run_impl(const double dt) {
 #endif
   } // update_rad
 
-  // Apply temperature tendency; if we updated radiation this timestep, then d_rad_heating_pdel should
-  // contain actual heating rate, not pdel scaled heating rate. Otherwise, if we have NOT updated the
-  // radiative heating, then we need to back out the heating from the rad_heating*pdel term that we carry
-  // across timesteps to conserve energy.
+  // Apply temperature tendency; if we updated radiation this timestep, then d_rad_heating_pdel
+  // should contain actual heating rate, not pdel scaled heating rate. Otherwise, if we have NOT
+  // updated the radiative heating, then we need to back out the heating from the rad_heating*pdel
+  // term that we carry across timesteps to conserve energy.
   const int ncols   = m_ncol;
   const int nlays   = m_nlay;
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(ncols, nlays);
diff --git i/components/eamxx/src/physics/rrtmgp/rrtmgp_test_utils.cpp w/components/eamxx/src/physics/rrtmgp/rrtmgp_test_utils.cpp
index a2a261808c..3135eb0089 100644
--- i/components/eamxx/src/physics/rrtmgp/rrtmgp_test_utils.cpp
+++ w/components/eamxx/src/physics/rrtmgp/rrtmgp_test_utils.cpp
@@ -39,9 +39,10 @@ bool all_close(real2d &arr1, real2d &arr2, double tolerance) {
   return true;
 }
 
-void dummy_atmos(std::string inputfile, int ncol, real2d &p_lay, real2d &t_lay, real1d &sfc_alb_dir_vis,
-                 real1d &sfc_alb_dir_nir, real1d &sfc_alb_dif_vis, real1d &sfc_alb_dif_nir, real1d &mu0, real2d &lwp,
-                 real2d &iwp, real2d &rel, real2d &rei, real2d &cld) {
+void dummy_atmos(std::string inputfile, int ncol, real2d &p_lay, real2d &t_lay,
+                 real1d &sfc_alb_dir_vis, real1d &sfc_alb_dir_nir, real1d &sfc_alb_dif_vis,
+                 real1d &sfc_alb_dif_nir, real1d &mu0, real2d &lwp, real2d &iwp, real2d &rel,
+                 real2d &rei, real2d &cld) {
 
   // Setup boundary conditions, solar zenith angle, etc
   // NOTE: this stuff would come from the model in a real run
@@ -62,8 +63,8 @@ void dummy_atmos(std::string inputfile, int ncol, real2d &p_lay, real2d &t_lay,
   dummy_clouds(scream::rrtmgp::cloud_optics_sw, p_lay, t_lay, lwp, iwp, rel, rei, cld);
 }
 
-void dummy_clouds(CloudOptics &cloud_optics, real2d &p_lay, real2d &t_lay, real2d &lwp, real2d &iwp, real2d &rel,
-                  real2d &rei, real2d &cloud_mask) {
+void dummy_clouds(CloudOptics &cloud_optics, real2d &p_lay, real2d &t_lay, real2d &lwp, real2d &iwp,
+                  real2d &rel, real2d &rei, real2d &cloud_mask) {
 
   // Problem sizes
   int ncol = t_lay.dimension[0];
@@ -74,24 +75,26 @@ void dummy_clouds(CloudOptics &cloud_optics, real2d &p_lay, real2d &t_lay, real2
   real rel_val = 0.5 * (cloud_optics.get_min_radius_liq() + cloud_optics.get_max_radius_liq());
   real rei_val = 0.5 * (cloud_optics.get_min_radius_ice() + cloud_optics.get_max_radius_ice());
 
-  // Restrict clouds to troposphere (> 100 hPa = 100*100 Pa) and not very close to the ground (< 900 hPa), and
-  // put them in 2/3 of the columns since that's roughly the total cloudiness of earth.
+  // Restrict clouds to troposphere (> 100 hPa = 100*100 Pa) and not very close to the ground (< 900
+  // hPa), and put them in 2/3 of the columns since that's roughly the total cloudiness of earth.
   // Set sane values for liquid and ice water path.
   // NOTE: these "sane" values are in g/m2!
   parallel_for(
       SimpleBounds<2>(nlay, ncol), YAKL_LAMBDA(int ilay, int icol) {
-        cloud_mask(icol, ilay) =
-            p_lay(icol, ilay) > 100._wp * 100._wp && p_lay(icol, ilay) < 900._wp * 100._wp && mod(icol, 3) != 0;
+        cloud_mask(icol, ilay) = p_lay(icol, ilay) > 100._wp * 100._wp &&
+                                 p_lay(icol, ilay) < 900._wp * 100._wp && mod(icol, 3) != 0;
         // Ice and liquid will overlap in a few layers
-        lwp(icol, ilay) = merge(10._wp, 0._wp, cloud_mask(icol, ilay) && t_lay(icol, ilay) > 263._wp);
-        iwp(icol, ilay) = merge(10._wp, 0._wp, cloud_mask(icol, ilay) && t_lay(icol, ilay) < 273._wp);
+        lwp(icol, ilay) =
+            merge(10._wp, 0._wp, cloud_mask(icol, ilay) && t_lay(icol, ilay) > 263._wp);
+        iwp(icol, ilay) =
+            merge(10._wp, 0._wp, cloud_mask(icol, ilay) && t_lay(icol, ilay) < 273._wp);
         rel(icol, ilay) = merge(rel_val, 0._wp, lwp(icol, ilay) > 0._wp);
         rei(icol, ilay) = merge(rei_val, 0._wp, iwp(icol, ilay) > 0._wp);
       });
 }
 
-void read_fluxes(std::string inputfile, real2d &sw_flux_up, real2d &sw_flux_dn, real2d &sw_flux_dir, real2d &lw_flux_up,
-                 real2d &lw_flux_dn) {
+void read_fluxes(std::string inputfile, real2d &sw_flux_up, real2d &sw_flux_dn, real2d &sw_flux_dir,
+                 real2d &lw_flux_up, real2d &lw_flux_dn) {
 
   // Initialize netcdf reader
   yakl::SimpleNetCDF io;
@@ -114,8 +117,8 @@ void read_fluxes(std::string inputfile, real2d &sw_flux_up, real2d &sw_flux_dn,
   io.read(lw_flux_dn, "lw_flux_dn");
 }
 
-void write_fluxes(std::string outputfile, real2d &sw_flux_up, real2d &sw_flux_dn, real2d &sw_flux_dir,
-                  real2d &lw_flux_up, real2d &lw_flux_dn) {
+void write_fluxes(std::string outputfile, real2d &sw_flux_up, real2d &sw_flux_dn,
+                  real2d &sw_flux_dir, real2d &lw_flux_up, real2d &lw_flux_dn) {
 
   yakl::SimpleNetCDF io;
   io.create(outputfile);
diff --git i/components/eamxx/src/physics/rrtmgp/rrtmgp_test_utils.hpp w/components/eamxx/src/physics/rrtmgp/rrtmgp_test_utils.hpp
index 1dbfa384c2..75c597c900 100644
--- i/components/eamxx/src/physics/rrtmgp/rrtmgp_test_utils.hpp
+++ w/components/eamxx/src/physics/rrtmgp/rrtmgp_test_utils.hpp
@@ -13,22 +13,24 @@ bool file_exists(const char *filename);
 #ifdef RRTMGP_ENABLE_YAKL
 bool all_close(real2d &arr1, real2d &arr2, double tolerance);
 
-void dummy_clouds(CloudOptics &cloud_optics, real2d &p_lay, real2d &t_lay, real2d &lwp, real2d &iwp, real2d &rel,
-                  real2d &rei, real2d &cld);
+void dummy_clouds(CloudOptics &cloud_optics, real2d &p_lay, real2d &t_lay, real2d &lwp, real2d &iwp,
+                  real2d &rel, real2d &rei, real2d &cld);
 
-void dummy_atmos(std::string inputfile, int ncol, real2d &p_lay, real2d &t_lay, real1d &sfc_alb_dir_vis,
-                 real1d &sfc_alb_dir_nir, real1d &sfc_alb_dif_vis, real1d &sfc_alb_dif_nir, real1d &mu0, real2d &lwp,
-                 real2d &iwp, real2d &rel, real2d &rei, real2d &cld);
+void dummy_atmos(std::string inputfile, int ncol, real2d &p_lay, real2d &t_lay,
+                 real1d &sfc_alb_dir_vis, real1d &sfc_alb_dir_nir, real1d &sfc_alb_dif_vis,
+                 real1d &sfc_alb_dif_nir, real1d &mu0, real2d &lwp, real2d &iwp, real2d &rel,
+                 real2d &rei, real2d &cld);
 
-void read_fluxes(std::string inputfile, real2d &sw_flux_up, real2d &sw_flux_dn, real2d &sw_flux_dir, real2d &lw_flux_up,
-                 real2d &lw_flux_dn);
+void read_fluxes(std::string inputfile, real2d &sw_flux_up, real2d &sw_flux_dn, real2d &sw_flux_dir,
+                 real2d &lw_flux_up, real2d &lw_flux_dn);
 
-void write_fluxes(std::string outputfile, real2d &sw_flux_up, real2d &sw_flux_dn, real2d &sw_flux_dir,
-                  real2d &lw_flux_up, real2d &lw_flux_dn);
+void write_fluxes(std::string outputfile, real2d &sw_flux_up, real2d &sw_flux_dn,
+                  real2d &sw_flux_dir, real2d &lw_flux_up, real2d &lw_flux_dn);
 #endif
 
 #ifdef RRTMGP_ENABLE_KOKKOS
-template <typename RealT = scream::Real, typename LayoutT = Kokkos::LayoutRight, typename DeviceT = DefaultDevice>
+template <typename RealT = scream::Real, typename LayoutT = Kokkos::LayoutRight,
+          typename DeviceT = DefaultDevice>
 struct rrtmgp_test_utils {
 
   using interface_t = scream::rrtmgp::rrtmgp_interface<RealT, LayoutT, DeviceT>;
@@ -46,7 +48,8 @@ struct rrtmgp_test_utils {
     Kokkos::deep_copy(arr2_h, arr2);
     for (int i = 0; i < nx; i++) {
       for (int j = 0; j < ny; j++) {
-        if (abs(arr1_h(i, j) - arr2_h(i, j)) > tolerance || std::isnan(arr1_h(i, j) - arr2_h(i, j))) {
+        if (abs(arr1_h(i, j) - arr2_h(i, j)) > tolerance ||
+            std::isnan(arr1_h(i, j) - arr2_h(i, j))) {
           printf("arr1 = %f, arr2 = %f at %i,%i\n", arr1_h(i, j), arr2_h(i, j), i, j);
           return false;
         }
@@ -55,8 +58,9 @@ struct rrtmgp_test_utils {
     return true;
   }
 
-  static void dummy_clouds(CloudOpticsK<RealT, LayoutT, DeviceT> &cloud_optics, real2dk &p_lay, real2dk &t_lay,
-                           real2dk &lwp, real2dk &iwp, real2dk &rel, real2dk &rei, real2dk &cloud_mask) {
+  static void dummy_clouds(CloudOpticsK<RealT, LayoutT, DeviceT> &cloud_optics, real2dk &p_lay,
+                           real2dk &t_lay, real2dk &lwp, real2dk &iwp, real2dk &rel, real2dk &rei,
+                           real2dk &cloud_mask) {
     // Problem sizes
     int ncol = t_lay.extent(0);
     int nlay = t_lay.extent(1);
@@ -66,24 +70,26 @@ struct rrtmgp_test_utils {
     real rel_val = 0.5 * (cloud_optics.get_min_radius_liq() + cloud_optics.get_max_radius_liq());
     real rei_val = 0.5 * (cloud_optics.get_min_radius_ice() + cloud_optics.get_max_radius_ice());
 
-    // Restrict clouds to troposphere (> 100 hPa = 100*100 Pa) and not very close to the ground (< 900 hPa), and
-    // put them in 2/3 of the columns since that's roughly the total cloudiness of earth.
-    // Set sane values for liquid and ice water path.
-    // NOTE: these "sane" values are in g/m2!
+    // Restrict clouds to troposphere (> 100 hPa = 100*100 Pa) and not very close to the ground (<
+    // 900 hPa), and put them in 2/3 of the columns since that's roughly the total cloudiness of
+    // earth. Set sane values for liquid and ice water path. NOTE: these "sane" values are in g/m2!
     Kokkos::parallel_for(
         MDRP::template get<2>({ncol, nlay}), KOKKOS_LAMBDA(int icol, int ilay) {
-          cloud_mask(icol, ilay) =
-              p_lay(icol, ilay) > 100. * 100. && p_lay(icol, ilay) < 900. * 100. && ((icol + 1) % 3) != 0;
+          cloud_mask(icol, ilay) = p_lay(icol, ilay) > 100. * 100. &&
+                                   p_lay(icol, ilay) < 900. * 100. && ((icol + 1) % 3) != 0;
           // Ice and liquid will overlap in a few layers
-          lwp(icol, ilay) = conv::merge(10., 0., cloud_mask(icol, ilay) && t_lay(icol, ilay) > 263.);
-          iwp(icol, ilay) = conv::merge(10., 0., cloud_mask(icol, ilay) && t_lay(icol, ilay) < 273.);
+          lwp(icol, ilay) =
+              conv::merge(10., 0., cloud_mask(icol, ilay) && t_lay(icol, ilay) > 263.);
+          iwp(icol, ilay) =
+              conv::merge(10., 0., cloud_mask(icol, ilay) && t_lay(icol, ilay) < 273.);
           rel(icol, ilay) = conv::merge(rel_val, 0., lwp(icol, ilay) > 0.);
           rei(icol, ilay) = conv::merge(rei_val, 0., iwp(icol, ilay) > 0.);
         });
   }
 
-  static void dummy_atmos(std::string inputfile, int ncol, real2dk &p_lay, real2dk &t_lay, real1dk &sfc_alb_dir_vis,
-                          real1dk &sfc_alb_dir_nir, real1dk &sfc_alb_dif_vis, real1dk &sfc_alb_dif_nir, real1dk &mu0,
+  static void dummy_atmos(std::string inputfile, int ncol, real2dk &p_lay, real2dk &t_lay,
+                          real1dk &sfc_alb_dir_vis, real1dk &sfc_alb_dir_nir,
+                          real1dk &sfc_alb_dif_vis, real1dk &sfc_alb_dif_nir, real1dk &mu0,
                           real2dk &lwp, real2dk &iwp, real2dk &rel, real2dk &rei, real2dk &cld) {
     // Setup boundary conditions, solar zenith angle, etc
     // NOTE: this stuff would come from the model in a real run
@@ -104,8 +110,8 @@ struct rrtmgp_test_utils {
     dummy_clouds(*interface_t::cloud_optics_sw_k, p_lay, t_lay, lwp, iwp, rel, rei, cld);
   }
 
-  static void read_fluxes(std::string inputfile, real2dk &sw_flux_up, real2dk &sw_flux_dn, real2dk &sw_flux_dir,
-                          real2dk &lw_flux_up, real2dk &lw_flux_dn) {
+  static void read_fluxes(std::string inputfile, real2dk &sw_flux_up, real2dk &sw_flux_dn,
+                          real2dk &sw_flux_dir, real2dk &lw_flux_up, real2dk &lw_flux_dn) {
     // Initialize netcdf reader
     conv::SimpleNetCDF io;
     io.open(inputfile, NC_NOWRITE);
@@ -127,8 +133,8 @@ struct rrtmgp_test_utils {
     io.read(lw_flux_dn, "lw_flux_dn");
   }
 
-  static void write_fluxes(std::string outputfile, real2dk &sw_flux_up, real2dk &sw_flux_dn, real2dk &sw_flux_dir,
-                           real2dk &lw_flux_up, real2dk &lw_flux_dn) {
+  static void write_fluxes(std::string outputfile, real2dk &sw_flux_up, real2dk &sw_flux_dn,
+                           real2dk &sw_flux_dir, real2dk &lw_flux_up, real2dk &lw_flux_dn) {
     conv::SimpleNetCDF io;
     io.create(outputfile);
     io.write(sw_flux_up, "sw_flux_up", {"col_flx", "lev"});
diff --git i/components/eamxx/src/physics/rrtmgp/rrtmgp_utils.hpp w/components/eamxx/src/physics/rrtmgp/rrtmgp_utils.hpp
index 07c4740f9a..15d3055e1a 100644
--- i/components/eamxx/src/physics/rrtmgp/rrtmgp_utils.hpp
+++ w/components/eamxx/src/physics/rrtmgp/rrtmgp_utils.hpp
@@ -42,24 +42,25 @@ void compute_heating_rate(yakl::Array<T, 2, myMem, myStyle> const &flux_up,
   auto nlay       = flux_up.dimension[1] - 1;
   TIMED_KERNEL(yakl::fortran::parallel_for(
       yakl::fortran::SimpleBounds<2>(nlay, ncol), YAKL_LAMBDA(int ilay, int icol) {
-        heating_rate(icol, ilay) =
-            (flux_up(icol, ilay + 1) - flux_up(icol, ilay) - flux_dn(icol, ilay + 1) + flux_dn(icol, ilay)) *
-            physconst::gravit / (physconst::Cpair * pdel(icol, ilay));
+        heating_rate(icol, ilay) = (flux_up(icol, ilay + 1) - flux_up(icol, ilay) -
+                                    flux_dn(icol, ilay + 1) + flux_dn(icol, ilay)) *
+                                   physconst::gravit / (physconst::Cpair * pdel(icol, ilay));
       }));
 }
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
 template <class View1, class View2, class View3, class View4>
-void compute_heating_rate(View1 const &flux_up, View2 const &flux_dn, View3 const &pdel, View4 const &heating_rate) {
+void compute_heating_rate(View1 const &flux_up, View2 const &flux_dn, View3 const &pdel,
+                          View4 const &heating_rate) {
   using physconst = scream::physics::Constants<Real>;
   using LayoutT   = typename View1::array_layout;
   const int ncol  = (int)flux_up.extent(0);
   const int nlay  = (int)flux_up.extent(1) - 1;
-  TIMED_KERNEL(FLATTEN_MD_KERNEL2(
-      ncol, nlay, icol, ilay,
-      heating_rate(icol, ilay) =
-          (flux_up(icol, ilay + 1) - flux_up(icol, ilay) - flux_dn(icol, ilay + 1) + flux_dn(icol, ilay)) *
-          physconst::gravit / (physconst::Cpair * pdel(icol, ilay));));
+  TIMED_KERNEL(FLATTEN_MD_KERNEL2(ncol, nlay, icol, ilay,
+                                  heating_rate(icol, ilay) =
+                                      (flux_up(icol, ilay + 1) - flux_up(icol, ilay) -
+                                       flux_dn(icol, ilay + 1) + flux_dn(icol, ilay)) *
+                                      physconst::gravit / (physconst::Cpair * pdel(icol, ilay));));
 }
 #endif
 
@@ -78,7 +79,8 @@ inline bool radiation_do(const int irad, const int nstep) {
 // Verify that array only contains values within valid range, and if not
 // report min and max of array
 #ifdef RRTMGP_ENABLE_YAKL
-template <class T> bool check_range(T x, Real xmin, Real xmax, std::string msg, std::ostream &out = std::cout) {
+template <class T>
+bool check_range(T x, Real xmin, Real xmax, std::string msg, std::ostream &out = std::cout) {
   bool pass  = true;
   auto _xmin = minval(x);
   auto _xmax = maxval(x);
@@ -105,8 +107,8 @@ template <class T> bool check_range(T x, Real xmin, Real xmax, std::string msg,
 #endif
 #ifdef RRTMGP_ENABLE_KOKKOS
 template <class T, typename std::enable_if<T::rank == 1>::type *dummy = nullptr>
-bool check_range_k(T x, typename T::const_value_type xmin, typename T::const_value_type xmax, std::string msg,
-                   std::ostream &out = std::cout) {
+bool check_range_k(T x, typename T::const_value_type xmin, typename T::const_value_type xmax,
+                   std::string msg, std::ostream &out = std::cout) {
   bool pass  = true;
   auto _xmin = conv::minval(x);
   auto _xmax = conv::maxval(x);
@@ -129,8 +131,8 @@ bool check_range_k(T x, typename T::const_value_type xmin, typename T::const_val
 }
 
 template <class T, typename std::enable_if<T::rank == 2>::type *dummy = nullptr>
-bool check_range_k(T x, typename T::const_value_type xmin, typename T::const_value_type xmax, std::string msg,
-                   std::ostream &out = std::cout) {
+bool check_range_k(T x, typename T::const_value_type xmin, typename T::const_value_type xmax,
+                   std::string msg, std::ostream &out = std::cout) {
   bool pass  = true;
   auto _xmin = conv::minval(x);
   auto _xmax = conv::maxval(x);
@@ -157,8 +159,8 @@ bool check_range_k(T x, typename T::const_value_type xmin, typename T::const_val
 }
 
 template <class T, typename std::enable_if<T::rank == 3>::type *dummy = nullptr>
-bool check_range_k(T x, typename T::const_value_type xmin, typename T::const_value_type xmax, std::string msg,
-                   std::ostream &out = std::cout) {
+bool check_range_k(T x, typename T::const_value_type xmin, typename T::const_value_type xmax,
+                   std::string msg, std::ostream &out = std::cout) {
   bool pass  = true;
   auto _xmin = conv::minval(x);
   auto _xmax = conv::maxval(x);
diff --git i/components/eamxx/src/physics/rrtmgp/shr_orb_mod_c2f.hpp w/components/eamxx/src/physics/rrtmgp/shr_orb_mod_c2f.hpp
index 575b7bea4c..9c330abbfa 100644
--- i/components/eamxx/src/physics/rrtmgp/shr_orb_mod_c2f.hpp
+++ w/components/eamxx/src/physics/rrtmgp/shr_orb_mod_c2f.hpp
@@ -1,9 +1,10 @@
 #ifndef SHR_ORB_MOD_C2F_HPP
 #define SHR_ORB_MOD_C2F_HPP
 extern "C" int shr_orb_undef_int_c2f;
-extern "C" void shr_orb_params_c2f(int *orb_year, double *eccen, double *mvelpp, double *lambm0, double *obliqr,
-                                   double *delta, double *eccf);
-extern "C" void shr_orb_decl_c2f(double calday, double eccen, double mvelpp, double lambm0, double obliqr,
-                                 double *delta, double *eccf);
-extern "C" double shr_orb_cosz_c2f(double jday, double lat, double lon, double declin, double dt_avg);
+extern "C" void shr_orb_params_c2f(int *orb_year, double *eccen, double *mvelpp, double *lambm0,
+                                   double *obliqr, double *delta, double *eccf);
+extern "C" void shr_orb_decl_c2f(double calday, double eccen, double mvelpp, double lambm0,
+                                 double obliqr, double *delta, double *eccf);
+extern "C" double shr_orb_cosz_c2f(double jday, double lat, double lon, double declin,
+                                   double dt_avg);
 #endif
diff --git i/components/eamxx/src/physics/rrtmgp/tests/generate_baseline.cpp w/components/eamxx/src/physics/rrtmgp/tests/generate_baseline.cpp
index 358842f31c..5610688b1b 100644
--- i/components/eamxx/src/physics/rrtmgp/tests/generate_baseline.cpp
+++ w/components/eamxx/src/physics/rrtmgp/tests/generate_baseline.cpp
@@ -73,7 +73,8 @@ int main(int argc, char **argv) {
   r2d lw_flux_up_ref;
   r2d lw_flux_dn_ref;
   logger->info("read_fluxes...");
-  utils_t::read_fluxes(inputfile, sw_flux_up_ref, sw_flux_dn_ref, sw_flux_dn_dir_ref, lw_flux_up_ref, lw_flux_dn_ref);
+  utils_t::read_fluxes(inputfile, sw_flux_up_ref, sw_flux_dn_ref, sw_flux_dn_dir_ref,
+                       lw_flux_up_ref, lw_flux_dn_ref);
 
   // Get dimension sizes
 #ifdef RRTMGP_ENABLE_YAKL
@@ -104,11 +105,11 @@ int main(int argc, char **argv) {
   // data that contains information about absorption coefficients for gases
   logger->info("rrtmgp_initialize...");
 #ifdef RRTMGP_ENABLE_YAKL
-  interface_t::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw, cloud_optics_file_sw,
-                                 cloud_optics_file_lw, logger);
+  interface_t::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw,
+                                 cloud_optics_file_sw, cloud_optics_file_lw, logger);
 #else
-  interface_t::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw, cloud_optics_file_sw,
-                                 cloud_optics_file_lw, logger, 2.0);
+  interface_t::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw,
+                                 cloud_optics_file_sw, cloud_optics_file_lw, logger, 2.0);
 #endif
 
   // Setup dummy all-sky problem
@@ -122,8 +123,8 @@ int main(int argc, char **argv) {
   r2d rel("rel", ncol, nlay);
   r2d rei("rei", ncol, nlay);
   r2d cld("cld", ncol, nlay);
-  utils_t::dummy_atmos(inputfile, ncol, p_lay, t_lay, sfc_alb_dir_vis, sfc_alb_dir_nir, sfc_alb_dif_vis,
-                       sfc_alb_dif_nir, mu0, lwp, iwp, rel, rei, cld);
+  utils_t::dummy_atmos(inputfile, ncol, p_lay, t_lay, sfc_alb_dir_vis, sfc_alb_dir_nir,
+                       sfc_alb_dif_vis, sfc_alb_dif_nir, mu0, lwp, iwp, rel, rei, cld);
 
   // Setup flux outputs; In a real model run, the fluxes would be
   // input/outputs into the driver (persisting between calls), and
@@ -165,7 +166,8 @@ int main(int argc, char **argv) {
   // Compute band-by-band surface_albedos.
   r2d sfc_alb_dir("sfc_alb_dir", ncol, nswbands);
   r2d sfc_alb_dif("sfc_alb_dif", ncol, nswbands);
-  interface_t::compute_band_by_band_surface_albedos(ncol, nswbands, sfc_alb_dir_vis, sfc_alb_dir_nir, sfc_alb_dif_vis,
+  interface_t::compute_band_by_band_surface_albedos(ncol, nswbands, sfc_alb_dir_vis,
+                                                    sfc_alb_dir_nir, sfc_alb_dif_vis,
                                                     sfc_alb_dif_nir, sfc_alb_dir, sfc_alb_dif);
 
   // Setup some dummy aerosol optical properties
@@ -175,7 +177,8 @@ int main(int argc, char **argv) {
   auto aer_tau_lw = r3d("aer_tau_lw", ncol, nlay, nlwbands);
 #ifdef RRTMGP_ENABLE_YAKL
   yakl::fortran::parallel_for(
-      yakl::fortran::SimpleBounds<3>(nswbands, nlay, ncol), YAKL_LAMBDA(int ibnd, int ilay, int icol) {
+      yakl::fortran::SimpleBounds<3>(nswbands, nlay, ncol),
+      YAKL_LAMBDA(int ibnd, int ilay, int icol) {
 #else
   Kokkos::parallel_for(
       MDRP::template get<3>({nswbands, nlay, ncol}), KOKKOS_LAMBDA(int ibnd, int ilay, int icol) {
@@ -186,7 +189,8 @@ int main(int argc, char **argv) {
       });
 #ifdef RRTMGP_ENABLE_YAKL
   yakl::fortran::parallel_for(
-      yakl::fortran::SimpleBounds<3>(nlwbands, nlay, ncol), YAKL_LAMBDA(int ibnd, int ilay, int icol) {
+      yakl::fortran::SimpleBounds<3>(nlwbands, nlay, ncol),
+      YAKL_LAMBDA(int ibnd, int ilay, int icol) {
 #else
   Kokkos::parallel_for(
       MDRP::template get<3>({nlwbands, nlay, ncol}), KOKKOS_LAMBDA(int ibnd, int ilay, int icol) {
@@ -214,12 +218,14 @@ int main(int argc, char **argv) {
   logger->info("rrtmgp_main...");
   const Real tsi_scaling = 1;
   interface_t::rrtmgp_main(
-      ncol, nlay, p_lay, t_lay, p_lev, t_lev, gas_concs, sfc_alb_dir, sfc_alb_dif, mu0, lwp, iwp, rel, rei, cld,
-      aer_tau_sw, aer_ssa_sw, aer_asm_sw, aer_tau_lw, cld_tau_sw_bnd, cld_tau_lw_bnd, cld_tau_sw, cld_tau_lw, // outputs
-      sw_flux_up, sw_flux_dn, sw_flux_dn_dir, lw_flux_up, lw_flux_dn, sw_clnclrsky_flux_up, sw_clnclrsky_flux_dn,
-      sw_clnclrsky_flux_dn_dir, sw_clrsky_flux_up, sw_clrsky_flux_dn, sw_clrsky_flux_dn_dir, sw_clnsky_flux_up,
-      sw_clnsky_flux_dn, sw_clnsky_flux_dn_dir, lw_clnclrsky_flux_up, lw_clnclrsky_flux_dn, lw_clrsky_flux_up,
-      lw_clrsky_flux_dn, lw_clnsky_flux_up, lw_clnsky_flux_dn, sw_bnd_flux_up, sw_bnd_flux_dn, sw_bnd_flux_dir,
+      ncol, nlay, p_lay, t_lay, p_lev, t_lev, gas_concs, sfc_alb_dir, sfc_alb_dif, mu0, lwp, iwp,
+      rel, rei, cld, aer_tau_sw, aer_ssa_sw, aer_asm_sw, aer_tau_lw, cld_tau_sw_bnd, cld_tau_lw_bnd,
+      cld_tau_sw, cld_tau_lw, // outputs
+      sw_flux_up, sw_flux_dn, sw_flux_dn_dir, lw_flux_up, lw_flux_dn, sw_clnclrsky_flux_up,
+      sw_clnclrsky_flux_dn, sw_clnclrsky_flux_dn_dir, sw_clrsky_flux_up, sw_clrsky_flux_dn,
+      sw_clrsky_flux_dn_dir, sw_clnsky_flux_up, sw_clnsky_flux_dn, sw_clnsky_flux_dn_dir,
+      lw_clnclrsky_flux_up, lw_clnclrsky_flux_dn, lw_clrsky_flux_up, lw_clrsky_flux_dn,
+      lw_clnsky_flux_up, lw_clnsky_flux_dn, sw_bnd_flux_up, sw_bnd_flux_dn, sw_bnd_flux_dir,
       lw_bnd_flux_up, lw_bnd_flux_dn, tsi_scaling, logger);
 
   // Write fluxes
diff --git i/components/eamxx/src/physics/rrtmgp/tests/rrtmgp_tests.cpp w/components/eamxx/src/physics/rrtmgp/tests/rrtmgp_tests.cpp
index 981c8fd0f3..55cd594812 100644
--- i/components/eamxx/src/physics/rrtmgp/tests/rrtmgp_tests.cpp
+++ w/components/eamxx/src/physics/rrtmgp/tests/rrtmgp_tests.cpp
@@ -26,7 +26,9 @@ std::string coefficients_file_lw = SCREAM_DATA_DIR "/init/rrtmgp-data-lw-g256-20
 std::string cloud_optics_file_sw = SCREAM_DATA_DIR "/init/rrtmgp-cloud-optics-coeffs-sw.nc";
 std::string cloud_optics_file_lw = SCREAM_DATA_DIR "/init/rrtmgp-cloud-optics-coeffs-lw.nc";
 
-void expect_another_arg(int i, int argc) { EKAT_REQUIRE_MSG(i != argc - 1, "Expected another cmd-line arg."); }
+void expect_another_arg(int i, int argc) {
+  EKAT_REQUIRE_MSG(i != argc - 1, "Expected another cmd-line arg.");
+}
 
 #ifdef RRTMGP_ENABLE_YAKL
 int run_yakl(int argc, char **argv) {
@@ -84,7 +86,8 @@ int run_yakl(int argc, char **argv) {
   real2d sw_flux_dir_ref;
   real2d lw_flux_up_ref;
   real2d lw_flux_dn_ref;
-  rrtmgpTest::read_fluxes(inputfile, sw_flux_up_ref, sw_flux_dn_ref, sw_flux_dir_ref, lw_flux_up_ref, lw_flux_dn_ref);
+  rrtmgpTest::read_fluxes(inputfile, sw_flux_up_ref, sw_flux_dn_ref, sw_flux_dir_ref,
+                          lw_flux_up_ref, lw_flux_dn_ref);
 
   // Get dimension sizes
   int ncol = sw_flux_up_ref.dimension[0];
@@ -109,8 +112,8 @@ int run_yakl(int argc, char **argv) {
 
   // Initialize absorption coefficients
   logger->info("Initialize RRTMGP...\n");
-  scream::rrtmgp::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw, cloud_optics_file_sw,
-                                    cloud_optics_file_lw, logger);
+  scream::rrtmgp::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw,
+                                    cloud_optics_file_sw, cloud_optics_file_lw, logger);
 
   // Setup our dummy atmosphere based on the input data we read in
   logger->info("Setup dummy atmos...\n");
@@ -124,8 +127,8 @@ int run_yakl(int argc, char **argv) {
   real2d rel("rel", ncol, nlay);
   real2d rei("rei", ncol, nlay);
   real2d cld("cld", ncol, nlay);
-  rrtmgpTest::dummy_atmos(inputfile, ncol, p_lay, t_lay, sfc_alb_dir_vis, sfc_alb_dir_nir, sfc_alb_dif_vis,
-                          sfc_alb_dif_nir, mu0, lwp, iwp, rel, rei, cld);
+  rrtmgpTest::dummy_atmos(inputfile, ncol, p_lay, t_lay, sfc_alb_dir_vis, sfc_alb_dir_nir,
+                          sfc_alb_dif_vis, sfc_alb_dif_nir, mu0, lwp, iwp, rel, rei, cld);
 
   // Setup flux outputs; In a real model run, the fluxes would be
   // input/outputs into the driver (persisting between calls), and
@@ -163,8 +166,9 @@ int run_yakl(int argc, char **argv) {
   // Compute band-by-band surface_albedos.
   real2d sfc_alb_dir("sfc_alb_dir", ncol, nswbands);
   real2d sfc_alb_dif("sfc_alb_dif", ncol, nswbands);
-  rrtmgp::compute_band_by_band_surface_albedos(ncol, nswbands, sfc_alb_dir_vis, sfc_alb_dir_nir, sfc_alb_dif_vis,
-                                               sfc_alb_dif_nir, sfc_alb_dir, sfc_alb_dif);
+  rrtmgp::compute_band_by_band_surface_albedos(ncol, nswbands, sfc_alb_dir_vis, sfc_alb_dir_nir,
+                                               sfc_alb_dif_vis, sfc_alb_dif_nir, sfc_alb_dir,
+                                               sfc_alb_dif);
 
   // Setup some dummy aerosol optical properties
   auto aer_tau_sw = real3d("aer_tau_sw", ncol, nlay, nswbands);
@@ -172,7 +176,8 @@ int run_yakl(int argc, char **argv) {
   auto aer_asm_sw = real3d("aer_asm_sw", ncol, nlay, nswbands);
   auto aer_tau_lw = real3d("aer_tau_lw", ncol, nlay, nlwbands);
   yakl::fortran::parallel_for(
-      yakl::fortran::SimpleBounds<3>(nswbands, nlay, ncol), YAKL_LAMBDA(int ibnd, int ilay, int icol) {
+      yakl::fortran::SimpleBounds<3>(nswbands, nlay, ncol),
+      YAKL_LAMBDA(int ibnd, int ilay, int icol) {
         aer_tau_sw(icol, ilay, ibnd) = 0;
         aer_ssa_sw(icol, ilay, ibnd) = 0;
         aer_asm_sw(icol, ilay, ibnd) = 0;
@@ -194,20 +199,24 @@ int run_yakl(int argc, char **argv) {
   logger->info("Run RRTMGP...\n");
   const Real tsi_scaling = 1;
   scream::rrtmgp::rrtmgp_main(
-      ncol, nlay, p_lay, t_lay, p_lev, t_lev, gas_concs, sfc_alb_dir, sfc_alb_dif, mu0, lwp, iwp, rel, rei, cld,
-      aer_tau_sw, aer_ssa_sw, aer_asm_sw, aer_tau_lw, cld_tau_sw_bnd, cld_tau_lw_bnd, // outputs
-      cld_tau_sw, cld_tau_lw,                                                         // outputs
-      sw_flux_up, sw_flux_dn, sw_flux_dir, lw_flux_up, lw_flux_dn, sw_clnclrsky_flux_up, sw_clnclrsky_flux_dn,
-      sw_clnclrsky_flux_dir, sw_clrsky_flux_up, sw_clrsky_flux_dn, sw_clrsky_flux_dir, sw_clnsky_flux_up,
-      sw_clnsky_flux_dn, sw_clnsky_flux_dir, lw_clnclrsky_flux_up, lw_clnclrsky_flux_dn, lw_clrsky_flux_up,
-      lw_clrsky_flux_dn, lw_clnsky_flux_up, lw_clnsky_flux_dn, sw_bnd_flux_up, sw_bnd_flux_dn, sw_bnd_flux_dir,
-      lw_bnd_flux_up, lw_bnd_flux_dn, tsi_scaling, logger, true, true // extra_clnclrsky_diag, extra_clnsky_diag
-      // set them both to true because we are testing them below
+      ncol, nlay, p_lay, t_lay, p_lev, t_lev, gas_concs, sfc_alb_dir, sfc_alb_dif, mu0, lwp, iwp,
+      rel, rei, cld, aer_tau_sw, aer_ssa_sw, aer_asm_sw, aer_tau_lw, cld_tau_sw_bnd,
+      cld_tau_lw_bnd,         // outputs
+      cld_tau_sw, cld_tau_lw, // outputs
+      sw_flux_up, sw_flux_dn, sw_flux_dir, lw_flux_up, lw_flux_dn, sw_clnclrsky_flux_up,
+      sw_clnclrsky_flux_dn, sw_clnclrsky_flux_dir, sw_clrsky_flux_up, sw_clrsky_flux_dn,
+      sw_clrsky_flux_dir, sw_clnsky_flux_up, sw_clnsky_flux_dn, sw_clnsky_flux_dir,
+      lw_clnclrsky_flux_up, lw_clnclrsky_flux_dn, lw_clrsky_flux_up, lw_clrsky_flux_dn,
+      lw_clnsky_flux_up, lw_clnsky_flux_dn, sw_bnd_flux_up, sw_bnd_flux_dn, sw_bnd_flux_dir,
+      lw_bnd_flux_up, lw_bnd_flux_dn, tsi_scaling, logger, true,
+      true // extra_clnclrsky_diag, extra_clnsky_diag
+           // set them both to true because we are testing them below
   );
 
   // Check values against baseline
   logger->info("Check values...\n");
-  rrtmgpTest::read_fluxes(baseline, sw_flux_up_ref, sw_flux_dn_ref, sw_flux_dir_ref, lw_flux_up_ref, lw_flux_dn_ref);
+  rrtmgpTest::read_fluxes(baseline, sw_flux_up_ref, sw_flux_dn_ref, sw_flux_dir_ref, lw_flux_up_ref,
+                          lw_flux_dn_ref);
   int nerr = 0;
   if (!rrtmgpTest::all_close(sw_flux_up_ref, sw_flux_up, 0.001))
     nerr++;
@@ -369,7 +378,8 @@ int run_kokkos(int argc, char **argv) {
   real2dk sw_flux_dir_ref;
   real2dk lw_flux_up_ref;
   real2dk lw_flux_dn_ref;
-  utils_t::read_fluxes(inputfile, sw_flux_up_ref, sw_flux_dn_ref, sw_flux_dir_ref, lw_flux_up_ref, lw_flux_dn_ref);
+  utils_t::read_fluxes(inputfile, sw_flux_up_ref, sw_flux_dn_ref, sw_flux_dir_ref, lw_flux_up_ref,
+                       lw_flux_dn_ref);
 
   // Get dimension sizes
   int ncol = sw_flux_up_ref.extent(0);
@@ -394,8 +404,8 @@ int run_kokkos(int argc, char **argv) {
 
   // Initialize absorption coefficients
   logger->info("Initialize RRTMGP...\n");
-  interface_t::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw, cloud_optics_file_sw,
-                                 cloud_optics_file_lw, logger, 2.0);
+  interface_t::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw,
+                                 cloud_optics_file_sw, cloud_optics_file_lw, logger, 2.0);
 
   // Setup our dummy atmosphere based on the input data we read in
   logger->info("Setup dummy atmos...\n");
@@ -409,8 +419,8 @@ int run_kokkos(int argc, char **argv) {
   real2dk rel("rel", ncol, nlay);
   real2dk rei("rei", ncol, nlay);
   real2dk cld("cld", ncol, nlay);
-  utils_t::dummy_atmos(inputfile, ncol, p_lay, t_lay, sfc_alb_dir_vis, sfc_alb_dir_nir, sfc_alb_dif_vis,
-                       sfc_alb_dif_nir, mu0, lwp, iwp, rel, rei, cld);
+  utils_t::dummy_atmos(inputfile, ncol, p_lay, t_lay, sfc_alb_dir_vis, sfc_alb_dir_nir,
+                       sfc_alb_dif_vis, sfc_alb_dif_nir, mu0, lwp, iwp, rel, rei, cld);
 
   // Setup flux outputs; In a real model run, the fluxes would be
   // input/outputs into the driver (persisting between calls), and
@@ -448,7 +458,8 @@ int run_kokkos(int argc, char **argv) {
   // Compute band-by-band surface_albedos.
   real2dk sfc_alb_dir("sfc_alb_dir", ncol, nswbands);
   real2dk sfc_alb_dif("sfc_alb_dif", ncol, nswbands);
-  interface_t::compute_band_by_band_surface_albedos(ncol, nswbands, sfc_alb_dir_vis, sfc_alb_dir_nir, sfc_alb_dif_vis,
+  interface_t::compute_band_by_band_surface_albedos(ncol, nswbands, sfc_alb_dir_vis,
+                                                    sfc_alb_dir_nir, sfc_alb_dif_vis,
                                                     sfc_alb_dif_nir, sfc_alb_dir, sfc_alb_dif);
 
   // Setup some dummy aerosol optical properties
@@ -479,20 +490,24 @@ int run_kokkos(int argc, char **argv) {
   logger->info("Run RRTMGP...\n");
   const Real tsi_scaling = 1;
   interface_t::rrtmgp_main(
-      ncol, nlay, p_lay, t_lay, p_lev, t_lev, gas_concs, sfc_alb_dir, sfc_alb_dif, mu0, lwp, iwp, rel, rei, cld,
-      aer_tau_sw, aer_ssa_sw, aer_asm_sw, aer_tau_lw, cld_tau_sw_bnd, cld_tau_lw_bnd, // outputs
-      cld_tau_sw, cld_tau_lw,                                                         // outputs
-      sw_flux_up, sw_flux_dn, sw_flux_dir, lw_flux_up, lw_flux_dn, sw_clnclrsky_flux_up, sw_clnclrsky_flux_dn,
-      sw_clnclrsky_flux_dir, sw_clrsky_flux_up, sw_clrsky_flux_dn, sw_clrsky_flux_dir, sw_clnsky_flux_up,
-      sw_clnsky_flux_dn, sw_clnsky_flux_dir, lw_clnclrsky_flux_up, lw_clnclrsky_flux_dn, lw_clrsky_flux_up,
-      lw_clrsky_flux_dn, lw_clnsky_flux_up, lw_clnsky_flux_dn, sw_bnd_flux_up, sw_bnd_flux_dn, sw_bnd_flux_dir,
-      lw_bnd_flux_up, lw_bnd_flux_dn, tsi_scaling, logger, true, true // extra_clnclrsky_diag, extra_clnsky_diag
-      // set them both to true because we are testing them below
+      ncol, nlay, p_lay, t_lay, p_lev, t_lev, gas_concs, sfc_alb_dir, sfc_alb_dif, mu0, lwp, iwp,
+      rel, rei, cld, aer_tau_sw, aer_ssa_sw, aer_asm_sw, aer_tau_lw, cld_tau_sw_bnd,
+      cld_tau_lw_bnd,         // outputs
+      cld_tau_sw, cld_tau_lw, // outputs
+      sw_flux_up, sw_flux_dn, sw_flux_dir, lw_flux_up, lw_flux_dn, sw_clnclrsky_flux_up,
+      sw_clnclrsky_flux_dn, sw_clnclrsky_flux_dir, sw_clrsky_flux_up, sw_clrsky_flux_dn,
+      sw_clrsky_flux_dir, sw_clnsky_flux_up, sw_clnsky_flux_dn, sw_clnsky_flux_dir,
+      lw_clnclrsky_flux_up, lw_clnclrsky_flux_dn, lw_clrsky_flux_up, lw_clrsky_flux_dn,
+      lw_clnsky_flux_up, lw_clnsky_flux_dn, sw_bnd_flux_up, sw_bnd_flux_dn, sw_bnd_flux_dir,
+      lw_bnd_flux_up, lw_bnd_flux_dn, tsi_scaling, logger, true,
+      true // extra_clnclrsky_diag, extra_clnsky_diag
+           // set them both to true because we are testing them below
   );
 
   // Check values against baseline
   logger->info("Check values...\n");
-  utils_t::read_fluxes(baseline, sw_flux_up_ref, sw_flux_dn_ref, sw_flux_dir_ref, lw_flux_up_ref, lw_flux_dn_ref);
+  utils_t::read_fluxes(baseline, sw_flux_up_ref, sw_flux_dn_ref, sw_flux_dir_ref, lw_flux_up_ref,
+                       lw_flux_dn_ref);
   int nerr = 0;
   if (!utils_t::all_close(sw_flux_up_ref, sw_flux_up, 0.001))
     nerr++;
diff --git i/components/eamxx/src/physics/rrtmgp/tests/rrtmgp_unit_tests.cpp w/components/eamxx/src/physics/rrtmgp/tests/rrtmgp_unit_tests.cpp
index e3b3b0a7d4..1a64b35203 100644
--- i/components/eamxx/src/physics/rrtmgp/tests/rrtmgp_unit_tests.cpp
+++ w/components/eamxx/src/physics/rrtmgp/tests/rrtmgp_unit_tests.cpp
@@ -12,7 +12,9 @@
 namespace {
 
 #ifdef RRTMGP_ENABLE_KOKKOS
-template <typename View> auto chc(const View &view) { return Kokkos::create_mirror_view_and_copy(HostDevice(), view); }
+template <typename View> auto chc(const View &view) {
+  return Kokkos::create_mirror_view_and_copy(HostDevice(), view);
+}
 #endif
 
 // Names of input files we will need.
@@ -105,8 +107,9 @@ TEST_CASE("rrtmgp_test_mixing_ratio_to_cloud_mass") {
         mixing_ratio(1, 1)   = 0.0001;
         cloud_fraction(1, 1) = 1.0;
       });
-  auto cloud_mass_ref = mixing_ratio.createHostCopy()(1, 1) / cloud_fraction.createHostCopy()(1, 1) *
-                        dp.createHostCopy()(1, 1) / physconst::gravit;
+  auto cloud_mass_ref = mixing_ratio.createHostCopy()(1, 1) /
+                        cloud_fraction.createHostCopy()(1, 1) * dp.createHostCopy()(1, 1) /
+                        physconst::gravit;
   scream::rrtmgp::mixing_ratio_to_cloud_mass(mixing_ratio, cloud_fraction, dp, cloud_mass);
   REQUIRE(cloud_mass.createHostCopy()(1, 1) == cloud_mass_ref);
 
@@ -278,8 +281,8 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux") {
   string1dv gas_names = {"h2o", "co2", "o3", "n2o", "co", "ch4", "o2", "n2"};
   gas_concs.init(gas_names, ncol, nlay);
   logger->info("Init RRTMGP...\n");
-  scream::rrtmgp::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw, cloud_optics_file_sw,
-                                    cloud_optics_file_lw, logger);
+  scream::rrtmgp::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw,
+                                    cloud_optics_file_sw, cloud_optics_file_lw, logger);
 
   // Create simple test cases; We expect, given the input data, that band 10
   // will straddle the NIR and VIS, bands 1-9 will be purely NIR, and bands 11-14
@@ -292,9 +295,11 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux") {
   // Test case: flux only in straddled band
   auto sw_bnd_flux_dir = real3d("sw_bnd_flux_dir", ncol, nlay + 1, nbnd);
   auto sw_bnd_flux_dif = real3d("sw_bnd_flux_dif", ncol, nlay + 1, nbnd);
-  logger->info("Populate band-resolved 3d fluxes for test case with only transition band flux...\n");
+  logger->info(
+      "Populate band-resolved 3d fluxes for test case with only transition band flux...\n");
   yakl::fortran::parallel_for(
-      yakl::fortran::SimpleBounds<3>(nbnd, nlay + 1, ncol), YAKL_LAMBDA(int ibnd, int ilay, int icol) {
+      yakl::fortran::SimpleBounds<3>(nbnd, nlay + 1, ncol),
+      YAKL_LAMBDA(int ibnd, int ilay, int icol) {
         if (ibnd < 10) {
           sw_bnd_flux_dir(icol, ilay, ibnd) = 0;
           sw_bnd_flux_dif(icol, ilay, ibnd) = 0;
@@ -308,8 +313,9 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux") {
       });
   // Compute surface fluxes
   logger->info("Compute broadband surface fluxes...\n");
-  scream::rrtmgp::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis,
-                                                   sfc_flux_dir_nir, sfc_flux_dif_vis, sfc_flux_dif_nir);
+  scream::rrtmgp::compute_broadband_surface_fluxes(
+      ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis, sfc_flux_dir_nir,
+      sfc_flux_dif_vis, sfc_flux_dif_nir);
   // Check computed surface fluxes
   logger->info("Check computed fluxes...\n");
   const double tol = 1e-10; // tolerance on floating point inequality for assertions
@@ -323,7 +329,8 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux") {
   // Test case, only flux in NIR bands
   logger->info("Populate band-resolved 3d fluxes for test case with only NIR flux...\n");
   yakl::fortran::parallel_for(
-      yakl::fortran::SimpleBounds<3>(nbnd, nlay + 1, ncol), YAKL_LAMBDA(int ibnd, int ilay, int icol) {
+      yakl::fortran::SimpleBounds<3>(nbnd, nlay + 1, ncol),
+      YAKL_LAMBDA(int ibnd, int ilay, int icol) {
         if (ibnd < 10) {
           sw_bnd_flux_dir(icol, ilay, ibnd) = 1;
           sw_bnd_flux_dif(icol, ilay, ibnd) = 1;
@@ -337,8 +344,9 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux") {
       });
   // Compute surface fluxes
   logger->info("Compute broadband surface fluxes...\n");
-  scream::rrtmgp::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis,
-                                                   sfc_flux_dir_nir, sfc_flux_dif_vis, sfc_flux_dif_nir);
+  scream::rrtmgp::compute_broadband_surface_fluxes(
+      ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis, sfc_flux_dir_nir,
+      sfc_flux_dif_vis, sfc_flux_dif_nir);
   // Check computed surface fluxes
   logger->info("Check computed fluxes...\n");
   REQUIRE(std::abs(sfc_flux_dir_nir.createHostCopy()(1) - 9.0) < tol);
@@ -351,7 +359,8 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux") {
   // Test case, only flux in VIS bands
   logger->info("Populate band-resolved 3d fluxes for test case with only VIS/UV flux...\n");
   yakl::fortran::parallel_for(
-      yakl::fortran::SimpleBounds<3>(nbnd, nlay + 1, ncol), YAKL_LAMBDA(int ibnd, int ilay, int icol) {
+      yakl::fortran::SimpleBounds<3>(nbnd, nlay + 1, ncol),
+      YAKL_LAMBDA(int ibnd, int ilay, int icol) {
         if (ibnd < 10) {
           sw_bnd_flux_dir(icol, ilay, ibnd) = 0;
           sw_bnd_flux_dif(icol, ilay, ibnd) = 0;
@@ -365,8 +374,9 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux") {
       });
   // Compute surface fluxes
   logger->info("Compute broadband surface fluxes...\n");
-  scream::rrtmgp::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis,
-                                                   sfc_flux_dir_nir, sfc_flux_dif_vis, sfc_flux_dif_nir);
+  scream::rrtmgp::compute_broadband_surface_fluxes(
+      ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis, sfc_flux_dir_nir,
+      sfc_flux_dif_vis, sfc_flux_dif_nir);
   // Check computed surface fluxes
   logger->info("Check computed fluxes...\n");
   REQUIRE(std::abs(sfc_flux_dir_nir.createHostCopy()(1) - 0.0) < tol);
@@ -379,7 +389,8 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux") {
   // Test case, only flux in all bands
   logger->info("Populate band-resolved 3d fluxes for test with non-zero flux in all bands...\n");
   yakl::fortran::parallel_for(
-      yakl::fortran::SimpleBounds<3>(nbnd, nlay + 1, ncol), YAKL_LAMBDA(int ibnd, int ilay, int icol) {
+      yakl::fortran::SimpleBounds<3>(nbnd, nlay + 1, ncol),
+      YAKL_LAMBDA(int ibnd, int ilay, int icol) {
         if (ibnd < 10) {
           sw_bnd_flux_dir(icol, ilay, ibnd) = 1.0;
           sw_bnd_flux_dif(icol, ilay, ibnd) = 2.0;
@@ -393,8 +404,9 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux") {
       });
   // Compute surface fluxes
   logger->info("Compute broadband surface fluxes...\n");
-  scream::rrtmgp::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis,
-                                                   sfc_flux_dir_nir, sfc_flux_dif_vis, sfc_flux_dif_nir);
+  scream::rrtmgp::compute_broadband_surface_fluxes(
+      ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis, sfc_flux_dir_nir,
+      sfc_flux_dif_vis, sfc_flux_dif_nir);
   // Check computed surface fluxes
   logger->info("Check computed fluxes...\n");
   REQUIRE(std::abs(sfc_flux_dir_nir.createHostCopy()(1) - 10.5) < tol);
@@ -498,10 +510,11 @@ TEST_CASE("rrtmgp_test_subcol_gen") {
           }
         });
     yakl::fortran::parallel_for(
-        yakl::fortran::SimpleBounds<2>(nlay, ncol),
-        YAKL_LAMBDA(int ilay, int icol) { cldfrac_from_mask(icol, ilay) = cldfrac_from_mask(icol, ilay) / ngpt; });
-    // For cldfrac 1 we should get 1, for cldfrac 0 we should get 0, but in between we cannot be sure
-    // deterministically, since the computed cloud mask depends on pseudo-random numbers
+        yakl::fortran::SimpleBounds<2>(nlay, ncol), YAKL_LAMBDA(int ilay, int icol) {
+          cldfrac_from_mask(icol, ilay) = cldfrac_from_mask(icol, ilay) / ngpt;
+        });
+    // For cldfrac 1 we should get 1, for cldfrac 0 we should get 0, but in between we cannot be
+    // sure deterministically, since the computed cloud mask depends on pseudo-random numbers
     REQUIRE(cldfrac_from_mask.createHostCopy()(1, 1) == 1);
     REQUIRE(cldfrac_from_mask.createHostCopy()(1, 2) <= 1);
     REQUIRE(cldfrac_from_mask.createHostCopy()(1, 3) == 0);
@@ -573,8 +586,8 @@ TEST_CASE("rrtmgp_cloud_area") {
         cldtau(1, 2, 2) = 0;
         cldtau(1, 2, 3) = 0;
       });
-  scream::rrtmgp::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(), pmid, cldtau,
-                                     cldtot);
+  scream::rrtmgp::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(),
+                                     pmid, cldtau, cldtot);
   REQUIRE(cldtot.createHostCopy()(1) == 0.0);
 
   // Case:
@@ -592,8 +605,8 @@ TEST_CASE("rrtmgp_cloud_area") {
         cldtau(1, 2, 2) = 1;
         cldtau(1, 2, 3) = 1;
       });
-  scream::rrtmgp::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(), pmid, cldtau,
-                                     cldtot);
+  scream::rrtmgp::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(),
+                                     pmid, cldtau, cldtot);
   REQUIRE(cldtot.createHostCopy()(1) == 1.0);
 
   // Case:
@@ -611,8 +624,8 @@ TEST_CASE("rrtmgp_cloud_area") {
         cldtau(1, 2, 2) = 0;
         cldtau(1, 2, 3) = 1.0;
       });
-  scream::rrtmgp::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(), pmid, cldtau,
-                                     cldtot);
+  scream::rrtmgp::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(),
+                                     pmid, cldtau, cldtot);
   REQUIRE(cldtot.createHostCopy()(1) == 1.0);
   scream::rrtmgp::compute_cloud_area(ncol, nlay, ngpt, 0, 150, pmid, cldtau, cldtot);
   REQUIRE(cldtot.createHostCopy()(1) == 2.0 / 3.0);
@@ -634,8 +647,8 @@ TEST_CASE("rrtmgp_cloud_area") {
         cldtau(1, 2, 2) = 0;
         cldtau(1, 2, 3) = 1;
       });
-  scream::rrtmgp::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(), pmid, cldtau,
-                                     cldtot);
+  scream::rrtmgp::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(),
+                                     pmid, cldtau, cldtot);
   REQUIRE(cldtot.createHostCopy()(1) == 2.0 / 3.0);
   scream::rrtmgp::compute_cloud_area(ncol, nlay, ngpt, 0, 100, pmid, cldtau, cldtot);
   REQUIRE(cldtot.createHostCopy()(1) == 0.0);
@@ -688,10 +701,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop") {
   memset(rel, 10.0);
   memset(rei, 10.0);
   // Call the function
-  scream::rrtmgp::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                           tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                           cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                           eff_radius_qi_at_cldtop);
+  scream::rrtmgp::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   // Check the results
   REQUIRE(tmid_at_cldtop.createHostCopy()(1) == 0.0);
@@ -705,10 +718,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop") {
 
   // Case 2: if all clouds, everything goes to 1 * its value
   memset(cldfrac_tot, 1.0);
-  scream::rrtmgp::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                           tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                           cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                           eff_radius_qi_at_cldtop);
+  scream::rrtmgp::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(tmid_at_cldtop.createHostCopy()(1) == 300.0);
   REQUIRE(pmid_at_cldtop.createHostCopy()(1) == 100.0);
@@ -728,10 +741,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop") {
         cldfrac_tot(1, 4) = 0.3;
         cldfrac_tot(1, 5) = 0.2;
       });
-  scream::rrtmgp::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                           tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                           cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                           eff_radius_qi_at_cldtop);
+  scream::rrtmgp::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(cldfrac_tot_at_cldtop.createHostCopy()(1) == .7);
 
@@ -744,10 +757,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop") {
         cldfrac_tot(1, 6) = 0.4;
         cldfrac_tot(1, 7) = 0.2;
       });
-  scream::rrtmgp::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                           tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                           cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                           eff_radius_qi_at_cldtop);
+  scream::rrtmgp::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(cldfrac_tot_at_cldtop.createHostCopy()(1) > .7);
 
@@ -758,10 +771,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop") {
         cldfrac_tot(1, 5) = 0.0;
         cldfrac_tot(1, 6) = 0.1;
       });
-  scream::rrtmgp::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                           tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                           cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                           eff_radius_qi_at_cldtop);
+  scream::rrtmgp::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(cldfrac_tot_at_cldtop.createHostCopy()(1) > .7); // larger than the max
 
@@ -774,10 +787,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop") {
       });
   memset(qc, 1.0);
   memset(qi, 0.0);
-  scream::rrtmgp::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                           tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                           cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                           eff_radius_qi_at_cldtop);
+  scream::rrtmgp::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(cldfrac_tot_at_cldtop.createHostCopy()(1) == 1.0);
   REQUIRE(cldfrac_liq_at_cldtop.createHostCopy()(1) == 1.0);
@@ -792,10 +805,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop") {
       });
   memset(qc, 0.0);
   memset(qi, 1.0);
-  scream::rrtmgp::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                           tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                           cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                           eff_radius_qi_at_cldtop);
+  scream::rrtmgp::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(cldfrac_tot_at_cldtop.createHostCopy()(1) == 1.0);
   REQUIRE(cldfrac_liq_at_cldtop.createHostCopy()(1) == 0.0);
@@ -828,10 +841,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop") {
         qc(1, 7) = 50;
         qc(1, 8) = 10;
       });
-  scream::rrtmgp::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                           tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                           cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                           eff_radius_qi_at_cldtop);
+  scream::rrtmgp::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
   REQUIRE(cldfrac_tot_at_cldtop.createHostCopy()(1) > 0.70); // unaffected
   REQUIRE(cldfrac_liq_at_cldtop.createHostCopy()(1) < 0.50); // not max
   REQUIRE(cldfrac_ice_at_cldtop.createHostCopy()(1) == 0.7); // max
@@ -950,7 +963,8 @@ TEST_CASE("rrtmgp_test_mixing_ratio_to_cloud_mass_k") {
         mixing_ratio(0, 0)   = 0.0001;
         cloud_fraction(0, 0) = 1.0;
       });
-  auto cloud_mass_ref = chc(mixing_ratio)(0, 0) / chc(cloud_fraction)(0, 0) * chc(dp)(0, 0) / physconst::gravit;
+  auto cloud_mass_ref =
+      chc(mixing_ratio)(0, 0) / chc(cloud_fraction)(0, 0) * chc(dp)(0, 0) / physconst::gravit;
   interface_t::mixing_ratio_to_cloud_mass(mixing_ratio, cloud_fraction, dp, cloud_mass);
   REQUIRE(chc(cloud_mass)(0, 0) == cloud_mass_ref);
 
@@ -985,7 +999,8 @@ TEST_CASE("rrtmgp_test_mixing_ratio_to_cloud_mass_k") {
         mixing_ratio(0, 0)   = 0.0001;
         cloud_fraction(0, 0) = 0.5;
       });
-  cloud_mass_ref = chc(mixing_ratio)(0, 0) / chc(cloud_fraction)(0, 0) * chc(dp)(0, 0) / physconst::gravit;
+  cloud_mass_ref =
+      chc(mixing_ratio)(0, 0) / chc(cloud_fraction)(0, 0) * chc(dp)(0, 0) / physconst::gravit;
   interface_t::mixing_ratio_to_cloud_mass(mixing_ratio, cloud_fraction, dp, cloud_mass);
   REQUIRE(chc(cloud_mass)(0, 0) == cloud_mass_ref);
 
@@ -1116,8 +1131,8 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux_k") {
   string1dv gas_names = {"h2o", "co2", "o3", "n2o", "co", "ch4", "o2", "n2"};
   gas_concs.init(gas_names, ncol, nlay);
   logger->info("Init RRTMGP...\n");
-  interface_t::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw, cloud_optics_file_sw,
-                                 cloud_optics_file_lw, logger);
+  interface_t::rrtmgp_initialize(gas_concs, coefficients_file_sw, coefficients_file_lw,
+                                 cloud_optics_file_sw, cloud_optics_file_lw, logger);
 
   // Create simple test cases; We expect, given the input data, that band 10
   // will straddle the NIR and VIS, bands 1-9 will be purely NIR, and bands 11-14
@@ -1130,7 +1145,8 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux_k") {
   // Test case: flux only in straddled band
   auto sw_bnd_flux_dir = real3dk("sw_bnd_flux_dir", ncol, nlay + 1, nbnd);
   auto sw_bnd_flux_dif = real3dk("sw_bnd_flux_dif", ncol, nlay + 1, nbnd);
-  logger->info("Populate band-resolved 3d fluxes for test case with only transition band flux...\n");
+  logger->info(
+      "Populate band-resolved 3d fluxes for test case with only transition band flux...\n");
   Kokkos::parallel_for(
       MDRP::template get<3>({ncol, nlay + 1, nbnd}), KOKKOS_LAMBDA(int icol, int ilay, int ibnd) {
         if (ibnd < 9) {
@@ -1146,8 +1162,9 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux_k") {
       });
   // Compute surface fluxes
   logger->info("Compute broadband surface fluxes...\n");
-  interface_t::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis,
-                                                sfc_flux_dir_nir, sfc_flux_dif_vis, sfc_flux_dif_nir);
+  interface_t::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif,
+                                                sfc_flux_dir_vis, sfc_flux_dir_nir,
+                                                sfc_flux_dif_vis, sfc_flux_dif_nir);
   // Check computed surface fluxes
   logger->info("Check computed fluxes...\n");
   const double tol = 1e-10; // tolerance on floating point inequality for assertions
@@ -1175,8 +1192,9 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux_k") {
       });
   // Compute surface fluxes
   logger->info("Compute broadband surface fluxes...\n");
-  interface_t::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis,
-                                                sfc_flux_dir_nir, sfc_flux_dif_vis, sfc_flux_dif_nir);
+  interface_t::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif,
+                                                sfc_flux_dir_vis, sfc_flux_dir_nir,
+                                                sfc_flux_dif_vis, sfc_flux_dif_nir);
   // Check computed surface fluxes
   logger->info("Check computed fluxes...\n");
   REQUIRE(std::abs(chc(sfc_flux_dir_nir)(0) - 9.0) < tol);
@@ -1203,8 +1221,9 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux_k") {
       });
   // Compute surface fluxes
   logger->info("Compute broadband surface fluxes...\n");
-  interface_t::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis,
-                                                sfc_flux_dir_nir, sfc_flux_dif_vis, sfc_flux_dif_nir);
+  interface_t::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif,
+                                                sfc_flux_dir_vis, sfc_flux_dir_nir,
+                                                sfc_flux_dif_vis, sfc_flux_dif_nir);
   // Check computed surface fluxes
   logger->info("Check computed fluxes...\n");
   REQUIRE(std::abs(chc(sfc_flux_dir_nir)(0) - 0.0) < tol);
@@ -1231,8 +1250,9 @@ TEST_CASE("rrtmgp_test_compute_broadband_surface_flux_k") {
       });
   // Compute surface fluxes
   logger->info("Compute broadband surface fluxes...\n");
-  interface_t::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif, sfc_flux_dir_vis,
-                                                sfc_flux_dir_nir, sfc_flux_dif_vis, sfc_flux_dif_nir);
+  interface_t::compute_broadband_surface_fluxes(ncol, kbot, nbnd, sw_bnd_flux_dir, sw_bnd_flux_dif,
+                                                sfc_flux_dir_vis, sfc_flux_dir_nir,
+                                                sfc_flux_dif_vis, sfc_flux_dif_nir);
   // Check computed surface fluxes
   logger->info("Check computed fluxes...\n");
   REQUIRE(std::abs(chc(sfc_flux_dir_nir)(0) - 10.5) < tol);
@@ -1325,10 +1345,11 @@ TEST_CASE("rrtmgp_test_subcol_gen_k") {
           }
         });
     Kokkos::parallel_for(
-        MDRP::template get<2>({ncol, nlay}),
-        KOKKOS_LAMBDA(int icol, int ilay) { cldfrac_from_mask(icol, ilay) = cldfrac_from_mask(icol, ilay) / ngpt; });
-    // For cldfrac 1 we should get 1, for cldfrac 0 we should get 0, but in between we cannot be sure
-    // deterministically, since the computed cloud mask depends on pseudo-random numbers
+        MDRP::template get<2>({ncol, nlay}), KOKKOS_LAMBDA(int icol, int ilay) {
+          cldfrac_from_mask(icol, ilay) = cldfrac_from_mask(icol, ilay) / ngpt;
+        });
+    // For cldfrac 1 we should get 1, for cldfrac 0 we should get 0, but in between we cannot be
+    // sure deterministically, since the computed cloud mask depends on pseudo-random numbers
     REQUIRE(chc(cldfrac_from_mask)(0, 0) == 1);
     REQUIRE(chc(cldfrac_from_mask)(0, 1) <= 1);
     REQUIRE(chc(cldfrac_from_mask)(0, 2) == 0);
@@ -1397,7 +1418,8 @@ TEST_CASE("rrtmgp_cloud_area_k") {
         cldtau(0, 1, 1) = 0;
         cldtau(0, 1, 2) = 0;
       });
-  interface_t::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(), pmid, cldtau, cldtot);
+  interface_t::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(),
+                                  pmid, cldtau, cldtot);
   REQUIRE(chc(cldtot)(0) == 0.0);
 
   // Case:
@@ -1415,7 +1437,8 @@ TEST_CASE("rrtmgp_cloud_area_k") {
         cldtau(0, 1, 1) = 1;
         cldtau(0, 1, 2) = 1;
       });
-  interface_t::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(), pmid, cldtau, cldtot);
+  interface_t::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(),
+                                  pmid, cldtau, cldtot);
   REQUIRE(chc(cldtot)(0) == 1.0);
 
   // Case:
@@ -1433,7 +1456,8 @@ TEST_CASE("rrtmgp_cloud_area_k") {
         cldtau(0, 1, 1) = 0;
         cldtau(0, 1, 2) = 1.0;
       });
-  interface_t::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(), pmid, cldtau, cldtot);
+  interface_t::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(),
+                                  pmid, cldtau, cldtot);
   REQUIRE(chc(cldtot)(0) == 1.0);
   interface_t::compute_cloud_area(ncol, nlay, ngpt, 0, 150, pmid, cldtau, cldtot);
   REQUIRE(chc(cldtot)(0) == 2.0 / 3.0);
@@ -1455,7 +1479,8 @@ TEST_CASE("rrtmgp_cloud_area_k") {
         cldtau(0, 1, 1) = 0;
         cldtau(0, 1, 2) = 1;
       });
-  interface_t::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(), pmid, cldtau, cldtot);
+  interface_t::compute_cloud_area(ncol, nlay, ngpt, 0, std::numeric_limits<scream::Real>::max(),
+                                  pmid, cldtau, cldtot);
   REQUIRE(chc(cldtot)(0) == 2.0 / 3.0);
   interface_t::compute_cloud_area(ncol, nlay, ngpt, 0, 100, pmid, cldtau, cldtot);
   REQUIRE(chc(cldtot)(0) == 0.0);
@@ -1506,10 +1531,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop_k") {
   Kokkos::deep_copy(rel, 10.0);
   Kokkos::deep_copy(rei, 10.0);
   // Call the function
-  interface_t::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                        tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                        cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                        eff_radius_qi_at_cldtop);
+  interface_t::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   // Check the results
   REQUIRE(chc(tmid_at_cldtop)(0) == 0.0);
@@ -1523,10 +1548,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop_k") {
 
   // Case 2: if all clouds, everything goes to 1 * its value
   Kokkos::deep_copy(cldfrac_tot, 1.0);
-  interface_t::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                        tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                        cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                        eff_radius_qi_at_cldtop);
+  interface_t::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(chc(tmid_at_cldtop)(0) == 300.0);
   REQUIRE(chc(pmid_at_cldtop)(0) == 100.0);
@@ -1546,10 +1571,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop_k") {
         cldfrac_tot(0, 3) = 0.3;
         cldfrac_tot(0, 4) = 0.2;
       });
-  interface_t::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                        tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                        cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                        eff_radius_qi_at_cldtop);
+  interface_t::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(chc(cldfrac_tot_at_cldtop)(0) == .7);
 
@@ -1562,10 +1587,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop_k") {
         cldfrac_tot(0, 5) = 0.4;
         cldfrac_tot(0, 6) = 0.2;
       });
-  interface_t::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                        tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                        cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                        eff_radius_qi_at_cldtop);
+  interface_t::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(chc(cldfrac_tot_at_cldtop)(0) > .7);
 
@@ -1576,10 +1601,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop_k") {
         cldfrac_tot(0, 4) = 0.0;
         cldfrac_tot(0, 5) = 0.1;
       });
-  interface_t::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                        tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                        cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                        eff_radius_qi_at_cldtop);
+  interface_t::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(chc(cldfrac_tot_at_cldtop)(0) > .7); // larger than the max
 
@@ -1592,10 +1617,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop_k") {
       });
   Kokkos::deep_copy(qc, 1.0);
   Kokkos::deep_copy(qi, 0.0);
-  interface_t::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                        tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                        cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                        eff_radius_qi_at_cldtop);
+  interface_t::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(chc(cldfrac_tot_at_cldtop)(0) == 1.0);
   REQUIRE(chc(cldfrac_liq_at_cldtop)(0) == 1.0);
@@ -1610,10 +1635,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop_k") {
       });
   Kokkos::deep_copy(qc, 0.0);
   Kokkos::deep_copy(qi, 1.0);
-  interface_t::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                        tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                        cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                        eff_radius_qi_at_cldtop);
+  interface_t::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
 
   REQUIRE(chc(cldfrac_tot_at_cldtop)(0) == 1.0);
   REQUIRE(chc(cldfrac_liq_at_cldtop)(0) == 0.0);
@@ -1646,10 +1671,10 @@ TEST_CASE("rrtmgp_aerocom_cloudtop_k") {
         qc(0, 6) = 50;
         qc(0, 7) = 10;
       });
-  interface_t::compute_aerocom_cloudtop(ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc,
-                                        tmid_at_cldtop, pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop,
-                                        cldfrac_tot_at_cldtop, cdnc_at_cldtop, eff_radius_qc_at_cldtop,
-                                        eff_radius_qi_at_cldtop);
+  interface_t::compute_aerocom_cloudtop(
+      ncol, nlay, tmid, pmid, p_del, z_del, qc, qi, rel, rei, cldfrac_tot, nc, tmid_at_cldtop,
+      pmid_at_cldtop, cldfrac_ice_at_cldtop, cldfrac_liq_at_cldtop, cldfrac_tot_at_cldtop,
+      cdnc_at_cldtop, eff_radius_qc_at_cldtop, eff_radius_qi_at_cldtop);
   REQUIRE(chc(cldfrac_tot_at_cldtop)(0) > 0.70); // unaffected
   REQUIRE(chc(cldfrac_liq_at_cldtop)(0) < 0.50); // not max
   REQUIRE(chc(cldfrac_ice_at_cldtop)(0) == 0.7); // max
diff --git i/components/eamxx/src/physics/share/eamxx_trcmix.cpp w/components/eamxx/src/physics/share/eamxx_trcmix.cpp
index 2eace83c0b..0471470cb1 100644
--- i/components/eamxx/src/physics/share/eamxx_trcmix.cpp
+++ w/components/eamxx/src/physics/share/eamxx_trcmix.cpp
@@ -16,7 +16,8 @@ void trcmix(const std::string &name, const int nlevs,
             trcmix_view1d<const Real> const &clat, // latitude for columns in degrees
             trcmix_view2d<const Real> const &pmid, // model pressures
             trcmix_view2d<Real> &q,                // constituent mass mixing ratio (output)
-            const Real co2vmr, const Real n2ovmr, const Real ch4vmr, const Real f11vmr, const Real f12vmr) {
+            const Real co2vmr, const Real n2ovmr, const Real ch4vmr, const Real f11vmr,
+            const Real f12vmr) {
   using C          = Constants<Real>;
   using KT         = KokkosTypes<DefaultDevice>;
   using ExeSpace   = KT::ExeSpace;
@@ -40,10 +41,11 @@ void trcmix(const std::string &name, const int nlevs,
   const auto rmwco2 = mwco2 / C::MWdry;
 
   // Constants map: gas_name -> [trop_mmr, scale1_base, scale1_fact, scale2_base, scale2_fact]
-  std::map<std::string, std::vector<Real>> const_map = {{"ch4", {rmwch4 * ch4vmr, 0.2353, 0., 0.2353, 0.0225489}},
-                                                        {"n2o", {rmwn2o * n2ovmr, 0.3478, 0.00116, 0.4000, 0.013333}},
-                                                        {"cfc11", {rmwf11 * f11vmr, 0.7273, 0.00606, 1., 0.013333}},
-                                                        {"cfc12", {rmwf12 * f12vmr, 0.4000, 0.00222, 0.5, 0.024444}}};
+  std::map<std::string, std::vector<Real>> const_map = {
+      {"ch4", {rmwch4 * ch4vmr, 0.2353, 0., 0.2353, 0.0225489}},
+      {"n2o", {rmwn2o * n2ovmr, 0.3478, 0.00116, 0.4000, 0.013333}},
+      {"cfc11", {rmwf11 * f11vmr, 0.7273, 0.00606, 1., 0.013333}},
+      {"cfc12", {rmwf12 * f12vmr, 0.4000, 0.00222, 0.5, 0.024444}}};
 
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(ncols, nlevs);
 
@@ -52,7 +54,8 @@ void trcmix(const std::string &name, const int nlevs,
     Kokkos::parallel_for(
         policy, KOKKOS_LAMBDA(const MemberType &team) {
           const Int i = team.league_rank();
-          Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlevs), [&](const Int &k) { q(i, k) = val; });
+          Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlevs),
+                               [&](const Int &k) { q(i, k) = val; });
         });
   } else {
     const auto it = const_map.find(name);
@@ -72,8 +75,8 @@ void trcmix(const std::string &name, const int nlevs,
             // clat to radians
             const auto clat_r = clat(i) * C::Pi / 180.0;
             const auto dlat   = std::abs(57.2958 * clat_r);
-            const auto scale =
-                dlat <= 45.0 ? scale1_base + scale1_fact * dlat : scale2_base + scale2_fact * (dlat - 45);
+            const auto scale  = dlat <= 45.0 ? scale1_base + scale1_fact * dlat
+                                             : scale2_base + scale2_fact * (dlat - 45);
 
             // pressure of tropopause
             const auto ptrop = 250.0e2 - 150.0e2 * std::pow(std::cos(clat_r), 2);
diff --git i/components/eamxx/src/physics/share/eamxx_trcmix.hpp w/components/eamxx/src/physics/share/eamxx_trcmix.hpp
index 241c463b45..9cf8a7cd37 100644
--- i/components/eamxx/src/physics/share/eamxx_trcmix.hpp
+++ w/components/eamxx/src/physics/share/eamxx_trcmix.hpp
@@ -10,9 +10,11 @@
 namespace scream {
 namespace physics {
 
-template <typename Scalar> using trcmix_view1d = typename ekat::KokkosTypes<DefaultDevice>::template view_1d<Scalar>;
+template <typename Scalar>
+using trcmix_view1d = typename ekat::KokkosTypes<DefaultDevice>::template view_1d<Scalar>;
 
-template <typename Scalar> using trcmix_view2d = typename ekat::KokkosTypes<DefaultDevice>::template view_2d<Scalar>;
+template <typename Scalar>
+using trcmix_view2d = typename ekat::KokkosTypes<DefaultDevice>::template view_2d<Scalar>;
 
 // NOTE: nlevs be smaller than pmid/q extent, in case one/both of them are padded
 void trcmix(const std::string &name,               // constituent name
diff --git i/components/eamxx/src/physics/share/physics_constants.hpp w/components/eamxx/src/physics/share/physics_constants.hpp
index 1740006f41..0a34c96ef9 100644
--- i/components/eamxx/src/physics/share/physics_constants.hpp
+++ w/components/eamxx/src/physics/share/physics_constants.hpp
@@ -34,45 +34,47 @@ template <typename Scalar> struct Constants {
   static constexpr Scalar o2mmr       = 0.23143; // o2 mass mixing ratio
   static constexpr Scalar ep_2 =
       MWH2O / MWdry; // ratio of molecular mass of water to the molecular mass of dry air !0.622
-  static constexpr Scalar gravit          = 9.80616;
-  static constexpr Scalar LatVap          = 2501000.0;
-  static constexpr Scalar LatIce          = 333700.0;
-  static constexpr Scalar CpLiq           = 4188.0;
-  static constexpr Scalar Tmelt           = 273.15;
-  static constexpr Scalar T_zerodegc      = Tmelt;
-  static constexpr Scalar T_homogfrz      = Tmelt - 40;
-  static constexpr Scalar T_rainfrz       = Tmelt - 4;
-  static constexpr Scalar Pi              = 3.14159265358979323;
-  static constexpr Scalar RHOW            = RHO_H2O;
-  static constexpr Scalar INV_RHOW        = 1.0 / RHOW;
-  static constexpr Scalar RHO_RIMEMIN     = 50.0;              // Min limit for rime density [kg m-3]
-  static constexpr Scalar RHO_RIMEMAX     = 900.0;             // Max limit for rime density [kg m-3]
-  static constexpr Scalar INV_RHO_RIMEMAX = 1.0 / RHO_RIMEMAX; // Inverse for limits for rime density [kg m-3]
-  static constexpr Scalar THIRD           = 1.0 / 3.0;
-  static constexpr Scalar SXTH            = 1.0 / 6.0;
-  static constexpr Scalar PIOV3           = Pi * THIRD;
-  static constexpr Scalar PIOV6           = Pi * SXTH;
-  static constexpr Scalar BIMM            = 2.0;
-  static constexpr Scalar CONS1           = PIOV6 * RHOW;
-  static constexpr Scalar CONS2           = 4. * PIOV3 * RHOW;
-  static constexpr Scalar CONS3           = 1.0 / (CONS2 * 1.562500000000000e-14); // 1./(CONS2*pow(25.e-6,3.0));
-  static constexpr Scalar CONS5           = PIOV6 * BIMM;
-  static constexpr Scalar CONS6           = PIOV6 * PIOV6 * RHOW * BIMM;
-  static constexpr Scalar CONS7           = 4. * PIOV3 * RHOW * 1.e-18;
-  static constexpr Scalar QSMALL          = 1.e-14;
-  static constexpr Scalar QTENDSMALL      = 1e-20;
-  static constexpr Scalar BSMALL          = 1.e-15;
-  static constexpr Scalar NSMALL          = 1.e-16;
-  static constexpr Scalar ZERO            = 0.0;
-  static constexpr Scalar ONE             = 1.0;
-  static constexpr Scalar P0              = 100000.0; // reference pressure, Pa
-  static constexpr Scalar RD              = Rair;     // gas constant for dry air, J/kg/K
-  static constexpr Scalar RHOSUR          = P0 / (RD * Tmelt);
-  static constexpr Scalar rhosui          = 60000 / (RD * 253.15);
-  static constexpr Scalar RHO_1000MB      = P0 / (RD * Tmelt);
-  static constexpr Scalar RHO_600MB       = 60000 / (RD * 253.15);
-  static constexpr Scalar CP              = Cpair; // heat constant of air at constant pressure, J/kg
-  static constexpr Scalar INV_CP          = 1.0 / CP;
+  static constexpr Scalar gravit      = 9.80616;
+  static constexpr Scalar LatVap      = 2501000.0;
+  static constexpr Scalar LatIce      = 333700.0;
+  static constexpr Scalar CpLiq       = 4188.0;
+  static constexpr Scalar Tmelt       = 273.15;
+  static constexpr Scalar T_zerodegc  = Tmelt;
+  static constexpr Scalar T_homogfrz  = Tmelt - 40;
+  static constexpr Scalar T_rainfrz   = Tmelt - 4;
+  static constexpr Scalar Pi          = 3.14159265358979323;
+  static constexpr Scalar RHOW        = RHO_H2O;
+  static constexpr Scalar INV_RHOW    = 1.0 / RHOW;
+  static constexpr Scalar RHO_RIMEMIN = 50.0;  // Min limit for rime density [kg m-3]
+  static constexpr Scalar RHO_RIMEMAX = 900.0; // Max limit for rime density [kg m-3]
+  static constexpr Scalar INV_RHO_RIMEMAX =
+      1.0 / RHO_RIMEMAX; // Inverse for limits for rime density [kg m-3]
+  static constexpr Scalar THIRD = 1.0 / 3.0;
+  static constexpr Scalar SXTH  = 1.0 / 6.0;
+  static constexpr Scalar PIOV3 = Pi * THIRD;
+  static constexpr Scalar PIOV6 = Pi * SXTH;
+  static constexpr Scalar BIMM  = 2.0;
+  static constexpr Scalar CONS1 = PIOV6 * RHOW;
+  static constexpr Scalar CONS2 = 4. * PIOV3 * RHOW;
+  static constexpr Scalar CONS3 =
+      1.0 / (CONS2 * 1.562500000000000e-14); // 1./(CONS2*pow(25.e-6,3.0));
+  static constexpr Scalar CONS5      = PIOV6 * BIMM;
+  static constexpr Scalar CONS6      = PIOV6 * PIOV6 * RHOW * BIMM;
+  static constexpr Scalar CONS7      = 4. * PIOV3 * RHOW * 1.e-18;
+  static constexpr Scalar QSMALL     = 1.e-14;
+  static constexpr Scalar QTENDSMALL = 1e-20;
+  static constexpr Scalar BSMALL     = 1.e-15;
+  static constexpr Scalar NSMALL     = 1.e-16;
+  static constexpr Scalar ZERO       = 0.0;
+  static constexpr Scalar ONE        = 1.0;
+  static constexpr Scalar P0         = 100000.0; // reference pressure, Pa
+  static constexpr Scalar RD         = Rair;     // gas constant for dry air, J/kg/K
+  static constexpr Scalar RHOSUR     = P0 / (RD * Tmelt);
+  static constexpr Scalar rhosui     = 60000 / (RD * 253.15);
+  static constexpr Scalar RHO_1000MB = P0 / (RD * Tmelt);
+  static constexpr Scalar RHO_600MB  = 60000 / (RD * 253.15);
+  static constexpr Scalar CP         = Cpair; // heat constant of air at constant pressure, J/kg
+  static constexpr Scalar INV_CP     = 1.0 / CP;
   //  static constexpr Scalar Tol           = ekat::is_single_precision<Real>::value ? 2e-5 : 1e-14;
   static constexpr Scalar macheps       = std::numeric_limits<Real>::epsilon();
   static constexpr Scalar dt_left_tol   = 1.e-4;
@@ -90,11 +92,12 @@ template <typename Scalar> struct Constants {
   static constexpr Scalar ZVIR          = (RWV / Rair) - 1.0;
   static constexpr Scalar f1r           = 0.78;
   static constexpr Scalar f2r           = 0.32;
-  static constexpr Scalar nmltratio     = 1.0; // ratio of rain number produced to ice number loss from melting
-  static constexpr Scalar basetemp      = 300.0;
-  static constexpr Scalar r_earth       = 6.376e6;  // Radius of the earth in m
-  static constexpr Scalar stebol        = 5.67e-8;  // Stefan-Boltzmann's constant (W/m^2/K^4)
-  static constexpr Scalar omega         = 7.292e-5; // Earth's rotation (rad/sec)
+  static constexpr Scalar nmltratio =
+      1.0; // ratio of rain number produced to ice number loss from melting
+  static constexpr Scalar basetemp = 300.0;
+  static constexpr Scalar r_earth  = 6.376e6;  // Radius of the earth in m
+  static constexpr Scalar stebol   = 5.67e-8;  // Stefan-Boltzmann's constant (W/m^2/K^4)
+  static constexpr Scalar omega    = 7.292e-5; // Earth's rotation (rad/sec)
 
   // Table dimension constants
   static constexpr int VTABLE_DIM0    = 300;
@@ -102,8 +105,9 @@ template <typename Scalar> struct Constants {
   static constexpr int MU_R_TABLE_DIM = 150;
 
   // Turbulent Mountain Stress constants
-  static constexpr Scalar orocnst = 1;     // Converts from standard deviation to height [ no unit ]
-  static constexpr Scalar z0fac   = 0.075; // Factor determining z_0 from orographic standard deviation [ no unit ]
+  static constexpr Scalar orocnst = 1; // Converts from standard deviation to height [ no unit ]
+  static constexpr Scalar z0fac =
+      0.075; // Factor determining z_0 from orographic standard deviation [ no unit ]
 
   // switch for warm-rain parameterization
   // = 1 Seifert and Beheng 2001
@@ -116,9 +120,12 @@ template <typename Scalar> struct Constants {
 
   // For use in converting area to length for a column cell
   // World Geodetic System 1984 (WGS84)
-  static constexpr Scalar earth_ellipsoid1 = 111132.92; // first coefficient, meters per degree longitude at equator
-  static constexpr Scalar earth_ellipsoid2 = 559.82;    // second expansion coefficient for WGS84 ellipsoid
-  static constexpr Scalar earth_ellipsoid3 = 1.175;     // third expansion coefficient for WGS84 ellipsoid
+  static constexpr Scalar earth_ellipsoid1 =
+      111132.92; // first coefficient, meters per degree longitude at equator
+  static constexpr Scalar earth_ellipsoid2 =
+      559.82; // second expansion coefficient for WGS84 ellipsoid
+  static constexpr Scalar earth_ellipsoid3 =
+      1.175; // third expansion coefficient for WGS84 ellipsoid
 };
 
 // Gases
diff --git i/components/eamxx/src/physics/share/physics_functions.hpp w/components/eamxx/src/physics/share/physics_functions.hpp
index 5908072b15..09edd408ac 100644
--- i/components/eamxx/src/physics/share/physics_functions.hpp
+++ w/components/eamxx/src/physics/share/physics_functions.hpp
@@ -51,7 +51,8 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   template <typename S> using view_1d = typename KT::template view_1d<S>;
   template <typename S> using view_2d = typename KT::template view_2d<S>;
 
-  template <typename S, int N> using view_1d_ptr_array = typename KT::template view_1d_ptr_carray<S, N>;
+  template <typename S, int N>
+  using view_1d_ptr_array = typename KT::template view_1d_ptr_carray<S, N>;
 
   template <typename S> using uview_1d = typename ekat::template Unmanaged<view_1d<S>>;
   template <typename S> using uview_2d = typename ekat::template Unmanaged<view_2d<S>>;
@@ -72,27 +73,30 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   //  t is input in units of k.
   //  ice refers to saturation with respect to liquid (false) or ice (true)
   KOKKOS_FUNCTION
-  static Spack polysvp1(const Spack &t, const bool ice, const Smask &range_mask, const char *caller = nullptr);
+  static Spack polysvp1(const Spack &t, const bool ice, const Smask &range_mask,
+                        const char *caller = nullptr);
 
   //  compute saturation vapor pressure using Murphy and Koop(2005) formulation
   //  MurphyKoop_svp returned in units of pa.
   //  t is input in units of k.
   //  ice refers to saturation with respect to liquid (false) or ice (true)
   KOKKOS_FUNCTION
-  static Spack MurphyKoop_svp(const Spack &t, const bool ice, const Smask &range_mask, const char *caller = nullptr);
+  static Spack MurphyKoop_svp(const Spack &t, const bool ice, const Smask &range_mask,
+                              const char *caller = nullptr);
 
   // Calls a function to obtain the saturation vapor pressure, and then computes
   // and returns the dry saturation mixing ratio, with respect to either liquid or ice,
   // depending on value of 'ice'
   KOKKOS_FUNCTION
-  static Spack qv_sat_dry(const Spack &t_atm, const Spack &p_atm, const bool ice, const Smask &range_mask,
-                          const SaturationFcn func_idx = MurphyKoop, const char *caller = nullptr);
+  static Spack qv_sat_dry(const Spack &t_atm, const Spack &p_atm, const bool ice,
+                          const Smask &range_mask, const SaturationFcn func_idx = MurphyKoop,
+                          const char *caller = nullptr);
 
   // Calls qv_sat_dry and converts it to wet mixing ratio
   KOKKOS_FUNCTION
-  static Spack qv_sat_wet(const Spack &t_atm, const Spack &p_atm, const bool ice, const Smask &range_mask,
-                          const Spack &dp_wet, const Spack &dp_dry, const SaturationFcn func_idx = MurphyKoop,
-                          const char *caller = nullptr);
+  static Spack qv_sat_wet(const Spack &t_atm, const Spack &p_atm, const bool ice,
+                          const Smask &range_mask, const Spack &dp_wet, const Spack &dp_dry,
+                          const SaturationFcn func_idx = MurphyKoop, const char *caller = nullptr);
 
   // checks temperature for negatives and NaNs
   KOKKOS_FUNCTION
diff --git i/components/eamxx/src/physics/share/physics_saturation_impl.hpp w/components/eamxx/src/physics/share/physics_saturation_impl.hpp
index 9e1a3854d7..6a51a57423 100644
--- i/components/eamxx/src/physics/share/physics_saturation_impl.hpp
+++ w/components/eamxx/src/physics/share/physics_saturation_impl.hpp
@@ -21,7 +21,8 @@ KOKKOS_FUNCTION void Functions<S, D>::check_temperature(const Spack &t_atm, cons
   Make error message dynamic so that it tells the user the function name (func_name) from where
   this error is coming from. Currently func_name is not used in this function */
 
-  // NOTE: EKAT_KERNEL_REQUIRE_MSG requires first argument to be "False" to exit with an error message
+  // NOTE: EKAT_KERNEL_REQUIRE_MSG requires first argument to be "False" to exit with an error
+  // message
 
   // find out if there are any negative temperatures in the pack
   const auto is_neg_t_atm = (t_atm <= 0) && range_mask;
@@ -34,7 +35,8 @@ KOKKOS_FUNCTION void Functions<S, D>::check_temperature(const Spack &t_atm, cons
 
 template <typename S, typename D>
 KOKKOS_FUNCTION typename Functions<S, D>::Spack
-Functions<S, D>::MurphyKoop_svp(const Spack &t_atm, const bool ice, const Smask &range_mask, const char *caller) {
+Functions<S, D>::MurphyKoop_svp(const Spack &t_atm, const bool ice, const Smask &range_mask,
+                                const char *caller) {
 
   // First check if the temperature is legitimate or not
   check_temperature(t_atm, caller ? caller : "MurphyKoop_svp", range_mask);
@@ -54,7 +56,7 @@ Functions<S, D>::MurphyKoop_svp(const Spack &t_atm, const bool ice, const Smask
     //  (good down to 110 K)
     // creating array for storing coefficients of ice sat equation
     static constexpr Scalar ic[] = {9.550426, 5723.265, 3.53068, 0.00728332};
-    const Spack ice_result       = exp(ic[0] - (ic[1] / t_atm) + (ic[2] * log(t_atm)) - (ic[3] * t_atm));
+    const Spack ice_result = exp(ic[0] - (ic[1] / t_atm) + (ic[2] * log(t_atm)) - (ic[3] * t_atm));
 
     result.set(ice_mask, ice_result);
   }
@@ -66,9 +68,9 @@ Functions<S, D>::MurphyKoop_svp(const Spack &t_atm, const bool ice, const Smask
     static constexpr Scalar lq[] = {54.842763, 6763.22, 4.210,   0.000367, 0.0415,
                                     218.8,     53.878,  1331.22, 9.44523,  0.014025};
     const auto logt              = log(t_atm);
-    const Spack liq_result =
-        exp(lq[0] - (lq[1] / t_atm) - (lq[2] * logt) + (lq[3] * t_atm) +
-            (tanh(lq[4] * (t_atm - lq[5])) * (lq[6] - (lq[7] / t_atm) - (lq[8] * logt) + lq[9] * t_atm)));
+    const Spack liq_result       = exp(lq[0] - (lq[1] / t_atm) - (lq[2] * logt) + (lq[3] * t_atm) +
+                                       (tanh(lq[4] * (t_atm - lq[5])) *
+                                  (lq[6] - (lq[7] / t_atm) - (lq[8] * logt) + lq[9] * t_atm)));
 
     result.set(liq_mask, liq_result);
   }
@@ -77,9 +79,11 @@ Functions<S, D>::MurphyKoop_svp(const Spack &t_atm, const bool ice, const Smask
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION typename Functions<S, D>::Spack Functions<S, D>::polysvp1(const Spack &t, const bool ice,
-                                                                          const Smask &range_mask, const char *caller) {
-  // REPLACE GOFF-GRATCH WITH FASTER FORMULATION FROM FLATAU ET AL. 1992, TABLE 4 (RIGHT-HAND COLUMN)
+KOKKOS_FUNCTION typename Functions<S, D>::Spack
+Functions<S, D>::polysvp1(const Spack &t, const bool ice, const Smask &range_mask,
+                          const char *caller) {
+  // REPLACE GOFF-GRATCH WITH FASTER FORMULATION FROM FLATAU ET AL. 1992, TABLE 4 (RIGHT-HAND
+  // COLUMN)
 
   // First check if the temperature is legitimate or not
   check_temperature(t, caller ? caller : "polysvp1", range_mask);
@@ -95,23 +99,31 @@ KOKKOS_FUNCTION typename Functions<S, D>::Spack Functions<S, D>::polysvp1(const
   // Flatau formulation:
   if (ice_mask.any()) {
     // ice
-    static constexpr Scalar ai[] = {6.11147274,     0.503160820,    0.188439774e-1,  0.420895665e-3, 0.615021634e-5,
-                                    0.602588177e-7, 0.385852041e-9, 0.146898966e-11, 0.252751365e-14};
+    static constexpr Scalar ai[] = {6.11147274,     0.503160820,     0.188439774e-1,
+                                    0.420895665e-3, 0.615021634e-5,  0.602588177e-7,
+                                    0.385852041e-9, 0.146898966e-11, 0.252751365e-14};
     const Spack ice_result =
         (ai[0] +
          dt * (ai[1] +
-               dt * (ai[2] + dt * (ai[3] + dt * (ai[4] + dt * (ai[5] + dt * (ai[6] + dt * (ai[7] + ai[8] * dt)))))))) *
+               dt * (ai[2] +
+                     dt * (ai[3] +
+                           dt * (ai[4] +
+                                 dt * (ai[5] + dt * (ai[6] + dt * (ai[7] + ai[8] * dt)))))))) *
         100;
     result.set(ice_mask, ice_result);
   }
   if (liq_mask.any()) {
     // liquid, V1.7
-    static constexpr Scalar a[] = {6.11239921,     0.443987641,     0.142986287e-1,   0.264847430e-3,  0.302950461e-5,
-                                   0.206739458e-7, 0.640689451e-10, -0.952447341e-13, -0.976195544e-15};
+    static constexpr Scalar a[] = {6.11239921,      0.443987641,      0.142986287e-1,
+                                   0.264847430e-3,  0.302950461e-5,   0.206739458e-7,
+                                   0.640689451e-10, -0.952447341e-13, -0.976195544e-15};
 
     const Spack liq_result =
         (a[0] +
-         dt * (a[1] + dt * (a[2] + dt * (a[3] + dt * (a[4] + dt * (a[5] + dt * (a[6] + dt * (a[7] + a[8] * dt)))))))) *
+         dt * (a[1] +
+               dt * (a[2] +
+                     dt * (a[3] +
+                           dt * (a[4] + dt * (a[5] + dt * (a[6] + dt * (a[7] + a[8] * dt)))))))) *
         100;
     result.set(liq_mask, liq_result);
   }
@@ -121,17 +133,18 @@ KOKKOS_FUNCTION typename Functions<S, D>::Spack Functions<S, D>::polysvp1(const
 
 template <typename S, typename D>
 KOKKOS_FUNCTION typename Functions<S, D>::Spack
-Functions<S, D>::qv_sat_dry(const Spack &t_atm, const Spack &p_atm_dry, const bool ice, const Smask &range_mask,
-                            const SaturationFcn func_idx, const char *caller) {
+Functions<S, D>::qv_sat_dry(const Spack &t_atm, const Spack &p_atm_dry, const bool ice,
+                            const Smask &range_mask, const SaturationFcn func_idx,
+                            const char *caller) {
   /*Arguments:
     ----------
   t_atm: temperature; p_atm_dry: dry pressure; ice: logical for ice
 
   range_mask: is a mask which masks out padded values in the packs, which are uninitialized
-  func_idx is an optional argument to decide which scheme is to be called for saturation vapor pressure
-  Currently default is set to "MurphyKoop_svp"
-  func_idx = Polysvp1 (=0) --> polysvp1 (Flatau et al. 1992)
-  func_idx = MurphyKoop (=1) --> MurphyKoop_svp (Murphy, D. M., and T. Koop 2005)*/
+  func_idx is an optional argument to decide which scheme is to be called for saturation vapor
+  pressure Currently default is set to "MurphyKoop_svp" func_idx = Polysvp1 (=0) --> polysvp1
+  (Flatau et al. 1992) func_idx = MurphyKoop (=1) --> MurphyKoop_svp (Murphy, D. M., and T. Koop
+  2005)*/
 
   Spack e_pres; // saturation vapor pressure [Pa]
 
@@ -152,20 +165,18 @@ Functions<S, D>::qv_sat_dry(const Spack &t_atm, const Spack &p_atm_dry, const bo
 
 template <typename S, typename D>
 KOKKOS_FUNCTION typename Functions<S, D>::Spack
-Functions<S, D>::qv_sat_wet(const Spack &t_atm, const Spack &p_atm_dry, const bool ice, const Smask &range_mask,
-                            const Spack &dp_wet, const Spack &dp_dry, const SaturationFcn func_idx,
-                            const char *caller) {
+Functions<S, D>::qv_sat_wet(const Spack &t_atm, const Spack &p_atm_dry, const bool ice,
+                            const Smask &range_mask, const Spack &dp_wet, const Spack &dp_dry,
+                            const SaturationFcn func_idx, const char *caller) {
   /*Arguments (the same as in qv_sat_dry plus dp wet and dp dry):
     ----------
   t_atm: temperature; p_atm_dry: dry pressure; ice: logical for ice
 
   range_mask: is a mask which masks out padded values in the packs, which are uninitialized
-  func_idx is an optional argument to decide which scheme is to be called for saturation vapor pressure
-  Currently default is set to "MurphyKoop_svp"
-  func_idx = Polysvp1 (=0) --> polysvp1 (Flatau et al. 1992)
-  func_idx = MurphyKoop (=1) --> MurphyKoop_svp (Murphy, D. M., and T. Koop 2005)
-  dp_wet: pseudo_density
-  dp_dry: pseudo_density_dry */
+  func_idx is an optional argument to decide which scheme is to be called for saturation vapor
+  pressure Currently default is set to "MurphyKoop_svp" func_idx = Polysvp1 (=0) --> polysvp1
+  (Flatau et al. 1992) func_idx = MurphyKoop (=1) --> MurphyKoop_svp (Murphy, D. M., and T. Koop
+  2005) dp_wet: pseudo_density dp_dry: pseudo_density_dry */
 
   Spack qsatdry = qv_sat_dry(t_atm, p_atm_dry, ice, range_mask, func_idx, caller);
 
diff --git i/components/eamxx/src/physics/share/physics_share.cpp w/components/eamxx/src/physics/share/physics_share.cpp
index f95a002c84..853c0818a2 100644
--- i/components/eamxx/src/physics/share/physics_share.cpp
+++ w/components/eamxx/src/physics/share/physics_share.cpp
@@ -22,23 +22,26 @@ template <typename ScalarT, typename DeviceT> struct CudaWrap {
   static Scalar pow(Scalar base, Scalar exp) {
     Scalar result;
     RangePolicy policy(0, 1);
-    Kokkos::parallel_reduce(policy, KOKKOS_LAMBDA(const Int &, Scalar &value) { value = std::pow(base, exp); }, result);
+    Kokkos::parallel_reduce(
+        policy, KOKKOS_LAMBDA(const Int &, Scalar &value) { value = std::pow(base, exp); }, result);
 
     return result;
   }
 
-#define cuda_wrap_single_arg(wrap_name, func_call)                                                                    \
-  static Scalar wrap_name(Scalar input) {                                                                             \
-    Scalar result;                                                                                                    \
-    RangePolicy policy(0, 1);                                                                                         \
-    Kokkos::parallel_reduce(policy, KOKKOS_LAMBDA(const Int &, Scalar &value) { value = func_call(input); }, result); \
-    return result;                                                                                                    \
+#define cuda_wrap_single_arg(wrap_name, func_call)                                                \
+  static Scalar wrap_name(Scalar input) {                                                         \
+    Scalar result;                                                                                \
+    RangePolicy policy(0, 1);                                                                     \
+    Kokkos::parallel_reduce(                                                                      \
+        policy, KOKKOS_LAMBDA(const Int &, Scalar &value) { value = func_call(input); }, result); \
+    return result;                                                                                \
   }
 
-  cuda_wrap_single_arg(gamma, std::tgamma) cuda_wrap_single_arg(sqrt, std::sqrt) cuda_wrap_single_arg(cbrt, std::cbrt)
-      cuda_wrap_single_arg(log, std::log) cuda_wrap_single_arg(log10, std::log10) cuda_wrap_single_arg(exp, std::exp)
-          cuda_wrap_single_arg(expm1, std::expm1) cuda_wrap_single_arg(tanh, std::tanh)
-              cuda_wrap_single_arg(erf, std::erf)
+  cuda_wrap_single_arg(gamma, std::tgamma) cuda_wrap_single_arg(sqrt, std::sqrt)
+      cuda_wrap_single_arg(cbrt, std::cbrt) cuda_wrap_single_arg(log, std::log)
+          cuda_wrap_single_arg(log10, std::log10) cuda_wrap_single_arg(exp, std::exp)
+              cuda_wrap_single_arg(expm1, std::expm1) cuda_wrap_single_arg(tanh, std::tanh)
+                  cuda_wrap_single_arg(erf, std::erf)
 
 #undef cuda_wrap_single_arg
 };
diff --git i/components/eamxx/src/physics/share/physics_test_data.cpp w/components/eamxx/src/physics/share/physics_test_data.cpp
index 8f51f22fc7..50d9b9f265 100644
--- i/components/eamxx/src/physics/share/physics_test_data.cpp
+++ w/components/eamxx/src/physics/share/physics_test_data.cpp
@@ -24,8 +24,8 @@ PhysicsTestData &PhysicsTestData::assignment_impl(const PhysicsTestData &rhs) {
 }
 
 void PhysicsTestData::read(const ekat::FILEPtr &fid) {
-  EKAT_REQUIRE_MSG(
-      fid, "Tried to read from missing file. You may have forgotten to generate baselines for some BFB unit tests");
+  EKAT_REQUIRE_MSG(fid, "Tried to read from missing file. You may have forgotten to generate "
+                        "baselines for some BFB unit tests");
   m_reals.read(fid);
   m_ints.read(fid);
   m_bools.read(fid);
diff --git i/components/eamxx/src/physics/share/physics_test_data.hpp w/components/eamxx/src/physics/share/physics_test_data.hpp
index 909055a4e1..e046a25b67 100644
--- i/components/eamxx/src/physics/share/physics_test_data.hpp
+++ w/components/eamxx/src/physics/share/physics_test_data.hpp
@@ -246,20 +246,20 @@ struct SHOCGridData : public PhysicsTestData {
     return *this;                                  \
   }
 
-#define PTD_RW_SCALARS(num_scalars, ...)                                                                               \
-  void read_scalars(const ekat::FILEPtr &fid) {                                                                        \
-    EKAT_REQUIRE_MSG(                                                                                                  \
-        fid, "Tried to read from missing file. You may have forgotten to generate baselines for some BFB unit tests"); \
-    PTD_RW##num_scalars(read, __VA_ARGS__);                                                                            \
-  }                                                                                                                    \
+#define PTD_RW_SCALARS(num_scalars, ...)                                                         \
+  void read_scalars(const ekat::FILEPtr &fid) {                                                  \
+    EKAT_REQUIRE_MSG(fid, "Tried to read from missing file. You may have forgotten to generate " \
+                          "baselines for some BFB unit tests");                                  \
+    PTD_RW##num_scalars(read, __VA_ARGS__);                                                      \
+  }                                                                                              \
   void write_scalars(const ekat::FILEPtr &fid) const { PTD_RW##num_scalars(write, __VA_ARGS__); }
 
-#define PTD_RW_SCALARS_ONLY(num_scalars, ...)                                                                          \
-  void read(const ekat::FILEPtr &fid) {                                                                                \
-    EKAT_REQUIRE_MSG(                                                                                                  \
-        fid, "Tried to read from missing file. You may have forgotten to generate baselines for some BFB unit tests"); \
-    PTD_RW##num_scalars(read, __VA_ARGS__);                                                                            \
-  }                                                                                                                    \
+#define PTD_RW_SCALARS_ONLY(num_scalars, ...)                                                    \
+  void read(const ekat::FILEPtr &fid) {                                                          \
+    EKAT_REQUIRE_MSG(fid, "Tried to read from missing file. You may have forgotten to generate " \
+                          "baselines for some BFB unit tests");                                  \
+    PTD_RW##num_scalars(read, __VA_ARGS__);                                                      \
+  }                                                                                              \
   void write(const ekat::FILEPtr &fid) const { PTD_RW##num_scalars(write, __VA_ARGS__); }
 
 #define PTD_RW()                               \
@@ -290,8 +290,10 @@ namespace scream {
 class PhysicsTestData {
   template <typename T> struct PTDImpl {
     template <typename Iterator>
-    PTDImpl(Iterator dims_begin, Iterator dims_end, const std::vector<std::vector<T **>> &members_list)
-        : m_dims_list(dims_begin, dims_end), m_members_list(members_list), m_totals(m_dims_list.size(), 0) {
+    PTDImpl(Iterator dims_begin, Iterator dims_end,
+            const std::vector<std::vector<T **>> &members_list)
+        : m_dims_list(dims_begin, dims_end), m_members_list(members_list),
+          m_totals(m_dims_list.size(), 0) {
       EKAT_REQUIRE_MSG(m_dims_list.size() == m_members_list.size(),
                        "Length of member lists did not match length of dimensions");
 
@@ -412,18 +414,20 @@ class PhysicsTestData {
 
     void write(const ekat::FILEPtr &fid) const { ekat::write(m_data.data(), m_data.size(), fid); }
 
-    std::vector<std::vector<Int>> m_dims_list;     // list of dims, one per unique set of dims
-    std::vector<std::vector<T **>> m_members_list; // list of member pointers, same outer index space as m_dims_list
-    std::vector<T> m_data;                         // the member data in a flat vector
-    std::vector<Int> m_totals;                     // total sizes of each set of data, same index space as m_dims_list
+    std::vector<std::vector<Int>> m_dims_list; // list of dims, one per unique set of dims
+    std::vector<std::vector<T **>>
+        m_members_list;        // list of member pointers, same outer index space as m_dims_list
+    std::vector<T> m_data;     // the member data in a flat vector
+    std::vector<Int> m_totals; // total sizes of each set of data, same index space as m_dims_list
   };
 
 public:
   // dims -> the dimensions of real data should come before dimensions of int data
   //         and the dims of int data should come before bool data
   PhysicsTestData(
-      const std::vector<std::vector<Int>> &dims,      // vector of dimensions, each set of dimensions is a vector of Int
-      const std::vector<std::vector<Real **>> &reals, // vector of pointers to real* members
+      const std::vector<std::vector<Int>>
+          &dims, // vector of dimensions, each set of dimensions is a vector of Int
+      const std::vector<std::vector<Real **>> &reals,       // vector of pointers to real* members
       const std::vector<std::vector<Int **>> &ints   = {},  // vector of pointers to int* members
       const std::vector<std::vector<bool **>> &bools = {}); // vector of pointers to bool* members
 
@@ -431,9 +435,15 @@ public:
   Int total(const Int *member) const { return m_ints.get_total(get_index(member).first); }
   Int total(const bool *member) const { return m_bools.get_total(get_index(member).first); }
 
-  Int dim(const Real *member, const size_t &dim_idx) const { return m_reals.get_dim(get_index(member).first, dim_idx); }
-  Int dim(const Int *member, const size_t &dim_idx) const { return m_ints.get_dim(get_index(member).first, dim_idx); }
-  Int dim(const bool *member, const size_t &dim_idx) const { return m_bools.get_dim(get_index(member).first, dim_idx); }
+  Int dim(const Real *member, const size_t &dim_idx) const {
+    return m_reals.get_dim(get_index(member).first, dim_idx);
+  }
+  Int dim(const Int *member, const size_t &dim_idx) const {
+    return m_ints.get_dim(get_index(member).first, dim_idx);
+  }
+  Int dim(const bool *member, const size_t &dim_idx) const {
+    return m_bools.get_dim(get_index(member).first, dim_idx);
+  }
 
   // Delete this to block subclasses getting the default impls, which would be incorrect
   PhysicsTestData(const PhysicsTestData &rhs)            = delete;
@@ -445,7 +455,8 @@ public:
   // Example, to use a -1 to 1 range for wthl member:
   // d.randomize({ {d.wthl, {-1, 1}} });
   template <typename Engine>
-  void randomize(Engine &engine, const std::vector<std::pair<void *, std::pair<Real, Real>>> &ranges = {}) {
+  void randomize(Engine &engine,
+                 const std::vector<std::pair<void *, std::pair<Real, Real>>> &ranges = {}) {
     std::uniform_real_distribution<Real> default_real_dist(0.0, 1.0);
     std::uniform_int_distribution<Int> default_int_dist(0, 1);
     std::uniform_int_distribution<Int> default_bool_dist(0, 1);
@@ -474,30 +485,35 @@ public:
                            "Use of non-round float for integer random range:" << bottom_range);
           EKAT_REQUIRE_MSG(std::ceil(top_range) == top_range,
                            "Use of non-round float for integer random range:" << top_range);
-          std::uniform_int_distribution<Int> data_dist(std::lround(bottom_range), std::lround(top_range));
+          std::uniform_int_distribution<Int> data_dist(std::lround(bottom_range),
+                                                       std::lround(top_range));
 
           m_ints.randomize(engine, data_dist, int_search);
         } else {
           const auto bool_search = get_index(reinterpret_cast<bool *>(member));
-          EKAT_REQUIRE_MSG(bool_search.first != std::string::npos, "Failed to find member for randomization");
+          EKAT_REQUIRE_MSG(bool_search.first != std::string::npos,
+                           "Failed to find member for randomization");
           EKAT_REQUIRE_MSG(bottom_range == 0.0 || bottom_range == 1.0,
                            "Use 0 or 1 for bool ranges, not:" << bottom_range);
-          EKAT_REQUIRE_MSG(top_range == 0.0 || top_range == 1.0, "Use 0 or 1 for bool ranges, not:" << top_range);
-          std::uniform_int_distribution<Int> data_dist(std::lround(bottom_range), std::lround(top_range));
+          EKAT_REQUIRE_MSG(top_range == 0.0 || top_range == 1.0,
+                           "Use 0 or 1 for bool ranges, not:" << top_range);
+          std::uniform_int_distribution<Int> data_dist(std::lround(bottom_range),
+                                                       std::lround(top_range));
           m_bools.randomize(engine, data_dist, bool_search);
         }
       }
     }
   }
 
-  // Since we are also preparing index data, this function is doing more than transposing. It's shifting the
-  // format of all data from one language to another
+  // Since we are also preparing index data, this function is doing more than transposing. It's
+  // shifting the format of all data from one language to another
   template <ekat::TransposeDirection::Enum D> void transpose() {
     m_reals.transpose<D>();
     m_ints.transpose<D>();
     m_bools.transpose<D>();
 
-    // Shift the indices. We might not be able to make the assumption that int data represented indices
+    // Shift the indices. We might not be able to make the assumption that int data represented
+    // indices
     for (size_t i = 0; i < m_ints.m_data.size(); ++i) {
       m_ints.m_data[i] += (D == ekat::TransposeDirection::c2f ? 1 : -1);
       EKAT_ASSERT_MSG(m_ints.m_data[i] >= 0, "Bad index: " << m_ints.m_data[i]);
@@ -512,7 +528,9 @@ protected:
   PhysicsTestData &assignment_impl(const PhysicsTestData &rhs);
 
 private:
-  std::pair<size_t, size_t> get_index(const Real *member) const { return m_reals.get_index(member); }
+  std::pair<size_t, size_t> get_index(const Real *member) const {
+    return m_reals.get_index(member);
+  }
   std::pair<size_t, size_t> get_index(const Int *member) const { return m_ints.get_index(member); }
   std::pair<size_t, size_t> get_index(const bool *member) const {
     return m_bools.get_index(reinterpret_cast<const char *>(member));
@@ -520,7 +538,8 @@ private:
 
   PTDImpl<Real> m_reals; // manage real data with this member
   PTDImpl<Int> m_ints;   // manage int data with this member
-  PTDImpl<char> m_bools; // manage bool data with this member, use chars internally to dodge vector<bool> specialization
+  PTDImpl<char> m_bools; // manage bool data with this member, use chars internally to dodge
+                         // vector<bool> specialization
 };
 
 enum BASELINE_ACTION { NONE, COMPARE, GENERATE };
@@ -538,8 +557,8 @@ struct UnitBase {
   ekat::FILEPtr m_fid;
 
   UnitBase()
-      : m_baseline_path(""), m_test_name(Catch::getResultCapture().getCurrentTestName()), m_baseline_action(NONE),
-        m_fid() {
+      : m_baseline_path(""), m_test_name(Catch::getResultCapture().getCurrentTestName()),
+        m_baseline_action(NONE), m_fid() {
     auto &ts = ekat::TestSession::get();
     if (ts.flags["c"]) {
       m_baseline_action = COMPARE;
@@ -551,7 +570,8 @@ struct UnitBase {
     m_baseline_path = ts.params["b"];
 
     EKAT_REQUIRE_MSG(!(m_baseline_action != NONE && m_baseline_path == ""),
-                     "Unit test flags problem: baseline actions were requested but no baseline path was provided");
+                     "Unit test flags problem: baseline actions were requested but no baseline "
+                     "path was provided");
 
     std::string baseline_name = m_baseline_path + "/" + m_test_name;
     if (m_baseline_action == COMPARE) {
diff --git i/components/eamxx/src/physics/share/tests/physics_saturation_run_and_cmp.cpp w/components/eamxx/src/physics/share/tests/physics_saturation_run_and_cmp.cpp
index 1e4fd66498..f3003ff69f 100644
--- i/components/eamxx/src/physics/share/tests/physics_saturation_run_and_cmp.cpp
+++ w/components/eamxx/src/physics/share/tests/physics_saturation_run_and_cmp.cpp
@@ -24,10 +24,11 @@ namespace physics {
 namespace unit_test {
 
 template <typename D> struct UnitWrap::UnitTest<D>::TestSaturation {
-  KOKKOS_FUNCTION static void saturation_tests(const Scalar &temperature, const Scalar &pressure, Scalar &sat_ice_fp,
-                                               Scalar &sat_liq_fp, Scalar &mix_ice_fr, Scalar &mix_liq_fr,
-                                               Scalar &sat_ice_mkp, Scalar &sat_liq_mkp, Scalar &mix_ice_mkr,
-                                               Scalar &mix_liq_mkr) {
+  KOKKOS_FUNCTION static void saturation_tests(const Scalar &temperature, const Scalar &pressure,
+                                               Scalar &sat_ice_fp, Scalar &sat_liq_fp,
+                                               Scalar &mix_ice_fr, Scalar &mix_liq_fr,
+                                               Scalar &sat_ice_mkp, Scalar &sat_liq_mkp,
+                                               Scalar &mix_ice_mkr, Scalar &mix_liq_mkr) {
     // Nomenclature:
     // subscript "_fp"  stands for "Flatau Pressure"
     // subscript "_fr"  stands for "Flatau mixing Ratios"
@@ -42,18 +43,20 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestSaturation {
     const Spack temps(temperature);
     const Spack pres(pressure);
 
-    // Get values from polysvp1 and qv_sat (qv_sat calls polysvp1 here) to test against "expected" values
+    // Get values from polysvp1 and qv_sat (qv_sat calls polysvp1 here) to test against "expected"
+    // values
     //--------------------------------------
     sat_ice_fp = physics::polysvp1(temps, true, Smask(true))[0];
     sat_liq_fp = physics::polysvp1(temps, false, Smask(true))[0];
 
-    // Functions<S,D>::qv_sat_dry(const Spack& t_atm, const Spack& p_atm_dry, const bool ice, const Smask& range_mask,
+    // Functions<S,D>::qv_sat_dry(const Spack& t_atm, const Spack& p_atm_dry, const bool ice, const
+    // Smask& range_mask,
     //                            const SaturationFcn func_idx, const char* caller)
     mix_ice_fr = physics::qv_sat_dry(temps, pres, true, Smask(true), physics::Polysvp1)[0];
     mix_liq_fr = physics::qv_sat_dry(temps, pres, false, Smask(true), physics::Polysvp1)[0];
 
-    // Get values from MurphyKoop_svp and qv_sat_dry (qv_sat_dry calls MurphyKoop_svp here) to test against "expected"
-    // values
+    // Get values from MurphyKoop_svp and qv_sat_dry (qv_sat_dry calls MurphyKoop_svp here) to test
+    // against "expected" values
     sat_ice_mkp = physics::MurphyKoop_svp(temps, true, Smask(true))[0];
     sat_liq_mkp = physics::MurphyKoop_svp(temps, false, Smask(true))[0];
 
@@ -71,9 +74,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestSaturation {
     This code tests polysvp1 and qv_sat at 0 degrees C, at a very cold T, and at a very hot T
     to make sure our impl gets the same answer as Flatau et al 1992:
     (https://journals.ametsoc.org/jamc/article/31/12/1507/14870/Polynomial-Fits-to-Saturation-Vapor-Pressure)
-    For 0 degrees C, polysvp values can be read directly from Flatau. For other cases, I independently
-    coded up the Flatau scheme (polysvp1) in python and used it to derive the expected values. My python code is
-    in https://github.com/E3SM-Project/scream-docs.git analysis-scripts/test_qv_sat.py
+    For 0 degrees C, polysvp values can be read directly from Flatau. For other cases, I
+    independently coded up the Flatau scheme (polysvp1) in python and used it to derive the expected
+    values. My python code is in https://github.com/E3SM-Project/scream-docs.git
+    analysis-scripts/test_qv_sat.py
    */
 
   TestSaturation()
@@ -89,7 +93,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestSaturation {
 
                  // Following values are picked from Murphy and Koop (2005)
                  // Table C1 titled: "VALUES RECOMMENDED FOR CHECKING COMPUTER CODES"
-                 // Saturation vapor pressure (SVP) values in the table were upto only 5 significant digits.
+                 // Saturation vapor pressure (SVP) values in the table were upto only 5 significant
+                 // digits.
                  {150, atm_pres},
                  {180, atm_pres},
                  {210, atm_pres},
@@ -107,9 +112,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestSaturation {
       Kokkos::View<OutputData *> d_dev("", 1);
       Kokkos::parallel_for(
           1, KOKKOS_LAMBDA(const size_t &) {
-            TestSaturation::saturation_tests(ps.temperature, ps.pressure, d_dev[0].sat_ice_fp, d_dev[0].sat_liq_fp,
-                                             d_dev[0].mix_ice_fr, d_dev[0].mix_liq_fr, d_dev[0].sat_ice_mkp,
-                                             d_dev[0].sat_liq_mkp, d_dev[0].mix_ice_mkr, d_dev[0].mix_liq_mkr);
+            TestSaturation::saturation_tests(
+                ps.temperature, ps.pressure, d_dev[0].sat_ice_fp, d_dev[0].sat_liq_fp,
+                d_dev[0].mix_ice_fr, d_dev[0].mix_liq_fr, d_dev[0].sat_ice_mkp,
+                d_dev[0].sat_liq_mkp, d_dev[0].mix_ice_mkr, d_dev[0].mix_liq_mkr);
           });
       Kokkos::fence();
 
@@ -137,9 +143,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestSaturation {
       Kokkos::View<OutputData *> d_dev("", 1);
       Kokkos::parallel_for(
           1, KOKKOS_LAMBDA(const size_t &) {
-            TestSaturation::saturation_tests(ps.temperature, ps.pressure, d_dev[0].sat_ice_fp, d_dev[0].sat_liq_fp,
-                                             d_dev[0].mix_ice_fr, d_dev[0].mix_liq_fr, d_dev[0].sat_ice_mkp,
-                                             d_dev[0].sat_liq_mkp, d_dev[0].mix_ice_mkr, d_dev[0].mix_liq_mkr);
+            TestSaturation::saturation_tests(
+                ps.temperature, ps.pressure, d_dev[0].sat_ice_fp, d_dev[0].sat_liq_fp,
+                d_dev[0].mix_ice_fr, d_dev[0].mix_liq_fr, d_dev[0].sat_ice_mkp,
+                d_dev[0].sat_liq_mkp, d_dev[0].mix_ice_mkr, d_dev[0].mix_liq_mkr);
           });
       Kokkos::fence();
 
@@ -241,7 +248,9 @@ private:
 
 namespace {
 
-void expect_another_arg(int i, int argc) { EKAT_REQUIRE_MSG(i != argc - 1, "Expected another cmd-line arg."); }
+void expect_another_arg(int i, int argc) {
+  EKAT_REQUIRE_MSG(i != argc - 1, "Expected another cmd-line arg.");
+}
 
 } // namespace
 
@@ -257,7 +266,8 @@ int main(int argc, char **argv) {
                  "Options:\n"
                  "  -g                  Generate baseline file. Default False.\n"
                  "  -b <baseline-file>  Path to baseline file. Required.\n"
-                 "  -t <tol>            Tolerance for relative error. Default machine eps (*10000 for Release).\n";
+                 "  -t <tol>            Tolerance for relative error. Default machine eps (*10000 "
+                 "for Release).\n";
     return 1;
   }
 
diff --git i/components/eamxx/src/physics/share/tests/physics_test_data_unit_tests.cpp w/components/eamxx/src/physics/share/tests/physics_test_data_unit_tests.cpp
index 1361eeb341..1818656d3a 100644
--- i/components/eamxx/src/physics/share/tests/physics_test_data_unit_tests.cpp
+++ w/components/eamxx/src/physics/share/tests/physics_test_data_unit_tests.cpp
@@ -43,7 +43,8 @@ struct AllTrue : public PhysicsTestData {
   Int dim1;
   bool *bools;
 
-  AllTrue(Int dim1_) : PhysicsTestData({{dim1_}}, {/*no reals*/}, {/*no ints*/}, {{&bools}}), dim1(dim1_) {}
+  AllTrue(Int dim1_)
+      : PhysicsTestData({{dim1_}}, {/*no reals*/}, {/*no ints*/}, {{&bools}}), dim1(dim1_) {}
 
   PTD_STD_DEF(AllTrue, 1, dim1);
 };
@@ -58,12 +59,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestTestData {
                                                               std::make_tuple(4, 8, 16, 2)};
     const std::vector<Real> scalars                        = {42.1, 43.1};
     FakeClass1 fakes_1[]                                   = {
-        FakeClass1(std::get<0>(dims[0]), std::get<1>(dims[0]), std::get<2>(dims[0]), std::get<3>(dims[0]), scalars[0]),
-        FakeClass1(std::get<0>(dims[1]), std::get<1>(dims[1]), std::get<2>(dims[1]), std::get<3>(dims[1]), scalars[1]),
+        FakeClass1(std::get<0>(dims[0]), std::get<1>(dims[0]), std::get<2>(dims[0]),
+                                                     std::get<3>(dims[0]), scalars[0]),
+        FakeClass1(std::get<0>(dims[1]), std::get<1>(dims[1]), std::get<2>(dims[1]),
+                                                     std::get<3>(dims[1]), scalars[1]),
     };
 
     for (auto &d : fakes_1) {
-      d.randomize(engine, {{d.two123, {-2.0, -1.0}}, {d.three124, {-3.0, -2.0}}, {d.int124, {42, 84}}});
+      d.randomize(engine,
+                  {{d.two123, {-2.0, -1.0}}, {d.three124, {-3.0, -2.0}}, {d.int124, {42, 84}}});
     }
 
     static constexpr Int num_runs = sizeof(fakes_1) / sizeof(FakeClass1);
@@ -90,15 +94,18 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestTestData {
       auto &d3 = fakes_3[n];
 
       // Check dimensions
-      REQUIRE(d1.total(d1.one123) == std::get<0>(dims[n]) * std::get<1>(dims[n]) * std::get<2>(dims[n]));
+      REQUIRE(d1.total(d1.one123) ==
+              std::get<0>(dims[n]) * std::get<1>(dims[n]) * std::get<2>(dims[n]));
       REQUIRE(d1.total(d1.one123) == d2.total(d2.one123));
       REQUIRE(d1.total(d1.one123) == d3.total(d3.one123));
 
-      REQUIRE(d1.total(d1.two123) == std::get<0>(dims[n]) * std::get<1>(dims[n]) * std::get<2>(dims[n]));
+      REQUIRE(d1.total(d1.two123) ==
+              std::get<0>(dims[n]) * std::get<1>(dims[n]) * std::get<2>(dims[n]));
       REQUIRE(d1.total(d1.two123) == d2.total(d2.two123));
       REQUIRE(d1.total(d1.two123) == d3.total(d3.two123));
 
-      REQUIRE(d1.total(d1.three124) == std::get<0>(dims[n]) * std::get<1>(dims[n]) * std::get<3>(dims[n]));
+      REQUIRE(d1.total(d1.three124) ==
+              std::get<0>(dims[n]) * std::get<1>(dims[n]) * std::get<3>(dims[n]));
       REQUIRE(d1.total(d1.three124) == d2.total(d2.three124));
       REQUIRE(d1.total(d1.three124) == d3.total(d3.three124));
 
@@ -106,7 +113,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestTestData {
       REQUIRE(d1.total(d1.int12) == d2.total(d2.int12));
       REQUIRE(d1.total(d1.int12) == d3.total(d3.int12));
 
-      REQUIRE(d1.total(d1.int124) == std::get<0>(dims[n]) * std::get<1>(dims[n]) * std::get<3>(dims[n]));
+      REQUIRE(d1.total(d1.int124) ==
+              std::get<0>(dims[n]) * std::get<1>(dims[n]) * std::get<3>(dims[n]));
       REQUIRE(d1.total(d1.int124) == d2.total(d2.int124));
       REQUIRE(d1.total(d1.int124) == d3.total(d3.int124));
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_assumed_pdf_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_assumed_pdf_disp.cpp
index 428118e452..03c8518c46 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_assumed_pdf_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_assumed_pdf_disp.cpp
@@ -8,12 +8,15 @@ namespace shoc {
 template <>
 void Functions<Real, DefaultDevice>::shoc_assumed_pdf_disp(
     const Int &shcol, const Int &nlev, const Int &nlevi, const view_2d<const Spack> &thetal,
-    const view_2d<const Spack> &qw, const view_2d<const Spack> &w_field, const view_2d<const Spack> &thl_sec,
-    const view_2d<const Spack> &qw_sec, const view_2d<const Spack> &wthl_sec, const view_2d<const Spack> &w_sec,
-    const view_2d<const Spack> &wqw_sec, const view_2d<const Spack> &qwthl_sec, const view_2d<const Spack> &w3,
-    const view_2d<const Spack> &pres, const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
-    const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &shoc_cldfrac, const view_2d<Spack> &shoc_ql,
-    const view_2d<Spack> &wqls, const view_2d<Spack> &wthv_sec, const view_2d<Spack> &shoc_ql2) {
+    const view_2d<const Spack> &qw, const view_2d<const Spack> &w_field,
+    const view_2d<const Spack> &thl_sec, const view_2d<const Spack> &qw_sec,
+    const view_2d<const Spack> &wthl_sec, const view_2d<const Spack> &w_sec,
+    const view_2d<const Spack> &wqw_sec, const view_2d<const Spack> &qwthl_sec,
+    const view_2d<const Spack> &w3, const view_2d<const Spack> &pres,
+    const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
+    const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &shoc_cldfrac,
+    const view_2d<Spack> &shoc_ql, const view_2d<Spack> &wqls, const view_2d<Spack> &wthv_sec,
+    const view_2d<Spack> &shoc_ql2) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
@@ -25,11 +28,13 @@ void Functions<Real, DefaultDevice>::shoc_assumed_pdf_disp(
         auto workspace = workspace_mgr.get_workspace(team);
 
         shoc_assumed_pdf(
-            team, nlev, nlevi, ekat::subview(thetal, i), ekat::subview(qw, i), ekat::subview(w_field, i),
-            ekat::subview(thl_sec, i), ekat::subview(qw_sec, i), ekat::subview(wthl_sec, i), ekat::subview(w_sec, i),
-            ekat::subview(wqw_sec, i), ekat::subview(qwthl_sec, i), ekat::subview(w3, i), ekat::subview(pres, i),
-            ekat::subview(zt_grid, i), ekat::subview(zi_grid, i), workspace, ekat::subview(shoc_cldfrac, i),
-            ekat::subview(shoc_ql, i), ekat::subview(wqls, i), ekat::subview(wthv_sec, i), ekat::subview(shoc_ql2, i));
+            team, nlev, nlevi, ekat::subview(thetal, i), ekat::subview(qw, i),
+            ekat::subview(w_field, i), ekat::subview(thl_sec, i), ekat::subview(qw_sec, i),
+            ekat::subview(wthl_sec, i), ekat::subview(w_sec, i), ekat::subview(wqw_sec, i),
+            ekat::subview(qwthl_sec, i), ekat::subview(w3, i), ekat::subview(pres, i),
+            ekat::subview(zt_grid, i), ekat::subview(zi_grid, i), workspace,
+            ekat::subview(shoc_cldfrac, i), ekat::subview(shoc_ql, i), ekat::subview(wqls, i),
+            ekat::subview(wthv_sec, i), ekat::subview(shoc_ql2, i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_check_tke_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_check_tke_disp.cpp
index 4b9e025a32..ff049d77f4 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_check_tke_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_check_tke_disp.cpp
@@ -6,7 +6,8 @@ namespace scream {
 namespace shoc {
 
 template <>
-void Functions<Real, DefaultDevice>::check_tke_disp(const Int &shcol, const Int &nlev, const view_2d<Spack> &tke) {
+void Functions<Real, DefaultDevice>::check_tke_disp(const Int &shcol, const Int &nlev,
+                                                    const view_2d<Spack> &tke) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_compute_shoc_temperature_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_compute_shoc_temperature_disp.cpp
index beb72acbcf..2c806e260a 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_compute_shoc_temperature_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_compute_shoc_temperature_disp.cpp
@@ -6,11 +6,10 @@ namespace scream {
 namespace shoc {
 
 template <>
-void Functions<Real, DefaultDevice>::compute_shoc_temperature_disp(const Int &shcol, const Int &nlev,
-                                                                   const view_2d<const Spack> &thetal,
-                                                                   const view_2d<const Spack> &ql,
-                                                                   const view_2d<const Spack> &inv_exner,
-                                                                   const view_2d<Spack> &tabs) {
+void Functions<Real, DefaultDevice>::compute_shoc_temperature_disp(
+    const Int &shcol, const Int &nlev, const view_2d<const Spack> &thetal,
+    const view_2d<const Spack> &ql, const view_2d<const Spack> &inv_exner,
+    const view_2d<Spack> &tabs) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_compute_shoc_vapor_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_compute_shoc_vapor_disp.cpp
index 2d9de11ce5..cc4c457fca 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_compute_shoc_vapor_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_compute_shoc_vapor_disp.cpp
@@ -8,7 +8,8 @@ namespace shoc {
 template <>
 void Functions<Real, DefaultDevice>::compute_shoc_vapor_disp(const Int &shcol, const Int &nlev,
                                                              const view_2d<const Spack> &qw,
-                                                             const view_2d<const Spack> &ql, const view_2d<Spack> &qv) {
+                                                             const view_2d<const Spack> &ql,
+                                                             const view_2d<Spack> &qv) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
@@ -17,7 +18,8 @@ void Functions<Real, DefaultDevice>::compute_shoc_vapor_disp(const Int &shcol, c
       policy, KOKKOS_LAMBDA(const MemberType &team) {
         const Int i = team.league_rank();
 
-        compute_shoc_vapor(team, nlev, ekat::subview(qw, i), ekat::subview(ql, i), ekat::subview(qv, i));
+        compute_shoc_vapor(team, nlev, ekat::subview(qw, i), ekat::subview(ql, i),
+                           ekat::subview(qv, i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_diag_obklen_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_diag_obklen_disp.cpp
index 0b80e1b92e..6abe99a31a 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_diag_obklen_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_diag_obklen_disp.cpp
@@ -7,15 +7,17 @@ namespace shoc {
 
 template <>
 void Functions<Real, DefaultDevice>::shoc_diag_obklen_disp(
-    const Int &shcol, const Int &nlev, const view_1d<const Scalar> &uw_sfc, const view_1d<const Scalar> &vw_sfc,
-    const view_1d<const Scalar> &wthl_sfc, const view_1d<const Scalar> &wqw_sfc, const view_2d<const Scalar> &thl_sfc,
-    const view_2d<const Scalar> &cldliq_sfc, const view_2d<const Scalar> &qv_sfc, const view_1d<Scalar> &ustar,
-    const view_1d<Scalar> &kbfs, const view_1d<Scalar> &obklen) {
+    const Int &shcol, const Int &nlev, const view_1d<const Scalar> &uw_sfc,
+    const view_1d<const Scalar> &vw_sfc, const view_1d<const Scalar> &wthl_sfc,
+    const view_1d<const Scalar> &wqw_sfc, const view_2d<const Scalar> &thl_sfc,
+    const view_2d<const Scalar> &cldliq_sfc, const view_2d<const Scalar> &qv_sfc,
+    const view_1d<Scalar> &ustar, const view_1d<Scalar> &kbfs, const view_1d<Scalar> &obklen) {
   Kokkos::parallel_for(
       shcol, KOKKOS_LAMBDA(const Int &i) {
-        shoc_diag_obklen(uw_sfc(i), vw_sfc(i), wthl_sfc(i), wqw_sfc(i), ekat::subview(thl_sfc, i)(nlev - 1),
-                         ekat::subview(cldliq_sfc, i)(nlev - 1), ekat::subview(qv_sfc, i)(nlev - 1), ustar(i), kbfs(i),
-                         obklen(i));
+        shoc_diag_obklen(uw_sfc(i), vw_sfc(i), wthl_sfc(i), wqw_sfc(i),
+                         ekat::subview(thl_sfc, i)(nlev - 1),
+                         ekat::subview(cldliq_sfc, i)(nlev - 1), ekat::subview(qv_sfc, i)(nlev - 1),
+                         ustar(i), kbfs(i), obklen(i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_diag_second_shoc_moments_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_diag_second_shoc_moments_disp.cpp
index 1994e783c1..1473ac25dc 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_diag_second_shoc_moments_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_diag_second_shoc_moments_disp.cpp
@@ -8,12 +8,15 @@ namespace shoc {
 template <>
 void Functions<Real, DefaultDevice>::diag_second_shoc_moments_disp(
     const Int &shcol, const Int &nlev, const Int &nlevi, const Real &thl2tune, const Real &qw2tune,
-    const Real &qwthl2tune, const Real &w2tune, const view_2d<const Spack> &thetal, const view_2d<const Spack> &qw,
-    const view_2d<const Spack> &u_wind, const view_2d<const Spack> &v_wind, const view_2d<const Spack> &tke,
-    const view_2d<const Spack> &isotropy, const view_2d<const Spack> &tkh, const view_2d<const Spack> &tk,
-    const view_2d<const Spack> &dz_zi, const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
-    const view_2d<const Spack> &shoc_mix, const view_1d<const Scalar> &wthl_sfc, const view_1d<const Scalar> &wqw_sfc,
-    const view_1d<const Scalar> &uw_sfc, const view_1d<const Scalar> &vw_sfc, const view_1d<Scalar> &ustar2,
+    const Real &qwthl2tune, const Real &w2tune, const view_2d<const Spack> &thetal,
+    const view_2d<const Spack> &qw, const view_2d<const Spack> &u_wind,
+    const view_2d<const Spack> &v_wind, const view_2d<const Spack> &tke,
+    const view_2d<const Spack> &isotropy, const view_2d<const Spack> &tkh,
+    const view_2d<const Spack> &tk, const view_2d<const Spack> &dz_zi,
+    const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
+    const view_2d<const Spack> &shoc_mix, const view_1d<const Scalar> &wthl_sfc,
+    const view_1d<const Scalar> &wqw_sfc, const view_1d<const Scalar> &uw_sfc,
+    const view_1d<const Scalar> &vw_sfc, const view_1d<Scalar> &ustar2,
     const view_1d<Scalar> &wstar, const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &thl_sec,
     const view_2d<Spack> &qw_sec, const view_2d<Spack> &wthl_sec, const view_2d<Spack> &wqw_sec,
     const view_2d<Spack> &qwthl_sec, const view_2d<Spack> &uw_sec, const view_2d<Spack> &vw_sec,
@@ -29,13 +32,15 @@ void Functions<Real, DefaultDevice>::diag_second_shoc_moments_disp(
         auto workspace = workspace_mgr.get_workspace(team);
 
         diag_second_shoc_moments(
-            team, nlev, nlevi, thl2tune, qw2tune, qwthl2tune, w2tune, ekat::subview(thetal, i), ekat::subview(qw, i),
-            ekat::subview(u_wind, i), ekat::subview(v_wind, i), ekat::subview(tke, i), ekat::subview(isotropy, i),
-            ekat::subview(tkh, i), ekat::subview(tk, i), ekat::subview(dz_zi, i), ekat::subview(zt_grid, i),
-            ekat::subview(zi_grid, i), ekat::subview(shoc_mix, i), wthl_sfc(i), wqw_sfc(i), uw_sfc(i), vw_sfc(i),
-            ustar2(i), wstar(i), workspace, ekat::subview(thl_sec, i), ekat::subview(qw_sec, i),
-            ekat::subview(wthl_sec, i), ekat::subview(wqw_sec, i), ekat::subview(qwthl_sec, i),
-            ekat::subview(uw_sec, i), ekat::subview(vw_sec, i), ekat::subview(wtke_sec, i), ekat::subview(w_sec, i));
+            team, nlev, nlevi, thl2tune, qw2tune, qwthl2tune, w2tune, ekat::subview(thetal, i),
+            ekat::subview(qw, i), ekat::subview(u_wind, i), ekat::subview(v_wind, i),
+            ekat::subview(tke, i), ekat::subview(isotropy, i), ekat::subview(tkh, i),
+            ekat::subview(tk, i), ekat::subview(dz_zi, i), ekat::subview(zt_grid, i),
+            ekat::subview(zi_grid, i), ekat::subview(shoc_mix, i), wthl_sfc(i), wqw_sfc(i),
+            uw_sfc(i), vw_sfc(i), ustar2(i), wstar(i), workspace, ekat::subview(thl_sec, i),
+            ekat::subview(qw_sec, i), ekat::subview(wthl_sec, i), ekat::subview(wqw_sec, i),
+            ekat::subview(qwthl_sec, i), ekat::subview(uw_sec, i), ekat::subview(vw_sec, i),
+            ekat::subview(wtke_sec, i), ekat::subview(w_sec, i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_diag_third_shoc_moments_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_diag_third_shoc_moments_disp.cpp
index 83affd54c3..f026de2e8f 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_diag_third_shoc_moments_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_diag_third_shoc_moments_disp.cpp
@@ -8,10 +8,12 @@ namespace shoc {
 template <>
 void Functions<Real, DefaultDevice>::diag_third_shoc_moments_disp(
     const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &c_diag_3rd_mom,
-    const view_2d<const Spack> &w_sec, const view_2d<const Spack> &thl_sec, const view_2d<const Spack> &wthl_sec,
-    const view_2d<const Spack> &isotropy, const view_2d<const Spack> &brunt, const view_2d<const Spack> &thetal,
-    const view_2d<const Spack> &tke, const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &dz_zi,
-    const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid, const WorkspaceMgr &workspace_mgr,
+    const view_2d<const Spack> &w_sec, const view_2d<const Spack> &thl_sec,
+    const view_2d<const Spack> &wthl_sec, const view_2d<const Spack> &isotropy,
+    const view_2d<const Spack> &brunt, const view_2d<const Spack> &thetal,
+    const view_2d<const Spack> &tke, const view_2d<const Spack> &dz_zt,
+    const view_2d<const Spack> &dz_zi, const view_2d<const Spack> &zt_grid,
+    const view_2d<const Spack> &zi_grid, const WorkspaceMgr &workspace_mgr,
     const view_2d<Spack> &w3) {
   using ExeSpace = typename KT::ExeSpace;
 
@@ -23,11 +25,12 @@ void Functions<Real, DefaultDevice>::diag_third_shoc_moments_disp(
 
         auto workspace = workspace_mgr.get_workspace(team);
 
-        diag_third_shoc_moments(team, nlev, nlevi, c_diag_3rd_mom, ekat::subview(w_sec, i), ekat::subview(thl_sec, i),
-                                ekat::subview(wthl_sec, i), ekat::subview(isotropy, i), ekat::subview(brunt, i),
-                                ekat::subview(thetal, i), ekat::subview(tke, i), ekat::subview(dz_zt, i),
-                                ekat::subview(dz_zi, i), ekat::subview(zt_grid, i), ekat::subview(zi_grid, i),
-                                workspace, ekat::subview(w3, i));
+        diag_third_shoc_moments(
+            team, nlev, nlevi, c_diag_3rd_mom, ekat::subview(w_sec, i), ekat::subview(thl_sec, i),
+            ekat::subview(wthl_sec, i), ekat::subview(isotropy, i), ekat::subview(brunt, i),
+            ekat::subview(thetal, i), ekat::subview(tke, i), ekat::subview(dz_zt, i),
+            ekat::subview(dz_zi, i), ekat::subview(zt_grid, i), ekat::subview(zi_grid, i),
+            workspace, ekat::subview(w3, i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_energy_fixer_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_energy_fixer_disp.cpp
index 56459ea0fb..dfd34caaf3 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_energy_fixer_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_energy_fixer_disp.cpp
@@ -8,12 +8,15 @@ namespace shoc {
 template <>
 void Functions<Real, DefaultDevice>::shoc_energy_fixer_disp(
     const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &dtime, const Int &nadv,
-    const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid, const view_1d<const Scalar> &se_b,
-    const view_1d<const Scalar> &ke_b, const view_1d<const Scalar> &wv_b, const view_1d<const Scalar> &wl_b,
-    const view_1d<const Scalar> &se_a, const view_1d<const Scalar> &ke_a, const view_1d<const Scalar> &wv_a,
-    const view_1d<const Scalar> &wl_a, const view_1d<const Scalar> &wthl_sfc, const view_1d<const Scalar> &wqw_sfc,
-    const view_2d<const Spack> &rho_zt, const view_2d<const Spack> &tke, const view_2d<const Spack> &pint,
-    const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &host_dse) {
+    const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
+    const view_1d<const Scalar> &se_b, const view_1d<const Scalar> &ke_b,
+    const view_1d<const Scalar> &wv_b, const view_1d<const Scalar> &wl_b,
+    const view_1d<const Scalar> &se_a, const view_1d<const Scalar> &ke_a,
+    const view_1d<const Scalar> &wv_a, const view_1d<const Scalar> &wl_a,
+    const view_1d<const Scalar> &wthl_sfc, const view_1d<const Scalar> &wqw_sfc,
+    const view_2d<const Spack> &rho_zt, const view_2d<const Spack> &tke,
+    const view_2d<const Spack> &pint, const WorkspaceMgr &workspace_mgr,
+    const view_2d<Spack> &host_dse) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
@@ -24,10 +27,11 @@ void Functions<Real, DefaultDevice>::shoc_energy_fixer_disp(
 
         auto workspace = workspace_mgr.get_workspace(team);
 
-        shoc_energy_fixer(team, nlev, nlevi, dtime, nadv, ekat::subview(zt_grid, i), ekat::subview(zi_grid, i), se_b(i),
-                          ke_b(i), wv_b(i), wl_b(i), se_a(i), ke_a(i), wv_a(i), wl_a(i), wthl_sfc(i), wqw_sfc(i),
-                          ekat::subview(rho_zt, i), ekat::subview(tke, i), ekat::subview(pint, i), workspace,
-                          ekat::subview(host_dse, i));
+        shoc_energy_fixer(team, nlev, nlevi, dtime, nadv, ekat::subview(zt_grid, i),
+                          ekat::subview(zi_grid, i), se_b(i), ke_b(i), wv_b(i), wl_b(i), se_a(i),
+                          ke_a(i), wv_a(i), wl_a(i), wthl_sfc(i), wqw_sfc(i),
+                          ekat::subview(rho_zt, i), ekat::subview(tke, i), ekat::subview(pint, i),
+                          workspace, ekat::subview(host_dse, i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_energy_integrals_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_energy_integrals_disp.cpp
index 3477256137..4551e32e34 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_energy_integrals_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_energy_integrals_disp.cpp
@@ -7,8 +7,9 @@ namespace shoc {
 
 template <>
 void Functions<Real, DefaultDevice>::shoc_energy_integrals_disp(
-    const Int &shcol, const Int &nlev, const view_2d<const Spack> &host_dse, const view_2d<const Spack> &pdel,
-    const view_2d<const Spack> &rtm, const view_2d<const Spack> &rcm, const uview_2d<const Spack> &u_wind,
+    const Int &shcol, const Int &nlev, const view_2d<const Spack> &host_dse,
+    const view_2d<const Spack> &pdel, const view_2d<const Spack> &rtm,
+    const view_2d<const Spack> &rcm, const uview_2d<const Spack> &u_wind,
     const uview_2d<const Spack> &v_wind, const view_1d<Scalar> &se_b, const view_1d<Scalar> &ke_b,
     const view_1d<Scalar> &wv_b, const view_1d<Scalar> &wl_b) {
   using ExeSpace = typename KT::ExeSpace;
@@ -19,9 +20,10 @@ void Functions<Real, DefaultDevice>::shoc_energy_integrals_disp(
       policy, KOKKOS_LAMBDA(const MemberType &team) {
         const Int i = team.league_rank();
 
-        shoc_energy_integrals(team, nlev, ekat::subview(host_dse, i), ekat::subview(pdel, i), ekat::subview(rtm, i),
-                              ekat::subview(rcm, i), ekat::subview(u_wind, i), ekat::subview(v_wind, i), se_b(i),
-                              ke_b(i), wv_b(i), wl_b(i));
+        shoc_energy_integrals(team, nlev, ekat::subview(host_dse, i), ekat::subview(pdel, i),
+                              ekat::subview(rtm, i), ekat::subview(rcm, i),
+                              ekat::subview(u_wind, i), ekat::subview(v_wind, i), se_b(i), ke_b(i),
+                              wv_b(i), wl_b(i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_grid_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_grid_disp.cpp
index 694b561a63..4fdf88d944 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_grid_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_grid_disp.cpp
@@ -6,11 +6,10 @@ namespace scream {
 namespace shoc {
 
 template <>
-void Functions<Real, DefaultDevice>::shoc_grid_disp(const Int &shcol, const Int &nlev, const Int &nlevi,
-                                                    const view_2d<const Spack> &zt_grid,
-                                                    const view_2d<const Spack> &zi_grid,
-                                                    const view_2d<const Spack> &pdel, const view_2d<Spack> &dz_zt,
-                                                    const view_2d<Spack> &dz_zi, const view_2d<Spack> &rho_zt) {
+void Functions<Real, DefaultDevice>::shoc_grid_disp(
+    const Int &shcol, const Int &nlev, const Int &nlevi, const view_2d<const Spack> &zt_grid,
+    const view_2d<const Spack> &zi_grid, const view_2d<const Spack> &pdel,
+    const view_2d<Spack> &dz_zt, const view_2d<Spack> &dz_zi, const view_2d<Spack> &rho_zt) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
@@ -19,8 +18,9 @@ void Functions<Real, DefaultDevice>::shoc_grid_disp(const Int &shcol, const Int
       policy, KOKKOS_LAMBDA(const MemberType &team) {
         const Int i = team.league_rank();
 
-        shoc_grid(team, nlev, nlevi, ekat::subview(zt_grid, i), ekat::subview(zi_grid, i), ekat::subview(pdel, i),
-                  ekat::subview(dz_zt, i), ekat::subview(dz_zi, i), ekat::subview(rho_zt, i));
+        shoc_grid(team, nlev, nlevi, ekat::subview(zt_grid, i), ekat::subview(zi_grid, i),
+                  ekat::subview(pdel, i), ekat::subview(dz_zt, i), ekat::subview(dz_zi, i),
+                  ekat::subview(rho_zt, i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_length_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_length_disp.cpp
index c2319962ee..b784ddb7df 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_length_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_length_disp.cpp
@@ -7,10 +7,12 @@ namespace shoc {
 
 template <>
 void Functions<Real, DefaultDevice>::shoc_length_disp(
-    const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &length_fac, const view_1d<const Scalar> &dx,
-    const view_1d<const Scalar> &dy, const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
-    const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &tke, const view_2d<const Spack> &thv,
-    const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &brunt, const view_2d<Spack> &shoc_mix) {
+    const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &length_fac,
+    const view_1d<const Scalar> &dx, const view_1d<const Scalar> &dy,
+    const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
+    const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &tke,
+    const view_2d<const Spack> &thv, const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &brunt,
+    const view_2d<Spack> &shoc_mix) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
@@ -21,9 +23,10 @@ void Functions<Real, DefaultDevice>::shoc_length_disp(
 
         auto workspace = workspace_mgr.get_workspace(team);
 
-        shoc_length(team, nlev, nlevi, length_fac, dx(i), dy(i), ekat::subview(zt_grid, i), ekat::subview(zi_grid, i),
-                    ekat::subview(dz_zt, i), ekat::subview(tke, i), ekat::subview(thv, i), workspace,
-                    ekat::subview(brunt, i), ekat::subview(shoc_mix, i));
+        shoc_length(team, nlev, nlevi, length_fac, dx(i), dy(i), ekat::subview(zt_grid, i),
+                    ekat::subview(zi_grid, i), ekat::subview(dz_zt, i), ekat::subview(tke, i),
+                    ekat::subview(thv, i), workspace, ekat::subview(brunt, i),
+                    ekat::subview(shoc_mix, i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_pblintd_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_pblintd_disp.cpp
index 89311b686c..cd5f19b3a5 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_pblintd_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_pblintd_disp.cpp
@@ -6,14 +6,14 @@ namespace scream {
 namespace shoc {
 
 template <>
-void Functions<Real, DefaultDevice>::pblintd_disp(const Int &shcol, const Int &nlev, const Int &nlevi, const Int &npbl,
-                                                  const view_2d<const Spack> &z, const view_2d<const Spack> &zi,
-                                                  const view_2d<const Spack> &thl, const view_2d<const Spack> &ql,
-                                                  const view_2d<const Spack> &q, const view_2d<const Spack> &u,
-                                                  const view_2d<const Spack> &v, const view_1d<const Scalar> &ustar,
-                                                  const view_1d<const Scalar> &obklen,
-                                                  const view_1d<const Scalar> &kbfs, const view_2d<const Spack> &cldn,
-                                                  const WorkspaceMgr &workspace_mgr, const view_1d<Scalar> &pblh) {
+void Functions<Real, DefaultDevice>::pblintd_disp(
+    const Int &shcol, const Int &nlev, const Int &nlevi, const Int &npbl,
+    const view_2d<const Spack> &z, const view_2d<const Spack> &zi, const view_2d<const Spack> &thl,
+    const view_2d<const Spack> &ql, const view_2d<const Spack> &q, const view_2d<const Spack> &u,
+    const view_2d<const Spack> &v, const view_1d<const Scalar> &ustar,
+    const view_1d<const Scalar> &obklen, const view_1d<const Scalar> &kbfs,
+    const view_2d<const Spack> &cldn, const WorkspaceMgr &workspace_mgr,
+    const view_1d<Scalar> &pblh) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
@@ -25,9 +25,10 @@ void Functions<Real, DefaultDevice>::pblintd_disp(const Int &shcol, const Int &n
         auto workspace = workspace_mgr.get_workspace(team);
 
         Scalar pblh_;
-        pblintd(team, nlev, nlevi, npbl, ekat::subview(z, i), ekat::subview(zi, i), ekat::subview(thl, i),
-                ekat::subview(ql, i), ekat::subview(q, i), ekat::subview(u, i), ekat::subview(v, i), ustar(i),
-                obklen(i), kbfs(i), ekat::subview(cldn, i), workspace, pblh_);
+        pblintd(team, nlev, nlevi, npbl, ekat::subview(z, i), ekat::subview(zi, i),
+                ekat::subview(thl, i), ekat::subview(ql, i), ekat::subview(q, i),
+                ekat::subview(u, i), ekat::subview(v, i), ustar(i), obklen(i), kbfs(i),
+                ekat::subview(cldn, i), workspace, pblh_);
         pblh(i) = pblh_;
       });
 }
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_tke_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_tke_disp.cpp
index 56e190c80b..23ff70a151 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_tke_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_tke_disp.cpp
@@ -7,14 +7,17 @@ namespace shoc {
 
 template <>
 void Functions<Real, DefaultDevice>::shoc_tke_disp(
-    const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &dtime, const Scalar &lambda_low,
-    const Scalar &lambda_high, const Scalar &lambda_slope, const Scalar &lambda_thresh, const Scalar &Ckh,
-    const Scalar &Ckm, const view_2d<const Spack> &wthv_sec, const view_2d<const Spack> &shoc_mix,
-    const view_2d<const Spack> &dz_zi, const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &pres,
-    const view_2d<const Spack> &tabs, const view_2d<const Spack> &u_wind, const view_2d<const Spack> &v_wind,
-    const view_2d<const Spack> &brunt, const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
-    const view_1d<const Scalar> &pblh, const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &tke,
-    const view_2d<Spack> &tk, const view_2d<Spack> &tkh, const view_2d<Spack> &isotropy) {
+    const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &dtime,
+    const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope,
+    const Scalar &lambda_thresh, const Scalar &Ckh, const Scalar &Ckm,
+    const view_2d<const Spack> &wthv_sec, const view_2d<const Spack> &shoc_mix,
+    const view_2d<const Spack> &dz_zi, const view_2d<const Spack> &dz_zt,
+    const view_2d<const Spack> &pres, const view_2d<const Spack> &tabs,
+    const view_2d<const Spack> &u_wind, const view_2d<const Spack> &v_wind,
+    const view_2d<const Spack> &brunt, const view_2d<const Spack> &zt_grid,
+    const view_2d<const Spack> &zi_grid, const view_1d<const Scalar> &pblh,
+    const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &tke, const view_2d<Spack> &tk,
+    const view_2d<Spack> &tkh, const view_2d<Spack> &isotropy) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
@@ -25,11 +28,12 @@ void Functions<Real, DefaultDevice>::shoc_tke_disp(
 
         auto workspace = workspace_mgr.get_workspace(team);
 
-        shoc_tke(team, nlev, nlevi, dtime, lambda_low, lambda_high, lambda_slope, lambda_thresh, Ckh, Ckm,
-                 ekat::subview(wthv_sec, i), ekat::subview(shoc_mix, i), ekat::subview(dz_zi, i),
-                 ekat::subview(dz_zt, i), ekat::subview(pres, i), ekat::subview(tabs, i), ekat::subview(u_wind, i),
-                 ekat::subview(v_wind, i), ekat::subview(brunt, i), ekat::subview(zt_grid, i),
-                 ekat::subview(zi_grid, i), pblh(i), workspace, ekat::subview(tke, i), ekat::subview(tk, i),
+        shoc_tke(team, nlev, nlevi, dtime, lambda_low, lambda_high, lambda_slope, lambda_thresh,
+                 Ckh, Ckm, ekat::subview(wthv_sec, i), ekat::subview(shoc_mix, i),
+                 ekat::subview(dz_zi, i), ekat::subview(dz_zt, i), ekat::subview(pres, i),
+                 ekat::subview(tabs, i), ekat::subview(u_wind, i), ekat::subview(v_wind, i),
+                 ekat::subview(brunt, i), ekat::subview(zt_grid, i), ekat::subview(zi_grid, i),
+                 pblh(i), workspace, ekat::subview(tke, i), ekat::subview(tk, i),
                  ekat::subview(tkh, i), ekat::subview(isotropy, i));
       });
 }
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_update_host_dse_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_update_host_dse_disp.cpp
index 3d7d311bea..e1f36ee803 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_update_host_dse_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_update_host_dse_disp.cpp
@@ -6,10 +6,13 @@ namespace scream {
 namespace shoc {
 
 template <>
-void Functions<Real, DefaultDevice>::update_host_dse_disp(
-    const Int &shcol, const Int &nlev, const view_2d<const Spack> &thlm, const view_2d<const Spack> &shoc_ql,
-    const view_2d<const Spack> &inv_exner, const view_2d<const Spack> &zt_grid, const view_1d<const Scalar> &phis,
-    const view_2d<Spack> &host_dse) {
+void Functions<Real, DefaultDevice>::update_host_dse_disp(const Int &shcol, const Int &nlev,
+                                                          const view_2d<const Spack> &thlm,
+                                                          const view_2d<const Spack> &shoc_ql,
+                                                          const view_2d<const Spack> &inv_exner,
+                                                          const view_2d<const Spack> &zt_grid,
+                                                          const view_1d<const Scalar> &phis,
+                                                          const view_2d<Spack> &host_dse) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
@@ -18,8 +21,9 @@ void Functions<Real, DefaultDevice>::update_host_dse_disp(
       policy, KOKKOS_LAMBDA(const MemberType &team) {
         const Int i = team.league_rank();
 
-        update_host_dse(team, nlev, ekat::subview(thlm, i), ekat::subview(shoc_ql, i), ekat::subview(inv_exner, i),
-                        ekat::subview(zt_grid, i), phis(i), ekat::subview(host_dse, i));
+        update_host_dse(team, nlev, ekat::subview(thlm, i), ekat::subview(shoc_ql, i),
+                        ekat::subview(inv_exner, i), ekat::subview(zt_grid, i), phis(i),
+                        ekat::subview(host_dse, i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/disp/shoc_update_prognostics_implicit_disp.cpp w/components/eamxx/src/physics/shoc/disp/shoc_update_prognostics_implicit_disp.cpp
index 309fc37e44..859fa2f789 100644
--- i/components/eamxx/src/physics/shoc/disp/shoc_update_prognostics_implicit_disp.cpp
+++ w/components/eamxx/src/physics/shoc/disp/shoc_update_prognostics_implicit_disp.cpp
@@ -8,13 +8,15 @@ namespace shoc {
 template <>
 void Functions<Real, DefaultDevice>::update_prognostics_implicit_disp(
     const Int &shcol, const Int &nlev, const Int &nlevi, const Int &num_tracer, const Scalar &dtime,
-    const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &dz_zi, const view_2d<const Spack> &rho_zt,
-    const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid, const view_2d<const Spack> &tk,
-    const view_2d<const Spack> &tkh, const view_1d<const Scalar> &uw_sfc, const view_1d<const Scalar> &vw_sfc,
-    const view_1d<const Scalar> &wthl_sfc, const view_1d<const Scalar> &wqw_sfc,
-    const view_2d<const Spack> &wtracer_sfc, const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &thetal,
-    const view_2d<Spack> &qw, const view_3d_strided<Spack> &tracer, const view_2d<Spack> &tke,
-    const view_2d<Spack> &u_wind, const view_2d<Spack> &v_wind) {
+    const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &dz_zi,
+    const view_2d<const Spack> &rho_zt, const view_2d<const Spack> &zt_grid,
+    const view_2d<const Spack> &zi_grid, const view_2d<const Spack> &tk,
+    const view_2d<const Spack> &tkh, const view_1d<const Scalar> &uw_sfc,
+    const view_1d<const Scalar> &vw_sfc, const view_1d<const Scalar> &wthl_sfc,
+    const view_1d<const Scalar> &wqw_sfc, const view_2d<const Spack> &wtracer_sfc,
+    const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &thetal, const view_2d<Spack> &qw,
+    const view_3d_strided<Spack> &tracer, const view_2d<Spack> &tke, const view_2d<Spack> &u_wind,
+    const view_2d<Spack> &v_wind) {
   using ExeSpace = typename KT::ExeSpace;
 
   const auto nlev_packs = ekat::npack<Spack>(nlev);
@@ -25,13 +27,13 @@ void Functions<Real, DefaultDevice>::update_prognostics_implicit_disp(
 
         auto workspace = workspace_mgr.get_workspace(team);
 
-        update_prognostics_implicit(team, nlev, nlevi, num_tracer, dtime, ekat::subview(dz_zt, i),
-                                    ekat::subview(dz_zi, i), ekat::subview(rho_zt, i), ekat::subview(zt_grid, i),
-                                    ekat::subview(zi_grid, i), ekat::subview(tk, i), ekat::subview(tkh, i), uw_sfc(i),
-                                    vw_sfc(i), wthl_sfc(i), wqw_sfc(i), ekat::subview(wtracer_sfc, i), workspace,
-                                    ekat::subview(thetal, i), ekat::subview(qw, i),
-                                    Kokkos::subview(tracer, i, Kokkos::ALL(), Kokkos::ALL()), ekat::subview(tke, i),
-                                    ekat::subview(u_wind, i), ekat::subview(v_wind, i));
+        update_prognostics_implicit(
+            team, nlev, nlevi, num_tracer, dtime, ekat::subview(dz_zt, i), ekat::subview(dz_zi, i),
+            ekat::subview(rho_zt, i), ekat::subview(zt_grid, i), ekat::subview(zi_grid, i),
+            ekat::subview(tk, i), ekat::subview(tkh, i), uw_sfc(i), vw_sfc(i), wthl_sfc(i),
+            wqw_sfc(i), ekat::subview(wtracer_sfc, i), workspace, ekat::subview(thetal, i),
+            ekat::subview(qw, i), Kokkos::subview(tracer, i, Kokkos::ALL(), Kokkos::ALL()),
+            ekat::subview(tke, i), ekat::subview(u_wind, i), ekat::subview(v_wind, i));
       });
 }
 
diff --git i/components/eamxx/src/physics/shoc/eamxx_shoc_process_interface.cpp w/components/eamxx/src/physics/shoc/eamxx_shoc_process_interface.cpp
index 1be0c0b9c7..4e43ee660b 100644
--- i/components/eamxx/src/physics/shoc/eamxx_shoc_process_interface.cpp
+++ w/components/eamxx/src/physics/shoc/eamxx_shoc_process_interface.cpp
@@ -121,14 +121,16 @@ void SHOCMacrophysics::set_grids(const std::shared_ptr<const GridsManager> grids
 
 // =========================================================================================
 void SHOCMacrophysics::set_computed_group_impl(const FieldGroup &group) {
-  EKAT_REQUIRE_MSG(group.m_info->size() >= 3, "Error! Shoc requires at least 3 tracers (tke, qv, qc) as inputs.");
+  EKAT_REQUIRE_MSG(group.m_info->size() >= 3,
+                   "Error! Shoc requires at least 3 tracers (tke, qv, qc) as inputs.");
 
   const auto &name = group.m_info->m_group_name;
 
   EKAT_REQUIRE_MSG(name == "turbulence_advected_tracers",
                    "Error! We were not expecting a field group called '" << name << "\n");
 
-  EKAT_REQUIRE_MSG(group.m_info->m_monolithic_allocation, "Error! Shoc expects a monolithic allocation for tracers.\n");
+  EKAT_REQUIRE_MSG(group.m_info->m_monolithic_allocation,
+                   "Error! Shoc expects a monolithic allocation for tracers.\n");
 
   // Calculate number of advected tracers
   m_num_tracers = group.m_info->size();
@@ -141,17 +143,20 @@ size_t SHOCMacrophysics::requested_buffer_size_in_bytes() const {
   const int num_tracer_packs = ekat::npack<Spack>(m_num_tracers);
 
   // Number of Reals needed by local views in the interface
-  const size_t interface_request = Buffer::num_1d_scalar_ncol * m_num_cols * sizeof(Real) +
-                                   Buffer::num_1d_scalar_nlev * nlev_packs * sizeof(Spack) +
-                                   Buffer::num_2d_vector_mid * m_num_cols * nlev_packs * sizeof(Spack) +
-                                   Buffer::num_2d_vector_int * m_num_cols * nlevi_packs * sizeof(Spack) +
-                                   Buffer::num_2d_vector_tr * m_num_cols * num_tracer_packs * sizeof(Spack);
+  const size_t interface_request =
+      Buffer::num_1d_scalar_ncol * m_num_cols * sizeof(Real) +
+      Buffer::num_1d_scalar_nlev * nlev_packs * sizeof(Spack) +
+      Buffer::num_2d_vector_mid * m_num_cols * nlev_packs * sizeof(Spack) +
+      Buffer::num_2d_vector_int * m_num_cols * nlevi_packs * sizeof(Spack) +
+      Buffer::num_2d_vector_tr * m_num_cols * num_tracer_packs * sizeof(Spack);
 
   // Number of Reals needed by the WorkspaceManager passed to shoc_main
-  const auto policy        = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
-  const int n_wind_slots   = ekat::npack<Spack>(2) * Spack::n;
-  const int n_trac_slots   = ekat::npack<Spack>(m_num_tracers + 3) * Spack::n;
-  const size_t wsm_request = WSM::get_total_bytes_needed(nlevi_packs, 14 + (n_wind_slots + n_trac_slots), policy);
+  const auto policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
+  const int n_wind_slots = ekat::npack<Spack>(2) * Spack::n;
+  const int n_trac_slots = ekat::npack<Spack>(m_num_tracers + 3) * Spack::n;
+  const size_t wsm_request =
+      WSM::get_total_bytes_needed(nlevi_packs, 14 + (n_wind_slots + n_trac_slots), policy);
 
   return interface_request + wsm_request;
 }
@@ -262,11 +267,13 @@ void SHOCMacrophysics::init_buffers(const ATMBufferManager &buffer_manager) {
 
   // Compute workspace manager size to check used memory
   // vs. requested memory
-  const auto policy      = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
+  const auto policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
   const int n_wind_slots = ekat::npack<Spack>(2) * Spack::n;
   const int n_trac_slots = ekat::npack<Spack>(m_num_tracers + 3) * Spack::n;
   const int wsm_size =
-      WSM::get_total_bytes_needed(nlevi_packs, 14 + (n_wind_slots + n_trac_slots), policy) / sizeof(Spack);
+      WSM::get_total_bytes_needed(nlevi_packs, 14 + (n_wind_slots + n_trac_slots), policy) /
+      sizeof(Spack);
   s_mem += wsm_size;
 
   size_t used_mem = (reinterpret_cast<Real *>(s_mem) - buffer_manager.get_memory()) * sizeof(Real);
@@ -300,10 +307,11 @@ void SHOCMacrophysics::initialize_impl(const RunType run_type) {
   const auto &surf_sens_flux = get_field_in("surf_sens_flux").get_view<const Real *>();
   const auto &surf_evap      = get_field_in("surf_evap").get_view<const Real *>();
   const auto &surf_mom_flux  = get_field_in("surf_mom_flux").get_view<const Real **>();
-  const auto &qtracers = get_group_out("turbulence_advected_tracers").m_monolithic_field->get_strided_view<Spack ***>();
-  const auto &qc       = get_field_out("qc").get_view<Spack **>();
-  const auto &qv       = get_field_out("qv").get_view<Spack **>();
-  const auto &tke      = get_field_out("tke").get_view<Spack **>();
+  const auto &qtracers       = get_group_out("turbulence_advected_tracers")
+                             .m_monolithic_field->get_strided_view<Spack ***>();
+  const auto &qc               = get_field_out("qc").get_view<Spack **>();
+  const auto &qv               = get_field_out("qv").get_view<Spack **>();
+  const auto &tke              = get_field_out("tke").get_view<Spack **>();
   const auto &cldfrac_liq      = get_field_out("cldfrac_liq").get_view<Spack **>();
   const auto &cldfrac_liq_prev = get_field_out("cldfrac_liq_prev").get_view<Spack **>();
   const auto &sgs_buoy_flux    = get_field_out("sgs_buoy_flux").get_view<Spack **>();
@@ -346,11 +354,11 @@ void SHOCMacrophysics::initialize_impl(const RunType run_type) {
     Kokkos::deep_copy(cldfrac_liq, 0.0);
   }
 
-  shoc_preprocess.set_variables(m_num_cols, m_num_levs, m_num_tracers, z_surf, T_mid, p_mid, p_int, pseudo_density,
-                                omega, phis, surf_sens_flux, surf_evap, surf_mom_flux, qtracers, qv, qc, qc_copy, tke,
-                                tke_copy, z_mid, z_int, dse, rrho, rrho_i, thv, dz, zt_grid, zi_grid, wpthlp_sfc,
-                                wprtp_sfc, upwp_sfc, vpwp_sfc, wtracer_sfc, wm_zt, inv_exner, thlm, qw, cldfrac_liq,
-                                cldfrac_liq_prev);
+  shoc_preprocess.set_variables(
+      m_num_cols, m_num_levs, m_num_tracers, z_surf, T_mid, p_mid, p_int, pseudo_density, omega,
+      phis, surf_sens_flux, surf_evap, surf_mom_flux, qtracers, qv, qc, qc_copy, tke, tke_copy,
+      z_mid, z_int, dse, rrho, rrho_i, thv, dz, zt_grid, zi_grid, wpthlp_sfc, wprtp_sfc, upwp_sfc,
+      vpwp_sfc, wtracer_sfc, wm_zt, inv_exner, thlm, qw, cldfrac_liq, cldfrac_liq_prev);
 
   // Input Variables:
   input.zt_grid     = shoc_preprocess.zt_grid;
@@ -423,15 +431,17 @@ void SHOCMacrophysics::initialize_impl(const RunType run_type) {
   temporaries.dz_zi   = m_buffer.dz_zi;
 #endif
 
-  shoc_postprocess.set_variables(m_num_cols, m_num_levs, m_num_tracers, rrho, qv, qw, qc, qc_copy, tke, tke_copy,
-                                 qtracers, shoc_ql2, cldfrac_liq, inv_qc_relvar, T_mid, dse, z_mid, phis);
+  shoc_postprocess.set_variables(m_num_cols, m_num_levs, m_num_tracers, rrho, qv, qw, qc, qc_copy,
+                                 tke, tke_copy, qtracers, shoc_ql2, cldfrac_liq, inv_qc_relvar,
+                                 T_mid, dse, z_mid, phis);
 
   if (has_column_conservation_check()) {
     const auto &vapor_flux = get_field_out("vapor_flux").get_view<Real *>();
     const auto &water_flux = get_field_out("water_flux").get_view<Real *>();
     const auto &ice_flux   = get_field_out("ice_flux").get_view<Real *>();
     const auto &heat_flux  = get_field_out("heat_flux").get_view<Real *>();
-    shoc_postprocess.set_mass_and_energy_fluxes(surf_evap, surf_sens_flux, vapor_flux, water_flux, ice_flux, heat_flux);
+    shoc_postprocess.set_mass_and_energy_fluxes(surf_evap, surf_sens_flux, vapor_flux, water_flux,
+                                                ice_flux, heat_flux);
   }
 
   // Set field property checks for the fields in this process
@@ -448,12 +458,14 @@ void SHOCMacrophysics::initialize_impl(const RunType run_type) {
   add_postcondition_check<Interval>(get_field_out("qv"), m_grid, 0, 0.2, true);
 
   // Setup WSM for internal local variables
-  const auto nlev_packs     = ekat::npack<Spack>(m_num_levs);
-  const auto nlevi_packs    = ekat::npack<Spack>(m_num_levs + 1);
-  const int n_wind_slots    = ekat::npack<Spack>(2) * Spack::n;
-  const int n_trac_slots    = ekat::npack<Spack>(m_num_tracers + 3) * Spack::n;
-  const auto default_policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
-  workspace_mgr.setup(m_buffer.wsm_data, nlevi_packs, 14 + (n_wind_slots + n_trac_slots), default_policy);
+  const auto nlev_packs  = ekat::npack<Spack>(m_num_levs);
+  const auto nlevi_packs = ekat::npack<Spack>(m_num_levs + 1);
+  const int n_wind_slots = ekat::npack<Spack>(2) * Spack::n;
+  const int n_trac_slots = ekat::npack<Spack>(m_num_tracers + 3) * Spack::n;
+  const auto default_policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
+  workspace_mgr.setup(m_buffer.wsm_data, nlevi_packs, 14 + (n_wind_slots + n_trac_slots),
+                      default_policy);
 
   // Calculate pref_mid, and use that to calculate
   // maximum number of levels in pbl from surface
@@ -497,13 +509,16 @@ void SHOCMacrophysics::initialize_impl(const RunType run_type) {
 
 // =========================================================================================
 void SHOCMacrophysics::run_impl(const double dt) {
-  EKAT_REQUIRE_MSG(dt <= 300, "Error! SHOC is intended to run with a timestep no longer than 5 minutes.\n"
-                              "       Please, reduce timestep (perhaps increasing subcycling iterations).\n");
+  EKAT_REQUIRE_MSG(dt <= 300,
+                   "Error! SHOC is intended to run with a timestep no longer than 5 minutes.\n"
+                   "       Please, reduce timestep (perhaps increasing subcycling iterations).\n");
 
   const auto nlev_packs = ekat::npack<Spack>(m_num_levs);
   const auto scan_policy =
-      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(m_num_cols, nlev_packs);
-  const auto default_policy = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(m_num_cols,
+                                                                                    nlev_packs);
+  const auto default_policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
 
   // Preprocessing of SHOC inputs. Kernel contains a parallel_scan,
   // so a special TeamPolicy is required.
@@ -528,8 +543,8 @@ void SHOCMacrophysics::run_impl(const double dt) {
   workspace_mgr.reset_internals();
 
   // Run shoc main
-  SHF::shoc_main(m_num_cols, m_num_levs, m_num_levs + 1, m_npbl, m_nadv, m_num_tracers, dt, workspace_mgr,
-                 runtime_options, input, input_output, output, history_output
+  SHF::shoc_main(m_num_cols, m_num_levs, m_num_levs + 1, m_npbl, m_nadv, m_num_tracers, dt,
+                 workspace_mgr, runtime_options, input, input_output, output, history_output
 #ifdef SCREAM_SHOC_SMALL_KERNELS
                  ,
                  temporaries
@@ -595,8 +610,10 @@ void SHOCMacrophysics::apply_turbulent_mountain_stress() {
 
   Kokkos::parallel_for(
       "apply_tms", KT::RangePolicy(0, m_num_cols), KOKKOS_LAMBDA(const int i) {
-        upwp_sfc(i) -= surf_drag_coeff_tms(i) * horiz_winds(i, 0, nlev_v)[nlev_p] / rrho_i(i, nlevi_v)[nlevi_p];
-        vpwp_sfc(i) -= surf_drag_coeff_tms(i) * horiz_winds(i, 1, nlev_v)[nlev_p] / rrho_i(i, nlevi_v)[nlevi_p];
+        upwp_sfc(i) -= surf_drag_coeff_tms(i) * horiz_winds(i, 0, nlev_v)[nlev_p] /
+                       rrho_i(i, nlevi_v)[nlevi_p];
+        vpwp_sfc(i) -= surf_drag_coeff_tms(i) * horiz_winds(i, 1, nlev_v)[nlev_p] /
+                       rrho_i(i, nlevi_v)[nlevi_p];
       });
 }
 // =========================================================================================
@@ -613,7 +630,8 @@ void SHOCMacrophysics::check_flux_state_consistency(const double dt) {
   const auto nlev_packs      = ekat::npack<Spack>(nlevs);
   const auto last_pack_idx   = (nlevs - 1) / Spack::n;
   const auto last_pack_entry = (nlevs - 1) % Spack::n;
-  const auto policy          = ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
+  const auto policy =
+      ekat::ExeSpaceUtils<KT::ExeSpace>::get_default_team_policy(m_num_cols, nlev_packs);
   Kokkos::parallel_for(
       "check_flux_state_consistency", policy, KOKKOS_LAMBDA(const KT::MemberType &team) {
         const auto i = team.league_rank();
@@ -626,15 +644,17 @@ void SHOCMacrophysics::check_flux_state_consistency(const double dt) {
 
         // Check if the negative surface latent heat flux can exhaust
         // the moisture in the lowest model level. If so, apply fixer.
-        const auto condition = surf_evap(i) - (qmin - qv_i(last_pack_idx)[last_pack_entry]) / (dt * gravit * rpdel);
+        const auto condition =
+            surf_evap(i) - (qmin - qv_i(last_pack_idx)[last_pack_entry]) / (dt * gravit * rpdel);
         if (condition < 0) {
           const auto cc = abs(surf_evap(i) * dt * gravit);
 
           auto tracer_mass = [&](const int k) { return qv_i(k) * pseudo_density_i(k); };
-          Real mm          = ekat::ExeSpaceUtils<KT::ExeSpace>::view_reduction(team, 0, nlevs, tracer_mass);
+          Real mm = ekat::ExeSpaceUtils<KT::ExeSpace>::view_reduction(team, 0, nlevs, tracer_mass);
 
-          EKAT_KERNEL_ASSERT_MSG(mm >= cc,
-                                 "Error! Total mass of column vapor should be greater than mass of surf_evap.\n");
+          EKAT_KERNEL_ASSERT_MSG(
+              mm >= cc,
+              "Error! Total mass of column vapor should be greater than mass of surf_evap.\n");
 
           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev_packs), [&](const int &k) {
             const auto adjust = cc * qv_i(k) * pseudo_density_i(k) / mm;
diff --git i/components/eamxx/src/physics/shoc/eamxx_shoc_process_interface.hpp w/components/eamxx/src/physics/shoc/eamxx_shoc_process_interface.hpp
index b63050741d..a3c9fede1b 100644
--- i/components/eamxx/src/physics/shoc/eamxx_shoc_process_interface.hpp
+++ w/components/eamxx/src/physics/shoc/eamxx_shoc_process_interface.hpp
@@ -82,7 +82,8 @@ public:
       Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev_packs), [&](const Int &k) {
         cldfrac_liq_prev(i, k) = cldfrac_liq(i, k);
 
-        // Inverse of Exner. In non-rel builds, assert that exner != 0 when in range before computing.
+        // Inverse of Exner. In non-rel builds, assert that exner != 0 when in range before
+        // computing.
         const Spack exner   = PF::exner_function(p_mid(i, k));
         const Smask nonzero = (exner != 0);
         EKAT_KERNEL_ASSERT((nonzero || !(ekat::range<IntSmallPack>(k * Spack::n) < nlev)).all());
@@ -90,11 +91,11 @@ public:
 
         tke(i, k) = ekat::max(mintke, tke(i, k));
 
-        // Tracers are updated as a group. The tracers tke and qc act as separate inputs to shoc_main()
-        // and are therefore updated differently to the tracers group's monolithic field. Here, we make
-        // a copy if each of these tracers and pass to shoc_main() so that changes to the tracer group
-        // does not alter tke or qc  values. Then during post processing, we copy back correct values of
-        // tke and qc to tracer group in postprocessing.
+        // Tracers are updated as a group. The tracers tke and qc act as separate inputs to
+        // shoc_main() and are therefore updated differently to the tracers group's monolithic
+        // field. Here, we make a copy if each of these tracers and pass to shoc_main() so that
+        // changes to the tracer group does not alter tke or qc  values. Then during post
+        // processing, we copy back correct values of tke and qc to tracer group in postprocessing.
         // TODO: remove *_copy views once SHOC can request a subset of tracers.
         tke_copy(i, k) = tke(i, k);
         qc_copy(i, k)  = qc(i, k);
@@ -148,10 +149,11 @@ public:
       const auto exner_int          = PF::exner_function(p_int(i, nlevi_v)[nlevi_p]);
       const auto inv_exner_int_surf = 1 / exner_int;
 
-      wpthlp_sfc(i) = (surf_sens_flux(i) / (cpair * rrho_i(i, nlevi_v)[nlevi_p])) * inv_exner_int_surf;
-      wprtp_sfc(i)  = surf_evap(i) / rrho_i(i, nlevi_v)[nlevi_p];
-      upwp_sfc(i)   = surf_mom_flux(i, 0) / rrho_i(i, nlevi_v)[nlevi_p];
-      vpwp_sfc(i)   = surf_mom_flux(i, 1) / rrho_i(i, nlevi_v)[nlevi_p];
+      wpthlp_sfc(i) =
+          (surf_sens_flux(i) / (cpair * rrho_i(i, nlevi_v)[nlevi_p])) * inv_exner_int_surf;
+      wprtp_sfc(i) = surf_evap(i) / rrho_i(i, nlevi_v)[nlevi_p];
+      upwp_sfc(i)  = surf_mom_flux(i, 0) / rrho_i(i, nlevi_v)[nlevi_p];
+      vpwp_sfc(i)  = surf_mom_flux(i, 1) / rrho_i(i, nlevi_v)[nlevi_p];
 
       const int num_qtracer_packs = ekat::npack<Spack>(num_qtracers);
       Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_qtracer_packs),
@@ -199,17 +201,20 @@ public:
     view_2d cldfrac_liq_prev;
 
     // Assigning local variables
-    void set_variables(const int ncol_, const int nlev_, const int num_qtracers_, const Real z_surf_,
-                       const view_2d_const &T_mid_, const view_2d_const &p_mid_, const view_2d_const &p_int_,
-                       const view_2d_const &pseudo_density_, const view_2d_const &omega_, const view_1d_const &phis_,
+    void set_variables(const int ncol_, const int nlev_, const int num_qtracers_,
+                       const Real z_surf_, const view_2d_const &T_mid_, const view_2d_const &p_mid_,
+                       const view_2d_const &p_int_, const view_2d_const &pseudo_density_,
+                       const view_2d_const &omega_, const view_1d_const &phis_,
                        const view_1d_const &surf_sens_flux_, const view_1d_const &surf_evap_,
-                       const sview_2d_const &surf_mom_flux_, const view_3d_strided &qtracers_, const view_2d &qv_,
-                       const view_2d_const &qc_, const view_2d &qc_copy_, const view_2d &tke_, const view_2d &tke_copy_,
-                       const view_2d &z_mid_, const view_2d &z_int_, const view_2d &dse_, const view_2d &rrho_,
-                       const view_2d &rrho_i_, const view_2d &thv_, const view_2d &dz_, const view_2d &zt_grid_,
-                       const view_2d &zi_grid_, const view_1d &wpthlp_sfc_, const view_1d &wprtp_sfc_,
-                       const view_1d &upwp_sfc_, const view_1d &vpwp_sfc_, const view_2d &wtracer_sfc_,
-                       const view_2d &wm_zt_, const view_2d &inv_exner_, const view_2d &thlm_, const view_2d &qw_,
+                       const sview_2d_const &surf_mom_flux_, const view_3d_strided &qtracers_,
+                       const view_2d &qv_, const view_2d_const &qc_, const view_2d &qc_copy_,
+                       const view_2d &tke_, const view_2d &tke_copy_, const view_2d &z_mid_,
+                       const view_2d &z_int_, const view_2d &dse_, const view_2d &rrho_,
+                       const view_2d &rrho_i_, const view_2d &thv_, const view_2d &dz_,
+                       const view_2d &zt_grid_, const view_2d &zi_grid_, const view_1d &wpthlp_sfc_,
+                       const view_1d &wprtp_sfc_, const view_1d &upwp_sfc_,
+                       const view_1d &vpwp_sfc_, const view_2d &wtracer_sfc_, const view_2d &wm_zt_,
+                       const view_2d &inv_exner_, const view_2d &thlm_, const view_2d &qw_,
                        const view_2d &cldfrac_liq_, const view_2d &cldfrac_liq_prev_) {
       ncol         = ncol_;
       nlev         = nlev_;
@@ -286,7 +291,8 @@ public:
         if (condition.any()) {
           inv_qc_relvar(i, k).set(
               condition,
-              ekat::min(inv_qc_relvar_max, ekat::max(inv_qc_relvar_min, ekat::square(qc(i, k)) / qc2(i, k))));
+              ekat::min(inv_qc_relvar_max,
+                        ekat::max(inv_qc_relvar_min, ekat::square(qc(i, k)) / qc2(i, k))));
         }
 
         // Temperature
@@ -327,11 +333,13 @@ public:
     view_1d heat_flux;
 
     // Assigning local variables
-    void set_variables(const int ncol_, const int nlev_, const int num_qtracers_, const view_2d_const &rrho_,
-                       const view_2d &qv_, const view_2d_const &qw_, const view_2d &qc_, const view_2d_const &qc_copy_,
-                       const view_2d &tke_, const view_2d_const &tke_copy_, const view_3d_strided &qtracers_,
-                       const view_2d_const &qc2_, const view_2d &cldfrac_liq_, const view_2d &inv_qc_relvar_,
-                       const view_2d &T_mid_, const view_2d_const &dse_, const view_2d_const &z_mid_,
+    void set_variables(const int ncol_, const int nlev_, const int num_qtracers_,
+                       const view_2d_const &rrho_, const view_2d &qv_, const view_2d_const &qw_,
+                       const view_2d &qc_, const view_2d_const &qc_copy_, const view_2d &tke_,
+                       const view_2d_const &tke_copy_, const view_3d_strided &qtracers_,
+                       const view_2d_const &qc2_, const view_2d &cldfrac_liq_,
+                       const view_2d &inv_qc_relvar_, const view_2d &T_mid_,
+                       const view_2d_const &dse_, const view_2d_const &z_mid_,
                        const view_1d_const phis_) {
       ncol          = ncol_;
       nlev          = nlev_;
@@ -353,8 +361,9 @@ public:
       phis          = phis_;
     } // set_variables
 
-    void set_mass_and_energy_fluxes(const view_1d_const &surf_evap_, const view_1d_const surf_sens_flux_,
-                                    const view_1d &vapor_flux_, const view_1d &water_flux_, const view_1d &ice_flux_,
+    void set_mass_and_energy_fluxes(const view_1d_const &surf_evap_,
+                                    const view_1d_const surf_sens_flux_, const view_1d &vapor_flux_,
+                                    const view_1d &water_flux_, const view_1d &ice_flux_,
                                     const view_1d &heat_flux_) {
       compute_mass_and_energy_fluxes = true;
       surf_evap                      = surf_evap_;
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_adv_sgs_tke_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_adv_sgs_tke_impl.hpp
index 050642ded9..5a27429d7f 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_adv_sgs_tke_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_adv_sgs_tke_impl.hpp
@@ -14,7 +14,8 @@ namespace shoc {
 template <typename S, typename D>
 KOKKOS_FUNCTION void
 Functions<S, D>::adv_sgs_tke(const MemberType &team, const Int &nlev, const Real &dtime,
-                             const uview_1d<const Spack> &shoc_mix, const uview_1d<const Spack> &wthv_sec,
+                             const uview_1d<const Spack> &shoc_mix,
+                             const uview_1d<const Spack> &wthv_sec,
                              const uview_1d<const Spack> &sterm_zt, const uview_1d<const Spack> &tk,
                              const uview_1d<Spack> &tke, const uview_1d<Spack> &a_diss) {
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_buoyancy_flux_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_buoyancy_flux_impl.hpp
index cb310516fb..221e83b0e5 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_buoyancy_flux_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_buoyancy_flux_impl.hpp
@@ -15,8 +15,9 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_INLINE_FUNCTION void
-Functions<S, D>::shoc_assumed_pdf_compute_buoyancy_flux(const Spack &wthlsec, const Spack &wqwsec, const Spack &pval,
-                                                        const Spack &wqls, Spack &wthv_sec) {
+Functions<S, D>::shoc_assumed_pdf_compute_buoyancy_flux(const Spack &wthlsec, const Spack &wqwsec,
+                                                        const Spack &pval, const Spack &wqls,
+                                                        Spack &wthv_sec) {
   const Scalar basepres = C::P0;
   const Scalar rair     = C::Rair;
   const Scalar rv       = C::RV;
@@ -25,8 +26,9 @@ Functions<S, D>::shoc_assumed_pdf_compute_buoyancy_flux(const Spack &wthlsec, co
   const Scalar basetemp = C::basetemp;
   const Scalar epsterm  = rair / rv;
 
-  wthv_sec = wthlsec + ((1 - epsterm) / epsterm) * basetemp * wqwsec +
-             ((lcond / cp) * ekat::pow(basepres / pval, (rair / cp)) - (1 / epsterm) * basetemp) * wqls;
+  wthv_sec =
+      wthlsec + ((1 - epsterm) / epsterm) * basetemp * wqwsec +
+      ((lcond / cp) * ekat::pow(basepres / pval, (rair / cp)) - (1 / epsterm) * basetemp) * wqls;
 }
 
 } // namespace shoc
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_cloud_liquid_variance_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_cloud_liquid_variance_impl.hpp
index 3dc016e1db..ad346fa0aa 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_cloud_liquid_variance_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_cloud_liquid_variance_impl.hpp
@@ -15,10 +15,12 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_compute_cloud_liquid_variance(
-    const Spack &a, const Spack &s1, const Spack &ql1, const Spack &C1, const Spack &std_s1, const Spack &s2,
-    const Spack &ql2, const Spack &C2, const Spack &std_s2, const Spack &shoc_ql, Spack &shoc_ql2) {
-  shoc_ql2 = ekat::max(0, a * (s1 * ql1 + C1 * ekat::square(std_s1)) +
-                              (1 - a) * (s2 * ql2 + C2 * ekat::square(std_s2)) - ekat::square(shoc_ql));
+    const Spack &a, const Spack &s1, const Spack &ql1, const Spack &C1, const Spack &std_s1,
+    const Spack &s2, const Spack &ql2, const Spack &C2, const Spack &std_s2, const Spack &shoc_ql,
+    Spack &shoc_ql2) {
+  shoc_ql2 =
+      ekat::max(0, a * (s1 * ql1 + C1 * ekat::square(std_s1)) +
+                       (1 - a) * (s2 * ql2 + C2 * ekat::square(std_s2)) - ekat::square(shoc_ql));
 }
 
 } // namespace shoc
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_liquid_water_flux_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_liquid_water_flux_impl.hpp
index 3b93104440..739c0de046 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_liquid_water_flux_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_liquid_water_flux_impl.hpp
@@ -14,10 +14,9 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_INLINE_FUNCTION void
-Functions<S, D>::shoc_assumed_pdf_compute_liquid_water_flux(const Spack &a, const Spack &w1_1, const Spack &w_first,
-                                                            const Spack &ql1, const Spack &w1_2, const Spack &ql2,
-                                                            Spack &wqls) {
+KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_compute_liquid_water_flux(
+    const Spack &a, const Spack &w1_1, const Spack &w_first, const Spack &ql1, const Spack &w1_2,
+    const Spack &ql2, Spack &wqls) {
   wqls = a * ((w1_1 - w_first) * ql1) + (1 - a) * ((w1_2 - w_first) * ql2);
 }
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_qs_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_qs_impl.hpp
index 707684e6a3..9ccbeb1859 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_qs_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_qs_impl.hpp
@@ -15,21 +15,21 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_compute_qs(const Spack &Tl1_1, const Spack &Tl1_2,
-                                                                         const Spack &pval, const Smask &active_entries,
-                                                                         Spack &qs1, Spack &beta1, Spack &qs2,
-                                                                         Spack &beta2) {
+KOKKOS_INLINE_FUNCTION void
+Functions<S, D>::shoc_assumed_pdf_compute_qs(const Spack &Tl1_1, const Spack &Tl1_2,
+                                             const Spack &pval, const Smask &active_entries,
+                                             Spack &qs1, Spack &beta1, Spack &qs2, Spack &beta2) {
   const Scalar rair  = C::Rair;
   const Scalar rv    = C::RV;
   const Scalar cp    = C::CP;
   const Scalar lcond = C::LatVap;
 
   // Compute MurphyKoop_svp
-  const int liquid = 0;
-  const Spack esval1_1 =
-      scream::physics::Functions<S, D>::MurphyKoop_svp(Tl1_1, liquid, active_entries, "shoc::shoc_assumed_pdf (Tl1_1)");
-  const Spack esval1_2 =
-      scream::physics::Functions<S, D>::MurphyKoop_svp(Tl1_2, liquid, active_entries, "shoc::shoc_assumed_pdf (Tl1_2)");
+  const int liquid     = 0;
+  const Spack esval1_1 = scream::physics::Functions<S, D>::MurphyKoop_svp(
+      Tl1_1, liquid, active_entries, "shoc::shoc_assumed_pdf (Tl1_1)");
+  const Spack esval1_2 = scream::physics::Functions<S, D>::MurphyKoop_svp(
+      Tl1_2, liquid, active_entries, "shoc::shoc_assumed_pdf (Tl1_2)");
   const Spack lstarn(lcond);
 
   qs1   = sp(0.622) * esval1_1 / ekat::max(esval1_1, pval - esval1_1);
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_s_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_s_impl.hpp
index 44d6439da6..d52f3a39a7 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_s_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_s_impl.hpp
@@ -15,8 +15,9 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_compute_s(
-    const Spack &qw1, const Spack &qs, const Spack &beta, const Spack &pval, const Spack &thl2, const Spack &qw2,
-    const Spack &sqrtthl2, const Spack &sqrtqw2, const Spack &r_qwthl, Spack &s, Spack &std_s, Spack &qn, Spack &C) {
+    const Spack &qw1, const Spack &qs, const Spack &beta, const Spack &pval, const Spack &thl2,
+    const Spack &qw2, const Spack &sqrtthl2, const Spack &sqrtqw2, const Spack &r_qwthl, Spack &s,
+    Spack &std_s, Spack &qn, Spack &C) {
   const Scalar rair     = C::Rair;
   const Scalar basepres = C::P0;
   const Scalar cp       = C::CP;
@@ -29,8 +30,8 @@ KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_compute_s(
                      ekat::pow(pval / basepres, (rair / cp));
   const Spack cqt = 1 / (1 + beta * qs);
 
-  std_s                      = ekat::sqrt(ekat::max(0, ekat::square(cthl) * thl2 + ekat::square(cqt) * qw2 -
-                                                           2 * cthl * sqrtthl2 * cqt * sqrtqw2 * r_qwthl));
+  std_s = ekat::sqrt(ekat::max(0, ekat::square(cthl) * thl2 + ekat::square(cqt) * qw2 -
+                                      2 * cthl * sqrtthl2 * cqt * sqrtqw2 * r_qwthl));
   const auto std_s_not_small = std_s > std::sqrt(Kokkos::Experimental::norm_min_v<Real>) * 100;
   s                          = qw1 - qs * ((1 + beta * qw1) / (1 + beta * qs));
   if (std_s_not_small.any()) {
@@ -39,7 +40,8 @@ KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_compute_s(
   C.set(!std_s_not_small && s > 0, 1);
   const auto std_s_C_not_small = std_s_not_small && C != 0;
   if (std_s_C_not_small.any()) {
-    qn.set(std_s_C_not_small, s * C + (std_s / sqrt2pi) * ekat::exp(-sp(0.5) * ekat::square(s / std_s)));
+    qn.set(std_s_C_not_small,
+           s * C + (std_s / sqrt2pi) * ekat::exp(-sp(0.5) * ekat::square(s / std_s)));
   }
   qn.set(!std_s_not_small && s > 0, s);
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_sgs_liquid_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_sgs_liquid_impl.hpp
index 85a5789852..410d4a6d18 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_sgs_liquid_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_sgs_liquid_impl.hpp
@@ -14,8 +14,9 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_compute_sgs_liquid(const Spack &a, const Spack &ql1,
-                                                                                 const Spack &ql2, Spack &shoc_ql) {
+KOKKOS_INLINE_FUNCTION void
+Functions<S, D>::shoc_assumed_pdf_compute_sgs_liquid(const Spack &a, const Spack &ql1,
+                                                     const Spack &ql2, Spack &shoc_ql) {
   shoc_ql = ekat::max(0, a * ql1 + (1 - a) * ql2);
 }
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_temperature_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_temperature_impl.hpp
index dbba30c9db..5319a29527 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_temperature_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_compute_temperature_impl.hpp
@@ -14,7 +14,8 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_compute_temperature(const Spack &thl1, const Spack &pval,
+KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_compute_temperature(const Spack &thl1,
+                                                                                  const Spack &pval,
                                                                                   Spack &Tl1) {
   constexpr Scalar basepres = C::P0;
   constexpr Scalar rair     = C::Rair;
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_impl.hpp
index 532f575454..e4ea3bb6f3 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_impl.hpp
@@ -35,10 +35,12 @@ KOKKOS_INLINE_FUNCTION constexpr Real safe_min() { return std::numeric_limits<Re
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::shoc_assumed_pdf(
     const MemberType &team, const Int &nlev, const Int &nlevi, const uview_1d<const Spack> &thetal,
-    const uview_1d<const Spack> &qw, const uview_1d<const Spack> &w_field, const uview_1d<const Spack> &thl_sec,
-    const uview_1d<const Spack> &qw_sec, const uview_1d<const Spack> &wthl_sec, const uview_1d<const Spack> &w_sec,
-    const uview_1d<const Spack> &wqw_sec, const uview_1d<const Spack> &qwthl_sec, const uview_1d<const Spack> &w3,
-    const uview_1d<const Spack> &pres, const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid,
+    const uview_1d<const Spack> &qw, const uview_1d<const Spack> &w_field,
+    const uview_1d<const Spack> &thl_sec, const uview_1d<const Spack> &qw_sec,
+    const uview_1d<const Spack> &wthl_sec, const uview_1d<const Spack> &w_sec,
+    const uview_1d<const Spack> &wqw_sec, const uview_1d<const Spack> &qwthl_sec,
+    const uview_1d<const Spack> &w3, const uview_1d<const Spack> &pres,
+    const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid,
     const Workspace &workspace, const uview_1d<Spack> &shoc_cldfrac, const uview_1d<Spack> &shoc_ql,
     const uview_1d<Spack> &wqls, const uview_1d<Spack> &wthv_sec, const uview_1d<Spack> &shoc_ql2) {
   // Define temporary variables
@@ -95,17 +97,20 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_assumed_pdf(
 
     // Find parameters for vertical velocity
     Spack Skew_w, w1_1, w1_2, w2_1, w2_2, a;
-    shoc_assumed_pdf_vv_parameters(w_first, w2sec, w3var, w_tol_sqd, Skew_w, w1_1, w1_2, w2_1, w2_2, a);
+    shoc_assumed_pdf_vv_parameters(w_first, w2sec, w3var, w_tol_sqd, Skew_w, w1_1, w1_2, w2_1, w2_2,
+                                   a);
 
     // Find parameters for thetal
     Spack thl1_1, thl1_2, thl2_1, thl2_2, sqrtthl2_1, sqrtthl2_2;
-    shoc_assumed_pdf_thl_parameters(wthlsec, sqrtw2, sqrtthl, thlsec, thl_first, w1_1, w1_2, Skew_w, a, thl_tol,
-                                    w_thresh, thl1_1, thl1_2, thl2_1, thl2_2, sqrtthl2_1, sqrtthl2_2);
+    shoc_assumed_pdf_thl_parameters(wthlsec, sqrtw2, sqrtthl, thlsec, thl_first, w1_1, w1_2, Skew_w,
+                                    a, thl_tol, w_thresh, thl1_1, thl1_2, thl2_1, thl2_2,
+                                    sqrtthl2_1, sqrtthl2_2);
 
     // Find parameters for total water mixing ratio
     Spack qw1_1, qw1_2, qw2_1, qw2_2, sqrtqw2_1, sqrtqw2_2;
-    shoc_assumed_pdf_qw_parameters(wqwsec, sqrtw2, Skew_w, sqrtqt, qwsec, w1_2, w1_1, qw_first, a, rt_tol, w_thresh,
-                                   qw1_1, qw1_2, qw2_1, qw2_2, sqrtqw2_1, sqrtqw2_2);
+    shoc_assumed_pdf_qw_parameters(wqwsec, sqrtw2, Skew_w, sqrtqt, qwsec, w1_2, w1_1, qw_first, a,
+                                   rt_tol, w_thresh, qw1_1, qw1_2, qw2_1, qw2_2, sqrtqw2_1,
+                                   sqrtqw2_2);
 
     // Convert from tilde variables to "real" variables
     shoc_assumed_pdf_tilde_to_real(w_first, sqrtw2, w1_1);
@@ -113,8 +118,9 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_assumed_pdf(
 
     // Find within-plume correlations.
     Spack r_qwthl_1;
-    shoc_assumed_pdf_inplume_correlations(sqrtqw2_1, sqrtthl2_1, a, sqrtqw2_2, sqrtthl2_2, qwthlsec, qw1_1, qw_first,
-                                          thl1_1, thl_first, qw1_2, thl1_2, r_qwthl_1);
+    shoc_assumed_pdf_inplume_correlations(sqrtqw2_1, sqrtthl2_1, a, sqrtqw2_2, sqrtthl2_2, qwthlsec,
+                                          qw1_1, qw_first, thl1_1, thl_first, qw1_2, thl1_2,
+                                          r_qwthl_1);
 
     // Begin to compute cloud property statistics
     Spack Tl1_1, Tl1_2;
@@ -140,10 +146,10 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_assumed_pdf(
                          " %16.9e, %16.9e, %16.9e, %16.9e, %16.9e, %16.9e, %16.9e, %16.9e\n"
                          "  qw1_1, qw1_2, qw2_1, qw2_2:"
                          " %16.9e, %16.9e, %16.9e, %16.9e\n",
-                         index_range[i], Tl1_1[i], Tl1_2[i], thl_first[i], qw_first[i], pval[i], thlsec[i], qwsec[i],
-                         w2sec[i], w_first[i], w3var[i], qwthlsec[i], wqwsec[i], wthlsec[i], a[i], w1_1[i], w1_2[i],
-                         w2_1[i], w2_2[i], thl1_1[i], thl1_2[i], thl2_1[i], thl2_2[i], qw1_1[i], qw1_2[i], qw2_1[i],
-                         qw2_2[i]);
+                         index_range[i], Tl1_1[i], Tl1_2[i], thl_first[i], qw_first[i], pval[i],
+                         thlsec[i], qwsec[i], w2sec[i], w_first[i], w3var[i], qwthlsec[i],
+                         wqwsec[i], wthlsec[i], a[i], w1_1[i], w1_2[i], w2_1[i], w2_2[i], thl1_1[i],
+                         thl1_2[i], thl2_1[i], thl2_2[i], qw1_1[i], qw1_2[i], qw2_1[i], qw2_2[i]);
         }
       }
     }
@@ -159,7 +165,9 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_assumed_pdf(
           n_mask++;
         }
       }
-      Kokkos::printf("WARNING: Tl1_1 has %d values <= allowable value.  Resetting to minimum value.\n", n_mask);
+      Kokkos::printf(
+          "WARNING: Tl1_1 has %d values <= allowable value.  Resetting to minimum value.\n",
+          n_mask);
     }
     if (is_small_Tl1_2.any()) {
       Tl1_2.set(is_small_Tl1_2, Tl_min);
@@ -169,7 +177,9 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_assumed_pdf(
           n_mask++;
         }
       }
-      Kokkos::printf("WARNING: Tl1_2 has %d values <= allowable value.  Resetting to minimum value.\n", n_mask);
+      Kokkos::printf(
+          "WARNING: Tl1_2 has %d values <= allowable value.  Resetting to minimum value.\n",
+          n_mask);
     }
 
     // Compute qs and beta
@@ -182,8 +192,8 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_assumed_pdf(
     Spack s1, std_s1, qn1, C1, ql1, s2, std_s2, qn2, C2, ql2;
 
     // First plume
-    shoc_assumed_pdf_compute_s(qw1_1, qs1, beta1, pval, thl2_1, qw2_1, sqrtthl2_1, sqrtqw2_1, r_qwthl_1, s1, std_s1,
-                               qn1, C1);
+    shoc_assumed_pdf_compute_s(qw1_1, qs1, beta1, pval, thl2_1, qw2_1, sqrtthl2_1, sqrtqw2_1,
+                               r_qwthl_1, s1, std_s1, qn1, C1);
 
     // Second plume
     // Only compute variables of the second plume if the two plumes are not equal
@@ -195,8 +205,8 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_assumed_pdf(
 
     const auto nequal = !equal;
     if (nequal.any()) {
-      shoc_assumed_pdf_compute_s(qw1_2, qs2, beta2, pval, thl2_2, qw2_2, sqrtthl2_2, sqrtqw2_2, r_qwthl_1, s2, std_s2,
-                                 qn2, C2);
+      shoc_assumed_pdf_compute_s(qw1_2, qs2, beta2, pval, thl2_2, qw2_2, sqrtthl2_2, sqrtqw2_2,
+                                 r_qwthl_1, s2, std_s2, qn2, C2);
     }
 
     ql1 = ekat::min(qn1, qw1_1);
@@ -209,8 +219,8 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_assumed_pdf(
     shoc_assumed_pdf_compute_sgs_liquid(a, ql1, ql2, shoc_ql(k));
 
     // Compute cloud liquid variance (CLUBB formulation, adjusted to SHOC parameters based)
-    shoc_assumed_pdf_compute_cloud_liquid_variance(a, s1, ql1, C1, std_s1, s2, ql2, C2, std_s2, shoc_ql(k),
-                                                   shoc_ql2(k));
+    shoc_assumed_pdf_compute_cloud_liquid_variance(a, s1, ql1, C1, std_s1, s2, ql2, C2, std_s2,
+                                                   shoc_ql(k), shoc_ql2(k));
 
     // Compute liquid water flux
     shoc_assumed_pdf_compute_liquid_water_flux(a, w1_1, w_first, ql1, w1_2, ql2, wqls(k));
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_inplume_correlations_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_inplume_correlations_impl.hpp
index 1905fb6914..8a54bd5398 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_inplume_correlations_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_inplume_correlations_impl.hpp
@@ -17,18 +17,20 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_inplume_correlations(
-    const Spack &sqrtqw2_1, const Spack &sqrtthl2_1, const Spack &a, const Spack &sqrtqw2_2, const Spack &sqrtthl2_2,
-    const Spack &qwthlsec, const Spack &qw1_1, const Spack &qw_first, const Spack &thl1_1, const Spack &thl_first,
-    const Spack &qw1_2, const Spack &thl1_2, Spack &r_qwthl_1) {
+    const Spack &sqrtqw2_1, const Spack &sqrtthl2_1, const Spack &a, const Spack &sqrtqw2_2,
+    const Spack &sqrtthl2_2, const Spack &qwthlsec, const Spack &qw1_1, const Spack &qw_first,
+    const Spack &thl1_1, const Spack &thl_first, const Spack &qw1_2, const Spack &thl1_2,
+    Spack &r_qwthl_1) {
   r_qwthl_1 = 0;
 
   const Spack testvar        = a * sqrtqw2_1 * sqrtthl2_1 + (1 - a) * sqrtqw2_2 * sqrtthl2_2;
   const auto testvar_ne_zero = testvar != 0;
   if (testvar_ne_zero.any()) {
-    r_qwthl_1.set(testvar_ne_zero,
-                  ekat::max(-1, ekat::min(1, (qwthlsec - a * (qw1_1 - qw_first) * (thl1_1 - thl_first) -
-                                              (1 - a) * (qw1_2 - qw_first) * (thl1_2 - thl_first)) /
-                                                 testvar)));
+    r_qwthl_1.set(
+        testvar_ne_zero,
+        ekat::max(-1, ekat::min(1, (qwthlsec - a * (qw1_1 - qw_first) * (thl1_1 - thl_first) -
+                                    (1 - a) * (qw1_2 - qw_first) * (thl1_2 - thl_first)) /
+                                       testvar)));
   }
 }
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_qw_parameters_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_qw_parameters_impl.hpp
index 81855638f0..cdce819168 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_qw_parameters_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_qw_parameters_impl.hpp
@@ -17,9 +17,10 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_qw_parameters(
-    const Spack &wqwsec, const Spack &sqrtw2, const Spack &Skew_w, const Spack &sqrtqt, const Spack &qwsec,
-    const Spack &w1_2, const Spack &w1_1, const Spack &qw_first, const Spack &a, const Scalar rt_tol,
-    const Scalar w_thresh, Spack &qw1_1, Spack &qw1_2, Spack &qw2_1, Spack &qw2_2, Spack &sqrtqw2_1, Spack &sqrtqw2_2) {
+    const Spack &wqwsec, const Spack &sqrtw2, const Spack &Skew_w, const Spack &sqrtqt,
+    const Spack &qwsec, const Spack &w1_2, const Spack &w1_1, const Spack &qw_first, const Spack &a,
+    const Scalar rt_tol, const Scalar w_thresh, Spack &qw1_1, Spack &qw1_2, Spack &qw2_1,
+    Spack &qw2_2, Spack &sqrtqw2_1, Spack &sqrtqw2_2) {
   qw1_1     = qw_first;
   qw1_2     = qw_first;
   qw2_1     = 0;
@@ -35,21 +36,24 @@ KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_qw_parameters(
   const auto tsign = ekat::abs(tmp_val_1 - tmp_val_2);
   Spack Skew_qw(0);
   Skew_qw.set(tsign > sp(0.4), sp(1.2) * Skew_w);
-  Skew_qw.set(tsign > sp(0.2) && tsign <= sp(0.4), (((sp(1.2) * Skew_w) / sp(0.2)) * (tsign - sp(0.2))));
+  Skew_qw.set(tsign > sp(0.2) && tsign <= sp(0.4),
+              (((sp(1.2) * Skew_w) / sp(0.2)) * (tsign - sp(0.2))));
 
   if (condition.any()) {
-    qw2_1.set(condition,
-              ekat::min(100, ekat::max(0, (3 * tmp_val_1 *
-                                               (1 - a * ekat::square(tmp_val_2) - (1 - a) * ekat::square(tmp_val_1)) -
-                                           (Skew_qw - a * ekat::cube(tmp_val_2) - (1 - a) * ekat::cube(tmp_val_1))) /
-                                              (3 * a * (tmp_val_1 - tmp_val_2)))) *
-                  qwsec);
-    qw2_2.set(condition,
-              ekat::min(100, ekat::max(0, (-3 * tmp_val_2 *
-                                               (1 - a * ekat::square(tmp_val_2) - (1 - a) * ekat::square(tmp_val_1)) +
-                                           (Skew_qw - a * ekat::cube(tmp_val_2) - (1 - a) * ekat::cube(tmp_val_1))) /
-                                              (3 * (1 - a) * (tmp_val_1 - tmp_val_2)))) *
-                  qwsec);
+    qw2_1.set(condition, ekat::min(100, ekat::max(0, (3 * tmp_val_1 *
+                                                          (1 - a * ekat::square(tmp_val_2) -
+                                                           (1 - a) * ekat::square(tmp_val_1)) -
+                                                      (Skew_qw - a * ekat::cube(tmp_val_2) -
+                                                       (1 - a) * ekat::cube(tmp_val_1))) /
+                                                         (3 * a * (tmp_val_1 - tmp_val_2)))) *
+                             qwsec);
+    qw2_2.set(condition, ekat::min(100, ekat::max(0, (-3 * tmp_val_2 *
+                                                          (1 - a * ekat::square(tmp_val_2) -
+                                                           (1 - a) * ekat::square(tmp_val_1)) +
+                                                      (Skew_qw - a * ekat::cube(tmp_val_2) -
+                                                       (1 - a) * ekat::cube(tmp_val_1))) /
+                                                         (3 * (1 - a) * (tmp_val_1 - tmp_val_2)))) *
+                             qwsec);
   }
 
   qw1_1.set(condition, tmp_val_2 * sqrtqt + qw_first);
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_thl_parameters_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_thl_parameters_impl.hpp
index fdb4532e45..ae64a4f3a3 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_thl_parameters_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_thl_parameters_impl.hpp
@@ -17,10 +17,10 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_thl_parameters(
-    const Spack &wthlsec, const Spack &sqrtw2, const Spack &sqrtthl, const Spack &thlsec, const Spack &thl_first,
-    const Spack &w1_1, const Spack &w1_2, const Spack &Skew_w, const Spack &a, const Scalar thl_tol,
-    const Scalar w_thresh, Spack &thl1_1, Spack &thl1_2, Spack &thl2_1, Spack &thl2_2, Spack &sqrtthl2_1,
-    Spack &sqrtthl2_2) {
+    const Spack &wthlsec, const Spack &sqrtw2, const Spack &sqrtthl, const Spack &thlsec,
+    const Spack &thl_first, const Spack &w1_1, const Spack &w1_2, const Spack &Skew_w,
+    const Spack &a, const Scalar thl_tol, const Scalar w_thresh, Spack &thl1_1, Spack &thl1_2,
+    Spack &thl2_1, Spack &thl2_2, Spack &sqrtthl2_1, Spack &sqrtthl2_2) {
   thl1_1     = thl_first;
   thl1_2     = thl_first;
   thl2_1     = 0;
@@ -37,22 +37,27 @@ KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_thl_parameters(
   if (SC::dothetal_skew == true) {
     const auto tsign = ekat::abs(tmp_val_1 - tmp_val_2);
     Skew_thl.set(tsign > sp(0.4), sp(1.2) * Skew_w);
-    Skew_thl.set(tsign > sp(0.2) && tsign <= sp(0.4), (((sp(1.2) * Skew_w) / sp(0.2)) * (tsign - sp(0.2))));
+    Skew_thl.set(tsign > sp(0.2) && tsign <= sp(0.4),
+                 (((sp(1.2) * Skew_w) / sp(0.2)) * (tsign - sp(0.2))));
   }
 
   if (condition.any()) {
-    thl2_1.set(condition,
-               ekat::min(100, ekat::max(0, (3 * tmp_val_1 *
-                                                (1 - a * ekat::square(tmp_val_2) - (1 - a) * ekat::square(tmp_val_1)) -
-                                            (Skew_thl - a * ekat::cube(tmp_val_2) - (1 - a) * ekat::cube(tmp_val_1))) /
-                                               (3 * a * (tmp_val_1 - tmp_val_2)))) *
-                   thlsec);
-    thl2_2.set(condition,
-               ekat::min(100, ekat::max(0, (-3 * tmp_val_2 *
-                                                (1 - a * ekat::square(tmp_val_2) - (1 - a) * ekat::square(tmp_val_1)) +
-                                            (Skew_thl - a * ekat::cube(tmp_val_2) - (1 - a) * ekat::cube(tmp_val_1))) /
-                                               (3 * (1 - a) * (tmp_val_1 - tmp_val_2)))) *
-                   thlsec);
+    thl2_1.set(condition, ekat::min(100, ekat::max(0, (3 * tmp_val_1 *
+                                                           (1 - a * ekat::square(tmp_val_2) -
+                                                            (1 - a) * ekat::square(tmp_val_1)) -
+                                                       (Skew_thl - a * ekat::cube(tmp_val_2) -
+                                                        (1 - a) * ekat::cube(tmp_val_1))) /
+                                                          (3 * a * (tmp_val_1 - tmp_val_2)))) *
+                              thlsec);
+    thl2_2.set(
+        condition,
+        ekat::min(
+            100, ekat::max(
+                     0, (-3 * tmp_val_2 *
+                             (1 - a * ekat::square(tmp_val_2) - (1 - a) * ekat::square(tmp_val_1)) +
+                         (Skew_thl - a * ekat::cube(tmp_val_2) - (1 - a) * ekat::cube(tmp_val_1))) /
+                            (3 * (1 - a) * (tmp_val_1 - tmp_val_2)))) *
+            thlsec);
 
     thl1_1.set(condition, tmp_val_2 * sqrtthl + thl_first);
     thl1_2.set(condition, tmp_val_1 * sqrtthl + thl_first);
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_tilde_to_real_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_tilde_to_real_impl.hpp
index 3e04b3f3f8..e22935724b 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_tilde_to_real_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_tilde_to_real_impl.hpp
@@ -16,7 +16,8 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_tilde_to_real(const Spack &w_first, const Spack &sqrtw2,
+KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_tilde_to_real(const Spack &w_first,
+                                                                            const Spack &sqrtw2,
                                                                             Spack &w1) {
   w1 *= sqrtw2;
   w1 += w_first;
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_vv_parameters_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_vv_parameters_impl.hpp
index 3f0efe7a96..393ffb310b 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_vv_parameters_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_assumed_pdf_vv_parameters_impl.hpp
@@ -16,10 +16,9 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_vv_parameters(const Spack &w_first, const Spack &w_sec,
-                                                                            const Spack &w3var, const Scalar w_tol_sqd,
-                                                                            Spack &Skew_w, Spack &w1_1, Spack &w1_2,
-                                                                            Spack &w2_1, Spack &w2_2, Spack &a) {
+KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_vv_parameters(
+    const Spack &w_first, const Spack &w_sec, const Spack &w3var, const Scalar w_tol_sqd,
+    Spack &Skew_w, Spack &w1_1, Spack &w1_2, Spack &w2_1, Spack &w2_2, Spack &a) {
   Skew_w = 0;
   w1_1   = w_first;
   w1_2   = w_first;
@@ -34,12 +33,13 @@ KOKKOS_INLINE_FUNCTION void Functions<S, D>::shoc_assumed_pdf_vv_parameters(cons
   const Scalar sqrtw2t(std::sqrt(1 - tmp_val));
 
   Skew_w.set(condition, w3var / ekat::sqrt(ekat::cube(w_sec)));
-  a.set(
-      condition,
-      ekat::max(sp(0.01),
-                ekat::min(sp(0.99),
-                          sp(0.5) * (1 - Skew_w * ekat::sqrt(1 / (4 * (one_m_tmp_val * one_m_tmp_val * one_m_tmp_val) +
-                                                                  ekat::square(Skew_w)))))));
+  a.set(condition,
+        ekat::max(
+            sp(0.01),
+            ekat::min(sp(0.99),
+                      sp(0.5) * (1 - Skew_w * ekat::sqrt(1 / (4 * (one_m_tmp_val * one_m_tmp_val *
+                                                                   one_m_tmp_val) +
+                                                              ekat::square(Skew_w)))))));
 
   w1_1.set(condition, ekat::sqrt((1 - a) / a) * sqrtw2t);
   w1_2.set(condition, -1 * ekat::sqrt(a / (1 - a)) * sqrtw2t);
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_calc_shoc_varorcovar_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_calc_shoc_varorcovar_impl.hpp
index 0b27b66dab..5b11cacf5f 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_calc_shoc_varorcovar_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_calc_shoc_varorcovar_impl.hpp
@@ -7,11 +7,11 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::calc_shoc_varorcovar(const MemberType &team, const Int &nlev, const Scalar &tunefac,
-                                      const uview_1d<const Spack> &isotropy_zi, const uview_1d<const Spack> &tkh_zi,
-                                      const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &invar1,
-                                      const uview_1d<const Spack> &invar2, const uview_1d<Spack> &varorcovar) {
+KOKKOS_FUNCTION void Functions<S, D>::calc_shoc_varorcovar(
+    const MemberType &team, const Int &nlev, const Scalar &tunefac,
+    const uview_1d<const Spack> &isotropy_zi, const uview_1d<const Spack> &tkh_zi,
+    const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &invar1,
+    const uview_1d<const Spack> &invar2, const uview_1d<Spack> &varorcovar) {
   const Int nlev_pack = ekat::npack<Spack>(nlev);
   const auto sinvar1  = scalarize(invar1);
   const auto sinvar2  = scalarize(invar2);
@@ -21,7 +21,8 @@ Functions<S, D>::calc_shoc_varorcovar(const MemberType &team, const Int &nlev, c
     Spack invar1_s, invar1_sm1, invar2_s, invar2_sm1;
     auto range_pack1 = ekat::range<IntSmallPack>(k * Spack::n);
     auto range_pack2 = range_pack1;
-    range_pack2.set(range_pack1 < 1, 1); // don't want the shift to go below zero. we mask out that result anyway
+    range_pack2.set(range_pack1 < 1,
+                    1); // don't want the shift to go below zero. we mask out that result anyway
     ekat::index_and_shift<-1>(sinvar1, range_pack2, invar1_s, invar1_sm1);
     ekat::index_and_shift<-1>(sinvar2, range_pack2, invar2_s, invar2_sm1);
 
@@ -31,8 +32,8 @@ Functions<S, D>::calc_shoc_varorcovar(const MemberType &team, const Int &nlev, c
       const Spack grid_dz2 = ekat::square(grid_dz); // vertical grid diff squared
 
       // Compute the variance or covariance
-      varorcovar(k).set(active_range, tunefac * (isotropy_zi(k) * tkh_zi(k)) * grid_dz2 * (invar1_sm1 - invar1_s) *
-                                          (invar2_sm1 - invar2_s));
+      varorcovar(k).set(active_range, tunefac * (isotropy_zi(k) * tkh_zi(k)) * grid_dz2 *
+                                          (invar1_sm1 - invar1_s) * (invar2_sm1 - invar2_s));
     }
   });
 }
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_calc_shoc_vertflux_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_calc_shoc_vertflux_impl.hpp
index 106e023b76..93252c70a3 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_calc_shoc_vertflux_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_calc_shoc_vertflux_impl.hpp
@@ -7,16 +7,18 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::calc_shoc_vertflux(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &tkh_zi,
-                                    const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &invar,
-                                    const uview_1d<Spack> &vertflux) {
+KOKKOS_FUNCTION void Functions<S, D>::calc_shoc_vertflux(const MemberType &team, const Int &nlev,
+                                                         const uview_1d<const Spack> &tkh_zi,
+                                                         const uview_1d<const Spack> &dz_zi,
+                                                         const uview_1d<const Spack> &invar,
+                                                         const uview_1d<Spack> &vertflux) {
   const Int nlev_pack = ekat::npack<Spack>(nlev);
   const auto sinvar   = scalarize(invar);
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev_pack), [&](const Int &k) {
     auto range_pack1 = ekat::range<IntSmallPack>(k * Spack::n);
     auto range_pack2 = range_pack1;
-    range_pack2.set(range_pack1 < 1, 1); // don't want the shift to go below zero. we mask out that result anyway
+    range_pack2.set(range_pack1 < 1,
+                    1); // don't want the shift to go below zero. we mask out that result anyway
 
     Spack up_grid, grid;
     ekat::index_and_shift<-1>(sinvar, range_pack2, grid, up_grid);
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_check_length_scale_shoc_length_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_check_length_scale_shoc_length_impl.hpp
index e4ce532398..d1ff698a73 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_check_length_scale_shoc_length_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_check_length_scale_shoc_length_impl.hpp
@@ -7,9 +7,10 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::check_length_scale_shoc_length(const MemberType &team, const Int &nlev,
-                                                                     const Scalar &dx, const Scalar &dy,
-                                                                     const uview_1d<Spack> &shoc_mix) {
+KOKKOS_FUNCTION void
+Functions<S, D>::check_length_scale_shoc_length(const MemberType &team, const Int &nlev,
+                                                const Scalar &dx, const Scalar &dy,
+                                                const uview_1d<Spack> &shoc_mix) {
   const auto minlen = scream::shoc::Constants<Real>::minlen;
 
   const Int nlev_pack = ekat::npack<Spack>(nlev);
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_check_tke_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_check_tke_impl.hpp
index eb0a17689b..ec1f93eed9 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_check_tke_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_check_tke_impl.hpp
@@ -7,7 +7,8 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::check_tke(const MemberType &team, const Int &nlev, const uview_1d<Spack> &tke) {
+KOKKOS_FUNCTION void Functions<S, D>::check_tke(const MemberType &team, const Int &nlev,
+                                                const uview_1d<Spack> &tke) {
   // obtain minimum TKE allowed
   static constexpr auto mintke = SC::mintke; // units:m2/s2
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_clipping_diag_third_shoc_moments_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_clipping_diag_third_shoc_moments_impl.hpp
index 565f941f92..ab9e052b53 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_clipping_diag_third_shoc_moments_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_clipping_diag_third_shoc_moments_impl.hpp
@@ -7,9 +7,10 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::clipping_diag_third_shoc_moments(const MemberType &team, const Int &nlevi,
-                                                                       const uview_1d<const Spack> &w_sec_zi,
-                                                                       const uview_1d<Spack> &w3) {
+KOKKOS_FUNCTION void
+Functions<S, D>::clipping_diag_third_shoc_moments(const MemberType &team, const Int &nlevi,
+                                                  const uview_1d<const Spack> &w_sec_zi,
+                                                  const uview_1d<Spack> &w3) {
   const Int nlevi_pack = ekat::npack<Spack>(nlevi);
 
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlevi_pack), [&](const Int &k) {
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_compute_brunt_shoc_length_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_compute_brunt_shoc_length_impl.hpp
index 5fa8b7f539..efd7a6cb5e 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_compute_brunt_shoc_length_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_compute_brunt_shoc_length_impl.hpp
@@ -7,10 +7,12 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::compute_brunt_shoc_length(const MemberType &team, const Int &nlev, const Int &nlevi,
-                                           const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &thv,
-                                           const uview_1d<const Spack> &thv_zi, const uview_1d<Spack> &brunt) {
+KOKKOS_FUNCTION void Functions<S, D>::compute_brunt_shoc_length(const MemberType &team,
+                                                                const Int &nlev, const Int &nlevi,
+                                                                const uview_1d<const Spack> &dz_zt,
+                                                                const uview_1d<const Spack> &thv,
+                                                                const uview_1d<const Spack> &thv_zi,
+                                                                const uview_1d<Spack> &brunt) {
   const auto ggr      = C::gravit;
   const auto s_thv_zi = scalarize(thv_zi);
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_compute_diag_third_shoc_moment_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_compute_diag_third_shoc_moment_impl.hpp
index 52cdafdef0..b7a08d2ba5 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_compute_diag_third_shoc_moment_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_compute_diag_third_shoc_moment_impl.hpp
@@ -9,10 +9,12 @@ namespace shoc {
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::compute_diag_third_shoc_moment(
     const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &c_diag_3rd_mom,
-    const uview_1d<const Spack> &w_sec, const uview_1d<const Spack> &thl_sec, const uview_1d<const Spack> &wthl_sec,
-    const uview_1d<const Spack> &tke, const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &dz_zi,
+    const uview_1d<const Spack> &w_sec, const uview_1d<const Spack> &thl_sec,
+    const uview_1d<const Spack> &wthl_sec, const uview_1d<const Spack> &tke,
+    const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &dz_zi,
     const uview_1d<const Spack> &isotropy_zi, const uview_1d<const Spack> &brunt_zi,
-    const uview_1d<const Spack> &w_sec_zi, const uview_1d<const Spack> &thetal_zi, const uview_1d<Spack> &w3) {
+    const uview_1d<const Spack> &w_sec_zi, const uview_1d<const Spack> &thetal_zi,
+    const uview_1d<Spack> &w3) {
   const auto ggr = C::gravit;
 
   const Int nlev_pack = ekat::npack<Spack>(nlev);
@@ -40,8 +42,8 @@ KOKKOS_FUNCTION void Functions<S, D>::compute_diag_third_shoc_moment(
     const Scalar a5 = sp(0.6) / (c_diag_3rd_mom * (3 + 5 * c_diag_3rd_mom));
 
     // Calculate shifts
-    Spack dz_zt_k, dz_zt_km1, wthl_sec_k, wthl_sec_km1, wthl_sec_kp1, thl_sec_k, thl_sec_km1, thl_sec_kp1, w_sec_k,
-        w_sec_km1, tke_k, tke_km1;
+    Spack dz_zt_k, dz_zt_km1, wthl_sec_k, wthl_sec_km1, wthl_sec_kp1, thl_sec_k, thl_sec_km1,
+        thl_sec_kp1, w_sec_k, w_sec_km1, tke_k, tke_km1;
 
     auto range_pack    = ekat::range<IntSmallPack>(k * Spack::n);
     auto range_pack_m1 = range_pack;
@@ -76,13 +78,14 @@ KOKKOS_FUNCTION void Functions<S, D>::compute_diag_third_shoc_moment(
       const Spack wsec_diff     = w_sec_km1 - w_sec(k);
       const Spack tke_diff      = tke_km1 - tke(k);
 
-      const auto f0 = thedz2 * ekat::cube(bet2) * ((iso * iso) * (iso * iso)) * wthl_sec_k * thl_sec_diff;
+      const auto f0 =
+          thedz2 * ekat::cube(bet2) * ((iso * iso) * (iso * iso)) * wthl_sec_k * thl_sec_diff;
       const auto f1 = thedz2 * ekat::square(bet2) * ekat::cube(iso) *
                       (wthl_sec_k * wthl_sec_diff + sp(0.5) * w_sec_zi(k) * thl_sec_diff);
-      const auto f2 =
-          thedz * bet2 * isosqrd * wthl_sec_k * wsec_diff + 2 * thedz2 * bet2 * isosqrd * w_sec_zi(k) * wthl_sec_diff;
-      const auto f3 =
-          thedz2 * bet2 * isosqrd * w_sec_zi(k) * wthl_sec_diff + thedz * bet2 * isosqrd * (wthl_sec_k * tke_diff);
+      const auto f2 = thedz * bet2 * isosqrd * wthl_sec_k * wsec_diff +
+                      2 * thedz2 * bet2 * isosqrd * w_sec_zi(k) * wthl_sec_diff;
+      const auto f3 = thedz2 * bet2 * isosqrd * w_sec_zi(k) * wthl_sec_diff +
+                      thedz * bet2 * isosqrd * (wthl_sec_k * tke_diff);
       const auto f4 = thedz * iso * w_sec_zi(k) * (wsec_diff + tke_diff);
       const auto f5 = thedz * iso * w_sec_zi(k) * wsec_diff;
 
@@ -92,17 +95,21 @@ KOKKOS_FUNCTION void Functions<S, D>::compute_diag_third_shoc_moment(
       const auto omega2 = omega1 * f3 + sp(5.0 / 4.0) * omega0 * f4;
 
       // Compute the x0, y0, x1, y1 terms
-      const auto x0 = (a2 * buoy_sgs2 * (Spack(1) - a3 * buoy_sgs2)) / (Spack(1) - (a1 + a3) * buoy_sgs2);
+      const auto x0 =
+          (a2 * buoy_sgs2 * (Spack(1) - a3 * buoy_sgs2)) / (Spack(1) - (a1 + a3) * buoy_sgs2);
       const auto y0 = (2 * a2 * buoy_sgs2 * x0) / (Spack(1) - a3 * buoy_sgs2);
-      const auto x1 = (a0 * f0 + a1 * f1 + a2 * (Spack(1) - a3 * buoy_sgs2) * f2) / (Spack(1) - (a1 + a3) * buoy_sgs2);
-      const auto y1 = (2 * a2 * (buoy_sgs2 * x1 + (a0 / a1) * f0 + f1)) / (Spack(1) - a3 * buoy_sgs2);
+      const auto x1 = (a0 * f0 + a1 * f1 + a2 * (Spack(1) - a3 * buoy_sgs2) * f2) /
+                      (Spack(1) - (a1 + a3) * buoy_sgs2);
+      const auto y1 =
+          (2 * a2 * (buoy_sgs2 * x1 + (a0 / a1) * f0 + f1)) / (Spack(1) - a3 * buoy_sgs2);
 
       // Compute the aa0, aa1 terms
       const auto aa0 = omega0 * x0 + omega1 * y0;
       const auto aa1 = omega0 * x1 + omega1 * y1 + omega2;
 
       // Finally, compute the third moment of w
-      w3(k).set(active_range, (aa1 - sp(1.2) * x1 - sp(1.5) * f5) / (Spack(c_diag_3rd_mom) - sp(1.2) * x0 + aa0));
+      w3(k).set(active_range,
+                (aa1 - sp(1.2) * x1 - sp(1.5) * f5) / (Spack(c_diag_3rd_mom) - sp(1.2) * x0 + aa0));
     }
   });
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_compute_l_inf_shoc_length_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_compute_l_inf_shoc_length_impl.hpp
index a66b3a35dc..aa1ab5c5d7 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_compute_l_inf_shoc_length_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_compute_l_inf_shoc_length_impl.hpp
@@ -7,20 +7,20 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::compute_l_inf_shoc_length(const MemberType &team, const Int &nlev,
-                                                                const uview_1d<const Spack> &zt_grid,
-                                                                const uview_1d<const Spack> &dz_zt,
-                                                                const uview_1d<const Spack> &tke, Scalar &l_inf) {
+KOKKOS_FUNCTION void Functions<S, D>::compute_l_inf_shoc_length(
+    const MemberType &team, const Int &nlev, const uview_1d<const Spack> &zt_grid,
+    const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &tke, Scalar &l_inf) {
   using ExeSpaceUtils = ekat::ExeSpaceUtils<typename KT::ExeSpace>;
 
   // Compute numerator
-  Scalar numer = ExeSpaceUtils::view_reduction(
-      team, 0, nlev, [&](const int k) -> Spack { return ekat::sqrt(tke(k)) * zt_grid(k) * dz_zt(k); });
+  Scalar numer = ExeSpaceUtils::view_reduction(team, 0, nlev, [&](const int k) -> Spack {
+    return ekat::sqrt(tke(k)) * zt_grid(k) * dz_zt(k);
+  });
   team.team_barrier(); // see comment in shoc_energy_integrals_impl.hpp
 
   // Compute denominator
-  Scalar denom =
-      ExeSpaceUtils::view_reduction(team, 0, nlev, [&](const int k) -> Spack { return ekat::sqrt(tke(k)) * dz_zt(k); });
+  Scalar denom = ExeSpaceUtils::view_reduction(
+      team, 0, nlev, [&](const int k) -> Spack { return ekat::sqrt(tke(k)) * dz_zt(k); });
   team.team_barrier();
 
   // Set l_inf
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_mix_shoc_length_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_mix_shoc_length_impl.hpp
index 22eb77bd7a..ce23336122 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_mix_shoc_length_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_mix_shoc_length_impl.hpp
@@ -7,11 +7,10 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::compute_shoc_mix_shoc_length(const MemberType &team, const Int &nlev, const Scalar &length_fac,
-                                              const uview_1d<const Spack> &tke, const uview_1d<const Spack> &brunt,
-                                              const uview_1d<const Spack> &zt_grid, const Scalar &l_inf,
-                                              const uview_1d<Spack> &shoc_mix) {
+KOKKOS_FUNCTION void Functions<S, D>::compute_shoc_mix_shoc_length(
+    const MemberType &team, const Int &nlev, const Scalar &length_fac,
+    const uview_1d<const Spack> &tke, const uview_1d<const Spack> &brunt,
+    const uview_1d<const Spack> &zt_grid, const Scalar &l_inf, const uview_1d<Spack> &shoc_mix) {
   const Int nlev_pack = ekat::npack<Spack>(nlev);
   const auto maxlen   = scream::shoc::Constants<Scalar>::maxlen;
   const auto vk       = C::Karman;
@@ -23,11 +22,11 @@ Functions<S, D>::compute_shoc_mix_shoc_length(const MemberType &team, const Int
     const Spack tkes   = ekat::sqrt(tke(k));
     const Spack brunt2 = ekat::max(0, brunt(k));
 
-    shoc_mix(k) =
-        ekat::min(maxlen, sp(2.8284) *
-                              (ekat::sqrt(1 / ((1 / (tscale * tkes * vk * zt_grid(k))) + (1 / (tscale * tkes * l_inf)) +
-                                               sp(0.01) * (brunt2 / tke(k))))) /
-                              length_fac);
+    shoc_mix(k) = ekat::min(maxlen, sp(2.8284) *
+                                        (ekat::sqrt(1 / ((1 / (tscale * tkes * vk * zt_grid(k))) +
+                                                         (1 / (tscale * tkes * l_inf)) +
+                                                         sp(0.01) * (brunt2 / tke(k))))) /
+                                        length_fac);
   });
 }
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_temperature_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_temperature_impl.hpp
index c4bec99003..e4f9850387 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_temperature_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_temperature_impl.hpp
@@ -15,17 +15,18 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::compute_shoc_temperature(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &thetal,
-                                          const uview_1d<const Spack> &ql, const uview_1d<const Spack> &inv_exner,
-                                          const uview_1d<Spack> &tabs) {
+KOKKOS_FUNCTION void Functions<S, D>::compute_shoc_temperature(
+    const MemberType &team, const Int &nlev, const uview_1d<const Spack> &thetal,
+    const uview_1d<const Spack> &ql, const uview_1d<const Spack> &inv_exner,
+    const uview_1d<Spack> &tabs) {
 
   const Scalar cp    = C::CP;
   const Scalar lcond = C::LatVap;
 
   const Int nlev_pack = ekat::npack<Spack>(nlev);
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev_pack),
-                       [&](const Int &k) { tabs(k) = thetal(k) / inv_exner(k) + (lcond / cp) * ql(k); });
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev_pack), [&](const Int &k) {
+    tabs(k) = thetal(k) / inv_exner(k) + (lcond / cp) * ql(k);
+  });
 }
 
 } // namespace shoc
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_vapor_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_vapor_impl.hpp
index 66edb099df..7ed32ff979 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_vapor_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_compute_shoc_vapor_impl.hpp
@@ -18,9 +18,11 @@ namespace shoc {
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::compute_shoc_vapor(const MemberType &team, const Int &nlev,
                                                          const uview_1d<const Spack> &qw,
-                                                         const uview_1d<const Spack> &ql, const uview_1d<Spack> &qv) {
+                                                         const uview_1d<const Spack> &ql,
+                                                         const uview_1d<Spack> &qv) {
   const Int nlev_pack = ekat::npack<Spack>(nlev);
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev_pack), [&](const Int &k) { qv(k) = qw(k) - ql(k); });
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, nlev_pack),
+                       [&](const Int &k) { qv(k) = qw(k) - ql(k); });
 }
 
 } // namespace shoc
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_compute_shr_prod_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_compute_shr_prod_impl.hpp
index 2ad87f1e1e..efbde0a61c 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_compute_shr_prod_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_compute_shr_prod_impl.hpp
@@ -12,10 +12,12 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::compute_shr_prod(const MemberType &team, const Int &nlevi, const Int &nlev,
-                                  const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &u_wind,
-                                  const uview_1d<const Spack> &v_wind, const uview_1d<Spack> &sterm) {
+KOKKOS_FUNCTION void Functions<S, D>::compute_shr_prod(const MemberType &team, const Int &nlevi,
+                                                       const Int &nlev,
+                                                       const uview_1d<const Spack> &dz_zi,
+                                                       const uview_1d<const Spack> &u_wind,
+                                                       const uview_1d<const Spack> &v_wind,
+                                                       const uview_1d<Spack> &sterm) {
   // Turbulent coefficient
   const Scalar Ck_sh = 0.1;
 
@@ -34,7 +36,8 @@ Functions<S, D>::compute_shr_prod(const MemberType &team, const Int &nlevi, cons
 
       // calculate vertical gradient of u&v wind
       auto range_pack2 = range_pack1;
-      range_pack2.set(range_pack1 < 1, 1); // don't want the shift to go below zero. we mask out that result anyway
+      range_pack2.set(range_pack1 < 1,
+                      1); // don't want the shift to go below zero. we mask out that result anyway
       Spack u_up_grid, u_grid, v_up_grid, v_grid;
       ekat::index_and_shift<-1>(sclr_uwind, range_pack2, u_grid, u_up_grid); // for u_wind
       ekat::index_and_shift<-1>(sclr_vwind, range_pack2, v_grid, v_up_grid); // for v_wind
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_compute_tmpi_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_compute_tmpi_impl.hpp
index 06f0820a84..53dda52692 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_compute_tmpi_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_compute_tmpi_impl.hpp
@@ -7,9 +7,10 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::compute_tmpi(const MemberType &team, const Int &nlevi, const Scalar &dtime,
-                                                   const uview_1d<const Spack> &rho_zi,
-                                                   const uview_1d<const Spack> &dz_zi, const uview_1d<Spack> &tmpi) {
+KOKKOS_FUNCTION void
+Functions<S, D>::compute_tmpi(const MemberType &team, const Int &nlevi, const Scalar &dtime,
+                              const uview_1d<const Spack> &rho_zi,
+                              const uview_1d<const Spack> &dz_zi, const uview_1d<Spack> &tmpi) {
   const auto ggr = C::gravit;
 
   tmpi(0)[0] = 0;
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_diag_obklen_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_diag_obklen_impl.hpp
index 9986a95477..d5ddb2738e 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_diag_obklen_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_diag_obklen_impl.hpp
@@ -12,10 +12,12 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::shoc_diag_obklen(const Scalar &uw_sfc, const Scalar &vw_sfc, const Scalar &wthl_sfc,
-                                  const Scalar &wqw_sfc, const Scalar &thl_sfc, const Scalar &cldliq_sfc,
-                                  const Scalar &qv_sfc, Scalar &ustar, Scalar &kbfs, Scalar &obklen) {
+KOKKOS_FUNCTION void Functions<S, D>::shoc_diag_obklen(const Scalar &uw_sfc, const Scalar &vw_sfc,
+                                                       const Scalar &wthl_sfc,
+                                                       const Scalar &wqw_sfc, const Scalar &thl_sfc,
+                                                       const Scalar &cldliq_sfc,
+                                                       const Scalar &qv_sfc, Scalar &ustar,
+                                                       Scalar &kbfs, Scalar &obklen) {
   // Constants
   const auto cp        = C::CP;
   const auto lcond     = C::LatVap;
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_impl.hpp
index dc286ee05a..d13491d887 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_impl.hpp
@@ -13,16 +13,18 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::diag_second_moments(
-    const MemberType &team, const Int &nlev, const Int &nlevi, const Real &thl2tune, const Real &qw2tune,
-    const Real &qwthl2tune, const Real &w2tune, const uview_1d<const Spack> &thetal, const uview_1d<const Spack> &qw,
-    const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind, const uview_1d<const Spack> &tke,
-    const uview_1d<const Spack> &isotropy, const uview_1d<const Spack> &tkh, const uview_1d<const Spack> &tk,
-    const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid,
-    const uview_1d<const Spack> &shoc_mix, const uview_1d<Spack> &isotropy_zi, const uview_1d<Spack> &tkh_zi,
-    const uview_1d<Spack> &tk_zi, const uview_1d<Spack> &thl_sec, const uview_1d<Spack> &qw_sec,
-    const uview_1d<Spack> &wthl_sec, const uview_1d<Spack> &wqw_sec, const uview_1d<Spack> &qwthl_sec,
-    const uview_1d<Spack> &uw_sec, const uview_1d<Spack> &vw_sec, const uview_1d<Spack> &wtke_sec,
-    const uview_1d<Spack> &w_sec) {
+    const MemberType &team, const Int &nlev, const Int &nlevi, const Real &thl2tune,
+    const Real &qw2tune, const Real &qwthl2tune, const Real &w2tune,
+    const uview_1d<const Spack> &thetal, const uview_1d<const Spack> &qw,
+    const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind,
+    const uview_1d<const Spack> &tke, const uview_1d<const Spack> &isotropy,
+    const uview_1d<const Spack> &tkh, const uview_1d<const Spack> &tk,
+    const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &zt_grid,
+    const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &shoc_mix,
+    const uview_1d<Spack> &isotropy_zi, const uview_1d<Spack> &tkh_zi, const uview_1d<Spack> &tk_zi,
+    const uview_1d<Spack> &thl_sec, const uview_1d<Spack> &qw_sec, const uview_1d<Spack> &wthl_sec,
+    const uview_1d<Spack> &wqw_sec, const uview_1d<Spack> &qwthl_sec, const uview_1d<Spack> &uw_sec,
+    const uview_1d<Spack> &vw_sec, const uview_1d<Spack> &wtke_sec, const uview_1d<Spack> &w_sec) {
   // Purpose of this subroutine is to diagnose the second
   //  order moments needed for the SHOC parameterization.
   //  Namely these are variances of thetal, qw, and vertical
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_lbycond_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_lbycond_impl.hpp
index 5256a565c6..cab34f3cdb 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_lbycond_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_lbycond_impl.hpp
@@ -8,9 +8,9 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::shoc_diag_second_moments_lbycond(
-    const Scalar &wthl_sfc, const Scalar &wqw_sfc, const Scalar &uw_sfc, const Scalar &vw_sfc, const Scalar &ustar2,
-    const Scalar &wstar, Scalar &wthl_sec, Scalar &wqw_sec, Scalar &uw_sec, Scalar &vw_sec, Scalar &wtke_sec,
-    Scalar &thl_sec, Scalar &qw_sec, Scalar &qwthl_sec) {
+    const Scalar &wthl_sfc, const Scalar &wqw_sfc, const Scalar &uw_sfc, const Scalar &vw_sfc,
+    const Scalar &ustar2, const Scalar &wstar, Scalar &wthl_sec, Scalar &wqw_sec, Scalar &uw_sec,
+    Scalar &vw_sec, Scalar &wtke_sec, Scalar &thl_sec, Scalar &qw_sec, Scalar &qwthl_sec) {
   // Purpose of this subroutine is to diagnose the lower
   // boundary condition for the second order moments needed
   // for the SHOC parameterization.
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_srf_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_srf_impl.hpp
index c1ee429fe2..d17a8dda7a 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_srf_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_srf_impl.hpp
@@ -9,9 +9,9 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::shoc_diag_second_moments_srf(const Scalar &wthl_sfc, const Scalar &uw_sfc,
-                                                                   const Scalar &vw_sfc, Scalar &ustar2,
-                                                                   Scalar &wstar) {
+KOKKOS_FUNCTION void
+Functions<S, D>::shoc_diag_second_moments_srf(const Scalar &wthl_sfc, const Scalar &uw_sfc,
+                                              const Scalar &vw_sfc, Scalar &ustar2, Scalar &wstar) {
   // Purpose of this subroutine is to diagnose surface
   // properties needed for the the lower
   // boundary condition for the second order moments needed
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_ubycond_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_ubycond_impl.hpp
index cb14c11382..202525aaa4 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_ubycond_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_diag_second_moments_ubycond_impl.hpp
@@ -8,9 +8,9 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::shoc_diag_second_moments_ubycond(Scalar &thl_sec, Scalar &qw_sec, Scalar &wthl_sec, Scalar &wqw_sec,
-                                                  Scalar &qwthl_sec, Scalar &uw_sec, Scalar &vw_sec, Scalar &wtke_sec) {
+KOKKOS_FUNCTION void Functions<S, D>::shoc_diag_second_moments_ubycond(
+    Scalar &thl_sec, Scalar &qw_sec, Scalar &wthl_sec, Scalar &wqw_sec, Scalar &qwthl_sec,
+    Scalar &uw_sec, Scalar &vw_sec, Scalar &wtke_sec) {
   // Purpose of this subroutine is to diagnose the upper
   //  boundary condition for the second order moments
   //  needed for the SHOC parameterization.  Currently
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_diag_second_shoc_moments_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_diag_second_shoc_moments_impl.hpp
index a2cb59e863..bb3e194dcc 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_diag_second_shoc_moments_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_diag_second_shoc_moments_impl.hpp
@@ -13,17 +13,19 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::diag_second_shoc_moments(
-    const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &thl2tune, const Scalar &qw2tune,
-    const Scalar &qwthl2tune, const Scalar &w2tune, const uview_1d<const Spack> &thetal,
-    const uview_1d<const Spack> &qw, const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind,
-    const uview_1d<const Spack> &tke, const uview_1d<const Spack> &isotropy, const uview_1d<const Spack> &tkh,
-    const uview_1d<const Spack> &tk, const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &zt_grid,
-    const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &shoc_mix, const Scalar &wthl_sfc,
-    const Scalar &wqw_sfc, const Scalar &uw_sfc, const Scalar &vw_sfc, Scalar &ustar2, Scalar &wstar,
-    const Workspace &workspace, const uview_1d<Spack> &thl_sec, const uview_1d<Spack> &qw_sec,
-    const uview_1d<Spack> &wthl_sec, const uview_1d<Spack> &wqw_sec, const uview_1d<Spack> &qwthl_sec,
-    const uview_1d<Spack> &uw_sec, const uview_1d<Spack> &vw_sec, const uview_1d<Spack> &wtke_sec,
-    const uview_1d<Spack> &w_sec) {
+    const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &thl2tune,
+    const Scalar &qw2tune, const Scalar &qwthl2tune, const Scalar &w2tune,
+    const uview_1d<const Spack> &thetal, const uview_1d<const Spack> &qw,
+    const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind,
+    const uview_1d<const Spack> &tke, const uview_1d<const Spack> &isotropy,
+    const uview_1d<const Spack> &tkh, const uview_1d<const Spack> &tk,
+    const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &zt_grid,
+    const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &shoc_mix,
+    const Scalar &wthl_sfc, const Scalar &wqw_sfc, const Scalar &uw_sfc, const Scalar &vw_sfc,
+    Scalar &ustar2, Scalar &wstar, const Workspace &workspace, const uview_1d<Spack> &thl_sec,
+    const uview_1d<Spack> &qw_sec, const uview_1d<Spack> &wthl_sec, const uview_1d<Spack> &wqw_sec,
+    const uview_1d<Spack> &qwthl_sec, const uview_1d<Spack> &uw_sec, const uview_1d<Spack> &vw_sec,
+    const uview_1d<Spack> &wtke_sec, const uview_1d<Spack> &w_sec) {
   // This is the main routine to compute the second
   // order moments in SHOC.
 
@@ -48,22 +50,23 @@ KOKKOS_FUNCTION void Functions<S, D>::diag_second_shoc_moments(
   const auto s_qwthl_sec = ekat::scalarize(qwthl_sec);
 
   // Diagnose the second order moments flux, for the lower boundary
-  shoc_diag_second_moments_lbycond(wthl_sfc, wqw_sfc, uw_sfc, vw_sfc, ustar2, wstar, s_wthl_sec(nlevi - 1),
-                                   s_wqw_sec(nlevi - 1), s_uw_sec(nlevi - 1), s_vw_sec(nlevi - 1),
-                                   s_wtke_sec(nlevi - 1), s_thl_sec(nlevi - 1), s_qw_sec(nlevi - 1),
-                                   s_qwthl_sec(nlevi - 1));
+  shoc_diag_second_moments_lbycond(wthl_sfc, wqw_sfc, uw_sfc, vw_sfc, ustar2, wstar,
+                                   s_wthl_sec(nlevi - 1), s_wqw_sec(nlevi - 1), s_uw_sec(nlevi - 1),
+                                   s_vw_sec(nlevi - 1), s_wtke_sec(nlevi - 1), s_thl_sec(nlevi - 1),
+                                   s_qw_sec(nlevi - 1), s_qwthl_sec(nlevi - 1));
   team.team_barrier();
 
   // Diagnose the second order moments, for points away from boundaries.  this is
   //  the main computation for the second moments
-  diag_second_moments(team, nlev, nlevi, thl2tune, qw2tune, qwthl2tune, w2tune, thetal, qw, u_wind, v_wind, tke,
-                      isotropy, tkh, tk, dz_zi, zt_grid, zi_grid, shoc_mix, isotropy_zi, tkh_zi, tk_zi, thl_sec, qw_sec,
-                      wthl_sec, wqw_sec, qwthl_sec, uw_sec, vw_sec, wtke_sec, w_sec);
+  diag_second_moments(team, nlev, nlevi, thl2tune, qw2tune, qwthl2tune, w2tune, thetal, qw, u_wind,
+                      v_wind, tke, isotropy, tkh, tk, dz_zi, zt_grid, zi_grid, shoc_mix,
+                      isotropy_zi, tkh_zi, tk_zi, thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec,
+                      uw_sec, vw_sec, wtke_sec, w_sec);
   team.team_barrier();
 
   // Diagnose the second order moments, calculate the upper boundary conditions
-  shoc_diag_second_moments_ubycond(s_thl_sec(0), s_qw_sec(0), s_wthl_sec(0), s_wqw_sec(0), s_qwthl_sec(0), s_uw_sec(0),
-                                   s_vw_sec(0), s_wtke_sec(0));
+  shoc_diag_second_moments_ubycond(s_thl_sec(0), s_qw_sec(0), s_wthl_sec(0), s_wqw_sec(0),
+                                   s_qwthl_sec(0), s_uw_sec(0), s_vw_sec(0), s_wtke_sec(0));
 
   // Release temporary variables from the workspace
   workspace.template release_many_contiguous<3>({&isotropy_zi, &tkh_zi, &tk_zi});
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_diag_third_shoc_moments_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_diag_third_shoc_moments_impl.hpp
index 0e3b9f25ff..448ea02f69 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_diag_third_shoc_moments_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_diag_third_shoc_moments_impl.hpp
@@ -14,15 +14,17 @@ namespace shoc {
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::diag_third_shoc_moments(
     const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &c_diag_3rd_mom,
-    const uview_1d<const Spack> &w_sec, const uview_1d<const Spack> &thl_sec, const uview_1d<const Spack> &wthl_sec,
-    const uview_1d<const Spack> &isotropy, const uview_1d<const Spack> &brunt, const uview_1d<const Spack> &thetal,
-    const uview_1d<const Spack> &tke, const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &dz_zi,
-    const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid, const Workspace &workspace,
-    const uview_1d<Spack> &w3) {
+    const uview_1d<const Spack> &w_sec, const uview_1d<const Spack> &thl_sec,
+    const uview_1d<const Spack> &wthl_sec, const uview_1d<const Spack> &isotropy,
+    const uview_1d<const Spack> &brunt, const uview_1d<const Spack> &thetal,
+    const uview_1d<const Spack> &tke, const uview_1d<const Spack> &dz_zt,
+    const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &zt_grid,
+    const uview_1d<const Spack> &zi_grid, const Workspace &workspace, const uview_1d<Spack> &w3) {
   // Define temporary variables
   uview_1d<Spack> isotropy_zi, w_sec_zi, brunt_zi, thetal_zi;
-  workspace.template take_many_contiguous_unsafe<4>({"isotropy_zi", "w_sec_zi", "brunt_zi", "thetal_zi"},
-                                                    {&isotropy_zi, &w_sec_zi, &brunt_zi, &thetal_zi});
+  workspace.template take_many_contiguous_unsafe<4>(
+      {"isotropy_zi", "w_sec_zi", "brunt_zi", "thetal_zi"},
+      {&isotropy_zi, &w_sec_zi, &brunt_zi, &thetal_zi});
 
   // Constants
   const auto largeneg = SC::largeneg;
@@ -36,8 +38,8 @@ KOKKOS_FUNCTION void Functions<S, D>::diag_third_shoc_moments(
   team.team_barrier();
 
   // Diagnose the third moment of the vertical-velocity
-  compute_diag_third_shoc_moment(team, nlev, nlevi, c_diag_3rd_mom, w_sec, thl_sec, wthl_sec, tke, dz_zt, dz_zi,
-                                 isotropy_zi, brunt_zi, w_sec_zi, thetal_zi, w3);
+  compute_diag_third_shoc_moment(team, nlev, nlevi, c_diag_3rd_mom, w_sec, thl_sec, wthl_sec, tke,
+                                 dz_zt, dz_zi, isotropy_zi, brunt_zi, w_sec_zi, thetal_zi, w3);
   team.team_barrier();
 
   // Perform clipping to prevent unrealistically large values from occuring
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_dp_inverse_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_dp_inverse_impl.hpp
index 84120a535b..8afbe923b0 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_dp_inverse_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_dp_inverse_impl.hpp
@@ -9,7 +9,8 @@ namespace shoc {
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::dp_inverse(const MemberType &team, const Int &nlev,
                                                  const uview_1d<const Spack> &rho_zt,
-                                                 const uview_1d<const Spack> &dz_zt, const uview_1d<Spack> &rdp_zt) {
+                                                 const uview_1d<const Spack> &dz_zt,
+                                                 const uview_1d<Spack> &rdp_zt) {
   const auto ggr = C::gravit;
 
   const Int nlev_pack = ekat::npack<Spack>(nlev);
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_eddy_diffusivities_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_eddy_diffusivities_impl.hpp
index 8865283195..82b8155b5f 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_eddy_diffusivities_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_eddy_diffusivities_impl.hpp
@@ -13,9 +13,10 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::eddy_diffusivities(
-    const MemberType &team, const Int &nlev, const Scalar &Ckh, const Scalar &Ckm, const Scalar &pblh,
-    const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &tabs, const uview_1d<const Spack> &shoc_mix,
-    const uview_1d<const Spack> &sterm_zt, const uview_1d<const Spack> &isotropy, const uview_1d<const Spack> &tke,
+    const MemberType &team, const Int &nlev, const Scalar &Ckh, const Scalar &Ckm,
+    const Scalar &pblh, const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &tabs,
+    const uview_1d<const Spack> &shoc_mix, const uview_1d<const Spack> &sterm_zt,
+    const uview_1d<const Spack> &isotropy, const uview_1d<const Spack> &tke,
     const uview_1d<Spack> &tkh, const uview_1d<Spack> &tk) {
   // Parameters
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_energy_fixer_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_energy_fixer_impl.hpp
index 1261776811..44ac9fb55e 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_energy_fixer_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_energy_fixer_impl.hpp
@@ -18,10 +18,11 @@ namespace shoc {
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::shoc_energy_fixer(
     const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &dtime, const Int &nadv,
-    const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid, const Scalar &se_b, const Scalar &ke_b,
-    const Scalar &wv_b, const Scalar &wl_b, const Scalar &se_a, const Scalar &ke_a, const Scalar &wv_a,
-    const Scalar &wl_a, const Scalar &wthl_sfc, const Scalar &wqw_sfc, const uview_1d<const Spack> &rho_zt,
-    const uview_1d<const Spack> &tke, const uview_1d<const Spack> &pint, const Workspace &workspace,
+    const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid, const Scalar &se_b,
+    const Scalar &ke_b, const Scalar &wv_b, const Scalar &wl_b, const Scalar &se_a,
+    const Scalar &ke_a, const Scalar &wv_a, const Scalar &wl_a, const Scalar &wthl_sfc,
+    const Scalar &wqw_sfc, const uview_1d<const Spack> &rho_zt, const uview_1d<const Spack> &tke,
+    const uview_1d<const Spack> &pint, const Workspace &workspace,
     const uview_1d<Spack> &host_dse) {
   // Define temporary variables
   auto rho_zi = workspace.take("rho_zi");
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_energy_integrals_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_energy_integrals_impl.hpp
index a24bf7f219..df1d9f83b0 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_energy_integrals_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_energy_integrals_impl.hpp
@@ -8,9 +8,11 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::shoc_energy_integrals(
-    const MemberType &team, const Int &nlev, const uview_1d<const Spack> &host_dse, const uview_1d<const Spack> &pdel,
-    const uview_1d<const Spack> &rtm, const uview_1d<const Spack> &rcm, const uview_1d<const Spack> &u_wind,
-    const uview_1d<const Spack> &v_wind, Scalar &se_int, Scalar &ke_int, Scalar &wv_int, Scalar &wl_int) {
+    const MemberType &team, const Int &nlev, const uview_1d<const Spack> &host_dse,
+    const uview_1d<const Spack> &pdel, const uview_1d<const Spack> &rtm,
+    const uview_1d<const Spack> &rcm, const uview_1d<const Spack> &u_wind,
+    const uview_1d<const Spack> &v_wind, Scalar &se_int, Scalar &ke_int, Scalar &wv_int,
+    Scalar &wl_int) {
   using ExeSpaceUtils = ekat::ExeSpaceUtils<typename KT::ExeSpace>;
   const auto ggr      = C::gravit;
 
@@ -27,8 +29,8 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_energy_integrals(
   // Kokkos::parallel_reduce calls acting on doubles and saw the same results.
 
   // Compute se_int
-  se_int =
-      ExeSpaceUtils::view_reduction(team, 0, nlev, [&](const int k) -> Spack { return host_dse(k) * pdel(k) / ggr; });
+  se_int = ExeSpaceUtils::view_reduction(
+      team, 0, nlev, [&](const int k) -> Spack { return host_dse(k) * pdel(k) / ggr; });
   team.team_barrier();
 
   // Compute ke_int
@@ -38,12 +40,13 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_energy_integrals(
   team.team_barrier();
 
   // Compute wv_int
-  wv_int = ExeSpaceUtils::view_reduction(team, 0, nlev,
-                                         [&](const int k) -> Spack { return (rtm(k) - rcm(k)) * pdel(k) / ggr; });
+  wv_int = ExeSpaceUtils::view_reduction(
+      team, 0, nlev, [&](const int k) -> Spack { return (rtm(k) - rcm(k)) * pdel(k) / ggr; });
   team.team_barrier();
 
   // Compute wl_int
-  wl_int = ExeSpaceUtils::view_reduction(team, 0, nlev, [&](const int k) -> Spack { return rcm(k) * pdel(k) / ggr; });
+  wl_int = ExeSpaceUtils::view_reduction(
+      team, 0, nlev, [&](const int k) -> Spack { return rcm(k) * pdel(k) / ggr; });
   team.team_barrier();
 }
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_grid_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_grid_impl.hpp
index bf94919c3e..2f7b4fadfa 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_grid_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_grid_impl.hpp
@@ -18,11 +18,10 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::shoc_grid(const MemberType &team, const Int &nlev, const Int &nlevi,
-                                                const uview_1d<const Spack> &zt_grid,
-                                                const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &pdel,
-                                                const uview_1d<Spack> &dz_zt, const uview_1d<Spack> &dz_zi,
-                                                const uview_1d<Spack> &rho_zt) {
+KOKKOS_FUNCTION void Functions<S, D>::shoc_grid(
+    const MemberType &team, const Int &nlev, const Int &nlevi, const uview_1d<const Spack> &zt_grid,
+    const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &pdel,
+    const uview_1d<Spack> &dz_zt, const uview_1d<Spack> &dz_zi, const uview_1d<Spack> &rho_zt) {
   const auto ggr = C::gravit;
 
   const auto s_zi_grid = ekat::scalarize(zi_grid);
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_integ_column_stability_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_integ_column_stability_impl.hpp
index 5fe0f5cf59..0e39763a3c 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_integ_column_stability_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_integ_column_stability_impl.hpp
@@ -7,10 +7,9 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::integ_column_stability(const MemberType &team, const Int &nlev,
-                                                             const uview_1d<const Spack> &dz_zt,
-                                                             const uview_1d<const Spack> &pres,
-                                                             const uview_1d<const Spack> &brunt, Scalar &brunt_int) {
+KOKKOS_FUNCTION void Functions<S, D>::integ_column_stability(
+    const MemberType &team, const Int &nlev, const uview_1d<const Spack> &dz_zt,
+    const uview_1d<const Spack> &pres, const uview_1d<const Spack> &brunt, Scalar &brunt_int) {
   // Lower troposphere pressure [Pa]
   static constexpr Scalar troppres = 80000;
 
@@ -20,7 +19,7 @@ KOKKOS_FUNCTION void Functions<S, D>::integ_column_stability(const MemberType &t
     // calculate only when pressure is > troposphere pressure
     auto press_gt_troppress = (pres(k) > troppres);
 
-    Spack return_val(0);                                     // initialize return value for brunt_int
+    Spack return_val(0); // initialize return value for brunt_int
     return_val.set(press_gt_troppress, dz_zt(k) * brunt(k)); // compute brunt_int for each column
 
     return return_val;
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_isotropic_ts_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_isotropic_ts_impl.hpp
index 999c553d9a..24d131a615 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_isotropic_ts_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_isotropic_ts_impl.hpp
@@ -15,9 +15,9 @@ template <typename S, typename D>
 KOKKOS_FUNCTION void
 Functions<S, D>::isotropic_ts(const MemberType &team, const Int &nlev, const Scalar &lambda_low_in,
                               const Scalar &lambda_high_in, const Scalar &lambda_slope_in,
-                              const Scalar &lambda_thresh_in, const Scalar &brunt_int, const uview_1d<const Spack> &tke,
-                              const uview_1d<const Spack> &a_diss, const uview_1d<const Spack> &brunt,
-                              const uview_1d<Spack> &isotropy) {
+                              const Scalar &lambda_thresh_in, const Scalar &brunt_int,
+                              const uview_1d<const Spack> &tke, const uview_1d<const Spack> &a_diss,
+                              const uview_1d<const Spack> &brunt, const uview_1d<Spack> &isotropy) {
 
   // constants from physics/share
   static constexpr Scalar ggr = C::gravit;
@@ -43,7 +43,8 @@ Functions<S, D>::isotropic_ts(const MemberType &team, const Int &nlev, const Sca
     lambda.set(buoy_sgs_save <= 0, 0); // set lambda to zero where buoy_sgs_save <=0
 
     // Compute the return to isotropic timescale
-    isotropy(k) = ekat::min(Spack(maxiso), tscale / (1 + lambda * buoy_sgs_save * ekat::square(tscale)));
+    isotropy(k) =
+        ekat::min(Spack(maxiso), tscale / (1 + lambda * buoy_sgs_save * ekat::square(tscale)));
   });
 }
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_length_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_length_impl.hpp
index 0e25cac319..faf49f3c14 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_length_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_length_impl.hpp
@@ -7,13 +7,12 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::shoc_length(const MemberType &team, const Int &nlev, const Int &nlevi,
-                                                  const Scalar &length_fac, const Scalar &dx, const Scalar &dy,
-                                                  const uview_1d<const Spack> &zt_grid,
-                                                  const uview_1d<const Spack> &zi_grid,
-                                                  const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &tke,
-                                                  const uview_1d<const Spack> &thv, const Workspace &workspace,
-                                                  const uview_1d<Spack> &brunt, const uview_1d<Spack> &shoc_mix) {
+KOKKOS_FUNCTION void Functions<S, D>::shoc_length(
+    const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &length_fac,
+    const Scalar &dx, const Scalar &dy, const uview_1d<const Spack> &zt_grid,
+    const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &dz_zt,
+    const uview_1d<const Spack> &tke, const uview_1d<const Spack> &thv, const Workspace &workspace,
+    const uview_1d<Spack> &brunt, const uview_1d<Spack> &shoc_mix) {
   // Define temporary variable
   auto thv_zi = workspace.take("thv_zi");
 
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_linear_interp_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_linear_interp_impl.hpp
index cfa737fad3..12c9ef844a 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_linear_interp_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_linear_interp_impl.hpp
@@ -12,10 +12,11 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::linear_interp(const MemberType &team, const uview_1d<const Spack> &x1,
-                                                    const uview_1d<const Spack> &x2, const uview_1d<const Spack> &y1,
-                                                    const uview_1d<Spack> &y2, const Int &km1, const Int &km2,
-                                                    const Scalar &minthresh) {
+KOKKOS_FUNCTION void
+Functions<S, D>::linear_interp(const MemberType &team, const uview_1d<const Spack> &x1,
+                               const uview_1d<const Spack> &x2, const uview_1d<const Spack> &y1,
+                               const uview_1d<Spack> &y2, const Int &km1, const Int &km2,
+                               const Scalar &minthresh) {
   const auto sx1     = scalarize(x1);
   const auto sy1     = scalarize(y1);
   const Int km2_pack = ekat::npack<Spack>(km2);
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_main_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_main_impl.hpp
index 99b3e85738..12a118681d 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_main_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_main_impl.hpp
@@ -16,7 +16,8 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-Int Functions<S, D>::shoc_init(const Int &nbot_shoc, const Int &ntop_shoc, const view_1d<const Spack> &pref_mid) {
+Int Functions<S, D>::shoc_init(const Int &nbot_shoc, const Int &ntop_shoc,
+                               const view_1d<const Spack> &pref_mid) {
   // This function calculates the maximum number of levels
   // in pbl from surface
 
@@ -69,30 +70,35 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_main_internal(
     const Int &num_qtracers, // Number of tracers
     const Scalar &dtime,     // SHOC timestep [s]
     // Runtime Parameters
-    const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope, const Scalar &lambda_thresh,
-    const Scalar &thl2tune, const Scalar &qw2tune, const Scalar &qwthl2tune, const Scalar &w2tune,
-    const Scalar &length_fac, const Scalar &c_diag_3rd_mom, const Scalar &Ckh, const Scalar &Ckm,
+    const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope,
+    const Scalar &lambda_thresh, const Scalar &thl2tune, const Scalar &qw2tune,
+    const Scalar &qwthl2tune, const Scalar &w2tune, const Scalar &length_fac,
+    const Scalar &c_diag_3rd_mom, const Scalar &Ckh, const Scalar &Ckm,
     // Input Variables
-    const Scalar &dx, const Scalar &dy, const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid,
-    const uview_1d<const Spack> &pres, const uview_1d<const Spack> &presi, const uview_1d<const Spack> &pdel,
+    const Scalar &dx, const Scalar &dy, const uview_1d<const Spack> &zt_grid,
+    const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &pres,
+    const uview_1d<const Spack> &presi, const uview_1d<const Spack> &pdel,
     const uview_1d<const Spack> &thv, const uview_1d<const Spack> &w_field, const Scalar &wthl_sfc,
-    const Scalar &wqw_sfc, const Scalar &uw_sfc, const Scalar &vw_sfc, const uview_1d<const Spack> &wtracer_sfc,
-    const uview_1d<const Spack> &inv_exner, const Scalar &phis,
+    const Scalar &wqw_sfc, const Scalar &uw_sfc, const Scalar &vw_sfc,
+    const uview_1d<const Spack> &wtracer_sfc, const uview_1d<const Spack> &inv_exner,
+    const Scalar &phis,
     // Workspace/Local Variables
     const Workspace &workspace,
     // Input/Output Variables
     const uview_1d<Spack> &host_dse, const uview_1d<Spack> &tke, const uview_1d<Spack> &thetal,
     const uview_1d<Spack> &qw, const uview_1d<Spack> &u_wind, const uview_1d<Spack> &v_wind,
-    const uview_1d<Spack> &wthv_sec, const uview_2d_strided<Spack> &qtracers, const uview_1d<Spack> &tk,
-    const uview_1d<Spack> &shoc_cldfrac, const uview_1d<Spack> &shoc_ql,
+    const uview_1d<Spack> &wthv_sec, const uview_2d_strided<Spack> &qtracers,
+    const uview_1d<Spack> &tk, const uview_1d<Spack> &shoc_cldfrac, const uview_1d<Spack> &shoc_ql,
     // Output Variables
-    Scalar &pblh, Scalar &ustar, Scalar &obklen, const uview_1d<Spack> &shoc_ql2, const uview_1d<Spack> &tkh,
+    Scalar &pblh, Scalar &ustar, Scalar &obklen, const uview_1d<Spack> &shoc_ql2,
+    const uview_1d<Spack> &tkh,
     // Diagnostic Output Variables
     const uview_1d<Spack> &shoc_mix, const uview_1d<Spack> &w_sec, const uview_1d<Spack> &thl_sec,
-    const uview_1d<Spack> &qw_sec, const uview_1d<Spack> &qwthl_sec, const uview_1d<Spack> &wthl_sec,
-    const uview_1d<Spack> &wqw_sec, const uview_1d<Spack> &wtke_sec, const uview_1d<Spack> &uw_sec,
-    const uview_1d<Spack> &vw_sec, const uview_1d<Spack> &w3, const uview_1d<Spack> &wqls_sec,
-    const uview_1d<Spack> &brunt, const uview_1d<Spack> &isotropy) {
+    const uview_1d<Spack> &qw_sec, const uview_1d<Spack> &qwthl_sec,
+    const uview_1d<Spack> &wthl_sec, const uview_1d<Spack> &wqw_sec,
+    const uview_1d<Spack> &wtke_sec, const uview_1d<Spack> &uw_sec, const uview_1d<Spack> &vw_sec,
+    const uview_1d<Spack> &w3, const uview_1d<Spack> &wqls_sec, const uview_1d<Spack> &brunt,
+    const uview_1d<Spack> &isotropy) {
 
   // Define temporary variables
   uview_1d<Spack> rho_zt, shoc_qv, shoc_tabs, dz_zt, dz_zi;
@@ -100,7 +106,8 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_main_internal(
                                             {&rho_zt, &shoc_qv, &shoc_tabs, &dz_zt, &dz_zi});
 
   // Local scalars
-  Scalar se_b{0}, ke_b{0}, wv_b{0}, wl_b{0}, se_a{0}, ke_a{0}, wv_a{0}, wl_a{0}, kbfs{0}, ustar2{0}, wstar{0};
+  Scalar se_b{0}, ke_b{0}, wv_b{0}, wl_b{0}, se_a{0}, ke_a{0}, wv_a{0}, wl_a{0}, kbfs{0}, ustar2{0},
+      wstar{0};
 
   // Scalarize some views for single entry access
   const auto s_thetal  = ekat::scalarize(thetal);
@@ -187,14 +194,15 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_main_internal(
                                 thetal, qw, qtracers, tke, u_wind, v_wind);       // Input/Output
 
     // Diagnose the second order moments
-    diag_second_shoc_moments(team, nlev, nlevi, thl2tune, qw2tune, qwthl2tune, w2tune, // Runtime options
-                             thetal, qw, u_wind, v_wind,                               // Input
-                             tke, isotropy, tkh, tk, dz_zi, zt_grid, zi_grid,          // Input
-                             shoc_mix, wthl_sfc, wqw_sfc, uw_sfc, vw_sfc,              // Input
-                             ustar2, wstar,                                            // Input/Output
-                             workspace,                                                // Workspace
-                             thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec,            // Output
-                             uw_sec, vw_sec, wtke_sec, w_sec);                         // Output
+    diag_second_shoc_moments(team, nlev, nlevi, thl2tune, qw2tune, qwthl2tune,
+                             w2tune,                                          // Runtime options
+                             thetal, qw, u_wind, v_wind,                      // Input
+                             tke, isotropy, tkh, tk, dz_zi, zt_grid, zi_grid, // Input
+                             shoc_mix, wthl_sfc, wqw_sfc, uw_sfc, vw_sfc,     // Input
+                             ustar2, wstar,                                   // Input/Output
+                             workspace,                                       // Workspace
+                             thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec,   // Output
+                             uw_sec, vw_sec, wtke_sec, w_sec);                // Output
 
     // Diagnose the third moment of vertical velocity,
     //  needed for the PDF closure
@@ -278,23 +286,26 @@ void Functions<S, D>::shoc_main_internal(
     const Int &num_qtracers, // Number of tracers
     const Scalar &dtime,     // SHOC timestep [s]
     // Runtime Parameters
-    const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope, const Scalar &lambda_thresh,
-    const Scalar &thl2tune, const Scalar &qw2tune, const Scalar &qwthl2tune, const Scalar &w2tune,
-    const Scalar &length_fac, const Scalar &c_diag_3rd_mom, const Scalar &Ckh, const Scalar &Ckm,
+    const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope,
+    const Scalar &lambda_thresh, const Scalar &thl2tune, const Scalar &qw2tune,
+    const Scalar &qwthl2tune, const Scalar &w2tune, const Scalar &length_fac,
+    const Scalar &c_diag_3rd_mom, const Scalar &Ckh, const Scalar &Ckm,
     // Input Variables
-    const view_1d<const Scalar> &dx, const view_1d<const Scalar> &dy, const view_2d<const Spack> &zt_grid,
-    const view_2d<const Spack> &zi_grid, const view_2d<const Spack> &pres, const view_2d<const Spack> &presi,
-    const view_2d<const Spack> &pdel, const view_2d<const Spack> &thv, const view_2d<const Spack> &w_field,
-    const view_1d<const Scalar> &wthl_sfc, const view_1d<const Scalar> &wqw_sfc, const view_1d<const Scalar> &uw_sfc,
-    const view_1d<const Scalar> &vw_sfc, const view_2d<const Spack> &wtracer_sfc, const view_2d<const Spack> &inv_exner,
-    const view_1d<const Scalar> &phis,
+    const view_1d<const Scalar> &dx, const view_1d<const Scalar> &dy,
+    const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
+    const view_2d<const Spack> &pres, const view_2d<const Spack> &presi,
+    const view_2d<const Spack> &pdel, const view_2d<const Spack> &thv,
+    const view_2d<const Spack> &w_field, const view_1d<const Scalar> &wthl_sfc,
+    const view_1d<const Scalar> &wqw_sfc, const view_1d<const Scalar> &uw_sfc,
+    const view_1d<const Scalar> &vw_sfc, const view_2d<const Spack> &wtracer_sfc,
+    const view_2d<const Spack> &inv_exner, const view_1d<const Scalar> &phis,
     // Workspace Manager
     WorkspaceMgr &workspace_mgr,
     // Input/Output Variables
-    const view_2d<Spack> &host_dse, const view_2d<Spack> &tke, const view_2d<Spack> &thetal, const view_2d<Spack> &qw,
-    const uview_2d<Spack> &u_wind, const uview_2d<Spack> &v_wind, const view_2d<Spack> &wthv_sec,
-    const view_3d_strided<Spack> &qtracers, const view_2d<Spack> &tk, const view_2d<Spack> &shoc_cldfrac,
-    const view_2d<Spack> &shoc_ql,
+    const view_2d<Spack> &host_dse, const view_2d<Spack> &tke, const view_2d<Spack> &thetal,
+    const view_2d<Spack> &qw, const uview_2d<Spack> &u_wind, const uview_2d<Spack> &v_wind,
+    const view_2d<Spack> &wthv_sec, const view_3d_strided<Spack> &qtracers,
+    const view_2d<Spack> &tk, const view_2d<Spack> &shoc_cldfrac, const view_2d<Spack> &shoc_ql,
     // Output Variables
     const view_1d<Scalar> &pblh, const view_1d<Scalar> &ustar, const view_1d<Scalar> &obklen,
     const view_2d<Spack> &shoc_ql2, const view_2d<Spack> &tkh,
@@ -302,14 +313,15 @@ void Functions<S, D>::shoc_main_internal(
     const view_2d<Spack> &shoc_mix, const view_2d<Spack> &w_sec, const view_2d<Spack> &thl_sec,
     const view_2d<Spack> &qw_sec, const view_2d<Spack> &qwthl_sec, const view_2d<Spack> &wthl_sec,
     const view_2d<Spack> &wqw_sec, const view_2d<Spack> &wtke_sec, const view_2d<Spack> &uw_sec,
-    const view_2d<Spack> &vw_sec, const view_2d<Spack> &w3, const view_2d<Spack> &wqls_sec, const view_2d<Spack> &brunt,
-    const view_2d<Spack> &isotropy,
+    const view_2d<Spack> &vw_sec, const view_2d<Spack> &w3, const view_2d<Spack> &wqls_sec,
+    const view_2d<Spack> &brunt, const view_2d<Spack> &isotropy,
     // Temporaries
-    const view_1d<Scalar> &se_b, const view_1d<Scalar> &ke_b, const view_1d<Scalar> &wv_b, const view_1d<Scalar> &wl_b,
-    const view_1d<Scalar> &se_a, const view_1d<Scalar> &ke_a, const view_1d<Scalar> &wv_a, const view_1d<Scalar> &wl_a,
-    const view_1d<Scalar> &kbfs, const view_1d<Scalar> &ustar2, const view_1d<Scalar> &wstar,
-    const view_2d<Spack> &rho_zt, const view_2d<Spack> &shoc_qv, const view_2d<Spack> &shoc_tabs,
-    const view_2d<Spack> &dz_zt, const view_2d<Spack> &dz_zi) {
+    const view_1d<Scalar> &se_b, const view_1d<Scalar> &ke_b, const view_1d<Scalar> &wv_b,
+    const view_1d<Scalar> &wl_b, const view_1d<Scalar> &se_a, const view_1d<Scalar> &ke_a,
+    const view_1d<Scalar> &wv_a, const view_1d<Scalar> &wl_a, const view_1d<Scalar> &kbfs,
+    const view_1d<Scalar> &ustar2, const view_1d<Scalar> &wstar, const view_2d<Spack> &rho_zt,
+    const view_2d<Spack> &shoc_qv, const view_2d<Spack> &shoc_tabs, const view_2d<Spack> &dz_zt,
+    const view_2d<Spack> &dz_zi) {
   // Scalarize some views for single entry access
   const auto s_thetal  = ekat::scalarize(thetal);
   const auto s_shoc_ql = ekat::scalarize(shoc_ql);
@@ -319,7 +331,8 @@ void Functions<S, D>::shoc_main_internal(
   // for the computation of total energy before SHOC is called.  This is for an
   // effort to conserve energy since liquid water potential temperature (which SHOC
   // conserves) and static energy (which E3SM conserves) are not exactly equal.
-  shoc_energy_integrals_disp(shcol, nlev, host_dse, pdel, qw, shoc_ql, u_wind, v_wind, se_b, ke_b, wv_b, wl_b); // Input
+  shoc_energy_integrals_disp(shcol, nlev, host_dse, pdel, qw, shoc_ql, u_wind, v_wind, se_b, ke_b,
+                             wv_b, wl_b); // Input
 
   for (Int t = 0; t < nadv; ++t) {
     // Check TKE to make sure values lie within acceptable
@@ -388,18 +401,19 @@ void Functions<S, D>::shoc_main_internal(
     update_prognostics_implicit_disp(shcol, nlev, nlevi, num_qtracers, dtime, dz_zt,   // Input
                                      dz_zi, rho_zt, zt_grid, zi_grid, tk, tkh, uw_sfc, // Input
                                      vw_sfc, wthl_sfc, wqw_sfc, wtracer_sfc,           // Input
-                                     workspace_mgr,                                    // Workspace mgr
-                                     thetal, qw, qtracers, tke, u_wind, v_wind);       // Input/Output
+                                     workspace_mgr,                              // Workspace mgr
+                                     thetal, qw, qtracers, tke, u_wind, v_wind); // Input/Output
 
     // Diagnose the second order moments
-    diag_second_shoc_moments_disp(shcol, nlev, nlevi, thl2tune, qw2tune, qwthl2tune, w2tune, // Runtime options
-                                  thetal, qw, u_wind, v_wind,                                // Input
-                                  tke, isotropy, tkh, tk, dz_zi, zt_grid, zi_grid,           // Input
-                                  shoc_mix, wthl_sfc, wqw_sfc, uw_sfc, vw_sfc,               // Input
-                                  ustar2, wstar,                                             // Input/Output
-                                  workspace_mgr,                                             // Workspace
-                                  thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec,             // Output
-                                  uw_sec, vw_sec, wtke_sec, w_sec);                          // Output
+    diag_second_shoc_moments_disp(shcol, nlev, nlevi, thl2tune, qw2tune, qwthl2tune,
+                                  w2tune,                     // Runtime options
+                                  thetal, qw, u_wind, v_wind, // Input
+                                  tke, isotropy, tkh, tk, dz_zi, zt_grid, zi_grid, // Input
+                                  shoc_mix, wthl_sfc, wqw_sfc, uw_sfc, vw_sfc,     // Input
+                                  ustar2, wstar,                                   // Input/Output
+                                  workspace_mgr,                                   // Workspace
+                                  thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec,   // Output
+                                  uw_sec, vw_sec, wtke_sec, w_sec);                // Output
 
     // Diagnose the third moment of vertical velocity,
     //  needed for the PDF closure
@@ -469,22 +483,23 @@ void Functions<S, D>::shoc_main_internal(
 #endif
 
 template <typename S, typename D>
-Int Functions<S, D>::shoc_main(const Int &shcol,                         // Number of SHOC columns in the array
-                               const Int &nlev,                          // Number of levels
-                               const Int &nlevi,                         // Number of levels on interface grid
-                               const Int &npbl,                          // Maximum number of levels in pbl from surface
-                               const Int &nadv,                          // Number of times to loop SHOC
-                               const Int &num_qtracers,                  // Number of tracers
-                               const Scalar &dtime,                      // SHOC timestep [s]
-                               WorkspaceMgr &workspace_mgr,              // WorkspaceManager for local variables
-                               const SHOCRuntime &shoc_runtime,          // Runtime Options
-                               const SHOCInput &shoc_input,              // Input
-                               const SHOCInputOutput &shoc_input_output, // Input/Output
-                               const SHOCOutput &shoc_output,            // Output
-                               const SHOCHistoryOutput &shoc_history_output // Output (diagnostic)
+Int Functions<S, D>::shoc_main(
+    const Int &shcol,                            // Number of SHOC columns in the array
+    const Int &nlev,                             // Number of levels
+    const Int &nlevi,                            // Number of levels on interface grid
+    const Int &npbl,                             // Maximum number of levels in pbl from surface
+    const Int &nadv,                             // Number of times to loop SHOC
+    const Int &num_qtracers,                     // Number of tracers
+    const Scalar &dtime,                         // SHOC timestep [s]
+    WorkspaceMgr &workspace_mgr,                 // WorkspaceManager for local variables
+    const SHOCRuntime &shoc_runtime,             // Runtime Options
+    const SHOCInput &shoc_input,                 // Input
+    const SHOCInputOutput &shoc_input_output,    // Input/Output
+    const SHOCOutput &shoc_output,               // Output
+    const SHOCHistoryOutput &shoc_history_output // Output (diagnostic)
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-                               ,
-                               const SHOCTemporaries &shoc_temporaries // Temporaries for small kernels
+    ,
+    const SHOCTemporaries &shoc_temporaries // Temporaries for small kernels
 #endif
 ) {
   // Start timer
@@ -561,26 +576,29 @@ Int Functions<S, D>::shoc_main(const Int &shcol,                         // Numb
         const auto brunt_s        = ekat::subview(shoc_history_output.brunt, i);
         const auto isotropy_s     = ekat::subview(shoc_history_output.isotropy, i);
 
-        const auto u_wind_s   = Kokkos::subview(shoc_input_output.horiz_wind, i, 0, Kokkos::ALL());
-        const auto v_wind_s   = Kokkos::subview(shoc_input_output.horiz_wind, i, 1, Kokkos::ALL());
-        const auto qtracers_s = Kokkos::subview(shoc_input_output.qtracers, i, Kokkos::ALL(), Kokkos::ALL());
+        const auto u_wind_s = Kokkos::subview(shoc_input_output.horiz_wind, i, 0, Kokkos::ALL());
+        const auto v_wind_s = Kokkos::subview(shoc_input_output.horiz_wind, i, 1, Kokkos::ALL());
+        const auto qtracers_s =
+            Kokkos::subview(shoc_input_output.qtracers, i, Kokkos::ALL(), Kokkos::ALL());
 
-        shoc_main_internal(team, nlev, nlevi, npbl, nadv, num_qtracers, dtime, lambda_low, lambda_high, lambda_slope,
-                           lambda_thresh,                                         // Runtime options
-                           thl2tune, qw2tune, qwthl2tune, w2tune, length_fac,     // Runtime options
-                           c_diag_3rd_mom, Ckh, Ckm,                              // Runtime options
-                           dx_s, dy_s, zt_grid_s, zi_grid_s,                      // Input
-                           pres_s, presi_s, pdel_s, thv_s, w_field_s,             // Input
-                           wthl_sfc_s, wqw_sfc_s, uw_sfc_s, vw_sfc_s,             // Input
-                           wtracer_sfc_s, inv_exner_s, phis_s,                    // Input
-                           workspace,                                             // Workspace
-                           host_dse_s, tke_s, thetal_s, qw_s, u_wind_s, v_wind_s, // Input/Output
-                           wthv_sec_s, qtracers_s, tk_s, shoc_cldfrac_s,          // Input/Output
-                           shoc_ql_s,                                             // Input/Output
-                           pblh_s, ustar_s, obklen_s, shoc_ql2_s, tkh_s,          // Output
-                           shoc_mix_s, w_sec_s, thl_sec_s, qw_sec_s, qwthl_sec_s, // Diagnostic Output Variables
-                           wthl_sec_s, wqw_sec_s, wtke_sec_s, uw_sec_s, vw_sec_s, // Diagnostic Output Variables
-                           w3_s, wqls_sec_s, brunt_s, isotropy_s);                // Diagnostic Output Variables
+        shoc_main_internal(
+            team, nlev, nlevi, npbl, nadv, num_qtracers, dtime, lambda_low, lambda_high,
+            lambda_slope,
+            lambda_thresh,                                         // Runtime options
+            thl2tune, qw2tune, qwthl2tune, w2tune, length_fac,     // Runtime options
+            c_diag_3rd_mom, Ckh, Ckm,                              // Runtime options
+            dx_s, dy_s, zt_grid_s, zi_grid_s,                      // Input
+            pres_s, presi_s, pdel_s, thv_s, w_field_s,             // Input
+            wthl_sfc_s, wqw_sfc_s, uw_sfc_s, vw_sfc_s,             // Input
+            wtracer_sfc_s, inv_exner_s, phis_s,                    // Input
+            workspace,                                             // Workspace
+            host_dse_s, tke_s, thetal_s, qw_s, u_wind_s, v_wind_s, // Input/Output
+            wthv_sec_s, qtracers_s, tk_s, shoc_cldfrac_s,          // Input/Output
+            shoc_ql_s,                                             // Input/Output
+            pblh_s, ustar_s, obklen_s, shoc_ql2_s, tkh_s,          // Output
+            shoc_mix_s, w_sec_s, thl_sec_s, qw_sec_s, qwthl_sec_s, // Diagnostic Output Variables
+            wthl_sec_s, wqw_sec_s, wtke_sec_s, uw_sec_s, vw_sec_s, // Diagnostic Output Variables
+            w3_s, wqls_sec_s, brunt_s, isotropy_s);                // Diagnostic Output Variables
 
         shoc_output.pblh(i)   = pblh_s;
         shoc_output.ustar(i)  = ustar_s;
@@ -588,36 +606,41 @@ Int Functions<S, D>::shoc_main(const Int &shcol,                         // Numb
       });
   Kokkos::fence();
 #else
-  const auto u_wind_s = Kokkos::subview(shoc_input_output.horiz_wind, Kokkos::ALL(), 0, Kokkos::ALL());
-  const auto v_wind_s = Kokkos::subview(shoc_input_output.horiz_wind, Kokkos::ALL(), 1, Kokkos::ALL());
+  const auto u_wind_s =
+      Kokkos::subview(shoc_input_output.horiz_wind, Kokkos::ALL(), 0, Kokkos::ALL());
+  const auto v_wind_s =
+      Kokkos::subview(shoc_input_output.horiz_wind, Kokkos::ALL(), 1, Kokkos::ALL());
 
-  shoc_main_internal(shcol, nlev, nlevi, npbl, nadv, num_qtracers, dtime, lambda_low, lambda_high, lambda_slope,
-                     lambda_thresh,                                                        // Runtime options
-                     thl2tune, qw2tune, qwthl2tune, w2tune, length_fac,                    // Runtime options
-                     c_diag_3rd_mom, Ckh, Ckm,                                             // Runtime options
-                     shoc_input.dx, shoc_input.dy, shoc_input.zt_grid, shoc_input.zi_grid, // Input
-                     shoc_input.pres, shoc_input.presi, shoc_input.pdel, shoc_input.thv, shoc_input.w_field, // Input
-                     shoc_input.wthl_sfc, shoc_input.wqw_sfc, shoc_input.uw_sfc, shoc_input.vw_sfc,          // Input
-                     shoc_input.wtracer_sfc, shoc_input.inv_exner, shoc_input.phis,                          // Input
-                     workspace_mgr, // Workspace Manager
-                     shoc_input_output.host_dse, shoc_input_output.tke, shoc_input_output.thetal, shoc_input_output.qw,
-                     u_wind_s, v_wind_s, // Input/Output
-                     shoc_input_output.wthv_sec, shoc_input_output.qtracers, shoc_input_output.tk,
-                     shoc_input_output.shoc_cldfrac, // Input/Output
-                     shoc_input_output.shoc_ql,      // Input/Output
-                     shoc_output.pblh, shoc_output.ustar, shoc_output.obklen, shoc_output.shoc_ql2,
-                     shoc_output.tkh, // Output
-                     shoc_history_output.shoc_mix, shoc_history_output.w_sec, shoc_history_output.thl_sec,
-                     shoc_history_output.qw_sec, shoc_history_output.qwthl_sec, // Diagnostic Output Variables
-                     shoc_history_output.wthl_sec, shoc_history_output.wqw_sec, shoc_history_output.wtke_sec,
-                     shoc_history_output.uw_sec, shoc_history_output.vw_sec, // Diagnostic Output Variables
-                     shoc_history_output.w3, shoc_history_output.wqls_sec, shoc_history_output.brunt,
-                     shoc_history_output.isotropy, // Diagnostic Output Variables
-                     // Temporaries
-                     shoc_temporaries.se_b, shoc_temporaries.ke_b, shoc_temporaries.wv_b, shoc_temporaries.wl_b,
-                     shoc_temporaries.se_a, shoc_temporaries.ke_a, shoc_temporaries.wv_a, shoc_temporaries.wl_a,
-                     shoc_temporaries.kbfs, shoc_temporaries.ustar2, shoc_temporaries.wstar, shoc_temporaries.rho_zt,
-                     shoc_temporaries.shoc_qv, shoc_temporaries.tabs, shoc_temporaries.dz_zt, shoc_temporaries.dz_zi);
+  shoc_main_internal(
+      shcol, nlev, nlevi, npbl, nadv, num_qtracers, dtime, lambda_low, lambda_high, lambda_slope,
+      lambda_thresh,                                                        // Runtime options
+      thl2tune, qw2tune, qwthl2tune, w2tune, length_fac,                    // Runtime options
+      c_diag_3rd_mom, Ckh, Ckm,                                             // Runtime options
+      shoc_input.dx, shoc_input.dy, shoc_input.zt_grid, shoc_input.zi_grid, // Input
+      shoc_input.pres, shoc_input.presi, shoc_input.pdel, shoc_input.thv,
+      shoc_input.w_field,                                                            // Input
+      shoc_input.wthl_sfc, shoc_input.wqw_sfc, shoc_input.uw_sfc, shoc_input.vw_sfc, // Input
+      shoc_input.wtracer_sfc, shoc_input.inv_exner, shoc_input.phis,                 // Input
+      workspace_mgr, // Workspace Manager
+      shoc_input_output.host_dse, shoc_input_output.tke, shoc_input_output.thetal,
+      shoc_input_output.qw, u_wind_s, v_wind_s, // Input/Output
+      shoc_input_output.wthv_sec, shoc_input_output.qtracers, shoc_input_output.tk,
+      shoc_input_output.shoc_cldfrac, // Input/Output
+      shoc_input_output.shoc_ql,      // Input/Output
+      shoc_output.pblh, shoc_output.ustar, shoc_output.obklen, shoc_output.shoc_ql2,
+      shoc_output.tkh, // Output
+      shoc_history_output.shoc_mix, shoc_history_output.w_sec, shoc_history_output.thl_sec,
+      shoc_history_output.qw_sec, shoc_history_output.qwthl_sec, // Diagnostic Output Variables
+      shoc_history_output.wthl_sec, shoc_history_output.wqw_sec, shoc_history_output.wtke_sec,
+      shoc_history_output.uw_sec, shoc_history_output.vw_sec, // Diagnostic Output Variables
+      shoc_history_output.w3, shoc_history_output.wqls_sec, shoc_history_output.brunt,
+      shoc_history_output.isotropy, // Diagnostic Output Variables
+      // Temporaries
+      shoc_temporaries.se_b, shoc_temporaries.ke_b, shoc_temporaries.wv_b, shoc_temporaries.wl_b,
+      shoc_temporaries.se_a, shoc_temporaries.ke_a, shoc_temporaries.wv_a, shoc_temporaries.wl_a,
+      shoc_temporaries.kbfs, shoc_temporaries.ustar2, shoc_temporaries.wstar,
+      shoc_temporaries.rho_zt, shoc_temporaries.shoc_qv, shoc_temporaries.tabs,
+      shoc_temporaries.dz_zt, shoc_temporaries.dz_zi);
 #endif
 
   auto finish   = std::chrono::steady_clock::now();
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_check_pblh_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_check_pblh_impl.hpp
index e28a6a8a00..0fddd8d589 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_check_pblh_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_check_pblh_impl.hpp
@@ -13,8 +13,9 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::pblintd_check_pblh(const Int &nlevi, const Int &npbl,
-                                                         const uview_1d<const Spack> &z, const Scalar &ustar,
-                                                         const bool &check, Scalar &pblh) {
+                                                         const uview_1d<const Spack> &z,
+                                                         const Scalar &ustar, const bool &check,
+                                                         Scalar &pblh) {
   // PBL height must be greater than some minimum mechanical mixing depth
   // Several investigators have proposed minimum mechanical mixing depth
   // relationships as a function of the local friction velocity, u*.  We
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_cldcheck_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_cldcheck_impl.hpp
index e479b67e3c..8f59a34761 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_cldcheck_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_cldcheck_impl.hpp
@@ -9,7 +9,8 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::shoc_pblintd_cldcheck(const Scalar &zi, const Scalar &cldn, Scalar &pblh) {
+KOKKOS_FUNCTION void Functions<S, D>::shoc_pblintd_cldcheck(const Scalar &zi, const Scalar &cldn,
+                                                            Scalar &pblh) {
   //
   // Final requirement on PBL heightis that it must be greater than the depth
   // of the lowest model level if there is any cloud diagnosed in
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_height_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_height_impl.hpp
index 4ea0e5944a..3e5b5c8659 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_height_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_height_impl.hpp
@@ -15,11 +15,12 @@ namespace shoc {
 // the first level and the current level exceeds the "critical" value.
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::pblintd_height(const MemberType &team, const Int &nlev, const Int &npbl,
-                                                     const uview_1d<const Spack> &z, const uview_1d<const Spack> &u,
-                                                     const uview_1d<const Spack> &v, const Scalar &ustar,
-                                                     const uview_1d<const Spack> &thv, const Scalar &thv_ref,
-                                                     Scalar &pblh, const uview_1d<Spack> &rino, bool &check) {
+KOKKOS_FUNCTION void
+Functions<S, D>::pblintd_height(const MemberType &team, const Int &nlev, const Int &npbl,
+                                const uview_1d<const Spack> &z, const uview_1d<const Spack> &u,
+                                const uview_1d<const Spack> &v, const Scalar &ustar,
+                                const uview_1d<const Spack> &thv, const Scalar &thv_ref,
+                                Scalar &pblh, const uview_1d<Spack> &rino, bool &check) {
   if (!check)
     return;
 
@@ -54,11 +55,13 @@ KOKKOS_FUNCTION void Functions<S, D>::pblintd_height(const MemberType &team, con
         const auto in_range = (indices_pack < nlev - 1 && indices_pack >= nlev - npbl);
 
         Spack vvk(0);
-        vvk.set(in_range, ekat::max(tiny, ekat::square(u(k) - s_u(nlev - 1)) + ekat::square(v(k) - s_v(nlev - 1)) +
-                                              fac * (ustar * ustar)));
+        vvk.set(in_range,
+                ekat::max(tiny, ekat::square(u(k) - s_u(nlev - 1)) +
+                                    ekat::square(v(k) - s_v(nlev - 1)) + fac * (ustar * ustar)));
 
         if (in_range.any()) {
-          rino(k).set(in_range, ggr * (thv(k) - thv_ref) * (z(k) - s_z(nlev - 1)) / (s_thv(nlev - 1) * vvk));
+          rino(k).set(in_range,
+                      ggr * (thv(k) - thv_ref) * (z(k) - s_z(nlev - 1)) / (s_thv(nlev - 1) * vvk));
         }
 
         // Set indices_pack entry to -1 if rino(k)<ricr or
@@ -74,7 +77,8 @@ KOKKOS_FUNCTION void Functions<S, D>::pblintd_height(const MemberType &team, con
   // Set check=false and compute pblh only if
   // there was an index s.t. rino(k)>=ricr.
   if (max_indx != Kokkos::reduction_identity<Int>::max()) {
-    pblh = s_z(max_indx + 1) + (ricr - s_rino(max_indx + 1)) / (s_rino(max_indx) - s_rino(max_indx + 1)) *
+    pblh = s_z(max_indx + 1) + (ricr - s_rino(max_indx + 1)) /
+                                   (s_rino(max_indx) - s_rino(max_indx + 1)) *
                                    (s_z(max_indx) - s_z(max_indx + 1));
     check = false;
   }
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_impl.hpp
index 6ea1048f61..5387048c00 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_impl.hpp
@@ -42,9 +42,10 @@ KOKKOS_FUNCTION void
 Functions<S, D>::pblintd(const MemberType &team, const Int &nlev, const Int &nlevi, const Int &npbl,
                          const uview_1d<const Spack> &z, const uview_1d<const Spack> &zi,
                          const uview_1d<const Spack> &thl, const uview_1d<const Spack> &ql,
-                         const uview_1d<const Spack> &q, const uview_1d<const Spack> &u, const uview_1d<const Spack> &v,
-                         const Scalar &ustar, const Scalar &obklen, const Scalar &kbfs,
-                         const uview_1d<const Spack> &cldn, const Workspace &workspace, Scalar &pblh) {
+                         const uview_1d<const Spack> &q, const uview_1d<const Spack> &u,
+                         const uview_1d<const Spack> &v, const Scalar &ustar, const Scalar &obklen,
+                         const Scalar &kbfs, const uview_1d<const Spack> &cldn,
+                         const Workspace &workspace, Scalar &pblh) {
   // Define temporary variables
   uview_1d<Spack> rino, thv;
   workspace.template take_many_contiguous_unsafe<2>({"rino", "thv"}, {&rino, &thv});
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_init_pot_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_init_pot_impl.hpp
index 42afa39c21..e01037a33d 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_init_pot_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_init_pot_impl.hpp
@@ -12,7 +12,8 @@ template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::shoc_pblintd_init_pot(const MemberType &team, const Int &nlev,
                                                             const view_1d<const Spack> &thl,
                                                             const view_1d<const Spack> &ql,
-                                                            const view_1d<const Spack> &q, const view_1d<Spack> &thv) {
+                                                            const view_1d<const Spack> &q,
+                                                            const view_1d<Spack> &thv) {
   // Compute virtual potential temperature
   const auto lcond = C::LatVap;
   const auto cp    = C::Cpair;
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_surf_temp_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_surf_temp_impl.hpp
index 3b0969d0c4..1bebc891e2 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_pblintd_surf_temp_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_pblintd_surf_temp_impl.hpp
@@ -12,11 +12,10 @@ namespace shoc {
  */
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::pblintd_surf_temp(const Int &nlev, const Int &nlevi, const Int &npbl,
-                                                        const uview_1d<const Spack> &z, const Scalar &ustar,
-                                                        const Scalar &obklen, const Scalar &kbfs,
-                                                        const uview_1d<const Spack> &thv, Scalar &tlv, Scalar &pblh,
-                                                        bool &check, const uview_1d<Spack> &rino) {
+KOKKOS_FUNCTION void Functions<S, D>::pblintd_surf_temp(
+    const Int &nlev, const Int &nlevi, const Int &npbl, const uview_1d<const Spack> &z,
+    const Scalar &ustar, const Scalar &obklen, const Scalar &kbfs, const uview_1d<const Spack> &thv,
+    Scalar &tlv, Scalar &pblh, bool &check, const uview_1d<Spack> &rino) {
   // const parameter for Diagnosis of PBL depth
   const Scalar fak    = 8.5;
   const Scalar betam  = 15.0;
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_tke_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_tke_impl.hpp
index a5a89762bb..a454eb9720 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_tke_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_tke_impl.hpp
@@ -19,17 +19,21 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::shoc_tke(
-    const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &dtime, const Scalar &lambda_low,
-    const Scalar &lambda_high, const Scalar &lambda_slope, const Scalar &lambda_thresh, const Scalar &Ckh,
-    const Scalar &Ckm, const uview_1d<const Spack> &wthv_sec, const uview_1d<const Spack> &shoc_mix,
-    const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &pres,
-    const uview_1d<const Spack> &tabs, const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind,
-    const uview_1d<const Spack> &brunt, const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid,
-    const Scalar &pblh, const Workspace &workspace, const uview_1d<Spack> &tke, const uview_1d<Spack> &tk,
-    const uview_1d<Spack> &tkh, const uview_1d<Spack> &isotropy) {
+    const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &dtime,
+    const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope,
+    const Scalar &lambda_thresh, const Scalar &Ckh, const Scalar &Ckm,
+    const uview_1d<const Spack> &wthv_sec, const uview_1d<const Spack> &shoc_mix,
+    const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &dz_zt,
+    const uview_1d<const Spack> &pres, const uview_1d<const Spack> &tabs,
+    const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind,
+    const uview_1d<const Spack> &brunt, const uview_1d<const Spack> &zt_grid,
+    const uview_1d<const Spack> &zi_grid, const Scalar &pblh, const Workspace &workspace,
+    const uview_1d<Spack> &tke, const uview_1d<Spack> &tk, const uview_1d<Spack> &tkh,
+    const uview_1d<Spack> &isotropy) {
   // Define temporary variables
   uview_1d<Spack> sterm_zt, a_diss, sterm;
-  workspace.template take_many_contiguous_unsafe<3>({"sterm_zt", "a_diss", "sterm"}, {&sterm_zt, &a_diss, &sterm});
+  workspace.template take_many_contiguous_unsafe<3>({"sterm_zt", "a_diss", "sterm"},
+                                                    {&sterm_zt, &a_diss, &sterm});
 
   // Compute integrated column stability in lower troposphere
   Scalar brunt_int(0);
@@ -47,11 +51,12 @@ KOKKOS_FUNCTION void Functions<S, D>::shoc_tke(
   adv_sgs_tke(team, nlev, dtime, shoc_mix, wthv_sec, sterm_zt, tk, tke, a_diss);
 
   // Compute isotropic time scale [s]
-  isotropic_ts(team, nlev, lambda_low, lambda_high, lambda_slope, lambda_thresh, brunt_int, tke, a_diss, brunt,
-               isotropy);
+  isotropic_ts(team, nlev, lambda_low, lambda_high, lambda_slope, lambda_thresh, brunt_int, tke,
+               a_diss, brunt, isotropy);
 
   // Compute eddy diffusivity for heat and momentum
-  eddy_diffusivities(team, nlev, Ckh, Ckm, pblh, zt_grid, tabs, shoc_mix, sterm_zt, isotropy, tke, tkh, tk);
+  eddy_diffusivities(team, nlev, Ckh, Ckm, pblh, zt_grid, tabs, shoc_mix, sterm_zt, isotropy, tke,
+                     tkh, tk);
 
   // Release temporary variables from the workspace
   workspace.template release_many_contiguous<3>({&sterm_zt, &a_diss, &sterm});
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_tridiag_solver_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_tridiag_solver_impl.hpp
index c1e6b718bb..bb5b6fc62c 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_tridiag_solver_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_tridiag_solver_impl.hpp
@@ -8,11 +8,11 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::vd_shoc_decomp(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &kv_term,
-                                const uview_1d<const Spack> &tmpi, const uview_1d<const Spack> &rdp_zt,
-                                const Scalar &dtime, const Scalar &flux, const uview_1d<Scalar> &du,
-                                const uview_1d<Scalar> &dl, const uview_1d<Scalar> &d) {
+KOKKOS_FUNCTION void Functions<S, D>::vd_shoc_decomp(
+    const MemberType &team, const Int &nlev, const uview_1d<const Spack> &kv_term,
+    const uview_1d<const Spack> &tmpi, const uview_1d<const Spack> &rdp_zt, const Scalar &dtime,
+    const Scalar &flux, const uview_1d<Scalar> &du, const uview_1d<Scalar> &dl,
+    const uview_1d<Scalar> &d) {
   const auto ggr = C::gravit;
 
   const auto skv_term = scalarize(kv_term);
@@ -63,9 +63,10 @@ Functions<S, D>::vd_shoc_decomp(const MemberType &team, const Int &nlev, const u
 }
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void Functions<S, D>::vd_shoc_solve(const MemberType &team, const uview_1d<Scalar> &du,
-                                                    const uview_1d<Scalar> &dl, const uview_1d<Scalar> &d,
-                                                    const uview_2d<Spack> &var) {
+KOKKOS_FUNCTION void
+Functions<S, D>::vd_shoc_solve(const MemberType &team, const uview_1d<Scalar> &du,
+                               const uview_1d<Scalar> &dl, const uview_1d<Scalar> &d,
+                               const uview_2d<Spack> &var) {
 #ifdef EKAT_DEFAULT_BFB
   ekat::tridiag::bfb(team, dl, d, du, var);
 #else
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_update_host_dse_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_update_host_dse_impl.hpp
index fda4beb575..6b26b34452 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_update_host_dse_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_update_host_dse_impl.hpp
@@ -7,11 +7,10 @@ namespace scream {
 namespace shoc {
 
 template <typename S, typename D>
-KOKKOS_FUNCTION void
-Functions<S, D>::update_host_dse(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &thlm,
-                                 const uview_1d<const Spack> &shoc_ql, const uview_1d<const Spack> &inv_exner,
-                                 const uview_1d<const Spack> &zt_grid, const Scalar &phis,
-                                 const uview_1d<Spack> &host_dse) {
+KOKKOS_FUNCTION void Functions<S, D>::update_host_dse(
+    const MemberType &team, const Int &nlev, const uview_1d<const Spack> &thlm,
+    const uview_1d<const Spack> &shoc_ql, const uview_1d<const Spack> &inv_exner,
+    const uview_1d<const Spack> &zt_grid, const Scalar &phis, const uview_1d<Spack> &host_dse) {
   const Int nlev_pack = ekat::npack<Spack>(nlev);
 
   // Constants used
diff --git i/components/eamxx/src/physics/shoc/impl/shoc_update_prognostics_implicit_impl.hpp w/components/eamxx/src/physics/shoc/impl/shoc_update_prognostics_implicit_impl.hpp
index ffde169d18..232a881e93 100644
--- i/components/eamxx/src/physics/shoc/impl/shoc_update_prognostics_implicit_impl.hpp
+++ w/components/eamxx/src/physics/shoc/impl/shoc_update_prognostics_implicit_impl.hpp
@@ -13,13 +13,15 @@ namespace shoc {
 
 template <typename S, typename D>
 KOKKOS_FUNCTION void Functions<S, D>::update_prognostics_implicit(
-    const MemberType &team, const Int &nlev, const Int &nlevi, const Int &num_qtracers, const Scalar &dtime,
-    const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &rho_zt,
-    const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &tk,
-    const uview_1d<const Spack> &tkh, const Scalar &uw_sfc, const Scalar &vw_sfc, const Scalar &wthl_sfc,
-    const Scalar &wqw_sfc, const uview_1d<const Spack> &wtracer_sfc, const Workspace &workspace,
-    const uview_1d<Spack> &thetal, const uview_1d<Spack> &qw, const uview_2d_strided<Spack> &qtracers,
-    const uview_1d<Spack> &tke, const uview_1d<Spack> &u_wind, const uview_1d<Spack> &v_wind) {
+    const MemberType &team, const Int &nlev, const Int &nlevi, const Int &num_qtracers,
+    const Scalar &dtime, const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &dz_zi,
+    const uview_1d<const Spack> &rho_zt, const uview_1d<const Spack> &zt_grid,
+    const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &tk,
+    const uview_1d<const Spack> &tkh, const Scalar &uw_sfc, const Scalar &vw_sfc,
+    const Scalar &wthl_sfc, const Scalar &wqw_sfc, const uview_1d<const Spack> &wtracer_sfc,
+    const Workspace &workspace, const uview_1d<Spack> &thetal, const uview_1d<Spack> &qw,
+    const uview_2d_strided<Spack> &qtracers, const uview_1d<Spack> &tke,
+    const uview_1d<Spack> &u_wind, const uview_1d<Spack> &v_wind) {
   // Define temporary variables via the WorkspaceManager
 
   // 1d allocations
@@ -29,8 +31,9 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostics_implicit(
   workspace.template take_many_contiguous_unsafe<5>({"tmpi", "tkh_zi", "tk_zi", "rho_zi", "rdp_zt"},
                                                     {&tmpi, &tkh_zi, &tk_zi, &rho_zi, &rdp_zt});
 
-  workspace.template take_many_contiguous_unsafe<3, Scalar>({"du_workspace", "dl_workspace", "d_workspace"},
-                                                            {&du_workspace, &dl_workspace, &d_workspace});
+  workspace.template take_many_contiguous_unsafe<3, Scalar>(
+      {"du_workspace", "dl_workspace", "d_workspace"},
+      {&du_workspace, &dl_workspace, &d_workspace});
   auto du = Kokkos::subview(du_workspace, Kokkos::make_pair(0, nlev));
   auto dl = Kokkos::subview(dl_workspace, Kokkos::make_pair(0, nlev));
   auto d  = Kokkos::subview(d_workspace, Kokkos::make_pair(0, nlev));
@@ -42,13 +45,15 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostics_implicit(
   const int n_wind_slots = num_wind_transpose_packs * Spack::n;
   const int n_trac_slots = num_qtracers_transpose_packs * Spack::n;
 
-  const auto wind_slot    = workspace.template take_macro_block<Scalar>("wind_slot", n_wind_slots);
-  const auto tracers_slot = workspace.template take_macro_block<Scalar>("tracers_slot", n_trac_slots);
+  const auto wind_slot = workspace.template take_macro_block<Scalar>("wind_slot", n_wind_slots);
+  const auto tracers_slot =
+      workspace.template take_macro_block<Scalar>("tracers_slot", n_trac_slots);
 
   // Reshape 2d views
-  const auto wind_rhs = uview_2d<Spack>(reinterpret_cast<Spack *>(wind_slot.data()), nlev, num_wind_transpose_packs);
-  const auto qtracers_rhs =
-      uview_2d<Spack>(reinterpret_cast<Spack *>(tracers_slot.data()), nlev, num_qtracers_transpose_packs);
+  const auto wind_rhs =
+      uview_2d<Spack>(reinterpret_cast<Spack *>(wind_slot.data()), nlev, num_wind_transpose_packs);
+  const auto qtracers_rhs = uview_2d<Spack>(reinterpret_cast<Spack *>(tracers_slot.data()), nlev,
+                                            num_qtracers_transpose_packs);
 
   // scalarized versions of some views will be needed
   const auto rdp_zt_s       = ekat::scalarize(rdp_zt);
@@ -98,7 +103,8 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostics_implicit(
     const Scalar u_wind_sfc = u_wind_s(nlev - 1);
     const Scalar v_wind_sfc = v_wind_s(nlev - 1);
 
-    const Scalar ws  = ekat::impl::max(std::sqrt((u_wind_sfc * u_wind_sfc) + v_wind_sfc * v_wind_sfc), wsmin);
+    const Scalar ws =
+        ekat::impl::max(std::sqrt((u_wind_sfc * u_wind_sfc) + v_wind_sfc * v_wind_sfc), wsmin);
     const Scalar tau = std::sqrt(taux * taux + tauy * tauy);
     ksrf             = ekat::impl::max(tau / ws, ksrfmin);
 
@@ -117,8 +123,9 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostics_implicit(
 
     const auto sfc_lev_idx  = (nlev - 1) / Spack::n;
     const auto sfc_pack_idx = (nlev - 1) % Spack::n;
-    Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_qtracers),
-                         [&](const Int &q) { qtracers(q, sfc_lev_idx)[sfc_pack_idx] += cmnfac * wtracer_sfc_s(q); });
+    Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_qtracers), [&](const Int &q) {
+      qtracers(q, sfc_lev_idx)[sfc_pack_idx] += cmnfac * wtracer_sfc_s(q);
+    });
   }
 
   // Store RHS values in wind_rhs and qtracers_rhs for 1st and 2nd solve respectively
@@ -130,8 +137,9 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostics_implicit(
     // The rhs version of the tracers is the transpose of the input/output layout
     const auto lev_idx  = k / Spack::n;
     const auto pack_idx = k % Spack::n;
-    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_qtracers),
-                         [&](const Int &q) { qtracers_rhs_s(k, q) = qtracers(q, lev_idx)[pack_idx]; });
+    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_qtracers), [&](const Int &q) {
+      qtracers_rhs_s(k, q) = qtracers(q, lev_idx)[pack_idx];
+    });
     qtracers_rhs_s(k, num_qtracers)     = thetal_s(k);
     qtracers_rhs_s(k, num_qtracers + 1) = qw_s(k);
     qtracers_rhs_s(k, num_qtracers + 2) = tke_s(k);
@@ -168,8 +176,9 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostics_implicit(
     // Transpose tracers back to  input/output layout
     const auto lev_idx  = k / Spack::n;
     const auto pack_idx = k % Spack::n;
-    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_qtracers),
-                         [&](const Int &q) { qtracers(q, lev_idx)[pack_idx] = qtracers_rhs_s(k, q); });
+    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_qtracers), [&](const Int &q) {
+      qtracers(q, lev_idx)[pack_idx] = qtracers_rhs_s(k, q);
+    });
     thetal_s(k) = qtracers_rhs_s(k, num_qtracers);
     qw_s(k)     = qtracers_rhs_s(k, num_qtracers + 1);
     tke_s(k)    = qtracers_rhs_s(k, num_qtracers + 2);
@@ -179,7 +188,8 @@ KOKKOS_FUNCTION void Functions<S, D>::update_prognostics_implicit(
   team.team_barrier();
   workspace.template release_macro_block<Scalar>(tracers_slot, n_trac_slots);
   workspace.template release_macro_block<Scalar>(wind_slot, n_wind_slots);
-  workspace.template release_many_contiguous<3, Scalar>({&du_workspace, &dl_workspace, &d_workspace});
+  workspace.template release_many_contiguous<3, Scalar>(
+      {&du_workspace, &dl_workspace, &d_workspace});
   workspace.template release_many_contiguous<5>({&tmpi, &tkh_zi, &tk_zi, &rho_zi, &rdp_zt});
 }
 
diff --git i/components/eamxx/src/physics/shoc/shoc_constants.hpp w/components/eamxx/src/physics/shoc/shoc_constants.hpp
index 3e438c2fb9..b6316dbb7c 100644
--- i/components/eamxx/src/physics/shoc/shoc_constants.hpp
+++ w/components/eamxx/src/physics/shoc/shoc_constants.hpp
@@ -9,16 +9,18 @@ namespace shoc {
  */
 
 template <typename Scalar> struct Constants {
-  static constexpr Scalar mintke      = 0.0004;       // Minimum TKE [m2/s2]
-  static constexpr Scalar maxtke      = 50.0;         // Maximum TKE [m2/s2]
-  static constexpr Scalar minlen      = 20.0;         // Lower limit for mixing length [m]
-  static constexpr Scalar maxlen      = 20000.0;      // Upper limit for mixing length [m]
-  static constexpr Scalar maxiso      = 20000.0;      // Upper limit for isotropy time scale [s]
-  static constexpr Scalar w3clip      = 1.2;          // Third moment of vertical velocity
-  static constexpr Scalar ustar_min   = 0.01;         // Minimum surface friction velocity
-  static constexpr Scalar largeneg    = -99999999.99; // Large negative value used for linear_interp threshold
-  static constexpr bool dothetal_skew = false; // Allow temperature skewness to be independent of moisture variance
-  static constexpr Scalar pblmaxp     = 4e4;   // PBL max depth in pressure units
+  static constexpr Scalar mintke    = 0.0004;  // Minimum TKE [m2/s2]
+  static constexpr Scalar maxtke    = 50.0;    // Maximum TKE [m2/s2]
+  static constexpr Scalar minlen    = 20.0;    // Lower limit for mixing length [m]
+  static constexpr Scalar maxlen    = 20000.0; // Upper limit for mixing length [m]
+  static constexpr Scalar maxiso    = 20000.0; // Upper limit for isotropy time scale [s]
+  static constexpr Scalar w3clip    = 1.2;     // Third moment of vertical velocity
+  static constexpr Scalar ustar_min = 0.01;    // Minimum surface friction velocity
+  static constexpr Scalar largeneg =
+      -99999999.99; // Large negative value used for linear_interp threshold
+  static constexpr bool dothetal_skew =
+      false; // Allow temperature skewness to be independent of moisture variance
+  static constexpr Scalar pblmaxp = 4e4; // PBL max depth in pressure units
 };
 
 } // namespace shoc
diff --git i/components/eamxx/src/physics/shoc/shoc_functions.hpp w/components/eamxx/src/physics/shoc/shoc_functions.hpp
index 9c5e068863..92d2f8c636 100644
--- i/components/eamxx/src/physics/shoc/shoc_functions.hpp
+++ w/components/eamxx/src/physics/shoc/shoc_functions.hpp
@@ -51,13 +51,15 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   template <typename S> using view_2d_strided = typename KT::template sview<S **>;
   template <typename S> using view_3d_strided = typename KT::template sview<S ***>;
 
-  template <typename S, int N> using view_1d_ptr_array = typename KT::template view_1d_ptr_carray<S, N>;
+  template <typename S, int N>
+  using view_1d_ptr_array = typename KT::template view_1d_ptr_carray<S, N>;
 
   template <typename S> using uview_1d = typename ekat::template Unmanaged<view_1d<S>>;
 
   template <typename S> using uview_2d = typename ekat::template Unmanaged<view_2d<S>>;
 
-  template <typename S> using uview_2d_strided = typename ekat::template Unmanaged<view_2d_strided<S>>;
+  template <typename S>
+  using uview_2d_strided = typename ekat::template Unmanaged<view_2d_strided<S>>;
 
   using MemberType = typename KT::MemberType;
 
@@ -228,53 +230,66 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   //
   KOKKOS_FUNCTION
   static void calc_shoc_varorcovar(const MemberType &team, const Int &nlev, const Scalar &tunefac,
-                                   const uview_1d<const Spack> &isotropy_zi, const uview_1d<const Spack> &tkh_zi,
-                                   const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &invar1,
-                                   const uview_1d<const Spack> &invar2, const uview_1d<Spack> &varorcovar);
+                                   const uview_1d<const Spack> &isotropy_zi,
+                                   const uview_1d<const Spack> &tkh_zi,
+                                   const uview_1d<const Spack> &dz_zi,
+                                   const uview_1d<const Spack> &invar1,
+                                   const uview_1d<const Spack> &invar2,
+                                   const uview_1d<Spack> &varorcovar);
 
   KOKKOS_FUNCTION
-  static void calc_shoc_vertflux(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &tkh_zi,
-                                 const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &invar,
+  static void calc_shoc_vertflux(const MemberType &team, const Int &nlev,
+                                 const uview_1d<const Spack> &tkh_zi,
+                                 const uview_1d<const Spack> &dz_zi,
+                                 const uview_1d<const Spack> &invar,
                                  const uview_1d<Spack> &vertflux);
 
   KOKKOS_FUNCTION
-  static void shoc_diag_second_moments_srf(const Scalar &wthl_sfc, const Scalar &uw_sfc, const Scalar &vw_sfc,
-                                           Scalar &ustar2, Scalar &wstar);
+  static void shoc_diag_second_moments_srf(const Scalar &wthl_sfc, const Scalar &uw_sfc,
+                                           const Scalar &vw_sfc, Scalar &ustar2, Scalar &wstar);
 
   KOKKOS_FUNCTION
-  static void shoc_diag_second_moments_ubycond(Scalar &thl_sec, Scalar &qw_sec, Scalar &wthl_sec, Scalar &wqw_sec,
-                                               Scalar &qwthl_sec, Scalar &uw_sec, Scalar &vw_sec, Scalar &wtke_sec);
+  static void shoc_diag_second_moments_ubycond(Scalar &thl_sec, Scalar &qw_sec, Scalar &wthl_sec,
+                                               Scalar &wqw_sec, Scalar &qwthl_sec, Scalar &uw_sec,
+                                               Scalar &vw_sec, Scalar &wtke_sec);
 
   KOKKOS_FUNCTION
-  static void update_host_dse(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &thlm,
-                              const uview_1d<const Spack> &shoc_ql, const uview_1d<const Spack> &inv_exner,
+  static void update_host_dse(const MemberType &team, const Int &nlev,
+                              const uview_1d<const Spack> &thlm,
+                              const uview_1d<const Spack> &shoc_ql,
+                              const uview_1d<const Spack> &inv_exner,
                               const uview_1d<const Spack> &zt_grid, const Scalar &phis,
                               const uview_1d<Spack> &host_dse);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void update_host_dse_disp(const Int &shcol, const Int &nlev, const view_2d<const Spack> &thlm,
-                                   const view_2d<const Spack> &shoc_ql, const view_2d<const Spack> &inv_exner,
-                                   const view_2d<const Spack> &zt_grid, const view_1d<const Scalar> &phis,
-                                   const view_2d<Spack> &host_dse);
+  static void
+  update_host_dse_disp(const Int &shcol, const Int &nlev, const view_2d<const Spack> &thlm,
+                       const view_2d<const Spack> &shoc_ql, const view_2d<const Spack> &inv_exner,
+                       const view_2d<const Spack> &zt_grid, const view_1d<const Scalar> &phis,
+                       const view_2d<Spack> &host_dse);
 #endif
 
   KOKKOS_FUNCTION
   static void compute_diag_third_shoc_moment(
       const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &c_diag_3rd_mom,
-      const uview_1d<const Spack> &w_sec, const uview_1d<const Spack> &thl_sec, const uview_1d<const Spack> &wthl_sec,
-      const uview_1d<const Spack> &tke, const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &dz_zi,
+      const uview_1d<const Spack> &w_sec, const uview_1d<const Spack> &thl_sec,
+      const uview_1d<const Spack> &wthl_sec, const uview_1d<const Spack> &tke,
+      const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &dz_zi,
       const uview_1d<const Spack> &isotropy_zi, const uview_1d<const Spack> &brunt_zi,
-      const uview_1d<const Spack> &w_sec_zi, const uview_1d<const Spack> &thetal_zi, const uview_1d<Spack> &w3);
+      const uview_1d<const Spack> &w_sec_zi, const uview_1d<const Spack> &thetal_zi,
+      const uview_1d<Spack> &w3);
 
   KOKKOS_FUNCTION
-  static void shoc_pblintd_init_pot(const MemberType &team, const Int &nlev, const view_1d<const Spack> &thl,
-                                    const view_1d<const Spack> &ql, const view_1d<const Spack> &q,
-                                    const view_1d<Spack> &thv);
+  static void shoc_pblintd_init_pot(const MemberType &team, const Int &nlev,
+                                    const view_1d<const Spack> &thl, const view_1d<const Spack> &ql,
+                                    const view_1d<const Spack> &q, const view_1d<Spack> &thv);
 
   KOKKOS_FUNCTION
-  static void compute_shoc_mix_shoc_length(const MemberType &team, const Int &nlev, const Scalar &length_fac,
-                                           const uview_1d<const Spack> &tke, const uview_1d<const Spack> &brunt,
-                                           const uview_1d<const Spack> &zt_grid, const Scalar &l_inf,
-                                           const uview_1d<Spack> &shoc_mix);
+  static void compute_shoc_mix_shoc_length(const MemberType &team, const Int &nlev,
+                                           const Scalar &length_fac,
+                                           const uview_1d<const Spack> &tke,
+                                           const uview_1d<const Spack> &brunt,
+                                           const uview_1d<const Spack> &zt_grid,
+                                           const Scalar &l_inf, const uview_1d<Spack> &shoc_mix);
 
   KOKKOS_FUNCTION
   static void check_tke(const MemberType &team, const Int &nlev, const uview_1d<Spack> &tke);
@@ -284,291 +299,351 @@ template <typename ScalarT, typename DeviceT> struct Functions {
 
   KOKKOS_FUNCTION
   static void clipping_diag_third_shoc_moments(const MemberType &team, const Int &nlevi,
-                                               const uview_1d<const Spack> &w_sec_zi, const uview_1d<Spack> &w3);
+                                               const uview_1d<const Spack> &w_sec_zi,
+                                               const uview_1d<Spack> &w3);
 
   KOKKOS_FUNCTION
-  static void linear_interp(const MemberType &team, const uview_1d<const Spack> &x1, const uview_1d<const Spack> &x2,
-                            const uview_1d<const Spack> &y1, const uview_1d<Spack> &y2, const Int &km1, const Int &km2,
+  static void linear_interp(const MemberType &team, const uview_1d<const Spack> &x1,
+                            const uview_1d<const Spack> &x2, const uview_1d<const Spack> &y1,
+                            const uview_1d<Spack> &y2, const Int &km1, const Int &km2,
                             const Scalar &minthresh);
 
   KOKKOS_FUNCTION
-  static void shoc_energy_integrals(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &host_dse,
-                                    const uview_1d<const Spack> &pdel, const uview_1d<const Spack> &rtm,
-                                    const uview_1d<const Spack> &rcm, const uview_1d<const Spack> &u_wind,
-                                    const uview_1d<const Spack> &v_wind, Scalar &se_int, Scalar &ke_int, Scalar &wv_int,
-                                    Scalar &wl_int);
+  static void
+  shoc_energy_integrals(const MemberType &team, const Int &nlev,
+                        const uview_1d<const Spack> &host_dse, const uview_1d<const Spack> &pdel,
+                        const uview_1d<const Spack> &rtm, const uview_1d<const Spack> &rcm,
+                        const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind,
+                        Scalar &se_int, Scalar &ke_int, Scalar &wv_int, Scalar &wl_int);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void shoc_energy_integrals_disp(const Int &shcol, const Int &nlev, const view_2d<const Spack> &host_dse,
-                                         const view_2d<const Spack> &pdel, const view_2d<const Spack> &rtm,
-                                         const view_2d<const Spack> &rcm, const uview_2d<const Spack> &u_wind,
-                                         const uview_2d<const Spack> &v_wind, const view_1d<Scalar> &se_b_slot,
-                                         const view_1d<Scalar> &ke_b_slot, const view_1d<Scalar> &wv_b_slot,
-                                         const view_1d<Scalar> &wl_b_slot);
+  static void
+  shoc_energy_integrals_disp(const Int &shcol, const Int &nlev,
+                             const view_2d<const Spack> &host_dse, const view_2d<const Spack> &pdel,
+                             const view_2d<const Spack> &rtm, const view_2d<const Spack> &rcm,
+                             const uview_2d<const Spack> &u_wind,
+                             const uview_2d<const Spack> &v_wind, const view_1d<Scalar> &se_b_slot,
+                             const view_1d<Scalar> &ke_b_slot, const view_1d<Scalar> &wv_b_slot,
+                             const view_1d<Scalar> &wl_b_slot);
 #endif
 
   KOKKOS_FUNCTION
-  static void shoc_diag_second_moments_lbycond(const Scalar &wthl_sfc, const Scalar &wqw_sfc, const Scalar &uw_sfc,
-                                               const Scalar &vw_sfc, const Scalar &ustar2, const Scalar &wstar,
-                                               Scalar &wthl_sec, Scalar &wqw_sec, Scalar &uw_sec, Scalar &vw_sec,
-                                               Scalar &wtke_sec, Scalar &thl_sec, Scalar &qw_sec, Scalar &qwthl_sec);
+  static void shoc_diag_second_moments_lbycond(const Scalar &wthl_sfc, const Scalar &wqw_sfc,
+                                               const Scalar &uw_sfc, const Scalar &vw_sfc,
+                                               const Scalar &ustar2, const Scalar &wstar,
+                                               Scalar &wthl_sec, Scalar &wqw_sec, Scalar &uw_sec,
+                                               Scalar &vw_sec, Scalar &wtke_sec, Scalar &thl_sec,
+                                               Scalar &qw_sec, Scalar &qwthl_sec);
 
   KOKKOS_FUNCTION
   static void diag_second_moments(
-      const MemberType &team, const Int &nlev, const Int &nlevi, const Real &thl2tune, const Real &qw2tune,
-      const Real &qwthl2tune, const Real &w2tune, const uview_1d<const Spack> &thetal, const uview_1d<const Spack> &qw,
-      const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind, const uview_1d<const Spack> &tke,
-      const uview_1d<const Spack> &isotropy, const uview_1d<const Spack> &tkh, const uview_1d<const Spack> &tk,
-      const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid,
-      const uview_1d<const Spack> &shoc_mix, const uview_1d<Spack> &isotropy_zi, const uview_1d<Spack> &tkh_zi,
+      const MemberType &team, const Int &nlev, const Int &nlevi, const Real &thl2tune,
+      const Real &qw2tune, const Real &qwthl2tune, const Real &w2tune,
+      const uview_1d<const Spack> &thetal, const uview_1d<const Spack> &qw,
+      const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind,
+      const uview_1d<const Spack> &tke, const uview_1d<const Spack> &isotropy,
+      const uview_1d<const Spack> &tkh, const uview_1d<const Spack> &tk,
+      const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &zt_grid,
+      const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &shoc_mix,
+      const uview_1d<Spack> &isotropy_zi, const uview_1d<Spack> &tkh_zi,
       const uview_1d<Spack> &tk_zi, const uview_1d<Spack> &thl_sec, const uview_1d<Spack> &qw_sec,
-      const uview_1d<Spack> &wthl_sec, const uview_1d<Spack> &wqw_sec, const uview_1d<Spack> &qwthl_sec,
-      const uview_1d<Spack> &uw_sec, const uview_1d<Spack> &vw_sec, const uview_1d<Spack> &wtke_sec,
-      const uview_1d<Spack> &w_sec);
+      const uview_1d<Spack> &wthl_sec, const uview_1d<Spack> &wqw_sec,
+      const uview_1d<Spack> &qwthl_sec, const uview_1d<Spack> &uw_sec,
+      const uview_1d<Spack> &vw_sec, const uview_1d<Spack> &wtke_sec, const uview_1d<Spack> &w_sec);
 
   KOKKOS_FUNCTION
   static void diag_second_shoc_moments(
-      const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &thl2tune, const Scalar &qw2tune,
-      const Scalar &qwthl2tune, const Scalar &w2tune, const uview_1d<const Spack> &thetal,
-      const uview_1d<const Spack> &qw, const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind,
-      const uview_1d<const Spack> &tke, const uview_1d<const Spack> &isotropy, const uview_1d<const Spack> &tkh,
-      const uview_1d<const Spack> &tk, const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &zt_grid,
-      const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &shoc_mix, const Scalar &wthl_sfc,
-      const Scalar &wqw_sfc, const Scalar &uw_sfc, const Scalar &vw_sfc, Scalar &ustar2, Scalar &wstar,
-      const Workspace &workspace, const uview_1d<Spack> &thl_sec, const uview_1d<Spack> &qw_sec,
-      const uview_1d<Spack> &wthl_sec, const uview_1d<Spack> &wqw_sec, const uview_1d<Spack> &qwthl_sec,
+      const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &thl2tune,
+      const Scalar &qw2tune, const Scalar &qwthl2tune, const Scalar &w2tune,
+      const uview_1d<const Spack> &thetal, const uview_1d<const Spack> &qw,
+      const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind,
+      const uview_1d<const Spack> &tke, const uview_1d<const Spack> &isotropy,
+      const uview_1d<const Spack> &tkh, const uview_1d<const Spack> &tk,
+      const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &zt_grid,
+      const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &shoc_mix,
+      const Scalar &wthl_sfc, const Scalar &wqw_sfc, const Scalar &uw_sfc, const Scalar &vw_sfc,
+      Scalar &ustar2, Scalar &wstar, const Workspace &workspace, const uview_1d<Spack> &thl_sec,
+      const uview_1d<Spack> &qw_sec, const uview_1d<Spack> &wthl_sec,
+      const uview_1d<Spack> &wqw_sec, const uview_1d<Spack> &qwthl_sec,
       const uview_1d<Spack> &uw_sec, const uview_1d<Spack> &vw_sec, const uview_1d<Spack> &wtke_sec,
       const uview_1d<Spack> &w_sec);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
   static void diag_second_shoc_moments_disp(
-      const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &thl2tune, const Scalar &qw2tune,
-      const Scalar &qwthl2tune, const Scalar &w2tune, const view_2d<const Spack> &thetal,
-      const view_2d<const Spack> &qw, const view_2d<const Spack> &u_wind, const view_2d<const Spack> &v_wind,
-      const view_2d<const Spack> &tke, const view_2d<const Spack> &isotropy, const view_2d<const Spack> &tkh,
-      const view_2d<const Spack> &tk, const view_2d<const Spack> &dz_zi, const view_2d<const Spack> &zt_grid,
-      const view_2d<const Spack> &zi_grid, const view_2d<const Spack> &shoc_mix, const view_1d<const Scalar> &wthl_sfc,
-      const view_1d<const Scalar> &wqw_sfc, const view_1d<const Scalar> &uw_sfc, const view_1d<const Scalar> &vw_sfc,
-      const view_1d<Scalar> &ustar2, const view_1d<Scalar> &wstar, const WorkspaceMgr &workspace_mgr,
-      const view_2d<Spack> &thl_sec, const view_2d<Spack> &qw_sec, const view_2d<Spack> &wthl_sec,
-      const view_2d<Spack> &wqw_sec, const view_2d<Spack> &qwthl_sec, const view_2d<Spack> &uw_sec,
-      const view_2d<Spack> &vw_sec, const view_2d<Spack> &wtke_sec, const view_2d<Spack> &w_sec);
+      const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &thl2tune,
+      const Scalar &qw2tune, const Scalar &qwthl2tune, const Scalar &w2tune,
+      const view_2d<const Spack> &thetal, const view_2d<const Spack> &qw,
+      const view_2d<const Spack> &u_wind, const view_2d<const Spack> &v_wind,
+      const view_2d<const Spack> &tke, const view_2d<const Spack> &isotropy,
+      const view_2d<const Spack> &tkh, const view_2d<const Spack> &tk,
+      const view_2d<const Spack> &dz_zi, const view_2d<const Spack> &zt_grid,
+      const view_2d<const Spack> &zi_grid, const view_2d<const Spack> &shoc_mix,
+      const view_1d<const Scalar> &wthl_sfc, const view_1d<const Scalar> &wqw_sfc,
+      const view_1d<const Scalar> &uw_sfc, const view_1d<const Scalar> &vw_sfc,
+      const view_1d<Scalar> &ustar2, const view_1d<Scalar> &wstar,
+      const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &thl_sec,
+      const view_2d<Spack> &qw_sec, const view_2d<Spack> &wthl_sec, const view_2d<Spack> &wqw_sec,
+      const view_2d<Spack> &qwthl_sec, const view_2d<Spack> &uw_sec, const view_2d<Spack> &vw_sec,
+      const view_2d<Spack> &wtke_sec, const view_2d<Spack> &w_sec);
 #endif
 
   KOKKOS_FUNCTION
   static void compute_brunt_shoc_length(const MemberType &team, const Int &nlev, const Int &nlevi,
-                                        const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &thv,
-                                        const uview_1d<const Spack> &thv_zi, const uview_1d<Spack> &brunt);
+                                        const uview_1d<const Spack> &dz_zt,
+                                        const uview_1d<const Spack> &thv,
+                                        const uview_1d<const Spack> &thv_zi,
+                                        const uview_1d<Spack> &brunt);
 
   KOKKOS_FUNCTION
-  static void compute_l_inf_shoc_length(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &zt_grid,
-                                        const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &tke,
-                                        Scalar &l_inf);
+  static void compute_l_inf_shoc_length(const MemberType &team, const Int &nlev,
+                                        const uview_1d<const Spack> &zt_grid,
+                                        const uview_1d<const Spack> &dz_zt,
+                                        const uview_1d<const Spack> &tke, Scalar &l_inf);
 
   KOKKOS_FUNCTION
-  static void check_length_scale_shoc_length(const MemberType &team, const Int &nlev, const Scalar &dx,
-                                             const Scalar &dy, const uview_1d<Spack> &shoc_mix);
+  static void check_length_scale_shoc_length(const MemberType &team, const Int &nlev,
+                                             const Scalar &dx, const Scalar &dy,
+                                             const uview_1d<Spack> &shoc_mix);
 
   KOKKOS_FUNCTION
   static void shoc_diag_obklen(const Scalar &uw_sfc, const Scalar &vw_sfc, const Scalar &wthl_sfc,
-                               const Scalar &wqw_sfc, const Scalar &thl_sfc, const Scalar &cldliq_sfc,
-                               const Scalar &qv_sfc, Scalar &ustar, Scalar &kbfs, Scalar &obklen);
+                               const Scalar &wqw_sfc, const Scalar &thl_sfc,
+                               const Scalar &cldliq_sfc, const Scalar &qv_sfc, Scalar &ustar,
+                               Scalar &kbfs, Scalar &obklen);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void shoc_diag_obklen_disp(const Int &shcol, const Int &nlev, const view_1d<const Scalar> &uw_sfc,
-                                    const view_1d<const Scalar> &vw_sfc, const view_1d<const Scalar> &wthl_sfc,
-                                    const view_1d<const Scalar> &wqw_sfc, const view_2d<const Scalar> &thl_sfc,
-                                    const view_2d<const Scalar> &cldliq_sfc, const view_2d<const Scalar> &qv_sfc,
-                                    const view_1d<Scalar> &ustar, const view_1d<Scalar> &kbfs,
-                                    const view_1d<Scalar> &obklen);
+  static void
+  shoc_diag_obklen_disp(const Int &shcol, const Int &nlev, const view_1d<const Scalar> &uw_sfc,
+                        const view_1d<const Scalar> &vw_sfc, const view_1d<const Scalar> &wthl_sfc,
+                        const view_1d<const Scalar> &wqw_sfc, const view_2d<const Scalar> &thl_sfc,
+                        const view_2d<const Scalar> &cldliq_sfc,
+                        const view_2d<const Scalar> &qv_sfc, const view_1d<Scalar> &ustar,
+                        const view_1d<Scalar> &kbfs, const view_1d<Scalar> &obklen);
 #endif
 
   KOKKOS_FUNCTION
   static void shoc_pblintd_cldcheck(const Scalar &zi, const Scalar &cldn, Scalar &pblh);
 
   KOKKOS_FUNCTION
-  static void shoc_length(const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &length_fac,
-                          const Scalar &dx, const Scalar &dy, const uview_1d<const Spack> &zt_grid,
+  static void shoc_length(const MemberType &team, const Int &nlev, const Int &nlevi,
+                          const Scalar &length_fac, const Scalar &dx, const Scalar &dy,
+                          const uview_1d<const Spack> &zt_grid,
                           const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &dz_zt,
                           const uview_1d<const Spack> &tke, const uview_1d<const Spack> &thv,
-                          const Workspace &workspace, const uview_1d<Spack> &brunt, const uview_1d<Spack> &shoc_mix);
+                          const Workspace &workspace, const uview_1d<Spack> &brunt,
+                          const uview_1d<Spack> &shoc_mix);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void shoc_length_disp(const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &length_fac,
-                               const view_1d<const Scalar> &dx, const view_1d<const Scalar> &dy,
-                               const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
+  static void shoc_length_disp(const Int &shcol, const Int &nlev, const Int &nlevi,
+                               const Scalar &length_fac, const view_1d<const Scalar> &dx,
+                               const view_1d<const Scalar> &dy, const view_2d<const Spack> &zt_grid,
+                               const view_2d<const Spack> &zi_grid,
                                const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &tke,
                                const view_2d<const Spack> &thv, const WorkspaceMgr &workspace_mgr,
                                const view_2d<Spack> &brunt, const view_2d<Spack> &shoc_mix);
 #endif
 
   KOKKOS_FUNCTION
-  static void shoc_energy_fixer(const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &dtime,
-                                const Int &nadv, const uview_1d<const Spack> &zt_grid,
-                                const uview_1d<const Spack> &zi_grid, const Scalar &se_b, const Scalar &ke_b,
-                                const Scalar &wv_b, const Scalar &wl_b, const Scalar &se_a, const Scalar &ke_a,
-                                const Scalar &wv_a, const Scalar &wl_a, const Scalar &wthl_sfc, const Scalar &wqw_sfc,
-                                const uview_1d<const Spack> &rho_zt, const uview_1d<const Spack> &tke,
-                                const uview_1d<const Spack> &pint, const Workspace &workspace,
-                                const uview_1d<Spack> &host_dse);
+  static void shoc_energy_fixer(const MemberType &team, const Int &nlev, const Int &nlevi,
+                                const Scalar &dtime, const Int &nadv,
+                                const uview_1d<const Spack> &zt_grid,
+                                const uview_1d<const Spack> &zi_grid, const Scalar &se_b,
+                                const Scalar &ke_b, const Scalar &wv_b, const Scalar &wl_b,
+                                const Scalar &se_a, const Scalar &ke_a, const Scalar &wv_a,
+                                const Scalar &wl_a, const Scalar &wthl_sfc, const Scalar &wqw_sfc,
+                                const uview_1d<const Spack> &rho_zt,
+                                const uview_1d<const Spack> &tke, const uview_1d<const Spack> &pint,
+                                const Workspace &workspace, const uview_1d<Spack> &host_dse);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void shoc_energy_fixer_disp(const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &dtime,
-                                     const Int &nadv, const view_2d<const Spack> &zt_grid,
-                                     const view_2d<const Spack> &zi_grid, const view_1d<const Scalar> &se_b,
-                                     const view_1d<const Scalar> &ke_b, const view_1d<const Scalar> &wv_b,
-                                     const view_1d<const Scalar> &wl_b, const view_1d<const Scalar> &se_a,
-                                     const view_1d<const Scalar> &ke_a, const view_1d<const Scalar> &wv_a,
-                                     const view_1d<const Scalar> &wl_a, const view_1d<const Scalar> &wthl_sfc,
-                                     const view_1d<const Scalar> &wqw_sfc, const view_2d<const Spack> &rho_zt,
-                                     const view_2d<const Spack> &tke, const view_2d<const Spack> &pint,
-                                     const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &host_dse);
+  static void
+  shoc_energy_fixer_disp(const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &dtime,
+                         const Int &nadv, const view_2d<const Spack> &zt_grid,
+                         const view_2d<const Spack> &zi_grid, const view_1d<const Scalar> &se_b,
+                         const view_1d<const Scalar> &ke_b, const view_1d<const Scalar> &wv_b,
+                         const view_1d<const Scalar> &wl_b, const view_1d<const Scalar> &se_a,
+                         const view_1d<const Scalar> &ke_a, const view_1d<const Scalar> &wv_a,
+                         const view_1d<const Scalar> &wl_a, const view_1d<const Scalar> &wthl_sfc,
+                         const view_1d<const Scalar> &wqw_sfc, const view_2d<const Spack> &rho_zt,
+                         const view_2d<const Spack> &tke, const view_2d<const Spack> &pint,
+                         const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &host_dse);
 #endif
 
   KOKKOS_FUNCTION
-  static void compute_shoc_vapor(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &qw,
-                                 const uview_1d<const Spack> &ql, const uview_1d<Spack> &qv);
+  static void compute_shoc_vapor(const MemberType &team, const Int &nlev,
+                                 const uview_1d<const Spack> &qw, const uview_1d<const Spack> &ql,
+                                 const uview_1d<Spack> &qv);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void compute_shoc_vapor_disp(const Int &shcol, const Int &nlev, const view_2d<const Spack> &qw,
+  static void compute_shoc_vapor_disp(const Int &shcol, const Int &nlev,
+                                      const view_2d<const Spack> &qw,
                                       const view_2d<const Spack> &ql, const view_2d<Spack> &qv);
 #endif
 
   KOKKOS_FUNCTION
-  static void compute_shoc_temperature(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &thetal,
-                                       const uview_1d<const Spack> &ql, const uview_1d<const Spack> &inv_exner,
+  static void compute_shoc_temperature(const MemberType &team, const Int &nlev,
+                                       const uview_1d<const Spack> &thetal,
+                                       const uview_1d<const Spack> &ql,
+                                       const uview_1d<const Spack> &inv_exner,
                                        const uview_1d<Spack> &tabs);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void compute_shoc_temperature_disp(const Int &shcol, const Int &nlev, const view_2d<const Spack> &thetal,
-                                            const view_2d<const Spack> &ql, const view_2d<const Spack> &inv_exner,
+  static void compute_shoc_temperature_disp(const Int &shcol, const Int &nlev,
+                                            const view_2d<const Spack> &thetal,
+                                            const view_2d<const Spack> &ql,
+                                            const view_2d<const Spack> &inv_exner,
                                             const view_2d<Spack> &tabs);
 #endif
 
   KOKKOS_FUNCTION
   static void update_prognostics_implicit(
-      const MemberType &team, const Int &nlev, const Int &nlevi, const Int &num_tracer, const Scalar &dtime,
-      const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &rho_zt,
-      const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &tk,
-      const uview_1d<const Spack> &tkh, const Scalar &uw_sfc, const Scalar &vw_sfc, const Scalar &wthl_sfc,
-      const Scalar &wqw_sfc, const uview_1d<const Spack> &wtracer_sfc, const Workspace &workspace,
-      const uview_1d<Spack> &thetal, const uview_1d<Spack> &qw, const uview_2d_strided<Spack> &tracer,
-      const uview_1d<Spack> &tke, const uview_1d<Spack> &u_wind, const uview_1d<Spack> &v_wind);
+      const MemberType &team, const Int &nlev, const Int &nlevi, const Int &num_tracer,
+      const Scalar &dtime, const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &dz_zi,
+      const uview_1d<const Spack> &rho_zt, const uview_1d<const Spack> &zt_grid,
+      const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &tk,
+      const uview_1d<const Spack> &tkh, const Scalar &uw_sfc, const Scalar &vw_sfc,
+      const Scalar &wthl_sfc, const Scalar &wqw_sfc, const uview_1d<const Spack> &wtracer_sfc,
+      const Workspace &workspace, const uview_1d<Spack> &thetal, const uview_1d<Spack> &qw,
+      const uview_2d_strided<Spack> &tracer, const uview_1d<Spack> &tke,
+      const uview_1d<Spack> &u_wind, const uview_1d<Spack> &v_wind);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
   static void update_prognostics_implicit_disp(
-      const Int &shcol, const Int &nlev, const Int &nlevi, const Int &num_tracer, const Scalar &dtime,
-      const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &dz_zi, const view_2d<const Spack> &rho_zt,
-      const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid, const view_2d<const Spack> &tk,
-      const view_2d<const Spack> &tkh, const view_1d<const Scalar> &uw_sfc, const view_1d<const Scalar> &vw_sfc,
-      const view_1d<const Scalar> &wthl_sfc, const view_1d<const Scalar> &wqw_sfc,
-      const view_2d<const Spack> &wtracer_sfc, const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &thetal,
-      const view_2d<Spack> &qw, const view_3d_strided<Spack> &tracer, const view_2d<Spack> &tke,
-      const view_2d<Spack> &u_wind, const view_2d<Spack> &v_wind);
+      const Int &shcol, const Int &nlev, const Int &nlevi, const Int &num_tracer,
+      const Scalar &dtime, const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &dz_zi,
+      const view_2d<const Spack> &rho_zt, const view_2d<const Spack> &zt_grid,
+      const view_2d<const Spack> &zi_grid, const view_2d<const Spack> &tk,
+      const view_2d<const Spack> &tkh, const view_1d<const Scalar> &uw_sfc,
+      const view_1d<const Scalar> &vw_sfc, const view_1d<const Scalar> &wthl_sfc,
+      const view_1d<const Scalar> &wqw_sfc, const view_2d<const Spack> &wtracer_sfc,
+      const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &thetal, const view_2d<Spack> &qw,
+      const view_3d_strided<Spack> &tracer, const view_2d<Spack> &tke, const view_2d<Spack> &u_wind,
+      const view_2d<Spack> &v_wind);
 #endif
 
   KOKKOS_FUNCTION
-  static void diag_third_shoc_moments(const MemberType &team, const Int &nlev, const Int &nlevi,
-                                      const Scalar &c_diag_3rd_mom, const uview_1d<const Spack> &w_sec,
-                                      const uview_1d<const Spack> &thl_sec, const uview_1d<const Spack> &wthl_sec,
-                                      const uview_1d<const Spack> &isotropy, const uview_1d<const Spack> &brunt,
-                                      const uview_1d<const Spack> &thetal, const uview_1d<const Spack> &tke,
-                                      const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &dz_zi,
-                                      const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid,
-                                      const Workspace &workspace, const uview_1d<Spack> &w3);
+  static void diag_third_shoc_moments(
+      const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &c_diag_3rd_mom,
+      const uview_1d<const Spack> &w_sec, const uview_1d<const Spack> &thl_sec,
+      const uview_1d<const Spack> &wthl_sec, const uview_1d<const Spack> &isotropy,
+      const uview_1d<const Spack> &brunt, const uview_1d<const Spack> &thetal,
+      const uview_1d<const Spack> &tke, const uview_1d<const Spack> &dz_zt,
+      const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &zt_grid,
+      const uview_1d<const Spack> &zi_grid, const Workspace &workspace, const uview_1d<Spack> &w3);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void diag_third_shoc_moments_disp(const Int &shcol, const Int &nlev, const Int &nlevi,
-                                           const Scalar &c_diag_3rd_mom, const view_2d<const Spack> &w_sec,
-                                           const view_2d<const Spack> &thl_sec, const view_2d<const Spack> &wthl_sec,
-                                           const view_2d<const Spack> &isotropy, const view_2d<const Spack> &brunt,
-                                           const view_2d<const Spack> &thetal, const view_2d<const Spack> &tke,
-                                           const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &dz_zi,
-                                           const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
-                                           const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &w3);
+  static void diag_third_shoc_moments_disp(
+      const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &c_diag_3rd_mom,
+      const view_2d<const Spack> &w_sec, const view_2d<const Spack> &thl_sec,
+      const view_2d<const Spack> &wthl_sec, const view_2d<const Spack> &isotropy,
+      const view_2d<const Spack> &brunt, const view_2d<const Spack> &thetal,
+      const view_2d<const Spack> &tke, const view_2d<const Spack> &dz_zt,
+      const view_2d<const Spack> &dz_zi, const view_2d<const Spack> &zt_grid,
+      const view_2d<const Spack> &zi_grid, const WorkspaceMgr &workspace_mgr,
+      const view_2d<Spack> &w3);
 #endif
 
   KOKKOS_FUNCTION
   static void adv_sgs_tke(const MemberType &team, const Int &nlev, const Real &dtime,
-                          const uview_1d<const Spack> &shoc_mix, const uview_1d<const Spack> &wthv_sec,
+                          const uview_1d<const Spack> &shoc_mix,
+                          const uview_1d<const Spack> &wthv_sec,
                           const uview_1d<const Spack> &sterm_zt, const uview_1d<const Spack> &tk,
                           const uview_1d<Spack> &tke, const uview_1d<Spack> &a_diss);
 
   KOKKOS_FUNCTION
-  static void shoc_assumed_pdf(
-      const MemberType &team, const Int &nlev, const Int &nlevi, const uview_1d<const Spack> &thetal,
-      const uview_1d<const Spack> &qw, const uview_1d<const Spack> &w_field, const uview_1d<const Spack> &thl_sec,
-      const uview_1d<const Spack> &qw_sec, const uview_1d<const Spack> &wthl_sec, const uview_1d<const Spack> &w_sec,
-      const uview_1d<const Spack> &wqw_sec, const uview_1d<const Spack> &qwthl_sec, const uview_1d<const Spack> &w3,
-      const uview_1d<const Spack> &pres, const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid,
-      const Workspace &workspace, const uview_1d<Spack> &shoc_cldfrac, const uview_1d<Spack> &shoc_ql,
-      const uview_1d<Spack> &wqls, const uview_1d<Spack> &wthv_sec, const uview_1d<Spack> &shoc_ql2);
+  static void
+  shoc_assumed_pdf(const MemberType &team, const Int &nlev, const Int &nlevi,
+                   const uview_1d<const Spack> &thetal, const uview_1d<const Spack> &qw,
+                   const uview_1d<const Spack> &w_field, const uview_1d<const Spack> &thl_sec,
+                   const uview_1d<const Spack> &qw_sec, const uview_1d<const Spack> &wthl_sec,
+                   const uview_1d<const Spack> &w_sec, const uview_1d<const Spack> &wqw_sec,
+                   const uview_1d<const Spack> &qwthl_sec, const uview_1d<const Spack> &w3,
+                   const uview_1d<const Spack> &pres, const uview_1d<const Spack> &zt_grid,
+                   const uview_1d<const Spack> &zi_grid, const Workspace &workspace,
+                   const uview_1d<Spack> &shoc_cldfrac, const uview_1d<Spack> &shoc_ql,
+                   const uview_1d<Spack> &wqls, const uview_1d<Spack> &wthv_sec,
+                   const uview_1d<Spack> &shoc_ql2);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void shoc_assumed_pdf_disp(
-      const Int &shcol, const Int &nlev, const Int &nlevi, const view_2d<const Spack> &thetal,
-      const view_2d<const Spack> &qw, const view_2d<const Spack> &w_field, const view_2d<const Spack> &thl_sec,
-      const view_2d<const Spack> &qw_sec, const view_2d<const Spack> &wthl_sec, const view_2d<const Spack> &w_sec,
-      const view_2d<const Spack> &wqw_sec, const view_2d<const Spack> &qwthl_sec, const view_2d<const Spack> &w3,
-      const view_2d<const Spack> &pres, const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
-      const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &shoc_cldfrac, const view_2d<Spack> &shoc_ql,
-      const view_2d<Spack> &wqls, const view_2d<Spack> &wthv_sec, const view_2d<Spack> &shoc_ql2);
+  static void
+  shoc_assumed_pdf_disp(const Int &shcol, const Int &nlev, const Int &nlevi,
+                        const view_2d<const Spack> &thetal, const view_2d<const Spack> &qw,
+                        const view_2d<const Spack> &w_field, const view_2d<const Spack> &thl_sec,
+                        const view_2d<const Spack> &qw_sec, const view_2d<const Spack> &wthl_sec,
+                        const view_2d<const Spack> &w_sec, const view_2d<const Spack> &wqw_sec,
+                        const view_2d<const Spack> &qwthl_sec, const view_2d<const Spack> &w3,
+                        const view_2d<const Spack> &pres, const view_2d<const Spack> &zt_grid,
+                        const view_2d<const Spack> &zi_grid, const WorkspaceMgr &workspace_mgr,
+                        const view_2d<Spack> &shoc_cldfrac, const view_2d<Spack> &shoc_ql,
+                        const view_2d<Spack> &wqls, const view_2d<Spack> &wthv_sec,
+                        const view_2d<Spack> &shoc_ql2);
 #endif
 
   KOKKOS_INLINE_FUNCTION
-  static void shoc_assumed_pdf_compute_buoyancy_flux(const Spack &wthlsec, const Spack &wqwsec, const Spack &pval,
-                                                     const Spack &wqls, Spack &wthv_sec);
+  static void shoc_assumed_pdf_compute_buoyancy_flux(const Spack &wthlsec, const Spack &wqwsec,
+                                                     const Spack &pval, const Spack &wqls,
+                                                     Spack &wthv_sec);
 
   KOKKOS_INLINE_FUNCTION
-  static void shoc_assumed_pdf_compute_cloud_liquid_variance(const Spack &a, const Spack &s1, const Spack &ql1,
-                                                             const Spack &C1, const Spack &std_s1, const Spack &s2,
-                                                             const Spack &ql2, const Spack &C2, const Spack &std_s2,
+  static void shoc_assumed_pdf_compute_cloud_liquid_variance(const Spack &a, const Spack &s1,
+                                                             const Spack &ql1, const Spack &C1,
+                                                             const Spack &std_s1, const Spack &s2,
+                                                             const Spack &ql2, const Spack &C2,
+                                                             const Spack &std_s2,
                                                              const Spack &shoc_ql, Spack &shoc_ql2);
 
   KOKKOS_INLINE_FUNCTION
-  static void shoc_assumed_pdf_compute_liquid_water_flux(const Spack &a, const Spack &w1_1, const Spack &w_first,
-                                                         const Spack &ql1, const Spack &w1_2, const Spack &ql2,
+  static void shoc_assumed_pdf_compute_liquid_water_flux(const Spack &a, const Spack &w1_1,
+                                                         const Spack &w_first, const Spack &ql1,
+                                                         const Spack &w1_2, const Spack &ql2,
                                                          Spack &wqls);
 
   KOKKOS_INLINE_FUNCTION
   static void shoc_assumed_pdf_compute_qs(const Spack &Tl1_1, const Spack &Tl1_2, const Spack &pval,
-                                          const Smask &active_entries, Spack &qs1, Spack &beta1, Spack &qs2,
-                                          Spack &beta2);
+                                          const Smask &active_entries, Spack &qs1, Spack &beta1,
+                                          Spack &qs2, Spack &beta2);
 
   KOKKOS_INLINE_FUNCTION
-  static void shoc_assumed_pdf_compute_s(const Spack &qw1, const Spack &qs, const Spack &beta, const Spack &pval,
-                                         const Spack &thl2, const Spack &qw2, const Spack &sqrtthl2,
-                                         const Spack &sqrtqw2, const Spack &r_qwthl, Spack &s, Spack &std_s, Spack &qn,
+  static void shoc_assumed_pdf_compute_s(const Spack &qw1, const Spack &qs, const Spack &beta,
+                                         const Spack &pval, const Spack &thl2, const Spack &qw2,
+                                         const Spack &sqrtthl2, const Spack &sqrtqw2,
+                                         const Spack &r_qwthl, Spack &s, Spack &std_s, Spack &qn,
                                          Spack &C);
 
   KOKKOS_INLINE_FUNCTION
-  static void shoc_assumed_pdf_compute_sgs_liquid(const Spack &a, const Spack &ql1, const Spack &ql2, Spack &shoc_ql);
+  static void shoc_assumed_pdf_compute_sgs_liquid(const Spack &a, const Spack &ql1,
+                                                  const Spack &ql2, Spack &shoc_ql);
 
   KOKKOS_INLINE_FUNCTION
-  static void shoc_assumed_pdf_compute_temperature(const Spack &thl1, const Spack &pval, Spack &Tl1);
+  static void shoc_assumed_pdf_compute_temperature(const Spack &thl1, const Spack &pval,
+                                                   Spack &Tl1);
 
   KOKKOS_INLINE_FUNCTION
-  static void shoc_assumed_pdf_inplume_correlations(const Spack &sqrtqw2_1, const Spack &sqrtthl2_1, const Spack &a,
-                                                    const Spack &sqrtqw2_2, const Spack &sqrtthl2_2,
-                                                    const Spack &qwthlsec, const Spack &qw1_1, const Spack &qw_first,
-                                                    const Spack &thl1_1, const Spack &thl_first, const Spack &qw1_2,
-                                                    const Spack &thl1_2, Spack &r_qwthl_1);
+  static void shoc_assumed_pdf_inplume_correlations(const Spack &sqrtqw2_1, const Spack &sqrtthl2_1,
+                                                    const Spack &a, const Spack &sqrtqw2_2,
+                                                    const Spack &sqrtthl2_2, const Spack &qwthlsec,
+                                                    const Spack &qw1_1, const Spack &qw_first,
+                                                    const Spack &thl1_1, const Spack &thl_first,
+                                                    const Spack &qw1_2, const Spack &thl1_2,
+                                                    Spack &r_qwthl_1);
 
   KOKKOS_INLINE_FUNCTION
-  static void shoc_assumed_pdf_qw_parameters(const Spack &wqwsec, const Spack &sqrtw2, const Spack &Skew_w,
-                                             const Spack &sqrtqt, const Spack &qwsec, const Spack &w1_2,
-                                             const Spack &w1_1, const Spack &qw_first, const Spack &a,
-                                             const Scalar rt_tol, const Scalar w_thresh, Spack &qw1_1, Spack &qw1_2,
-                                             Spack &qw2_1, Spack &qw2_2, Spack &sqrtqw2_1, Spack &sqrtqw2_2);
+  static void shoc_assumed_pdf_qw_parameters(
+      const Spack &wqwsec, const Spack &sqrtw2, const Spack &Skew_w, const Spack &sqrtqt,
+      const Spack &qwsec, const Spack &w1_2, const Spack &w1_1, const Spack &qw_first,
+      const Spack &a, const Scalar rt_tol, const Scalar w_thresh, Spack &qw1_1, Spack &qw1_2,
+      Spack &qw2_1, Spack &qw2_2, Spack &sqrtqw2_1, Spack &sqrtqw2_2);
 
   KOKKOS_INLINE_FUNCTION
-  static void shoc_assumed_pdf_thl_parameters(const Spack &wthlsec, const Spack &sqrtw2, const Spack &sqrtthl,
-                                              const Spack &thlsec, const Spack &thl_first, const Spack &w1_1,
-                                              const Spack &w1_2, const Spack &Skew_w, const Spack &a,
-                                              const Scalar thl_tol, const Scalar w_thresh, Spack &thl1_1, Spack &thl1_2,
-                                              Spack &thl2_1, Spack &thl2_2, Spack &sqrtthl2_1, Spack &sqrtthl2_2);
+  static void shoc_assumed_pdf_thl_parameters(
+      const Spack &wthlsec, const Spack &sqrtw2, const Spack &sqrtthl, const Spack &thlsec,
+      const Spack &thl_first, const Spack &w1_1, const Spack &w1_2, const Spack &Skew_w,
+      const Spack &a, const Scalar thl_tol, const Scalar w_thresh, Spack &thl1_1, Spack &thl1_2,
+      Spack &thl2_1, Spack &thl2_2, Spack &sqrtthl2_1, Spack &sqrtthl2_2);
 
   KOKKOS_INLINE_FUNCTION
   static void shoc_assumed_pdf_tilde_to_real(const Spack &w_first, const Spack &sqrtw2, Spack &w1);
 
   KOKKOS_INLINE_FUNCTION
-  static void shoc_assumed_pdf_vv_parameters(const Spack &w_first, const Spack &w_sec, const Spack &w3var,
-                                             const Scalar w_tol_sqd, Spack &Skew_w, Spack &w1_1, Spack &w1_2,
-                                             Spack &w2_1, Spack &w2_2, Spack &a);
+  static void shoc_assumed_pdf_vv_parameters(const Spack &w_first, const Spack &w_sec,
+                                             const Spack &w3var, const Scalar w_tol_sqd,
+                                             Spack &Skew_w, Spack &w1_1, Spack &w1_2, Spack &w2_1,
+                                             Spack &w2_2, Spack &a);
 
   KOKKOS_FUNCTION
   static void compute_shr_prod(const MemberType &team, const Int &nlevi, const Int &nlev,
-                               const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &u_wind,
+                               const uview_1d<const Spack> &dz_zi,
+                               const uview_1d<const Spack> &u_wind,
                                const uview_1d<const Spack> &v_wind, const uview_1d<Spack> &sterm);
 
   KOKKOS_FUNCTION
@@ -577,21 +652,25 @@ template <typename ScalarT, typename DeviceT> struct Functions {
                            const uview_1d<Spack> &tmpi);
 
   KOKKOS_FUNCTION
-  static void integ_column_stability(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &dz_zt,
-                                     const uview_1d<const Spack> &pres, const uview_1d<const Spack> &brunt,
-                                     Scalar &brunt_int);
+  static void integ_column_stability(const MemberType &team, const Int &nlev,
+                                     const uview_1d<const Spack> &dz_zt,
+                                     const uview_1d<const Spack> &pres,
+                                     const uview_1d<const Spack> &brunt, Scalar &brunt_int);
 
   KOKKOS_FUNCTION
-  static void isotropic_ts(const MemberType &team, const Int &nlev, const Scalar &lambda_low, const Scalar &lambda_high,
-                           const Scalar &lambda_slope, const Scalar &lambda_thresh, const Scalar &brunt_int,
+  static void isotropic_ts(const MemberType &team, const Int &nlev, const Scalar &lambda_low,
+                           const Scalar &lambda_high, const Scalar &lambda_slope,
+                           const Scalar &lambda_thresh, const Scalar &brunt_int,
                            const uview_1d<const Spack> &tke, const uview_1d<const Spack> &a_diss,
                            const uview_1d<const Spack> &brunt, const uview_1d<Spack> &isotropy);
 
   KOKKOS_FUNCTION
-  static void dp_inverse(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &rho_zt,
-                         const uview_1d<const Spack> &dz_zt, const uview_1d<Spack> &rdp_zt);
+  static void dp_inverse(const MemberType &team, const Int &nlev,
+                         const uview_1d<const Spack> &rho_zt, const uview_1d<const Spack> &dz_zt,
+                         const uview_1d<Spack> &rdp_zt);
 
-  static Int shoc_init(const Int &nbot_shoc, const Int &ntop_shoc, const view_1d<const Spack> &pref_mid);
+  static Int shoc_init(const Int &nbot_shoc, const Int &ntop_shoc,
+                       const view_1d<const Spack> &pref_mid);
 
 #ifndef SCREAM_SHOC_SMALL_KERNELS
   KOKKOS_FUNCTION
@@ -604,30 +683,36 @@ template <typename ScalarT, typename DeviceT> struct Functions {
       const Int &num_qtracers, // Number of tracers
       const Scalar &dtime,     // SHOC timestep [s]
       // Runtime Parameters
-      const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope, const Scalar &lambda_thresh,
-      const Scalar &thl2tune, const Scalar &qw2tune, const Scalar &qwthl2tune, const Scalar &w2tune,
-      const Scalar &length_fac, const Scalar &c_diag_3rd_mom, const Scalar &Ckh, const Scalar &Ckm,
+      const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope,
+      const Scalar &lambda_thresh, const Scalar &thl2tune, const Scalar &qw2tune,
+      const Scalar &qwthl2tune, const Scalar &w2tune, const Scalar &length_fac,
+      const Scalar &c_diag_3rd_mom, const Scalar &Ckh, const Scalar &Ckm,
       // Input Variables
       const Scalar &host_dx, const Scalar &host_dy, const uview_1d<const Spack> &zt_grid,
-      const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &pres, const uview_1d<const Spack> &presi,
-      const uview_1d<const Spack> &pdel, const uview_1d<const Spack> &thv, const uview_1d<const Spack> &w_field,
+      const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &pres,
+      const uview_1d<const Spack> &presi, const uview_1d<const Spack> &pdel,
+      const uview_1d<const Spack> &thv, const uview_1d<const Spack> &w_field,
       const Scalar &wthl_sfc, const Scalar &wqw_sfc, const Scalar &uw_sfc, const Scalar &vw_sfc,
-      const uview_1d<const Spack> &wtracer_sfc, const uview_1d<const Spack> &inv_exner, const Scalar &phis,
+      const uview_1d<const Spack> &wtracer_sfc, const uview_1d<const Spack> &inv_exner,
+      const Scalar &phis,
       // Local Workspace
       const Workspace &workspace,
       // Input/Output Variables
       const uview_1d<Spack> &host_dse, const uview_1d<Spack> &tke, const uview_1d<Spack> &thetal,
       const uview_1d<Spack> &qw, const uview_1d<Spack> &u_wind, const uview_1d<Spack> &v_wind,
-      const uview_1d<Spack> &wthv_sec, const uview_2d_strided<Spack> &qtracers, const uview_1d<Spack> &tk,
-      const uview_1d<Spack> &shoc_cldfrac, const uview_1d<Spack> &shoc_ql,
+      const uview_1d<Spack> &wthv_sec, const uview_2d_strided<Spack> &qtracers,
+      const uview_1d<Spack> &tk, const uview_1d<Spack> &shoc_cldfrac,
+      const uview_1d<Spack> &shoc_ql,
       // Output Variables
-      Scalar &pblh, Scalar &ustar, Scalar &obklen, const uview_1d<Spack> &shoc_ql2, const uview_1d<Spack> &tkh,
+      Scalar &pblh, Scalar &ustar, Scalar &obklen, const uview_1d<Spack> &shoc_ql2,
+      const uview_1d<Spack> &tkh,
       // Diagnostic Output Variables
       const uview_1d<Spack> &shoc_mix, const uview_1d<Spack> &w_sec, const uview_1d<Spack> &thl_sec,
-      const uview_1d<Spack> &qw_sec, const uview_1d<Spack> &qwthl_sec, const uview_1d<Spack> &wthl_sec,
-      const uview_1d<Spack> &wqw_sec, const uview_1d<Spack> &wtke_sec, const uview_1d<Spack> &uw_sec,
-      const uview_1d<Spack> &vw_sec, const uview_1d<Spack> &w3, const uview_1d<Spack> &wqls_sec,
-      const uview_1d<Spack> &brunt, const uview_1d<Spack> &isotropy);
+      const uview_1d<Spack> &qw_sec, const uview_1d<Spack> &qwthl_sec,
+      const uview_1d<Spack> &wthl_sec, const uview_1d<Spack> &wqw_sec,
+      const uview_1d<Spack> &wtke_sec, const uview_1d<Spack> &uw_sec, const uview_1d<Spack> &vw_sec,
+      const uview_1d<Spack> &w3, const uview_1d<Spack> &wqls_sec, const uview_1d<Spack> &brunt,
+      const uview_1d<Spack> &isotropy);
 #else
   static void shoc_main_internal(
       const Int &shcol,        // Number of columns
@@ -638,23 +723,26 @@ template <typename ScalarT, typename DeviceT> struct Functions {
       const Int &num_qtracers, // Number of tracers
       const Scalar &dtime,     // SHOC timestep [s]
       // Runtime Parameters
-      const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope, const Scalar &lambda_thresh,
-      const Scalar &thl2tune, const Scalar &qw2tune, const Scalar &qwthl2tune, const Scalar &w2tune,
-      const Scalar &length_fac, const Scalar &c_diag_3rd_mom, const Scalar &Ckh, const Scalar &Ckm,
+      const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope,
+      const Scalar &lambda_thresh, const Scalar &thl2tune, const Scalar &qw2tune,
+      const Scalar &qwthl2tune, const Scalar &w2tune, const Scalar &length_fac,
+      const Scalar &c_diag_3rd_mom, const Scalar &Ckh, const Scalar &Ckm,
       // Input Variables
-      const view_1d<const Scalar> &host_dx, const view_1d<const Scalar> &host_dy, const view_2d<const Spack> &zt_grid,
-      const view_2d<const Spack> &zi_grid, const view_2d<const Spack> &pres, const view_2d<const Spack> &presi,
-      const view_2d<const Spack> &pdel, const view_2d<const Spack> &thv, const view_2d<const Spack> &w_field,
-      const view_1d<const Scalar> &wthl_sfc, const view_1d<const Scalar> &wqw_sfc, const view_1d<const Scalar> &uw_sfc,
+      const view_1d<const Scalar> &host_dx, const view_1d<const Scalar> &host_dy,
+      const view_2d<const Spack> &zt_grid, const view_2d<const Spack> &zi_grid,
+      const view_2d<const Spack> &pres, const view_2d<const Spack> &presi,
+      const view_2d<const Spack> &pdel, const view_2d<const Spack> &thv,
+      const view_2d<const Spack> &w_field, const view_1d<const Scalar> &wthl_sfc,
+      const view_1d<const Scalar> &wqw_sfc, const view_1d<const Scalar> &uw_sfc,
       const view_1d<const Scalar> &vw_sfc, const view_2d<const Spack> &wtracer_sfc,
       const view_2d<const Spack> &inv_exner, const view_1d<const Scalar> &phis,
       // Workspace Manager
       WorkspaceMgr &workspace_mgr,
       // Input/Output Variables
-      const view_2d<Spack> &host_dse, const view_2d<Spack> &tke, const view_2d<Spack> &thetal, const view_2d<Spack> &qw,
-      const uview_2d<Spack> &u_wind, const uview_2d<Spack> &v_wind, const view_2d<Spack> &wthv_sec,
-      const view_3d_strided<Spack> &qtracers, const view_2d<Spack> &tk, const view_2d<Spack> &shoc_cldfrac,
-      const view_2d<Spack> &shoc_ql,
+      const view_2d<Spack> &host_dse, const view_2d<Spack> &tke, const view_2d<Spack> &thetal,
+      const view_2d<Spack> &qw, const uview_2d<Spack> &u_wind, const uview_2d<Spack> &v_wind,
+      const view_2d<Spack> &wthv_sec, const view_3d_strided<Spack> &qtracers,
+      const view_2d<Spack> &tk, const view_2d<Spack> &shoc_cldfrac, const view_2d<Spack> &shoc_ql,
       // Output Variables
       const view_1d<Scalar> &pblh, const view_1d<Scalar> &ustar, const view_1d<Scalar> &obklen,
       const view_2d<Spack> &shoc_ql2, const view_2d<Spack> &tkh,
@@ -674,14 +762,14 @@ template <typename ScalarT, typename DeviceT> struct Functions {
 #endif
 
   // Return microseconds elapsed
-  static Int shoc_main(const Int &shcol,                            // Number of SHOC columns in the array
-                       const Int &nlev,                             // Number of levels
-                       const Int &nlevi,                            // Number of levels on interface grid
-                       const Int &npbl,                             // Maximum number of levels in pbl from surface
-                       const Int &nadv,                             // Number of times to loop SHOC
-                       const Int &num_q_tracers,                    // Number of tracers
-                       const Scalar &dtime,                         // SHOC timestep [s]
-                       WorkspaceMgr &workspace_mgr,                 // WorkspaceManager for local variables
+  static Int shoc_main(const Int &shcol,            // Number of SHOC columns in the array
+                       const Int &nlev,             // Number of levels
+                       const Int &nlevi,            // Number of levels on interface grid
+                       const Int &npbl,             // Maximum number of levels in pbl from surface
+                       const Int &nadv,             // Number of times to loop SHOC
+                       const Int &num_q_tracers,    // Number of tracers
+                       const Scalar &dtime,         // SHOC timestep [s]
+                       WorkspaceMgr &workspace_mgr, // WorkspaceManager for local variables
                        const SHOCRuntime &shoc_runtime,             // Runtime options
                        const SHOCInput &shoc_input,                 // Input
                        const SHOCInputOutput &shoc_input_output,    // Input/Output
@@ -694,89 +782,104 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   );
 
   KOKKOS_FUNCTION
-  static void pblintd_height(const MemberType &team, const Int &nlev, const Int &npbl, const uview_1d<const Spack> &z,
-                             const uview_1d<const Spack> &u, const uview_1d<const Spack> &v, const Scalar &ustar,
+  static void pblintd_height(const MemberType &team, const Int &nlev, const Int &npbl,
+                             const uview_1d<const Spack> &z, const uview_1d<const Spack> &u,
+                             const uview_1d<const Spack> &v, const Scalar &ustar,
                              const uview_1d<const Spack> &thv, const Scalar &thv_ref, Scalar &pblh,
                              const uview_1d<Spack> &rino, bool &check);
 
   KOKKOS_FUNCTION
-  static void vd_shoc_decomp(const MemberType &team, const Int &nlev, const uview_1d<const Spack> &kv_term,
+  static void vd_shoc_decomp(const MemberType &team, const Int &nlev,
+                             const uview_1d<const Spack> &kv_term,
                              const uview_1d<const Spack> &tmpi, const uview_1d<const Spack> &rdp_zt,
                              const Scalar &dtime, const Scalar &flux, const uview_1d<Scalar> &du,
                              const uview_1d<Scalar> &dl, const uview_1d<Scalar> &d);
 
   KOKKOS_FUNCTION
-  static void vd_shoc_solve(const MemberType &team, const uview_1d<Scalar> &du, const uview_1d<Scalar> &dl,
-                            const uview_1d<Scalar> &d, const uview_2d<Spack> &var);
+  static void vd_shoc_solve(const MemberType &team, const uview_1d<Scalar> &du,
+                            const uview_1d<Scalar> &dl, const uview_1d<Scalar> &d,
+                            const uview_2d<Spack> &var);
 
   KOKKOS_FUNCTION
-  static void pblintd_surf_temp(const Int &nlev, const Int &nlevi, const Int &npbl, const uview_1d<const Spack> &z,
-                                const Scalar &ustar, const Scalar &obklen, const Scalar &kbfs,
-                                const uview_1d<const Spack> &thv, Scalar &tlv, Scalar &pblh, bool &check,
-                                const uview_1d<Spack> &rino);
+  static void pblintd_surf_temp(const Int &nlev, const Int &nlevi, const Int &npbl,
+                                const uview_1d<const Spack> &z, const Scalar &ustar,
+                                const Scalar &obklen, const Scalar &kbfs,
+                                const uview_1d<const Spack> &thv, Scalar &tlv, Scalar &pblh,
+                                bool &check, const uview_1d<Spack> &rino);
 
   KOKKOS_FUNCTION
-  static void pblintd_check_pblh(const Int &nlevi, const Int &npbl, const uview_1d<const Spack> &z, const Scalar &ustar,
-                                 const bool &check, Scalar &pblh);
+  static void pblintd_check_pblh(const Int &nlevi, const Int &npbl, const uview_1d<const Spack> &z,
+                                 const Scalar &ustar, const bool &check, Scalar &pblh);
 
   KOKKOS_FUNCTION
   static void pblintd(const MemberType &team, const Int &nlev, const Int &nlevi, const Int &npbl,
-                      const uview_1d<const Spack> &z, const uview_1d<const Spack> &zi, const uview_1d<const Spack> &thl,
-                      const uview_1d<const Spack> &ql, const uview_1d<const Spack> &q, const uview_1d<const Spack> &u,
-                      const uview_1d<const Spack> &v, const Scalar &ustar, const Scalar &obklen, const Scalar &kbfs,
-                      const uview_1d<const Spack> &cldn, const Workspace &workspace, Scalar &pblh);
+                      const uview_1d<const Spack> &z, const uview_1d<const Spack> &zi,
+                      const uview_1d<const Spack> &thl, const uview_1d<const Spack> &ql,
+                      const uview_1d<const Spack> &q, const uview_1d<const Spack> &u,
+                      const uview_1d<const Spack> &v, const Scalar &ustar, const Scalar &obklen,
+                      const Scalar &kbfs, const uview_1d<const Spack> &cldn,
+                      const Workspace &workspace, Scalar &pblh);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
   static void pblintd_disp(const Int &shcol, const Int &nlev, const Int &nlevi, const Int &npbl,
                            const view_2d<const Spack> &z, const view_2d<const Spack> &zi,
                            const view_2d<const Spack> &thl, const view_2d<const Spack> &ql,
-                           const view_2d<const Spack> &q, const view_2d<const Spack> &u, const view_2d<const Spack> &v,
-                           const view_1d<const Scalar> &ustar, const view_1d<const Scalar> &obklen,
-                           const view_1d<const Scalar> &kbfs, const view_2d<const Spack> &cldn,
-                           const WorkspaceMgr &workspace_mgr, const view_1d<Scalar> &pblh);
+                           const view_2d<const Spack> &q, const view_2d<const Spack> &u,
+                           const view_2d<const Spack> &v, const view_1d<const Scalar> &ustar,
+                           const view_1d<const Scalar> &obklen, const view_1d<const Scalar> &kbfs,
+                           const view_2d<const Spack> &cldn, const WorkspaceMgr &workspace_mgr,
+                           const view_1d<Scalar> &pblh);
 #endif
 
   KOKKOS_FUNCTION
-  static void shoc_grid(const MemberType &team, const Int &nlev, const Int &nlevi, const uview_1d<const Spack> &zt_grid,
-                        const uview_1d<const Spack> &zi_grid, const uview_1d<const Spack> &pdel,
-                        const uview_1d<Spack> &dz_zt, const uview_1d<Spack> &dz_zi, const uview_1d<Spack> &rho_zt);
+  static void shoc_grid(const MemberType &team, const Int &nlev, const Int &nlevi,
+                        const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid,
+                        const uview_1d<const Spack> &pdel, const uview_1d<Spack> &dz_zt,
+                        const uview_1d<Spack> &dz_zi, const uview_1d<Spack> &rho_zt);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void shoc_grid_disp(const Int &shcol, const Int &nlev, const Int &nlevi, const view_2d<const Spack> &zt_grid,
+  static void shoc_grid_disp(const Int &shcol, const Int &nlev, const Int &nlevi,
+                             const view_2d<const Spack> &zt_grid,
                              const view_2d<const Spack> &zi_grid, const view_2d<const Spack> &pdel,
-                             const view_2d<Spack> &dz_zt, const view_2d<Spack> &dz_zi, const view_2d<Spack> &rho_zt);
+                             const view_2d<Spack> &dz_zt, const view_2d<Spack> &dz_zi,
+                             const view_2d<Spack> &rho_zt);
 #endif
 
   KOKKOS_FUNCTION
-  static void eddy_diffusivities(const MemberType &team, const Int &nlev, const Scalar &Ckh, const Scalar &Ckm,
-                                 const Scalar &pblh, const uview_1d<const Spack> &zt_grid,
-                                 const uview_1d<const Spack> &tabs, const uview_1d<const Spack> &shoc_mix,
-                                 const uview_1d<const Spack> &sterm_zt, const uview_1d<const Spack> &isotropy,
-                                 const uview_1d<const Spack> &tke, const uview_1d<Spack> &tkh,
-                                 const uview_1d<Spack> &tk);
+  static void
+  eddy_diffusivities(const MemberType &team, const Int &nlev, const Scalar &Ckh, const Scalar &Ckm,
+                     const Scalar &pblh, const uview_1d<const Spack> &zt_grid,
+                     const uview_1d<const Spack> &tabs, const uview_1d<const Spack> &shoc_mix,
+                     const uview_1d<const Spack> &sterm_zt, const uview_1d<const Spack> &isotropy,
+                     const uview_1d<const Spack> &tke, const uview_1d<Spack> &tkh,
+                     const uview_1d<Spack> &tk);
 
   KOKKOS_FUNCTION
-  static void shoc_tke(const MemberType &team, const Int &nlev, const Int &nlevi, const Scalar &dtime,
-                       const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope,
-                       const Scalar &lambda_thresh, const Scalar &Ckh, const Scalar &Ckm,
-                       const uview_1d<const Spack> &wthv_sec, const uview_1d<const Spack> &shoc_mix,
-                       const uview_1d<const Spack> &dz_zi, const uview_1d<const Spack> &dz_zt,
-                       const uview_1d<const Spack> &pres, const uview_1d<const Spack> &tabs,
-                       const uview_1d<const Spack> &u_wind, const uview_1d<const Spack> &v_wind,
-                       const uview_1d<const Spack> &brunt, const uview_1d<const Spack> &zt_grid,
-                       const uview_1d<const Spack> &zi_grid, const Scalar &pblh, const Workspace &workspace,
-                       const uview_1d<Spack> &tke, const uview_1d<Spack> &tk, const uview_1d<Spack> &tkh,
+  static void shoc_tke(const MemberType &team, const Int &nlev, const Int &nlevi,
+                       const Scalar &dtime, const Scalar &lambda_low, const Scalar &lambda_high,
+                       const Scalar &lambda_slope, const Scalar &lambda_thresh, const Scalar &Ckh,
+                       const Scalar &Ckm, const uview_1d<const Spack> &wthv_sec,
+                       const uview_1d<const Spack> &shoc_mix, const uview_1d<const Spack> &dz_zi,
+                       const uview_1d<const Spack> &dz_zt, const uview_1d<const Spack> &pres,
+                       const uview_1d<const Spack> &tabs, const uview_1d<const Spack> &u_wind,
+                       const uview_1d<const Spack> &v_wind, const uview_1d<const Spack> &brunt,
+                       const uview_1d<const Spack> &zt_grid, const uview_1d<const Spack> &zi_grid,
+                       const Scalar &pblh, const Workspace &workspace, const uview_1d<Spack> &tke,
+                       const uview_1d<Spack> &tk, const uview_1d<Spack> &tkh,
                        const uview_1d<Spack> &isotropy);
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  static void shoc_tke_disp(const Int &shcol, const Int &nlev, const Int &nlevi, const Scalar &dtime,
-                            const Scalar &lambda_low, const Scalar &lambda_high, const Scalar &lambda_slope,
+  static void shoc_tke_disp(const Int &shcol, const Int &nlev, const Int &nlevi,
+                            const Scalar &dtime, const Scalar &lambda_low,
+                            const Scalar &lambda_high, const Scalar &lambda_slope,
                             const Scalar &lambda_thresh, const Scalar &Ckh, const Scalar &Ckm,
-                            const view_2d<const Spack> &wthv_sec, const view_2d<const Spack> &shoc_mix,
-                            const view_2d<const Spack> &dz_zi, const view_2d<const Spack> &dz_zt,
-                            const view_2d<const Spack> &pres, const view_2d<const Spack> &tabs,
-                            const view_2d<const Spack> &u_wind, const view_2d<const Spack> &v_wind,
-                            const view_2d<const Spack> &brunt, const view_2d<const Spack> &zt_grid,
+                            const view_2d<const Spack> &wthv_sec,
+                            const view_2d<const Spack> &shoc_mix, const view_2d<const Spack> &dz_zi,
+                            const view_2d<const Spack> &dz_zt, const view_2d<const Spack> &pres,
+                            const view_2d<const Spack> &tabs, const view_2d<const Spack> &u_wind,
+                            const view_2d<const Spack> &v_wind, const view_2d<const Spack> &brunt,
+                            const view_2d<const Spack> &zt_grid,
                             const view_2d<const Spack> &zi_grid, const view_1d<const Scalar> &pblh,
-                            const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &tke, const view_2d<Spack> &tk,
-                            const view_2d<Spack> &tkh, const view_2d<Spack> &isotropy);
+                            const WorkspaceMgr &workspace_mgr, const view_2d<Spack> &tke,
+                            const view_2d<Spack> &tk, const view_2d<Spack> &tkh,
+                            const view_2d<Spack> &isotropy);
 #endif
 }; // struct Functions
 
diff --git i/components/eamxx/src/physics/shoc/tests/infra/shoc_data.hpp w/components/eamxx/src/physics/shoc/tests/infra/shoc_data.hpp
index da034d4ff3..42c411db1b 100644
--- i/components/eamxx/src/physics/shoc/tests/infra/shoc_data.hpp
+++ w/components/eamxx/src/physics/shoc/tests/infra/shoc_data.hpp
@@ -38,8 +38,8 @@ struct FortranData {
   // Out
   Array2 shoc_cldfrac, shoc_ql;
   Array1 pblh;
-  Array2 shoc_mix, w_sec, thl_sec, qw_sec, qwthl_sec, wthl_sec, wqw_sec, wtke_sec, uw_sec, vw_sec, w3, wqls_sec,
-      isotropy, brunt, shoc_ql2;
+  Array2 shoc_mix, w_sec, thl_sec, qw_sec, qwthl_sec, wthl_sec, wqw_sec, wtke_sec, uw_sec, vw_sec,
+      w3, wqls_sec, isotropy, brunt, shoc_ql2;
 
   FortranData() = delete;
   FortranData(Int shcol, Int nlev, Int nlevi, Int num_qtracers);
diff --git i/components/eamxx/src/physics/shoc/tests/infra/shoc_ic_cases.cpp w/components/eamxx/src/physics/shoc/tests/infra/shoc_ic_cases.cpp
index 14c7fcfdb0..a580c37909 100644
--- i/components/eamxx/src/physics/shoc/tests/infra/shoc_ic_cases.cpp
+++ w/components/eamxx/src/physics/shoc/tests/infra/shoc_ic_cases.cpp
@@ -83,13 +83,15 @@ const Real surface_pressure = 1015e2;
 // Linearly interpolates data at a specific elevation using elevation and
 // data arrays.
 template <size_t N>
-Real interpolate_data(const std::array<Real, N> &ref_elevations, const std::array<Real, N> &ref_data, Real z) {
+Real interpolate_data(const std::array<Real, N> &ref_elevations,
+                      const std::array<Real, N> &ref_data, Real z) {
   auto pos  = std::lower_bound(ref_elevations.begin(), ref_elevations.end(), z);
   Int index = pos - ref_elevations.begin();
   if (index == 0)
     return ref_data[0];
   else if (index < (Int)N) {
-    const Real a = (z - ref_elevations[index - 1]) / (ref_elevations[index] - ref_elevations[index - 1]);
+    const Real a =
+        (z - ref_elevations[index - 1]) / (ref_elevations[index] - ref_elevations[index - 1]);
     return (1.0 - a) * ref_data[index - 1] + a * ref_data[index];
   } else {
     // Don't extrapolate off the end of the table.
@@ -190,7 +192,8 @@ FortranData::Ptr make_standard(const Int shcol, Int nlev, Int num_qtracers) {
     for (Int k = 0; k < nlev; ++k) {
       d.pdel(i, k)      = std::abs(d.presi(i, k + 1) - d.presi(i, k));
       d.inv_exner(i, k) = 1 / pow(d.pres(i, k) / consts::P0, consts::Rair / consts::Cpair);
-      d.host_dse(i, k)  = consts::Cpair * d.thv(i, k) / d.inv_exner(i, k) + consts::gravit * d.zt_grid(i, k);
+      d.host_dse(i, k) =
+          consts::Cpair * d.thv(i, k) / d.inv_exner(i, k) + consts::gravit * d.zt_grid(i, k);
     }
 
     // Zero the other input fields.
diff --git i/components/eamxx/src/physics/shoc/tests/infra/shoc_main_wrap.cpp w/components/eamxx/src/physics/shoc/tests/infra/shoc_main_wrap.cpp
index 5e2acdd3ff..1ed25bc78d 100644
--- i/components/eamxx/src/physics/shoc/tests/infra/shoc_main_wrap.cpp
+++ w/components/eamxx/src/physics/shoc/tests/infra/shoc_main_wrap.cpp
@@ -17,13 +17,15 @@ Int shoc_main(FortranData &d) {
   EKAT_REQUIRE_MSG(d.nadv > 0, "Invalid nadv");
   const int npbl = d.nlev;
   return shoc_main_host(
-      (int)d.shcol, (int)d.nlev, (int)d.nlevi, d.dtime, (int)d.nadv, npbl, d.host_dx.data(), d.host_dy.data(),
-      d.thv.data(), d.zt_grid.data(), d.zi_grid.data(), d.pres.data(), d.presi.data(), d.pdel.data(), d.wthl_sfc.data(),
-      d.wqw_sfc.data(), d.uw_sfc.data(), d.vw_sfc.data(), d.wtracer_sfc.data(), (int)d.num_qtracers, d.w_field.data(),
-      d.inv_exner.data(), d.phis.data(), d.host_dse.data(), d.tke.data(), d.thetal.data(), d.qw.data(), d.u_wind.data(),
-      d.v_wind.data(), d.qtracers.data(), d.wthv_sec.data(), d.tkh.data(), d.tk.data(), d.shoc_ql.data(),
-      d.shoc_cldfrac.data(), d.pblh.data(), d.shoc_mix.data(), d.isotropy.data(), d.w_sec.data(), d.thl_sec.data(),
-      d.qw_sec.data(), d.qwthl_sec.data(), d.wthl_sec.data(), d.wqw_sec.data(), d.wtke_sec.data(), d.uw_sec.data(),
+      (int)d.shcol, (int)d.nlev, (int)d.nlevi, d.dtime, (int)d.nadv, npbl, d.host_dx.data(),
+      d.host_dy.data(), d.thv.data(), d.zt_grid.data(), d.zi_grid.data(), d.pres.data(),
+      d.presi.data(), d.pdel.data(), d.wthl_sfc.data(), d.wqw_sfc.data(), d.uw_sfc.data(),
+      d.vw_sfc.data(), d.wtracer_sfc.data(), (int)d.num_qtracers, d.w_field.data(),
+      d.inv_exner.data(), d.phis.data(), d.host_dse.data(), d.tke.data(), d.thetal.data(),
+      d.qw.data(), d.u_wind.data(), d.v_wind.data(), d.qtracers.data(), d.wthv_sec.data(),
+      d.tkh.data(), d.tk.data(), d.shoc_ql.data(), d.shoc_cldfrac.data(), d.pblh.data(),
+      d.shoc_mix.data(), d.isotropy.data(), d.w_sec.data(), d.thl_sec.data(), d.qw_sec.data(),
+      d.qwthl_sec.data(), d.wthl_sec.data(), d.wqw_sec.data(), d.wtke_sec.data(), d.uw_sec.data(),
       d.vw_sec.data(), d.w3.data(), d.wqls_sec.data(), d.brunt.data(), d.shoc_ql2.data());
 }
 
@@ -126,7 +128,8 @@ void gen_plot_script(const std::vector<std::shared_ptr<FortranData>> &data, cons
         "                  'qw', 'u_wind', 'v_wind', 'w_field', 'tke', 'tkh',\n"
         "                  'shoc_mix', 'isotropy', 'wtke_sec', 'uw_sec', 'vw_sec', 'wthl_sec',\n"
         "                  'wqw_sec', 'w_sec', 'thl_sec', 'qw_sec',\n"
-        "                  'w3', 'wqls_sec', 'brunt', 'qtracers', 'host_dse', 'inv_exner','shoc_ql2']\n"
+        "                  'w3', 'wqls_sec', 'brunt', 'qtracers', 'host_dse', "
+        "'inv_exner','shoc_ql2']\n"
         "        for i in range(len(plotno)):\n"
         "            if i == 0 or plotno[i] != plotno[i-1]:\n"
         "                if first: axs.append(pl.subplot(5, 5, plotno[i]))\n"
diff --git i/components/eamxx/src/physics/shoc/tests/infra/shoc_test_data.cpp w/components/eamxx/src/physics/shoc/tests/infra/shoc_test_data.cpp
index 55936ea9dc..dbeb74fcd7 100644
--- i/components/eamxx/src/physics/shoc/tests/infra/shoc_test_data.cpp
+++ w/components/eamxx/src/physics/shoc/tests/infra/shoc_test_data.cpp
@@ -24,27 +24,29 @@ namespace shoc {
 //
 
 void shoc_grid(ShocGridData &d) {
-  shoc_grid_host(d.shcol, d.nlev, d.nlevi, d.zt_grid, d.zi_grid, d.pdel, d.dz_zt, d.dz_zi, d.rho_zt);
+  shoc_grid_host(d.shcol, d.nlev, d.nlevi, d.zt_grid, d.zi_grid, d.pdel, d.dz_zt, d.dz_zi,
+                 d.rho_zt);
 }
 
 void shoc_diag_obklen(ShocDiagObklenData &d) {
-  shoc_diag_obklen_host(d.shcol, d.uw_sfc, d.vw_sfc, d.wthl_sfc, d.wqw_sfc, d.thl_sfc, d.cldliq_sfc, d.qv_sfc, d.ustar,
-                        d.kbfs, d.obklen);
+  shoc_diag_obklen_host(d.shcol, d.uw_sfc, d.vw_sfc, d.wthl_sfc, d.wqw_sfc, d.thl_sfc, d.cldliq_sfc,
+                        d.qv_sfc, d.ustar, d.kbfs, d.obklen);
 }
 
 void update_host_dse(UpdateHostDseData &d) {
-  update_host_dse_host(d.shcol, d.nlev, d.thlm, d.shoc_ql, d.inv_exner, d.zt_grid, d.phis, d.host_dse);
+  update_host_dse_host(d.shcol, d.nlev, d.thlm, d.shoc_ql, d.inv_exner, d.zt_grid, d.phis,
+                       d.host_dse);
 }
 
 void shoc_energy_fixer(ShocEnergyFixerData &d) {
-  shoc_energy_fixer_host(d.shcol, d.nlev, d.nlevi, d.dtime, d.nadv, d.zt_grid, d.zi_grid, d.se_b, d.ke_b, d.wv_b,
-                         d.wl_b, d.se_a, d.ke_a, d.wv_a, d.wl_a, d.wthl_sfc, d.wqw_sfc, d.rho_zt, d.tke, d.pint,
-                         d.host_dse);
+  shoc_energy_fixer_host(d.shcol, d.nlev, d.nlevi, d.dtime, d.nadv, d.zt_grid, d.zi_grid, d.se_b,
+                         d.ke_b, d.wv_b, d.wl_b, d.se_a, d.ke_a, d.wv_a, d.wl_a, d.wthl_sfc,
+                         d.wqw_sfc, d.rho_zt, d.tke, d.pint, d.host_dse);
 }
 
 void shoc_energy_integrals(ShocEnergyIntegralsData &d) {
-  shoc_energy_integrals_host(d.shcol, d.nlev, d.host_dse, d.pdel, d.rtm, d.rcm, d.u_wind, d.v_wind, d.se_int, d.ke_int,
-                             d.wv_int, d.wl_int);
+  shoc_energy_integrals_host(d.shcol, d.nlev, d.host_dse, d.pdel, d.rtm, d.rcm, d.u_wind, d.v_wind,
+                             d.se_int, d.ke_int, d.wv_int, d.wl_int);
 }
 
 void calc_shoc_vertflux(CalcShocVertfluxData &d) {
@@ -52,11 +54,13 @@ void calc_shoc_vertflux(CalcShocVertfluxData &d) {
 }
 
 void calc_shoc_varorcovar(CalcShocVarorcovarData &d) {
-  calc_shoc_varorcovar_host(d.shcol, d.nlev, d.nlevi, d.tunefac, d.isotropy_zi, d.tkh_zi, d.dz_zi, d.invar1, d.invar2,
-                            d.varorcovar);
+  calc_shoc_varorcovar_host(d.shcol, d.nlev, d.nlevi, d.tunefac, d.isotropy_zi, d.tkh_zi, d.dz_zi,
+                            d.invar1, d.invar2, d.varorcovar);
 }
 
-void compute_tmpi(ComputeTmpiData &d) { compute_tmpi_host(d.nlevi, d.shcol, d.dtime, d.rho_zi, d.dz_zi, d.tmpi); }
+void compute_tmpi(ComputeTmpiData &d) {
+  compute_tmpi_host(d.nlevi, d.shcol, d.dtime, d.rho_zi, d.dz_zi, d.tmpi);
+}
 
 void dp_inverse(DpInverseData &d) { dp_inverse_host(d.nlev, d.shcol, d.rho_zt, d.dz_zt, d.rdp_zt); }
 
@@ -67,8 +71,9 @@ void integ_column_stability(IntegColumnStabilityData &d) {
 void check_tke(CheckTkeData &d) { check_tke_host(d.shcol, d.nlev, d.tke); }
 
 void shoc_tke(ShocTkeData &d) {
-  shoc_tke_host(d.shcol, d.nlev, d.nlevi, d.dtime, d.wthv_sec, d.shoc_mix, d.dz_zi, d.dz_zt, d.pres, d.tabs, d.u_wind,
-                d.v_wind, d.brunt, d.zt_grid, d.zi_grid, d.pblh, d.tke, d.tk, d.tkh, d.isotropy);
+  shoc_tke_host(d.shcol, d.nlev, d.nlevi, d.dtime, d.wthv_sec, d.shoc_mix, d.dz_zi, d.dz_zt, d.pres,
+                d.tabs, d.u_wind, d.v_wind, d.brunt, d.zt_grid, d.zi_grid, d.pblh, d.tke, d.tk,
+                d.tkh, d.isotropy);
 }
 
 void compute_shr_prod(ComputeShrProdData &d) {
@@ -80,17 +85,18 @@ void isotropic_ts(IsotropicTsData &d) {
 }
 
 void adv_sgs_tke(AdvSgsTkeData &d) {
-  adv_sgs_tke_host(d.nlev, d.shcol, d.dtime, d.shoc_mix, d.wthv_sec, d.sterm_zt, d.tk, d.tke, d.a_diss);
+  adv_sgs_tke_host(d.nlev, d.shcol, d.dtime, d.shoc_mix, d.wthv_sec, d.sterm_zt, d.tk, d.tke,
+                   d.a_diss);
 }
 
 void eddy_diffusivities(EddyDiffusivitiesData &d) {
-  eddy_diffusivities_host(d.nlev, d.shcol, d.pblh, d.zt_grid, d.tabs, d.shoc_mix, d.sterm_zt, d.isotropy, d.tke, d.tkh,
-                          d.tk);
+  eddy_diffusivities_host(d.nlev, d.shcol, d.pblh, d.zt_grid, d.tabs, d.shoc_mix, d.sterm_zt,
+                          d.isotropy, d.tke, d.tkh, d.tk);
 }
 
 void shoc_length(ShocLengthData &d) {
-  shoc_length_host(d.shcol, d.nlev, d.nlevi, d.host_dx, d.host_dy, d.zt_grid, d.zi_grid, d.dz_zt, d.tke, d.thv, d.brunt,
-                   d.shoc_mix);
+  shoc_length_host(d.shcol, d.nlev, d.nlevi, d.host_dx, d.host_dy, d.zt_grid, d.zi_grid, d.dz_zt,
+                   d.tke, d.thv, d.brunt, d.shoc_mix);
 }
 
 void compute_brunt_shoc_length(ComputeBruntShocLengthData &d) {
@@ -102,7 +108,8 @@ void compute_l_inf_shoc_length(ComputeLInfShocLengthData &d) {
 }
 
 void compute_shoc_mix_shoc_length(ComputeShocMixShocLengthData &d) {
-  compute_shoc_mix_shoc_length_host(d.nlev, d.shcol, d.tke, d.brunt, d.zt_grid, d.l_inf, d.shoc_mix);
+  compute_shoc_mix_shoc_length_host(d.nlev, d.shcol, d.tke, d.brunt, d.zt_grid, d.l_inf,
+                                    d.shoc_mix);
 }
 
 void check_length_scale_shoc_length(CheckLengthScaleShocLengthData &d) {
@@ -122,19 +129,21 @@ void linear_interp(LinearInterpData &d) {
 }
 
 void diag_third_shoc_moments(DiagThirdShocMomentsData &d) {
-  diag_third_shoc_moments_host(d.shcol, d.nlev, d.nlevi, d.w_sec, d.thl_sec, d.wthl_sec, d.isotropy, d.brunt, d.thetal,
-                               d.tke, d.dz_zt, d.dz_zi, d.zt_grid, d.zi_grid, d.w3);
+  diag_third_shoc_moments_host(d.shcol, d.nlev, d.nlevi, d.w_sec, d.thl_sec, d.wthl_sec, d.isotropy,
+                               d.brunt, d.thetal, d.tke, d.dz_zt, d.dz_zi, d.zt_grid, d.zi_grid,
+                               d.w3);
 }
 
 void compute_diag_third_shoc_moment(ComputeDiagThirdShocMomentData &d) {
-  compute_diag_third_shoc_moment_host(d.shcol, d.nlev, d.nlevi, d.w_sec, d.thl_sec, d.wthl_sec, d.tke, d.dz_zt, d.dz_zi,
-                                      d.isotropy_zi, d.brunt_zi, d.w_sec_zi, d.thetal_zi, d.w3);
+  compute_diag_third_shoc_moment_host(d.shcol, d.nlev, d.nlevi, d.w_sec, d.thl_sec, d.wthl_sec,
+                                      d.tke, d.dz_zt, d.dz_zi, d.isotropy_zi, d.brunt_zi,
+                                      d.w_sec_zi, d.thetal_zi, d.w3);
 }
 
 void shoc_assumed_pdf(ShocAssumedPdfData &d) {
-  shoc_assumed_pdf_host(d.shcol, d.nlev, d.nlevi, d.thetal, d.qw, d.w_field, d.thl_sec, d.qw_sec, d.wthl_sec, d.w_sec,
-                        d.wqw_sec, d.qwthl_sec, d.w3, d.pres, d.zt_grid, d.zi_grid, d.shoc_cldfrac, d.shoc_ql, d.wqls,
-                        d.wthv_sec, d.shoc_ql2);
+  shoc_assumed_pdf_host(d.shcol, d.nlev, d.nlevi, d.thetal, d.qw, d.w_field, d.thl_sec, d.qw_sec,
+                        d.wthl_sec, d.w_sec, d.wqw_sec, d.qwthl_sec, d.w3, d.pres, d.zt_grid,
+                        d.zi_grid, d.shoc_cldfrac, d.shoc_ql, d.wqls, d.wthv_sec, d.shoc_ql2);
 }
 
 void shoc_assumed_pdf_tilde_to_real(ShocAssumedPdfTildeToRealData &d) {
@@ -142,26 +151,27 @@ void shoc_assumed_pdf_tilde_to_real(ShocAssumedPdfTildeToRealData &d) {
 }
 
 void shoc_assumed_pdf_vv_parameters(ShocAssumedPdfVvParametersData &d) {
-  shoc_assumed_pdf_vv_parameters_host(d.w_first, d.w_sec, d.w3var, d.w_tol_sqd, &d.skew_w, &d.w1_1, &d.w1_2, &d.w2_1,
-                                      &d.w2_2, &d.a);
+  shoc_assumed_pdf_vv_parameters_host(d.w_first, d.w_sec, d.w3var, d.w_tol_sqd, &d.skew_w, &d.w1_1,
+                                      &d.w1_2, &d.w2_1, &d.w2_2, &d.a);
 }
 
 void shoc_assumed_pdf_thl_parameters(ShocAssumedPdfThlParametersData &d) {
-  shoc_assumed_pdf_thl_parameters_host(d.wthlsec, d.sqrtw2, d.sqrtthl, d.thlsec, d.thl_first, d.w1_1, d.w1_2, d.skew_w,
-                                       d.a, d.thl_tol, d.w_thresh, &d.thl1_1, &d.thl1_2, &d.thl2_1, &d.thl2_2,
-                                       &d.sqrtthl2_1, &d.sqrtthl2_2);
+  shoc_assumed_pdf_thl_parameters_host(d.wthlsec, d.sqrtw2, d.sqrtthl, d.thlsec, d.thl_first,
+                                       d.w1_1, d.w1_2, d.skew_w, d.a, d.thl_tol, d.w_thresh,
+                                       &d.thl1_1, &d.thl1_2, &d.thl2_1, &d.thl2_2, &d.sqrtthl2_1,
+                                       &d.sqrtthl2_2);
 }
 
 void shoc_assumed_pdf_qw_parameters(ShocAssumedPdfQwParametersData &d) {
-  shoc_assumed_pdf_qw_parameters_host(d.wqwsec, d.sqrtw2, d.skew_w, d.sqrtqt, d.qwsec, d.w1_2, d.w1_1, d.qw_first, d.a,
-                                      d.rt_tol, d.w_thresh, &d.qw1_1, &d.qw1_2, &d.qw2_1, &d.qw2_2, &d.sqrtqw2_1,
-                                      &d.sqrtqw2_2);
+  shoc_assumed_pdf_qw_parameters_host(d.wqwsec, d.sqrtw2, d.skew_w, d.sqrtqt, d.qwsec, d.w1_2,
+                                      d.w1_1, d.qw_first, d.a, d.rt_tol, d.w_thresh, &d.qw1_1,
+                                      &d.qw1_2, &d.qw2_1, &d.qw2_2, &d.sqrtqw2_1, &d.sqrtqw2_2);
 }
 
 void shoc_assumed_pdf_inplume_correlations(ShocAssumedPdfInplumeCorrelationsData &d) {
-  shoc_assumed_pdf_inplume_correlations_host(d.sqrtqw2_1, d.sqrtthl2_1, d.a, d.sqrtqw2_2, d.sqrtthl2_2, d.qwthlsec,
-                                             d.qw1_1, d.qw_first, d.thl1_1, d.thl_first, d.qw1_2, d.thl1_2,
-                                             &d.r_qwthl_1);
+  shoc_assumed_pdf_inplume_correlations_host(
+      d.sqrtqw2_1, d.sqrtthl2_1, d.a, d.sqrtqw2_2, d.sqrtthl2_2, d.qwthlsec, d.qw1_1, d.qw_first,
+      d.thl1_1, d.thl_first, d.qw1_2, d.thl1_2, &d.r_qwthl_1);
 }
 
 void shoc_assumed_pdf_compute_temperature(ShocAssumedPdfComputeTemperatureData &d) {
@@ -173,21 +183,23 @@ void shoc_assumed_pdf_compute_qs(ShocAssumedPdfComputeQsData &d) {
 }
 
 void shoc_assumed_pdf_compute_s(ShocAssumedPdfComputeSData &d) {
-  shoc_assumed_pdf_compute_s_host(d.qw1, d.qs1, d.beta, d.pval, d.thl2, d.qw2, d.sqrtthl2, d.sqrtqw2, d.r_qwthl, &d.s,
-                                  &d.std_s, &d.qn, &d.c);
+  shoc_assumed_pdf_compute_s_host(d.qw1, d.qs1, d.beta, d.pval, d.thl2, d.qw2, d.sqrtthl2,
+                                  d.sqrtqw2, d.r_qwthl, &d.s, &d.std_s, &d.qn, &d.c);
 }
 
 void shoc_assumed_pdf_compute_sgs_liquid(ShocAssumedPdfComputeSgsLiquidData &d) {
   shoc_assumed_pdf_compute_sgs_liquid_host(d.a, d.ql1, d.ql2, &d.shoc_ql);
 }
 
-void shoc_assumed_pdf_compute_cloud_liquid_variance(ShocAssumedPdfComputeCloudLiquidVarianceData &d) {
-  shoc_assumed_pdf_compute_cloud_liquid_variance_host(d.a, d.s1, d.ql1, d.c1, d.std_s1, d.s2, d.ql2, d.c2, d.std_s2,
-                                                      d.shoc_ql, &d.shoc_ql2);
+void shoc_assumed_pdf_compute_cloud_liquid_variance(
+    ShocAssumedPdfComputeCloudLiquidVarianceData &d) {
+  shoc_assumed_pdf_compute_cloud_liquid_variance_host(d.a, d.s1, d.ql1, d.c1, d.std_s1, d.s2, d.ql2,
+                                                      d.c2, d.std_s2, d.shoc_ql, &d.shoc_ql2);
 }
 
 void shoc_assumed_pdf_compute_liquid_water_flux(ShocAssumedPdfComputeLiquidWaterFluxData &d) {
-  shoc_assumed_pdf_compute_liquid_water_flux_host(d.a, d.w1_1, d.w_first, d.ql1, d.w1_2, d.ql2, &d.wqls);
+  shoc_assumed_pdf_compute_liquid_water_flux_host(d.a, d.w1_1, d.w_first, d.ql1, d.w1_2, d.ql2,
+                                                  &d.wqls);
 }
 
 void shoc_assumed_pdf_compute_buoyancy_flux(ShocAssumedPdfComputeBuoyancyFluxData &d) {
@@ -195,63 +207,74 @@ void shoc_assumed_pdf_compute_buoyancy_flux(ShocAssumedPdfComputeBuoyancyFluxDat
 }
 
 void diag_second_moments_ubycond(DiagSecondMomentsUbycondData &d) {
-  shoc_diag_second_moments_ubycond_host(d.shcol, d.thl_sec, d.qw_sec, d.wthl_sec, d.wqw_sec, d.qwthl_sec, d.uw_sec,
-                                        d.vw_sec, d.wtke_sec);
+  shoc_diag_second_moments_ubycond_host(d.shcol, d.thl_sec, d.qw_sec, d.wthl_sec, d.wqw_sec,
+                                        d.qwthl_sec, d.uw_sec, d.vw_sec, d.wtke_sec);
 }
 
-void pblintd_init_pot(PblintdInitPotData &d) { shoc_pblintd_init_pot_host(d.shcol, d.nlev, d.thl, d.ql, d.q, d.thv); }
+void pblintd_init_pot(PblintdInitPotData &d) {
+  shoc_pblintd_init_pot_host(d.shcol, d.nlev, d.thl, d.ql, d.q, d.thv);
+}
 
 void pblintd_cldcheck(PblintdCldcheckData &d) {
   shoc_pblintd_cldcheck_host(d.shcol, d.nlev, d.nlevi, d.zi, d.cldn, d.pblh);
 }
 
 void diag_second_moments_lbycond(DiagSecondMomentsLbycondData &d) {
-  diag_second_moments_lbycond_host(d.shcol, d.wthl_sfc, d.wqw_sfc, d.uw_sfc, d.vw_sfc, d.ustar2, d.wstar, d.wthl_sec,
-                                   d.wqw_sec, d.uw_sec, d.vw_sec, d.wtke_sec, d.thl_sec, d.qw_sec, d.qwthl_sec);
+  diag_second_moments_lbycond_host(d.shcol, d.wthl_sfc, d.wqw_sfc, d.uw_sfc, d.vw_sfc, d.ustar2,
+                                   d.wstar, d.wthl_sec, d.wqw_sec, d.uw_sec, d.vw_sec, d.wtke_sec,
+                                   d.thl_sec, d.qw_sec, d.qwthl_sec);
 }
 
 void diag_second_moments(DiagSecondMomentsData &d) {
-  diag_second_moments_host(d.shcol, d.nlev, d.nlevi, d.thetal, d.qw, d.u_wind, d.v_wind, d.tke, d.isotropy, d.tkh, d.tk,
-                           d.dz_zi, d.zt_grid, d.zi_grid, d.shoc_mix, d.thl_sec, d.qw_sec, d.wthl_sec, d.wqw_sec,
-                           d.qwthl_sec, d.uw_sec, d.vw_sec, d.wtke_sec, d.w_sec);
+  diag_second_moments_host(d.shcol, d.nlev, d.nlevi, d.thetal, d.qw, d.u_wind, d.v_wind, d.tke,
+                           d.isotropy, d.tkh, d.tk, d.dz_zi, d.zt_grid, d.zi_grid, d.shoc_mix,
+                           d.thl_sec, d.qw_sec, d.wthl_sec, d.wqw_sec, d.qwthl_sec, d.uw_sec,
+                           d.vw_sec, d.wtke_sec, d.w_sec);
 }
 
 void diag_second_shoc_moments(DiagSecondShocMomentsData &d) {
-  diag_second_shoc_moments_host(d.shcol, d.nlev, d.nlevi, d.thetal, d.qw, d.u_wind, d.v_wind, d.tke, d.isotropy, d.tkh,
-                                d.tk, d.dz_zi, d.zt_grid, d.zi_grid, d.shoc_mix, d.wthl_sfc, d.wqw_sfc, d.uw_sfc,
-                                d.vw_sfc, d.thl_sec, d.qw_sec, d.wthl_sec, d.wqw_sec, d.qwthl_sec, d.uw_sec, d.vw_sec,
-                                d.wtke_sec, d.w_sec);
+  diag_second_shoc_moments_host(d.shcol, d.nlev, d.nlevi, d.thetal, d.qw, d.u_wind, d.v_wind, d.tke,
+                                d.isotropy, d.tkh, d.tk, d.dz_zi, d.zt_grid, d.zi_grid, d.shoc_mix,
+                                d.wthl_sfc, d.wqw_sfc, d.uw_sfc, d.vw_sfc, d.thl_sec, d.qw_sec,
+                                d.wthl_sec, d.wqw_sec, d.qwthl_sec, d.uw_sec, d.vw_sec, d.wtke_sec,
+                                d.w_sec);
 }
 
-void compute_shoc_vapor(ComputeShocVaporData &d) { compute_shoc_vapor_host(d.shcol, d.nlev, d.qw, d.ql, d.qv); }
+void compute_shoc_vapor(ComputeShocVaporData &d) {
+  compute_shoc_vapor_host(d.shcol, d.nlev, d.qw, d.ql, d.qv);
+}
 
 void update_prognostics_implicit(UpdatePrognosticsImplicitData &d) {
-  update_prognostics_implicit_host(d.shcol, d.nlev, d.nlevi, d.num_tracer, d.dtime, d.dz_zt, d.dz_zi, d.rho_zt,
-                                   d.zt_grid, d.zi_grid, d.tk, d.tkh, d.uw_sfc, d.vw_sfc, d.wthl_sfc, d.wqw_sfc,
-                                   d.wtracer_sfc, d.thetal, d.qw, d.tracer, d.tke, d.u_wind, d.v_wind);
+  update_prognostics_implicit_host(d.shcol, d.nlev, d.nlevi, d.num_tracer, d.dtime, d.dz_zt,
+                                   d.dz_zi, d.rho_zt, d.zt_grid, d.zi_grid, d.tk, d.tkh, d.uw_sfc,
+                                   d.vw_sfc, d.wthl_sfc, d.wqw_sfc, d.wtracer_sfc, d.thetal, d.qw,
+                                   d.tracer, d.tke, d.u_wind, d.v_wind);
 }
 
 void shoc_main(ShocMainData &d) {
   const int npbl = shoc_init_host(d.nlev, d.pref_mid, d.nbot_shoc, d.ntop_shoc);
   d.elapsed_s    = shoc_main_host(
-      d.shcol, d.nlev, d.nlevi, d.dtime, d.nadv, npbl, d.host_dx, d.host_dy, d.thv, d.zt_grid, d.zi_grid, d.pres,
-      d.presi, d.pdel, d.wthl_sfc, d.wqw_sfc, d.uw_sfc, d.vw_sfc, d.wtracer_sfc, d.num_qtracers, d.w_field, d.inv_exner,
-      d.phis, d.host_dse, d.tke, d.thetal, d.qw, d.u_wind, d.v_wind, d.qtracers, d.wthv_sec, d.tkh, d.tk, d.shoc_ql,
-      d.shoc_cldfrac, d.pblh, d.shoc_mix, d.isotropy, d.w_sec, d.thl_sec, d.qw_sec, d.qwthl_sec, d.wthl_sec, d.wqw_sec,
-      d.wtke_sec, d.uw_sec, d.vw_sec, d.w3, d.wqls_sec, d.brunt, d.shoc_ql2);
+      d.shcol, d.nlev, d.nlevi, d.dtime, d.nadv, npbl, d.host_dx, d.host_dy, d.thv, d.zt_grid,
+      d.zi_grid, d.pres, d.presi, d.pdel, d.wthl_sfc, d.wqw_sfc, d.uw_sfc, d.vw_sfc, d.wtracer_sfc,
+      d.num_qtracers, d.w_field, d.inv_exner, d.phis, d.host_dse, d.tke, d.thetal, d.qw, d.u_wind,
+      d.v_wind, d.qtracers, d.wthv_sec, d.tkh, d.tk, d.shoc_ql, d.shoc_cldfrac, d.pblh, d.shoc_mix,
+      d.isotropy, d.w_sec, d.thl_sec, d.qw_sec, d.qwthl_sec, d.wthl_sec, d.wqw_sec, d.wtke_sec,
+      d.uw_sec, d.vw_sec, d.w3, d.wqls_sec, d.brunt, d.shoc_ql2);
 }
 
 void pblintd_height(PblintdHeightData &d) {
-  pblintd_height_host(d.shcol, d.nlev, d.npbl, d.z, d.u, d.v, d.ustar, d.thv, d.thv_ref, d.pblh, d.rino, d.check);
+  pblintd_height_host(d.shcol, d.nlev, d.npbl, d.z, d.u, d.v, d.ustar, d.thv, d.thv_ref, d.pblh,
+                      d.rino, d.check);
 }
 
 void vd_shoc_decomp_and_solve(VdShocDecompandSolveData &d) {
-  vd_shoc_decomp_and_solve_host(d.shcol, d.nlev, d.nlevi, d.n_rhs, d.dtime, d.kv_term, d.tmpi, d.rdp_zt, d.flux, d.var);
+  vd_shoc_decomp_and_solve_host(d.shcol, d.nlev, d.nlevi, d.n_rhs, d.dtime, d.kv_term, d.tmpi,
+                                d.rdp_zt, d.flux, d.var);
 }
 
 void pblintd_surf_temp(PblintdSurfTempData &d) {
-  pblintd_surf_temp_host(d.shcol, d.nlev, d.nlevi, d.z, d.ustar, d.obklen, d.kbfs, d.thv, d.tlv, d.pblh, d.check,
-                         d.rino);
+  pblintd_surf_temp_host(d.shcol, d.nlev, d.nlevi, d.z, d.ustar, d.obklen, d.kbfs, d.thv, d.tlv,
+                         d.pblh, d.check, d.rino);
 }
 
 void pblintd_check_pblh(PblintdCheckPblhData &d) {
@@ -259,8 +282,8 @@ void pblintd_check_pblh(PblintdCheckPblhData &d) {
 }
 
 void pblintd(PblintdData &d) {
-  pblintd_host(d.shcol, d.nlev, d.nlevi, d.npbl, d.z, d.zi, d.thl, d.ql, d.q, d.u, d.v, d.ustar, d.obklen, d.kbfs,
-               d.cldn, d.pblh);
+  pblintd_host(d.shcol, d.nlev, d.nlevi, d.npbl, d.z, d.zi, d.thl, d.ql, d.q, d.u, d.v, d.ustar,
+               d.obklen, d.kbfs, d.cldn, d.pblh);
 }
 
 void compute_shoc_temperature(ComputeShocTempData &d) {
@@ -273,8 +296,9 @@ void compute_shoc_temperature(ComputeShocTempData &d) {
 // _host function definitions. These expect data in C layout
 //
 
-void calc_shoc_varorcovar_host(Int shcol, Int nlev, Int nlevi, Real tunefac, Real *isotropy_zi, Real *tkh_zi,
-                               Real *dz_zi, Real *invar1, Real *invar2, Real *varorcovar) {
+void calc_shoc_varorcovar_host(Int shcol, Int nlev, Int nlevi, Real tunefac, Real *isotropy_zi,
+                               Real *tkh_zi, Real *dz_zi, Real *invar1, Real *invar2,
+                               Real *varorcovar) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -293,8 +317,8 @@ void calc_shoc_varorcovar_host(Int shcol, Int nlev, Int nlevi, Real tunefac, Rea
   // Sync to device
   ekat::host_to_device(ptr_array, dim1_sizes, dim2_sizes, temp_d);
 
-  view_2d isotropy_zi_d(temp_d[0]), tkh_zi_d(temp_d[1]), dz_zi_d(temp_d[2]), invar1_d(temp_d[3]), invar2_d(temp_d[4]),
-      varorcovar_d(temp_d[5]);
+  view_2d isotropy_zi_d(temp_d[0]), tkh_zi_d(temp_d[1]), dz_zi_d(temp_d[2]), invar1_d(temp_d[3]),
+      invar2_d(temp_d[4]), varorcovar_d(temp_d[5]);
 
   const Int nk_pack = ekat::npack<Spack>(nlev);
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(shcol, nk_pack);
@@ -309,8 +333,8 @@ void calc_shoc_varorcovar_host(Int shcol, Int nlev, Int nlevi, Real tunefac, Rea
         const auto oinvar2_d      = ekat::subview(invar2_d, i);
         const auto ovarorcovar_d  = ekat::subview(varorcovar_d, i);
 
-        SHF::calc_shoc_varorcovar(team, nlev, tunefac, oisotropy_zi_d, otkh_zi_d, odz_zi_d, oinvar1_d, oinvar2_d,
-                                  ovarorcovar_d);
+        SHF::calc_shoc_varorcovar(team, nlev, tunefac, oisotropy_zi_d, otkh_zi_d, odz_zi_d,
+                                  oinvar1_d, oinvar2_d, ovarorcovar_d);
       });
 
   // Sync back to host
@@ -318,7 +342,8 @@ void calc_shoc_varorcovar_host(Int shcol, Int nlev, Int nlevi, Real tunefac, Rea
   ekat::device_to_host({varorcovar}, shcol, nlevi, inout_views);
 }
 
-void calc_shoc_vertflux_host(Int shcol, Int nlev, Int nlevi, Real *tkh_zi, Real *dz_zi, Real *invar, Real *vertflux) {
+void calc_shoc_vertflux_host(Int shcol, Int nlev, Int nlevi, Real *tkh_zi, Real *dz_zi, Real *invar,
+                             Real *vertflux) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -358,8 +383,8 @@ void calc_shoc_vertflux_host(Int shcol, Int nlev, Int nlevi, Real *tkh_zi, Real
   ekat::device_to_host({vertflux}, shcol, nlevi, inout_views);
 }
 
-void shoc_diag_second_moments_srf_host(Int shcol, Real *wthl_sfc, Real *uw_sfc, Real *vw_sfc, Real *ustar2,
-                                       Real *wstar) {
+void shoc_diag_second_moments_srf_host(Int shcol, Real *wthl_sfc, Real *uw_sfc, Real *vw_sfc,
+                                       Real *ustar2, Real *wstar) {
   using SHOC    = Functions<Real, DefaultDevice>;
   using Scalar  = typename SHOC::Scalar;
   using view_1d = typename SHOC::view_1d<Scalar>;
@@ -392,15 +417,16 @@ void shoc_diag_second_moments_srf_host(Int shcol, Real *wthl_sfc, Real *uw_sfc,
   ScreamDeepCopy::copy_to_host({ustar2, wstar}, shcol, inout_views);
 }
 
-void shoc_diag_second_moments_ubycond_host(Int shcol, Real *thl_sec, Real *qw_sec, Real *wthl_sec, Real *wqw_sec,
-                                           Real *qwthl_sec, Real *uw_sec, Real *vw_sec, Real *wtke_sec) {
+void shoc_diag_second_moments_ubycond_host(Int shcol, Real *thl_sec, Real *qw_sec, Real *wthl_sec,
+                                           Real *wqw_sec, Real *qwthl_sec, Real *uw_sec,
+                                           Real *vw_sec, Real *wtke_sec) {
   using SHOC    = Functions<Real, DefaultDevice>;
   using Scalar  = typename SHOC::Scalar;
   using view_1d = typename SHOC::view_1d<Scalar>;
 
   view_1d thl_sec_d("thl_sec", shcol), qw_sec_d("qw_sec", shcol), qwthl_sec_d("qwthl_sec", shcol),
-      wthl_sec_d("wthl_sec", shcol), wqw_sec_d("wqw_sec", shcol), uw_sec_d("uw_sec", shcol), vw_sec_d("vw_sec", shcol),
-      wtke_sec_d("wtke_sec", shcol);
+      wthl_sec_d("wthl_sec", shcol), wqw_sec_d("wqw_sec", shcol), uw_sec_d("uw_sec", shcol),
+      vw_sec_d("vw_sec", shcol), wtke_sec_d("wtke_sec", shcol);
 
   Kokkos::parallel_for(
       "parallel_moments_ubycond", shcol, KOKKOS_LAMBDA(const int &i) {
@@ -413,8 +439,8 @@ void shoc_diag_second_moments_ubycond_host(Int shcol, Real *thl_sec, Real *qw_se
         Scalar vw_sec_s{0.};
         Scalar wtke_sec_s{0.};
 
-        SHOC::shoc_diag_second_moments_ubycond(thl_sec_s, qw_sec_s, wthl_sec_s, wqw_sec_s, qwthl_sec_s, uw_sec_s,
-                                               vw_sec_s, wtke_sec_s);
+        SHOC::shoc_diag_second_moments_ubycond(thl_sec_s, qw_sec_s, wthl_sec_s, wqw_sec_s,
+                                               qwthl_sec_s, uw_sec_s, vw_sec_s, wtke_sec_s);
 
         thl_sec_d(i)   = thl_sec_s;
         qw_sec_d(i)    = qw_sec_s;
@@ -429,12 +455,12 @@ void shoc_diag_second_moments_ubycond_host(Int shcol, Real *thl_sec, Real *qw_se
   std::vector<view_1d> host_views = {thl_sec_d, qw_sec_d, qwthl_sec_d, wthl_sec_d,
                                      wqw_sec_d, uw_sec_d, vw_sec_d,    wtke_sec_d};
 
-  ScreamDeepCopy::copy_to_host({thl_sec, qw_sec, qwthl_sec, wthl_sec, wqw_sec, uw_sec, vw_sec, wtke_sec}, shcol,
-                               host_views);
+  ScreamDeepCopy::copy_to_host(
+      {thl_sec, qw_sec, qwthl_sec, wthl_sec, wqw_sec, uw_sec, vw_sec, wtke_sec}, shcol, host_views);
 }
 
-void update_host_dse_host(Int shcol, Int nlev, Real *thlm, Real *shoc_ql, Real *inv_exner, Real *zt_grid, Real *phis,
-                          Real *host_dse) {
+void update_host_dse_host(Int shcol, Int nlev, Real *thlm, Real *shoc_ql, Real *inv_exner,
+                          Real *zt_grid, Real *phis, Real *host_dse) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -455,8 +481,8 @@ void update_host_dse_host(Int shcol, Int nlev, Real *thlm, Real *shoc_ql, Real *
 
   view_1d phis_d(temp_1d_d[0]);
 
-  view_2d thlm_d(temp_2d_d[0]), shoc_ql_d(temp_2d_d[1]), inv_exner_d(temp_2d_d[2]), zt_grid_d(temp_2d_d[3]),
-      host_dse_d(temp_2d_d[4]);
+  view_2d thlm_d(temp_2d_d[0]), shoc_ql_d(temp_2d_d[1]), inv_exner_d(temp_2d_d[2]),
+      zt_grid_d(temp_2d_d[3]), host_dse_d(temp_2d_d[4]);
 
   const Int nk_pack = ekat::npack<Spack>(nlev);
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(shcol, nk_pack);
@@ -471,7 +497,8 @@ void update_host_dse_host(Int shcol, Int nlev, Real *thlm, Real *shoc_ql, Real *
         const auto zt_grid_s   = ekat::subview(zt_grid_d, i);
         const auto host_dse_s  = ekat::subview(host_dse_d, i);
 
-        SHF::update_host_dse(team, nlev, thlm_s, shoc_ql_s, inv_exner_s, zt_grid_s, phis_s, host_dse_s);
+        SHF::update_host_dse(team, nlev, thlm_s, shoc_ql_s, inv_exner_s, zt_grid_s, phis_s,
+                             host_dse_s);
       });
 
   // Sync back to host
@@ -479,9 +506,10 @@ void update_host_dse_host(Int shcol, Int nlev, Real *thlm, Real *shoc_ql, Real *
   ekat::device_to_host({host_dse}, shcol, nlev, inout_views);
 }
 
-void compute_diag_third_shoc_moment_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, Real *thl_sec, Real *wthl_sec,
-                                         Real *tke, Real *dz_zt, Real *dz_zi, Real *isotropy_zi, Real *brunt_zi,
-                                         Real *w_sec_zi, Real *thetal_zi, Real *w3) {
+void compute_diag_third_shoc_moment_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, Real *thl_sec,
+                                         Real *wthl_sec, Real *tke, Real *dz_zt, Real *dz_zi,
+                                         Real *isotropy_zi, Real *brunt_zi, Real *w_sec_zi,
+                                         Real *thetal_zi, Real *w3) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -492,16 +520,17 @@ void compute_diag_third_shoc_moment_host(Int shcol, Int nlev, Int nlevi, Real *w
 
   std::vector<view_2d> temp_d(11);
   std::vector<Int> dim1_sizes(11, shcol);
-  std::vector<Int> dim2_sizes         = {nlev, nlevi, nlevi, nlev, nlev, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi};
+  std::vector<Int> dim2_sizes         = {nlev,  nlevi, nlevi, nlev,  nlev, nlevi,
+                                         nlevi, nlevi, nlevi, nlevi, nlevi};
   std::vector<const Real *> ptr_array = {w_sec,       thl_sec,  wthl_sec, tke,       dz_zt, dz_zi,
                                          isotropy_zi, brunt_zi, w_sec_zi, thetal_zi, w3};
 
   // Sync to device
   ekat::host_to_device(ptr_array, dim1_sizes, dim2_sizes, temp_d);
 
-  view_2d w_sec_d(temp_d[0]), thl_sec_d(temp_d[1]), wthl_sec_d(temp_d[2]), tke_d(temp_d[3]), dz_zt_d(temp_d[4]),
-      dz_zi_d(temp_d[5]), isotropy_zi_d(temp_d[6]), brunt_zi_d(temp_d[7]), w_sec_zi_d(temp_d[8]),
-      thetal_zi_d(temp_d[9]), w3_d(temp_d[10]);
+  view_2d w_sec_d(temp_d[0]), thl_sec_d(temp_d[1]), wthl_sec_d(temp_d[2]), tke_d(temp_d[3]),
+      dz_zt_d(temp_d[4]), dz_zi_d(temp_d[5]), isotropy_zi_d(temp_d[6]), brunt_zi_d(temp_d[7]),
+      w_sec_zi_d(temp_d[8]), thetal_zi_d(temp_d[9]), w3_d(temp_d[10]);
 
   const Int nk_pack = ekat::npack<Spack>(nlev);
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(shcol, nk_pack);
@@ -523,8 +552,9 @@ void compute_diag_third_shoc_moment_host(Int shcol, Int nlev, Int nlevi, Real *w
 
         // Hardcode runtime options for F90 testing
         const Real c_diag_3rd_mom = 7.0;
-        SHF::compute_diag_third_shoc_moment(team, nlev, nlevi, c_diag_3rd_mom, w_sec_s, thl_sec_s, wthl_sec_s, tke_s,
-                                            dz_zt_s, dz_zi_s, isotropy_zi_s, brunt_zi_s, w_sec_zi_s, thetal_zi_s, w3_s);
+        SHF::compute_diag_third_shoc_moment(team, nlev, nlevi, c_diag_3rd_mom, w_sec_s, thl_sec_s,
+                                            wthl_sec_s, tke_s, dz_zt_s, dz_zi_s, isotropy_zi_s,
+                                            brunt_zi_s, w_sec_zi_s, thetal_zi_s, w3_s);
       });
 
   // Sync back to host
@@ -567,8 +597,8 @@ void shoc_pblintd_init_pot_host(Int shcol, Int nlev, Real *thl, Real *ql, Real *
   ekat::device_to_host({thv}, shcol, nlev, inout_views);
 }
 
-void compute_shoc_mix_shoc_length_host(Int nlev, Int shcol, Real *tke, Real *brunt, Real *zt_grid, Real *l_inf,
-                                       Real *shoc_mix) {
+void compute_shoc_mix_shoc_length_host(Int nlev, Int shcol, Real *tke, Real *brunt, Real *zt_grid,
+                                       Real *l_inf, Real *shoc_mix) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -589,7 +619,8 @@ void compute_shoc_mix_shoc_length_host(Int nlev, Int shcol, Real *tke, Real *bru
 
   view_1d l_inf_d(temp_1d_d[0]);
 
-  view_2d tke_d(temp_2d_d[0]), brunt_d(temp_2d_d[1]), zt_grid_d(temp_2d_d[2]), shoc_mix_d(temp_2d_d[3]);
+  view_2d tke_d(temp_2d_d[0]), brunt_d(temp_2d_d[1]), zt_grid_d(temp_2d_d[2]),
+      shoc_mix_d(temp_2d_d[3]);
 
   const Int nk_pack = ekat::npack<Spack>(nlev);
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(shcol, nk_pack);
@@ -605,7 +636,8 @@ void compute_shoc_mix_shoc_length_host(Int nlev, Int shcol, Real *tke, Real *bru
         const auto shoc_mix_s = ekat::subview(shoc_mix_d, i);
 
         const Real length_fac = 0.5;
-        SHF::compute_shoc_mix_shoc_length(team, nlev, length_fac, tke_s, brunt_s, zt_grid_s, l_inf_s, shoc_mix_s);
+        SHF::compute_shoc_mix_shoc_length(team, nlev, length_fac, tke_s, brunt_s, zt_grid_s,
+                                          l_inf_s, shoc_mix_s);
       });
 
   // Sync back to host
@@ -644,7 +676,8 @@ void check_tke_host(Int shcol, Int nlev, Real *tke) {
   ekat::device_to_host({tke}, shcol, nlev, inout_views);
 }
 
-void linear_interp_host(Real *x1, Real *x2, Real *y1, Real *y2, Int km1, Int km2, Int ncol, Real minthresh) {
+void linear_interp_host(Real *x1, Real *x2, Real *y1, Real *y2, Int km1, Int km2, Int ncol,
+                        Real minthresh) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -714,8 +747,9 @@ void clipping_diag_third_shoc_moments_host(Int nlevi, Int shcol, Real *w_sec_zi,
   ekat::device_to_host({w3}, shcol, nlevi, inout_views);
 }
 
-void shoc_energy_integrals_host(Int shcol, Int nlev, Real *host_dse, Real *pdel, Real *rtm, Real *rcm, Real *u_wind,
-                                Real *v_wind, Real *se_int, Real *ke_int, Real *wv_int, Real *wl_int) {
+void shoc_energy_integrals_host(Int shcol, Int nlev, Real *host_dse, Real *pdel, Real *rtm,
+                                Real *rcm, Real *u_wind, Real *v_wind, Real *se_int, Real *ke_int,
+                                Real *wv_int, Real *wl_int) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -733,11 +767,12 @@ void shoc_energy_integrals_host(Int shcol, Int nlev, Real *host_dse, Real *pdel,
   ekat::host_to_device(ptr_array, shcol, nlev, temp_d);
 
   // inputs
-  view_2d host_dse_d(temp_d[0]), pdel_d(temp_d[1]), rtm_d(temp_d[2]), rcm_d(temp_d[3]), u_wind_d(temp_d[4]),
-      v_wind_d(temp_d[5]);
+  view_2d host_dse_d(temp_d[0]), pdel_d(temp_d[1]), rtm_d(temp_d[2]), rcm_d(temp_d[3]),
+      u_wind_d(temp_d[4]), v_wind_d(temp_d[5]);
 
   // outputs
-  view_1d se_int_d("se_int", shcol), ke_int_d("ke_int", shcol), wv_int_d("wv_int", shcol), wl_int_d("wl_int", shcol);
+  view_1d se_int_d("se_int", shcol), ke_int_d("ke_int", shcol), wv_int_d("wv_int", shcol),
+      wl_int_d("wl_int", shcol);
 
   const Int nk_pack = ekat::npack<Spack>(nlev);
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(shcol, nk_pack);
@@ -757,8 +792,8 @@ void shoc_energy_integrals_host(Int shcol, Int nlev, Real *host_dse, Real *pdel,
         Scalar wv_int_s{0};
         Scalar wl_int_s{0};
 
-        SHF::shoc_energy_integrals(team, nlev, host_dse_s, pdel_s, rtm_s, rcm_s, u_wind_s, v_wind_s, se_int_s, ke_int_s,
-                                   wv_int_s, wl_int_s);
+        SHF::shoc_energy_integrals(team, nlev, host_dse_s, pdel_s, rtm_s, rcm_s, u_wind_s, v_wind_s,
+                                   se_int_s, ke_int_s, wv_int_s, wl_int_s);
 
         se_int_d(i) = se_int_s;
         ke_int_d(i) = ke_int_s;
@@ -771,33 +806,37 @@ void shoc_energy_integrals_host(Int shcol, Int nlev, Real *host_dse, Real *pdel,
   ScreamDeepCopy::copy_to_host({se_int, ke_int, wv_int, wl_int}, shcol, inout_views);
 }
 
-void diag_second_moments_lbycond_host(Int shcol, Real *wthl_sfc, Real *wqw_sfc, Real *uw_sfc, Real *vw_sfc,
-                                      Real *ustar2, Real *wstar, Real *wthl_sec, Real *wqw_sec, Real *uw_sec,
-                                      Real *vw_sec, Real *wtke_sec, Real *thl_sec, Real *qw_sec, Real *qwthl_sec) {
+void diag_second_moments_lbycond_host(Int shcol, Real *wthl_sfc, Real *wqw_sfc, Real *uw_sfc,
+                                      Real *vw_sfc, Real *ustar2, Real *wstar, Real *wthl_sec,
+                                      Real *wqw_sec, Real *uw_sec, Real *vw_sec, Real *wtke_sec,
+                                      Real *thl_sec, Real *qw_sec, Real *qwthl_sec) {
   using SHOC    = Functions<Real, DefaultDevice>;
   using Scalar  = typename SHOC::Scalar;
   using view_1d = typename SHOC::view_1d<Scalar>;
 
   std::vector<view_1d> lbycond_d(6);
-  ScreamDeepCopy::copy_to_device({wthl_sfc, wqw_sfc, uw_sfc, vw_sfc, ustar2, wstar}, shcol, lbycond_d);
+  ScreamDeepCopy::copy_to_device({wthl_sfc, wqw_sfc, uw_sfc, vw_sfc, ustar2, wstar}, shcol,
+                                 lbycond_d);
 
   // inputs
-  view_1d wthl_d(lbycond_d[0]), wqw_d(lbycond_d[1]), uw_d(lbycond_d[2]), vw_d(lbycond_d[3]), ustar2_d(lbycond_d[4]),
-      wstar_d(lbycond_d[5]);
+  view_1d wthl_d(lbycond_d[0]), wqw_d(lbycond_d[1]), uw_d(lbycond_d[2]), vw_d(lbycond_d[3]),
+      ustar2_d(lbycond_d[4]), wstar_d(lbycond_d[5]);
 
   // outputs
-  view_1d wthlo_d("wthl", shcol), wqwo_d("wqw", shcol), uwo_d("uw", shcol), vwo_d("vw", shcol), wtkeo_d("wtke", shcol),
-      thlo_d("thl", shcol), qwo_d("qw", shcol), qwthlo_d("qwthl", shcol);
+  view_1d wthlo_d("wthl", shcol), wqwo_d("wqw", shcol), uwo_d("uw", shcol), vwo_d("vw", shcol),
+      wtkeo_d("wtke", shcol), thlo_d("thl", shcol), qwo_d("qw", shcol), qwthlo_d("qwthl", shcol);
 
   Kokkos::parallel_for(
       "parallel_moments_lbycond", shcol, KOKKOS_LAMBDA(const int &i) {
-        Scalar wthl_s{wthl_d(i)}, wqw_s{wqw_d(i)}, uw_s{uw_d(i)}, vw_s{vw_d(i)}, ustar2_s{ustar2_d(i)},
-            wstar_s{wstar_d(i)};
+        Scalar wthl_s{wthl_d(i)}, wqw_s{wqw_d(i)}, uw_s{uw_d(i)}, vw_s{vw_d(i)},
+            ustar2_s{ustar2_d(i)}, wstar_s{wstar_d(i)};
 
-        Scalar wthlo_s{0.}, wqwo_s{0.}, uwo_s{0.}, vwo_s{0.}, wtkeo_s{0.}, thlo_s{0.}, qwo_s{0.}, qwthlo_s{0.};
+        Scalar wthlo_s{0.}, wqwo_s{0.}, uwo_s{0.}, vwo_s{0.}, wtkeo_s{0.}, thlo_s{0.}, qwo_s{0.},
+            qwthlo_s{0.};
 
-        SHOC::shoc_diag_second_moments_lbycond(wthl_s, wqw_s, uw_s, vw_s, ustar2_s, wstar_s, wthlo_s, wqwo_s, uwo_s,
-                                               vwo_s, wtkeo_s, thlo_s, qwo_s, qwthlo_s);
+        SHOC::shoc_diag_second_moments_lbycond(wthl_s, wqw_s, uw_s, vw_s, ustar2_s, wstar_s,
+                                               wthlo_s, wqwo_s, uwo_s, vwo_s, wtkeo_s, thlo_s,
+                                               qwo_s, qwthlo_s);
 
         wthlo_d(i)  = wthlo_s;
         wqwo_d(i)   = wqwo_s;
@@ -809,15 +848,18 @@ void diag_second_moments_lbycond_host(Int shcol, Real *wthl_sfc, Real *wqw_sfc,
         qwthlo_d(i) = qwthlo_s;
       });
 
-  std::vector<view_1d> host_views = {wthlo_d, wqwo_d, uwo_d, vwo_d, wtkeo_d, thlo_d, qwo_d, qwthlo_d};
-  ScreamDeepCopy::copy_to_host({wthl_sec, wqw_sec, uw_sec, vw_sec, wtke_sec, thl_sec, qw_sec, qwthl_sec}, shcol,
-                               host_views);
+  std::vector<view_1d> host_views = {wthlo_d, wqwo_d, uwo_d, vwo_d,
+                                     wtkeo_d, thlo_d, qwo_d, qwthlo_d};
+  ScreamDeepCopy::copy_to_host(
+      {wthl_sec, wqw_sec, uw_sec, vw_sec, wtke_sec, thl_sec, qw_sec, qwthl_sec}, shcol, host_views);
 }
 
-void diag_second_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw, Real *u_wind, Real *v_wind,
-                              Real *tke, Real *isotropy, Real *tkh, Real *tk, Real *dz_zi, Real *zt_grid, Real *zi_grid,
-                              Real *shoc_mix, Real *thl_sec, Real *qw_sec, Real *wthl_sec, Real *wqw_sec,
-                              Real *qwthl_sec, Real *uw_sec, Real *vw_sec, Real *wtke_sec, Real *w_sec) {
+void diag_second_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw, Real *u_wind,
+                              Real *v_wind, Real *tke, Real *isotropy, Real *tkh, Real *tk,
+                              Real *dz_zi, Real *zt_grid, Real *zi_grid, Real *shoc_mix,
+                              Real *thl_sec, Real *qw_sec, Real *wthl_sec, Real *wqw_sec,
+                              Real *qwthl_sec, Real *uw_sec, Real *vw_sec, Real *wtke_sec,
+                              Real *w_sec) {
   using SHOC       = Functions<Real, DefaultDevice>;
   using Spack      = typename SHOC::Spack;
   using view_2d    = typename SHOC::view_2d<Spack>;
@@ -826,21 +868,23 @@ void diag_second_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real
   using MemberType = typename SHOC::MemberType;
 
   std::vector<Int> dim1_array(20, shcol);
-  std::vector<Int> dim2_array = {nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,
-                                 nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi};
+  std::vector<Int> dim2_array = {nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,
+                                 nlev,  nlev,  nlev,  nlevi, nlevi, nlevi, nlevi,
+                                 nlevi, nlevi, nlevi, nlevi, nlevi, nlevi};
 
   std::vector<view_2d> temp_2d(20);
-  std::vector<const Real *> ptr_array = {thetal,    qw,      u_wind,   v_wind,   tke,    isotropy, tkh,
-                                         tk,        zt_grid, shoc_mix, thl_sec,  qw_sec, wthl_sec, wqw_sec,
-                                         qwthl_sec, uw_sec,  vw_sec,   wtke_sec, dz_zi,  zi_grid};
+  std::vector<const Real *> ptr_array = {
+      thetal,  qw,     u_wind,   v_wind,  tke,       isotropy, tkh,    tk,       zt_grid, shoc_mix,
+      thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec, uw_sec,   vw_sec, wtke_sec, dz_zi,   zi_grid};
 
   ekat::host_to_device(ptr_array, dim1_array, dim2_array, temp_2d);
 
-  view_2d thetal_2d(temp_2d[0]), qw_2d(temp_2d[1]), u_wind_2d(temp_2d[2]), v_wind_2d(temp_2d[3]), tke_2d(temp_2d[4]),
-      isotropy_2d(temp_2d[5]), tkh_2d(temp_2d[6]), tk_2d(temp_2d[7]), zt_grid_2d(temp_2d[8]), shoc_mix_2d(temp_2d[9]),
-      thl_sec_2d(temp_2d[10]), qw_sec_2d(temp_2d[11]), wthl_sec_2d(temp_2d[12]), wqw_sec_2d(temp_2d[13]),
-      qwthl_sec_2d(temp_2d[14]), uw_sec_2d(temp_2d[15]), vw_sec_2d(temp_2d[16]), wtke_sec_2d(temp_2d[17]),
-      dz_zi_2d(temp_2d[18]), zi_grid_2d(temp_2d[19]);
+  view_2d thetal_2d(temp_2d[0]), qw_2d(temp_2d[1]), u_wind_2d(temp_2d[2]), v_wind_2d(temp_2d[3]),
+      tke_2d(temp_2d[4]), isotropy_2d(temp_2d[5]), tkh_2d(temp_2d[6]), tk_2d(temp_2d[7]),
+      zt_grid_2d(temp_2d[8]), shoc_mix_2d(temp_2d[9]), thl_sec_2d(temp_2d[10]),
+      qw_sec_2d(temp_2d[11]), wthl_sec_2d(temp_2d[12]), wqw_sec_2d(temp_2d[13]),
+      qwthl_sec_2d(temp_2d[14]), uw_sec_2d(temp_2d[15]), vw_sec_2d(temp_2d[16]),
+      wtke_sec_2d(temp_2d[17]), dz_zi_2d(temp_2d[18]), zi_grid_2d(temp_2d[19]);
 
   const Int nlev_packs  = ekat::npack<Spack>(nlev);
   const Int nlevi_packs = ekat::npack<Spack>(nlevi);
@@ -883,25 +927,29 @@ void diag_second_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real
         const auto tkh_zi_1d      = ekat::subview(tkh_zi_2d, i);
         const auto tk_zi_1d       = ekat::subview(tk_zi_2d, i);
 
-        SHOC::diag_second_moments(team, nlev, nlevi, thl2tune, qw2tune, qwthl2tune, w2tune, thetal_1d, qw_1d, u_wind_1d,
-                                  v_wind_1d, tke_1d, isotropy_1d, tkh_1d, tk_1d, dz_zi_1d, zt_grid_1d, zi_grid_1d,
-                                  shoc_mix_1d, isotropy_zi_1d, tkh_zi_1d, tk_zi_1d, thl_sec_1d, qw_sec_1d, wthl_sec_1d,
-                                  wqw_sec_1d, qwthl_sec_1d, uw_sec_1d, vw_sec_1d, wtke_sec_1d, w_sec_1d);
+        SHOC::diag_second_moments(
+            team, nlev, nlevi, thl2tune, qw2tune, qwthl2tune, w2tune, thetal_1d, qw_1d, u_wind_1d,
+            v_wind_1d, tke_1d, isotropy_1d, tkh_1d, tk_1d, dz_zi_1d, zt_grid_1d, zi_grid_1d,
+            shoc_mix_1d, isotropy_zi_1d, tkh_zi_1d, tk_zi_1d, thl_sec_1d, qw_sec_1d, wthl_sec_1d,
+            wqw_sec_1d, qwthl_sec_1d, uw_sec_1d, vw_sec_1d, wtke_sec_1d, w_sec_1d);
       });
 
   std::vector<Int> dim1(9, shcol);
   std::vector<Int> dim2           = {nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlev};
   std::vector<view_2d> host_views = {thl_sec_2d, qw_sec_2d, wthl_sec_2d, wqw_sec_2d, qwthl_sec_2d,
                                      uw_sec_2d,  vw_sec_2d, wtke_sec_2d, w_sec_2d};
-  ekat::device_to_host({thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec, uw_sec, vw_sec, wtke_sec, w_sec}, dim1, dim2,
-                       host_views);
+  ekat::device_to_host(
+      {thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec, uw_sec, vw_sec, wtke_sec, w_sec}, dim1, dim2,
+      host_views);
 }
 
-void diag_second_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw, Real *u_wind, Real *v_wind,
-                                   Real *tke, Real *isotropy, Real *tkh, Real *tk, Real *dz_zi, Real *zt_grid,
-                                   Real *zi_grid, Real *shoc_mix, Real *wthl_sfc, Real *wqw_sfc, Real *uw_sfc,
-                                   Real *vw_sfc, Real *thl_sec, Real *qw_sec, Real *wthl_sec, Real *wqw_sec,
-                                   Real *qwthl_sec, Real *uw_sec, Real *vw_sec, Real *wtke_sec, Real *w_sec) {
+void diag_second_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw,
+                                   Real *u_wind, Real *v_wind, Real *tke, Real *isotropy, Real *tkh,
+                                   Real *tk, Real *dz_zi, Real *zt_grid, Real *zi_grid,
+                                   Real *shoc_mix, Real *wthl_sfc, Real *wqw_sfc, Real *uw_sfc,
+                                   Real *vw_sfc, Real *thl_sec, Real *qw_sec, Real *wthl_sec,
+                                   Real *wqw_sec, Real *qwthl_sec, Real *uw_sec, Real *vw_sec,
+                                   Real *wtke_sec, Real *w_sec) {
   using SHOC       = Functions<Real, DefaultDevice>;
   using Scalar     = typename SHOC::Scalar;
   using Spack      = typename SHOC::Spack;
@@ -917,20 +965,22 @@ void diag_second_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal,
   view_1d wthl_1d(temp_1d[0]), wqw_1d(temp_1d[1]), uw_1d(temp_1d[2]), vw_1d(temp_1d[3]);
 
   std::vector<Int> dim1_array(20, shcol);
-  std::vector<Int> dim2_array = {nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,
-                                 nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi};
+  std::vector<Int> dim2_array = {nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,
+                                 nlev,  nlev,  nlev,  nlevi, nlevi, nlevi, nlevi,
+                                 nlevi, nlevi, nlevi, nlevi, nlevi, nlevi};
   std::vector<view_2d> temp_2d(20);
-  std::vector<const Real *> ptr_array = {thetal,    qw,      u_wind,   v_wind,   tke,    isotropy, tkh,
-                                         tk,        zt_grid, shoc_mix, thl_sec,  qw_sec, wthl_sec, wqw_sec,
-                                         qwthl_sec, uw_sec,  vw_sec,   wtke_sec, dz_zi,  zi_grid};
+  std::vector<const Real *> ptr_array = {
+      thetal,  qw,     u_wind,   v_wind,  tke,       isotropy, tkh,    tk,       zt_grid, shoc_mix,
+      thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec, uw_sec,   vw_sec, wtke_sec, dz_zi,   zi_grid};
 
   ekat::host_to_device(ptr_array, dim1_array, dim2_array, temp_2d);
 
-  view_2d thetal_2d(temp_2d[0]), qw_2d(temp_2d[1]), u_wind_2d(temp_2d[2]), v_wind_2d(temp_2d[3]), tke_2d(temp_2d[4]),
-      isotropy_2d(temp_2d[5]), tkh_2d(temp_2d[6]), tk_2d(temp_2d[7]), zt_grid_2d(temp_2d[8]), shoc_mix_2d(temp_2d[9]),
-      thl_sec_2d(temp_2d[10]), qw_sec_2d(temp_2d[11]), wthl_sec_2d(temp_2d[12]), wqw_sec_2d(temp_2d[13]),
-      qwthl_sec_2d(temp_2d[14]), uw_sec_2d(temp_2d[15]), vw_sec_2d(temp_2d[16]), wtke_sec_2d(temp_2d[17]),
-      dz_zi_2d(temp_2d[18]), zi_grid_2d(temp_2d[19]);
+  view_2d thetal_2d(temp_2d[0]), qw_2d(temp_2d[1]), u_wind_2d(temp_2d[2]), v_wind_2d(temp_2d[3]),
+      tke_2d(temp_2d[4]), isotropy_2d(temp_2d[5]), tkh_2d(temp_2d[6]), tk_2d(temp_2d[7]),
+      zt_grid_2d(temp_2d[8]), shoc_mix_2d(temp_2d[9]), thl_sec_2d(temp_2d[10]),
+      qw_sec_2d(temp_2d[11]), wthl_sec_2d(temp_2d[12]), wqw_sec_2d(temp_2d[13]),
+      qwthl_sec_2d(temp_2d[14]), uw_sec_2d(temp_2d[15]), vw_sec_2d(temp_2d[16]),
+      wtke_sec_2d(temp_2d[17]), dz_zi_2d(temp_2d[18]), zi_grid_2d(temp_2d[19]);
 
   view_2d w_sec_2d("w_sec", shcol, nlev);
 
@@ -983,22 +1033,26 @@ void diag_second_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal,
         Scalar ustar2_s = ustar2_1d(i);
         Scalar wstar_s  = wstar_1d(i);
 
-        SHOC::diag_second_shoc_moments(team, nlev, nlevi, thl2tune, qw2tune, qwthl2tune, w2tune, thetal_1d, qw_1d,
-                                       u_wind_1d, v_wind_1d, tke_1d, isotropy_1d, tkh_1d, tk_1d, dz_zi_1d, zt_grid_1d,
-                                       zi_grid_1d, shoc_mix_1d, wthl_s, wqw_s, uw_s, vw_s, ustar2_s, wstar_s, workspace,
-                                       thl_sec_1d, qw_sec_1d, wthl_sec_1d, wqw_sec_1d, qwthl_sec_1d, uw_sec_1d,
-                                       vw_sec_1d, wtke_sec_1d, w_sec_1d);
+        SHOC::diag_second_shoc_moments(team, nlev, nlevi, thl2tune, qw2tune, qwthl2tune, w2tune,
+                                       thetal_1d, qw_1d, u_wind_1d, v_wind_1d, tke_1d, isotropy_1d,
+                                       tkh_1d, tk_1d, dz_zi_1d, zt_grid_1d, zi_grid_1d, shoc_mix_1d,
+                                       wthl_s, wqw_s, uw_s, vw_s, ustar2_s, wstar_s, workspace,
+                                       thl_sec_1d, qw_sec_1d, wthl_sec_1d, wqw_sec_1d, qwthl_sec_1d,
+                                       uw_sec_1d, vw_sec_1d, wtke_sec_1d, w_sec_1d);
       });
 
   std::vector<Int> dim1(9, shcol);
-  std::vector<Int> dim2              = {nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlev};
-  std::vector<view_2d> host_2d_views = {thl_sec_2d, qw_sec_2d, wthl_sec_2d, wqw_sec_2d, qwthl_sec_2d,
-                                        uw_sec_2d,  vw_sec_2d, wtke_sec_2d, w_sec_2d};
-  ekat::device_to_host({thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec, uw_sec, vw_sec, wtke_sec, w_sec}, dim1, dim2,
-                       host_2d_views);
+  std::vector<Int> dim2 = {nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlev};
+  std::vector<view_2d> host_2d_views = {thl_sec_2d, qw_sec_2d,    wthl_sec_2d,
+                                        wqw_sec_2d, qwthl_sec_2d, uw_sec_2d,
+                                        vw_sec_2d,  wtke_sec_2d,  w_sec_2d};
+  ekat::device_to_host(
+      {thl_sec, qw_sec, wthl_sec, wqw_sec, qwthl_sec, uw_sec, vw_sec, wtke_sec, w_sec}, dim1, dim2,
+      host_2d_views);
 }
 
-void compute_brunt_shoc_length_host(Int nlev, Int nlevi, Int shcol, Real *dz_zt, Real *thv, Real *thv_zi, Real *brunt) {
+void compute_brunt_shoc_length_host(Int nlev, Int nlevi, Int shcol, Real *dz_zt, Real *thv,
+                                    Real *thv_zi, Real *brunt) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -1036,7 +1090,8 @@ void compute_brunt_shoc_length_host(Int nlev, Int nlevi, Int shcol, Real *dz_zt,
   ekat::device_to_host({brunt}, shcol, nlev, inout_views);
 }
 
-void compute_l_inf_shoc_length_host(Int nlev, Int shcol, Real *zt_grid, Real *dz_zt, Real *tke, Real *l_inf) {
+void compute_l_inf_shoc_length_host(Int nlev, Int shcol, Real *zt_grid, Real *dz_zt, Real *tke,
+                                    Real *l_inf) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -1079,7 +1134,8 @@ void compute_l_inf_shoc_length_host(Int nlev, Int shcol, Real *zt_grid, Real *dz
   ScreamDeepCopy::copy_to_host({l_inf}, shcol, inout_views);
 }
 
-void check_length_scale_shoc_length_host(Int nlev, Int shcol, Real *host_dx, Real *host_dy, Real *shoc_mix) {
+void check_length_scale_shoc_length_host(Int nlev, Int shcol, Real *host_dx, Real *host_dy,
+                                         Real *shoc_mix) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -1118,8 +1174,9 @@ void check_length_scale_shoc_length_host(Int nlev, Int shcol, Real *host_dx, Rea
   ekat::device_to_host({shoc_mix}, shcol, nlev, inout_views);
 }
 
-void shoc_diag_obklen_host(Int shcol, Real *uw_sfc, Real *vw_sfc, Real *wthl_sfc, Real *wqw_sfc, Real *thl_sfc,
-                           Real *cldliq_sfc, Real *qv_sfc, Real *ustar, Real *kbfs, Real *obklen) {
+void shoc_diag_obklen_host(Int shcol, Real *uw_sfc, Real *vw_sfc, Real *wthl_sfc, Real *wqw_sfc,
+                           Real *thl_sfc, Real *cldliq_sfc, Real *qv_sfc, Real *ustar, Real *kbfs,
+                           Real *obklen) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar  = typename SHF::Scalar;
@@ -1127,12 +1184,13 @@ void shoc_diag_obklen_host(Int shcol, Real *uw_sfc, Real *vw_sfc, Real *wthl_sfc
 
   // Sync to device
   std::vector<view_1d> temp_d(7);
-  std::vector<const Real *> ptr_array = {uw_sfc, vw_sfc, wthl_sfc, wqw_sfc, thl_sfc, cldliq_sfc, qv_sfc};
+  std::vector<const Real *> ptr_array = {uw_sfc,  vw_sfc,     wthl_sfc, wqw_sfc,
+                                         thl_sfc, cldliq_sfc, qv_sfc};
   ScreamDeepCopy::copy_to_device(ptr_array, shcol, temp_d);
 
   // Inputs
-  view_1d uw_sfc_d(temp_d[0]), vw_sfc_d(temp_d[1]), wthl_sfc_d(temp_d[2]), wqw_sfc_d(temp_d[3]), thl_sfc_d(temp_d[4]),
-      cldliq_sfc_d(temp_d[5]), qv_sfc_d(temp_d[6]);
+  view_1d uw_sfc_d(temp_d[0]), vw_sfc_d(temp_d[1]), wthl_sfc_d(temp_d[2]), wqw_sfc_d(temp_d[3]),
+      thl_sfc_d(temp_d[4]), cldliq_sfc_d(temp_d[5]), qv_sfc_d(temp_d[6]);
 
   // Outputs
   view_1d ustar_d("ustar", shcol), kbfs_d("kbfs", shcol), obklen_d("obklen", shcol);
@@ -1151,8 +1209,8 @@ void shoc_diag_obklen_host(Int shcol, Real *uw_sfc, Real *vw_sfc, Real *wthl_sfc
         Scalar kbfs_s{0};
         Scalar obklen_s{0};
 
-        SHF::shoc_diag_obklen(uw_sfc_s, vw_sfc_s, wthl_sfc_s, wqw_sfc_s, thl_sfc_s, cldliq_sfc_s, qv_sfc_s, ustar_s,
-                              kbfs_s, obklen_s);
+        SHF::shoc_diag_obklen(uw_sfc_s, vw_sfc_s, wthl_sfc_s, wqw_sfc_s, thl_sfc_s, cldliq_sfc_s,
+                              qv_sfc_s, ustar_s, kbfs_s, obklen_s);
 
         ustar_d(i)  = ustar_s;
         kbfs_d(i)   = kbfs_s;
@@ -1201,8 +1259,9 @@ void shoc_pblintd_cldcheck_host(Int shcol, Int nlev, Int nlevi, Real *zi, Real *
   ScreamDeepCopy::copy_to_host({pblh}, shcol, inout_views);
 }
 
-void shoc_length_host(Int shcol, Int nlev, Int nlevi, Real *host_dx, Real *host_dy, Real *zt_grid, Real *zi_grid,
-                      Real *dz_zt, Real *tke, Real *thv, Real *brunt, Real *shoc_mix) {
+void shoc_length_host(Int shcol, Int nlev, Int nlevi, Real *host_dx, Real *host_dy, Real *zt_grid,
+                      Real *zi_grid, Real *dz_zt, Real *tke, Real *thv, Real *brunt,
+                      Real *shoc_mix) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -1225,8 +1284,8 @@ void shoc_length_host(Int shcol, Int nlev, Int nlevi, Real *host_dx, Real *host_
   // inputs
   view_1d host_dx_d(temp_1d_d[0]), host_dy_d(temp_1d_d[1]);
 
-  view_2d zt_grid_d(temp_2d_d[0]), zi_grid_d(temp_2d_d[1]), dz_zt_d(temp_2d_d[2]), tke_d(temp_2d_d[3]),
-      thv_d(temp_2d_d[4]), brunt_d(temp_2d_d[5]), shoc_mix_d(temp_2d_d[6]);
+  view_2d zt_grid_d(temp_2d_d[0]), zi_grid_d(temp_2d_d[1]), dz_zt_d(temp_2d_d[2]),
+      tke_d(temp_2d_d[3]), thv_d(temp_2d_d[4]), brunt_d(temp_2d_d[5]), shoc_mix_d(temp_2d_d[6]);
 
   const Int nlev_packs  = ekat::npack<Spack>(nlev);
   const Int nlevi_packs = ekat::npack<Spack>(nlevi);
@@ -1255,8 +1314,8 @@ void shoc_length_host(Int shcol, Int nlev, Int nlevi, Real *host_dx, Real *host_
 
         // Hardcode runtime option for F90 tests.
         const Scalar length_fac = 0.5;
-        SHF::shoc_length(team, nlev, nlevi, length_fac, host_dx_s, host_dy_s, zt_grid_s, zi_grid_s, dz_zt_s, tke_s,
-                         thv_s, workspace, brunt_s, shoc_mix_s);
+        SHF::shoc_length(team, nlev, nlevi, length_fac, host_dx_s, host_dy_s, zt_grid_s, zi_grid_s,
+                         dz_zt_s, tke_s, thv_s, workspace, brunt_s, shoc_mix_s);
       });
 
   // Sync back to host
@@ -1264,10 +1323,10 @@ void shoc_length_host(Int shcol, Int nlev, Int nlevi, Real *host_dx, Real *host_
   ekat::device_to_host({brunt, shoc_mix}, shcol, nlev, inout_views);
 }
 
-void shoc_energy_fixer_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Real *zt_grid, Real *zi_grid,
-                            Real *se_b, Real *ke_b, Real *wv_b, Real *wl_b, Real *se_a, Real *ke_a, Real *wv_a,
-                            Real *wl_a, Real *wthl_sfc, Real *wqw_sfc, Real *rho_zt, Real *tke, Real *pint,
-                            Real *host_dse) {
+void shoc_energy_fixer_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Real *zt_grid,
+                            Real *zi_grid, Real *se_b, Real *ke_b, Real *wv_b, Real *wl_b,
+                            Real *se_a, Real *ke_a, Real *wv_a, Real *wl_a, Real *wthl_sfc,
+                            Real *wqw_sfc, Real *rho_zt, Real *tke, Real *pint, Real *host_dse) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -1279,7 +1338,8 @@ void shoc_energy_fixer_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv
   using MemberType = typename SHF::MemberType;
 
   std::vector<view_1d> temp_1d_d(10);
-  std::vector<const Real *> ptr_array_1d = {se_b, ke_b, wv_b, wl_b, se_a, ke_a, wv_a, wl_a, wthl_sfc, wqw_sfc};
+  std::vector<const Real *> ptr_array_1d = {se_b, ke_b, wv_b, wl_b,     se_a,
+                                            ke_a, wv_a, wl_a, wthl_sfc, wqw_sfc};
   std::vector<view_2d> temp_2d_d(6);
   std::vector<int> dim1_sizes(6, shcol);
   std::vector<int> dim2_sizes            = {nlev, nlevi, nlevi, nlev, nlev, nlev};
@@ -1289,12 +1349,12 @@ void shoc_energy_fixer_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv
   ScreamDeepCopy::copy_to_device(ptr_array_1d, shcol, temp_1d_d);
   ekat::host_to_device(ptr_array_2d, dim1_sizes, dim2_sizes, temp_2d_d);
 
-  view_1d se_b_d(temp_1d_d[0]), ke_b_d(temp_1d_d[1]), wv_b_d(temp_1d_d[2]), wl_b_d(temp_1d_d[3]), se_a_d(temp_1d_d[4]),
-      ke_a_d(temp_1d_d[5]), wv_a_d(temp_1d_d[6]), wl_a_d(temp_1d_d[7]), wthl_sfc_d(temp_1d_d[8]),
-      wqw_sfc_d(temp_1d_d[9]);
+  view_1d se_b_d(temp_1d_d[0]), ke_b_d(temp_1d_d[1]), wv_b_d(temp_1d_d[2]), wl_b_d(temp_1d_d[3]),
+      se_a_d(temp_1d_d[4]), ke_a_d(temp_1d_d[5]), wv_a_d(temp_1d_d[6]), wl_a_d(temp_1d_d[7]),
+      wthl_sfc_d(temp_1d_d[8]), wqw_sfc_d(temp_1d_d[9]);
 
-  view_2d zt_grid_d(temp_2d_d[0]), zi_grid_d(temp_2d_d[1]), pint_d(temp_2d_d[2]), rho_zt_d(temp_2d_d[3]),
-      tke_d(temp_2d_d[4]), host_dse_d(temp_2d_d[5]);
+  view_2d zt_grid_d(temp_2d_d[0]), zi_grid_d(temp_2d_d[1]), pint_d(temp_2d_d[2]),
+      rho_zt_d(temp_2d_d[3]), tke_d(temp_2d_d[4]), host_dse_d(temp_2d_d[5]);
 
   const Int nlev_packs  = ekat::npack<Spack>(nlev);
   const Int nlevi_packs = ekat::npack<Spack>(nlevi);
@@ -1327,9 +1387,9 @@ void shoc_energy_fixer_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv
         const auto tke_s      = ekat::subview(tke_d, i);
         const auto host_dse_s = ekat::subview(host_dse_d, i);
 
-        SHF::shoc_energy_fixer(team, nlev, nlevi, dtime, nadv, zt_grid_s, zi_grid_s, se_b_s, ke_b_s, wv_b_s, wl_b_s,
-                               se_a_s, ke_a_s, wv_a_s, wl_a_s, wthl_sfc_s, wqw_sfc_s, rho_zt_s, tke_s, pint_s,
-                               workspace, host_dse_s);
+        SHF::shoc_energy_fixer(team, nlev, nlevi, dtime, nadv, zt_grid_s, zi_grid_s, se_b_s, ke_b_s,
+                               wv_b_s, wl_b_s, se_a_s, ke_a_s, wv_a_s, wl_a_s, wthl_sfc_s,
+                               wqw_sfc_s, rho_zt_s, tke_s, pint_s, workspace, host_dse_s);
       });
 
   // Sync back to host
@@ -1373,10 +1433,12 @@ void compute_shoc_vapor_host(Int shcol, Int nlev, Real *qw, Real *ql, Real *qv)
   ekat::device_to_host({qv}, shcol, nlev, inout_views);
 }
 
-void update_prognostics_implicit_host(Int shcol, Int nlev, Int nlevi, Int num_tracer, Real dtime, Real *dz_zt,
-                                      Real *dz_zi, Real *rho_zt, Real *zt_grid, Real *zi_grid, Real *tk, Real *tkh,
-                                      Real *uw_sfc, Real *vw_sfc, Real *wthl_sfc, Real *wqw_sfc, Real *wtracer_sfc,
-                                      Real *thetal, Real *qw, Real *tracer, Real *tke, Real *u_wind, Real *v_wind) {
+void update_prognostics_implicit_host(Int shcol, Int nlev, Int nlevi, Int num_tracer, Real dtime,
+                                      Real *dz_zt, Real *dz_zi, Real *rho_zt, Real *zt_grid,
+                                      Real *zi_grid, Real *tk, Real *tkh, Real *uw_sfc,
+                                      Real *vw_sfc, Real *wthl_sfc, Real *wqw_sfc,
+                                      Real *wtracer_sfc, Real *thetal, Real *qw, Real *tracer,
+                                      Real *tke, Real *u_wind, Real *v_wind) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -1395,7 +1457,8 @@ void update_prognostics_implicit_host(Int shcol, Int nlev, Int nlevi, Int num_tr
   std::vector<view_3d> temp_3d_d(1);
 
   std::vector<int> dim1_sizes(num_2d_arrays, shcol);
-  std::vector<int> dim2_sizes = {nlev, nlevi, nlev, nlev, nlevi, nlev, nlev, num_tracer, nlev, nlev, nlev, nlev, nlev};
+  std::vector<int> dim2_sizes         = {nlev,       nlevi, nlev, nlev, nlevi, nlev, nlev,
+                                         num_tracer, nlev,  nlev, nlev, nlev,  nlev};
   std::vector<const Real *> ptr_array = {dz_zt,       dz_zi,  rho_zt, zt_grid, zi_grid, tk,    tkh,
                                          wtracer_sfc, thetal, qw,     tke,     u_wind,  v_wind};
 
@@ -1404,12 +1467,13 @@ void update_prognostics_implicit_host(Int shcol, Int nlev, Int nlevi, Int num_tr
   ekat::host_to_device(ptr_array, dim1_sizes, dim2_sizes, temp_2d_d);
   ekat::host_to_device({tracer}, shcol, nlev, num_tracer, temp_3d_d);
 
-  view_1d uw_sfc_d(temp_1d_d[0]), vw_sfc_d(temp_1d_d[1]), wthl_sfc_d(temp_1d_d[2]), wqw_sfc_d(temp_1d_d[3]);
+  view_1d uw_sfc_d(temp_1d_d[0]), vw_sfc_d(temp_1d_d[1]), wthl_sfc_d(temp_1d_d[2]),
+      wqw_sfc_d(temp_1d_d[3]);
 
-  view_2d dz_zt_d(temp_2d_d[0]), dz_zi_d(temp_2d_d[1]), rho_zt_d(temp_2d_d[2]), zt_grid_d(temp_2d_d[3]),
-      zi_grid_d(temp_2d_d[4]), tk_d(temp_2d_d[5]), tkh_d(temp_2d_d[6]), wtracer_sfc_d(temp_2d_d[7]),
-      thetal_d(temp_2d_d[8]), qw_d(temp_2d_d[9]), tke_d(temp_2d_d[10]), u_wind_d(temp_2d_d[11]),
-      v_wind_d(temp_2d_d[12]);
+  view_2d dz_zt_d(temp_2d_d[0]), dz_zi_d(temp_2d_d[1]), rho_zt_d(temp_2d_d[2]),
+      zt_grid_d(temp_2d_d[3]), zi_grid_d(temp_2d_d[4]), tk_d(temp_2d_d[5]), tkh_d(temp_2d_d[6]),
+      wtracer_sfc_d(temp_2d_d[7]), thetal_d(temp_2d_d[8]), qw_d(temp_2d_d[9]), tke_d(temp_2d_d[10]),
+      u_wind_d(temp_2d_d[11]), v_wind_d(temp_2d_d[12]);
 
   view_3d qtracers_f90_d(temp_3d_d[0]);
 
@@ -1429,8 +1493,9 @@ void update_prognostics_implicit_host(Int shcol, Int nlev, Int nlevi, Int num_tr
       policy, KOKKOS_LAMBDA(const MemberType &team) {
         const int i = team.league_rank();
         Kokkos::parallel_for(Kokkos::TeamThreadRange(team, nlev), [&](const Int &k) {
-          Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_tracer),
-                               [&](const Int &q) { qtracers_cxx_d_s(i, q, k) = qtracers_f90_d_s(i, k, q); });
+          Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_tracer), [&](const Int &q) {
+            qtracers_cxx_d_s(i, q, k) = qtracers_f90_d_s(i, k, q);
+          });
         });
       });
 
@@ -1466,9 +1531,10 @@ void update_prognostics_implicit_host(Int shcol, Int nlev, Int nlevi, Int num_tr
         const auto tke_s         = ekat::subview(tke_d, i);
         const auto tracer_s      = Kokkos::subview(qtracers_cxx_d, i, Kokkos::ALL(), Kokkos::ALL());
 
-        SHF::update_prognostics_implicit(team, nlev, nlevi, num_tracer, dtime, dz_zt_s, dz_zi_s, rho_zt_s, zt_grid_s,
-                                         zi_grid_s, tk_s, tkh_s, uw_sfc_s, vw_sfc_s, wthl_sfc_s, wqw_sfc_s,
-                                         wtracer_sfc_s, workspace, thetal_s, qw_s, tracer_s, tke_s, u_wind_s, v_wind_s);
+        SHF::update_prognostics_implicit(team, nlev, nlevi, num_tracer, dtime, dz_zt_s, dz_zi_s,
+                                         rho_zt_s, zt_grid_s, zi_grid_s, tk_s, tkh_s, uw_sfc_s,
+                                         vw_sfc_s, wthl_sfc_s, wqw_sfc_s, wtracer_sfc_s, workspace,
+                                         thetal_s, qw_s, tracer_s, tke_s, u_wind_s, v_wind_s);
       });
 
   // Transpose tracers
@@ -1476,8 +1542,9 @@ void update_prognostics_implicit_host(Int shcol, Int nlev, Int nlevi, Int num_tr
       policy, KOKKOS_LAMBDA(const MemberType &team) {
         const int i = team.league_rank();
         Kokkos::parallel_for(Kokkos::TeamThreadRange(team, nlev), [&](const Int &k) {
-          Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_tracer),
-                               [&](const Int &q) { qtracers_f90_d_s(i, k, q) = qtracers_cxx_d_s(i, q, k); });
+          Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_tracer), [&](const Int &q) {
+            qtracers_f90_d_s(i, k, q) = qtracers_cxx_d_s(i, q, k);
+          });
         });
       });
 
@@ -1489,9 +1556,10 @@ void update_prognostics_implicit_host(Int shcol, Int nlev, Int nlevi, Int num_tr
   ekat::device_to_host({tracer}, shcol, nlev, num_tracer, inout_views);
 }
 
-void diag_third_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, Real *thl_sec, Real *wthl_sec,
-                                  Real *isotropy, Real *brunt, Real *thetal, Real *tke, Real *dz_zt, Real *dz_zi,
-                                  Real *zt_grid, Real *zi_grid, Real *w3) {
+void diag_third_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, Real *thl_sec,
+                                  Real *wthl_sec, Real *isotropy, Real *brunt, Real *thetal,
+                                  Real *tke, Real *dz_zt, Real *dz_zi, Real *zt_grid, Real *zi_grid,
+                                  Real *w3) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -1502,16 +1570,17 @@ void diag_third_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, R
 
   std::vector<view_2d> temp_d(12);
   std::vector<int> dim1_sizes(12, shcol);
-  std::vector<int> dim2_sizes         = {nlev, nlevi, nlevi, nlev, nlev, nlev, nlev, nlev, nlevi, nlev, nlevi, nlevi};
+  std::vector<int> dim2_sizes         = {nlev, nlevi, nlevi, nlev, nlev,  nlev,
+                                         nlev, nlev,  nlevi, nlev, nlevi, nlevi};
   std::vector<const Real *> ptr_array = {w_sec, thl_sec, wthl_sec, isotropy, brunt,   thetal,
                                          tke,   dz_zt,   dz_zi,    zt_grid,  zi_grid, w3};
 
   // Sync to device
   ekat::host_to_device(ptr_array, dim1_sizes, dim2_sizes, temp_d);
 
-  view_2d wsec_d(temp_d[0]), thl_sec_d(temp_d[1]), wthl_sec_d(temp_d[2]), isotropy_d(temp_d[3]), brunt_d(temp_d[4]),
-      thetal_d(temp_d[5]), tke_d(temp_d[6]), dz_zt_d(temp_d[7]), dz_zi_d(temp_d[8]), zt_grid_d(temp_d[9]),
-      zi_grid_d(temp_d[10]), w3_d(temp_d[11]);
+  view_2d wsec_d(temp_d[0]), thl_sec_d(temp_d[1]), wthl_sec_d(temp_d[2]), isotropy_d(temp_d[3]),
+      brunt_d(temp_d[4]), thetal_d(temp_d[5]), tke_d(temp_d[6]), dz_zt_d(temp_d[7]),
+      dz_zi_d(temp_d[8]), zt_grid_d(temp_d[9]), zi_grid_d(temp_d[10]), w3_d(temp_d[11]);
 
   // Local variables
   const Int nlev_packs  = ekat::npack<Spack>(nlev);
@@ -1542,8 +1611,9 @@ void diag_third_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, R
 
         // Hardcode for F90 testing
         const Real c_diag_3rd_mom = 7.0;
-        SHF::diag_third_shoc_moments(team, nlev, nlevi, c_diag_3rd_mom, wsec_s, thl_sec_s, wthl_sec_s, isotropy_s,
-                                     brunt_s, thetal_s, tke_s, dz_zt_s, dz_zi_s, zt_grid_s, zi_grid_s, workspace, w3_s);
+        SHF::diag_third_shoc_moments(team, nlev, nlevi, c_diag_3rd_mom, wsec_s, thl_sec_s,
+                                     wthl_sec_s, isotropy_s, brunt_s, thetal_s, tke_s, dz_zt_s,
+                                     dz_zi_s, zt_grid_s, zi_grid_s, workspace, w3_s);
       });
 
   // Sync back to host
@@ -1551,8 +1621,8 @@ void diag_third_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, R
   ekat::device_to_host({w3}, shcol, nlevi, inout_views);
 }
 
-void adv_sgs_tke_host(Int nlev, Int shcol, Real dtime, Real *shoc_mix, Real *wthv_sec, Real *sterm_zt, Real *tk,
-                      Real *tke, Real *a_diss) {
+void adv_sgs_tke_host(Int nlev, Int shcol, Real dtime, Real *shoc_mix, Real *wthv_sec,
+                      Real *sterm_zt, Real *tk, Real *tke, Real *a_diss) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -1592,7 +1662,8 @@ void adv_sgs_tke_host(Int nlev, Int shcol, Real dtime, Real *shoc_mix, Real *wth
         const auto tke_s      = ekat::subview(tke_d, i);
         const auto a_diss_s   = ekat::subview(a_diss_d, i);
 
-        SHF::adv_sgs_tke(team, nlev, dtime, shoc_mix_s, wthv_sec_s, sterm_zt_s, tk_s, tke_s, a_diss_s);
+        SHF::adv_sgs_tke(team, nlev, dtime, shoc_mix_s, wthv_sec_s, sterm_zt_s, tk_s, tke_s,
+                         a_diss_s);
       });
 
   // Sync back to host
@@ -1600,10 +1671,11 @@ void adv_sgs_tke_host(Int nlev, Int shcol, Real dtime, Real *shoc_mix, Real *wth
   ekat::device_to_host({tke, a_diss}, shcol, nlev, inout_views);
 }
 
-void shoc_assumed_pdf_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw, Real *w_field, Real *thl_sec,
-                           Real *qw_sec, Real *wthl_sec, Real *w_sec, Real *wqw_sec, Real *qwthl_sec, Real *w3,
-                           Real *pres, Real *zt_grid, Real *zi_grid, Real *shoc_cldfrac, Real *shoc_ql, Real *wqls,
-                           Real *wthv_sec, Real *shoc_ql2) {
+void shoc_assumed_pdf_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw, Real *w_field,
+                           Real *thl_sec, Real *qw_sec, Real *wthl_sec, Real *w_sec, Real *wqw_sec,
+                           Real *qwthl_sec, Real *w3, Real *pres, Real *zt_grid, Real *zi_grid,
+                           Real *shoc_cldfrac, Real *shoc_ql, Real *wqls, Real *wthv_sec,
+                           Real *shoc_ql2) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -1618,17 +1690,18 @@ void shoc_assumed_pdf_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *q
   std::vector<int> dim1_sizes(num_arrays, shcol);
   std::vector<int> dim2_sizes         = {nlev, nlev, nlevi, nlevi, nlevi, nlev, nlevi, nlevi, nlevi,
                                          nlev, nlev, nlev,  nlevi, nlev,  nlev, nlev,  nlev,  nlev};
-  std::vector<const Real *> ptr_array = {thetal,  qw,           thl_sec, qw_sec,  wthl_sec, w_sec,
-                                         wqw_sec, qwthl_sec,    w3,      w_field, pres,     zt_grid,
-                                         zi_grid, shoc_cldfrac, shoc_ql, wqls,    wthv_sec, shoc_ql2};
+  std::vector<const Real *> ptr_array = {
+      thetal,  qw,   thl_sec, qw_sec,  wthl_sec,     w_sec,   wqw_sec, qwthl_sec, w3,
+      w_field, pres, zt_grid, zi_grid, shoc_cldfrac, shoc_ql, wqls,    wthv_sec,  shoc_ql2};
   // Sync to device
   ekat::host_to_device(ptr_array, dim1_sizes, dim2_sizes, temp_d);
 
   // Inputs/Outputs
-  view_2d thetal_d(temp_d[0]), qw_d(temp_d[1]), thl_sec_d(temp_d[2]), qw_sec_d(temp_d[3]), wthl_sec_d(temp_d[4]),
-      w_sec_d(temp_d[5]), wqw_sec_d(temp_d[6]), qwthl_sec_d(temp_d[7]), w3_d(temp_d[8]), w_field_d(temp_d[9]),
-      pres_d(temp_d[10]), zt_grid_d(temp_d[11]), zi_grid_d(temp_d[12]), shoc_cldfrac_d(temp_d[13]),
-      shoc_ql_d(temp_d[14]), wqls_d(temp_d[15]), wthv_sec_d(temp_d[16]), shoc_ql2_d(temp_d[17]);
+  view_2d thetal_d(temp_d[0]), qw_d(temp_d[1]), thl_sec_d(temp_d[2]), qw_sec_d(temp_d[3]),
+      wthl_sec_d(temp_d[4]), w_sec_d(temp_d[5]), wqw_sec_d(temp_d[6]), qwthl_sec_d(temp_d[7]),
+      w3_d(temp_d[8]), w_field_d(temp_d[9]), pres_d(temp_d[10]), zt_grid_d(temp_d[11]),
+      zi_grid_d(temp_d[12]), shoc_cldfrac_d(temp_d[13]), shoc_ql_d(temp_d[14]), wqls_d(temp_d[15]),
+      wthv_sec_d(temp_d[16]), shoc_ql2_d(temp_d[17]);
 
   const Int nlev_packs = ekat::npack<Spack>(nlev);
   const auto policy    = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(shcol, nlev_packs);
@@ -1661,16 +1734,18 @@ void shoc_assumed_pdf_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *q
         const auto wthv_sec_s     = ekat::subview(wthv_sec_d, i);
         const auto shoc_ql2_s     = ekat::subview(shoc_ql2_d, i);
 
-        SHF::shoc_assumed_pdf(team, nlev, nlevi, thetal_s, qw_s, w_field_s, thl_sec_s, qw_sec_s, wthl_sec_s, w_sec_s,
-                              wqw_sec_s, qwthl_sec_s, w3_s, pres_s, zt_grid_s, zi_grid_s, workspace, shoc_cldfrac_s,
-                              shoc_ql_s, wqls_s, wthv_sec_s, shoc_ql2_s);
+        SHF::shoc_assumed_pdf(team, nlev, nlevi, thetal_s, qw_s, w_field_s, thl_sec_s, qw_sec_s,
+                              wthl_sec_s, w_sec_s, wqw_sec_s, qwthl_sec_s, w3_s, pres_s, zt_grid_s,
+                              zi_grid_s, workspace, shoc_cldfrac_s, shoc_ql_s, wqls_s, wthv_sec_s,
+                              shoc_ql2_s);
       });
 
   // Sync back to host
   std::vector<view_2d> out_views = {shoc_cldfrac_d, shoc_ql_d, wqls_d, wthv_sec_d, shoc_ql2_d};
   ekat::device_to_host({shoc_cldfrac, shoc_ql, wqls, wthv_sec, shoc_ql2}, shcol, nlev, out_views);
 }
-void compute_shr_prod_host(Int nlevi, Int nlev, Int shcol, Real *dz_zi, Real *u_wind, Real *v_wind, Real *sterm) {
+void compute_shr_prod_host(Int nlevi, Int nlev, Int shcol, Real *dz_zi, Real *u_wind, Real *v_wind,
+                           Real *sterm) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -1754,7 +1829,8 @@ void compute_tmpi_host(Int nlevi, Int shcol, Real dtime, Real *rho_zi, Real *dz_
   ekat::device_to_host({tmpi}, shcol, nlevi, inout_views);
 }
 
-void integ_column_stability_host(Int nlev, Int shcol, Real *dz_zt, Real *pres, Real *brunt, Real *brunt_int) {
+void integ_column_stability_host(Int nlev, Int shcol, Real *dz_zt, Real *pres, Real *brunt,
+                                 Real *brunt_int) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -1802,7 +1878,8 @@ void integ_column_stability_host(Int nlev, Int shcol, Real *dz_zt, Real *pres, R
   ScreamDeepCopy::copy_to_host({brunt_int}, shcol, inout_views);
 }
 
-void isotropic_ts_host(Int nlev, Int shcol, Real *brunt_int, Real *tke, Real *a_diss, Real *brunt, Real *isotropy) {
+void isotropic_ts_host(Int nlev, Int shcol, Real *brunt_int, Real *tke, Real *a_diss, Real *brunt,
+                       Real *isotropy) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -1851,8 +1928,8 @@ void isotropic_ts_host(Int nlev, Int shcol, Real *brunt_int, Real *tke, Real *a_
         const Real lambda_high   = 0.08;
         const Real lambda_slope  = 2.65;
         const Real lambda_thresh = 0.02;
-        SHF::isotropic_ts(team, nlev, lambda_low, lambda_high, lambda_slope, lambda_thresh, brunt_int_s, tke_s,
-                          a_diss_s, brunt_s, isotropy_s);
+        SHF::isotropic_ts(team, nlev, lambda_low, lambda_high, lambda_slope, lambda_thresh,
+                          brunt_int_s, tke_s, a_diss_s, brunt_s, isotropy_s);
       });
 
   // Sync back to host
@@ -1909,14 +1986,16 @@ int shoc_init_host(Int nlev, Real *pref_mid, Int nbot_shoc, Int ntop_shoc) {
   return SHF::shoc_init(nbot_shoc, ntop_shoc, pref_mid_d);
 }
 
-Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npbl, Real *host_dx, Real *host_dy,
-                   Real *thv, Real *zt_grid, Real *zi_grid, Real *pres, Real *presi, Real *pdel, Real *wthl_sfc,
-                   Real *wqw_sfc, Real *uw_sfc, Real *vw_sfc, Real *wtracer_sfc, Int num_qtracers, Real *w_field,
-                   Real *inv_exner, Real *phis, Real *host_dse, Real *tke, Real *thetal, Real *qw, Real *u_wind,
-                   Real *v_wind, Real *qtracers, Real *wthv_sec, Real *tkh, Real *tk, Real *shoc_ql, Real *shoc_cldfrac,
-                   Real *pblh, Real *shoc_mix, Real *isotropy, Real *w_sec, Real *thl_sec, Real *qw_sec,
-                   Real *qwthl_sec, Real *wthl_sec, Real *wqw_sec, Real *wtke_sec, Real *uw_sec, Real *vw_sec, Real *w3,
-                   Real *wqls_sec, Real *brunt, Real *shoc_ql2) {
+Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npbl, Real *host_dx,
+                   Real *host_dy, Real *thv, Real *zt_grid, Real *zi_grid, Real *pres, Real *presi,
+                   Real *pdel, Real *wthl_sfc, Real *wqw_sfc, Real *uw_sfc, Real *vw_sfc,
+                   Real *wtracer_sfc, Int num_qtracers, Real *w_field, Real *inv_exner, Real *phis,
+                   Real *host_dse, Real *tke, Real *thetal, Real *qw, Real *u_wind, Real *v_wind,
+                   Real *qtracers, Real *wthv_sec, Real *tkh, Real *tk, Real *shoc_ql,
+                   Real *shoc_cldfrac, Real *pblh, Real *shoc_mix, Real *isotropy, Real *w_sec,
+                   Real *thl_sec, Real *qw_sec, Real *qwthl_sec, Real *wthl_sec, Real *wqw_sec,
+                   Real *wtke_sec, Real *uw_sec, Real *vw_sec, Real *w3, Real *wqls_sec,
+                   Real *brunt, Real *shoc_ql2) {
 
   using SHF = Functions<Real, DefaultDevice>;
 
@@ -1937,15 +2016,17 @@ Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npb
   std::vector<view_2d> temp_2d_d(num_2d_arrays);
   std::vector<view_3d> temp_3d_d(num_3d_arrays);
 
-  std::vector<int> dim1_2d_sizes = {shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol,
-                                    shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol,
-                                    shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol};
-  std::vector<int> dim2_2d_sizes = {nlev,  nlevi, nlev,  nlevi, nlev,  nlev,  nlev,  num_qtracers, nlev,
-                                    nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,         nlev,
-                                    nlev,  nlev,  nlev,  nlev,  nlev,  nlevi, nlevi, nlevi,        nlevi,
-                                    nlevi, nlevi, nlevi, nlevi, nlevi, nlev,  nlev,  nlev};
+  std::vector<int> dim1_2d_sizes = {shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol,
+                                    shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol,
+                                    shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol,
+                                    shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol};
+  std::vector<int> dim2_2d_sizes = {
+      nlev,  nlevi, nlev,  nlevi, nlev,  nlev,  nlev,  num_qtracers, nlev, nlev, nlev, nlev,
+      nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,         nlev, nlev, nlev, nlevi,
+      nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi,        nlev, nlev, nlev};
 
-  std::vector<const Real *> ptr_array_1d = {host_dx, host_dy, wthl_sfc, wqw_sfc, uw_sfc, vw_sfc, phis};
+  std::vector<const Real *> ptr_array_1d = {host_dx, host_dy, wthl_sfc, wqw_sfc,
+                                            uw_sfc,  vw_sfc,  phis};
   std::vector<const Real *> ptr_array_2d = {
       zt_grid,  zi_grid,  pres,   presi,    pdel,   thv,      w_field,  wtracer_sfc, inv_exner,
       host_dse, tke,      thetal, qw,       u_wind, v_wind,   wthv_sec, tk,          shoc_cldfrac,
@@ -1959,23 +2040,27 @@ Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npb
   Int index_counter = 0;
   view_1d host_dx_d(temp_1d_d[index_counter++]), host_dy_d(temp_1d_d[index_counter++]),
       wthl_sfc_d(temp_1d_d[index_counter++]), wqw_sfc_d(temp_1d_d[index_counter++]),
-      uw_sfc_d(temp_1d_d[index_counter++]), vw_sfc_d(temp_1d_d[index_counter++]), phis_d(temp_1d_d[index_counter++]),
-      pblh_d("pblh", shcol), ustar_d("ustar", shcol), obklen_d("obklen", shcol);
+      uw_sfc_d(temp_1d_d[index_counter++]), vw_sfc_d(temp_1d_d[index_counter++]),
+      phis_d(temp_1d_d[index_counter++]), pblh_d("pblh", shcol), ustar_d("ustar", shcol),
+      obklen_d("obklen", shcol);
 
   index_counter = 0;
   view_2d zt_grid_d(temp_2d_d[index_counter++]), zi_grid_d(temp_2d_d[index_counter++]),
-      pres_d(temp_2d_d[index_counter++]), presi_d(temp_2d_d[index_counter++]), pdel_d(temp_2d_d[index_counter++]),
-      thv_d(temp_2d_d[index_counter++]), w_field_d(temp_2d_d[index_counter++]),
-      wtracer_sfc_d(temp_2d_d[index_counter++]), inv_exner_d(temp_2d_d[index_counter++]),
-      host_dse_d(temp_2d_d[index_counter++]), tke_d(temp_2d_d[index_counter++]), thetal_d(temp_2d_d[index_counter++]),
-      qw_d(temp_2d_d[index_counter++]), u_wind_d(temp_2d_d[index_counter++]), v_wind_d(temp_2d_d[index_counter++]),
-      wthv_sec_d(temp_2d_d[index_counter++]), tk_d(temp_2d_d[index_counter++]),
-      shoc_cldfrac_d(temp_2d_d[index_counter++]), shoc_ql_d(temp_2d_d[index_counter++]),
-      shoc_ql2_d(temp_2d_d[index_counter++]), tkh_d(temp_2d_d[index_counter++]), shoc_mix_d(temp_2d_d[index_counter++]),
-      w_sec_d(temp_2d_d[index_counter++]), thl_sec_d(temp_2d_d[index_counter++]), qw_sec_d(temp_2d_d[index_counter++]),
-      qwthl_sec_d(temp_2d_d[index_counter++]), wthl_sec_d(temp_2d_d[index_counter++]),
-      wqw_sec_d(temp_2d_d[index_counter++]), wtke_sec_d(temp_2d_d[index_counter++]),
-      uw_sec_d(temp_2d_d[index_counter++]), vw_sec_d(temp_2d_d[index_counter++]), w3_d(temp_2d_d[index_counter++]),
+      pres_d(temp_2d_d[index_counter++]), presi_d(temp_2d_d[index_counter++]),
+      pdel_d(temp_2d_d[index_counter++]), thv_d(temp_2d_d[index_counter++]),
+      w_field_d(temp_2d_d[index_counter++]), wtracer_sfc_d(temp_2d_d[index_counter++]),
+      inv_exner_d(temp_2d_d[index_counter++]), host_dse_d(temp_2d_d[index_counter++]),
+      tke_d(temp_2d_d[index_counter++]), thetal_d(temp_2d_d[index_counter++]),
+      qw_d(temp_2d_d[index_counter++]), u_wind_d(temp_2d_d[index_counter++]),
+      v_wind_d(temp_2d_d[index_counter++]), wthv_sec_d(temp_2d_d[index_counter++]),
+      tk_d(temp_2d_d[index_counter++]), shoc_cldfrac_d(temp_2d_d[index_counter++]),
+      shoc_ql_d(temp_2d_d[index_counter++]), shoc_ql2_d(temp_2d_d[index_counter++]),
+      tkh_d(temp_2d_d[index_counter++]), shoc_mix_d(temp_2d_d[index_counter++]),
+      w_sec_d(temp_2d_d[index_counter++]), thl_sec_d(temp_2d_d[index_counter++]),
+      qw_sec_d(temp_2d_d[index_counter++]), qwthl_sec_d(temp_2d_d[index_counter++]),
+      wthl_sec_d(temp_2d_d[index_counter++]), wqw_sec_d(temp_2d_d[index_counter++]),
+      wtke_sec_d(temp_2d_d[index_counter++]), uw_sec_d(temp_2d_d[index_counter++]),
+      vw_sec_d(temp_2d_d[index_counter++]), w3_d(temp_2d_d[index_counter++]),
       wqls_sec_d(temp_2d_d[index_counter++]), brunt_d(temp_2d_d[index_counter++]),
       isotropy_d(temp_2d_d[index_counter++]);
 
@@ -2002,31 +2087,36 @@ Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npb
           horiz_wind_d_s(i, 0, k) = u_wind_d_s(i, k);
           horiz_wind_d_s(i, 1, k) = v_wind_d_s(i, k);
 
-          Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_qtracers),
-                               [&](const Int &q) { qtracers_cxx_d_s(i, q, k) = qtracers_f90_d_s(i, k, q); });
+          Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_qtracers), [&](const Int &q) {
+            qtracers_cxx_d_s(i, q, k) = qtracers_f90_d_s(i, k, q);
+          });
         });
       });
 
   // Pack our data into structs and ship it off to shoc_main.
-  SHF::SHOCInput shoc_input{host_dx_d, host_dy_d,  zt_grid_d, zi_grid_d, pres_d,   presi_d,       pdel_d,      thv_d,
-                            w_field_d, wthl_sfc_d, wqw_sfc_d, uw_sfc_d,  vw_sfc_d, wtracer_sfc_d, inv_exner_d, phis_d};
-  SHF::SHOCInputOutput shoc_input_output{host_dse_d, tke_d,          thetal_d, qw_d,           horiz_wind_d,
-                                         wthv_sec_d, qtracers_cxx_d, tk_d,     shoc_cldfrac_d, shoc_ql_d};
+  SHF::SHOCInput shoc_input{host_dx_d, host_dy_d,     zt_grid_d,   zi_grid_d,  pres_d,    presi_d,
+                            pdel_d,    thv_d,         w_field_d,   wthl_sfc_d, wqw_sfc_d, uw_sfc_d,
+                            vw_sfc_d,  wtracer_sfc_d, inv_exner_d, phis_d};
+  SHF::SHOCInputOutput shoc_input_output{host_dse_d,     tke_d,      thetal_d,       qw_d,
+                                         horiz_wind_d,   wthv_sec_d, qtracers_cxx_d, tk_d,
+                                         shoc_cldfrac_d, shoc_ql_d};
   SHF::SHOCOutput shoc_output{pblh_d, ustar_d, obklen_d, shoc_ql2_d, tkh_d};
-  SHF::SHOCHistoryOutput shoc_history_output{shoc_mix_d, w_sec_d,    thl_sec_d,  qw_sec_d,  qwthl_sec_d,
-                                             wthl_sec_d, wqw_sec_d,  wtke_sec_d, uw_sec_d,  vw_sec_d,
-                                             w3_d,       wqls_sec_d, brunt_d,    isotropy_d};
-  SHF::SHOCRuntime shoc_runtime_options{0.001, 0.04, 2.65, 0.02, 1.0, 1.0, 1.0, 1.0, 0.5, 7.0, 0.1, 0.1};
+  SHF::SHOCHistoryOutput shoc_history_output{
+      shoc_mix_d, w_sec_d,  thl_sec_d, qw_sec_d, qwthl_sec_d, wthl_sec_d, wqw_sec_d,
+      wtke_sec_d, uw_sec_d, vw_sec_d,  w3_d,     wqls_sec_d,  brunt_d,    isotropy_d};
+  SHF::SHOCRuntime shoc_runtime_options{0.001, 0.04, 2.65, 0.02, 1.0, 1.0,
+                                        1.0,   1.0,  0.5,  7.0,  0.1, 0.1};
 
   const auto nlevi_packs = ekat::npack<Spack>(nlevi);
 
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-  view_1d se_b("se_b", shcol), ke_b("ke_b", shcol), wv_b("wv_b", shcol), wl_b("wl_b", shcol), se_a("se_a", shcol),
-      ke_a("ke_a", shcol), wv_a("wv_a", shcol), wl_a("wl_a", shcol), kbfs("kbfs", shcol), ustar2("ustar2", shcol),
-      wstar("wstar", shcol);
+  view_1d se_b("se_b", shcol), ke_b("ke_b", shcol), wv_b("wv_b", shcol), wl_b("wl_b", shcol),
+      se_a("se_a", shcol), ke_a("ke_a", shcol), wv_a("wv_a", shcol), wl_a("wl_a", shcol),
+      kbfs("kbfs", shcol), ustar2("ustar2", shcol), wstar("wstar", shcol);
 
   view_2d rho_zt("rho_zt", shcol, nlevi_packs), shoc_qv("shoc_qv", shcol, nlevi_packs),
-      tabs("shoc_tabs", shcol, nlev_packs), dz_zt("dz_zt", shcol, nlevi_packs), dz_zi("dz_zi", shcol, nlevi_packs);
+      tabs("shoc_tabs", shcol, nlev_packs), dz_zt("dz_zt", shcol, nlevi_packs),
+      dz_zi("dz_zi", shcol, nlevi_packs);
 
   SHF::SHOCTemporaries shoc_temporaries{se_b, ke_b,   wv_b,  wl_b,   se_a,    ke_a, wv_a,  wl_a,
                                         kbfs, ustar2, wstar, rho_zt, shoc_qv, tabs, dz_zt, dz_zi};
@@ -2035,16 +2125,17 @@ Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npb
   // Create local workspace
   const int n_wind_slots = ekat::npack<Spack>(2) * Spack::n;
   const int n_trac_slots = ekat::npack<Spack>(num_qtracers + 3) * Spack::n;
-  ekat::WorkspaceManager<Spack, SHF::KT::Device> workspace_mgr(nlevi_packs, 14 + (n_wind_slots + n_trac_slots), policy);
+  ekat::WorkspaceManager<Spack, SHF::KT::Device> workspace_mgr(
+      nlevi_packs, 14 + (n_wind_slots + n_trac_slots), policy);
 
-  const auto elapsed_microsec =
-      SHF::shoc_main(shcol, nlev, nlevi, npbl, nadv, num_qtracers, dtime, workspace_mgr, shoc_runtime_options,
-                     shoc_input, shoc_input_output, shoc_output, shoc_history_output
+  const auto elapsed_microsec = SHF::shoc_main(shcol, nlev, nlevi, npbl, nadv, num_qtracers, dtime,
+                                               workspace_mgr, shoc_runtime_options, shoc_input,
+                                               shoc_input_output, shoc_output, shoc_history_output
 #ifdef SCREAM_SHOC_SMALL_KERNELS
-                     ,
-                     shoc_temporaries
+                                               ,
+                                               shoc_temporaries
 #endif
-      );
+  );
 
   // Copy wind back into separate views and
   // Transpose tracers
@@ -2055,8 +2146,9 @@ Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npb
           u_wind_d_s(i, k) = horiz_wind_d_s(i, 0, k);
           v_wind_d_s(i, k) = horiz_wind_d_s(i, 1, k);
 
-          Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_qtracers),
-                               [&](const Int &q) { qtracers_f90_d_s(i, k, q) = qtracers_cxx_d_s(i, q, k); });
+          Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, num_qtracers), [&](const Int &q) {
+            qtracers_f90_d_s(i, k, q) = qtracers_cxx_d_s(i, q, k);
+          });
         });
       });
 
@@ -2069,16 +2161,18 @@ Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npb
   std::vector<int> dim1_2d_out = {shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol,
                                   shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol, shcol,
                                   shcol, shcol, shcol, shcol, shcol, shcol, shcol};
-  std::vector<int> dim2_2d_out = {nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev, nlev, nlev, nlev,
-                                  nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlevi, nlev, nlev, nlev};
-  std::vector<Real *> ptr_array_2d_out = {host_dse, tke,          thetal,   qw,       u_wind,   v_wind, wthv_sec,
-                                          tk,       shoc_cldfrac, shoc_ql,  shoc_ql2, shoc_mix, w_sec,  thl_sec,
-                                          qw_sec,   qwthl_sec,    wthl_sec, wqw_sec,  wtke_sec, uw_sec, vw_sec,
-                                          w3,       wqls_sec,     brunt,    isotropy};
-  std::vector<view_2d> out_views_2d    = {
-      host_dse_d, tke_d,      thetal_d,   qw_d,    u_wind_d,   v_wind_d, wthv_sec_d,  tk_d,       shoc_cldfrac_d,
-      shoc_ql_d,  shoc_ql2_d, shoc_mix_d, w_sec_d, thl_sec_d,  qw_sec_d, qwthl_sec_d, wthl_sec_d, wqw_sec_d,
-      wtke_sec_d, uw_sec_d,   vw_sec_d,   w3_d,    wqls_sec_d, brunt_d,  isotropy_d};
+  std::vector<int> dim2_2d_out = {nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,  nlev,
+                                  nlev,  nlev,  nlev,  nlev,  nlevi, nlevi, nlevi, nlevi, nlevi,
+                                  nlevi, nlevi, nlevi, nlevi, nlev,  nlev,  nlev};
+  std::vector<Real *> ptr_array_2d_out = {
+      host_dse, tke,      thetal,   qw,    u_wind,   v_wind, wthv_sec,  tk,       shoc_cldfrac,
+      shoc_ql,  shoc_ql2, shoc_mix, w_sec, thl_sec,  qw_sec, qwthl_sec, wthl_sec, wqw_sec,
+      wtke_sec, uw_sec,   vw_sec,   w3,    wqls_sec, brunt,  isotropy};
+  std::vector<view_2d> out_views_2d = {
+      host_dse_d, tke_d,          thetal_d,   qw_d,       u_wind_d,   v_wind_d, wthv_sec_d,
+      tk_d,       shoc_cldfrac_d, shoc_ql_d,  shoc_ql2_d, shoc_mix_d, w_sec_d,  thl_sec_d,
+      qw_sec_d,   qwthl_sec_d,    wthl_sec_d, wqw_sec_d,  wtke_sec_d, uw_sec_d, vw_sec_d,
+      w3_d,       wqls_sec_d,     brunt_d,    isotropy_d};
   ekat::device_to_host(ptr_array_2d_out, dim1_2d_out, dim2_2d_out, out_views_2d);
 
   // 3d
@@ -2088,8 +2182,8 @@ Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npb
   return elapsed_microsec;
 }
 
-void pblintd_height_host(Int shcol, Int nlev, Int npbl, Real *z, Real *u, Real *v, Real *ustar, Real *thv,
-                         Real *thv_ref, Real *pblh, Real *rino, bool *check) {
+void pblintd_height_host(Int shcol, Int nlev, Int npbl, Real *z, Real *u, Real *v, Real *ustar,
+                         Real *thv, Real *thv_ref, Real *pblh, Real *rino, bool *check) {
   using SHOC       = Functions<Real, DefaultDevice>;
   using Spack      = typename SHOC::Spack;
   using Scalar     = typename SHOC::Scalar;
@@ -2102,7 +2196,8 @@ void pblintd_height_host(Int shcol, Int nlev, Int npbl, Real *z, Real *u, Real *
   std::vector<view_2d> views_2d(5);
   ekat::host_to_device({z, u, v, thv, rino}, shcol, nlev, views_2d);
 
-  view_2d z_2d(views_2d[0]), u_2d(views_2d[1]), v_2d(views_2d[2]), thv_2d(views_2d[3]), rino_2d(views_2d[4]);
+  view_2d z_2d(views_2d[0]), u_2d(views_2d[1]), v_2d(views_2d[2]), thv_2d(views_2d[3]),
+      rino_2d(views_2d[4]);
 
   std::vector<view_1d> views_1d(3);
   ScreamDeepCopy::copy_to_device({ustar, thv_ref, pblh}, shcol, views_1d);
@@ -2129,7 +2224,8 @@ void pblintd_height_host(Int shcol, Int nlev, Int npbl, Real *z, Real *u, Real *
         Scalar &pblh_s    = pblh_1d(i);
         bool &check_s     = check_1d(i);
 
-        SHOC::pblintd_height(team, nlev, npbl, z_1d, u_1d, v_1d, ustar_s, thv_1d, thv_ref_s, pblh_s, rino_1d, check_s);
+        SHOC::pblintd_height(team, nlev, npbl, z_1d, u_1d, v_1d, ustar_s, thv_1d, thv_ref_s, pblh_s,
+                             rino_1d, check_s);
       });
 
   std::vector<view_1d> out_1d_views = {pblh_1d};
@@ -2142,8 +2238,8 @@ void pblintd_height_host(Int shcol, Int nlev, Int npbl, Real *z, Real *u, Real *
   ScreamDeepCopy::copy_to_host({check}, shcol, out_bool_1d_views);
 }
 
-void vd_shoc_decomp_and_solve_host(Int shcol, Int nlev, Int nlevi, Int num_rhs, Real dtime, Real *kv_term, Real *tmpi,
-                                   Real *rdp_zt, Real *flux, Real *var) {
+void vd_shoc_decomp_and_solve_host(Int shcol, Int nlev, Int nlevi, Int num_rhs, Real dtime,
+                                   Real *kv_term, Real *tmpi, Real *rdp_zt, Real *flux, Real *var) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar         = typename SHF::Scalar;
@@ -2196,7 +2292,8 @@ void vd_shoc_decomp_and_solve_host(Int shcol, Int nlev, Int nlevi, Int num_rhs,
         const auto d_s       = ekat::subview(d_d, i);
         const auto var_s     = Kokkos::subview(var_d, i, Kokkos::ALL(), Kokkos::ALL());
 
-        SHF::vd_shoc_decomp(team, nlev, kv_term_s, tmpi_s, rdp_zt_s, dtime, flux_s, du_s, dl_s, d_s);
+        SHF::vd_shoc_decomp(team, nlev, kv_term_s, tmpi_s, rdp_zt_s, dtime, flux_s, du_s, dl_s,
+                            d_s);
         team.team_barrier();
         SHF::vd_shoc_solve(team, du_s, dl_s, d_s, var_s);
       });
@@ -2206,8 +2303,8 @@ void vd_shoc_decomp_and_solve_host(Int shcol, Int nlev, Int nlevi, Int num_rhs,
   ekat::device_to_host({var}, shcol, nlev, num_rhs, inout_views);
 }
 
-void shoc_grid_host(Int shcol, Int nlev, Int nlevi, Real *zt_grid, Real *zi_grid, Real *pdel, Real *dz_zt, Real *dz_zi,
-                    Real *rho_zt) {
+void shoc_grid_host(Int shcol, Int nlev, Int nlevi, Real *zt_grid, Real *zi_grid, Real *pdel,
+                    Real *dz_zt, Real *dz_zi, Real *rho_zt) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -2225,8 +2322,8 @@ void shoc_grid_host(Int shcol, Int nlev, Int nlevi, Real *zt_grid, Real *zi_grid
   // Sync to device
   ekat::host_to_device(ptr_array, dim1_sizes, dim2_sizes, temp_2d_d);
 
-  view_2d zt_grid_d(temp_2d_d[0]), zi_grid_d(temp_2d_d[1]), pdel_d(temp_2d_d[2]), dz_zt_d(temp_2d_d[3]),
-      dz_zi_d(temp_2d_d[4]), rho_zt_d(temp_2d_d[5]);
+  view_2d zt_grid_d(temp_2d_d[0]), zi_grid_d(temp_2d_d[1]), pdel_d(temp_2d_d[2]),
+      dz_zt_d(temp_2d_d[3]), dz_zi_d(temp_2d_d[4]), rho_zt_d(temp_2d_d[5]);
 
   const Int nk_pack = ekat::npack<Spack>(nlev);
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(shcol, nk_pack);
@@ -2246,11 +2343,13 @@ void shoc_grid_host(Int shcol, Int nlev, Int nlevi, Real *zt_grid, Real *zi_grid
 
   // Sync back to host
   std::vector<view_2d> inout_views = {dz_zt_d, dz_zi_d, rho_zt_d};
-  ekat::device_to_host<Int>({dz_zt, dz_zi, rho_zt}, {shcol, shcol, shcol}, {nlev, nlevi, nlev}, inout_views);
+  ekat::device_to_host<Int>({dz_zt, dz_zi, rho_zt}, {shcol, shcol, shcol}, {nlev, nlevi, nlev},
+                            inout_views);
 }
 
-void eddy_diffusivities_host(Int nlev, Int shcol, Real *pblh, Real *zt_grid, Real *tabs, Real *shoc_mix, Real *sterm_zt,
-                             Real *isotropy, Real *tke, Real *tkh, Real *tk) {
+void eddy_diffusivities_host(Int nlev, Int shcol, Real *pblh, Real *zt_grid, Real *tabs,
+                             Real *shoc_mix, Real *sterm_zt, Real *isotropy, Real *tke, Real *tkh,
+                             Real *tk) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -2275,8 +2374,9 @@ void eddy_diffusivities_host(Int nlev, Int shcol, Real *pblh, Real *zt_grid, Rea
 
   view_1d pblh_d(temp_1d_d[0]);
 
-  view_2d zt_grid_d(temp_2d_d[0]), tabs_d(temp_2d_d[1]), shoc_mix_d(temp_2d_d[2]), sterm_zt_d(temp_2d_d[3]),
-      isotropy_d(temp_2d_d[4]), tke_d(temp_2d_d[5]), tkh_d(temp_2d_d[6]), tk_d(temp_2d_d[7]);
+  view_2d zt_grid_d(temp_2d_d[0]), tabs_d(temp_2d_d[1]), shoc_mix_d(temp_2d_d[2]),
+      sterm_zt_d(temp_2d_d[3]), isotropy_d(temp_2d_d[4]), tke_d(temp_2d_d[5]), tkh_d(temp_2d_d[6]),
+      tk_d(temp_2d_d[7]);
 
   const Int nk_pack = ekat::npack<Spack>(nlev);
   const auto policy = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(shcol, nk_pack);
@@ -2298,8 +2398,8 @@ void eddy_diffusivities_host(Int nlev, Int shcol, Real *pblh, Real *zt_grid, Rea
         // Hardcode runtime options for F90 testing
         const Real Ckh = 0.1;
         const Real Ckm = 0.1;
-        SHF::eddy_diffusivities(team, nlev, Ckh, Ckm, pblh_s, zt_grid_s, tabs_s, shoc_mix_s, sterm_zt_s, isotropy_s,
-                                tke_s, tkh_s, tk_s);
+        SHF::eddy_diffusivities(team, nlev, Ckh, Ckm, pblh_s, zt_grid_s, tabs_s, shoc_mix_s,
+                                sterm_zt_s, isotropy_s, tke_s, tkh_s, tk_s);
       });
 
   // Sync back to host
@@ -2307,8 +2407,8 @@ void eddy_diffusivities_host(Int nlev, Int shcol, Real *pblh, Real *zt_grid, Rea
   ekat::device_to_host({tkh, tk}, shcol, nlev, inout_views);
 }
 
-void pblintd_surf_temp_host(Int shcol, Int nlev, Int nlevi, Real *z, Real *ustar, Real *obklen, Real *kbfs, Real *thv,
-                            Real *tlv, Real *pblh, bool *check, Real *rino) {
+void pblintd_surf_temp_host(Int shcol, Int nlev, Int nlevi, Real *z, Real *ustar, Real *obklen,
+                            Real *kbfs, Real *thv, Real *tlv, Real *pblh, bool *check, Real *rino) {
   using SHOC         = Functions<Real, DefaultDevice>;
   using Spack        = typename SHOC::Spack;
   using Scalar       = typename SHOC::Scalar;
@@ -2345,8 +2445,8 @@ void pblintd_surf_temp_host(Int shcol, Int nlev, Int nlevi, Real *z, Real *ustar
         Scalar &tlv_s = tlv_1d(i);
         bool &check_s = check_1d(i);
 
-        SHOC::pblintd_surf_temp(nlev, nlevi, npbl, z_1d, ustar_s, obklen_s, kbfs_s, thv_1d, tlv_s, pblh_s, check_s,
-                                rino_1d);
+        SHOC::pblintd_surf_temp(nlev, nlevi, npbl, z_1d, ustar_s, obklen_s, kbfs_s, thv_1d, tlv_s,
+                                pblh_s, check_s, rino_1d);
       });
 
   std::vector<view_1d> out_1d_views = {pblh_1d, tlv_1d};
@@ -2359,7 +2459,8 @@ void pblintd_surf_temp_host(Int shcol, Int nlev, Int nlevi, Real *z, Real *ustar
   ScreamDeepCopy::copy_to_host({check}, shcol, out_bool_1d_views);
 }
 
-void pblintd_check_pblh_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *ustar, bool *check, Real *pblh) {
+void pblintd_check_pblh_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *ustar,
+                             bool *check, Real *pblh) {
   using SHOC         = Functions<Real, DefaultDevice>;
   using Spack        = typename SHOC::Spack;
   using Scalar       = typename SHOC::Scalar;
@@ -2393,8 +2494,9 @@ void pblintd_check_pblh_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z,
   ScreamDeepCopy::copy_to_host({pblh}, shcol, out_1d_views);
 }
 
-void pblintd_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *zi, Real *thl, Real *ql, Real *q, Real *u,
-                  Real *v, Real *ustar, Real *obklen, Real *kbfs, Real *cldn, Real *pblh) {
+void pblintd_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *zi, Real *thl, Real *ql,
+                  Real *q, Real *u, Real *v, Real *ustar, Real *obklen, Real *kbfs, Real *cldn,
+                  Real *pblh) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -2419,10 +2521,11 @@ void pblintd_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *zi, R
   ScreamDeepCopy::copy_to_device({ustar, obklen, kbfs}, shcol, temp_1d_d);
   ekat::host_to_device(ptr_array, dim1_sizes, dim2_sizes, temp_2d_d);
 
-  view_1d ustar_d(temp_1d_d[0]), obklen_d(temp_1d_d[1]), kbfs_d(temp_1d_d[2]), pblh_d("pblh", shcol);
+  view_1d ustar_d(temp_1d_d[0]), obklen_d(temp_1d_d[1]), kbfs_d(temp_1d_d[2]),
+      pblh_d("pblh", shcol);
 
-  view_2d z_d(temp_2d_d[0]), zi_d(temp_2d_d[1]), thl_d(temp_2d_d[2]), ql_d(temp_2d_d[3]), q_d(temp_2d_d[4]),
-      u_d(temp_2d_d[5]), v_d(temp_2d_d[6]), cldn_d(temp_2d_d[7]);
+  view_2d z_d(temp_2d_d[0]), zi_d(temp_2d_d[1]), thl_d(temp_2d_d[2]), ql_d(temp_2d_d[3]),
+      q_d(temp_2d_d[4]), u_d(temp_2d_d[5]), v_d(temp_2d_d[6]), cldn_d(temp_2d_d[7]);
 
   const Int nlev_pack = ekat::npack<Spack>(nlev);
   const auto policy   = ekat::ExeSpaceUtils<ExeSpace>::get_default_team_policy(shcol, nlev_pack);
@@ -2450,8 +2553,8 @@ void pblintd_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *zi, R
         const auto v_s    = ekat::subview(v_d, i);
         const auto cldn_s = ekat::subview(cldn_d, i);
 
-        SHF::pblintd(team, nlev, nlevi, npbl, z_s, zi_s, thl_s, ql_s, q_s, u_s, v_s, ustar_s, obklen_s, kbfs_s, cldn_s,
-                     workspace, pblh_s);
+        SHF::pblintd(team, nlev, nlevi, npbl, z_s, zi_s, thl_s, ql_s, q_s, u_s, v_s, ustar_s,
+                     obklen_s, kbfs_s, cldn_s, workspace, pblh_s);
 
         pblh_d(i) = pblh_s;
       });
@@ -2461,9 +2564,10 @@ void pblintd_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *zi, R
   ScreamDeepCopy::copy_to_host({pblh}, shcol, out_views);
 }
 
-void shoc_tke_host(Int shcol, Int nlev, Int nlevi, Real dtime, Real *wthv_sec, Real *shoc_mix, Real *dz_zi, Real *dz_zt,
-                   Real *pres, Real *tabs, Real *u_wind, Real *v_wind, Real *brunt, Real *zt_grid, Real *zi_grid,
-                   Real *pblh, Real *tke, Real *tk, Real *tkh, Real *isotropy) {
+void shoc_tke_host(Int shcol, Int nlev, Int nlevi, Real dtime, Real *wthv_sec, Real *shoc_mix,
+                   Real *dz_zi, Real *dz_zt, Real *pres, Real *tabs, Real *u_wind, Real *v_wind,
+                   Real *brunt, Real *zt_grid, Real *zi_grid, Real *pblh, Real *tke, Real *tk,
+                   Real *tkh, Real *isotropy) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename SHF::Scalar;
@@ -2483,8 +2587,9 @@ void shoc_tke_host(Int shcol, Int nlev, Int nlevi, Real dtime, Real *wthv_sec, R
   std::vector<int> dim1_sizes(num_2d_arrays, shcol);
   std::vector<int> dim2_sizes         = {nlev, nlev, nlev,  nlev, nlevi, nlev, nlev, nlev,
                                          nlev, nlev, nlevi, nlev, nlev,  nlev, nlev};
-  std::vector<const Real *> ptr_array = {wthv_sec, shoc_mix, u_wind,  v_wind, dz_zi, dz_zt, pres,    tabs,
-                                         brunt,    zt_grid,  zi_grid, tke,    tk,    tkh,   isotropy};
+  std::vector<const Real *> ptr_array = {wthv_sec, shoc_mix, u_wind, v_wind, dz_zi,
+                                         dz_zt,    pres,     tabs,   brunt,  zt_grid,
+                                         zi_grid,  tke,      tk,     tkh,    isotropy};
 
   // Sync to device
   ScreamDeepCopy::copy_to_device({pblh}, shcol, temp_1d_d);
@@ -2492,10 +2597,11 @@ void shoc_tke_host(Int shcol, Int nlev, Int nlevi, Real dtime, Real *wthv_sec, R
 
   view_1d pblh_d(temp_1d_d[0]);
 
-  view_2d wthv_sec_d(temp_2d_d[0]), shoc_mix_d(temp_2d_d[1]), u_wind_d(temp_2d_d[2]), v_wind_d(temp_2d_d[3]),
-      dz_zi_d(temp_2d_d[4]), dz_zt_d(temp_2d_d[5]), pres_d(temp_2d_d[6]), tabs_d(temp_2d_d[7]), brunt_d(temp_2d_d[8]),
-      zt_grid_d(temp_2d_d[9]), zi_grid_d(temp_2d_d[10]), tke_d(temp_2d_d[11]), tk_d(temp_2d_d[12]),
-      tkh_d(temp_2d_d[13]), isotropy_d(temp_2d_d[14]);
+  view_2d wthv_sec_d(temp_2d_d[0]), shoc_mix_d(temp_2d_d[1]), u_wind_d(temp_2d_d[2]),
+      v_wind_d(temp_2d_d[3]), dz_zi_d(temp_2d_d[4]), dz_zt_d(temp_2d_d[5]), pres_d(temp_2d_d[6]),
+      tabs_d(temp_2d_d[7]), brunt_d(temp_2d_d[8]), zt_grid_d(temp_2d_d[9]),
+      zi_grid_d(temp_2d_d[10]), tke_d(temp_2d_d[11]), tk_d(temp_2d_d[12]), tkh_d(temp_2d_d[13]),
+      isotropy_d(temp_2d_d[14]);
 
   const Int nlev_packs  = ekat::npack<Spack>(nlev);
   const Int nlevi_packs = ekat::npack<Spack>(nlevi);
@@ -2536,9 +2642,10 @@ void shoc_tke_host(Int shcol, Int nlev, Int nlevi, Real dtime, Real *wthv_sec, R
         const Real Ckh           = 0.1;
         const Real Ckm           = 0.1;
 
-        SHF::shoc_tke(team, nlev, nlevi, dtime, lambda_low, lambda_high, lambda_slope, lambda_thresh, Ckh, Ckm,
-                      wthv_sec_s, shoc_mix_s, dz_zi_s, dz_zt_s, pres_s, tabs_s, u_wind_s, v_wind_s, brunt_s, zt_grid_s,
-                      zi_grid_s, pblh_s, workspace, tke_s, tk_s, tkh_s, isotropy_s);
+        SHF::shoc_tke(team, nlev, nlevi, dtime, lambda_low, lambda_high, lambda_slope,
+                      lambda_thresh, Ckh, Ckm, wthv_sec_s, shoc_mix_s, dz_zi_s, dz_zt_s, pres_s,
+                      tabs_s, u_wind_s, v_wind_s, brunt_s, zt_grid_s, zi_grid_s, pblh_s, workspace,
+                      tke_s, tk_s, tkh_s, isotropy_s);
       });
 
   // Sync back to host
@@ -2546,7 +2653,8 @@ void shoc_tke_host(Int shcol, Int nlev, Int nlevi, Real dtime, Real *wthv_sec, R
   ekat::device_to_host({tke, tk, tkh, isotropy}, shcol, nlev, inout_views);
 }
 
-void compute_shoc_temperature_host(Int shcol, Int nlev, Real *thetal, Real *ql, Real *inv_exner, Real *tabs) {
+void compute_shoc_temperature_host(Int shcol, Int nlev, Real *thetal, Real *ql, Real *inv_exner,
+                                   Real *tabs) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack      = typename SHF::Spack;
@@ -2603,8 +2711,9 @@ void shoc_assumed_pdf_tilde_to_real_host(Real w_first, Real sqrtw2, Real *w1) {
   *w1 = t_h(0);
 }
 
-void shoc_assumed_pdf_vv_parameters_host(Real w_first, Real w_sec, Real w3var, Real w_tol_sqd, Real *skew_w, Real *w1_1,
-                                         Real *w1_2, Real *w2_1, Real *w2_2, Real *a) {
+void shoc_assumed_pdf_vv_parameters_host(Real w_first, Real w_sec, Real w3var, Real w_tol_sqd,
+                                         Real *skew_w, Real *w1_1, Real *w1_2, Real *w2_1,
+                                         Real *w2_2, Real *a) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack   = typename SHF::Spack;
@@ -2615,9 +2724,10 @@ void shoc_assumed_pdf_vv_parameters_host(Real w_first, Real w_sec, Real w3var, R
 
   Kokkos::parallel_for(
       1, KOKKOS_LAMBDA(const Int &) {
-        Spack w3var_(w3var), w_first_(w_first), w_sec_(w_sec), a_, skew_w_, w1_1_, w1_2_, w2_1_, w2_2_;
-        SHF::shoc_assumed_pdf_vv_parameters(w_first_, w_sec_, w3var_, w_tol_sqd, skew_w_, w1_1_, w1_2_, w2_1_, w2_2_,
-                                            a_);
+        Spack w3var_(w3var), w_first_(w_first), w_sec_(w_sec), a_, skew_w_, w1_1_, w1_2_, w2_1_,
+            w2_2_;
+        SHF::shoc_assumed_pdf_vv_parameters(w_first_, w_sec_, w3var_, w_tol_sqd, skew_w_, w1_1_,
+                                            w1_2_, w2_1_, w2_2_, a_);
         t_d(0) = a_[0];
         t_d(1) = skew_w_[0];
         t_d(2) = w1_1_[0];
@@ -2634,9 +2744,10 @@ void shoc_assumed_pdf_vv_parameters_host(Real w_first, Real w_sec, Real w3var, R
   *w2_2   = t_h(5);
 }
 
-void shoc_assumed_pdf_thl_parameters_host(Real wthlsec, Real sqrtw2, Real sqrtthl, Real thlsec, Real thl_first,
-                                          Real w1_1, Real w1_2, Real skew_w, Real a, Real thl_tol, Real w_thresh,
-                                          Real *thl1_1, Real *thl1_2, Real *thl2_1, Real *thl2_2, Real *sqrtthl2_1,
+void shoc_assumed_pdf_thl_parameters_host(Real wthlsec, Real sqrtw2, Real sqrtthl, Real thlsec,
+                                          Real thl_first, Real w1_1, Real w1_2, Real skew_w, Real a,
+                                          Real thl_tol, Real w_thresh, Real *thl1_1, Real *thl1_2,
+                                          Real *thl2_1, Real *thl2_2, Real *sqrtthl2_1,
                                           Real *sqrtthl2_2) {
   using SHF = Functions<Real, DefaultDevice>;
 
@@ -2648,11 +2759,12 @@ void shoc_assumed_pdf_thl_parameters_host(Real wthlsec, Real sqrtw2, Real sqrtth
 
   Kokkos::parallel_for(
       1, KOKKOS_LAMBDA(const Int &) {
-        Spack a_(a), skew_w_(skew_w), sqrtthl_(sqrtthl), sqrtw2_(sqrtw2), thl_first_(thl_first), thlsec_(thlsec),
-            w1_1_(w1_1), w1_2_(w1_2), wthlsec_(wthlsec), sqrtthl2_1_, sqrtthl2_2_, thl1_1_, thl1_2_, thl2_1_, thl2_2_;
-        SHF::shoc_assumed_pdf_thl_parameters(wthlsec_, sqrtw2_, sqrtthl_, thlsec_, thl_first_, w1_1_, w1_2_, skew_w_,
-                                             a_, thl_tol, w_thresh, thl1_1_, thl1_2_, thl2_1_, thl2_2_, sqrtthl2_1_,
-                                             sqrtthl2_2_);
+        Spack a_(a), skew_w_(skew_w), sqrtthl_(sqrtthl), sqrtw2_(sqrtw2), thl_first_(thl_first),
+            thlsec_(thlsec), w1_1_(w1_1), w1_2_(w1_2), wthlsec_(wthlsec), sqrtthl2_1_, sqrtthl2_2_,
+            thl1_1_, thl1_2_, thl2_1_, thl2_2_;
+        SHF::shoc_assumed_pdf_thl_parameters(wthlsec_, sqrtw2_, sqrtthl_, thlsec_, thl_first_,
+                                             w1_1_, w1_2_, skew_w_, a_, thl_tol, w_thresh, thl1_1_,
+                                             thl1_2_, thl2_1_, thl2_2_, sqrtthl2_1_, sqrtthl2_2_);
         t_d(0) = sqrtthl2_1_[0];
         t_d(1) = sqrtthl2_2_[0];
         t_d(2) = thl1_1_[0];
@@ -2669,9 +2781,11 @@ void shoc_assumed_pdf_thl_parameters_host(Real wthlsec, Real sqrtw2, Real sqrtth
   *thl2_2     = t_h(5);
 }
 
-void shoc_assumed_pdf_qw_parameters_host(Real wqwsec, Real sqrtw2, Real skew_w, Real sqrtqt, Real qwsec, Real w1_2,
-                                         Real w1_1, Real qw_first, Real a, Real rt_tol, Real w_thresh, Real *qw1_1,
-                                         Real *qw1_2, Real *qw2_1, Real *qw2_2, Real *sqrtqw2_1, Real *sqrtqw2_2) {
+void shoc_assumed_pdf_qw_parameters_host(Real wqwsec, Real sqrtw2, Real skew_w, Real sqrtqt,
+                                         Real qwsec, Real w1_2, Real w1_1, Real qw_first, Real a,
+                                         Real rt_tol, Real w_thresh, Real *qw1_1, Real *qw1_2,
+                                         Real *qw2_1, Real *qw2_2, Real *sqrtqw2_1,
+                                         Real *sqrtqw2_2) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack   = typename SHF::Spack;
@@ -2682,10 +2796,12 @@ void shoc_assumed_pdf_qw_parameters_host(Real wqwsec, Real sqrtw2, Real skew_w,
 
   Kokkos::parallel_for(
       1, KOKKOS_LAMBDA(const Int &) {
-        Spack a_(a), qw_first_(qw_first), qwsec_(qwsec), skew_w_(skew_w), sqrtqt_(sqrtqt), sqrtw2_(sqrtw2), w1_1_(w1_1),
-            w1_2_(w1_2), wqwsec_(wqwsec), qw1_1_, qw1_2_, qw2_1_, qw2_2_, sqrtqw2_1_, sqrtqw2_2_;
-        SHF::shoc_assumed_pdf_qw_parameters(wqwsec_, sqrtw2_, skew_w_, sqrtqt_, qwsec_, w1_2_, w1_1_, qw_first_, a_,
-                                            rt_tol, w_thresh, qw1_1_, qw1_2_, qw2_1_, qw2_2_, sqrtqw2_1_, sqrtqw2_2_);
+        Spack a_(a), qw_first_(qw_first), qwsec_(qwsec), skew_w_(skew_w), sqrtqt_(sqrtqt),
+            sqrtw2_(sqrtw2), w1_1_(w1_1), w1_2_(w1_2), wqwsec_(wqwsec), qw1_1_, qw1_2_, qw2_1_,
+            qw2_2_, sqrtqw2_1_, sqrtqw2_2_;
+        SHF::shoc_assumed_pdf_qw_parameters(wqwsec_, sqrtw2_, skew_w_, sqrtqt_, qwsec_, w1_2_,
+                                            w1_1_, qw_first_, a_, rt_tol, w_thresh, qw1_1_, qw1_2_,
+                                            qw2_1_, qw2_2_, sqrtqw2_1_, sqrtqw2_2_);
         t_d(0) = qw1_1_[0];
         t_d(1) = qw1_2_[0];
         t_d(2) = qw2_1_[0];
@@ -2702,9 +2818,11 @@ void shoc_assumed_pdf_qw_parameters_host(Real wqwsec, Real sqrtw2, Real skew_w,
   *sqrtqw2_2 = t_h(5);
 }
 
-void shoc_assumed_pdf_inplume_correlations_host(Real sqrtqw2_1, Real sqrtthl2_1, Real a, Real sqrtqw2_2,
-                                                Real sqrtthl2_2, Real qwthlsec, Real qw1_1, Real qw_first, Real thl1_1,
-                                                Real thl_first, Real qw1_2, Real thl1_2, Real *r_qwthl_1) {
+void shoc_assumed_pdf_inplume_correlations_host(Real sqrtqw2_1, Real sqrtthl2_1, Real a,
+                                                Real sqrtqw2_2, Real sqrtthl2_2, Real qwthlsec,
+                                                Real qw1_1, Real qw_first, Real thl1_1,
+                                                Real thl_first, Real qw1_2, Real thl1_2,
+                                                Real *r_qwthl_1) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack   = typename SHF::Spack;
@@ -2715,11 +2833,13 @@ void shoc_assumed_pdf_inplume_correlations_host(Real sqrtqw2_1, Real sqrtthl2_1,
 
   Kokkos::parallel_for(
       1, KOKKOS_LAMBDA(const Int &) {
-        Spack a_(a), qw1_1_(qw1_1), qw1_2_(qw1_2), qw_first_(qw_first), qwthlsec_(qwthlsec), sqrtqw2_1_(sqrtqw2_1),
-            sqrtqw2_2_(sqrtqw2_2), sqrtthl2_1_(sqrtthl2_1), sqrtthl2_2_(sqrtthl2_2), thl1_1_(thl1_1), thl1_2_(thl1_2),
-            thl_first_(thl_first), r_qwthl_1_;
-        SHF::shoc_assumed_pdf_inplume_correlations(sqrtqw2_1_, sqrtthl2_1_, a_, sqrtqw2_2_, sqrtthl2_2_, qwthlsec_,
-                                                   qw1_1_, qw_first_, thl1_1_, thl_first_, qw1_2_, thl1_2_, r_qwthl_1_);
+        Spack a_(a), qw1_1_(qw1_1), qw1_2_(qw1_2), qw_first_(qw_first), qwthlsec_(qwthlsec),
+            sqrtqw2_1_(sqrtqw2_1), sqrtqw2_2_(sqrtqw2_2), sqrtthl2_1_(sqrtthl2_1),
+            sqrtthl2_2_(sqrtthl2_2), thl1_1_(thl1_1), thl1_2_(thl1_2), thl_first_(thl_first),
+            r_qwthl_1_;
+        SHF::shoc_assumed_pdf_inplume_correlations(
+            sqrtqw2_1_, sqrtthl2_1_, a_, sqrtqw2_2_, sqrtthl2_2_, qwthlsec_, qw1_1_, qw_first_,
+            thl1_1_, thl_first_, qw1_2_, thl1_2_, r_qwthl_1_);
         t_d(0) = r_qwthl_1_[0];
       });
   Kokkos::deep_copy(t_h, t_d);
@@ -2745,8 +2865,8 @@ void shoc_assumed_pdf_compute_temperature_host(Real thl1, Real pval, Real *tl1)
   *tl1 = t_h(0);
 }
 
-void shoc_assumed_pdf_compute_qs_host(Real tl1_1, Real tl1_2, Real pval, Real *qs1, Real *beta1, Real *qs2,
-                                      Real *beta2) {
+void shoc_assumed_pdf_compute_qs_host(Real tl1_1, Real tl1_2, Real pval, Real *qs1, Real *beta1,
+                                      Real *qs2, Real *beta2) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack   = typename SHF::Spack;
@@ -2760,7 +2880,8 @@ void shoc_assumed_pdf_compute_qs_host(Real tl1_1, Real tl1_2, Real pval, Real *q
       1, KOKKOS_LAMBDA(const Int &) {
         Spack pval_(pval), tl1_1_(tl1_1), tl1_2_(tl1_2), beta1_, beta2_, qs1_, qs2_;
         Smask active_entries(true);
-        SHF::shoc_assumed_pdf_compute_qs(tl1_1_, tl1_2_, pval_, active_entries, qs1_, beta1_, qs2_, beta2_);
+        SHF::shoc_assumed_pdf_compute_qs(tl1_1_, tl1_2_, pval_, active_entries, qs1_, beta1_, qs2_,
+                                         beta2_);
         t_d(0) = beta1_[0];
         t_d(1) = beta2_[0];
         t_d(2) = qs1_[0];
@@ -2773,8 +2894,9 @@ void shoc_assumed_pdf_compute_qs_host(Real tl1_1, Real tl1_2, Real pval, Real *q
   *qs2   = t_h(3);
 }
 
-void shoc_assumed_pdf_compute_s_host(Real qw1, Real qs1, Real beta, Real pval, Real thl2, Real qw2, Real sqrtthl2,
-                                     Real sqrtqw2, Real r_qwthl, Real *s, Real *std_s, Real *qn, Real *c) {
+void shoc_assumed_pdf_compute_s_host(Real qw1, Real qs1, Real beta, Real pval, Real thl2, Real qw2,
+                                     Real sqrtthl2, Real sqrtqw2, Real r_qwthl, Real *s,
+                                     Real *std_s, Real *qn, Real *c) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack   = typename SHF::Spack;
@@ -2785,10 +2907,10 @@ void shoc_assumed_pdf_compute_s_host(Real qw1, Real qs1, Real beta, Real pval, R
 
   Kokkos::parallel_for(
       1, KOKKOS_LAMBDA(const Int &) {
-        Spack beta_(beta), pval_(pval), qs1_(qs1), qw1_(qw1), qw2_(qw2), r_qwthl_(r_qwthl), sqrtqw2_(sqrtqw2),
-            sqrtthl2_(sqrtthl2), thl2_(thl2), c_, qn_, s_, std_s_;
-        SHF::shoc_assumed_pdf_compute_s(qw1_, qs1_, beta_, pval_, thl2_, qw2_, sqrtthl2_, sqrtqw2_, r_qwthl_, s_,
-                                        std_s_, qn_, c_);
+        Spack beta_(beta), pval_(pval), qs1_(qs1), qw1_(qw1), qw2_(qw2), r_qwthl_(r_qwthl),
+            sqrtqw2_(sqrtqw2), sqrtthl2_(sqrtthl2), thl2_(thl2), c_, qn_, s_, std_s_;
+        SHF::shoc_assumed_pdf_compute_s(qw1_, qs1_, beta_, pval_, thl2_, qw2_, sqrtthl2_, sqrtqw2_,
+                                        r_qwthl_, s_, std_s_, qn_, c_);
         t_d(0) = c_[0];
         t_d(1) = qn_[0];
         t_d(2) = s_[0];
@@ -2820,8 +2942,10 @@ void shoc_assumed_pdf_compute_sgs_liquid_host(Real a, Real ql1, Real ql2, Real *
   *shoc_ql = t_h(0);
 }
 
-void shoc_assumed_pdf_compute_cloud_liquid_variance_host(Real a, Real s1, Real ql1, Real c1, Real std_s1, Real s2,
-                                                         Real ql2, Real c2, Real std_s2, Real shoc_ql, Real *shoc_ql2) {
+void shoc_assumed_pdf_compute_cloud_liquid_variance_host(Real a, Real s1, Real ql1, Real c1,
+                                                         Real std_s1, Real s2, Real ql2, Real c2,
+                                                         Real std_s2, Real shoc_ql,
+                                                         Real *shoc_ql2) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack   = typename SHF::Spack;
@@ -2832,18 +2956,18 @@ void shoc_assumed_pdf_compute_cloud_liquid_variance_host(Real a, Real s1, Real q
 
   Kokkos::parallel_for(
       1, KOKKOS_LAMBDA(const Int &) {
-        Spack a_(a), c1_(c1), c2_(c2), ql1_(ql1), ql2_(ql2), s1_(s1), s2_(s2), shoc_ql_(shoc_ql), std_s1_(std_s1),
-            std_s2_(std_s2), shoc_ql2_;
-        SHF::shoc_assumed_pdf_compute_cloud_liquid_variance(a_, s1_, ql1_, c1_, std_s1_, s2_, ql2_, c2_, std_s2_,
-                                                            shoc_ql_, shoc_ql2_);
+        Spack a_(a), c1_(c1), c2_(c2), ql1_(ql1), ql2_(ql2), s1_(s1), s2_(s2), shoc_ql_(shoc_ql),
+            std_s1_(std_s1), std_s2_(std_s2), shoc_ql2_;
+        SHF::shoc_assumed_pdf_compute_cloud_liquid_variance(a_, s1_, ql1_, c1_, std_s1_, s2_, ql2_,
+                                                            c2_, std_s2_, shoc_ql_, shoc_ql2_);
         t_d(0) = shoc_ql2_[0];
       });
   Kokkos::deep_copy(t_h, t_d);
   *shoc_ql2 = t_h(0);
 }
 
-void shoc_assumed_pdf_compute_liquid_water_flux_host(Real a, Real w1_1, Real w_first, Real ql1, Real w1_2, Real ql2,
-                                                     Real *wqls) {
+void shoc_assumed_pdf_compute_liquid_water_flux_host(Real a, Real w1_1, Real w_first, Real ql1,
+                                                     Real w1_2, Real ql2, Real *wqls) {
   using SHF = Functions<Real, DefaultDevice>;
 
   using Spack   = typename SHF::Spack;
@@ -2855,14 +2979,16 @@ void shoc_assumed_pdf_compute_liquid_water_flux_host(Real a, Real w1_1, Real w_f
   Kokkos::parallel_for(
       1, KOKKOS_LAMBDA(const Int &) {
         Spack a_(a), ql1_(ql1), ql2_(ql2), w1_1_(w1_1), w1_2_(w1_2), w_first_(w_first), wqls_;
-        SHF::shoc_assumed_pdf_compute_liquid_water_flux(a_, w1_1_, w_first_, ql1_, w1_2_, ql2_, wqls_);
+        SHF::shoc_assumed_pdf_compute_liquid_water_flux(a_, w1_1_, w_first_, ql1_, w1_2_, ql2_,
+                                                        wqls_);
         t_d(0) = wqls_[0];
       });
   Kokkos::deep_copy(t_h, t_d);
   *wqls = t_h(0);
 }
 
-void shoc_assumed_pdf_compute_buoyancy_flux_host(Real wthlsec, Real wqwsec, Real pval, Real wqls, Real *wthv_sec) {
+void shoc_assumed_pdf_compute_buoyancy_flux_host(Real wthlsec, Real wqwsec, Real pval, Real wqls,
+                                                 Real *wthv_sec) {
   using PF = Functions<Real, DefaultDevice>;
 
   using Spack   = typename PF::Spack;
diff --git i/components/eamxx/src/physics/shoc/tests/infra/shoc_test_data.hpp w/components/eamxx/src/physics/shoc/tests/infra/shoc_test_data.hpp
index 495d9f32ce..33b97c258d 100644
--- i/components/eamxx/src/physics/shoc/tests/infra/shoc_test_data.hpp
+++ w/components/eamxx/src/physics/shoc/tests/infra/shoc_test_data.hpp
@@ -21,13 +21,15 @@ namespace shoc {
 struct ShocTestGridDataBase : public PhysicsTestData {
   Real *zt_grid, *zi_grid;
 
-  ShocTestGridDataBase(const std::vector<std::vector<Int>> &dims, const std::vector<std::vector<Real **>> &reals,
+  ShocTestGridDataBase(const std::vector<std::vector<Int>> &dims,
+                       const std::vector<std::vector<Real **>> &reals,
                        const std::vector<std::vector<Int **>> &ints   = {},
                        const std::vector<std::vector<bool **>> &bools = {})
       : PhysicsTestData(dims, reals, ints, bools) {}
 
   template <typename Engine>
-  void randomize(Engine &engine, const std::vector<std::pair<void *, std::pair<Real, Real>>> &ranges = {}) {
+  void randomize(Engine &engine,
+                 const std::vector<std::pair<void *, std::pair<Real, Real>>> &ranges = {}) {
     PhysicsTestData::randomize(engine, ranges);
 
     const auto shcol = dim(zt_grid, 0);
@@ -37,7 +39,8 @@ struct ShocTestGridDataBase : public PhysicsTestData {
     EKAT_REQUIRE_MSG(shcol == dim(zi_grid, 0), "Mismatched shcol dim for zt_grid and zi_grid");
     EKAT_REQUIRE_MSG(nlev == nlevi - 1, "Mismatched lev dim for zt_grid and zi_grid");
 
-    // Don't want true randomness in the grid data, need interleaved grid points with some minimum separation
+    // Don't want true randomness in the grid data, need interleaved grid points with some minimum
+    // separation
     for (auto i = decltype(shcol){0}; i < shcol; ++i) {
       Real *this_col_zi = zi_grid + nlevi * i;
       std::sort(this_col_zi, this_col_zi + nlevi);
@@ -48,13 +51,15 @@ struct ShocTestGridDataBase : public PhysicsTestData {
       const auto avg_jump_d = avg_jump / 2.5;
 
       for (auto k = decltype(nlevi){1}; k < (nlevi - 1); ++k) {
-        std::uniform_real_distribution<Real> x2_dist(min + k * avg_jump - avg_jump_d, min + k * avg_jump + avg_jump_d);
+        std::uniform_real_distribution<Real> x2_dist(min + k * avg_jump - avg_jump_d,
+                                                     min + k * avg_jump + avg_jump_d);
         this_col_zi[k] = x2_dist(engine);
       }
 
       std::sort(this_col_zi, this_col_zi + nlevi, std::greater<Real>());
       for (auto k = decltype(nlev){0}; k < nlev; ++k) {
-        std::uniform_real_distribution<Real> x2_dist(zi_grid[nlevi * i + k], zi_grid[nlevi * i + k + 1]);
+        std::uniform_real_distribution<Real> x2_dist(zi_grid[nlevi * i + k],
+                                                     zi_grid[nlevi * i + k + 1]);
         zt_grid[nlev * i + k] = x2_dist(engine);
       }
     }
@@ -86,8 +91,8 @@ struct ShocDiagObklenData : public PhysicsTestData {
   Real *ustar, *kbfs, *obklen;
 
   ShocDiagObklenData(Int shcol_)
-      : PhysicsTestData({{shcol_}}, {{&uw_sfc, &vw_sfc, &wthl_sfc, &wqw_sfc, &thl_sfc, &cldliq_sfc, &qv_sfc, &ustar,
-                                      &kbfs, &obklen}}),
+      : PhysicsTestData({{shcol_}}, {{&uw_sfc, &vw_sfc, &wthl_sfc, &wqw_sfc, &thl_sfc, &cldliq_sfc,
+                                      &qv_sfc, &ustar, &kbfs, &obklen}}),
         shcol(shcol_) {}
 
   PTD_STD_DEF(ShocDiagObklenData, 1, shcol);
@@ -102,7 +107,8 @@ struct UpdateHostDseData : public PhysicsTestData {
   Real *host_dse;
 
   UpdateHostDseData(Int shcol_, Int nlev_)
-      : PhysicsTestData({{shcol_, nlev_}, {shcol_}}, {{&thlm, &shoc_ql, &inv_exner, &zt_grid, &host_dse}, {&phis}}),
+      : PhysicsTestData({{shcol_, nlev_}, {shcol_}},
+                        {{&thlm, &shoc_ql, &inv_exner, &zt_grid, &host_dse}, {&phis}}),
         shcol(shcol_), nlev(nlev_) {}
 
   PTD_STD_DEF(UpdateHostDseData, 2, shcol, nlev);
@@ -112,16 +118,18 @@ struct ShocEnergyFixerData : public ShocTestGridDataBase {
   // Inputs
   Int shcol, nlev, nlevi, nadv;
   Real dtime;
-  Real *se_b, *ke_b, *wv_b, *wl_b, *se_a, *ke_a, *wv_a, *wl_a, *wthl_sfc, *wqw_sfc, *rho_zt, *tke, *pint;
+  Real *se_b, *ke_b, *wv_b, *wl_b, *se_a, *ke_a, *wv_a, *wl_a, *wthl_sfc, *wqw_sfc, *rho_zt, *tke,
+      *pint;
 
   // Inputs/Outputs
   Real *host_dse;
 
   ShocEnergyFixerData(Int shcol_, Int nlev_, Int nlevi_, Real dtime_, Int nadv_)
-      : ShocTestGridDataBase({{shcol_, nlev_}, {shcol_, nlevi_}, {shcol_}},
-                             {{&zt_grid, &rho_zt, &tke, &host_dse},
-                              {&zi_grid, &pint},
-                              {&se_b, &ke_b, &wv_b, &wl_b, &se_a, &ke_a, &wv_a, &wl_a, &wthl_sfc, &wqw_sfc}}),
+      : ShocTestGridDataBase(
+            {{shcol_, nlev_}, {shcol_, nlevi_}, {shcol_}},
+            {{&zt_grid, &rho_zt, &tke, &host_dse},
+             {&zi_grid, &pint},
+             {&se_b, &ke_b, &wv_b, &wl_b, &se_a, &ke_a, &wv_a, &wl_a, &wthl_sfc, &wqw_sfc}}),
         shcol(shcol_), nlev(nlev_), nlevi(nlevi_), nadv(nadv_), dtime(dtime_) {}
 
   PTD_STD_DEF(ShocEnergyFixerData, 5, shcol, nlev, nlevi, dtime, nadv);
@@ -137,7 +145,8 @@ struct ShocEnergyIntegralsData : public PhysicsTestData {
 
   ShocEnergyIntegralsData(Int shcol_, Int nlev_)
       : PhysicsTestData({{shcol_, nlev_}, {shcol_}},
-                        {{&host_dse, &pdel, &rtm, &rcm, &u_wind, &v_wind}, {&se_int, &ke_int, &wv_int, &wl_int}}),
+                        {{&host_dse, &pdel, &rtm, &rcm, &u_wind, &v_wind},
+                         {&se_int, &ke_int, &wv_int, &wl_int}}),
         shcol(shcol_), nlev(nlev_) {}
 
   PTD_STD_DEF(ShocEnergyIntegralsData, 2, shcol, nlev);
@@ -152,8 +161,9 @@ struct CalcShocVertfluxData : public PhysicsTestData {
   Real *vertflux;
 
   CalcShocVertfluxData(Int shcol_, Int nlev_, Int nlevi_)
-      : PhysicsTestData({{shcol_, nlevi_}, {shcol_, nlev_}}, {{&tkh_zi, &dz_zi, &vertflux}, {&invar}}), shcol(shcol_),
-        nlev(nlev_), nlevi(nlevi_) {}
+      : PhysicsTestData({{shcol_, nlevi_}, {shcol_, nlev_}},
+                        {{&tkh_zi, &dz_zi, &vertflux}, {&invar}}),
+        shcol(shcol_), nlev(nlev_), nlevi(nlevi_) {}
 
   PTD_STD_DEF(CalcShocVertfluxData, 3, shcol, nlev, nlevi);
 };
@@ -185,7 +195,8 @@ struct ComputeTmpiData : public PhysicsTestData {
   Real *tmpi;
 
   ComputeTmpiData(Int shcol_, Int nlevi_, Real dtime_)
-      : PhysicsTestData({{shcol_, nlevi_}}, {{&rho_zi, &dz_zi, &tmpi}}), shcol(shcol_), nlevi(nlevi_), dtime(dtime_) {}
+      : PhysicsTestData({{shcol_, nlevi_}}, {{&rho_zi, &dz_zi, &tmpi}}), shcol(shcol_),
+        nlevi(nlevi_), dtime(dtime_) {}
 
   PTD_STD_DEF(ComputeTmpiData, 3, shcol, nlevi, dtime);
 };
@@ -199,7 +210,8 @@ struct DpInverseData : public PhysicsTestData {
   Real *rdp_zt;
 
   DpInverseData(Int shcol_, Int nlev_)
-      : PhysicsTestData({{shcol_, nlev_}}, {{&rho_zt, &dz_zt, &rdp_zt}}), shcol(shcol_), nlev(nlev_) {}
+      : PhysicsTestData({{shcol_, nlev_}}, {{&rho_zt, &dz_zt, &rdp_zt}}), shcol(shcol_),
+        nlev(nlev_) {}
 
   PTD_STD_DEF(DpInverseData, 2, shcol, nlev);
 };
@@ -213,8 +225,8 @@ struct IntegColumnStabilityData : public PhysicsTestData {
   Real *brunt_int;
 
   IntegColumnStabilityData(Int shcol_, Int nlev_)
-      : PhysicsTestData({{shcol_, nlev_}, {shcol_}}, {{&dz_zt, &pres, &brunt}, {&brunt_int}}), shcol(shcol_),
-        nlev(nlev_) {}
+      : PhysicsTestData({{shcol_, nlev_}, {shcol_}}, {{&dz_zt, &pres, &brunt}, {&brunt_int}}),
+        shcol(shcol_), nlev(nlev_) {}
 
   PTD_STD_DEF(IntegColumnStabilityData, 2, shcol, nlev);
 };
@@ -226,7 +238,8 @@ struct CheckTkeData : public PhysicsTestData {
   // Inputs/Outputs
   Real *tke;
 
-  CheckTkeData(Int shcol_, Int nlev_) : PhysicsTestData({{shcol_, nlev_}}, {{&tke}}), shcol(shcol_), nlev(nlev_) {}
+  CheckTkeData(Int shcol_, Int nlev_)
+      : PhysicsTestData({{shcol_, nlev_}}, {{&tke}}), shcol(shcol_), nlev(nlev_) {}
 
   PTD_STD_DEF(CheckTkeData, 2, shcol, nlev);
 };
@@ -245,8 +258,8 @@ struct ShocTkeData : public ShocTestGridDataBase {
 
   ShocTkeData(Int shcol_, Int nlev_, Int nlevi_, Real dtime_)
       : ShocTestGridDataBase({{shcol_, nlev_}, {shcol_, nlevi_}, {shcol_}},
-                             {{&wthv_sec, &shoc_mix, &dz_zt, &pres, &tabs, &u_wind, &v_wind, &brunt, &zt_grid, &tke,
-                               &tk, &tkh, &isotropy},
+                             {{&wthv_sec, &shoc_mix, &dz_zt, &pres, &tabs, &u_wind, &v_wind, &brunt,
+                               &zt_grid, &tke, &tk, &tkh, &isotropy},
                               {&dz_zi, &zi_grid},
                               {&pblh}}),
         shcol(shcol_), nlev(nlev_), nlevi(nlevi_), dtime(dtime_) {}
@@ -263,8 +276,9 @@ struct ComputeShrProdData : public PhysicsTestData {
   Real *sterm;
 
   ComputeShrProdData(Int shcol_, Int nlev_, Int nlevi_)
-      : PhysicsTestData({{shcol_, nlevi_}, {shcol_, nlev_}}, {{&dz_zi, &sterm}, {&u_wind, &v_wind}}), shcol(shcol_),
-        nlev(nlev_), nlevi(nlevi_) {}
+      : PhysicsTestData({{shcol_, nlevi_}, {shcol_, nlev_}},
+                        {{&dz_zi, &sterm}, {&u_wind, &v_wind}}),
+        shcol(shcol_), nlev(nlev_), nlevi(nlevi_) {}
 
   PTD_STD_DEF(ComputeShrProdData, 3, shcol, nlev, nlevi);
 };
@@ -278,8 +292,9 @@ struct IsotropicTsData : public PhysicsTestData {
   Real *isotropy;
 
   IsotropicTsData(Int shcol_, Int nlev_)
-      : PhysicsTestData({{shcol_}, {shcol_, nlev_}}, {{&brunt_int}, {&tke, &a_diss, &brunt, &isotropy}}), shcol(shcol_),
-        nlev(nlev_) {}
+      : PhysicsTestData({{shcol_}, {shcol_, nlev_}},
+                        {{&brunt_int}, {&tke, &a_diss, &brunt, &isotropy}}),
+        shcol(shcol_), nlev(nlev_) {}
 
   PTD_STD_DEF(IsotropicTsData, 2, shcol, nlev);
 };
@@ -297,8 +312,8 @@ struct AdvSgsTkeData : public PhysicsTestData {
   Real *a_diss;
 
   AdvSgsTkeData(Int shcol_, Int nlev_, Real dtime_)
-      : PhysicsTestData({{shcol_, nlev_}}, {{&shoc_mix, &wthv_sec, &sterm_zt, &tk, &tke, &a_diss}}), shcol(shcol_),
-        nlev(nlev_), dtime(dtime_) {}
+      : PhysicsTestData({{shcol_, nlev_}}, {{&shoc_mix, &wthv_sec, &sterm_zt, &tk, &tke, &a_diss}}),
+        shcol(shcol_), nlev(nlev_), dtime(dtime_) {}
 
   PTD_STD_DEF(AdvSgsTkeData, 3, shcol, nlev, dtime);
 };
@@ -312,8 +327,9 @@ struct EddyDiffusivitiesData : public PhysicsTestData {
   Real *tkh, *tk;
 
   EddyDiffusivitiesData(Int shcol_, Int nlev_)
-      : PhysicsTestData({{shcol_}, {shcol_, nlev_}},
-                        {{&pblh}, {&zt_grid, &tabs, &shoc_mix, &sterm_zt, &isotropy, &tke, &tkh, &tk}}),
+      : PhysicsTestData(
+            {{shcol_}, {shcol_, nlev_}},
+            {{&pblh}, {&zt_grid, &tabs, &shoc_mix, &sterm_zt, &isotropy, &tke, &tkh, &tk}}),
         shcol(shcol_), nlev(nlev_) {}
 
   PTD_STD_DEF(EddyDiffusivitiesData, 2, shcol, nlev);
@@ -328,8 +344,9 @@ struct ShocLengthData : public ShocTestGridDataBase {
   Real *brunt, *shoc_mix;
 
   ShocLengthData(Int shcol_, Int nlev_, Int nlevi_)
-      : ShocTestGridDataBase({{shcol_}, {shcol_, nlev_}, {shcol_, nlevi_}},
-                             {{&host_dx, &host_dy}, {&zt_grid, &dz_zt, &tke, &thv, &brunt, &shoc_mix}, {&zi_grid}}),
+      : ShocTestGridDataBase(
+            {{shcol_}, {shcol_, nlev_}, {shcol_, nlevi_}},
+            {{&host_dx, &host_dy}, {&zt_grid, &dz_zt, &tke, &thv, &brunt, &shoc_mix}, {&zi_grid}}),
         shcol(shcol_), nlev(nlev_), nlevi(nlevi_) {}
 
   PTD_STD_DEF(ShocLengthData, 3, shcol, nlev, nlevi);
@@ -344,8 +361,8 @@ struct ComputeBruntShocLengthData : public PhysicsTestData {
   Real *brunt;
 
   ComputeBruntShocLengthData(Int shcol_, Int nlev_, Int nlevi_)
-      : PhysicsTestData({{shcol_, nlev_}, {shcol_, nlevi_}}, {{&dz_zt, &thv, &brunt}, {&thv_zi}}), shcol(shcol_),
-        nlev(nlev_), nlevi(nlevi_) {}
+      : PhysicsTestData({{shcol_, nlev_}, {shcol_, nlevi_}}, {{&dz_zt, &thv, &brunt}, {&thv_zi}}),
+        shcol(shcol_), nlev(nlev_), nlevi(nlevi_) {}
 
   PTD_STD_DEF(ComputeBruntShocLengthData, 3, shcol, nlev, nlevi);
 };
@@ -359,8 +376,8 @@ struct ComputeLInfShocLengthData : public PhysicsTestData {
   Real *l_inf;
 
   ComputeLInfShocLengthData(Int shcol_, Int nlev_)
-      : PhysicsTestData({{shcol_, nlev_}, {shcol_}}, {{&zt_grid, &dz_zt, &tke}, {&l_inf}}), shcol(shcol_), nlev(nlev_) {
-  }
+      : PhysicsTestData({{shcol_, nlev_}, {shcol_}}, {{&zt_grid, &dz_zt, &tke}, {&l_inf}}),
+        shcol(shcol_), nlev(nlev_) {}
 
   PTD_STD_DEF(ComputeLInfShocLengthData, 2, shcol, nlev);
 };
@@ -388,7 +405,8 @@ struct ComputeShocMixShocLengthData : public PhysicsTestData {
   Real *shoc_mix;
 
   ComputeShocMixShocLengthData(Int shcol_, Int nlev_)
-      : PhysicsTestData({{shcol_, nlev_}, {shcol_}}, {{&tke, &brunt, &zt_grid, &shoc_mix}, {&tscale, &l_inf}}),
+      : PhysicsTestData({{shcol_, nlev_}, {shcol_}},
+                        {{&tke, &brunt, &zt_grid, &shoc_mix}, {&tscale, &l_inf}}),
         shcol(shcol_), nlev(nlev_) {}
 
   PTD_STD_DEF(ComputeShocMixShocLengthData, 2, shcol, nlev);
@@ -403,7 +421,8 @@ struct CheckLengthScaleShocLengthData : public PhysicsTestData {
   Real *shoc_mix;
 
   CheckLengthScaleShocLengthData(Int shcol_, Int nlev_)
-      : PhysicsTestData({{shcol_}, {shcol_, nlev_}}, {{&host_dx, &host_dy}, {&shoc_mix}}), shcol(shcol_), nlev(nlev_) {}
+      : PhysicsTestData({{shcol_}, {shcol_, nlev_}}, {{&host_dx, &host_dy}, {&shoc_mix}}),
+        shcol(shcol_), nlev(nlev_) {}
 
   PTD_STD_DEF(CheckLengthScaleShocLengthData, 2, shcol, nlev);
 };
@@ -431,7 +450,8 @@ struct DiagSecondMomentsSrfData : public PhysicsTestData {
   Real *ustar2, *wstar;
 
   DiagSecondMomentsSrfData(Int shcol_)
-      : PhysicsTestData({{shcol_}}, {{&wthl_sfc, &uw_sfc, &vw_sfc, &ustar2, &wstar}}), shcol(shcol_) {}
+      : PhysicsTestData({{shcol_}}, {{&wthl_sfc, &uw_sfc, &vw_sfc, &ustar2, &wstar}}),
+        shcol(shcol_) {}
 
   PTD_STD_DEF(DiagSecondMomentsSrfData, 1, shcol);
 };
@@ -446,8 +466,8 @@ struct LinearInterpData : public PhysicsTestData {
   Real *y2;
 
   LinearInterpData(Int ncol_, Int km1_, Int km2_, Real minthresh_)
-      : PhysicsTestData({{ncol_, km1_}, {ncol_, km2_}}, {{&x1, &y1}, {&x2, &y2}}), ncol(ncol_), km1(km1_), km2(km2_),
-        minthresh(minthresh_) {}
+      : PhysicsTestData({{ncol_, km1_}, {ncol_, km2_}}, {{&x1, &y1}, {&x2, &y2}}), ncol(ncol_),
+        km1(km1_), km2(km2_), minthresh(minthresh_) {}
 
   PTD_STD_DEF(LinearInterpData, 4, ncol, km1, km2, minthresh);
 };
@@ -472,15 +492,17 @@ struct DiagThirdShocMomentsData : public ShocTestGridDataBase {
 struct ComputeDiagThirdShocMomentData : public PhysicsTestData {
   // Inputs
   Int shcol, nlev, nlevi;
-  Real *w_sec, *thl_sec, *wthl_sec, *tke, *dz_zt, *dz_zi, *isotropy_zi, *brunt_zi, *w_sec_zi, *thetal_zi;
+  Real *w_sec, *thl_sec, *wthl_sec, *tke, *dz_zt, *dz_zi, *isotropy_zi, *brunt_zi, *w_sec_zi,
+      *thetal_zi;
 
   // Outputs
   Real *w3;
 
   ComputeDiagThirdShocMomentData(Int shcol_, Int nlev_, Int nlevi_)
-      : PhysicsTestData({{shcol_, nlev_}, {shcol_, nlevi_}},
-                        {{&w_sec, &tke, &dz_zt},
-                         {&thl_sec, &wthl_sec, &dz_zi, &isotropy_zi, &brunt_zi, &w_sec_zi, &thetal_zi, &w3}}),
+      : PhysicsTestData(
+            {{shcol_, nlev_}, {shcol_, nlevi_}},
+            {{&w_sec, &tke, &dz_zt},
+             {&thl_sec, &wthl_sec, &dz_zi, &isotropy_zi, &brunt_zi, &w_sec_zi, &thetal_zi, &w3}}),
         shcol(shcol_), nlev(nlev_), nlevi(nlevi_) {}
 
   PTD_STD_DEF(ComputeDiagThirdShocMomentData, 3, shcol, nlev, nlevi);
@@ -489,16 +511,17 @@ struct ComputeDiagThirdShocMomentData : public PhysicsTestData {
 struct ShocAssumedPdfData : public ShocTestGridDataBase {
   // Inputs
   Int shcol, nlev, nlevi;
-  Real *thetal, *qw, *w_field, *thl_sec, *qw_sec, *wthl_sec, *w_sec, *wqw_sec, *qwthl_sec, *w3, *pres;
+  Real *thetal, *qw, *w_field, *thl_sec, *qw_sec, *wthl_sec, *w_sec, *wqw_sec, *qwthl_sec, *w3,
+      *pres;
 
   // Outputs
   Real *shoc_cldfrac, *shoc_ql, *wqls, *wthv_sec, *shoc_ql2;
 
   ShocAssumedPdfData(Int shcol_, Int nlev_, Int nlevi_)
-      : ShocTestGridDataBase(
-            {{shcol_, nlev_}, {shcol_, nlevi_}},
-            {{&thetal, &qw, &w_field, &w_sec, &pres, &zt_grid, &shoc_cldfrac, &shoc_ql, &wqls, &wthv_sec, &shoc_ql2},
-             {&thl_sec, &qw_sec, &wthl_sec, &wqw_sec, &qwthl_sec, &w3, &zi_grid}}),
+      : ShocTestGridDataBase({{shcol_, nlev_}, {shcol_, nlevi_}},
+                             {{&thetal, &qw, &w_field, &w_sec, &pres, &zt_grid, &shoc_cldfrac,
+                               &shoc_ql, &wqls, &wthv_sec, &shoc_ql2},
+                              {&thl_sec, &qw_sec, &wthl_sec, &wqw_sec, &qwthl_sec, &w3, &zi_grid}}),
         shcol(shcol_), nlev(nlev_), nlevi(nlevi_) {}
 
   PTD_STD_DEF(ShocAssumedPdfData, 3, shcol, nlev, nlevi);
@@ -538,7 +561,8 @@ struct ShocAssumedPdfQwParametersData {
 
 struct ShocAssumedPdfInplumeCorrelationsData {
   // Inputs
-  Real sqrtqw2_1, sqrtthl2_1, a, sqrtqw2_2, sqrtthl2_2, qwthlsec, qw1_1, qw_first, thl1_1, thl_first, qw1_2, thl1_2;
+  Real sqrtqw2_1, sqrtthl2_1, a, sqrtqw2_2, sqrtthl2_2, qwthlsec, qw1_1, qw_first, thl1_1,
+      thl_first, qw1_2, thl1_2;
 
   // Outputs
   Real r_qwthl_1;
@@ -608,8 +632,8 @@ struct DiagSecondMomentsUbycondData : public PhysicsTestData {
   Real *thl_sec, *qw_sec, *wthl_sec, *wqw_sec, *qwthl_sec, *uw_sec, *vw_sec, *wtke_sec;
 
   DiagSecondMomentsUbycondData(Int shcol_)
-      : PhysicsTestData({{shcol_}},
-                        {{&thl_sec, &qw_sec, &wthl_sec, &wqw_sec, &qwthl_sec, &uw_sec, &vw_sec, &wtke_sec}}),
+      : PhysicsTestData({{shcol_}}, {{&thl_sec, &qw_sec, &wthl_sec, &wqw_sec, &qwthl_sec, &uw_sec,
+                                      &vw_sec, &wtke_sec}}),
         shcol(shcol_) {}
 
   PTD_STD_DEF(DiagSecondMomentsUbycondData, 1, shcol);
@@ -638,8 +662,8 @@ struct PblintdCldcheckData : public PhysicsTestData {
   Real *pblh;
 
   PblintdCldcheckData(Int shcol_, Int nlev_, Int nlevi_)
-      : PhysicsTestData({{shcol_, nlevi_}, {shcol_, nlev_}, {shcol_}}, {{&zi}, {&cldn}, {&pblh}}), shcol(shcol_),
-        nlev(nlev_), nlevi(nlevi_) {}
+      : PhysicsTestData({{shcol_, nlevi_}, {shcol_, nlev_}, {shcol_}}, {{&zi}, {&cldn}, {&pblh}}),
+        shcol(shcol_), nlev(nlev_), nlevi(nlevi_) {}
 
   PTD_STD_DEF(PblintdCldcheckData, 3, shcol, nlev, nlevi);
 };
@@ -653,8 +677,9 @@ struct DiagSecondMomentsLbycondData : public PhysicsTestData {
   Real *wthl_sec, *wqw_sec, *uw_sec, *vw_sec, *wtke_sec, *thl_sec, *qw_sec, *qwthl_sec;
 
   DiagSecondMomentsLbycondData(Int shcol_)
-      : PhysicsTestData({{shcol_}}, {{&wthl_sfc, &wqw_sfc, &uw_sfc, &vw_sfc, &ustar2, &wstar, &wthl_sec, &wqw_sec,
-                                      &uw_sec, &vw_sec, &wtke_sec, &thl_sec, &qw_sec, &qwthl_sec}}),
+      : PhysicsTestData({{shcol_}},
+                        {{&wthl_sfc, &wqw_sfc, &uw_sfc, &vw_sfc, &ustar2, &wstar, &wthl_sec,
+                          &wqw_sec, &uw_sec, &vw_sec, &wtke_sec, &thl_sec, &qw_sec, &qwthl_sec}}),
         shcol(shcol_) {}
 
   PTD_STD_DEF(DiagSecondMomentsLbycondData, 1, shcol);
@@ -672,10 +697,11 @@ struct DiagSecondMomentsData : public ShocTestGridDataBase {
   Real *w_sec;
 
   DiagSecondMomentsData(Int shcol_, Int nlev_, Int nlevi_)
-      : ShocTestGridDataBase(
-            {{shcol_, nlev_}, {shcol_, nlevi_}},
-            {{&thetal, &qw, &u_wind, &v_wind, &tke, &isotropy, &tkh, &tk, &zt_grid, &shoc_mix, &w_sec},
-             {&dz_zi, &zi_grid, &thl_sec, &qw_sec, &wthl_sec, &wqw_sec, &qwthl_sec, &uw_sec, &vw_sec, &wtke_sec}}),
+      : ShocTestGridDataBase({{shcol_, nlev_}, {shcol_, nlevi_}},
+                             {{&thetal, &qw, &u_wind, &v_wind, &tke, &isotropy, &tkh, &tk, &zt_grid,
+                               &shoc_mix, &w_sec},
+                              {&dz_zi, &zi_grid, &thl_sec, &qw_sec, &wthl_sec, &wqw_sec, &qwthl_sec,
+                               &uw_sec, &vw_sec, &wtke_sec}}),
         shcol(shcol_), nlev(nlev_), nlevi(nlevi_) {}
 
   PTD_STD_DEF(DiagSecondMomentsData, 3, shcol, nlev, nlevi);
@@ -684,18 +710,19 @@ struct DiagSecondMomentsData : public ShocTestGridDataBase {
 struct DiagSecondShocMomentsData : public ShocTestGridDataBase {
   // Inputs
   Int shcol, nlev, nlevi;
-  Real *thetal, *qw, *u_wind, *v_wind, *tke, *isotropy, *tkh, *tk, *dz_zi, *shoc_mix, *wthl_sfc, *wqw_sfc, *uw_sfc,
-      *vw_sfc;
+  Real *thetal, *qw, *u_wind, *v_wind, *tke, *isotropy, *tkh, *tk, *dz_zi, *shoc_mix, *wthl_sfc,
+      *wqw_sfc, *uw_sfc, *vw_sfc;
 
   // Outputs
   Real *thl_sec, *qw_sec, *wthl_sec, *wqw_sec, *qwthl_sec, *uw_sec, *vw_sec, *wtke_sec, *w_sec;
 
   DiagSecondShocMomentsData(Int shcol_, Int nlev_, Int nlevi_)
-      : ShocTestGridDataBase(
-            {{shcol_, nlev_}, {shcol_, nlevi_}, {shcol_}},
-            {{&thetal, &qw, &u_wind, &v_wind, &tke, &isotropy, &tkh, &tk, &zt_grid, &shoc_mix, &w_sec},
-             {&dz_zi, &zi_grid, &thl_sec, &qw_sec, &wthl_sec, &wqw_sec, &qwthl_sec, &uw_sec, &vw_sec, &wtke_sec},
-             {&wthl_sfc, &wqw_sfc, &uw_sfc, &vw_sfc}}),
+      : ShocTestGridDataBase({{shcol_, nlev_}, {shcol_, nlevi_}, {shcol_}},
+                             {{&thetal, &qw, &u_wind, &v_wind, &tke, &isotropy, &tkh, &tk, &zt_grid,
+                               &shoc_mix, &w_sec},
+                              {&dz_zi, &zi_grid, &thl_sec, &qw_sec, &wthl_sec, &wqw_sec, &qwthl_sec,
+                               &uw_sec, &vw_sec, &wtke_sec},
+                              {&wthl_sfc, &wqw_sfc, &uw_sfc, &vw_sfc}}),
         shcol(shcol_), nlev(nlev_), nlevi(nlevi_) {}
 
   PTD_STD_DEF(DiagSecondShocMomentsData, 3, shcol, nlev, nlevi);
@@ -726,7 +753,11 @@ struct UpdatePrognosticsImplicitData : public ShocTestGridDataBase {
 
   UpdatePrognosticsImplicitData(Int shcol_, Int nlev_, Int nlevi_, Int num_tracer_, Real dtime_)
       : ShocTestGridDataBase(
-            {{shcol_, nlev_}, {shcol_, nlevi_}, {shcol_}, {shcol_, num_tracer_}, {shcol_, nlev_, num_tracer_}},
+            {{shcol_, nlev_},
+             {shcol_, nlevi_},
+             {shcol_},
+             {shcol_, num_tracer_},
+             {shcol_, nlev_, num_tracer_}},
             {{&dz_zt, &rho_zt, &zt_grid, &tk, &tkh, &thetal, &qw, &tke, &u_wind, &v_wind},
              {&dz_zi, &zi_grid},
              {&uw_sfc, &vw_sfc, &wthl_sfc, &wqw_sfc},
@@ -741,24 +772,25 @@ struct ShocMainData : public ShocTestGridDataBase {
   // Inputs
   Int shcol, nlev, nlevi, nadv, num_qtracers;
   Real dtime;
-  Real *host_dx, *host_dy, *thv, *pres, *presi, *pdel, *wthl_sfc, *wqw_sfc, *uw_sfc, *vw_sfc, *wtracer_sfc, *w_field,
-      *inv_exner, *phis;
+  Real *host_dx, *host_dy, *thv, *pres, *presi, *pdel, *wthl_sfc, *wqw_sfc, *uw_sfc, *vw_sfc,
+      *wtracer_sfc, *w_field, *inv_exner, *phis;
 
   // Inputs for shoc_init
   Int nbot_shoc, ntop_shoc;
   Real *pref_mid;
 
   // Inputs/Outputs
-  Real *host_dse, *tke, *thetal, *qw, *u_wind, *v_wind, *qtracers, *wthv_sec, *tkh, *tk, *shoc_ql, *shoc_cldfrac;
+  Real *host_dse, *tke, *thetal, *qw, *u_wind, *v_wind, *qtracers, *wthv_sec, *tkh, *tk, *shoc_ql,
+      *shoc_cldfrac;
 
   // Outputs
-  Real *pblh, *shoc_mix, *isotropy, *w_sec, *thl_sec, *qw_sec, *qwthl_sec, *wthl_sec, *wqw_sec, *wtke_sec, *uw_sec,
-      *vw_sec, *w3, *wqls_sec, *brunt, *shoc_ql2;
+  Real *pblh, *shoc_mix, *isotropy, *w_sec, *thl_sec, *qw_sec, *qwthl_sec, *wthl_sec, *wqw_sec,
+      *wtke_sec, *uw_sec, *vw_sec, *w3, *wqls_sec, *brunt, *shoc_ql2;
 
   Real elapsed_s;
 
-  ShocMainData(Int shcol_, Int nlev_, Int nlevi_, Int num_qtracers_, Real dtime_, Int nadv_, Int nbot_shoc_,
-               Int ntop_shoc_)
+  ShocMainData(Int shcol_, Int nlev_, Int nlevi_, Int num_qtracers_, Real dtime_, Int nadv_,
+               Int nbot_shoc_, Int ntop_shoc_)
       : ShocTestGridDataBase(
             {{shcol_},
              {shcol_, nlev_},
@@ -767,26 +799,30 @@ struct ShocMainData : public ShocTestGridDataBase {
              {shcol_, nlev_, num_qtracers_},
              {nlev_}},
             {{&host_dx, &host_dy, &wthl_sfc, &wqw_sfc, &uw_sfc, &vw_sfc, &phis, &pblh},
-             {&thv,          &zt_grid,  &pres,     &pdel,   &w_field,  &inv_exner, &host_dse, &tke,
-              &thetal,       &qw,       &u_wind,   &v_wind, &wthv_sec, &tkh,       &tk,       &shoc_ql,
-              &shoc_cldfrac, &shoc_mix, &isotropy, &w_sec,  &wqls_sec, &brunt,     &shoc_ql2},
-             {&zi_grid, &presi, &thl_sec, &qw_sec, &qwthl_sec, &wthl_sec, &wqw_sec, &wtke_sec, &uw_sec, &vw_sec, &w3},
+             {&thv,      &zt_grid, &pres,     &pdel,    &w_field,      &inv_exner,
+              &host_dse, &tke,     &thetal,   &qw,      &u_wind,       &v_wind,
+              &wthv_sec, &tkh,     &tk,       &shoc_ql, &shoc_cldfrac, &shoc_mix,
+              &isotropy, &w_sec,   &wqls_sec, &brunt,   &shoc_ql2},
+             {&zi_grid, &presi, &thl_sec, &qw_sec, &qwthl_sec, &wthl_sec, &wqw_sec, &wtke_sec,
+              &uw_sec, &vw_sec, &w3},
              {&wtracer_sfc},
              {&qtracers},
              {&pref_mid}}),
-        shcol(shcol_), nlev(nlev_), nlevi(nlevi_), nadv(nadv_), num_qtracers(num_qtracers_), dtime(dtime_),
-        nbot_shoc(nbot_shoc_), ntop_shoc(ntop_shoc_) {}
+        shcol(shcol_), nlev(nlev_), nlevi(nlevi_), nadv(nadv_), num_qtracers(num_qtracers_),
+        dtime(dtime_), nbot_shoc(nbot_shoc_), ntop_shoc(ntop_shoc_) {}
 
   PTD_STD_DEF(ShocMainData, 8, shcol, nlev, nlevi, num_qtracers, dtime, nadv, nbot_shoc, ntop_shoc);
 
   template <size_t N>
-  Real interpolate_data(const std::array<Real, N> &ref_elevations, const std::array<Real, N> &ref_data, Real z) {
+  Real interpolate_data(const std::array<Real, N> &ref_elevations,
+                        const std::array<Real, N> &ref_data, Real z) {
     auto pos  = std::lower_bound(ref_elevations.begin(), ref_elevations.end(), z);
     Int index = pos - ref_elevations.begin();
     if (index == 0)
       return ref_data[0];
     else if (index < (Int)N) {
-      const Real a = (z - ref_elevations[index - 1]) / (ref_elevations[index] - ref_elevations[index - 1]);
+      const Real a =
+          (z - ref_elevations[index - 1]) / (ref_elevations[index] - ref_elevations[index - 1]);
       return (1.0 - a) * ref_data[index - 1] + a * ref_data[index];
     } else {
       // Don't extrapolate off the end of the table.
@@ -823,7 +859,8 @@ struct ShocMainData : public ShocTestGridDataBase {
   }
 
   template <typename Engine>
-  void randomize(Engine &engine, const std::vector<std::pair<void *, std::pair<Real, Real>>> &ranges = {}) {
+  void randomize(Engine &engine,
+                 const std::vector<std::pair<void *, std::pair<Real, Real>>> &ranges = {}) {
     using consts = scream::physics::Constants<Real>;
 
     ShocTestGridDataBase::randomize(engine, ranges);
@@ -844,15 +881,19 @@ struct ShocMainData : public ShocTestGridDataBase {
       const auto nlev_offset  = i * nlev;
       const auto nlevi_offset = i * nlevi;
       for (auto k = decltype(nlev){0}; k < nlev; ++k) {
-        pdel[nlev_offset + k]      = std::abs(presi[nlevi_offset + k] - presi[nlevi_offset + k + 1]);
-        inv_exner[nlev_offset + k] = pow(pres[nlev_offset + k] / consts::P0, consts::Rair / consts::Cpair);
-        host_dse[nlev_offset + k]  = consts::Cpair * inv_exner[nlev_offset + k] * thv[nlev_offset + k] +
-                                    consts::gravit * zt_grid[nlev_offset + k];
+        pdel[nlev_offset + k] = std::abs(presi[nlevi_offset + k] - presi[nlevi_offset + k + 1]);
+        inv_exner[nlev_offset + k] =
+            pow(pres[nlev_offset + k] / consts::P0, consts::Rair / consts::Cpair);
+        host_dse[nlev_offset + k] =
+            consts::Cpair * inv_exner[nlev_offset + k] * thv[nlev_offset + k] +
+            consts::gravit * zt_grid[nlev_offset + k];
 
-        const Real qv              = qw[nlev_offset + k] - shoc_ql[nlev_offset + k];
-        thetal[nlev_offset + k]    = pot_temp - (consts::LatVap / consts::Cpair) * shoc_ql[nlev_offset + k];
-        thv[nlev_offset + k]       = pot_temp * (1 + 0.61 * qv - shoc_ql[nlev_offset + k]);
-        inv_exner[nlev_offset + k] = 1 / std::pow(pres[nlev_offset + k] / consts::P0, consts::Rair / consts::Cpair);
+        const Real qv = qw[nlev_offset + k] - shoc_ql[nlev_offset + k];
+        thetal[nlev_offset + k] =
+            pot_temp - (consts::LatVap / consts::Cpair) * shoc_ql[nlev_offset + k];
+        thv[nlev_offset + k] = pot_temp * (1 + 0.61 * qv - shoc_ql[nlev_offset + k]);
+        inv_exner[nlev_offset + k] =
+            1 / std::pow(pres[nlev_offset + k] / consts::P0, consts::Rair / consts::Cpair);
       }
     }
 
@@ -899,8 +940,8 @@ struct PblintdHeightData : public PhysicsTestData {
   Real *pblh;
 
   PblintdHeightData(Int shcol_, Int nlev_, Int npbl_)
-      : PhysicsTestData({{shcol_, nlev_}, {shcol_}, {shcol_}}, {{&z, &u, &v, &thv, &rino}, {&ustar, &thv_ref, &pblh}},
-                        {}, {{&check}}),
+      : PhysicsTestData({{shcol_, nlev_}, {shcol_}, {shcol_}},
+                        {{&z, &u, &v, &thv, &rino}, {&ustar, &thv_ref, &pblh}}, {}, {{&check}}),
         shcol(shcol_), nlev(nlev_), npbl(npbl_) {}
 
   PTD_STD_DEF(PblintdHeightData, 3, shcol, nlev, npbl);
@@ -953,8 +994,9 @@ struct PblintdCheckPblhData : public PhysicsTestData {
   Real *pblh;
 
   PblintdCheckPblhData(Int shcol_, Int nlev_, Int nlevi_)
-      : PhysicsTestData({{shcol_, nlev_}, {shcol_}, {shcol_}}, {{&z}, {&ustar, &pblh}}, {}, {{&check}}), shcol(shcol_),
-        nlev(nlev_), nlevi(nlevi_) {}
+      : PhysicsTestData({{shcol_, nlev_}, {shcol_}, {shcol_}}, {{&z}, {&ustar, &pblh}}, {},
+                        {{&check}}),
+        shcol(shcol_), nlev(nlev_), nlevi(nlevi_) {}
 
   PTD_STD_DEF(PblintdCheckPblhData, 3, shcol, nlev, nlevi);
 };
@@ -968,8 +1010,9 @@ struct PblintdData : public PhysicsTestData {
   Real *pblh;
 
   PblintdData(Int shcol_, Int nlev_, Int nlevi_, Int npbl_)
-      : PhysicsTestData({{shcol_, nlev_}, {shcol_, nlevi_}, {shcol_}},
-                        {{&z, &thl, &ql, &q, &u, &v, &cldn}, {&zi}, {&ustar, &obklen, &kbfs, &pblh}}),
+      : PhysicsTestData(
+            {{shcol_, nlev_}, {shcol_, nlevi_}, {shcol_}},
+            {{&z, &thl, &ql, &q, &u, &v, &cldn}, {&zi}, {&ustar, &obklen, &kbfs, &pblh}}),
         shcol(shcol_), nlev(nlev_), nlevi(nlevi_), npbl(npbl_) {}
 
   PTD_STD_DEF(PblintdData, 4, shcol, nlev, nlevi, npbl);
@@ -984,7 +1027,8 @@ struct ComputeShocTempData : public PhysicsTestData {
   Real *tabs;
 
   ComputeShocTempData(Int shcol_, Int nlev_)
-      : PhysicsTestData({{shcol_, nlev_}}, {{&thetal, &ql, &inv_exner, &tabs}}), shcol(shcol_), nlev(nlev_) {}
+      : PhysicsTestData({{shcol_, nlev_}}, {{&thetal, &ql, &inv_exner, &tabs}}), shcol(shcol_),
+        nlev(nlev_) {}
 
   PTD_STD_DEF(ComputeShocTempData, 2, shcol, nlev);
 };
@@ -1027,7 +1071,8 @@ void shoc_assumed_pdf_compute_temperature(ShocAssumedPdfComputeTemperatureData &
 void shoc_assumed_pdf_compute_qs(ShocAssumedPdfComputeQsData &d);
 void shoc_assumed_pdf_compute_s(ShocAssumedPdfComputeSData &d);
 void shoc_assumed_pdf_compute_sgs_liquid(ShocAssumedPdfComputeSgsLiquidData &d);
-void shoc_assumed_pdf_compute_cloud_liquid_variance(ShocAssumedPdfComputeCloudLiquidVarianceData &d);
+void shoc_assumed_pdf_compute_cloud_liquid_variance(
+    ShocAssumedPdfComputeCloudLiquidVarianceData &d);
 void shoc_assumed_pdf_compute_liquid_water_flux(ShocAssumedPdfComputeLiquidWaterFluxData &d);
 void shoc_assumed_pdf_compute_buoyancy_flux(ShocAssumedPdfComputeBuoyancyFluxData &d);
 void diag_second_moments_ubycond(DiagSecondMomentsUbycondData &d);
@@ -1048,141 +1093,181 @@ void compute_shoc_temperature(ComputeShocTempData &d);
 
 // Call from host
 
-void calc_shoc_varorcovar_host(Int shcol, Int nlev, Int nlevi, Real tunefac, Real *isotropy_zi, Real *tkh_zi,
-                               Real *dz_zi, Real *invar1, Real *invar2, Real *varorcovar);
-void calc_shoc_vertflux_host(Int shcol, Int nlev, Int nlevi, Real *tkh_zi, Real *dz_zi, Real *invar, Real *vertflux);
-void shoc_diag_second_moments_srf_host(Int shcol, Real *wthl, Real *uw, Real *vw, Real *ustar2, Real *wstar);
-void shoc_diag_second_moments_ubycond_host(Int shcol, Real *thl, Real *qw, Real *wthl, Real *wqw, Real *qwthl, Real *uw,
-                                           Real *vw, Real *wtke);
-void update_host_dse_host(Int shcol, Int nlev, Real *thlm, Real *shoc_ql, Real *inv_exner, Real *zt_grid, Real *phis,
-                          Real *host_dse);
-void compute_diag_third_shoc_moment_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, Real *thl_sec, Real *wthl_sec,
-                                         Real *tke, Real *dz_zt, Real *dz_zi, Real *isotropy_zi, Real *brunt_zi,
-                                         Real *w_sec_zi, Real *thetal_zi, Real *w3);
+void calc_shoc_varorcovar_host(Int shcol, Int nlev, Int nlevi, Real tunefac, Real *isotropy_zi,
+                               Real *tkh_zi, Real *dz_zi, Real *invar1, Real *invar2,
+                               Real *varorcovar);
+void calc_shoc_vertflux_host(Int shcol, Int nlev, Int nlevi, Real *tkh_zi, Real *dz_zi, Real *invar,
+                             Real *vertflux);
+void shoc_diag_second_moments_srf_host(Int shcol, Real *wthl, Real *uw, Real *vw, Real *ustar2,
+                                       Real *wstar);
+void shoc_diag_second_moments_ubycond_host(Int shcol, Real *thl, Real *qw, Real *wthl, Real *wqw,
+                                           Real *qwthl, Real *uw, Real *vw, Real *wtke);
+void update_host_dse_host(Int shcol, Int nlev, Real *thlm, Real *shoc_ql, Real *inv_exner,
+                          Real *zt_grid, Real *phis, Real *host_dse);
+void compute_diag_third_shoc_moment_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, Real *thl_sec,
+                                         Real *wthl_sec, Real *tke, Real *dz_zt, Real *dz_zi,
+                                         Real *isotropy_zi, Real *brunt_zi, Real *w_sec_zi,
+                                         Real *thetal_zi, Real *w3);
 void shoc_pblintd_init_pot_host(Int shcol, Int nlev, Real *thl, Real *ql, Real *q, Real *thv);
-void compute_shoc_mix_shoc_length_host(Int nlev, Int shcol, Real *tke, Real *brunt, Real *zt_grid, Real *l_inf,
-                                       Real *shoc_mix);
+void compute_shoc_mix_shoc_length_host(Int nlev, Int shcol, Real *tke, Real *brunt, Real *zt_grid,
+                                       Real *l_inf, Real *shoc_mix);
 void check_tke_host(Int shcol, Int nlev, Real *tke);
-void linear_interp_host(Real *x1, Real *x2, Real *y1, Real *y2, Int km1, Int km2, Int ncol, Real minthresh);
+void linear_interp_host(Real *x1, Real *x2, Real *y1, Real *y2, Int km1, Int km2, Int ncol,
+                        Real minthresh);
 void clipping_diag_third_shoc_moments_host(Int nlevi, Int shcol, Real *w_sec_zi, Real *w3);
-void shoc_energy_integrals_host(Int shcol, Int nlev, Real *host_dse, Real *pdel, Real *rtm, Real *rcm, Real *u_wind,
-                                Real *v_wind, Real *se_int, Real *ke_int, Real *wv_int, Real *wl_int);
-void compute_brunt_shoc_length_host(Int nlev, Int nlevi, Int shcol, Real *dz_zt, Real *thv, Real *thv_zi, Real *brunt);
-void compute_l_inf_shoc_length_host(Int nlev, Int shcol, Real *zt_grid, Real *dz_zt, Real *tke, Real *l_inf);
-void check_length_scale_shoc_length_host(Int nlev, Int shcol, Real *host_dx, Real *host_dy, Real *shoc_mix);
-void diag_second_moments_lbycond_host(Int shcol, Real *wthl_sfc, Real *wqw_sfc, Real *uw_sfc, Real *vw_sfc,
-                                      Real *ustar2, Real *wstar, Real *wthl_sec, Real *wqw_sec, Real *uw_sec,
-                                      Real *vw_sec, Real *wtke_sec, Real *thl_sec, Real *qw_sec, Real *qwthl_sec);
-void diag_second_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw, Real *u_wind, Real *v_wind,
-                              Real *tke, Real *isotropy, Real *tkh, Real *tk, Real *dz_zi, Real *zt_grid, Real *zi_grid,
-                              Real *shoc_mix, Real *thl_sec, Real *qw_sec, Real *wthl_sec, Real *wqw_sec,
-                              Real *qwthl_sec, Real *uw_sec, Real *vw_sec, Real *wtke_sec, Real *w_sec);
-void diag_second_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw, Real *u_wind, Real *v_wind,
-                                   Real *tke, Real *isotropy, Real *tkh, Real *tk, Real *dz_zi, Real *zt_grid,
-                                   Real *zi_grid, Real *shoc_mix, Real *wthl_sfc, Real *wqw_sfc, Real *uw_sfc,
-                                   Real *vw_sfc, Real *thl_sec, Real *qw_sec, Real *wthl_sec, Real *wqw_sec,
-                                   Real *qwthl_sec, Real *uw_sec, Real *vw_sec, Real *wtke_sec, Real *w_sec);
-void shoc_diag_obklen_host(Int shcol, Real *uw_sfc, Real *vw_sfc, Real *wthl_sfc, Real *wqw_sfc, Real *thl_sfc,
-                           Real *cldliq_sfc, Real *qv_sfc, Real *ustar, Real *kbfs, Real *obklen);
+void shoc_energy_integrals_host(Int shcol, Int nlev, Real *host_dse, Real *pdel, Real *rtm,
+                                Real *rcm, Real *u_wind, Real *v_wind, Real *se_int, Real *ke_int,
+                                Real *wv_int, Real *wl_int);
+void compute_brunt_shoc_length_host(Int nlev, Int nlevi, Int shcol, Real *dz_zt, Real *thv,
+                                    Real *thv_zi, Real *brunt);
+void compute_l_inf_shoc_length_host(Int nlev, Int shcol, Real *zt_grid, Real *dz_zt, Real *tke,
+                                    Real *l_inf);
+void check_length_scale_shoc_length_host(Int nlev, Int shcol, Real *host_dx, Real *host_dy,
+                                         Real *shoc_mix);
+void diag_second_moments_lbycond_host(Int shcol, Real *wthl_sfc, Real *wqw_sfc, Real *uw_sfc,
+                                      Real *vw_sfc, Real *ustar2, Real *wstar, Real *wthl_sec,
+                                      Real *wqw_sec, Real *uw_sec, Real *vw_sec, Real *wtke_sec,
+                                      Real *thl_sec, Real *qw_sec, Real *qwthl_sec);
+void diag_second_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw, Real *u_wind,
+                              Real *v_wind, Real *tke, Real *isotropy, Real *tkh, Real *tk,
+                              Real *dz_zi, Real *zt_grid, Real *zi_grid, Real *shoc_mix,
+                              Real *thl_sec, Real *qw_sec, Real *wthl_sec, Real *wqw_sec,
+                              Real *qwthl_sec, Real *uw_sec, Real *vw_sec, Real *wtke_sec,
+                              Real *w_sec);
+void diag_second_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw,
+                                   Real *u_wind, Real *v_wind, Real *tke, Real *isotropy, Real *tkh,
+                                   Real *tk, Real *dz_zi, Real *zt_grid, Real *zi_grid,
+                                   Real *shoc_mix, Real *wthl_sfc, Real *wqw_sfc, Real *uw_sfc,
+                                   Real *vw_sfc, Real *thl_sec, Real *qw_sec, Real *wthl_sec,
+                                   Real *wqw_sec, Real *qwthl_sec, Real *uw_sec, Real *vw_sec,
+                                   Real *wtke_sec, Real *w_sec);
+void shoc_diag_obklen_host(Int shcol, Real *uw_sfc, Real *vw_sfc, Real *wthl_sfc, Real *wqw_sfc,
+                           Real *thl_sfc, Real *cldliq_sfc, Real *qv_sfc, Real *ustar, Real *kbfs,
+                           Real *obklen);
 void shoc_pblintd_cldcheck_host(Int shcol, Int nlev, Int nlevi, Real *zi, Real *cldn, Real *pblh);
-void compute_shr_prod_host(Int nlevi, Int nlev, Int shcol, Real *dz_zi, Real *u_wind, Real *v_wind, Real *sterm);
-void shoc_length_host(Int shcol, Int nlev, Int nlevi, Real *host_dx, Real *host_dy, Real *zt_grid, Real *zi_grid,
-                      Real *dz_zt, Real *tke, Real *thv, Real *brunt, Real *shoc_mix);
-void shoc_energy_fixer_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Real *zt_grid, Real *zi_grid,
-                            Real *se_b, Real *ke_b, Real *wv_b, Real *wl_b, Real *se_a, Real *ke_a, Real *wv_a,
-                            Real *wl_a, Real *wthl_sfc, Real *wqw_sfc, Real *rho_zt, Real *tke, Real *pint,
-                            Real *host_dse);
+void compute_shr_prod_host(Int nlevi, Int nlev, Int shcol, Real *dz_zi, Real *u_wind, Real *v_wind,
+                           Real *sterm);
+void shoc_length_host(Int shcol, Int nlev, Int nlevi, Real *host_dx, Real *host_dy, Real *zt_grid,
+                      Real *zi_grid, Real *dz_zt, Real *tke, Real *thv, Real *brunt,
+                      Real *shoc_mix);
+void shoc_energy_fixer_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Real *zt_grid,
+                            Real *zi_grid, Real *se_b, Real *ke_b, Real *wv_b, Real *wl_b,
+                            Real *se_a, Real *ke_a, Real *wv_a, Real *wl_a, Real *wthl_sfc,
+                            Real *wqw_sfc, Real *rho_zt, Real *tke, Real *pint, Real *host_dse);
 void compute_shoc_vapor_host(Int shcol, Int nlev, Real *qw, Real *ql, Real *qv);
-void update_prognostics_implicit_host(Int shcol, Int nlev, Int nlevi, Int num_tracer, Real dtime, Real *dz_zt,
-                                      Real *dz_zi, Real *rho_zt, Real *zt_grid, Real *zi_grid, Real *tk, Real *tkh,
-                                      Real *uw_sfc, Real *vw_sfc, Real *wthl_sfc, Real *wqw_sfc, Real *wtracer_sfc,
-                                      Real *thetal, Real *qw, Real *tracer, Real *tke, Real *u_wind, Real *v_wind);
-void diag_third_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, Real *thl_sec, Real *wthl_sec,
-                                  Real *isotropy, Real *brunt, Real *thetal, Real *tke, Real *dz_zt, Real *dz_zi,
-                                  Real *zt_grid, Real *zi_grid, Real *w3);
-void adv_sgs_tke_host(Int nlev, Int shcol, Real dtime, Real *shoc_mix, Real *wthv_sec, Real *sterm_zt, Real *tk,
-                      Real *tke, Real *a_diss);
-void shoc_assumed_pdf_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw, Real *w_field, Real *thl_sec,
-                           Real *qw_sec, Real *wthl_sec, Real *w_sec, Real *wqw_sec, Real *qwthl_sec, Real *w3,
-                           Real *pres, Real *zt_grid, Real *zi_grid, Real *shoc_cldfrac, Real *shoc_ql, Real *wqls,
-                           Real *wthv_sec, Real *shoc_ql2);
+void update_prognostics_implicit_host(Int shcol, Int nlev, Int nlevi, Int num_tracer, Real dtime,
+                                      Real *dz_zt, Real *dz_zi, Real *rho_zt, Real *zt_grid,
+                                      Real *zi_grid, Real *tk, Real *tkh, Real *uw_sfc,
+                                      Real *vw_sfc, Real *wthl_sfc, Real *wqw_sfc,
+                                      Real *wtracer_sfc, Real *thetal, Real *qw, Real *tracer,
+                                      Real *tke, Real *u_wind, Real *v_wind);
+void diag_third_shoc_moments_host(Int shcol, Int nlev, Int nlevi, Real *w_sec, Real *thl_sec,
+                                  Real *wthl_sec, Real *isotropy, Real *brunt, Real *thetal,
+                                  Real *tke, Real *dz_zt, Real *dz_zi, Real *zt_grid, Real *zi_grid,
+                                  Real *w3);
+void adv_sgs_tke_host(Int nlev, Int shcol, Real dtime, Real *shoc_mix, Real *wthv_sec,
+                      Real *sterm_zt, Real *tk, Real *tke, Real *a_diss);
+void shoc_assumed_pdf_host(Int shcol, Int nlev, Int nlevi, Real *thetal, Real *qw, Real *w_field,
+                           Real *thl_sec, Real *qw_sec, Real *wthl_sec, Real *w_sec, Real *wqw_sec,
+                           Real *qwthl_sec, Real *w3, Real *pres, Real *zt_grid, Real *zi_grid,
+                           Real *shoc_cldfrac, Real *shoc_ql, Real *wqls, Real *wthv_sec,
+                           Real *shoc_ql2);
 void compute_tmpi_host(Int nlevi, Int shcol, Real dtime, Real *rho_zi, Real *dz_zi, Real *tmpi);
-void integ_column_stability_host(Int nlev, Int shcol, Real *dz_zt, Real *pres, Real *brunt, Real *brunt_int);
-void isotropic_ts_host(Int nlev, Int shcol, Real *brunt_int, Real *tke, Real *a_diss, Real *brunt, Real *isotropy);
+void integ_column_stability_host(Int nlev, Int shcol, Real *dz_zt, Real *pres, Real *brunt,
+                                 Real *brunt_int);
+void isotropic_ts_host(Int nlev, Int shcol, Real *brunt_int, Real *tke, Real *a_diss, Real *brunt,
+                       Real *isotropy);
 void dp_inverse_host(Int nlev, Int shcol, Real *rho_zt, Real *dz_zt, Real *rdp_zt);
 
 int shoc_init_host(Int nlev, Real *pref_mid, Int nbot_shoc, Int ntop_shoc);
-Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npbl, Real *host_dx, Real *host_dy,
-                   Real *thv, Real *zt_grid, Real *zi_grid, Real *pres, Real *presi, Real *pdel, Real *wthl_sfc,
-                   Real *wqw_sfc, Real *uw_sfc, Real *vw_sfc, Real *wtracer_sfc, Int num_qtracers, Real *w_field,
-                   Real *inv_exner, Real *phis, Real *host_dse, Real *tke, Real *thetal, Real *qw, Real *u_wind,
-                   Real *v_wind, Real *qtracers, Real *wthv_sec, Real *tkh, Real *tk, Real *shoc_ql, Real *shoc_cldfrac,
-                   Real *pblh, Real *shoc_mix, Real *isotropy, Real *w_sec, Real *thl_sec, Real *qw_sec,
-                   Real *qwthl_sec, Real *wthl_sec, Real *wqw_sec, Real *wtke_sec, Real *uw_sec, Real *vw_sec, Real *w3,
-                   Real *wqls_sec, Real *brunt, Real *shoc_ql2);
+Int shoc_main_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Int npbl, Real *host_dx,
+                   Real *host_dy, Real *thv, Real *zt_grid, Real *zi_grid, Real *pres, Real *presi,
+                   Real *pdel, Real *wthl_sfc, Real *wqw_sfc, Real *uw_sfc, Real *vw_sfc,
+                   Real *wtracer_sfc, Int num_qtracers, Real *w_field, Real *inv_exner, Real *phis,
+                   Real *host_dse, Real *tke, Real *thetal, Real *qw, Real *u_wind, Real *v_wind,
+                   Real *qtracers, Real *wthv_sec, Real *tkh, Real *tk, Real *shoc_ql,
+                   Real *shoc_cldfrac, Real *pblh, Real *shoc_mix, Real *isotropy, Real *w_sec,
+                   Real *thl_sec, Real *qw_sec, Real *qwthl_sec, Real *wthl_sec, Real *wqw_sec,
+                   Real *wtke_sec, Real *uw_sec, Real *vw_sec, Real *w3, Real *wqls_sec,
+                   Real *brunt, Real *shoc_ql2);
 
-void pblintd_height_host(Int shcol, Int nlev, Int npbl, Real *z, Real *u, Real *v, Real *ustar, Real *thv,
-                         Real *thv_ref, Real *pblh, Real *rino, bool *check);
+void pblintd_height_host(Int shcol, Int nlev, Int npbl, Real *z, Real *u, Real *v, Real *ustar,
+                         Real *thv, Real *thv_ref, Real *pblh, Real *rino, bool *check);
 
-void vd_shoc_decomp_and_solve_host(Int shcol, Int nlev, Int nlevi, Int num_rhs, Real dtime, Real *kv_term, Real *tmpi,
-                                   Real *rdp_zt, Real *flux, Real *var);
+void vd_shoc_decomp_and_solve_host(Int shcol, Int nlev, Int nlevi, Int num_rhs, Real dtime,
+                                   Real *kv_term, Real *tmpi, Real *rdp_zt, Real *flux, Real *var);
 
-void pblintd_surf_temp_host(Int shcol, Int nlev, Int nlevi, Real *z, Real *ustar, Real *obklen, Real *kbfs, Real *thv,
-                            Real *tlv, Real *pblh, bool *check, Real *rino);
+void pblintd_surf_temp_host(Int shcol, Int nlev, Int nlevi, Real *z, Real *ustar, Real *obklen,
+                            Real *kbfs, Real *thv, Real *tlv, Real *pblh, bool *check, Real *rino);
 
-void pblintd_check_pblh_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *ustar, bool *check, Real *pblh);
+void pblintd_check_pblh_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *ustar,
+                             bool *check, Real *pblh);
 
-void pblintd_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *zi, Real *thl, Real *ql, Real *q, Real *u,
-                  Real *v, Real *ustar, Real *obklen, Real *kbfs, Real *cldn, Real *pblh);
-void shoc_grid_host(Int shcol, Int nlev, Int nlevi, Real *zt_grid, Real *zi_grid, Real *pdel, Real *dz_zt, Real *dz_zi,
-                    Real *rho_zt);
-void eddy_diffusivities_host(Int nlev, Int shcol, Real *pblh, Real *zt_grid, Real *tabs, Real *shoc_mix, Real *sterm_zt,
-                             Real *isotropy, Real *tke, Real *tkh, Real *tk);
-void shoc_tke_host(Int shcol, Int nlev, Int nlevi, Real dtime, Real *wthv_sec, Real *shoc_mix, Real *dz_zi, Real *dz_zt,
-                   Real *pres, Real *u_wind, Real *v_wind, Real *brunt, Real *obklen, Real *zt_grid, Real *zi_grid,
-                   Real *pblh, Real *tke, Real *tk, Real *tkh, Real *isotropy);
-void compute_shoc_temperature_host(Int shcol, Int nlev, Real *thetal, Real *ql, Real *inv_exner, Real *tabs);
+void pblintd_host(Int shcol, Int nlev, Int nlevi, Int npbl, Real *z, Real *zi, Real *thl, Real *ql,
+                  Real *q, Real *u, Real *v, Real *ustar, Real *obklen, Real *kbfs, Real *cldn,
+                  Real *pblh);
+void shoc_grid_host(Int shcol, Int nlev, Int nlevi, Real *zt_grid, Real *zi_grid, Real *pdel,
+                    Real *dz_zt, Real *dz_zi, Real *rho_zt);
+void eddy_diffusivities_host(Int nlev, Int shcol, Real *pblh, Real *zt_grid, Real *tabs,
+                             Real *shoc_mix, Real *sterm_zt, Real *isotropy, Real *tke, Real *tkh,
+                             Real *tk);
+void shoc_tke_host(Int shcol, Int nlev, Int nlevi, Real dtime, Real *wthv_sec, Real *shoc_mix,
+                   Real *dz_zi, Real *dz_zt, Real *pres, Real *u_wind, Real *v_wind, Real *brunt,
+                   Real *obklen, Real *zt_grid, Real *zi_grid, Real *pblh, Real *tke, Real *tk,
+                   Real *tkh, Real *isotropy);
+void compute_shoc_temperature_host(Int shcol, Int nlev, Real *thetal, Real *ql, Real *inv_exner,
+                                   Real *tabs);
 
-void shoc_energy_total_fixer_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv, Real *zt_grid, Real *zi_grid,
-                                  Real *se_b, Real *ke_b, Real *wv_b, Real *wl_b, Real *se_a, Real *ke_a, Real *wv_a,
-                                  Real *wl_a, Real *wthl_sfc, Real *wqw_sfc, Real *rho_zt, Real *pint, Real *te_a,
-                                  Real *te_b);
+void shoc_energy_total_fixer_host(Int shcol, Int nlev, Int nlevi, Real dtime, Int nadv,
+                                  Real *zt_grid, Real *zi_grid, Real *se_b, Real *ke_b, Real *wv_b,
+                                  Real *wl_b, Real *se_a, Real *ke_a, Real *wv_a, Real *wl_a,
+                                  Real *wthl_sfc, Real *wqw_sfc, Real *rho_zt, Real *pint,
+                                  Real *te_a, Real *te_b);
 
 void shoc_assumed_pdf_tilde_to_real_host(Real w_first, Real sqrtw2, Real *w1);
 
-void shoc_assumed_pdf_vv_parameters_host(Real w_first, Real w_sec, Real w3var, Real w_tol_sqd, Real *skew_w, Real *w1_1,
-                                         Real *w1_2, Real *w2_1, Real *w2_2, Real *a);
+void shoc_assumed_pdf_vv_parameters_host(Real w_first, Real w_sec, Real w3var, Real w_tol_sqd,
+                                         Real *skew_w, Real *w1_1, Real *w1_2, Real *w2_1,
+                                         Real *w2_2, Real *a);
 
-void shoc_assumed_pdf_thl_parameters_host(Real wthlsec, Real sqrtw2, Real sqrtthl, Real thlsec, Real thl_first,
-                                          Real w1_1, Real w1_2, Real skew_w, Real a, Real thl_tol, Real w_thresh,
-                                          Real *thl1_1, Real *thl1_2, Real *thl2_1, Real *thl2_2, Real *sqrtthl2_1,
+void shoc_assumed_pdf_thl_parameters_host(Real wthlsec, Real sqrtw2, Real sqrtthl, Real thlsec,
+                                          Real thl_first, Real w1_1, Real w1_2, Real skew_w, Real a,
+                                          Real thl_tol, Real w_thresh, Real *thl1_1, Real *thl1_2,
+                                          Real *thl2_1, Real *thl2_2, Real *sqrtthl2_1,
                                           Real *sqrtthl2_2);
 
-void shoc_assumed_pdf_qw_parameters_host(Real wqwsec, Real sqrtw2, Real skew_w, Real sqrtqt, Real qwsec, Real w1_2,
-                                         Real w1_1, Real qw_first, Real a, Real rt_tol, Real w_thresh, Real *qw1_1,
-                                         Real *qw1_2, Real *qw2_1, Real *qw2_2, Real *sqrtqw2_1, Real *sqrtqw2_2);
+void shoc_assumed_pdf_qw_parameters_host(Real wqwsec, Real sqrtw2, Real skew_w, Real sqrtqt,
+                                         Real qwsec, Real w1_2, Real w1_1, Real qw_first, Real a,
+                                         Real rt_tol, Real w_thresh, Real *qw1_1, Real *qw1_2,
+                                         Real *qw2_1, Real *qw2_2, Real *sqrtqw2_1,
+                                         Real *sqrtqw2_2);
 
-void shoc_assumed_pdf_inplume_correlations_host(Real sqrtqw2_1, Real sqrtthl2_1, Real a, Real sqrtqw2_2,
-                                                Real sqrtthl2_2, Real qwthlsec, Real qw1_1, Real qw_first, Real thl1_1,
-                                                Real thl_first, Real qw1_2, Real thl1_2, Real *r_qwthl_1);
+void shoc_assumed_pdf_inplume_correlations_host(Real sqrtqw2_1, Real sqrtthl2_1, Real a,
+                                                Real sqrtqw2_2, Real sqrtthl2_2, Real qwthlsec,
+                                                Real qw1_1, Real qw_first, Real thl1_1,
+                                                Real thl_first, Real qw1_2, Real thl1_2,
+                                                Real *r_qwthl_1);
 
 void shoc_assumed_pdf_compute_temperature_host(Real thl1, Real pval, Real *tl1);
 
-void shoc_assumed_pdf_compute_qs_host(Real tl1_1, Real tl1_2, Real pval, Real *qs1, Real *beta1, Real *qs2,
-                                      Real *beta2);
+void shoc_assumed_pdf_compute_qs_host(Real tl1_1, Real tl1_2, Real pval, Real *qs1, Real *beta1,
+                                      Real *qs2, Real *beta2);
 
-void shoc_assumed_pdf_compute_s_host(Real qw1, Real qs1, Real beta, Real pval, Real thl2, Real qw2, Real sqrtthl2,
-                                     Real sqrtqw2, Real r_qwthl, Real *s, Real *std_s, Real *qn, Real *c);
+void shoc_assumed_pdf_compute_s_host(Real qw1, Real qs1, Real beta, Real pval, Real thl2, Real qw2,
+                                     Real sqrtthl2, Real sqrtqw2, Real r_qwthl, Real *s,
+                                     Real *std_s, Real *qn, Real *c);
 
 void shoc_assumed_pdf_compute_sgs_liquid_host(Real a, Real ql1, Real ql2, Real *shoc_ql);
 
-void shoc_assumed_pdf_compute_cloud_liquid_variance_host(Real a, Real s1, Real ql1, Real c1, Real std_s1, Real s2,
-                                                         Real ql2, Real c2, Real std_s2, Real shoc_ql, Real *shoc_ql2);
+void shoc_assumed_pdf_compute_cloud_liquid_variance_host(Real a, Real s1, Real ql1, Real c1,
+                                                         Real std_s1, Real s2, Real ql2, Real c2,
+                                                         Real std_s2, Real shoc_ql, Real *shoc_ql2);
 
-void shoc_assumed_pdf_compute_liquid_water_flux_host(Real a, Real w1_1, Real w_first, Real ql1, Real w1_2, Real ql2,
-                                                     Real *wqls);
+void shoc_assumed_pdf_compute_liquid_water_flux_host(Real a, Real w1_1, Real w_first, Real ql1,
+                                                     Real w1_2, Real ql2, Real *wqls);
 
-void shoc_assumed_pdf_compute_buoyancy_flux_host(Real wthlsec, Real wqwsec, Real pval, Real wqls, Real *wthv_sec);
+void shoc_assumed_pdf_compute_buoyancy_flux_host(Real wthlsec, Real wqwsec, Real pval, Real wqls,
+                                                 Real *wthv_sec);
 
 // end _host function decls
 
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_assumed_pdf_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_assumed_pdf_tests.cpp
index b700cbf7c5..4898a9342e 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_assumed_pdf_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_assumed_pdf_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocAssumedPdf : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocAssumedPdf : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol  = 2;
@@ -460,13 +461,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocAssumedPdf : public
 namespace {
 
 TEST_CASE("shoc_assumed_pdf_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocAssumedPdf;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocAssumedPdf;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_assumed_pdf_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocAssumedPdf;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocAssumedPdf;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_brunt_length_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_brunt_length_tests.cpp
index ab71faa7f9..f78d64d22c 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_brunt_length_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_brunt_length_tests.cpp
@@ -21,7 +21,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestCompBruntShocLength : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestCompBruntShocLength : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol  = 2;
@@ -185,13 +186,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCompBruntShocLength : pu
 namespace {
 
 TEST_CASE("shoc_brunt_length_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCompBruntShocLength;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCompBruntShocLength;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_brunt_length_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCompBruntShocLength;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCompBruntShocLength;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_check_length_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_check_length_tests.cpp
index e2bbaa9909..07c65ab77c 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_check_length_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_check_length_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestCheckShocLength : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestCheckShocLength : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Real maxlen = scream::shoc::Constants<Real>::maxlen;
@@ -155,13 +156,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCheckShocLength : public
 namespace {
 
 TEST_CASE("shoc_check_length_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCheckShocLength;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCheckShocLength;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_check_length_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCheckShocLength;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCheckShocLength;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_check_tke_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_check_tke_tests.cpp
index 25b3935a5c..b8476e073d 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_check_tke_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_check_tke_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocCheckTke : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocCheckTke : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Real mintke = scream::shoc::Constants<Real>::mintke;
@@ -136,13 +137,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocCheckTke : public Un
 namespace {
 
 TEST_CASE("shoc_check_tke_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocCheckTke;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocCheckTke;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_check_tke_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocCheckTke;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocCheckTke;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_clip_third_moms_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_clip_third_moms_tests.cpp
index 76ffddf002..6e549fb740 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_clip_third_moms_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_clip_third_moms_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestClipThirdMoms : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestClipThirdMoms : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -162,13 +163,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestClipThirdMoms : public U
 namespace {
 
 TEST_CASE("shoc_clip_third_moms_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestClipThirdMoms;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestClipThirdMoms;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_clip_third_moms_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestClipThirdMoms;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestClipThirdMoms;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_compute_diag_third_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_compute_diag_third_tests.cpp
index be7c647a91..735926e038 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_compute_diag_third_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_compute_diag_third_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocCompDiagThird : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocCompDiagThird : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -243,13 +244,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocCompDiagThird : publ
 namespace {
 
 TEST_CASE("shoc_comp_diag_third_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocCompDiagThird;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocCompDiagThird;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_comp_diag_third_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocCompDiagThird;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocCompDiagThird;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_compute_shoc_temperature_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_compute_shoc_temperature_tests.cpp
index a35e5cf4c8..349119c68d 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_compute_shoc_temperature_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_compute_shoc_temperature_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestComputeShocTemp : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestComputeShocTemp : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 1;
@@ -254,13 +255,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestComputeShocTemp : public
 namespace {
 
 TEST_CASE("shoc_compute_shoc_temperature_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestComputeShocTemp;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestComputeShocTemp;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_compute_shoc_temperature_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestComputeShocTemp;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestComputeShocTemp;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_compute_shoc_vapor_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_compute_shoc_vapor_tests.cpp
index 4a540605c8..11980298e6 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_compute_shoc_vapor_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_compute_shoc_vapor_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestComputeShocVapor : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestComputeShocVapor : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -146,13 +147,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestComputeShocVapor : publi
 namespace {
 
 TEST_CASE("compute_shoc_vapor_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestComputeShocVapor;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestComputeShocVapor;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("compute_shoc_vapor_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestComputeShocVapor;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestComputeShocVapor;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_diag_obklen_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_diag_obklen_tests.cpp
index dd790b121d..898df6685f 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_diag_obklen_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_diag_obklen_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocDiagObklen : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocDiagObklen : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 5;
@@ -161,8 +162,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocDiagObklen : public
     auto engine = Base::get_engine();
 
     ShocDiagObklenData SDS_baseline[] = {//             shcol
-                                         ShocDiagObklenData(12), ShocDiagObklenData(10), ShocDiagObklenData(7),
-                                         ShocDiagObklenData(2)};
+                                         ShocDiagObklenData(12), ShocDiagObklenData(10),
+                                         ShocDiagObklenData(7), ShocDiagObklenData(2)};
 
     // Generate random input data
     for (auto &d : SDS_baseline) {
@@ -171,8 +172,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocDiagObklen : public
 
     // Create copies of data for use by cxx. Needs to happen before reads so that
     // inout data is in original state
-    ShocDiagObklenData SDS_cxx[] = {ShocDiagObklenData(SDS_baseline[0]), ShocDiagObklenData(SDS_baseline[1]),
-                                    ShocDiagObklenData(SDS_baseline[2]), ShocDiagObklenData(SDS_baseline[3])};
+    ShocDiagObklenData SDS_cxx[] = {
+        ShocDiagObklenData(SDS_baseline[0]), ShocDiagObklenData(SDS_baseline[1]),
+        ShocDiagObklenData(SDS_baseline[2]), ShocDiagObklenData(SDS_baseline[3])};
 
     static constexpr Int num_runs = sizeof(SDS_baseline) / sizeof(ShocDiagObklenData);
 
@@ -217,13 +219,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocDiagObklen : public
 namespace {
 
 TEST_CASE("shoc_diag_obklen_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocDiagObklen;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocDiagObklen;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_diag_obklen_length_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocDiagObklen;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocDiagObklen;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_diag_second_mom_srf_test.cpp w/components/eamxx/src/physics/shoc/tests/shoc_diag_second_mom_srf_test.cpp
index 7a27817be1..cd6088abe8 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_diag_second_mom_srf_test.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_diag_second_mom_srf_test.cpp
@@ -21,7 +21,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestSecondMomSrf : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestSecondMomSrf : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     // Property test for the SHOC subroutine:
@@ -135,13 +136,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestSecondMomSrf : public Un
 namespace {
 
 TEST_CASE("shoc_second_moments_srf_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestSecondMomSrf;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestSecondMomSrf;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_second_moments_srf_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestSecondMomSrf;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestSecondMomSrf;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_diag_second_mom_ubycond_test.cpp w/components/eamxx/src/physics/shoc/tests/shoc_diag_second_mom_ubycond_test.cpp
index 0b766c4eaa..e4ef2809e2 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_diag_second_mom_ubycond_test.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_diag_second_mom_ubycond_test.cpp
@@ -22,7 +22,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestSecondMomUbycond : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestSecondMomUbycond : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     // Property test for SHOC subroutine:
@@ -125,13 +126,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestSecondMomUbycond : publi
 namespace {
 
 TEST_CASE("second_mom_uby_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestSecondMomUbycond;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestSecondMomUbycond;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("second_mom_uby_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestSecondMomUbycond;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestSecondMomUbycond;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_diag_second_moments_lbycond_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_diag_second_moments_lbycond_tests.cpp
index ed9779c272..d0ba5a8f42 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_diag_second_moments_lbycond_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_diag_second_moments_lbycond_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestDiagSecondMomentsLbycond : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestDiagSecondMomentsLbycond : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     // Property tests for the SHOC function
@@ -181,13 +182,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestDiagSecondMomentsLbycond
 namespace {
 
 TEST_CASE("diag_second_moments_lbycond_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDiagSecondMomentsLbycond;
+  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestDiagSecondMomentsLbycond;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("diag_second_moments_lbycond_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDiagSecondMomentsLbycond;
+  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestDiagSecondMomentsLbycond;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_diag_second_moments_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_diag_second_moments_tests.cpp
index 786970b606..ad6b723ea3 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_diag_second_moments_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_diag_second_moments_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestDiagSecondMoments : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestDiagSecondMoments : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol  = 2;
@@ -315,13 +316,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestDiagSecondMoments : publ
 namespace {
 
 TEST_CASE("diag_second_moments_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDiagSecondMoments;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDiagSecondMoments;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("diag_second_moments_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDiagSecondMoments;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDiagSecondMoments;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_diag_second_shoc_moments_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_diag_second_shoc_moments_tests.cpp
index c03ac8aa60..3e2e552d4a 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_diag_second_shoc_moments_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_diag_second_shoc_moments_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestDiagSecondShocMoments : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestDiagSecondShocMoments : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
 
@@ -328,13 +329,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestDiagSecondShocMoments :
 namespace {
 
 TEST_CASE("diag_second_shoc_moments_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDiagSecondShocMoments;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDiagSecondShocMoments;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("diag_second_shoc_moments_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDiagSecondShocMoments;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestDiagSecondShocMoments;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_diag_third_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_diag_third_tests.cpp
index 4b108bc9c4..559da76200 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_diag_third_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_diag_third_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocDiagThird : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocDiagThird : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -263,13 +264,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocDiagThird : public U
 namespace {
 
 TEST_CASE("shoc_diag_third_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocDiagThird;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocDiagThird;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_diag_third_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocDiagThird;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocDiagThird;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_eddy_diffusivities_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_eddy_diffusivities_tests.cpp
index 12d676a232..4878d76d51 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_eddy_diffusivities_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_eddy_diffusivities_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocEddyDiff : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocEddyDiff : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -171,7 +172,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocEddyDiff : public Un
         const auto offset = n + s * nlev;
         // Get value corresponding to next column
         const auto offsets = n + (s + 1) * nlev;
-        if (SDS.shoc_mix[offset] < SDS.shoc_mix[offsets] & SDS.sterm_zt[offset] < SDS.sterm_zt[offsets]) {
+        if (SDS.shoc_mix[offset] < SDS.shoc_mix[offsets] &
+            SDS.sterm_zt[offset] < SDS.sterm_zt[offsets]) {
           REQUIRE(SDS.tk[offset] < SDS.tkh[offsets]);
           REQUIRE(SDS.tkh[offset] < SDS.tkh[offsets]);
         }
@@ -314,13 +316,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocEddyDiff : public Un
 namespace {
 
 TEST_CASE("shoc_tke_eddy_diffusivities_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEddyDiff;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEddyDiff;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_tke_eddy_diffusivities_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEddyDiff;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEddyDiff;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_energy_fixer_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_energy_fixer_tests.cpp
index a911db1c7a..c297965bf5 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_energy_fixer_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_energy_fixer_tests.cpp
@@ -22,7 +22,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocEnergyFixer : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocEnergyFixer : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Real gravit = scream::physics::Constants<Real>::gravit;
@@ -82,7 +83,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocEnergyFixer : public
 
     // Test that the inputs are reasonable.
     // for this test we need exactly two columns
-    REQUIRE((SDS.shcol == shcol && SDS.nlev == nlev && SDS.nlevi && SDS.dtime == dtime && SDS.nadv == nadv));
+    REQUIRE((SDS.shcol == shcol && SDS.nlev == nlev && SDS.nlevi && SDS.dtime == dtime &&
+             SDS.nadv == nadv));
     // Want exactly three columns for this case
     REQUIRE(shcol == 3);
     REQUIRE(nlevi == nlev + 1);
@@ -318,13 +320,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocEnergyFixer : public
 namespace {
 
 TEST_CASE("shoc_energy_fixer_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEnergyFixer;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEnergyFixer;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_energy_fixer_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEnergyFixer;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEnergyFixer;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_energy_integral_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_energy_integral_tests.cpp
index 5ad713fa68..e60feb43de 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_energy_integral_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_energy_integral_tests.cpp
@@ -21,7 +21,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocEnergyInt : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocEnergyInt : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -194,13 +195,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocEnergyInt : public U
 namespace {
 
 TEST_CASE("shoc_energy_integrals_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEnergyInt;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEnergyInt;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_energy_integrals_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEnergyInt;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocEnergyInt;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_energy_update_dse_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_energy_update_dse_tests.cpp
index 8a91966e73..a2ce67eedf 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_energy_update_dse_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_energy_update_dse_tests.cpp
@@ -21,7 +21,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocUpdateDse : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocUpdateDse : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -198,13 +199,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocUpdateDse : public U
 namespace {
 
 TEST_CASE("shoc_energy_host_dse_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocUpdateDse;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocUpdateDse;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_energy_host_dse_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocUpdateDse;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocUpdateDse;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_grid_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_grid_tests.cpp
index d772245293..e34e953ddf 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_grid_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_grid_tests.cpp
@@ -22,7 +22,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocGrid : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocGrid : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Real gravit = scream::physics::Constants<Real>::gravit;
@@ -195,13 +196,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocGrid : public UnitWr
 namespace {
 
 TEST_CASE("shoc_grid_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocGrid;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocGrid;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_grid_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocGrid;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocGrid;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_impli_comp_tmpi_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_impli_comp_tmpi_tests.cpp
index bd16b5e9b2..0c6342ab99 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_impli_comp_tmpi_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_impli_comp_tmpi_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestImpCompTmpi : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestImpCompTmpi : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -174,13 +175,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestImpCompTmpi : public Uni
 namespace {
 
 TEST_CASE("shoc_imp_comp_tmpi_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestImpCompTmpi;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestImpCompTmpi;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_imp_comp_tmpi_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestImpCompTmpi;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestImpCompTmpi;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_impli_dp_inverse_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_impli_dp_inverse_tests.cpp
index b0b3ab7a37..fb5c544509 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_impli_dp_inverse_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_impli_dp_inverse_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestImpDpInverse : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestImpDpInverse : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -97,8 +98,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestImpDpInverse : public Un
     auto engine = Base::get_engine();
 
     DpInverseData baseline_data[] = {//            shcol, nlev
-                                     DpInverseData(10, 71), DpInverseData(10, 12), DpInverseData(7, 16),
-                                     DpInverseData(2, 7)};
+                                     DpInverseData(10, 71), DpInverseData(10, 12),
+                                     DpInverseData(7, 16), DpInverseData(2, 7)};
 
     // Generate random input data
     for (auto &d : baseline_data) {
@@ -155,13 +156,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestImpDpInverse : public Un
 namespace {
 
 TEST_CASE("shoc_imp_dp_inverse_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestImpDpInverse;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestImpDpInverse;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_imp_dp_inverse_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestImpDpInverse;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestImpDpInverse;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_l_inf_length_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_l_inf_length_tests.cpp
index 8f666af0cf..f9eafe63aa 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_l_inf_length_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_l_inf_length_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestLInfShocLength : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestLInfShocLength : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 3;
@@ -169,13 +170,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestLInfShocLength : public
 namespace {
 
 TEST_CASE("shoc_l_inf_length_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestLInfShocLength;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestLInfShocLength;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_l_inf_length_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestLInfShocLength;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestLInfShocLength;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_length_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_length_tests.cpp
index 8f797f693b..5485bce6fe 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_length_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_length_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocLength : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocLength : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Real minlen = scream::shoc::Constants<Real>::minlen;
@@ -249,13 +250,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocLength : public Unit
 namespace {
 
 TEST_CASE("shoc_length_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocLength;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocLength;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_length_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocLength;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocLength;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_linear_interp_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_linear_interp_tests.cpp
index ee27392c3b..6a6bb9c003 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_linear_interp_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_linear_interp_tests.cpp
@@ -21,7 +21,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocLinearInt : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocLinearInt : public UnitWrap::UnitTest<D>::Base {
 
   void run_property_fixed() {
     static constexpr Int shcol = 2;
@@ -271,7 +272,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocLinearInt : public U
 
     // The combination of single-precision and randomness generating points
     // close together can result in larger error margins.
-    const auto margin = std::numeric_limits<Real>::epsilon() * (ekat::is_single_precision<Real>::value ? 1000 : 1);
+    const auto margin =
+        std::numeric_limits<Real>::epsilon() * (ekat::is_single_precision<Real>::value ? 1000 : 1);
 
     for (Int s = 0; s < shcol; ++s) {
       if (km1_bigger) {
@@ -325,8 +327,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocLinearInt : public U
 
     LinearInterpData baseline_data[] = {
         //                   shcol, nlev(km1), nlevi(km2), minthresh
-        LinearInterpData(10, 72, 71, 1e-15), LinearInterpData(10, 71, 72, 1e-15), LinearInterpData(1, 15, 16, 1e-15),
-        LinearInterpData(1, 16, 15, 1e-15),  LinearInterpData(1, 5, 6, 1e-15),    LinearInterpData(1, 6, 5, 1e-15),
+        LinearInterpData(10, 72, 71, 1e-15), LinearInterpData(10, 71, 72, 1e-15),
+        LinearInterpData(1, 15, 16, 1e-15),  LinearInterpData(1, 16, 15, 1e-15),
+        LinearInterpData(1, 5, 6, 1e-15),    LinearInterpData(1, 6, 5, 1e-15),
     };
 
     // Generate random input data
@@ -337,8 +340,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocLinearInt : public U
     // Create copies of data for use by cxx. Needs to happen before reads so that
     // inout data is in original state
     LinearInterpData cxx_data[] = {
-        LinearInterpData(baseline_data[0]), LinearInterpData(baseline_data[1]), LinearInterpData(baseline_data[2]),
-        LinearInterpData(baseline_data[3]), LinearInterpData(baseline_data[4]), LinearInterpData(baseline_data[5]),
+        LinearInterpData(baseline_data[0]), LinearInterpData(baseline_data[1]),
+        LinearInterpData(baseline_data[2]), LinearInterpData(baseline_data[3]),
+        LinearInterpData(baseline_data[4]), LinearInterpData(baseline_data[5]),
     };
 
     // Assume all data is in C layout
@@ -381,13 +385,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocLinearInt : public U
 namespace {
 
 TEST_CASE("shoc_linear_interp_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocLinearInt;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocLinearInt;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_linear_interp_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocLinearInt;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocLinearInt;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_main_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_main_tests.cpp
index e954792a49..f09b0a700f 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_main_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_main_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocMain : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocMain : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Real mintke = scream::shoc::Constants<Real>::mintke;
@@ -324,7 +325,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocMain : public UnitWr
     auto engine = Base::get_engine();
 
     ShocMainData baseline_data[] = {
-        //           shcol, nlev, nlevi, num_qtracers, dtime, nadv, nbot_shoc, ntop_shoc(C++ indexing)
+        //           shcol, nlev, nlevi, num_qtracers, dtime, nadv, nbot_shoc, ntop_shoc(C++
+        //           indexing)
         ShocMainData(12, 72, 73, 5, 300, 15, 72, 0), ShocMainData(8, 12, 13, 3, 300, 10, 8, 3),
         ShocMainData(7, 16, 17, 3, 300, 1, 12, 0), ShocMainData(2, 7, 8, 2, 300, 5, 7, 4)};
 
@@ -459,13 +461,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocMain : public UnitWr
 namespace {
 
 TEST_CASE("shoc_main_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocMain;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocMain;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_main_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocMain;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocMain;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_mix_length_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_mix_length_tests.cpp
index de452c30f1..e737db7813 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_mix_length_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_mix_length_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestCompShocMixLength : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestCompShocMixLength : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 3;
@@ -117,8 +118,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCompShocMixLength : publ
 
     ComputeShocMixShocLengthData SDS_baseline[] = {
         //               shcol, nlev
-        ComputeShocMixShocLengthData(10, 71), ComputeShocMixShocLengthData(10, 12), ComputeShocMixShocLengthData(7, 16),
-        ComputeShocMixShocLengthData(2, 7)};
+        ComputeShocMixShocLengthData(10, 71), ComputeShocMixShocLengthData(10, 12),
+        ComputeShocMixShocLengthData(7, 16), ComputeShocMixShocLengthData(2, 7)};
 
     // Generate random input data
     for (auto &d : SDS_baseline) {
@@ -175,13 +176,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCompShocMixLength : publ
 namespace {
 
 TEST_CASE("shoc_mix_length_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCompShocMixLength;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCompShocMixLength;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_mix_length_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCompShocMixLength;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCompShocMixLength;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_check_pblh_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_check_pblh_tests.cpp
index 0c733e72ef..d4dab877ea 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_check_pblh_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_check_pblh_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdCheckPblh : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestPblintdCheckPblh : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr auto ustar_min = scream::shoc::Constants<Scalar>::ustar_min;
@@ -142,13 +143,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdCheckPblh : publi
 namespace {
 
 TEST_CASE("pblintd_check_pblh_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdCheckPblh;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdCheckPblh;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("pblintd_check_pblh_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdCheckPblh;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdCheckPblh;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_cldcheck_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_cldcheck_tests.cpp
index 91b9bf942f..ad20c2f742 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_cldcheck_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_cldcheck_tests.cpp
@@ -21,7 +21,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdCldCheck : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestPblintdCldCheck : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 5;
@@ -148,13 +149,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdCldCheck : public
 namespace {
 
 TEST_CASE("shoc_pblintd_cldcheck_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdCldCheck;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdCldCheck;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_pblintd_cldcheck_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdCldCheck;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdCldCheck;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_height_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_height_tests.cpp
index 1d988514bc..32ab17dd62 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_height_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_height_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdHeight : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestPblintdHeight : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr auto ustar_min = scream::shoc::Constants<Scalar>::ustar_min;
@@ -172,8 +173,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdHeight : public U
     Int npbl_rand = rand() % 72 + 1;
 
     PblintdHeightData baseline_data[] = {
-        PblintdHeightData(10, 72, 1), PblintdHeightData(10, 72, 72), PblintdHeightData(10, 72, npbl_rand),
-        PblintdHeightData(10, 12, 1), PblintdHeightData(7, 16, 1),   PblintdHeightData(2, 7, 1),
+        PblintdHeightData(10, 72, 1),         PblintdHeightData(10, 72, 72),
+        PblintdHeightData(10, 72, npbl_rand), PblintdHeightData(10, 12, 1),
+        PblintdHeightData(7, 16, 1),          PblintdHeightData(2, 7, 1),
     };
 
     // Generate random input data
@@ -184,8 +186,9 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdHeight : public U
     // Create copies of data for use by cxx. Needs to happen before reads so that
     // inout data is in original state
     PblintdHeightData cxx_data[] = {
-        PblintdHeightData(baseline_data[0]), PblintdHeightData(baseline_data[1]), PblintdHeightData(baseline_data[2]),
-        PblintdHeightData(baseline_data[3]), PblintdHeightData(baseline_data[4]), PblintdHeightData(baseline_data[5]),
+        PblintdHeightData(baseline_data[0]), PblintdHeightData(baseline_data[1]),
+        PblintdHeightData(baseline_data[2]), PblintdHeightData(baseline_data[3]),
+        PblintdHeightData(baseline_data[4]), PblintdHeightData(baseline_data[5]),
     };
 
     // Assume all data is in C layout
@@ -231,13 +234,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdHeight : public U
 namespace {
 
 TEST_CASE("pblintd_height_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdHeight;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdHeight;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("pblintd_height_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdHeight;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdHeight;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_init_pot_test.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_init_pot_test.cpp
index 3549b05e48..96cf2e621c 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_init_pot_test.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_init_pot_test.cpp
@@ -21,7 +21,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdInitPot : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestPblintdInitPot : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -181,13 +182,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdInitPot : public
     }
 
     if (SCREAM_BFB_TESTING && this->m_baseline_action == COMPARE) {
-      static constexpr Int num_runs = sizeof(pblintd_init_pot_data_baseline) / sizeof(PblintdInitPotData);
+      static constexpr Int num_runs =
+          sizeof(pblintd_init_pot_data_baseline) / sizeof(PblintdInitPotData);
       for (Int i = 0; i < num_runs; ++i) {
         Int shcol = pblintd_init_pot_data_cxx[i].shcol;
         Int nlev  = pblintd_init_pot_data_cxx[i].nlev;
         for (Int j = 0; j < shcol; ++j) {
           for (Int k = 0; k < nlev; ++k) {
-            REQUIRE(pblintd_init_pot_data_baseline[i].thv[j * k] == pblintd_init_pot_data_cxx[i].thv[j * k]);
+            REQUIRE(pblintd_init_pot_data_baseline[i].thv[j * k] ==
+                    pblintd_init_pot_data_cxx[i].thv[j * k]);
           }
         }
       }
@@ -207,13 +210,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdInitPot : public
 namespace {
 
 TEST_CASE("shoc_pblintd_init_pot_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdInitPot;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdInitPot;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_pblintd_init_pot_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdInitPot;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdInitPot;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_surf_temp_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_surf_temp_tests.cpp
index 5163400ef4..c8a32e883e 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_surf_temp_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_surf_temp_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdSurfTemp : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestPblintdSurfTemp : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr auto ustar_min = scream::shoc::Constants<Scalar>::ustar_min;
@@ -180,13 +181,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPblintdSurfTemp : public
 namespace {
 
 TEST_CASE("pblintd_surf_temp_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdSurfTemp;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdSurfTemp;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("pblintd_surf_temp_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdSurfTemp;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintdSurfTemp;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_tests.cpp
index 2a6d1abb58..418777ea7e 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pblintd_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pblintd_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestPblintd : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestPblintd : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr auto ustar_min = scream::shoc::Constants<Scalar>::ustar_min;
@@ -195,13 +196,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestPblintd : public UnitWra
 namespace {
 
 TEST_CASE("pblintd_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintd;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintd;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("pblintd_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintd;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestPblintd;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_buoyflux_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_buoyflux_tests.cpp
index 3b7e2534d7..2d83c96090 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_buoyflux_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_buoyflux_tests.cpp
@@ -117,13 +117,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocPdfCompBuoyFlux {
 namespace {
 
 TEST_CASE("shoc_pdf_compute_buoyflux_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompBuoyFlux;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompBuoyFlux;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_compute_buoyflux_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompBuoyFlux;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompBuoyFlux;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_cloudvar_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_cloudvar_tests.cpp
index 9069d8d49c..0e10952685 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_cloudvar_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_cloudvar_tests.cpp
@@ -153,13 +153,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocPdfCompCldVar {
 namespace {
 
 TEST_CASE("shoc_pdf_compute_cldvar_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompCldVar;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompCldVar;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_compute_cldvar_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompCldVar;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompCldVar;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_liqflux_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_liqflux_tests.cpp
index 993e90c92c..815339a6b6 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_liqflux_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_liqflux_tests.cpp
@@ -151,13 +151,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocPdfCompLiqFlux {
 namespace {
 
 TEST_CASE("shoc_pdf_compute_liqflux_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompLiqFlux;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompLiqFlux;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_compute_liqflux_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompLiqFlux;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfCompLiqFlux;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_qs_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_qs_tests.cpp
index 167a55fb94..cba02d4dda 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_qs_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_qs_tests.cpp
@@ -118,13 +118,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocPdfComputeQs {
 namespace {
 
 TEST_CASE("shoc_pdf_compute_qs_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeQs;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeQs;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_compute_qs_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeQs;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeQs;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_s_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_s_tests.cpp
index aab674dead..7258870471 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_s_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_s_tests.cpp
@@ -149,13 +149,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocPdfComputeS {
 namespace {
 
 TEST_CASE("shoc_pdf_compute_s_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeS;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeS;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_compute_s_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeS;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeS;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_sgsliq_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_sgsliq_tests.cpp
index 812f14bde8..e78a1e1adb 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_sgsliq_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_compute_sgsliq_tests.cpp
@@ -128,13 +128,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocPdfComputeSgsLiq {
 namespace {
 
 TEST_CASE("shoc_pdf_compute_sgsliq_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeSgsLiq;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeSgsLiq;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_compute_sgsliq_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeSgsLiq;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeSgsLiq;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_computetemp_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_computetemp_tests.cpp
index ff5f6f29b0..037d26082f 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_computetemp_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_computetemp_tests.cpp
@@ -117,13 +117,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocPdfComputeTemp {
 namespace {
 
 TEST_CASE("shoc_pdf_computetemp_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeTemp;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeTemp;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_computetemp_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeTemp;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfComputeTemp;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_inplume_corr_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_inplume_corr_tests.cpp
index b04be00729..9d3b05d363 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_inplume_corr_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_inplume_corr_tests.cpp
@@ -138,13 +138,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocInPlumeCorr {
 namespace {
 
 TEST_CASE("shoc_pdf_inplume_corr_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocInPlumeCorr;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocInPlumeCorr;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_inplume_corr_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocInPlumeCorr;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocInPlumeCorr;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_qw_parameters_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_qw_parameters_tests.cpp
index cc297376d3..4f19aafe2a 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_qw_parameters_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_qw_parameters_tests.cpp
@@ -119,7 +119,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocQwParameters {
     REQUIRE((SDS.qw2_1 > 0 && SDS.qw2_2 > 0));
     REQUIRE((SDS.qw2_2 < qw2_bound_high && SDS.qw2_2 < qw2_bound_high));
     REQUIRE((SDS.sqrtqw2_1 > 0 && SDS.sqrtqw2_2 > 0));
-    REQUIRE((SDS.sqrtqw2_1 < std::sqrt(qw2_bound_high) && SDS.sqrtqw2_2 < std::sqrt(qw2_bound_high)));
+    REQUIRE(
+        (SDS.sqrtqw2_1 < std::sqrt(qw2_bound_high) && SDS.sqrtqw2_2 < std::sqrt(qw2_bound_high)));
 
     // TEST TWO
     // Run the test two times given idential inputs, except one test
@@ -167,13 +168,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocQwParameters {
 namespace {
 
 TEST_CASE("shoc_pdf_qw_parameters_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocQwParameters;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocQwParameters;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_qw_parameters_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocQwParameters;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocQwParameters;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_thl_parameters_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_thl_parameters_tests.cpp
index 6d14409de9..d90d15d14d 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_thl_parameters_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_thl_parameters_tests.cpp
@@ -122,7 +122,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocThlParameters {
     REQUIRE((SDS.thl2_1 > 0 && SDS.thl2_2 > 0));
     REQUIRE((SDS.thl2_2 < thl2_bound_high && SDS.thl2_2 < thl2_bound_high));
     REQUIRE((SDS.sqrtthl2_1 > 0 && SDS.sqrtthl2_2 > 0));
-    REQUIRE((SDS.sqrtthl2_1 < std::sqrt(thl2_bound_high) && SDS.sqrtthl2_2 < std::sqrt(thl2_bound_high)));
+    REQUIRE((SDS.sqrtthl2_1 < std::sqrt(thl2_bound_high) &&
+             SDS.sqrtthl2_2 < std::sqrt(thl2_bound_high)));
 
     // TEST TWO
     // For a case with identical input except wthlsec, verify that
@@ -170,13 +171,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocThlParameters {
 namespace {
 
 TEST_CASE("shoc_pdf_thl_parameters_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocThlParameters;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocThlParameters;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_thl_parameters_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocThlParameters;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocThlParameters;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_tildetoreal_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_tildetoreal_tests.cpp
index e270909f88..5fe9b6ccea 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_tildetoreal_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_tildetoreal_tests.cpp
@@ -105,13 +105,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocPdfTildetoReal {
 namespace {
 
 TEST_CASE("shoc_pdf_tildetoreal_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfTildetoReal;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfTildetoReal;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_tildetoreal_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfTildetoReal;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocPdfTildetoReal;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_pdf_vv_parameters_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_pdf_vv_parameters_tests.cpp
index 84337311f9..29cf80fab1 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_pdf_vv_parameters_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_pdf_vv_parameters_tests.cpp
@@ -139,13 +139,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocVVParameters {
 namespace {
 
 TEST_CASE("shoc_pdf_vv_parameters_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocVVParameters;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocVVParameters;
 
   TestStruct::run_property();
 }
 
 TEST_CASE("shoc_pdf_vv_parameters_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocVVParameters;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocVVParameters;
 
   TestStruct::run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_run_and_cmp.cpp w/components/eamxx/src/physics/shoc/tests/shoc_run_and_cmp.cpp
index 4c15f83c0e..2fec6e757a 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_run_and_cmp.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_run_and_cmp.cpp
@@ -56,8 +56,8 @@ Int compare(const double &tol, const FortranData::Ptr &ref, const FortranData::P
 
 struct Baseline {
 
-  Baseline(const Int nsteps, const Real dt, const Int ncol, const Int nlev, const Int num_qtracers, const Int nadv,
-           const Int repeat) {
+  Baseline(const Int nsteps, const Real dt, const Int ncol, const Int nlev, const Int num_qtracers,
+           const Int nadv, const Int repeat) {
     params_.push_back({ic::Factory::standard, repeat, nsteps, ncol, nlev, num_qtracers, nadv, dt});
   }
 
@@ -76,8 +76,8 @@ struct Baseline {
         set_params(ps, *d);
 
         if (ps.repeat > 0 && r == -1) {
-          std::cout << "Running SHOC with ni=" << d->shcol << ", nk=" << d->nlev << ", dt=" << d->dtime
-                    << ", ts=" << ps.nsteps;
+          std::cout << "Running SHOC with ni=" << d->shcol << ", nk=" << d->nlev
+                    << ", dt=" << d->dtime << ", ts=" << ps.nsteps;
 
           std::cout << ", small_packn=" << SCREAM_SMALL_PACK_SIZE;
           std::cout << std::endl;
@@ -118,7 +118,8 @@ struct Baseline {
         const auto d = ic::Factory::create(ps.ic, ps.ncol, ps.nlev, ps.num_qtracers);
         set_params(ps, *d);
         for (int it = 0; it < ps.nsteps; it++) {
-          std::cout << "--- running case # " << case_num << ", timestep # " << it + 1 << " of " << ps.nsteps << " ---\n"
+          std::cout << "--- running case # " << case_num << ", timestep # " << it + 1 << " of "
+                    << ps.nsteps << " ---\n"
                     << std::flush;
           shoc_main(*d);
         }
@@ -132,7 +133,8 @@ struct Baseline {
           const auto d = ic::Factory::create(ps.ic, ps.ncol, ps.nlev, ps.num_qtracers);
           set_params(ps, *d);
           for (int it = 0; it < ps.nsteps; it++) {
-            std::cout << "--- checking case # " << case_num << ", timestep # = " << (it + 1) * ps.nadv << " ---\n"
+            std::cout << "--- checking case # " << case_num
+                      << ", timestep # = " << (it + 1) * ps.nadv << " ---\n"
                       << std::flush;
             read(fid, d_ref);
             shoc_main(*d);
@@ -178,18 +180,21 @@ private:
       const auto &f = fdi.getfield(i);
       int dim, ds[3];
       ekat::read(&dim, 1, fid);
-      EKAT_REQUIRE_MSG(dim == f.dim, "For field " << f.name << " read expected dim " << f.dim << " but got " << dim);
+      EKAT_REQUIRE_MSG(dim == f.dim, "For field " << f.name << " read expected dim " << f.dim
+                                                  << " but got " << dim);
       ekat::read(ds, dim, fid);
       for (int i = 0; i < dim; ++i)
         EKAT_REQUIRE_MSG(ds[i] == f.extent[i], "For field " << f.name << " read expected dim " << i
-                                                            << " to have extent " << f.extent[i] << " but got "
-                                                            << ds[i]);
+                                                            << " to have extent " << f.extent[i]
+                                                            << " but got " << ds[i]);
       ekat::read(f.data, f.size, fid);
     }
   }
 };
 
-void expect_another_arg(int i, int argc) { EKAT_REQUIRE_MSG(i != argc - 1, "Expected another cmd-line arg."); }
+void expect_another_arg(int i, int argc) {
+  EKAT_REQUIRE_MSG(i != argc - 1, "Expected another cmd-line arg.");
+}
 
 } // namespace
 
@@ -211,7 +216,8 @@ int main(int argc, char **argv) {
                  "  -k <nlev>         Number of vertical levels. Default=72.\n"
                  "  -q <num_qtracers> Number of q tracers. Default=3.\n"
                  "  -l <nadv>         Number of SHOC loops per timestep. Default=15.\n"
-                 "  -r <repeat>       Number of repetitions, implies timing run (generate + no I/O). Default=0.\n";
+                 "  -r <repeat>       Number of repetitions, implies timing run (generate + no "
+                 "I/O). Default=0.\n";
 
     return 1;
   }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_tke_adv_sgs_tke_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_tke_adv_sgs_tke_tests.cpp
index a7e90a7c67..57877b95b7 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_tke_adv_sgs_tke_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_tke_adv_sgs_tke_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocAdvSgsTke : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocAdvSgsTke : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Real mintke = scream::shoc::Constants<Real>::mintke;
@@ -189,8 +190,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocAdvSgsTke : public U
     auto engine = Base::get_engine();
 
     AdvSgsTkeData baseline_data[] = {//            shcol, nlev
-                                     AdvSgsTkeData(10, 71, 72), AdvSgsTkeData(10, 12, 13), AdvSgsTkeData(7, 16, 17),
-                                     AdvSgsTkeData(2, 7, 8)};
+                                     AdvSgsTkeData(10, 71, 72), AdvSgsTkeData(10, 12, 13),
+                                     AdvSgsTkeData(7, 16, 17), AdvSgsTkeData(2, 7, 8)};
 
     // Generate random input data
     for (auto &d : baseline_data) {
@@ -247,13 +248,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocAdvSgsTke : public U
 namespace {
 
 TEST_CASE("shoc_tke_adv_sgs_tke_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocAdvSgsTke;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocAdvSgsTke;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_tke_adv_sgs_tke_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocAdvSgsTke;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocAdvSgsTke;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_tke_column_stab_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_tke_column_stab_tests.cpp
index 3e191ae8b7..dffe6ae015 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_tke_column_stab_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_tke_column_stab_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocIntColStab : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocIntColStab : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol = 2;
@@ -180,13 +181,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocIntColStab : public
 namespace {
 
 TEST_CASE("shoc_tke_column_stab_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocIntColStab;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocIntColStab;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_tke_column_stab_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocIntColStab;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocIntColStab;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_tke_isotropic_ts_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_tke_isotropic_ts_tests.cpp
index 0338bf3217..df57452de9 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_tke_isotropic_ts_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_tke_isotropic_ts_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocIsotropicTs : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocIsotropicTs : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Real maxiso = scream::shoc::Constants<Real>::maxiso;
@@ -174,8 +175,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocIsotropicTs : public
     auto engine = Base::get_engine();
 
     IsotropicTsData baseline_data[] = {//            shcol, nlev
-                                       IsotropicTsData(10, 71), IsotropicTsData(10, 12), IsotropicTsData(7, 16),
-                                       IsotropicTsData(2, 7)};
+                                       IsotropicTsData(10, 71), IsotropicTsData(10, 12),
+                                       IsotropicTsData(7, 16), IsotropicTsData(2, 7)};
 
     // Generate random input data
     for (auto &d : baseline_data) {
@@ -231,13 +232,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocIsotropicTs : public
 namespace {
 
 TEST_CASE("shoc_tke_isotropic_ts_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocIsotropicTs;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocIsotropicTs;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_tke_isotropic_ts_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocIsotropicTs;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocIsotropicTs;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_tke_shr_prod_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_tke_shr_prod_tests.cpp
index 6c5c85712f..a1e6459ab6 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_tke_shr_prod_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_tke_shr_prod_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocShearProd : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocShearProd : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol  = 2;
@@ -155,9 +156,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocShearProd : public U
   void run_bfb() {
     auto engine = Base::get_engine();
 
-    ComputeShrProdData baseline_data[] = {//            shcol, nlev
-                                          ComputeShrProdData(10, 71, 72), ComputeShrProdData(10, 12, 13),
-                                          ComputeShrProdData(7, 16, 17), ComputeShrProdData(2, 7, 8)};
+    ComputeShrProdData baseline_data[] = {
+        //            shcol, nlev
+        ComputeShrProdData(10, 71, 72), ComputeShrProdData(10, 12, 13),
+        ComputeShrProdData(7, 16, 17), ComputeShrProdData(2, 7, 8)};
 
     // Generate random input data
     for (auto &d : baseline_data) {
@@ -213,13 +215,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocShearProd : public U
 namespace {
 
 TEST_CASE("shoc_tke_shr_prod_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocShearProd;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocShearProd;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_tke_shr_prod_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocShearProd;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocShearProd;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_tke_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_tke_tests.cpp
index 2ace98f0e0..8870326b16 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_tke_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_tke_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocTke : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocTke : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Real mintke = scream::shoc::Constants<Real>::mintke;
@@ -315,13 +316,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocTke : public UnitWra
 namespace {
 
 TEST_CASE("shoc_tke_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocTke;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocTke;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_tke_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocTke;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocTke;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_update_prognostics_implicit_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_update_prognostics_implicit_tests.cpp
index e5ef65c751..51aef4c5cb 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_update_prognostics_implicit_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_update_prognostics_implicit_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestUpdatePrognosticsImplicit : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestUpdatePrognosticsImplicit : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol      = 5;
@@ -247,7 +248,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpdatePrognosticsImplici
             trc_int_b[s][t] = 0;
           }
           const auto t_offset = t + offset * num_tracer;
-          trc_int_b[s][t]     = trc_int_b[s][t] + SDS.tracer[t_offset] * SDS.rho_zt[offset] * SDS.dz_zt[offset];
+          trc_int_b[s][t] =
+              trc_int_b[s][t] + SDS.tracer[t_offset] * SDS.rho_zt[offset] * SDS.dz_zt[offset];
         }
       }
     }
@@ -288,7 +290,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpdatePrognosticsImplici
             trc_int_a[s][t] = 0;
           }
           const auto t_offset = t + offset * num_tracer;
-          trc_int_a[s][t]     = trc_int_a[s][t] + SDS.tracer[t_offset] * SDS.rho_zt[offset] * SDS.dz_zt[offset];
+          trc_int_a[s][t] =
+              trc_int_a[s][t] + SDS.tracer[t_offset] * SDS.rho_zt[offset] * SDS.dz_zt[offset];
         }
       }
 
@@ -313,7 +316,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpdatePrognosticsImplici
       for (Int t = 0; t < num_tracer; ++t) {
         const auto t_offset = t + s * num_tracer;
         // Calculate spurious source
-        spurious = (trc_int_a[s][t] - trc_int_b[s][t]) / dtime - rho_zi_srf * SDS.wtracer_sfc[t_offset];
+        spurious =
+            (trc_int_a[s][t] - trc_int_b[s][t]) / dtime - rho_zi_srf * SDS.wtracer_sfc[t_offset];
         // Spurious source should be sufficiently small
         REQUIRE(std::abs(spurious) < thresh_check);
       }
@@ -325,8 +329,10 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpdatePrognosticsImplici
     auto engine = Base::get_engine();
 
     UpdatePrognosticsImplicitData baseline_data[] = {
-        UpdatePrognosticsImplicitData(10, 71, 72, 19, .5), UpdatePrognosticsImplicitData(10, 12, 13, 7, .25),
-        UpdatePrognosticsImplicitData(7, 16, 17, 2, .1), UpdatePrognosticsImplicitData(2, 7, 8, 1, .1)};
+        UpdatePrognosticsImplicitData(10, 71, 72, 19, .5),
+        UpdatePrognosticsImplicitData(10, 12, 13, 7, .25),
+        UpdatePrognosticsImplicitData(7, 16, 17, 2, .1),
+        UpdatePrognosticsImplicitData(2, 7, 8, 1, .1)};
 
     // Generate random input data
     for (auto &d : baseline_data) {
@@ -397,13 +403,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestUpdatePrognosticsImplici
 namespace {
 
 TEST_CASE("update_prognostics_implicit_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestUpdatePrognosticsImplicit;
+  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestUpdatePrognosticsImplicit;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("update_prognostics_implicit_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestUpdatePrognosticsImplicit;
+  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<
+      scream::DefaultDevice>::TestUpdatePrognosticsImplicit;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_varorcovar_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_varorcovar_tests.cpp
index e7d945081c..5d53e124f8 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_varorcovar_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_varorcovar_tests.cpp
@@ -22,7 +22,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestShocVarorCovar : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestShocVarorCovar : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol  = 2;
@@ -65,7 +66,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocVarorCovar : public
     CalcShocVarorcovarData SDS(shcol, nlev, nlevi, tunefac);
 
     // Test that the inputs are reasonable.
-    REQUIRE((SDS.shcol == shcol && SDS.nlev == nlev && SDS.nlevi == nlevi && SDS.tunefac == tunefac));
+    REQUIRE(
+        (SDS.shcol == shcol && SDS.nlev == nlev && SDS.nlevi == nlevi && SDS.tunefac == tunefac));
     REQUIRE(nlevi - nlev == 1);
     REQUIRE(shcol > 0);
 
@@ -323,13 +325,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestShocVarorCovar : public
 namespace {
 
 TEST_CASE("shoc_varorcovar_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocVarorCovar;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocVarorCovar;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_varorcovar_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocVarorCovar;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestShocVarorCovar;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_vd_shoc_decomp_and_solve_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_vd_shoc_decomp_and_solve_tests.cpp
index 48d07905df..c5b94b44f1 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_vd_shoc_decomp_and_solve_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_vd_shoc_decomp_and_solve_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestVdShocDecompandSolve : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestVdShocDecompandSolve : public UnitWrap::UnitTest<D>::Base {
 
   void run_bfb() {
     auto engine = Base::get_engine();
@@ -79,7 +80,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestVdShocDecompandSolve : p
 namespace {
 
 TEST_CASE("vd_shoc_solve_bfb", "[shoc]") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestVdShocDecompandSolve;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestVdShocDecompandSolve;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/shoc/tests/shoc_vertflux_tests.cpp w/components/eamxx/src/physics/shoc/tests/shoc_vertflux_tests.cpp
index f170bb33e7..6851d43a0f 100644
--- i/components/eamxx/src/physics/shoc/tests/shoc_vertflux_tests.cpp
+++ w/components/eamxx/src/physics/shoc/tests/shoc_vertflux_tests.cpp
@@ -20,7 +20,8 @@ namespace scream {
 namespace shoc {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestCalcShocVertflux : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestCalcShocVertflux : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     static constexpr Int shcol  = 2;
@@ -193,13 +194,15 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestCalcShocVertflux : publi
 namespace {
 
 TEST_CASE("shoc_vertflux_property", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCalcShocVertflux;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCalcShocVertflux;
 
   TestStruct().run_property();
 }
 
 TEST_CASE("shoc_vertflux_bfb", "shoc") {
-  using TestStruct = scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCalcShocVertflux;
+  using TestStruct =
+      scream::shoc::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestCalcShocVertflux;
 
   TestStruct().run_bfb();
 }
diff --git i/components/eamxx/src/physics/spa/eamxx_spa_process_interface.cpp w/components/eamxx/src/physics/spa/eamxx_spa_process_interface.cpp
index 6a9b62bcf8..77773b9eb3 100644
--- i/components/eamxx/src/physics/spa/eamxx_spa_process_interface.cpp
+++ w/components/eamxx/src/physics/spa/eamxx_spa_process_interface.cpp
@@ -9,8 +9,10 @@
 
 namespace scream {
 
-SPA::SPA(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereProcess(comm, params) {
-  EKAT_REQUIRE_MSG(m_params.isParameter("spa_data_file"), "ERROR: spa_data_file is missing from SPA parameter list.");
+SPA::SPA(const ekat::Comm &comm, const ekat::ParameterList &params)
+    : AtmosphereProcess(comm, params) {
+  EKAT_REQUIRE_MSG(m_params.isParameter("spa_data_file"),
+                   "ERROR: spa_data_file is missing from SPA parameter list.");
 }
 
 // =========================================================================================
@@ -58,7 +60,8 @@ void SPA::initialize_impl(const RunType /* run_type */) {
 
   // NOTE: SPA does not have an internal persistent state, so run_type is irrelevant
 
-  std::vector<Field> spa_fields = {get_field_out("nccn").alias("CCN3"), get_field_out("aero_g_sw").alias("AER_G_SW"),
+  std::vector<Field> spa_fields = {get_field_out("nccn").alias("CCN3"),
+                                   get_field_out("aero_g_sw").alias("AER_G_SW"),
                                    get_field_out("aero_ssa_sw").alias("AER_SSA_SW"),
                                    get_field_out("aero_tau_sw").alias("AER_TAU_SW"),
                                    get_field_out("aero_tau_lw").alias("AER_TAU_LW")};
@@ -73,20 +76,24 @@ void SPA::initialize_impl(const RunType /* run_type */) {
   // properties compatible with SCREAM_PACK_SIZE.
   // NOTE: we could just add p_int as a required field, but that would be misleading in the DAG
   auto pmid = get_field_in("p_mid");
-  Field pint(FieldIdentifier("p_int", m_model_grid->get_vertical_layout(false), Pa, m_model_grid->name()));
+  Field pint(
+      FieldIdentifier("p_int", m_model_grid->get_vertical_layout(false), Pa, m_model_grid->name()));
   pint.get_header().get_alloc_properties().request_allocation(SCREAM_PACK_SIZE);
   pint.allocate_view();
 
-  util::TimeStamp ref_ts(1, 1, 1, 0, 0, 0); // Beg of any year, since we use yearly periodic timeline
+  util::TimeStamp ref_ts(1, 1, 1, 0, 0,
+                         0); // Beg of any year, since we use yearly periodic timeline
   m_data_interpolation = std::make_shared<DataInterpolation>(m_model_grid, spa_fields);
-  m_data_interpolation->setup_time_database({spa_data_file}, util::TimeLine::YearlyPeriodic, ref_ts);
+  m_data_interpolation->setup_time_database({spa_data_file}, util::TimeLine::YearlyPeriodic,
+                                            ref_ts);
 
   DataInterpolation::RemapData remap_data;
   remap_data.hremap_file = spa_map_file == "none" ? "" : spa_map_file;
   if (m_iop_data_manager != nullptr) {
     // IOP cases cannot have a remap file. We will create a IOPRemapper as the horiz remapper
     EKAT_REQUIRE_MSG(spa_map_file == "" or spa_map_file == "none",
-                     "Error! Cannot define spa_remap_file for cases with an Intensive Observation Period defined. "
+                     "Error! Cannot define spa_remap_file for cases with an Intensive Observation "
+                     "Period defined. "
                      "The IOP class defines it's own remap from file data -> model data.\n");
 
     // TODO: expose tgt lat/lon in IOPDataManager, to avoid injecting knowledge
diff --git i/components/eamxx/src/physics/tms/eamxx_tms_process_interface.cpp w/components/eamxx/src/physics/tms/eamxx_tms_process_interface.cpp
index 7f9e08c9e5..6e4f9b2e2d 100644
--- i/components/eamxx/src/physics/tms/eamxx_tms_process_interface.cpp
+++ w/components/eamxx/src/physics/tms/eamxx_tms_process_interface.cpp
@@ -10,7 +10,8 @@
 namespace scream {
 
 // =========================================================================================
-TurbulentMountainStress::TurbulentMountainStress(const ekat::Comm &comm, const ekat::ParameterList &params)
+TurbulentMountainStress::TurbulentMountainStress(const ekat::Comm &comm,
+                                                 const ekat::ParameterList &params)
     : AtmosphereProcess(comm, params) {
   // Do nothing
 }
@@ -29,9 +30,10 @@ void TurbulentMountainStress::set_grids(const std::shared_ptr<const GridsManager
   // Initialize grid from grids manager
   m_grid                = grids_manager->get_grid("physics");
   const auto &grid_name = m_grid->name();
-  EKAT_REQUIRE_MSG(grid_name == "physics_pg2", "Error! TMS process can only be used with \"physics_pg2\" physics grid. "
-                                               "Current physics grid is " +
-                                                   grid_name + ".\n");
+  EKAT_REQUIRE_MSG(grid_name == "physics_pg2",
+                   "Error! TMS process can only be used with \"physics_pg2\" physics grid. "
+                   "Current physics grid is " +
+                       grid_name + ".\n");
 
   m_ncols = m_grid->get_num_local_dofs();      // Number of columns on this rank
   m_nlevs = m_grid->get_num_vertical_levels(); // Number of levels per column
@@ -87,7 +89,8 @@ void TurbulentMountainStress::run_impl(const double /* dt */) {
   const int nlev_packs = ekat::npack<Spack>(nlevs);
   // calculate_z_int contains a team-level parallel_scan, which requires a special policy
   const auto scan_policy =
-      ekat::ExeSpaceUtils<TMSFunctions::KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(ncols, nlev_packs);
+      ekat::ExeSpaceUtils<TMSFunctions::KT::ExeSpace>::get_thread_range_parallel_scan_team_policy(
+          ncols, nlev_packs);
   Kokkos::parallel_for(
       scan_policy, KOKKOS_LAMBDA(const TMSFunctions::KT::MemberType &team) {
         const int i = team.league_rank();
@@ -114,9 +117,9 @@ void TurbulentMountainStress::run_impl(const double /* dt */) {
       });
 
   // Compute TMS
-  TMSFunctions::compute_tms(ncols, nlevs, ekat::scalarize(horiz_winds), ekat::scalarize(T_mid), ekat::scalarize(p_mid),
-                            ekat::scalarize(exner), ekat::scalarize(z_mid), sgh30, landfrac, surf_drag_coeff_tms,
-                            wind_stress_tms);
+  TMSFunctions::compute_tms(ncols, nlevs, ekat::scalarize(horiz_winds), ekat::scalarize(T_mid),
+                            ekat::scalarize(p_mid), ekat::scalarize(exner), ekat::scalarize(z_mid),
+                            sgh30, landfrac, surf_drag_coeff_tms, wind_stress_tms);
 }
 
 // =========================================================================================
@@ -139,7 +142,8 @@ void TurbulentMountainStress::init_buffers(const ATMBufferManager &buffer_manage
   const int nlev_packs  = ekat::npack<Spack>(m_nlevs);
   const int nlevi_packs = ekat::npack<Spack>(m_nlevs + 1);
 
-  uview_2d *buffer_mid_view_ptrs[Buffer::num_2d_midpoint_views] = {&m_buffer.exner, &m_buffer.dz, &m_buffer.z_mid};
+  uview_2d *buffer_mid_view_ptrs[Buffer::num_2d_midpoint_views] = {&m_buffer.exner, &m_buffer.dz,
+                                                                   &m_buffer.z_mid};
 
   for (int i = 0; i < Buffer::num_2d_midpoint_views; ++i) {
     *buffer_mid_view_ptrs[i] = uview_2d(mem, m_ncols, nlev_packs);
diff --git i/components/eamxx/src/physics/tms/impl/compute_tms_impl.hpp w/components/eamxx/src/physics/tms/impl/compute_tms_impl.hpp
index 7e160268d6..e7526898ef 100644
--- i/components/eamxx/src/physics/tms/impl/compute_tms_impl.hpp
+++ w/components/eamxx/src/physics/tms/impl/compute_tms_impl.hpp
@@ -7,28 +7,31 @@ namespace scream {
 namespace tms {
 
 template <typename S, typename D>
-void Functions<S, D>::compute_tms(const int &ncols, const int &nlevs, const view_3d<const Scalar> &horiz_wind,
-                                  const view_2d<const Scalar> &t_mid, const view_2d<const Scalar> &p_mid,
-                                  const view_2d<const Scalar> &exner, const view_2d<const Scalar> &z_mid,
-                                  const view_1d<const Scalar> &sgh, const view_1d<const Scalar> &landfrac,
-                                  const view_1d<Scalar> &ksrf, const view_2d<Scalar> &tau_tms) {
+void Functions<S, D>::compute_tms(
+    const int &ncols, const int &nlevs, const view_3d<const Scalar> &horiz_wind,
+    const view_2d<const Scalar> &t_mid, const view_2d<const Scalar> &p_mid,
+    const view_2d<const Scalar> &exner, const view_2d<const Scalar> &z_mid,
+    const view_1d<const Scalar> &sgh, const view_1d<const Scalar> &landfrac,
+    const view_1d<Scalar> &ksrf, const view_2d<Scalar> &tau_tms) {
   using C = physics::Constants<Scalar>;
 
   // Define some constants used
-  const Scalar horomin = 1;          // Minimum value of subgrid orographic height for mountain stress [ m ]
+  const Scalar horomin = 1; // Minimum value of subgrid orographic height for mountain stress [ m ]
   const Scalar z0max   = 100;        // Maximum value of z_0 for orography [ m ]
   const Scalar dv2min  = 0.01;       // Minimum shear squared [ m2/s2 ]
   const Scalar orocnst = C::orocnst; // Converts from standard deviation to height [ no unit ]
-  const Scalar z0fac   = C::z0fac;   // Factor determining z_0 from orographic standard deviation [ no unit ]
-  const Scalar karman  = C::Karman;  // von Karman constant
-  const Scalar gravit  = C::gravit;  // Acceleration due to gravity
-  const Scalar rair    = C::Rair;    // Gas constant for dry air
+  const Scalar z0fac =
+      C::z0fac; // Factor determining z_0 from orographic standard deviation [ no unit ]
+  const Scalar karman = C::Karman; // von Karman constant
+  const Scalar gravit = C::gravit; // Acceleration due to gravity
+  const Scalar rair   = C::Rair;   // Gas constant for dry air
 
   // Loop over columns
   const typename KT::RangePolicy policy(0, ncols);
   Kokkos::parallel_for(
       policy, KOKKOS_LAMBDA(const int &i) {
-        // Subview on column, scalarize since we only care about last 2 levels (never loop over levels)
+        // Subview on column, scalarize since we only care about last 2 levels (never loop over
+        // levels)
         const auto u_wind_i = ekat::subview(horiz_wind, i, 0);
         const auto v_wind_i = ekat::subview(horiz_wind, i, 1);
         const auto t_mid_i  = ekat::subview(t_mid, i);
@@ -60,7 +63,8 @@ void Functions<S, D>::compute_tms(const int &ncols, const int &nlevs, const view
           const auto dv2   = ekat::impl::max(tmp_u * tmp_u + tmp_v * tmp_v, dv2min);
 
           const auto ri = 2 * gravit * (t_mid_i(kt) * exner_i(kt) - t_mid_i(kb) * exner_i(kb)) *
-                          (z_mid_i(kt) - z_mid_i(kb)) / ((t_mid_i(kt) * exner_i(kt) + t_mid_i(kb) * exner_i(kb)) * dv2);
+                          (z_mid_i(kt) - z_mid_i(kb)) /
+                          ((t_mid_i(kt) * exner_i(kt) + t_mid_i(kb) * exner_i(kb)) * dv2);
 
           // Calculate the instability function and modify the neutral drag cofficient.
           // We should probably follow more elegant approach like Louis et al (1982) or
@@ -70,12 +74,12 @@ void Functions<S, D>::compute_tms(const int &ncols, const int &nlevs, const view
           cd *= stabfri;
 
           // Compute density, velocity magnitude and stress using bottom level properties
-          const auto rho = p_mid_i(nlevs - 1) / (rair * t_mid_i(nlevs - 1));
-          const auto vmag =
-              std::sqrt(u_wind_i(nlevs - 1) * u_wind_i(nlevs - 1) + v_wind_i(nlevs - 1) * v_wind_i(nlevs - 1));
-          ksrf(i)       = rho * cd * vmag * landfrac(i);
-          tau_tms(i, 0) = -ksrf(i) * u_wind_i(nlevs - 1);
-          tau_tms(i, 1) = -ksrf(i) * v_wind_i(nlevs - 1);
+          const auto rho  = p_mid_i(nlevs - 1) / (rair * t_mid_i(nlevs - 1));
+          const auto vmag = std::sqrt(u_wind_i(nlevs - 1) * u_wind_i(nlevs - 1) +
+                                      v_wind_i(nlevs - 1) * v_wind_i(nlevs - 1));
+          ksrf(i)         = rho * cd * vmag * landfrac(i);
+          tau_tms(i, 0)   = -ksrf(i) * u_wind_i(nlevs - 1);
+          tau_tms(i, 1)   = -ksrf(i) * v_wind_i(nlevs - 1);
         }
       });
 }
diff --git i/components/eamxx/src/physics/tms/tests/compute_tms_tests.cpp w/components/eamxx/src/physics/tms/tests/compute_tms_tests.cpp
index 947c01aba8..0f8dbe9f0a 100644
--- i/components/eamxx/src/physics/tms/tests/compute_tms_tests.cpp
+++ w/components/eamxx/src/physics/tms/tests/compute_tms_tests.cpp
@@ -13,7 +13,8 @@ namespace scream {
 namespace tms {
 namespace unit_test {
 
-template <typename D> struct UnitWrap::UnitTest<D>::TestComputeTMS : public UnitWrap::UnitTest<D>::Base {
+template <typename D>
+struct UnitWrap::UnitTest<D>::TestComputeTMS : public UnitWrap::UnitTest<D>::Base {
 
   void run_property() {
     // Should property tests be created?
@@ -23,8 +24,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestComputeTMS : public Unit
     auto engine = Base::get_engine();
 
     ComputeTMSData baseline_data[] = {//             ncols, nlevs
-                                      ComputeTMSData(12, 72), ComputeTMSData(8, 12), ComputeTMSData(7, 16),
-                                      ComputeTMSData(2, 7)};
+                                      ComputeTMSData(12, 72), ComputeTMSData(8, 12),
+                                      ComputeTMSData(7, 16), ComputeTMSData(2, 7)};
 
     static constexpr Int num_runs = sizeof(baseline_data) / sizeof(ComputeTMSData);
 
@@ -36,7 +37,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestComputeTMS : public Unit
     // Create copies of data for use by cxx. Needs to happen before read calls so that
     // inout data is in original state
     ComputeTMSData cxx_data[] = {ComputeTMSData(baseline_data[0]), ComputeTMSData(baseline_data[1]),
-                                 ComputeTMSData(baseline_data[2]), ComputeTMSData(baseline_data[3])};
+                                 ComputeTMSData(baseline_data[2]),
+                                 ComputeTMSData(baseline_data[3])};
 
     // Assume all data is in C layout
 
@@ -82,7 +84,8 @@ template <typename D> struct UnitWrap::UnitTest<D>::TestComputeTMS : public Unit
 namespace {
 
 TEST_CASE("compute_tms_bfb", "tms") {
-  using TestStruct = scream::tms::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestComputeTMS;
+  using TestStruct =
+      scream::tms::unit_test::UnitWrap::UnitTest<scream::DefaultDevice>::TestComputeTMS;
 
   TestStruct t;
   t.run_bfb();
diff --git i/components/eamxx/src/physics/tms/tests/infra/tms_test_data.cpp w/components/eamxx/src/physics/tms/tests/infra/tms_test_data.cpp
index dfad26e681..ea3e22d5df 100644
--- i/components/eamxx/src/physics/tms/tests/infra/tms_test_data.cpp
+++ w/components/eamxx/src/physics/tms/tests/infra/tms_test_data.cpp
@@ -17,8 +17,9 @@ namespace tms {
 //
 // _f function definitions. These expect data in C layout
 //
-void compute_tms_f(int ncols, int nlevs, Real *u_wind, Real *v_wind, Real *t_mid, Real *p_mid, Real *exner, Real *z_mid,
-                   Real *sgh, Real *landfrac, Real *ksrf, Real *taux, Real *tauy) {
+void compute_tms_f(int ncols, int nlevs, Real *u_wind, Real *v_wind, Real *t_mid, Real *p_mid,
+                   Real *exner, Real *z_mid, Real *sgh, Real *landfrac, Real *ksrf, Real *taux,
+                   Real *tauy) {
   using TMSFunc = Functions<Real, DefaultDevice>;
 
   using Scalar     = typename TMSFunc::Scalar;
@@ -36,11 +37,11 @@ void compute_tms_f(int ncols, int nlevs, Real *u_wind, Real *v_wind, Real *t_mid
   ScreamDeepCopy::copy_to_device({sgh, landfrac}, ncols, temp_d_1d);
   ekat::host_to_device({u_wind, v_wind, t_mid, p_mid, exner, z_mid}, ncols, nlevs, temp_d_2d, true);
 
-  view_1d sgh_d(temp_d_1d[0]), landfrac_d(temp_d_1d[1]), ksrf_d("ksrf_d", ncols), taux_d("taux_d", ncols),
-      tauy_d("tauy_d", ncols);
+  view_1d sgh_d(temp_d_1d[0]), landfrac_d(temp_d_1d[1]), ksrf_d("ksrf_d", ncols),
+      taux_d("taux_d", ncols), tauy_d("tauy_d", ncols);
 
-  view_2d u_wind_d(temp_d_2d[0]), v_wind_d(temp_d_2d[1]), t_mid_d(temp_d_2d[2]), p_mid_d(temp_d_2d[3]),
-      exner_d(temp_d_2d[4]), z_mid_d(temp_d_2d[5]);
+  view_2d u_wind_d(temp_d_2d[0]), v_wind_d(temp_d_2d[1]), t_mid_d(temp_d_2d[2]),
+      p_mid_d(temp_d_2d[3]), exner_d(temp_d_2d[4]), z_mid_d(temp_d_2d[5]);
 
   // calculate_tms treats u/v_wind and taux/y as multiple component arrays.
   const auto nlev_packs = ekat::npack<Spack>(nlevs);
@@ -59,8 +60,9 @@ void compute_tms_f(int ncols, int nlevs, Real *u_wind, Real *v_wind, Real *t_mid
       });
 
   // C++ compute_tms function implementation
-  TMSFunc::compute_tms(ncols, nlevs, ekat::scalarize(horiz_wind_d), ekat::scalarize(t_mid_d), ekat::scalarize(p_mid_d),
-                       ekat::scalarize(exner_d), ekat::scalarize(z_mid_d), sgh_d, landfrac_d, ksrf_d, tau_d);
+  TMSFunc::compute_tms(ncols, nlevs, ekat::scalarize(horiz_wind_d), ekat::scalarize(t_mid_d),
+                       ekat::scalarize(p_mid_d), ekat::scalarize(exner_d), ekat::scalarize(z_mid_d),
+                       sgh_d, landfrac_d, ksrf_d, tau_d);
 
   // Transfer data back to individual arrays (only for output variables)
   Kokkos::parallel_for(
@@ -76,8 +78,8 @@ void compute_tms_f(int ncols, int nlevs, Real *u_wind, Real *v_wind, Real *t_mid
 }
 
 void compute_tms(ComputeTMSData &d) {
-  compute_tms_f(d.ncols, d.nlevs, d.u_wind, d.v_wind, d.t_mid, d.p_mid, d.exner, d.z_mid, d.sgh, d.landfrac, d.ksrf,
-                d.taux, d.tauy);
+  compute_tms_f(d.ncols, d.nlevs, d.u_wind, d.v_wind, d.t_mid, d.p_mid, d.exner, d.z_mid, d.sgh,
+                d.landfrac, d.ksrf, d.taux, d.tauy);
 }
 
 } // namespace tms
diff --git i/components/eamxx/src/physics/tms/tests/infra/tms_test_data.hpp w/components/eamxx/src/physics/tms/tests/infra/tms_test_data.hpp
index b7e0df21ca..598b04fa5a 100644
--- i/components/eamxx/src/physics/tms/tests/infra/tms_test_data.hpp
+++ w/components/eamxx/src/physics/tms/tests/infra/tms_test_data.hpp
@@ -28,7 +28,8 @@ struct ComputeTMSData : public PhysicsTestData {
 
   ComputeTMSData(int ncols_, int nlevs_)
       : PhysicsTestData({{ncols_}, {ncols_, nlevs_}},
-                        {{&sgh, &landfrac, &ksrf, &taux, &tauy}, {&u_wind, &v_wind, &t_mid, &p_mid, &exner, &z_mid}}),
+                        {{&sgh, &landfrac, &ksrf, &taux, &tauy},
+                         {&u_wind, &v_wind, &t_mid, &p_mid, &exner, &z_mid}}),
         ncols(ncols_), nlevs(nlevs_) {}
 
   PTD_STD_DEF(ComputeTMSData, 2, ncols, nlevs);
diff --git i/components/eamxx/src/physics/tms/tms_functions.hpp w/components/eamxx/src/physics/tms/tms_functions.hpp
index 80b226f8fb..448fee9ea8 100644
--- i/components/eamxx/src/physics/tms/tms_functions.hpp
+++ w/components/eamxx/src/physics/tms/tms_functions.hpp
@@ -35,7 +35,8 @@ template <typename ScalarT, typename DeviceT> struct Functions {
   //
   // --------- Functions ---------
   //
-  static void compute_tms(const int &ncols, const int &nlevs, const view_3d<const Scalar> &horiz_wind,
+  static void compute_tms(const int &ncols, const int &nlevs,
+                          const view_3d<const Scalar> &horiz_wind,
                           const view_2d<const Scalar> &t_mid, const view_2d<const Scalar> &p_mid,
                           const view_2d<const Scalar> &exner, const view_2d<const Scalar> &z_mid,
                           const view_1d<const Scalar> &sgh, const view_1d<const Scalar> &landfrac,
diff --git i/components/eamxx/src/python/libpyeamxx/pyatmproc.hpp w/components/eamxx/src/python/libpyeamxx/pyatmproc.hpp
index f738a5edc9..78b5ca1fab 100644
--- i/components/eamxx/src/python/libpyeamxx/pyatmproc.hpp
+++ w/components/eamxx/src/python/libpyeamxx/pyatmproc.hpp
@@ -36,9 +36,10 @@ struct PyAtmProc {
     const auto &comm = PySession::get().comm;
 
     // Create the atm proc
-    auto &apf           = AtmosphereProcessFactory::instance();
-    const auto &ap_type = params.pl.isParameter("type") ? params.pl.get<std::string>("type") : params.pl.name();
-    ap                  = apf.create(ap_type, comm, params.pl);
+    auto &apf = AtmosphereProcessFactory::instance();
+    const auto &ap_type =
+        params.pl.isParameter("type") ? params.pl.get<std::string>("type") : params.pl.name();
+    ap = apf.create(ap_type, comm, params.pl);
 
     // Create the fields
     auto gm = PySession::get().gm;
diff --git i/components/eamxx/src/python/libpyeamxx/pyfield.hpp w/components/eamxx/src/python/libpyeamxx/pyfield.hpp
index f540be5421..5170c20896 100644
--- i/components/eamxx/src/python/libpyeamxx/pyfield.hpp
+++ w/components/eamxx/src/python/libpyeamxx/pyfield.hpp
@@ -28,16 +28,16 @@ struct PyField {
     const auto &fh  = f.get_header();
     const auto &fid = fh.get_identifier();
 
-    // Can this actually happen? For now, no, since we only create fields from identifiers, so each PyField
-    // holds separate memory. However, this may change if we allow subfields.
-    EKAT_REQUIRE_MSG(
-        f.get_header().get_parent().lock() == nullptr,
-        "Error! Cannot get the array for a field that is a subfield of another. Please, get array of parent field.\n"
-        "  - field name : " +
-            fid.name() +
-            "\n"
-            "  - parent name: " +
-            fh.get_parent().lock()->get_identifier().name() + "\n");
+    // Can this actually happen? For now, no, since we only create fields from identifiers, so each
+    // PyField holds separate memory. However, this may change if we allow subfields.
+    EKAT_REQUIRE_MSG(f.get_header().get_parent().lock() == nullptr,
+                     "Error! Cannot get the array for a field that is a subfield of another. "
+                     "Please, get array of parent field.\n"
+                     "  - field name : " +
+                         fid.name() +
+                         "\n"
+                         "  - parent name: " +
+                         fh.get_parent().lock()->get_identifier().name() + "\n");
 
     // Get array shape and strides.
     // NOTE: since the field may be padded, the strides do not necessarily
@@ -76,7 +76,8 @@ struct PyField {
   void print() const { print_field_hyperslab(f); }
 
 private:
-  template <typename T> nb::dlpack::dtype get_dt_and_set_strides(std::vector<ssize_t> &strides) const {
+  template <typename T>
+  nb::dlpack::dtype get_dt_and_set_strides(std::vector<ssize_t> &strides) const {
     strides.resize(f.rank());
     switch (f.rank()) {
     case 1: {
diff --git i/components/eamxx/src/python/libpyeamxx/pygrid.hpp w/components/eamxx/src/python/libpyeamxx/pygrid.hpp
index 699c19419b..5b6f5805aa 100644
--- i/components/eamxx/src/python/libpyeamxx/pygrid.hpp
+++ w/components/eamxx/src/python/libpyeamxx/pygrid.hpp
@@ -15,7 +15,8 @@ namespace nb = nanobind;
 namespace scream {
 
 inline void create_grids_manager(int ncols, int nlevs, const std::string &latlon_nc_file) {
-  EKAT_REQUIRE_MSG(PySession::get().inited, "Error! You did not initialize pyeamxx, or you already finalized it!\n");
+  EKAT_REQUIRE_MSG(PySession::get().inited,
+                   "Error! You did not initialize pyeamxx, or you already finalized it!\n");
   auto &comm = PySession::get().comm;
   ekat::ParameterList gm_params;
   std::vector<std::string> grids_names = {"physics"};
@@ -38,7 +39,8 @@ inline void create_grids_manager(int ncols, int nlevs) { create_grids_manager(nc
 
 inline void nb_pygrid(nb::module_ &m) {
   m.def("create_grids_manager", nb::overload_cast<int, int>(&create_grids_manager));
-  m.def("create_grids_manager", nb::overload_cast<int, int, const std::string &>(&create_grids_manager));
+  m.def("create_grids_manager",
+        nb::overload_cast<int, int, const std::string &>(&create_grids_manager));
 }
 
 } // namespace scream
diff --git i/components/eamxx/src/python/libpyeamxx/pyparamlist.hpp w/components/eamxx/src/python/libpyeamxx/pyparamlist.hpp
index 78c1de46af..abf55128a4 100644
--- i/components/eamxx/src/python/libpyeamxx/pyparamlist.hpp
+++ w/components/eamxx/src/python/libpyeamxx/pyparamlist.hpp
@@ -22,7 +22,9 @@ struct PyParamList {
 
   PyParamList(const nb::dict &d) : PyParamList(d, "") {}
 
-  PyParamList(const nb::dict &d, const std::string &name) : pl(name), pl_ref(pl) { parse_dict(d, pl); }
+  PyParamList(const nb::dict &d, const std::string &name) : pl(name), pl_ref(pl) {
+    parse_dict(d, pl);
+  }
 
   PyParamList sublist(const std::string &name) {
     PyParamList spl(pl.sublist(name));
@@ -34,8 +36,12 @@ struct PyParamList {
   double get_dbl(const std::string &name) const { return pl_ref.get().get<double>(name); }
   std::string get_str(const std::string &name) const { return pl_ref.get().get<std::string>(name); }
 
-  std::vector<int> get_int_vec(const std::string &name) const { return pl_ref.get().get<std::vector<int>>(name); }
-  std::vector<double> get_dbl_vec(const std::string &name) const { return pl_ref.get().get<std::vector<double>>(name); }
+  std::vector<int> get_int_vec(const std::string &name) const {
+    return pl_ref.get().get<std::vector<int>>(name);
+  }
+  std::vector<double> get_dbl_vec(const std::string &name) const {
+    return pl_ref.get().get<std::vector<double>>(name);
+  }
   std::vector<std::string> get_str_vec(const std::string &name) const {
     return pl_ref.get().get<std::vector<std::string>>(name);
   }
@@ -73,7 +79,8 @@ private:
   }
 
   void parse_list(const nb::list &l, ekat::ParameterList &p, const std::string &key) {
-    EKAT_REQUIRE_MSG(nb::len(l) > 0, "Error! Cannot deduce type for dictionary list entry '" + key + "'\n");
+    EKAT_REQUIRE_MSG(nb::len(l) > 0,
+                     "Error! Cannot deduce type for dictionary list entry '" + key + "'\n");
     auto first       = l[0];
     bool are_ints    = nb::isinstance<nb::int_>(first);
     bool are_floats  = nb::isinstance<nb::float_>(first);
diff --git i/components/eamxx/src/share/atm_process/ATMBufferManager.hpp w/components/eamxx/src/share/atm_process/ATMBufferManager.hpp
index e7e55584e0..56f1f05f3a 100644
--- i/components/eamxx/src/share/atm_process/ATMBufferManager.hpp
+++ w/components/eamxx/src/share/atm_process/ATMBufferManager.hpp
@@ -24,8 +24,9 @@ struct ATMBufferManager {
   // the same time, the total allocation will be the maximum
   // of each request.
   void request_bytes(const size_t num_bytes) {
-    ekat::error::runtime_check(num_bytes % sizeof(Real) == 0,
-                               "Error! Must request number of bytes which is divisible by sizeof(Real).\n");
+    ekat::error::runtime_check(
+        num_bytes % sizeof(Real) == 0,
+        "Error! Must request number of bytes which is divisible by sizeof(Real).\n");
 
     const size_t num_reals = num_bytes / sizeof(Real);
     m_size                 = std::max(num_reals, m_size);
diff --git i/components/eamxx/src/share/atm_process/IOPDataManager.cpp w/components/eamxx/src/share/atm_process/IOPDataManager.cpp
index 147a6d4b82..e164d13eaf 100644
--- i/components/eamxx/src/share/atm_process/IOPDataManager.cpp
+++ w/components/eamxx/src/share/atm_process/IOPDataManager.cpp
@@ -12,24 +12,28 @@
 namespace scream {
 namespace control {
 
-IOPDataManager::IOPDataManager(const ekat::Comm &comm, const ekat::ParameterList &params, const util::TimeStamp &run_t0,
-                               const int model_nlevs, const Field &hyam, const Field &hybm) {
+IOPDataManager::IOPDataManager(const ekat::Comm &comm, const ekat::ParameterList &params,
+                               const util::TimeStamp &run_t0, const int model_nlevs,
+                               const Field &hyam, const Field &hybm) {
   m_comm   = comm;
   m_params = params;
   EKAT_REQUIRE_MSG(m_params.get<bool>("doubly_periodic_mode", false),
                    "Error! Currently doubly_periodic_mode is the only use case for "
                    "intensive observation period files.\n");
 
-  EKAT_REQUIRE_MSG(m_params.isParameter("target_latitude") && m_params.isParameter("target_longitude"),
+  EKAT_REQUIRE_MSG(m_params.isParameter("target_latitude") &&
+                       m_params.isParameter("target_longitude"),
                    "Error! Using intensive observation period files requires "
                    "target_latitude and target_longitude be gives as parameters in "
                    "\"iop_options\" in the input yaml file.\n");
   const auto target_lat = m_params.get<Real>("target_latitude");
   const auto target_lon = m_params.get<Real>("target_longitude");
   EKAT_REQUIRE_MSG(-90 <= target_lat and target_lat <= 90,
-                   "Error! IOP target_lat=" + std::to_string(target_lat) + " outside of expected range [-90, 90].\n");
+                   "Error! IOP target_lat=" + std::to_string(target_lat) +
+                       " outside of expected range [-90, 90].\n");
   EKAT_REQUIRE_MSG(0 <= target_lon and target_lon <= 360,
-                   "Error! IOP target_lat=" + std::to_string(target_lon) + " outside of expected range [0, 360].\n");
+                   "Error! IOP target_lat=" + std::to_string(target_lon) +
+                       " outside of expected range [0, 360].\n");
 
   // Set defaults for some parameters
   if (not m_params.isParameter("iop_srf_prop"))
@@ -66,7 +70,8 @@ IOPDataManager::~IOPDataManager() {
 }
 
 void IOPDataManager::initialize_iop_file(const util::TimeStamp &run_t0, int model_nlevs) {
-  EKAT_REQUIRE_MSG(m_params.isParameter("iop_file"), "Error! Using IOP requires defining an iop_file parameter.\n");
+  EKAT_REQUIRE_MSG(m_params.isParameter("iop_file"),
+                   "Error! Using IOP requires defining an iop_file parameter.\n");
 
   const auto iop_file = m_params.get<std::string>("iop_file");
 
@@ -85,8 +90,8 @@ void IOPDataManager::initialize_iop_file(const util::TimeStamp &run_t0, int mode
                                    const std::string &srf_varname = "none") {
     EKAT_REQUIRE_MSG(fl.rank() == 0 || fl.rank() == 1, "Error! IOP fields must have rank 0 or 1. "
                                                        "Attempting to setup " +
-                                                           varnames[0] + " with rank " + std::to_string(fl.rank()) +
-                                                           ".\n");
+                                                           varnames[0] + " with rank " +
+                                                           std::to_string(fl.rank()) + ".\n");
 
     // Check if var exists in IOP file. Some variables will
     // need to check alternate names.
@@ -114,8 +119,8 @@ void IOPDataManager::initialize_iop_file(const util::TimeStamp &run_t0, int mode
       // Allocate field for variable
       FieldIdentifier fid(iop_varname, fl, ekat::units::Units::nondimensional(), "");
       const auto field_rank = fl.rank();
-      EKAT_REQUIRE_MSG(field_rank <= 1,
-                       "Error! Unexpected field rank " + std::to_string(field_rank) + " for iop file fields.\n");
+      EKAT_REQUIRE_MSG(field_rank <= 1, "Error! Unexpected field rank " +
+                                            std::to_string(field_rank) + " for iop file fields.\n");
       Field field(fid);
       if (fl.has_tag(FieldTag::LevelMidPoint) or fl.has_tag(FieldTag::LevelInterface)) {
         // Request packsize allocation for level layout
@@ -164,13 +169,16 @@ void IOPDataManager::initialize_iop_file(const util::TimeStamp &run_t0, int mode
   EKAT_REQUIRE_MSG(has_iop_field("Ps"), "Error! IOP file required to contain variable \"Ps\".\n");
   EKAT_REQUIRE_MSG(has_iop_field("T"), "Error! IOP file required to contain variable \"T\".\n");
   EKAT_REQUIRE_MSG(has_iop_field("q"), "Error! IOP file required to contain variable \"q\".\n");
-  EKAT_REQUIRE_MSG(has_iop_field("divT"), "Error! IOP file required to contain variable \"divT\".\n");
-  EKAT_REQUIRE_MSG(has_iop_field("divq"), "Error! IOP file required to contain variable \"divq\".\n");
+  EKAT_REQUIRE_MSG(has_iop_field("divT"),
+                   "Error! IOP file required to contain variable \"divT\".\n");
+  EKAT_REQUIRE_MSG(has_iop_field("divq"),
+                   "Error! IOP file required to contain variable \"divq\".\n");
 
   // Check for large scale winds and enfore "all-or-nothing" for u and v component
   const bool both_ls    = (has_iop_field("u_ls") and has_iop_field("v_ls"));
   const bool neither_ls = (not(has_iop_field("u_ls") or has_iop_field("v_ls")));
-  EKAT_REQUIRE_MSG(both_ls or neither_ls, "Error! Either u_ls and v_ls both defined in IOP file, or neither.\n");
+  EKAT_REQUIRE_MSG(both_ls or neither_ls,
+                   "Error! Either u_ls and v_ls both defined in IOP file, or neither.\n");
   m_params.set<bool>("use_large_scale_wind", both_ls);
 
   // Require large scale winds if using Coriolis forcing
@@ -248,7 +256,8 @@ void IOPDataManager::initialize_iop_file(const util::TimeStamp &run_t0, int mode
   // longitude may be negtive in the iop file, we convert to positive before checking.
   const auto nlats = scorpio::get_dimlen(iop_file, "lat");
   const auto nlons = scorpio::get_dimlen(iop_file, "lon");
-  EKAT_REQUIRE_MSG(nlats == 1 and nlons == 1, "Error! IOP data file requires a single lat/lon pair.\n");
+  EKAT_REQUIRE_MSG(nlats == 1 and nlons == 1,
+                   "Error! IOP data file requires a single lat/lon pair.\n");
   Real iop_file_lat, iop_file_lon;
 
   scorpio::read_var(iop_file, "lat", &iop_file_lat);
@@ -256,17 +265,21 @@ void IOPDataManager::initialize_iop_file(const util::TimeStamp &run_t0, int mode
 
   const Real rel_lat_err = std::fabs(iop_file_lat - m_params.get<Real>("target_latitude")) /
                            std::max(std::fabs(m_params.get<Real>("target_latitude")), (Real)0.1);
-  const Real rel_lon_err = std::fabs(std::fmod(iop_file_lon + 360.0, 360.0) - m_params.get<Real>("target_longitude")) /
-                           std::max(m_params.get<Real>("target_longitude"), (Real)0.1);
-  EKAT_REQUIRE_MSG(rel_lat_err < std::numeric_limits<float>::epsilon(),
-                   "Error! IOP file variable \"lat\" does not match target_latitude from IOP parameters.\n");
-  EKAT_REQUIRE_MSG(rel_lon_err < std::numeric_limits<float>::epsilon(),
-                   "Error! IOP file variable \"lon\" does not match target_longitude from IOP parameters.\n");
+  const Real rel_lon_err =
+      std::fabs(std::fmod(iop_file_lon + 360.0, 360.0) - m_params.get<Real>("target_longitude")) /
+      std::max(m_params.get<Real>("target_longitude"), (Real)0.1);
+  EKAT_REQUIRE_MSG(
+      rel_lat_err < std::numeric_limits<float>::epsilon(),
+      "Error! IOP file variable \"lat\" does not match target_latitude from IOP parameters.\n");
+  EKAT_REQUIRE_MSG(
+      rel_lon_err < std::numeric_limits<float>::epsilon(),
+      "Error! IOP file variable \"lon\" does not match target_longitude from IOP parameters.\n");
 
   // Store iop file pressure as helper field with dimension lev+1.
   // Load the first lev entries from iop file, the lev+1 entry will
   // be set when reading iop data.
-  EKAT_REQUIRE_MSG(scorpio::has_var(iop_file, "lev"), "Error! Using IOP file requires variable \"lev\".\n");
+  EKAT_REQUIRE_MSG(scorpio::has_var(iop_file, "lev"),
+                   "Error! Using IOP file requires variable \"lev\".\n");
   const auto file_levs = scorpio::get_dimlen(iop_file, "lev");
   FieldIdentifier fid("iop_file_pressure", FieldLayout({FieldTag::LevelMidPoint}, {file_levs + 1}),
                       ekat::units::Units::nondimensional(), "");
@@ -284,7 +297,8 @@ void IOPDataManager::initialize_iop_file(const util::TimeStamp &run_t0, int mode
 
   // Create model pressure helper field (values will be computed
   // in read_iop_file_data())
-  FieldIdentifier model_pres_fid("model_pressure", fl_vector, ekat::units::Units::nondimensional(), "");
+  FieldIdentifier model_pres_fid("model_pressure", fl_vector, ekat::units::Units::nondimensional(),
+                                 "");
   Field model_pressure(model_pres_fid);
   model_pressure.get_header().get_alloc_properties().request_allocation(Pack::n);
   model_pressure.allocate_view();
@@ -311,13 +325,16 @@ void IOPDataManager::setup_io_info(const std::string &file_name, const grid_ptr
   }
 }
 
-void IOPDataManager::read_fields_from_file_for_iop(const std::string &file_name, const std::vector<Field> &fields,
-                                                   const std::shared_ptr<const AbstractGrid> &grid) {
-  EKAT_REQUIRE_MSG(fields.size() > 0,
-                   "[IOPDataManager::read_fields_from_file_for_iop] Error! Input fields list is empty.\n");
+void IOPDataManager::read_fields_from_file_for_iop(
+    const std::string &file_name, const std::vector<Field> &fields,
+    const std::shared_ptr<const AbstractGrid> &grid) {
+  EKAT_REQUIRE_MSG(
+      fields.size() > 0,
+      "[IOPDataManager::read_fields_from_file_for_iop] Error! Input fields list is empty.\n");
 
   auto io_grid = m_io_grids[grid->name()];
-  EKAT_REQUIRE_MSG(io_grid != nullptr, "Error! Attempting to read IOP initial conditions on" + grid->name() +
+  EKAT_REQUIRE_MSG(io_grid != nullptr, "Error! Attempting to read IOP initial conditions on" +
+                                           grid->name() +
                                            " grid, but m_io_grid entry has not been created.\n");
 
   if (grid->name() == "physics_gll" and scorpio::has_dim(file_name, "ncol_d")) {
@@ -403,7 +420,8 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
     // where the last level is the first level equal to surface pressure.
     const auto iop_file_pres_v = iop_file_pressure.get_view<Real *>();
     // Sanity check
-    EKAT_REQUIRE_MSG(file_levs + 1 == iop_file_pressure.get_header().get_identifier().get_layout().dim(0),
+    EKAT_REQUIRE_MSG(file_levs + 1 ==
+                         iop_file_pressure.get_header().get_identifier().get_layout().dim(0),
                      "Error! Unexpected size for helper field \"iop_file_pressure\"\n");
     const auto &Ps = surface_pressure.get_view<const Real>();
     Kokkos::parallel_reduce(
@@ -426,10 +444,11 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
         },
         Kokkos::Min<int>(adjusted_file_levs));
 
-    EKAT_REQUIRE_MSG(adjusted_file_levs > 1, "Error! Pressures in iop file " + iop_file +
-                                                 " is are inccorrectly set. "
-                                                 "Surface pressure \"Ps\" (converted to millibar) should be greater "
-                                                 "than at least the 1st entry in midpoint pressures \"lev\".\n");
+    EKAT_REQUIRE_MSG(adjusted_file_levs > 1,
+                     "Error! Pressures in iop file " + iop_file +
+                         " is are inccorrectly set. "
+                         "Surface pressure \"Ps\" (converted to millibar) should be greater "
+                         "than at least the 1st entry in midpoint pressures \"lev\".\n");
 
     // Compute model pressure levels
     const auto model_pres_v = model_pressure.get_view<Real *>();
@@ -437,8 +456,9 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
     const auto hyam_v       = m_helper_fields["hyam"].get_view<const Real *>();
     const auto hybm_v       = m_helper_fields["hybm"].get_view<const Real *>();
     Kokkos::parallel_for(
-        model_nlevs,
-        KOKKOS_LAMBDA(const int ilev) { model_pres_v(ilev) = 1000 * hyam_v(ilev) + Ps() * hybm_v(ilev) / 100; });
+        model_nlevs, KOKKOS_LAMBDA(const int ilev) {
+          model_pres_v(ilev) = 1000 * hyam_v(ilev) + Ps() * hybm_v(ilev) / 100;
+        });
 
     // Find file pressure levels just outside the range of model pressure levels
     Kokkos::parallel_reduce(
@@ -453,7 +473,8 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
         },
         Kokkos::Max<int>(iop_file_start), Kokkos::Min<int>(iop_file_end));
 
-    // If no file pressures are found outide the reference pressure range, set to file level endpoints
+    // If no file pressures are found outide the reference pressure range, set to file level
+    // endpoints
     if (iop_file_start == Kokkos::reduction_identity<int>::max())
       iop_file_start = 0;
     if (iop_file_end == Kokkos::reduction_identity<int>::min())
@@ -500,7 +521,8 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
       // Create temporary fields for reading iop file variables. We use
       // adjusted_file_levels (computed above) which contains an unset
       // value for surface.
-      FieldIdentifier fid(file_varname + "_iop_file", FieldLayout({FieldTag::LevelMidPoint}, {adjusted_file_levs}),
+      FieldIdentifier fid(file_varname + "_iop_file",
+                          FieldLayout({FieldTag::LevelMidPoint}, {adjusted_file_levs}),
                           ekat::units::Units::nondimensional(), "");
       Field iop_file_field(fid);
       iop_file_field.get_header().get_alloc_properties().request_allocation(Pack::n);
@@ -519,7 +541,8 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
       const auto has_srf = m_iop_field_surface_varnames.count(fname) > 0;
       if (has_srf) {
         const auto srf_varname = m_iop_field_surface_varnames[fname];
-        scorpio::read_var(iop_file, srf_varname, &iop_file_v_h(adjusted_file_levs - 1), iop_file_time_idx);
+        scorpio::read_var(iop_file, srf_varname, &iop_file_v_h(adjusted_file_levs - 1),
+                          iop_file_time_idx);
       } else {
         // No surface value exists, compute surface value
         const auto dx = iop_file_v_h(adjusted_file_levs - 2) - iop_file_v_h(adjusted_file_levs - 3);
@@ -528,12 +551,14 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
         else {
           iop_file_pressure.sync_to_host();
           const auto iop_file_pres_v_h = iop_file_pressure.get_view<const Real *, Host>();
-          const auto dy    = iop_file_pres_v_h(adjusted_file_levs - 2) - iop_file_pres_v_h(adjusted_file_levs - 3);
+          const auto dy =
+              iop_file_pres_v_h(adjusted_file_levs - 2) - iop_file_pres_v_h(adjusted_file_levs - 3);
           const auto scale = dy / dx;
 
-          iop_file_v_h(adjusted_file_levs - 1) =
-              (iop_file_pres_v_h(adjusted_file_levs - 1) - iop_file_pres_v_h(adjusted_file_levs - 2)) / scale +
-              iop_file_v_h(adjusted_file_levs - 2);
+          iop_file_v_h(adjusted_file_levs - 1) = (iop_file_pres_v_h(adjusted_file_levs - 1) -
+                                                  iop_file_pres_v_h(adjusted_file_levs - 2)) /
+                                                     scale +
+                                                 iop_file_v_h(adjusted_file_levs - 2);
         }
       }
       iop_file_field.sync_to_dev();
@@ -554,10 +579,14 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
       const auto policy = ESU::get_default_team_policy(1, total_nlevs);
       Kokkos::parallel_for(
           policy, KOKKOS_LAMBDA(const KT::MemberType &team) {
-            const auto x_src  = Kokkos::subview(iop_file_pres_v, Kokkos::pair<int, int>(iop_file_start, iop_file_end));
-            const auto x_tgt  = Kokkos::subview(model_pres_v, Kokkos::pair<int, int>(model_start, model_end));
-            const auto input  = Kokkos::subview(iop_file_v, Kokkos::pair<int, int>(iop_file_start, iop_file_end));
-            const auto output = Kokkos::subview(iop_field_v, Kokkos::pair<int, int>(model_start, model_end));
+            const auto x_src = Kokkos::subview(
+                iop_file_pres_v, Kokkos::pair<int, int>(iop_file_start, iop_file_end));
+            const auto x_tgt =
+                Kokkos::subview(model_pres_v, Kokkos::pair<int, int>(model_start, model_end));
+            const auto input =
+                Kokkos::subview(iop_file_v, Kokkos::pair<int, int>(iop_file_start, iop_file_end));
+            const auto output =
+                Kokkos::subview(iop_field_v, Kokkos::pair<int, int>(model_start, model_end));
 
             vert_interp.setup(team, x_src, x_tgt);
             vert_interp.lin_interp(team, x_src, x_tgt, input, output);
@@ -566,13 +595,15 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
 
       // For certain fields we need to make sure to fill in the ends of
       // the interpolated region with the value at model_start/model_end
-      if (fname == "T" || fname == "q" || fname == "u" || fname == "u_ls" || fname == "v" || fname == "v_ls") {
+      if (fname == "T" || fname == "q" || fname == "u" || fname == "u_ls" || fname == "v" ||
+          fname == "v_ls") {
         Kokkos::parallel_for(
             Kokkos::RangePolicy<>(0, model_start + 1),
             KOKKOS_LAMBDA(const int ilev) { iop_field_v(ilev) = iop_file_v(0); });
         Kokkos::parallel_for(
-            Kokkos::RangePolicy<>(model_end - 1, total_nlevs),
-            KOKKOS_LAMBDA(const int ilev) { iop_field_v(ilev) = iop_file_v(adjusted_file_levs - 1); });
+            Kokkos::RangePolicy<>(model_end - 1, total_nlevs), KOKKOS_LAMBDA(const int ilev) {
+              iop_field_v(ilev) = iop_file_v(adjusted_file_levs - 1);
+            });
       }
     }
   }
@@ -583,8 +614,9 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
       const auto divT     = get_iop_field("divT").get_view<const Real *>();
       const auto vertdivT = get_iop_field("vertdivT").get_view<const Real *>();
       const auto divT3d   = get_iop_field("divT3d").get_view<Real *>();
-      const auto nlevs    = get_iop_field("divT3d").get_header().get_identifier().get_layout().dim(0);
-      Kokkos::parallel_for(nlevs, KOKKOS_LAMBDA(const int ilev) { divT3d(ilev) = divT(ilev) + vertdivT(ilev); });
+      const auto nlevs = get_iop_field("divT3d").get_header().get_identifier().get_layout().dim(0);
+      Kokkos::parallel_for(
+          nlevs, KOKKOS_LAMBDA(const int ilev) { divT3d(ilev) = divT(ilev) + vertdivT(ilev); });
     }
   }
   if (has_iop_field("divq3d")) {
@@ -592,8 +624,9 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
       const auto divq     = get_iop_field("divq").get_view<const Real *>();
       const auto vertdivq = get_iop_field("vertdivq").get_view<const Real *>();
       const auto divq3d   = get_iop_field("divq3d").get_view<Real *>();
-      const auto nlevs    = get_iop_field("divq3d").get_header().get_identifier().get_layout().dim(0);
-      Kokkos::parallel_for(nlevs, KOKKOS_LAMBDA(const int ilev) { divq3d(ilev) = divq(ilev) + vertdivq(ilev); });
+      const auto nlevs = get_iop_field("divq3d").get_header().get_identifier().get_layout().dim(0);
+      Kokkos::parallel_for(
+          nlevs, KOKKOS_LAMBDA(const int ilev) { divq3d(ilev) = divq(ilev) + vertdivq(ilev); });
     }
   }
 
@@ -601,7 +634,8 @@ void IOPDataManager::read_iop_file_data(const util::TimeStamp &current_ts) {
   m_time_info.time_idx_of_current_data = iop_file_time_idx;
 }
 
-void IOPDataManager::set_fields_from_iop_data(const field_mgr_ptr field_mgr, const std::string &grid_name) {
+void IOPDataManager::set_fields_from_iop_data(const field_mgr_ptr field_mgr,
+                                              const std::string &grid_name) {
   if (m_params.get<bool>("zero_non_iop_tracers") && field_mgr->has_group("tracers", grid_name)) {
     // Zero out all tracers before setting iop tracers (if requested)
     field_mgr->get_field_group("tracers", grid_name).m_monolithic_field->deep_copy(0);
@@ -611,15 +645,17 @@ void IOPDataManager::set_fields_from_iop_data(const field_mgr_ptr field_mgr, con
                                                "data from the IOP file.\n");
 
   // Find which fields need to be written
-  const bool set_ps            = field_mgr->has_field("ps", grid_name) && has_iop_field("Ps");
-  const bool set_T_mid         = field_mgr->has_field("T_mid", grid_name) && has_iop_field("T");
-  const bool set_horiz_winds_u = field_mgr->has_field("horiz_winds", grid_name) && has_iop_field("u");
-  const bool set_horiz_winds_v = field_mgr->has_field("horiz_winds", grid_name) && has_iop_field("v");
-  const bool set_qv            = field_mgr->has_field("qv", grid_name) && has_iop_field("q");
-  const bool set_nc            = field_mgr->has_field("nc", grid_name) && has_iop_field("NUMLIQ");
-  const bool set_qc            = field_mgr->has_field("qc", grid_name) && has_iop_field("CLDLIQ");
-  const bool set_qi            = field_mgr->has_field("qi", grid_name) && has_iop_field("CLDICE");
-  const bool set_ni            = field_mgr->has_field("ni", grid_name) && has_iop_field("NUMICE");
+  const bool set_ps    = field_mgr->has_field("ps", grid_name) && has_iop_field("Ps");
+  const bool set_T_mid = field_mgr->has_field("T_mid", grid_name) && has_iop_field("T");
+  const bool set_horiz_winds_u =
+      field_mgr->has_field("horiz_winds", grid_name) && has_iop_field("u");
+  const bool set_horiz_winds_v =
+      field_mgr->has_field("horiz_winds", grid_name) && has_iop_field("v");
+  const bool set_qv = field_mgr->has_field("qv", grid_name) && has_iop_field("q");
+  const bool set_nc = field_mgr->has_field("nc", grid_name) && has_iop_field("NUMLIQ");
+  const bool set_qc = field_mgr->has_field("qc", grid_name) && has_iop_field("CLDLIQ");
+  const bool set_qi = field_mgr->has_field("qi", grid_name) && has_iop_field("CLDICE");
+  const bool set_ni = field_mgr->has_field("ni", grid_name) && has_iop_field("NUMICE");
 
   // Create views/scalars for these field's data
   view_1d<Real> ps;
@@ -671,8 +707,8 @@ void IOPDataManager::set_fields_from_iop_data(const field_mgr_ptr field_mgr, con
   correct_temperature_and_water_vapor(field_mgr, grid_name);
 
   // Loop over all columns and copy IOP field values to FM views
-  const auto ncols  = field_mgr->get_grids_manager()->get_grid(grid_name)->get_num_local_dofs();
-  const auto nlevs  = field_mgr->get_grids_manager()->get_grid(grid_name)->get_num_vertical_levels();
+  const auto ncols = field_mgr->get_grids_manager()->get_grid(grid_name)->get_num_local_dofs();
+  const auto nlevs = field_mgr->get_grids_manager()->get_grid(grid_name)->get_num_vertical_levels();
   const auto policy = ESU::get_default_team_policy(ncols, nlevs);
   Kokkos::parallel_for(
       policy, KOKKOS_LAMBDA(const KT::MemberType &team) {
@@ -710,7 +746,8 @@ void IOPDataManager::set_fields_from_iop_data(const field_mgr_ptr field_mgr, con
       });
 }
 
-void IOPDataManager::correct_temperature_and_water_vapor(const field_mgr_ptr field_mgr, const std::string &grid_name) {
+void IOPDataManager::correct_temperature_and_water_vapor(const field_mgr_ptr field_mgr,
+                                                         const std::string &grid_name) {
   // Find the first valid level index for t_iop, i.e., first non-zero entry
   int first_valid_idx;
   const auto nlevs = field_mgr->get_grids_manager()->get_grid(grid_name)->get_num_vertical_levels();
@@ -727,8 +764,10 @@ void IOPDataManager::correct_temperature_and_water_vapor(const field_mgr_ptr fie
   // levels 0,...,first_valid_idx-1
   if (first_valid_idx > 0) {
     // If we have values of T and q to correct, we must have both T_mid and qv as FM fields
-    EKAT_REQUIRE_MSG(field_mgr->has_field("T_mid", grid_name), "Error! IOP requires FM to define T_mid.\n");
-    EKAT_REQUIRE_MSG(field_mgr->has_field("qv", grid_name), "Error! IOP requires FM to define qv.\n");
+    EKAT_REQUIRE_MSG(field_mgr->has_field("T_mid", grid_name),
+                     "Error! IOP requires FM to define T_mid.\n");
+    EKAT_REQUIRE_MSG(field_mgr->has_field("qv", grid_name),
+                     "Error! IOP requires FM to define qv.\n");
 
     // Replace values of T and q where t_iop contains zeros
     auto T_mid = field_mgr->get_field("T_mid", grid_name).get_view<const Real **>();
diff --git i/components/eamxx/src/share/atm_process/IOPDataManager.hpp w/components/eamxx/src/share/atm_process/IOPDataManager.hpp
index 10b4281254..f144793171 100644
--- i/components/eamxx/src/share/atm_process/IOPDataManager.hpp
+++ w/components/eamxx/src/share/atm_process/IOPDataManager.hpp
@@ -39,8 +39,9 @@ public:
   //   - run_t0: Initial timestamp for the simulation
   //   - model_nlevs: Number of vertical levels in the simulation. Needed since
   //                  the iop file contains a (potentially) different number of levels
-  IOPDataManager(const ekat::Comm &comm, const ekat::ParameterList &params, const util::TimeStamp &run_t0,
-                 const int model_nlevs, const Field &hyam, const Field &hybm);
+  IOPDataManager(const ekat::Comm &comm, const ekat::ParameterList &params,
+                 const util::TimeStamp &run_t0, const int model_nlevs, const Field &hyam,
+                 const Field &hybm);
 
   // Destructor
   ~IOPDataManager();
@@ -72,15 +73,16 @@ public:
   // Note: We only need to use the first column because during
   //       the loading of ICs, every columns will have the same
   //       data.
-  void correct_temperature_and_water_vapor(const field_mgr_ptr field_mgr, const std::string &grid_name);
+  void correct_temperature_and_water_vapor(const field_mgr_ptr field_mgr,
+                                           const std::string &grid_name);
 
   ekat::ParameterList &get_params() { return m_params; }
 
   bool has_iop_field(const std::string &fname) { return m_iop_fields.count(fname) > 0; }
 
   Field get_iop_field(const std::string &fname) {
-    EKAT_REQUIRE_MSG(has_iop_field(fname),
-                     "Error! Requesting IOP field \"" + fname + "\", but field is not stored in object.\n");
+    EKAT_REQUIRE_MSG(has_iop_field(fname), "Error! Requesting IOP field \"" + fname +
+                                               "\", but field is not stored in object.\n");
     return m_iop_fields[fname];
   }
 
@@ -105,12 +107,13 @@ private:
         }
       }
 
-      EKAT_REQUIRE_MSG(time_idx >= 0, "Error! Current model time (" + current_ts.to_string() +
-                                          ") is not within "
-                                          "IOP time period: [" +
-                                          iop_file_begin_time.to_string() + ", " +
-                                          (iop_file_begin_time + iop_file_times_in_sec(n_iop_times - 1)).to_string() +
-                                          ").\n");
+      EKAT_REQUIRE_MSG(
+          time_idx >= 0,
+          "Error! Current model time (" + current_ts.to_string() +
+              ") is not within "
+              "IOP time period: [" +
+              iop_file_begin_time.to_string() + ", " +
+              (iop_file_begin_time + iop_file_times_in_sec(n_iop_times - 1)).to_string() + ").\n");
       return time_idx;
     }
   };
diff --git i/components/eamxx/src/share/atm_process/SCDataManager.hpp w/components/eamxx/src/share/atm_process/SCDataManager.hpp
index 591b2a33bb..5efc6bb675 100644
--- i/components/eamxx/src/share/atm_process/SCDataManager.hpp
+++ w/components/eamxx/src/share/atm_process/SCDataManager.hpp
@@ -6,12 +6,14 @@
 
 namespace scream {
 
-// This struct provides a intermediary between the AD and the SurfaceCouplingImport/Export AtmophereProcess
-// classes, allowing SCREAM to access CPL data pointers and info about the fields.
+// This struct provides a intermediary between the AD and the SurfaceCouplingImport/Export
+// AtmophereProcess classes, allowing SCREAM to access CPL data pointers and info about the fields.
 struct SCDataManager {
 
-  template <typename DevT, typename DataT> using view_1d = typename KokkosTypes<DevT>::template view_1d<DataT>;
-  template <typename DevT, typename DataT> using view_2d = typename KokkosTypes<DevT>::template view_2d<DataT>;
+  template <typename DevT, typename DataT>
+  using view_1d = typename KokkosTypes<DevT>::template view_1d<DataT>;
+  template <typename DevT, typename DataT>
+  using view_2d = typename KokkosTypes<DevT>::template view_2d<DataT>;
 
   using name_t = char[32];
 
@@ -24,8 +26,9 @@ struct SCDataManager {
 #ifdef HAVE_MOAB
                        Real *field_data_moab_ptr,
 #endif
-                       char *field_names, int *field_cpl_indices_ptr, int *field_vector_components_ptr,
-                       Real *field_constant_multiple_ptr, bool *transfer_during_init_ptr) {
+                       char *field_names, int *field_cpl_indices_ptr,
+                       int *field_vector_components_ptr, Real *field_constant_multiple_ptr,
+                       bool *transfer_during_init_ptr) {
     m_num_cpl_fields    = num_cpl_fields;
     m_num_scream_fields = num_scream_fields;
     m_field_size        = field_size;
@@ -34,16 +37,22 @@ struct SCDataManager {
     EKAT_ASSERT_MSG(field_data_ptr != nullptr, "Error! Ptr for field data is null.");
     EKAT_ASSERT_MSG(field_names != nullptr, "Error! Ptr for field names is null.");
     EKAT_ASSERT_MSG(field_cpl_indices_ptr != nullptr, "Error! Ptr for cpl indices is null.");
-    EKAT_ASSERT_MSG(field_vector_components_ptr != nullptr, "Error! Ptr for field vector components is null.");
-    EKAT_ASSERT_MSG(field_constant_multiple_ptr != nullptr, "Error! Ptr for constant multiple is null.");
-    EKAT_ASSERT_MSG(transfer_during_init_ptr != nullptr, "Error! Ptr for initial transfer boolean is null.");
+    EKAT_ASSERT_MSG(field_vector_components_ptr != nullptr,
+                    "Error! Ptr for field vector components is null.");
+    EKAT_ASSERT_MSG(field_constant_multiple_ptr != nullptr,
+                    "Error! Ptr for constant multiple is null.");
+    EKAT_ASSERT_MSG(transfer_during_init_ptr != nullptr,
+                    "Error! Ptr for initial transfer boolean is null.");
     m_field_data = decltype(m_field_data)(field_data_ptr, m_field_size, m_num_cpl_fields);
 #ifdef HAVE_MOAB
-    m_field_data_moab = decltype(m_field_data_moab)(field_data_moab_ptr, m_num_cpl_fields, m_field_size);
+    m_field_data_moab =
+        decltype(m_field_data_moab)(field_data_moab_ptr, m_num_cpl_fields, m_field_size);
 #endif
-    m_field_cpl_indices       = decltype(m_field_cpl_indices)(field_cpl_indices_ptr, m_num_scream_fields);
-    m_field_vector_components = decltype(m_field_vector_components)(field_vector_components_ptr, m_num_scream_fields);
-    m_field_constant_multiple = decltype(m_field_constant_multiple)(field_constant_multiple_ptr, m_num_scream_fields);
+    m_field_cpl_indices = decltype(m_field_cpl_indices)(field_cpl_indices_ptr, m_num_scream_fields);
+    m_field_vector_components =
+        decltype(m_field_vector_components)(field_vector_components_ptr, m_num_scream_fields);
+    m_field_constant_multiple =
+        decltype(m_field_constant_multiple)(field_constant_multiple_ptr, m_num_scream_fields);
     m_field_transfer_during_init =
         decltype(m_field_transfer_during_init)(transfer_during_init_ptr, m_num_scream_fields);
 
diff --git i/components/eamxx/src/share/atm_process/atmosphere_diagnostic.cpp w/components/eamxx/src/share/atm_process/atmosphere_diagnostic.cpp
index 2dfdf6e849..1de75684b4 100644
--- i/components/eamxx/src/share/atm_process/atmosphere_diagnostic.cpp
+++ w/components/eamxx/src/share/atm_process/atmosphere_diagnostic.cpp
@@ -2,16 +2,19 @@
 
 namespace scream {
 
-AtmosphereDiagnostic::AtmosphereDiagnostic(const ekat::Comm &comm, const ekat::ParameterList &params)
+AtmosphereDiagnostic::AtmosphereDiagnostic(const ekat::Comm &comm,
+                                           const ekat::ParameterList &params)
     : AtmosphereProcess(comm, params) {
   // Nothing to do here
 }
 
 // Function to retrieve the diagnostic output which is stored in m_diagnostic_output
 Field AtmosphereDiagnostic::get_diagnostic() const {
-  EKAT_REQUIRE_MSG(m_diagnostic_output.is_allocated(),
-                   "Error! Getting a diagnostic field before it is allocated is suspicious at best.\n"
-                   "       We chose to throw an error, but if this is a legit use, please, contact developers.\n");
+  EKAT_REQUIRE_MSG(
+      m_diagnostic_output.is_allocated(),
+      "Error! Getting a diagnostic field before it is allocated is suspicious at best.\n"
+      "       We chose to throw an error, but if this is a legit use, please, contact "
+      "developers.\n");
   return m_diagnostic_output;
 }
 
@@ -82,7 +85,8 @@ void AtmosphereDiagnostic::set_computed_field_impl(const Field & /* f */) {
 }
 
 void AtmosphereDiagnostic::set_computed_group_impl(const FieldGroup & /* group */) {
-  EKAT_ERROR_MSG("Error! Diagnostics are not allowed to compute field groups. See " + name() + ".\n");
+  EKAT_ERROR_MSG("Error! Diagnostics are not allowed to compute field groups. See " + name() +
+                 ".\n");
 }
 
 } // namespace scream
diff --git i/components/eamxx/src/share/atm_process/atmosphere_diagnostic.hpp w/components/eamxx/src/share/atm_process/atmosphere_diagnostic.hpp
index 5a718ca6cd..c7333141a2 100644
--- i/components/eamxx/src/share/atm_process/atmosphere_diagnostic.hpp
+++ w/components/eamxx/src/share/atm_process/atmosphere_diagnostic.hpp
@@ -75,20 +75,22 @@ protected:
 };
 
 // A short name for the factory for atmosphere diagnostics
-// WARNING: you do not need to write your own creator function to register your atmosphere diagnostic in the factory.
-//          You could, but there's no need. You can simply register the common one right below, using your
-//          atmosphere diagnostic subclass name as templated argument. If you roll your own creator function, you
-//          *MUST* ensure that it correctly sets up the self pointer after creating the shared_ptr.
-//          This is *necessary* until we can safely switch to std::enable_shared_from_this.
-//          For more details, see the comments at the top of ekat_std_enable_shared_from_this.hpp.
-using AtmosphereDiagnosticFactory =
-    ekat::Factory<AtmosphereDiagnostic, ekat::CaseInsensitiveString, std::shared_ptr<AtmosphereDiagnostic>,
-                  const ekat::Comm &, const ekat::ParameterList &>;
+// WARNING: you do not need to write your own creator function to register your atmosphere
+// diagnostic in the factory.
+//          You could, but there's no need. You can simply register the common one right below,
+//          using your atmosphere diagnostic subclass name as templated argument. If you roll your
+//          own creator function, you *MUST* ensure that it correctly sets up the self pointer after
+//          creating the shared_ptr. This is *necessary* until we can safely switch to
+//          std::enable_shared_from_this. For more details, see the comments at the top of
+//          ekat_std_enable_shared_from_this.hpp.
+using AtmosphereDiagnosticFactory = ekat::Factory<AtmosphereDiagnostic, ekat::CaseInsensitiveString,
+                                                  std::shared_ptr<AtmosphereDiagnostic>,
+                                                  const ekat::Comm &, const ekat::ParameterList &>;
 
 // Create an atmosphere process, and correctly set up the (weak) pointer to self.
 template <typename AtmDiagType>
-inline std::shared_ptr<AtmosphereDiagnostic> create_atmosphere_diagnostic(const ekat::Comm &comm,
-                                                                          const ekat::ParameterList &p) {
+inline std::shared_ptr<AtmosphereDiagnostic>
+create_atmosphere_diagnostic(const ekat::Comm &comm, const ekat::ParameterList &p) {
   auto ptr = std::make_shared<AtmDiagType>(comm, p);
   ptr->setSelfPointer(ptr);
   return ptr;
diff --git i/components/eamxx/src/share/atm_process/atmosphere_process.cpp w/components/eamxx/src/share/atm_process/atmosphere_process.cpp
index 98c9f65c40..26392e0b69 100644
--- i/components/eamxx/src/share/atm_process/atmosphere_process.cpp
+++ w/components/eamxx/src/share/atm_process/atmosphere_process.cpp
@@ -47,7 +47,8 @@ AtmosphereProcess::AtmosphereProcess(const ekat::Comm &comm, const ekat::Paramet
   if (m_params.isParameter("number_of_subcycles")) {
     m_num_subcycles = m_params.get<int>("number_of_subcycles");
   }
-  EKAT_REQUIRE_MSG(m_num_subcycles > 0, "Error! Invalid number of subcycles in param list " + m_params.name() +
+  EKAT_REQUIRE_MSG(m_num_subcycles > 0, "Error! Invalid number of subcycles in param list " +
+                                            m_params.name() +
                                             ".\n"
                                             "  - Num subcycles: " +
                                             std::to_string(m_num_subcycles) + "\n");
@@ -57,7 +58,8 @@ AtmosphereProcess::AtmosphereProcess(const ekat::Comm &comm, const ekat::Paramet
   m_repair_log_level = str2LogLevel(m_params.get<std::string>("repair_log_level", "warn"));
 
   // Info for mass and energy conservation checks
-  m_column_conservation_check_data.has_check = m_params.get<bool>("enable_column_conservation_checks", false);
+  m_column_conservation_check_data.has_check =
+      m_params.get<bool>("enable_column_conservation_checks", false);
 
   m_internal_diagnostics_level = m_params.get<int>("internal_diagnostics_level", 0);
 }
@@ -124,16 +126,16 @@ void AtmosphereProcess::run(const double dt) {
 
     if (m_internal_diagnostics_level > 0)
       // Print hash of INPUTS before run
-      print_global_state_hash(name() + "-pre-sc-" + std::to_string(m_subcycle_iter), m_start_of_step_ts, true, false,
-                              false);
+      print_global_state_hash(name() + "-pre-sc-" + std::to_string(m_subcycle_iter),
+                              m_start_of_step_ts, true, false, false);
 
     // Run derived class implementation
     run_impl(dt_sub);
 
     if (m_internal_diagnostics_level > 0)
       // Print hash of OUTPUTS/INTERNALS after run
-      print_global_state_hash(name() + "-pst-sc-" + std::to_string(m_subcycle_iter), m_end_of_step_ts, true, true,
-                              true);
+      print_global_state_hash(name() + "-pst-sc-" + std::to_string(m_subcycle_iter),
+                              m_end_of_step_ts, true, true, true);
 
     if (has_column_conservation_check()) {
       // Run the column local mass and energy conservation checks
@@ -408,10 +410,11 @@ void AtmosphereProcess::set_computed_group(const FieldGroup &group) {
   set_computed_group_impl(group);
 }
 
-void AtmosphereProcess::run_property_check(const prop_check_ptr &property_check,
-                                           const CheckFailHandling check_fail_handling,
-                                           const PropertyCheckCategory property_check_category) const {
-  m_atm_logger->trace("[" + this->name() + "] run_property_check '" + property_check->name() + "'...");
+void AtmosphereProcess::run_property_check(
+    const prop_check_ptr &property_check, const CheckFailHandling check_fail_handling,
+    const PropertyCheckCategory property_check_category) const {
+  m_atm_logger->trace("[" + this->name() + "] run_property_check '" + property_check->name() +
+                      "'...");
   auto res_and_msg = property_check->check();
 
   // string for output
@@ -597,7 +600,8 @@ bool AtmosphereProcess::has_required_field(const FieldIdentifier &id) const {
   return has_required_field(id.name(), id.get_grid_name());
 }
 
-bool AtmosphereProcess::has_required_field(const std::string &name, const std::string &grid_name) const {
+bool AtmosphereProcess::has_required_field(const std::string &name,
+                                           const std::string &grid_name) const {
   for (const auto &it : m_required_field_requests) {
     if (it.fid.name() == name && it.fid.get_grid_name() == grid_name) {
       return true;
@@ -610,7 +614,8 @@ bool AtmosphereProcess::has_computed_field(const FieldIdentifier &id) const {
   return has_computed_field(id.name(), id.get_grid_name());
 }
 
-bool AtmosphereProcess::has_computed_field(const std::string &name, const std::string &grid_name) const {
+bool AtmosphereProcess::has_computed_field(const std::string &name,
+                                           const std::string &grid_name) const {
   for (const auto &it : m_computed_field_requests) {
     if (it.fid.name() == name && it.fid.get_grid_name() == grid_name) {
       return true;
@@ -637,9 +642,13 @@ bool AtmosphereProcess::has_computed_group(const std::string &name, const std::s
   return false;
 }
 
-void AtmosphereProcess::log(const LogLevel lev, const std::string &msg) const { m_atm_logger->log(lev, msg); }
+void AtmosphereProcess::log(const LogLevel lev, const std::string &msg) const {
+  m_atm_logger->log(lev, msg);
+}
 
-void AtmosphereProcess::set_update_time_stamps(const bool do_update) { m_update_time_stamps = do_update; }
+void AtmosphereProcess::set_update_time_stamps(const bool do_update) {
+  m_update_time_stamps = do_update;
+}
 
 void AtmosphereProcess::update_time_stamps() {
   const auto &t = end_of_step_ts();
@@ -671,11 +680,13 @@ void AtmosphereProcess::add_me_as_customer(const Field &f) {
 
 void AtmosphereProcess::add_internal_field(const Field &f) { m_internal_fields.push_back(f); }
 
-const Field &AtmosphereProcess::get_field_in(const std::string &field_name, const std::string &grid_name) const {
+const Field &AtmosphereProcess::get_field_in(const std::string &field_name,
+                                             const std::string &grid_name) const {
   return get_field_in_impl(field_name, grid_name);
 }
 
-Field &AtmosphereProcess::get_field_in(const std::string &field_name, const std::string &grid_name) {
+Field &AtmosphereProcess::get_field_in(const std::string &field_name,
+                                       const std::string &grid_name) {
   return get_field_in_impl(field_name, grid_name);
 }
 
@@ -683,13 +694,17 @@ const Field &AtmosphereProcess::get_field_in(const std::string &field_name) cons
   return get_field_in_impl(field_name);
 }
 
-Field &AtmosphereProcess::get_field_in(const std::string &field_name) { return get_field_in_impl(field_name); }
+Field &AtmosphereProcess::get_field_in(const std::string &field_name) {
+  return get_field_in_impl(field_name);
+}
 
-const Field &AtmosphereProcess::get_field_out(const std::string &field_name, const std::string &grid_name) const {
+const Field &AtmosphereProcess::get_field_out(const std::string &field_name,
+                                              const std::string &grid_name) const {
   return get_field_out_impl(field_name, grid_name);
 }
 
-Field &AtmosphereProcess::get_field_out(const std::string &field_name, const std::string &grid_name) {
+Field &AtmosphereProcess::get_field_out(const std::string &field_name,
+                                        const std::string &grid_name) {
   return get_field_out_impl(field_name, grid_name);
 }
 
@@ -697,13 +712,17 @@ const Field &AtmosphereProcess::get_field_out(const std::string &field_name) con
   return get_field_out_impl(field_name);
 }
 
-Field &AtmosphereProcess::get_field_out(const std::string &field_name) { return get_field_out_impl(field_name); }
+Field &AtmosphereProcess::get_field_out(const std::string &field_name) {
+  return get_field_out_impl(field_name);
+}
 
-const FieldGroup &AtmosphereProcess::get_group_in(const std::string &group_name, const std::string &grid_name) const {
+const FieldGroup &AtmosphereProcess::get_group_in(const std::string &group_name,
+                                                  const std::string &grid_name) const {
   return get_group_in_impl(group_name, grid_name);
 }
 
-FieldGroup &AtmosphereProcess::get_group_in(const std::string &group_name, const std::string &grid_name) {
+FieldGroup &AtmosphereProcess::get_group_in(const std::string &group_name,
+                                            const std::string &grid_name) {
   return get_group_in_impl(group_name, grid_name);
 }
 
@@ -711,13 +730,17 @@ const FieldGroup &AtmosphereProcess::get_group_in(const std::string &group_name)
   return get_group_in_impl(group_name);
 }
 
-FieldGroup &AtmosphereProcess::get_group_in(const std::string &group_name) { return get_group_in_impl(group_name); }
+FieldGroup &AtmosphereProcess::get_group_in(const std::string &group_name) {
+  return get_group_in_impl(group_name);
+}
 
-const FieldGroup &AtmosphereProcess::get_group_out(const std::string &group_name, const std::string &grid_name) const {
+const FieldGroup &AtmosphereProcess::get_group_out(const std::string &group_name,
+                                                   const std::string &grid_name) const {
   return get_group_out_impl(group_name, grid_name);
 }
 
-FieldGroup &AtmosphereProcess::get_group_out(const std::string &group_name, const std::string &grid_name) {
+FieldGroup &AtmosphereProcess::get_group_out(const std::string &group_name,
+                                             const std::string &grid_name) {
   return get_group_out_impl(group_name, grid_name);
 }
 
@@ -725,13 +748,17 @@ const FieldGroup &AtmosphereProcess::get_group_out(const std::string &group_name
   return get_group_out_impl(group_name);
 }
 
-FieldGroup &AtmosphereProcess::get_group_out(const std::string &group_name) { return get_group_out_impl(group_name); }
+FieldGroup &AtmosphereProcess::get_group_out(const std::string &group_name) {
+  return get_group_out_impl(group_name);
+}
 
-const Field &AtmosphereProcess::get_internal_field(const std::string &field_name, const std::string &grid_name) const {
+const Field &AtmosphereProcess::get_internal_field(const std::string &field_name,
+                                                   const std::string &grid_name) const {
   return get_internal_field_impl(field_name, grid_name);
 }
 
-Field &AtmosphereProcess::get_internal_field(const std::string &field_name, const std::string &grid_name) {
+Field &AtmosphereProcess::get_internal_field(const std::string &field_name,
+                                             const std::string &grid_name) {
   return get_internal_field_impl(field_name, grid_name);
 }
 
@@ -748,7 +775,8 @@ void AtmosphereProcess::add_invariant_check(const prop_check_ptr &pc, const Chec
   add_postcondition_check(pc, cfh);
 }
 
-void AtmosphereProcess::add_precondition_check(const prop_check_ptr &pc, const CheckFailHandling cfh) {
+void AtmosphereProcess::add_precondition_check(const prop_check_ptr &pc,
+                                               const CheckFailHandling cfh) {
   // If a pc can repair, we need to make sure the repairable
   // fields are among the computed fields of this atm proc.
   // Otherwise, it would be possible for this AP to implicitly
@@ -766,7 +794,8 @@ void AtmosphereProcess::add_precondition_check(const prop_check_ptr &pc, const C
   m_precondition_checks.push_back(std::make_pair(cfh, pc));
 }
 
-void AtmosphereProcess::add_postcondition_check(const prop_check_ptr &pc, const CheckFailHandling cfh) {
+void AtmosphereProcess::add_postcondition_check(const prop_check_ptr &pc,
+                                                const CheckFailHandling cfh) {
   auto cfh2str = [](const CheckFailHandling cfh) -> std::string {
     std::string s = "";
     switch (cfh) {
@@ -786,18 +815,19 @@ void AtmosphereProcess::add_postcondition_check(const prop_check_ptr &pc, const
   // Avoid adding the *SAME* test twice
   for (const auto &it : m_postcondition_checks) {
     if (it.second->same_as(*pc)) {
-      EKAT_REQUIRE_MSG(it.first == cfh, "Error! Duplicate property check with different CheckFailHandling.\n"
-                                        "  - Atmosphere process name: " +
-                                            name() +
-                                            "\n"
-                                            "  - Property check name: " +
-                                            pc->name() +
-                                            "\n"
-                                            "  - Current CFH: " +
-                                            cfh2str(it.first) +
-                                            "\n"
-                                            "  - Input CFH: " +
-                                            cfh2str(cfh) + "\n");
+      EKAT_REQUIRE_MSG(it.first == cfh,
+                       "Error! Duplicate property check with different CheckFailHandling.\n"
+                       "  - Atmosphere process name: " +
+                           name() +
+                           "\n"
+                           "  - Property check name: " +
+                           pc->name() +
+                           "\n"
+                           "  - Current CFH: " +
+                           cfh2str(it.first) +
+                           "\n"
+                           "  - Input CFH: " +
+                           cfh2str(cfh) + "\n");
       return;
     }
   }
@@ -819,9 +849,11 @@ void AtmosphereProcess::add_postcondition_check(const prop_check_ptr &pc, const
   m_postcondition_checks.push_back(std::make_pair(cfh, pc));
 }
 
-void AtmosphereProcess::add_column_conservation_check(const prop_check_ptr &prop_check, const CheckFailHandling cfh) {
+void AtmosphereProcess::add_column_conservation_check(const prop_check_ptr &prop_check,
+                                                      const CheckFailHandling cfh) {
   EKAT_REQUIRE_MSG(m_column_conservation_check.second == nullptr,
-                   "Error! Conservation check for process \"" + name() + "\" has already been added.");
+                   "Error! Conservation check for process \"" + name() +
+                       "\" has already been added.");
 
   m_column_conservation_check = std::make_pair(cfh, prop_check);
 }
@@ -868,7 +900,8 @@ void AtmosphereProcess::alias_field_in(const std::string &field_name, const std:
 void AtmosphereProcess::alias_field_out(const std::string &field_name, const std::string &grid_name,
                                         const std::string &alias_name) {
   try {
-    m_fields_out_pointers[alias_name][grid_name] = m_fields_out_pointers.at(field_name).at(grid_name);
+    m_fields_out_pointers[alias_name][grid_name] =
+        m_fields_out_pointers.at(field_name).at(grid_name);
   } catch (const std::out_of_range &) {
     // std::out_of_range message would not help detecting where
     // the exception originated, so print a more meaningful message.
@@ -900,7 +933,8 @@ void AtmosphereProcess::alias_group_in(const std::string &group_name, const std:
 void AtmosphereProcess::alias_group_out(const std::string &group_name, const std::string &grid_name,
                                         const std::string &alias_name) {
   try {
-    m_groups_out_pointers[alias_name][grid_name] = m_groups_out_pointers.at(group_name).at(grid_name);
+    m_groups_out_pointers[alias_name][grid_name] =
+        m_groups_out_pointers.at(group_name).at(grid_name);
   } catch (const std::out_of_range &) {
     // std::out_of_range message would not help detecting where
     // the exception originated, so print a more meaningful message.
@@ -913,7 +947,8 @@ void AtmosphereProcess::alias_group_out(const std::string &group_name, const std
   }
 }
 
-Field &AtmosphereProcess::get_field_in_impl(const std::string &field_name, const std::string &grid_name) const {
+Field &AtmosphereProcess::get_field_in_impl(const std::string &field_name,
+                                            const std::string &grid_name) const {
   try {
     return *m_fields_in_pointers.at(field_name).at(grid_name);
   } catch (const std::out_of_range &) {
@@ -936,16 +971,17 @@ Field &AtmosphereProcess::get_field_in_impl(const std::string &field_name, const
 Field &AtmosphereProcess::get_field_in_impl(const std::string &field_name) const {
   try {
     auto &copies = m_fields_in_pointers.at(field_name);
-    EKAT_REQUIRE_MSG(copies.size() == 1, "Error! Attempt to find input field providing only the name,\n"
-                                         "       but multiple copies (on different grids) are present.\n"
-                                         "  field name: " +
-                                             field_name +
-                                             "\n"
-                                             "  atm process: " +
-                                             this->name() +
-                                             "\n"
-                                             "  number of copies: " +
-                                             std::to_string(copies.size()) + "\n");
+    EKAT_REQUIRE_MSG(copies.size() == 1,
+                     "Error! Attempt to find input field providing only the name,\n"
+                     "       but multiple copies (on different grids) are present.\n"
+                     "  field name: " +
+                         field_name +
+                         "\n"
+                         "  atm process: " +
+                         this->name() +
+                         "\n"
+                         "  number of copies: " +
+                         std::to_string(copies.size()) + "\n");
     return *copies.begin()->second;
   } catch (const std::out_of_range &) {
     // std::out_of_range message would not help detecting where
@@ -961,7 +997,8 @@ Field &AtmosphereProcess::get_field_in_impl(const std::string &field_name) const
   return f;
 }
 
-Field &AtmosphereProcess::get_field_out_impl(const std::string &field_name, const std::string &grid_name) const {
+Field &AtmosphereProcess::get_field_out_impl(const std::string &field_name,
+                                             const std::string &grid_name) const {
   try {
     return *m_fields_out_pointers.at(field_name).at(grid_name);
   } catch (const std::out_of_range &) {
@@ -984,16 +1021,17 @@ Field &AtmosphereProcess::get_field_out_impl(const std::string &field_name, cons
 Field &AtmosphereProcess::get_field_out_impl(const std::string &field_name) const {
   try {
     auto &copies = m_fields_out_pointers.at(field_name);
-    EKAT_REQUIRE_MSG(copies.size() == 1, "Error! Attempt to find output field providing only the name,\n"
-                                         "       but multiple copies (on different grids) are present.\n"
-                                         "  field name: " +
-                                             field_name +
-                                             "\n"
-                                             "  atm process: " +
-                                             this->name() +
-                                             "\n"
-                                             "  number of copies: " +
-                                             std::to_string(copies.size()) + "\n");
+    EKAT_REQUIRE_MSG(copies.size() == 1,
+                     "Error! Attempt to find output field providing only the name,\n"
+                     "       but multiple copies (on different grids) are present.\n"
+                     "  field name: " +
+                         field_name +
+                         "\n"
+                         "  atm process: " +
+                         this->name() +
+                         "\n"
+                         "  number of copies: " +
+                         std::to_string(copies.size()) + "\n");
     return *copies.begin()->second;
   } catch (const std::out_of_range &) {
     // std::out_of_range message would not help detecting where
@@ -1009,7 +1047,8 @@ Field &AtmosphereProcess::get_field_out_impl(const std::string &field_name) cons
   return f;
 }
 
-FieldGroup &AtmosphereProcess::get_group_in_impl(const std::string &group_name, const std::string &grid_name) const {
+FieldGroup &AtmosphereProcess::get_group_in_impl(const std::string &group_name,
+                                                 const std::string &grid_name) const {
   try {
     return *m_groups_in_pointers.at(group_name).at(grid_name);
   } catch (const std::out_of_range &) {
@@ -1032,16 +1071,17 @@ FieldGroup &AtmosphereProcess::get_group_in_impl(const std::string &group_name,
 FieldGroup &AtmosphereProcess::get_group_in_impl(const std::string &group_name) const {
   try {
     auto &copies = m_groups_in_pointers.at(group_name);
-    EKAT_REQUIRE_MSG(copies.size() == 1, "Error! Attempt to find input group providing only the name,\n"
-                                         "       but multiple copies (on different grids) are present.\n"
-                                         "  group name: " +
-                                             group_name +
-                                             "\n"
-                                             "  atm process: " +
-                                             this->name() +
-                                             "\n"
-                                             "  number of copies: " +
-                                             std::to_string(copies.size()) + "\n");
+    EKAT_REQUIRE_MSG(copies.size() == 1,
+                     "Error! Attempt to find input group providing only the name,\n"
+                     "       but multiple copies (on different grids) are present.\n"
+                     "  group name: " +
+                         group_name +
+                         "\n"
+                         "  atm process: " +
+                         this->name() +
+                         "\n"
+                         "  number of copies: " +
+                         std::to_string(copies.size()) + "\n");
     return *copies.begin()->second;
   } catch (const std::out_of_range &) {
     // std::out_of_range message would not help detecting where
@@ -1057,7 +1097,8 @@ FieldGroup &AtmosphereProcess::get_group_in_impl(const std::string &group_name)
   return g;
 }
 
-FieldGroup &AtmosphereProcess::get_group_out_impl(const std::string &group_name, const std::string &grid_name) const {
+FieldGroup &AtmosphereProcess::get_group_out_impl(const std::string &group_name,
+                                                  const std::string &grid_name) const {
   try {
     return *m_groups_out_pointers.at(group_name).at(grid_name);
   } catch (const std::out_of_range &) {
@@ -1080,16 +1121,17 @@ FieldGroup &AtmosphereProcess::get_group_out_impl(const std::string &group_name,
 FieldGroup &AtmosphereProcess::get_group_out_impl(const std::string &group_name) const {
   try {
     auto &copies = m_groups_out_pointers.at(group_name);
-    EKAT_REQUIRE_MSG(copies.size() == 1, "Error! Attempt to find output group providing only the name,\n"
-                                         "       but multiple copies (on different grids) are present.\n"
-                                         "  group name: " +
-                                             group_name +
-                                             "\n"
-                                             "  atm process: " +
-                                             this->name() +
-                                             "\n"
-                                             "  number of copies: " +
-                                             std::to_string(copies.size()) + "\n");
+    EKAT_REQUIRE_MSG(copies.size() == 1,
+                     "Error! Attempt to find output group providing only the name,\n"
+                     "       but multiple copies (on different grids) are present.\n"
+                     "  group name: " +
+                         group_name +
+                         "\n"
+                         "  atm process: " +
+                         this->name() +
+                         "\n"
+                         "  number of copies: " +
+                         std::to_string(copies.size()) + "\n");
     return *copies.begin()->second;
   } catch (const std::out_of_range &) {
     // std::out_of_range would message would not help detecting where
@@ -1105,7 +1147,8 @@ FieldGroup &AtmosphereProcess::get_group_out_impl(const std::string &group_name)
   return g;
 }
 
-Field &AtmosphereProcess::get_internal_field_impl(const std::string &field_name, const std::string &grid_name) const {
+Field &AtmosphereProcess::get_internal_field_impl(const std::string &field_name,
+                                                  const std::string &grid_name) const {
   try {
     return *m_internal_fields_pointers.at(field_name).at(grid_name);
   } catch (const std::out_of_range &) {
@@ -1128,16 +1171,17 @@ Field &AtmosphereProcess::get_internal_field_impl(const std::string &field_name,
 Field &AtmosphereProcess::get_internal_field_impl(const std::string &field_name) const {
   try {
     auto &copies = m_internal_fields_pointers.at(field_name);
-    EKAT_REQUIRE_MSG(copies.size() == 1, "Error! Attempt to find internal field providing only the name,\n"
-                                         "       but multiple copies (on different grids) are present.\n"
-                                         "  field name: " +
-                                             field_name +
-                                             "\n"
-                                             "  atm process: " +
-                                             this->name() +
-                                             "\n"
-                                             "  number of copies: " +
-                                             std::to_string(copies.size()) + "\n");
+    EKAT_REQUIRE_MSG(copies.size() == 1,
+                     "Error! Attempt to find internal field providing only the name,\n"
+                     "       but multiple copies (on different grids) are present.\n"
+                     "  field name: " +
+                         field_name +
+                         "\n"
+                         "  atm process: " +
+                         this->name() +
+                         "\n"
+                         "  number of copies: " +
+                         std::to_string(copies.size()) + "\n");
     return *copies.begin()->second;
   } catch (const std::out_of_range &) {
     // std::out_of_range message would not help detecting where
@@ -1197,8 +1241,8 @@ void AtmosphereProcess::compute_column_conservation_checks_data(const int dt) {
                    "but no conservation check exists.\n");
 
   // Set dt and compute current mass and energy.
-  const auto &conservation_check =
-      std::dynamic_pointer_cast<MassAndEnergyColumnConservationCheck>(m_column_conservation_check.second);
+  const auto &conservation_check = std::dynamic_pointer_cast<MassAndEnergyColumnConservationCheck>(
+      m_column_conservation_check.second);
   conservation_check->set_dt(dt);
   conservation_check->compute_current_mass();
   conservation_check->compute_current_energy();
diff --git i/components/eamxx/src/share/atm_process/atmosphere_process.hpp w/components/eamxx/src/share/atm_process/atmosphere_process.hpp
index 1a142d3871..3ace69c1f1 100644
--- i/components/eamxx/src/share/atm_process/atmosphere_process.hpp
+++ w/components/eamxx/src/share/atm_process/atmosphere_process.hpp
@@ -153,9 +153,15 @@ public:
   void run_column_conservation_check() const;
 
   // Returns pre/postcondition checks
-  std::list<std::pair<CheckFailHandling, prop_check_ptr>> get_precondition_checks() { return m_precondition_checks; }
-  std::list<std::pair<CheckFailHandling, prop_check_ptr>> get_postcondition_checks() { return m_postcondition_checks; }
-  std::pair<CheckFailHandling, prop_check_ptr> get_column_conservation_check() { return m_column_conservation_check; }
+  std::list<std::pair<CheckFailHandling, prop_check_ptr>> get_precondition_checks() {
+    return m_precondition_checks;
+  }
+  std::list<std::pair<CheckFailHandling, prop_check_ptr>> get_postcondition_checks() {
+    return m_postcondition_checks;
+  }
+  std::pair<CheckFailHandling, prop_check_ptr> get_column_conservation_check() {
+    return m_column_conservation_check;
+  }
 
   void init_step_tendencies();
   void compute_step_tendencies(const double dt);
@@ -163,10 +169,18 @@ public:
   // These methods allow the AD to figure out what each process needs, with very fine
   // grain detail. See field_request.hpp for more info on what FieldRequest and GroupRequest
   // are, and field_group.hpp for what groups of fields are.
-  const std::list<FieldRequest> &get_required_field_requests() const { return m_required_field_requests; }
-  const std::list<FieldRequest> &get_computed_field_requests() const { return m_computed_field_requests; }
-  const std::list<GroupRequest> &get_required_group_requests() const { return m_required_group_requests; }
-  const std::list<GroupRequest> &get_computed_group_requests() const { return m_computed_group_requests; }
+  const std::list<FieldRequest> &get_required_field_requests() const {
+    return m_required_field_requests;
+  }
+  const std::list<FieldRequest> &get_computed_field_requests() const {
+    return m_computed_field_requests;
+  }
+  const std::list<GroupRequest> &get_required_group_requests() const {
+    return m_required_group_requests;
+  }
+  const std::list<GroupRequest> &get_computed_group_requests() const {
+    return m_computed_group_requests;
+  }
 
   // These sets allow to get all the actual in/out fields stored by the atm proc
   // Note: if an atm proc requires a group, then all the fields in the group, as well as
@@ -219,22 +233,26 @@ public:
   const FieldGroup &get_group_in(const std::string &group_name) const;
   FieldGroup &get_group_in(const std::string &group_name);
 
-  const FieldGroup &get_group_out(const std::string &group_name, const std::string &grid_name) const;
+  const FieldGroup &get_group_out(const std::string &group_name,
+                                  const std::string &grid_name) const;
   FieldGroup &get_group_out(const std::string &group_name, const std::string &grid_name);
   const FieldGroup &get_group_out(const std::string &group_name) const;
   FieldGroup &get_group_out(const std::string &group_name);
 
-  const Field &get_internal_field(const std::string &field_name, const std::string &grid_name) const;
+  const Field &get_internal_field(const std::string &field_name,
+                                  const std::string &grid_name) const;
   Field &get_internal_field(const std::string &field_name, const std::string &grid_name);
   const Field &get_internal_field(const std::string &field_name) const;
   Field &get_internal_field(const std::string &field_name);
 
   // Add a pre-built property check (PC) for precondition, postcondition,
   // invariant (i.e., pre+post), or column conservation check.
-  void add_precondition_check(const prop_check_ptr &prop_check, const CheckFailHandling cfh = CheckFailHandling::Fatal);
+  void add_precondition_check(const prop_check_ptr &prop_check,
+                              const CheckFailHandling cfh = CheckFailHandling::Fatal);
   void add_postcondition_check(const prop_check_ptr &prop_check,
                                const CheckFailHandling cfh = CheckFailHandling::Fatal);
-  void add_invariant_check(const prop_check_ptr &prop_check, const CheckFailHandling cfh = CheckFailHandling::Fatal);
+  void add_invariant_check(const prop_check_ptr &prop_check,
+                           const CheckFailHandling cfh = CheckFailHandling::Fatal);
   void add_column_conservation_check(const prop_check_ptr &prop_check,
                                      const CheckFailHandling cfh = CheckFailHandling::Fatal);
 
@@ -259,14 +277,16 @@ public:
   // Note: (mem, nmem) describe an arbitrary device array. If mem!=nullptr,
   // the array will be hashed and reported as an additional entry
   void print_global_state_hash(const std::string &label, const TimeStamp &t, const bool in = true,
-                               const bool out = true, const bool internal = true, const Real *mem = nullptr,
-                               const int nmem = 0) const;
+                               const bool out = true, const bool internal = true,
+                               const Real *mem = nullptr, const int nmem = 0) const;
 
   // For BFB tracking in production simulations.
   void print_fast_global_state_hash(const std::string &label, const TimeStamp &t) const;
 
   // Set IOP object
-  virtual void set_iop_data_manager(const iop_data_ptr &iop_data_manager) { m_iop_data_manager = iop_data_manager; }
+  virtual void set_iop_data_manager(const iop_data_ptr &iop_data_manager) {
+    m_iop_data_manager = iop_data_manager;
+  }
 
   std::shared_ptr<logger_t> get_logger() const { return m_atm_logger; }
 
@@ -292,11 +312,12 @@ protected:
 
   // Field requests
   template <RequestType RT>
-  void add_field(const std::string &name, const std::string &grid_name, const std::list<std::string> &groups,
-                 const int ps = 1) {
+  void add_field(const std::string &name, const std::string &grid_name,
+                 const std::list<std::string> &groups, const int ps = 1) {
     add_field<RT>(FieldRequest(name, grid_name, groups, ps));
   }
-  template <RequestType RT> void add_field(const std::string &name, const std::string &grid_name, const int ps = 1) {
+  template <RequestType RT>
+  void add_field(const std::string &name, const std::string &grid_name, const int ps = 1) {
     add_field<RT>(name, grid_name, {}, ps);
   }
 
@@ -314,15 +335,18 @@ protected:
 
   template <RequestType RT>
   void add_field(const std::string &name, const FieldLayout &layout, const ekat::units::Units &u,
-                 const std::string &grid_name, const std::list<std::string> &groups, const int ps = 1) {
+                 const std::string &grid_name, const std::list<std::string> &groups,
+                 const int ps = 1) {
     add_field<RT>(FieldIdentifier(name, layout, u, grid_name), groups, ps);
   }
 
-  template <RequestType RT> void add_field(const FieldIdentifier &fid, const std::string &group, const int ps = 1) {
+  template <RequestType RT>
+  void add_field(const FieldIdentifier &fid, const std::string &group, const int ps = 1) {
     add_field<RT>(FieldRequest(fid, group, ps));
   }
 
-  template <RequestType RT> void add_field(const FieldIdentifier &fid, const std::list<std::string> &groups) {
+  template <RequestType RT>
+  void add_field(const FieldIdentifier &fid, const std::list<std::string> &groups) {
     add_field<RT>(FieldRequest(fid, groups));
   }
 
@@ -337,8 +361,9 @@ protected:
 
   // Specialization for add_field to tracer group
   template <RequestType RT>
-  void add_tracer(const std::string &name, std::shared_ptr<const AbstractGrid> grid, const ekat::units::Units &u,
-                  const int ps = 1, const TracerAdvection tracer_advection = TracerAdvection::NoPreference) {
+  void add_tracer(const std::string &name, std::shared_ptr<const AbstractGrid> grid,
+                  const ekat::units::Units &u, const int ps = 1,
+                  const TracerAdvection tracer_advection = TracerAdvection::NoPreference) {
     std::list<std::string> tracer_groups;
     tracer_groups.push_back("tracers");
     if (tracer_advection == TracerAdvection::DynamicsAndTurbulence) {
@@ -443,11 +468,15 @@ protected:
   // for convenience of use (e.g., use a short name for a field/group).
   // Note: these methods do *not* create a copy of the field/group. Also, notice that
   //       these methods need to be called *after* set_fields_and_groups_pointers().
-  void alias_field_in(const std::string &field_name, const std::string &grid_name, const std::string &alias_name);
-  void alias_field_out(const std::string &field_name, const std::string &grid_name, const std::string &alias_name);
+  void alias_field_in(const std::string &field_name, const std::string &grid_name,
+                      const std::string &alias_name);
+  void alias_field_out(const std::string &field_name, const std::string &grid_name,
+                       const std::string &alias_name);
 
-  void alias_group_in(const std::string &group_name, const std::string &grid_name, const std::string &alias_name);
-  void alias_group_out(const std::string &group_name, const std::string &grid_name, const std::string &alias_name);
+  void alias_group_in(const std::string &group_name, const std::string &grid_name,
+                      const std::string &alias_name);
+  void alias_group_out(const std::string &group_name, const std::string &grid_name,
+                       const std::string &alias_name);
 
   // MPI communicator
   ekat::Comm m_comm;
@@ -504,7 +533,8 @@ private:
   void compute_column_conservation_checks_data(const int dt);
 
   // Run an individual property check. The input property_check_category_name
-  void run_property_check(const prop_check_ptr &property_check, const CheckFailHandling check_fail_handling,
+  void run_property_check(const prop_check_ptr &property_check,
+                          const CheckFailHandling check_fail_handling,
                           const PropertyCheckCategory property_check_category) const;
 
   // NOTE: all these members are private, so that derived classes cannot
@@ -586,29 +616,34 @@ protected:
 
 // ================= IMPLEMENTATION ================== //
 
-template <typename FPC, typename... Args> void AtmosphereProcess::add_precondition_check(const Args... args) {
+template <typename FPC, typename... Args>
+void AtmosphereProcess::add_precondition_check(const Args... args) {
   auto fpc = std::make_shared<FPC>(args...);
   add_precondition_check(fpc);
 }
-template <typename FPC, typename... Args> void AtmosphereProcess::add_postcondition_check(const Args... args) {
+template <typename FPC, typename... Args>
+void AtmosphereProcess::add_postcondition_check(const Args... args) {
   auto fpc = std::make_shared<FPC>(args...);
   add_postcondition_check(fpc);
 }
-template <typename FPC, typename... Args> void AtmosphereProcess::add_invariant_check(const Args... args) {
+template <typename FPC, typename... Args>
+void AtmosphereProcess::add_invariant_check(const Args... args) {
   auto fpc = std::make_shared<FPC>(args...);
   add_invariant_check(fpc);
 }
 
 // A short name for the factory for atmosphere processes
-// WARNING: you do not need to write your own creator function to register your atmosphere process in the factory.
-//          You could, but there's no need. You can simply register the common one right below, using your
-//          atmosphere process class name as templated argument. If you roll your own creator function, you
-//          *MUST* ensure that it correctly sets up the self pointer after creating the shared_ptr.
-//          This is *necessary* until we can safely switch to std::enable_shared_from_this.
-//          For more details, see the comments at the top of ekat_std_enable_shared_from_this.hpp.
-using AtmosphereProcessFactory =
-    ekat::Factory<AtmosphereProcess, ekat::CaseInsensitiveString, std::shared_ptr<AtmosphereProcess>,
-                  const ekat::Comm &, const ekat::ParameterList &>;
+// WARNING: you do not need to write your own creator function to register your atmosphere process
+// in the factory.
+//          You could, but there's no need. You can simply register the common one right below,
+//          using your atmosphere process class name as templated argument. If you roll your own
+//          creator function, you *MUST* ensure that it correctly sets up the self pointer after
+//          creating the shared_ptr. This is *necessary* until we can safely switch to
+//          std::enable_shared_from_this. For more details, see the comments at the top of
+//          ekat_std_enable_shared_from_this.hpp.
+using AtmosphereProcessFactory = ekat::Factory<AtmosphereProcess, ekat::CaseInsensitiveString,
+                                               std::shared_ptr<AtmosphereProcess>,
+                                               const ekat::Comm &, const ekat::ParameterList &>;
 
 // Create an atmosphere process, and correctly set up the (weak) pointer to self.
 template <typename AtmProcType>
diff --git i/components/eamxx/src/share/atm_process/atmosphere_process_dag.cpp w/components/eamxx/src/share/atm_process/atmosphere_process_dag.cpp
index e948c358f9..e42378b59b 100644
--- i/components/eamxx/src/share/atm_process/atmosphere_process_dag.cpp
+++ w/components/eamxx/src/share/atm_process/atmosphere_process_dag.cpp
@@ -66,7 +66,8 @@ void AtmProcDAG::create_dag(const group_type &atm_procs) {
 
 void AtmProcDAG::add_surface_coupling(const std::set<FieldIdentifier> &imports,
                                       const std::set<FieldIdentifier> &exports) {
-  EKAT_REQUIRE_MSG(m_nodes.size() > 0, "Error! You need to create the dag before adding surface coupling.\n");
+  EKAT_REQUIRE_MSG(m_nodes.size() > 0,
+                   "Error! You need to create the dag before adding surface coupling.\n");
 
   // Process all imports
   m_nodes.push_back(Node());
@@ -198,7 +199,8 @@ void AtmProcDAG::write_dag(const std::string &fname, const int verbosity) const
           << "  fontsize=30\n"
           << "  label=<\n"
           << "    <table border=\"0\">\n"
-          << "      <tr><td><b><font point-size=\"40\">" << html_fix(n.name) << "</font></b></td></tr>\n";
+          << "      <tr><td><b><font point-size=\"40\">" << html_fix(n.name)
+          << "</font></b></td></tr>\n";
 
     int sz_comp = n.computed.size(), sz_req = n.required.size(), sz_grcomp = n.gr_computed.size(),
         sz_grreq = n.gr_required.size();
@@ -227,8 +229,8 @@ void AtmProcDAG::write_dag(const std::string &fname, const int verbosity) const
           int fid_out    = std::abs(fid);
           fc += "black";
           fc += "\">  ";
-          ofile << "      <tr><td align=\"left\">" << fc << html_fix(print_fid(m_fids[fid_out], fid_verb))
-                << "</font></td></tr>\n";
+          ofile << "      <tr><td align=\"left\">" << fc
+                << html_fix(print_fid(m_fids[fid_out], fid_verb)) << "</font></td></tr>\n";
         }
       }
 
@@ -251,7 +253,8 @@ void AtmProcDAG::write_dag(const std::string &fname, const int verbosity) const
             fc += "black";
           }
           fc += "\">  ";
-          ofile << "      <tr><td align=\"left\">" << fc << html_fix(print_fid(m_fids[fid], fid_verb));
+          ofile << "      <tr><td align=\"left\">" << fc
+                << html_fix(print_fid(m_fids[fid], fid_verb));
           if (ekat::contains(unmet, fid)) {
             ofile << "<b>  *** MISSING ***</b>";
           } else if (ekat::contains(unmet, -fid)) {
@@ -265,15 +268,18 @@ void AtmProcDAG::write_dag(const std::string &fname, const int verbosity) const
       // Computed groups
       if (sz_grcomp > 0) {
         if (n.id == id_begin) {
-          ofile << "      <tr><td align=\"left\"><b><font color=\"#00667E\">Atm Input groups:</font></b></td></tr>\n";
+          ofile << "      <tr><td align=\"left\"><b><font color=\"#00667E\">Atm Input "
+                   "groups:</font></b></td></tr>\n";
         } else if (n.id != id_end) {
-          ofile << "      <tr><td align=\"left\"><b><font color=\"#88621e\">Computed Groups:</font></b></td></tr>\n";
+          ofile << "      <tr><td align=\"left\"><b><font color=\"#88621e\">Computed "
+                   "Groups:</font></b></td></tr>\n";
         }
         for (const auto &gr_fid : n.gr_computed) {
           std::string fc = "<font color=\"";
           fc += "black";
           fc += "\">  ";
-          ofile << "      <tr><td align=\"left\">" << fc << html_fix(print_fid(m_fids[gr_fid], fid_verb));
+          ofile << "      <tr><td align=\"left\">" << fc
+                << html_fix(print_fid(m_fids[gr_fid], fid_verb));
           ofile << "</font></td></tr>\n";
           if (verbosity > 2) {
             ofile << "      <tr><td align=\"left\">  Members:";
@@ -312,15 +318,18 @@ void AtmProcDAG::write_dag(const std::string &fname, const int verbosity) const
       // Required groups
       if (sz_grreq > 0) {
         if (n.name == "End of atm time step") {
-          ofile << "      <tr><td align=\"left\"><b><font color=\"#00667E\">Atm Output Groups:</font></b></td></tr>\n";
+          ofile << "      <tr><td align=\"left\"><b><font color=\"#00667E\">Atm Output "
+                   "Groups:</font></b></td></tr>\n";
         } else if (n.name != "Begin of atm time step") {
-          ofile << "      <tr><td align=\"left\"><b><font color=\"#00667E\">Required Groups:</font></b></td></tr>\n";
+          ofile << "      <tr><td align=\"left\"><b><font color=\"#00667E\">Required "
+                   "Groups:</font></b></td></tr>\n";
         }
         for (const auto &gr_fid : n.gr_required) {
           std::string fc = "<font color=\"";
           fc += (ekat::contains(unmet, gr_fid) ? "red" : "black");
           fc += "\">  ";
-          ofile << "      <tr><td align=\"left\">" << fc << html_fix(print_fid(m_fids[gr_fid], fid_verb));
+          ofile << "      <tr><td align=\"left\">" << fc
+                << html_fix(print_fid(m_fids[gr_fid], fid_verb));
           if (ekat::contains(unmet, gr_fid)) {
             ofile << "<b>  *** MISSING ***</b>";
           }
diff --git i/components/eamxx/src/share/atm_process/atmosphere_process_dag.hpp w/components/eamxx/src/share/atm_process/atmosphere_process_dag.hpp
index 089839af69..537be0f655 100644
--- i/components/eamxx/src/share/atm_process/atmosphere_process_dag.hpp
+++ w/components/eamxx/src/share/atm_process/atmosphere_process_dag.hpp
@@ -20,7 +20,8 @@ public:
 
   void init_atm_proc_nodes(const group_type &atm_procs);
 
-  void add_surface_coupling(const std::set<FieldIdentifier> &imports, const std::set<FieldIdentifier> &exports);
+  void add_surface_coupling(const std::set<FieldIdentifier> &imports,
+                            const std::set<FieldIdentifier> &exports);
 
   void write_dag(const std::string &fname, const int verbosity = VERB_MAX) const;
 
diff --git i/components/eamxx/src/share/atm_process/atmosphere_process_group.cpp w/components/eamxx/src/share/atm_process/atmosphere_process_group.cpp
index e41cec1e0d..1b2b6af55b 100644
--- i/components/eamxx/src/share/atm_process/atmosphere_process_group.cpp
+++ w/components/eamxx/src/share/atm_process/atmosphere_process_group.cpp
@@ -10,7 +10,8 @@
 
 namespace scream {
 
-AtmosphereProcessGroup::AtmosphereProcessGroup(const ekat::Comm &comm, const ekat::ParameterList &params)
+AtmosphereProcessGroup::AtmosphereProcessGroup(const ekat::Comm &comm,
+                                               const ekat::ParameterList &params)
     : AtmosphereProcess(comm, params) {
   // Get the list of procs in the group
   auto group_list = m_params.get<std::vector<std::string>>("atm_procs_list");
@@ -79,17 +80,19 @@ AtmosphereProcessGroup::AtmosphereProcessGroup(const ekat::Comm &comm, const eka
     m_atm_processes.push_back(ap);
 
     // NOTE: the shared_ptr of the new atmosphere process *MUST* have been created correctly.
-    //       Namely, the creation process must have set up enable_shared_from_this's status correctly.
-    //       This is done by the library-provided templated function 'create_atm_process<T>.
-    //       However, if the user has decided to roll his/her own creator function to be registered
-    //       in the AtmosphereProcessFactory, he/she may have forgot to set the self pointer in the process.
-    //       To make sure this is not the case, we check that the weak_ptr in the newly created
-    //       atmosphere process (which comes through inheritance from enable_shared_from_this) is valid.
+    //       Namely, the creation process must have set up enable_shared_from_this's status
+    //       correctly. This is done by the library-provided templated function
+    //       'create_atm_process<T>. However, if the user has decided to roll his/her own creator
+    //       function to be registered in the AtmosphereProcessFactory, he/she may have forgot to
+    //       set the self pointer in the process. To make sure this is not the case, we check that
+    //       the weak_ptr in the newly created atmosphere process (which comes through inheritance
+    //       from enable_shared_from_this) is valid.
     EKAT_REQUIRE_MSG(
         !ap->weak_from_this().expired(),
         "Error! The newly created std::shared_ptr<AtmosphereProcess> did not correctly setup\n"
         "       the 'enable_shared_from_this' interface.\n"
-        "       Did you by chance register your own creator function in the AtmosphereProccessFactory class?\n"
+        "       Did you by chance register your own creator function in the "
+        "AtmosphereProccessFactory class?\n"
         "       If so, don't. Instead, use the instantiation of create_atmosphere_process<T>,\n"
         "       with T = YourAtmProcessClassName.\n");
 
@@ -119,8 +122,8 @@ AtmosphereProcessGroup::AtmosphereProcessGroup(const ekat::Comm &comm, const eka
 
 std::shared_ptr<AtmosphereProcessGroup::atm_proc_type>
 AtmosphereProcessGroup::get_process_nonconst(const std::string &name) const {
-  EKAT_REQUIRE_MSG(has_process(name), "Error! Process " + name + " requested from group " + this->name() +
-                                          " but is not constained in this group.\n");
+  EKAT_REQUIRE_MSG(has_process(name), "Error! Process " + name + " requested from group " +
+                                          this->name() + " but is not constained in this group.\n");
 
   std::shared_ptr<atm_proc_type> return_process;
   for (auto &process : m_atm_processes) {
@@ -211,15 +214,16 @@ void AtmosphereProcessGroup::gather_internal_fields() {
     const auto &ifs = atm_proc->get_internal_fields();
     for (const auto &f : ifs) {
       const auto &name = f.get_header().get_identifier().name();
-      EKAT_REQUIRE_MSG(f2proc.find(name) == f2proc.end(), "Error! Two atm procs created the same internal field.\n"
-                                                          "  - field name: " +
-                                                              name +
-                                                              "\n"
-                                                              "  - first atm proc: " +
-                                                              f2proc.at(name) +
-                                                              "\n"
-                                                              "  - second atm proc: " +
-                                                              atm_proc->name() + "\n");
+      EKAT_REQUIRE_MSG(f2proc.find(name) == f2proc.end(),
+                       "Error! Two atm procs created the same internal field.\n"
+                       "  - field name: " +
+                           name +
+                           "\n"
+                           "  - first atm proc: " +
+                           f2proc.at(name) +
+                           "\n"
+                           "  - second atm proc: " +
+                           atm_proc->name() + "\n");
       add_internal_field(f);
       f2proc[name] = atm_proc->name();
     }
@@ -266,11 +270,12 @@ void AtmosphereProcessGroup::setup_column_conservation_checks(
       // Individual processes are the only ones that can define
       // this check as there is currenty no concept of boundary
       // fluxes over multiple processes implemented in the model.
-      EKAT_REQUIRE_MSG(not atm_proc_group->has_column_conservation_check(),
-                       "Error! The ATM process group \"" + atm_proc_group->name() +
-                           "\" attempted to enable "
-                           "conservation checks. Should have enable_column_conservation_checks=false for all "
-                           "process groups.\n");
+      EKAT_REQUIRE_MSG(
+          not atm_proc_group->has_column_conservation_check(),
+          "Error! The ATM process group \"" + atm_proc_group->name() +
+              "\" attempted to enable "
+              "conservation checks. Should have enable_column_conservation_checks=false for all "
+              "process groups.\n");
 
       atm_proc_group->setup_column_conservation_checks(conservation_check, fail_handling_type);
       continue;
@@ -292,37 +297,41 @@ void AtmosphereProcessGroup::setup_column_conservation_checks(
                          "This check is column local and therefore can only be run "
                          "on physics processes.\n");
 
-    // Query the computed fields for this atm process and see if either the mass or energy computation
-    // might be changed after the process has run. If no field used in the mass or energy calculate
-    // is updated by this process, there is no need to run the check.
+    // Query the computed fields for this atm process and see if either the mass or energy
+    // computation might be changed after the process has run. If no field used in the mass or
+    // energy calculate is updated by this process, there is no need to run the check.
     const std::string phys_grid_name  = conservation_check->get_grid()->name();
     const bool updates_static_energy  = atm_proc->has_computed_field("T_mid", phys_grid_name);
     const bool updates_kinetic_energy = atm_proc->has_computed_field("horiz_winds", phys_grid_name);
     const bool updates_water_vapor    = atm_proc->has_computed_field("qv", phys_grid_name);
-    const bool updates_water_liquid =
-        atm_proc->has_computed_field("qc", phys_grid_name) || atm_proc->has_computed_field("qr", phys_grid_name);
+    const bool updates_water_liquid   = atm_proc->has_computed_field("qc", phys_grid_name) ||
+                                      atm_proc->has_computed_field("qr", phys_grid_name);
     const bool updates_water_ice         = atm_proc->has_computed_field("qi", phys_grid_name);
-    const bool mass_or_energy_is_updated = updates_static_energy || updates_kinetic_energy || updates_water_vapor ||
-                                           updates_water_liquid || updates_water_ice;
-    EKAT_REQUIRE_MSG(mass_or_energy_is_updated, "Error! enable_column_conservation_checks=true for "
-                                                "process \"" +
-                                                    atm_proc->name() +
-                                                    "\" but mass or energy is "
-                                                    "not updated by the process. Set to false to avoid "
-                                                    "unnecessary computation.\n");
+    const bool mass_or_energy_is_updated = updates_static_energy || updates_kinetic_energy ||
+                                           updates_water_vapor || updates_water_liquid ||
+                                           updates_water_ice;
+    EKAT_REQUIRE_MSG(mass_or_energy_is_updated,
+                     "Error! enable_column_conservation_checks=true for "
+                     "process \"" +
+                         atm_proc->name() +
+                         "\" but mass or energy is "
+                         "not updated by the process. Set to false to avoid "
+                         "unnecessary computation.\n");
 
     // Require that, if a process adds the conservation check, it also defines all
     // the boundary fluxes needed to compute the mass and energy tendencies.
-    const bool has_all_boundary_fluxes = atm_proc->has_computed_field("vapor_flux", phys_grid_name) &&
-                                         atm_proc->has_computed_field("water_flux", phys_grid_name) &&
-                                         atm_proc->has_computed_field("ice_flux", phys_grid_name) &&
-                                         atm_proc->has_computed_field("heat_flux", phys_grid_name);
-    EKAT_REQUIRE_MSG(has_all_boundary_fluxes, "Error! Process \"" + atm_proc->name() +
-                                                  "\" enables the mass "
-                                                  "and energy conservation check, but does not define all "
-                                                  "the boundary fluxes required: vapor_flux, water_flux "
-                                                  "ice_flux, heat_flux. If a flux does not have a natural definition "
-                                                  "within the process, set to 0.\n");
+    const bool has_all_boundary_fluxes =
+        atm_proc->has_computed_field("vapor_flux", phys_grid_name) &&
+        atm_proc->has_computed_field("water_flux", phys_grid_name) &&
+        atm_proc->has_computed_field("ice_flux", phys_grid_name) &&
+        atm_proc->has_computed_field("heat_flux", phys_grid_name);
+    EKAT_REQUIRE_MSG(has_all_boundary_fluxes,
+                     "Error! Process \"" + atm_proc->name() +
+                         "\" enables the mass "
+                         "and energy conservation check, but does not define all "
+                         "the boundary fluxes required: vapor_flux, water_flux "
+                         "ice_flux, heat_flux. If a flux does not have a natural definition "
+                         "within the process, set to 0.\n");
 
     // If all conditions are satisfied, add as postcondition_check
     atm_proc->add_column_conservation_check(conservation_check, fail_handling_type);
@@ -337,7 +346,7 @@ void AtmosphereProcessGroup::add_postcondition_nan_checks() const {
     } else {
       for (const auto &f : proc->get_fields_out()) {
         const auto &grid_name = f.get_header().get_identifier().get_grid_name();
-        auto nan_check        = std::make_shared<FieldNaNCheck>(f, m_grids_mgr->get_grid(grid_name));
+        auto nan_check = std::make_shared<FieldNaNCheck>(f, m_grids_mgr->get_grid(grid_name));
         proc->add_postcondition_check(nan_check, CheckFailHandling::Fatal);
       }
 
@@ -352,7 +361,8 @@ void AtmosphereProcessGroup::add_postcondition_nan_checks() const {
   }
 }
 
-void AtmosphereProcessGroup::add_additional_data_fields_to_property_checks(const Field &data_field) {
+void AtmosphereProcessGroup::add_additional_data_fields_to_property_checks(
+    const Field &data_field) {
   for (auto proc : m_atm_processes) {
     auto group = std::dynamic_pointer_cast<AtmosphereProcessGroup>(proc);
     if (group) {
@@ -407,7 +417,8 @@ void AtmosphereProcessGroup::pre_process_tracer_requests() {
 
     if (turb_advect_req and non_turb_advect_req) {
       std::ostringstream ss;
-      ss << "Error! Incompatible tracer request. Turbulence advection requests not consistent among processes.\n"
+      ss << "Error! Incompatible tracer request. Turbulence advection requests not consistent "
+            "among processes.\n"
             "  - Tracer name: " +
                 fr.first +
                 "\n"
@@ -416,7 +427,8 @@ void AtmosphereProcessGroup::pre_process_tracer_requests() {
         const auto turb_advect     = ekat::contains(req.groups, "turbulence_advected_tracers");
         const auto non_turb_advect = ekat::contains(req.groups, "non_turbulence_advected_tracers");
         std::string turb_advect_info =
-            (turb_advect ? "DynamicsAndTurbulence" : (non_turb_advect ? "DynamicsOnly" : "NoPreference"));
+            (turb_advect ? "DynamicsAndTurbulence"
+                         : (non_turb_advect ? "DynamicsOnly" : "NoPreference"));
         const auto grid_name = req.fid.get_grid_name();
         ss << "    - (" + req.calling_process + ", " + grid_name + ", " + turb_advect_info + ")\n";
       }
@@ -453,8 +465,8 @@ void AtmosphereProcessGroup::initialize_impl(const RunType run_type) {
     long long my_mem_usage = get_mem_usage(MB);
     long long max_mem_usage;
     m_comm.all_reduce(&my_mem_usage, &max_mem_usage, 1, MPI_MAX);
-    m_atm_logger->debug("[EAMxx::initialize::" + atm_proc->name() + "] memory usage: " + std::to_string(max_mem_usage) +
-                        "MB");
+    m_atm_logger->debug("[EAMxx::initialize::" + atm_proc->name() +
+                        "] memory usage: " + std::to_string(max_mem_usage) + "MB");
 #endif
   }
 }
@@ -497,8 +509,8 @@ void AtmosphereProcessGroup::finalize_impl(/* what inputs? */) {
     long long my_mem_usage = get_mem_usage(MB);
     long long max_mem_usage;
     m_comm.all_reduce(&my_mem_usage, &max_mem_usage, 1, MPI_MAX);
-    m_atm_logger->debug("[EAMxx::finalize::" + atm_proc->name() + "] memory usage: " + std::to_string(max_mem_usage) +
-                        "MB");
+    m_atm_logger->debug("[EAMxx::finalize::" + atm_proc->name() +
+                        "] memory usage: " + std::to_string(max_mem_usage) + "MB");
 #endif
   }
 }
diff --git i/components/eamxx/src/share/atm_process/atmosphere_process_group.hpp w/components/eamxx/src/share/atm_process/atmosphere_process_group.hpp
index b1b46ed771..7f36db3087 100644
--- i/components/eamxx/src/share/atm_process/atmosphere_process_group.hpp
+++ w/components/eamxx/src/share/atm_process/atmosphere_process_group.hpp
@@ -49,9 +49,13 @@ public:
   // --- Methods specific to AtmosphereProcessGroup --- //
   int get_num_processes() const { return m_atm_processes.size(); }
 
-  std::shared_ptr<const atm_proc_type> get_process(const int i) const { return m_atm_processes.at(i); }
+  std::shared_ptr<const atm_proc_type> get_process(const int i) const {
+    return m_atm_processes.at(i);
+  }
 
-  std::shared_ptr<atm_proc_type> get_process_nonconst(const int i) const { return m_atm_processes.at(i); }
+  std::shared_ptr<atm_proc_type> get_process_nonconst(const int i) const {
+    return m_atm_processes.at(i);
+  }
 
   // Returns atmosphere process if contained in this group, error out if not
   std::shared_ptr<atm_proc_type> get_process_nonconst(const std::string &name) const;
@@ -87,8 +91,9 @@ public:
 
   // Adds the mass and energy conservation
   // checks to appropriate physics processes.
-  void setup_column_conservation_checks(const std::shared_ptr<MassAndEnergyColumnConservationCheck> &conservation_check,
-                                        const CheckFailHandling fail_handling_type) const;
+  void setup_column_conservation_checks(
+      const std::shared_ptr<MassAndEnergyColumnConservationCheck> &conservation_check,
+      const CheckFailHandling fail_handling_type) const;
 
   // Add nan checks after each non-group process, for each computed field.
   // If checks fail, we print all input and output fields of that process
diff --git i/components/eamxx/src/share/atm_process/atmosphere_process_hash.cpp w/components/eamxx/src/share/atm_process/atmosphere_process_hash.cpp
index a0180cadff..70b8614208 100644
--- i/components/eamxx/src/share/atm_process/atmosphere_process_hash.cpp
+++ w/components/eamxx/src/share/atm_process/atmosphere_process_hash.cpp
@@ -17,7 +17,8 @@ void hash(const Field::view_dev_t<const Real *> &v, const FieldLayout &lo, HashT
   HashType accum = 0;
   Kokkos::parallel_reduce(
       Kokkos::RangePolicy<ExeSpace>(0, lo.size()),
-      KOKKOS_LAMBDA(const int idx, HashType &accum) { bfbhash::hash(v(idx), accum); }, bfbhash::HashReducer<>(accum));
+      KOKKOS_LAMBDA(const int idx, HashType &accum) { bfbhash::hash(v(idx), accum); },
+      bfbhash::HashReducer<>(accum));
   Kokkos::fence();
   bfbhash::hash(accum, accum_out);
 }
@@ -67,7 +68,8 @@ void hash(const Field::view_dev_t<const Real ****> &v, const FieldLayout &lo, Ha
   bfbhash::hash(accum, accum_out);
 }
 
-void hash(const Field::view_dev_t<const Real *****> &v, const FieldLayout &lo, HashType &accum_out) {
+void hash(const Field::view_dev_t<const Real *****> &v, const FieldLayout &lo,
+          HashType &accum_out) {
   HashType accum   = 0;
   const auto &dims = lo.extents();
   Kokkos::parallel_reduce(
@@ -121,9 +123,9 @@ void hash(const std::list<FieldGroup> &fgs, HashType &accum) {
 
 } // namespace
 
-void AtmosphereProcess ::print_global_state_hash(const std::string &label, const TimeStamp &t, const bool in,
-                                                 const bool out, const bool internal, const Real *mem,
-                                                 const int nmem) const {
+void AtmosphereProcess ::print_global_state_hash(const std::string &label, const TimeStamp &t,
+                                                 const bool in, const bool out, const bool internal,
+                                                 const Real *mem, const int nmem) const {
   const bool compute[4] = {in, out, internal, mem != nullptr};
 
   std::vector<std::string> hash_names;
@@ -229,21 +231,22 @@ void AtmosphereProcess ::print_global_state_hash(const std::string &label, const
        << std::setw(2) << std::setfill('0') << date[1] << "-"                        // Month
        << std::setw(2) << std::setfill('0') << date[2] << "-"                        // Day
        << std::setw(5) << std::setfill('0') << tod << " "                            // Time of day
-       << "(" << label << "), naccum=" << naccum;                                    // Label and number of accum
+       << "(" << label << "), naccum=" << naccum; // Label and number of accum
     log(ss.str());
 
     for (int i = 0; i < naccum; ++i) {
       ss.str(""); // Clear content
       ss.clear(); // Clear error flags
-      ss << std::setw(slen) << std::setfill(' ') << hash_names[i] << ": " << std::hex << std::setfill('0')
-         << std::setw(16) << gaccum[i];
+      ss << std::setw(slen) << std::setfill(' ') << hash_names[i] << ": " << std::hex
+         << std::setfill('0') << std::setw(16) << gaccum[i];
       log(ss.str());
     }
     m_atm_logger->flush();
   }
 }
 
-void AtmosphereProcess::print_fast_global_state_hash(const std::string &label, const TimeStamp &t) const {
+void AtmosphereProcess::print_fast_global_state_hash(const std::string &label,
+                                                     const TimeStamp &t) const {
   HashType laccum = 0;
   hash(m_fields_in, laccum);
   HashType gaccum;
diff --git i/components/eamxx/src/share/atm_process/atmosphere_process_utils.hpp w/components/eamxx/src/share/atm_process/atmosphere_process_utils.hpp
index 68ad911ff9..a4f0747df6 100644
--- i/components/eamxx/src/share/atm_process/atmosphere_process_utils.hpp
+++ w/components/eamxx/src/share/atm_process/atmosphere_process_utils.hpp
@@ -14,8 +14,8 @@ enum class AtmosphereProcessType {
   Physics,                 // Process handling a physics parametrization
   SurfaceCouplingImporter, // Process handling the transfers from surface models to atm
   SurfaceCouplingExporter, // Process handling the transfers from atm to surface models
-  Group,                   // Process that groups a bunch of processes (so they look as a single process)
-  Diagnostic               // Process that handles a diagnostic output
+  Group,     // Process that groups a bunch of processes (so they look as a single process)
+  Diagnostic // Process that handles a diagnostic output
 };
 
 inline std::string e2str(const AtmosphereProcessType ap_type) {
diff --git i/components/eamxx/src/share/eamxx_config.cpp w/components/eamxx/src/share/eamxx_config.cpp
index 53803e99ae..be8ba8bd64 100644
--- i/components/eamxx/src/share/eamxx_config.cpp
+++ w/components/eamxx/src/share/eamxx_config.cpp
@@ -13,9 +13,10 @@ std::string eamxx_config_string() {
   config += "\n-------- SCREAM CONFIGS --------\n\n";
   config += " sizeof(Real) = " + std::to_string(sizeof(Real)) + "\n";
   config += " default pack size = " + std::to_string(SCREAM_PACK_SIZE) + "\n";
-  config += " default FPE mask: " + (get_default_fpes() == 0 ? "0 (NONE) \n"
-                                                             : std::to_string(get_default_fpes()) +
-                                                                   " (FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW) \n");
+  config += " default FPE mask: " + (get_default_fpes() == 0
+                                         ? "0 (NONE) \n"
+                                         : std::to_string(get_default_fpes()) +
+                                               " (FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW) \n");
   config += "-------------------------------\n";
 
   return config;
diff --git i/components/eamxx/src/share/eamxx_types.hpp w/components/eamxx/src/share/eamxx_types.hpp
index 3ed53fab1b..b2dac4548e 100644
--- i/components/eamxx/src/share/eamxx_types.hpp
+++ w/components/eamxx/src/share/eamxx_types.hpp
@@ -55,7 +55,8 @@ static constexpr bool SCREAM_BFB_TESTING = true;
  * to ensure that literals are not a source of round-off differences.
  */
 template <typename T>
-KOKKOS_INLINE_FUNCTION constexpr typename std::enable_if<std::is_arithmetic<T>::value, Real>::type sp(const T val) {
+KOKKOS_INLINE_FUNCTION constexpr typename std::enable_if<std::is_arithmetic<T>::value, Real>::type
+sp(const T val) {
   return Real(val);
 }
 
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_double_device.cpp w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_double_device.cpp
index 4164749e55..d0067e38f1 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_double_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_double_device.cpp
@@ -2,17 +2,27 @@
 
 namespace scream {
 
-template Field::get_strided_view_type<double, Device> Field::get_strided_view<double, Device>() const;
-template Field::get_strided_view_type<double *, Device> Field::get_strided_view<double *, Device>() const;
-template Field::get_strided_view_type<double **, Device> Field::get_strided_view<double **, Device>() const;
-template Field::get_strided_view_type<double ***, Device> Field::get_strided_view<double ***, Device>() const;
-template Field::get_strided_view_type<double ****, Device> Field::get_strided_view<double ****, Device>() const;
-template Field::get_strided_view_type<double *****, Device> Field::get_strided_view<double *****, Device>() const;
-template Field::get_strided_view_type<double ******, Device> Field::get_strided_view<double ******, Device>() const;
+template Field::get_strided_view_type<double, Device>
+Field::get_strided_view<double, Device>() const;
+template Field::get_strided_view_type<double *, Device>
+Field::get_strided_view<double *, Device>() const;
+template Field::get_strided_view_type<double **, Device>
+Field::get_strided_view<double **, Device>() const;
+template Field::get_strided_view_type<double ***, Device>
+Field::get_strided_view<double ***, Device>() const;
+template Field::get_strided_view_type<double ****, Device>
+Field::get_strided_view<double ****, Device>() const;
+template Field::get_strided_view_type<double *****, Device>
+Field::get_strided_view<double *****, Device>() const;
+template Field::get_strided_view_type<double ******, Device>
+Field::get_strided_view<double ******, Device>() const;
 
-template Field::get_strided_view_type<const double, Device> Field::get_strided_view<const double, Device>() const;
-template Field::get_strided_view_type<const double *, Device> Field::get_strided_view<const double *, Device>() const;
-template Field::get_strided_view_type<const double **, Device> Field::get_strided_view<const double **, Device>() const;
+template Field::get_strided_view_type<const double, Device>
+Field::get_strided_view<const double, Device>() const;
+template Field::get_strided_view_type<const double *, Device>
+Field::get_strided_view<const double *, Device>() const;
+template Field::get_strided_view_type<const double **, Device>
+Field::get_strided_view<const double **, Device>() const;
 template Field::get_strided_view_type<const double ***, Device>
 Field::get_strided_view<const double ***, Device>() const;
 template Field::get_strided_view_type<const double ****, Device>
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_double_host.cpp w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_double_host.cpp
index 5e97254d98..e4cb0b2197 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_double_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_double_host.cpp
@@ -3,18 +3,29 @@
 namespace scream {
 
 template Field::get_strided_view_type<double, Host> Field::get_strided_view<double, Host>() const;
-template Field::get_strided_view_type<double *, Host> Field::get_strided_view<double *, Host>() const;
-template Field::get_strided_view_type<double **, Host> Field::get_strided_view<double **, Host>() const;
-template Field::get_strided_view_type<double ***, Host> Field::get_strided_view<double ***, Host>() const;
-template Field::get_strided_view_type<double ****, Host> Field::get_strided_view<double ****, Host>() const;
-template Field::get_strided_view_type<double *****, Host> Field::get_strided_view<double *****, Host>() const;
-template Field::get_strided_view_type<double ******, Host> Field::get_strided_view<double ******, Host>() const;
+template Field::get_strided_view_type<double *, Host>
+Field::get_strided_view<double *, Host>() const;
+template Field::get_strided_view_type<double **, Host>
+Field::get_strided_view<double **, Host>() const;
+template Field::get_strided_view_type<double ***, Host>
+Field::get_strided_view<double ***, Host>() const;
+template Field::get_strided_view_type<double ****, Host>
+Field::get_strided_view<double ****, Host>() const;
+template Field::get_strided_view_type<double *****, Host>
+Field::get_strided_view<double *****, Host>() const;
+template Field::get_strided_view_type<double ******, Host>
+Field::get_strided_view<double ******, Host>() const;
 
-template Field::get_strided_view_type<const double, Host> Field::get_strided_view<const double, Host>() const;
-template Field::get_strided_view_type<const double *, Host> Field::get_strided_view<const double *, Host>() const;
-template Field::get_strided_view_type<const double **, Host> Field::get_strided_view<const double **, Host>() const;
-template Field::get_strided_view_type<const double ***, Host> Field::get_strided_view<const double ***, Host>() const;
-template Field::get_strided_view_type<const double ****, Host> Field::get_strided_view<const double ****, Host>() const;
+template Field::get_strided_view_type<const double, Host>
+Field::get_strided_view<const double, Host>() const;
+template Field::get_strided_view_type<const double *, Host>
+Field::get_strided_view<const double *, Host>() const;
+template Field::get_strided_view_type<const double **, Host>
+Field::get_strided_view<const double **, Host>() const;
+template Field::get_strided_view_type<const double ***, Host>
+Field::get_strided_view<const double ***, Host>() const;
+template Field::get_strided_view_type<const double ****, Host>
+Field::get_strided_view<const double ****, Host>() const;
 template Field::get_strided_view_type<const double *****, Host>
 Field::get_strided_view<const double *****, Host>() const;
 template Field::get_strided_view_type<const double ******, Host>
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_float_device.cpp w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_float_device.cpp
index 26ee67c374..ad3f46a95c 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_float_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_float_device.cpp
@@ -3,17 +3,27 @@
 namespace scream {
 
 template Field::get_strided_view_type<float, Device> Field::get_strided_view<float, Device>() const;
-template Field::get_strided_view_type<float *, Device> Field::get_strided_view<float *, Device>() const;
-template Field::get_strided_view_type<float **, Device> Field::get_strided_view<float **, Device>() const;
-template Field::get_strided_view_type<float ***, Device> Field::get_strided_view<float ***, Device>() const;
-template Field::get_strided_view_type<float ****, Device> Field::get_strided_view<float ****, Device>() const;
-template Field::get_strided_view_type<float *****, Device> Field::get_strided_view<float *****, Device>() const;
-template Field::get_strided_view_type<float ******, Device> Field::get_strided_view<float ******, Device>() const;
+template Field::get_strided_view_type<float *, Device>
+Field::get_strided_view<float *, Device>() const;
+template Field::get_strided_view_type<float **, Device>
+Field::get_strided_view<float **, Device>() const;
+template Field::get_strided_view_type<float ***, Device>
+Field::get_strided_view<float ***, Device>() const;
+template Field::get_strided_view_type<float ****, Device>
+Field::get_strided_view<float ****, Device>() const;
+template Field::get_strided_view_type<float *****, Device>
+Field::get_strided_view<float *****, Device>() const;
+template Field::get_strided_view_type<float ******, Device>
+Field::get_strided_view<float ******, Device>() const;
 
-template Field::get_strided_view_type<const float, Device> Field::get_strided_view<const float, Device>() const;
-template Field::get_strided_view_type<const float *, Device> Field::get_strided_view<const float *, Device>() const;
-template Field::get_strided_view_type<const float **, Device> Field::get_strided_view<const float **, Device>() const;
-template Field::get_strided_view_type<const float ***, Device> Field::get_strided_view<const float ***, Device>() const;
+template Field::get_strided_view_type<const float, Device>
+Field::get_strided_view<const float, Device>() const;
+template Field::get_strided_view_type<const float *, Device>
+Field::get_strided_view<const float *, Device>() const;
+template Field::get_strided_view_type<const float **, Device>
+Field::get_strided_view<const float **, Device>() const;
+template Field::get_strided_view_type<const float ***, Device>
+Field::get_strided_view<const float ***, Device>() const;
 template Field::get_strided_view_type<const float ****, Device>
 Field::get_strided_view<const float ****, Device>() const;
 template Field::get_strided_view_type<const float *****, Device>
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_float_host.cpp w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_float_host.cpp
index 06f918db56..14e4efb5ff 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_float_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_float_host.cpp
@@ -4,18 +4,29 @@ namespace scream {
 
 template Field::get_strided_view_type<float, Host> Field::get_strided_view<float, Host>() const;
 template Field::get_strided_view_type<float *, Host> Field::get_strided_view<float *, Host>() const;
-template Field::get_strided_view_type<float **, Host> Field::get_strided_view<float **, Host>() const;
-template Field::get_strided_view_type<float ***, Host> Field::get_strided_view<float ***, Host>() const;
-template Field::get_strided_view_type<float ****, Host> Field::get_strided_view<float ****, Host>() const;
-template Field::get_strided_view_type<float *****, Host> Field::get_strided_view<float *****, Host>() const;
-template Field::get_strided_view_type<float ******, Host> Field::get_strided_view<float ******, Host>() const;
+template Field::get_strided_view_type<float **, Host>
+Field::get_strided_view<float **, Host>() const;
+template Field::get_strided_view_type<float ***, Host>
+Field::get_strided_view<float ***, Host>() const;
+template Field::get_strided_view_type<float ****, Host>
+Field::get_strided_view<float ****, Host>() const;
+template Field::get_strided_view_type<float *****, Host>
+Field::get_strided_view<float *****, Host>() const;
+template Field::get_strided_view_type<float ******, Host>
+Field::get_strided_view<float ******, Host>() const;
 
-template Field::get_strided_view_type<const float, Host> Field::get_strided_view<const float, Host>() const;
-template Field::get_strided_view_type<const float *, Host> Field::get_strided_view<const float *, Host>() const;
-template Field::get_strided_view_type<const float **, Host> Field::get_strided_view<const float **, Host>() const;
-template Field::get_strided_view_type<const float ***, Host> Field::get_strided_view<const float ***, Host>() const;
-template Field::get_strided_view_type<const float ****, Host> Field::get_strided_view<const float ****, Host>() const;
-template Field::get_strided_view_type<const float *****, Host> Field::get_strided_view<const float *****, Host>() const;
+template Field::get_strided_view_type<const float, Host>
+Field::get_strided_view<const float, Host>() const;
+template Field::get_strided_view_type<const float *, Host>
+Field::get_strided_view<const float *, Host>() const;
+template Field::get_strided_view_type<const float **, Host>
+Field::get_strided_view<const float **, Host>() const;
+template Field::get_strided_view_type<const float ***, Host>
+Field::get_strided_view<const float ***, Host>() const;
+template Field::get_strided_view_type<const float ****, Host>
+Field::get_strided_view<const float ****, Host>() const;
+template Field::get_strided_view_type<const float *****, Host>
+Field::get_strided_view<const float *****, Host>() const;
 template Field::get_strided_view_type<const float ******, Host>
 Field::get_strided_view<const float ******, Host>() const;
 
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_int_device.cpp w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_int_device.cpp
index 4ff144c90a..d5b1fcb621 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_int_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_int_device.cpp
@@ -4,18 +4,29 @@ namespace scream {
 
 template Field::get_strided_view_type<int, Device> Field::get_strided_view<int, Device>() const;
 template Field::get_strided_view_type<int *, Device> Field::get_strided_view<int *, Device>() const;
-template Field::get_strided_view_type<int **, Device> Field::get_strided_view<int **, Device>() const;
-template Field::get_strided_view_type<int ***, Device> Field::get_strided_view<int ***, Device>() const;
-template Field::get_strided_view_type<int ****, Device> Field::get_strided_view<int ****, Device>() const;
-template Field::get_strided_view_type<int *****, Device> Field::get_strided_view<int *****, Device>() const;
-template Field::get_strided_view_type<int ******, Device> Field::get_strided_view<int ******, Device>() const;
+template Field::get_strided_view_type<int **, Device>
+Field::get_strided_view<int **, Device>() const;
+template Field::get_strided_view_type<int ***, Device>
+Field::get_strided_view<int ***, Device>() const;
+template Field::get_strided_view_type<int ****, Device>
+Field::get_strided_view<int ****, Device>() const;
+template Field::get_strided_view_type<int *****, Device>
+Field::get_strided_view<int *****, Device>() const;
+template Field::get_strided_view_type<int ******, Device>
+Field::get_strided_view<int ******, Device>() const;
 
-template Field::get_strided_view_type<const int, Device> Field::get_strided_view<const int, Device>() const;
-template Field::get_strided_view_type<const int *, Device> Field::get_strided_view<const int *, Device>() const;
-template Field::get_strided_view_type<const int **, Device> Field::get_strided_view<const int **, Device>() const;
-template Field::get_strided_view_type<const int ***, Device> Field::get_strided_view<const int ***, Device>() const;
-template Field::get_strided_view_type<const int ****, Device> Field::get_strided_view<const int ****, Device>() const;
-template Field::get_strided_view_type<const int *****, Device> Field::get_strided_view<const int *****, Device>() const;
+template Field::get_strided_view_type<const int, Device>
+Field::get_strided_view<const int, Device>() const;
+template Field::get_strided_view_type<const int *, Device>
+Field::get_strided_view<const int *, Device>() const;
+template Field::get_strided_view_type<const int **, Device>
+Field::get_strided_view<const int **, Device>() const;
+template Field::get_strided_view_type<const int ***, Device>
+Field::get_strided_view<const int ***, Device>() const;
+template Field::get_strided_view_type<const int ****, Device>
+Field::get_strided_view<const int ****, Device>() const;
+template Field::get_strided_view_type<const int *****, Device>
+Field::get_strided_view<const int *****, Device>() const;
 template Field::get_strided_view_type<const int ******, Device>
 Field::get_strided_view<const int ******, Device>() const;
 
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_int_host.cpp w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_int_host.cpp
index ffe2703375..b30e8b9096 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_strided_view_int_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_strided_view_int_host.cpp
@@ -6,16 +6,26 @@ template Field::get_strided_view_type<int, Host> Field::get_strided_view<int, Ho
 template Field::get_strided_view_type<int *, Host> Field::get_strided_view<int *, Host>() const;
 template Field::get_strided_view_type<int **, Host> Field::get_strided_view<int **, Host>() const;
 template Field::get_strided_view_type<int ***, Host> Field::get_strided_view<int ***, Host>() const;
-template Field::get_strided_view_type<int ****, Host> Field::get_strided_view<int ****, Host>() const;
-template Field::get_strided_view_type<int *****, Host> Field::get_strided_view<int *****, Host>() const;
-template Field::get_strided_view_type<int ******, Host> Field::get_strided_view<int ******, Host>() const;
+template Field::get_strided_view_type<int ****, Host>
+Field::get_strided_view<int ****, Host>() const;
+template Field::get_strided_view_type<int *****, Host>
+Field::get_strided_view<int *****, Host>() const;
+template Field::get_strided_view_type<int ******, Host>
+Field::get_strided_view<int ******, Host>() const;
 
-template Field::get_strided_view_type<const int, Host> Field::get_strided_view<const int, Host>() const;
-template Field::get_strided_view_type<const int *, Host> Field::get_strided_view<const int *, Host>() const;
-template Field::get_strided_view_type<const int **, Host> Field::get_strided_view<const int **, Host>() const;
-template Field::get_strided_view_type<const int ***, Host> Field::get_strided_view<const int ***, Host>() const;
-template Field::get_strided_view_type<const int ****, Host> Field::get_strided_view<const int ****, Host>() const;
-template Field::get_strided_view_type<const int *****, Host> Field::get_strided_view<const int *****, Host>() const;
-template Field::get_strided_view_type<const int ******, Host> Field::get_strided_view<const int ******, Host>() const;
+template Field::get_strided_view_type<const int, Host>
+Field::get_strided_view<const int, Host>() const;
+template Field::get_strided_view_type<const int *, Host>
+Field::get_strided_view<const int *, Host>() const;
+template Field::get_strided_view_type<const int **, Host>
+Field::get_strided_view<const int **, Host>() const;
+template Field::get_strided_view_type<const int ***, Host>
+Field::get_strided_view<const int ***, Host>() const;
+template Field::get_strided_view_type<const int ****, Host>
+Field::get_strided_view<const int ****, Host>() const;
+template Field::get_strided_view_type<const int *****, Host>
+Field::get_strided_view<const int *****, Host>() const;
+template Field::get_strided_view_type<const int ******, Host>
+Field::get_strided_view<const int ******, Host>() const;
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_view_double_device.cpp w/components/eamxx/src/share/field/eti/field_eti_get_view_double_device.cpp
index eeb7785ef0..e5c478f022 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_view_double_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_view_double_device.cpp
@@ -11,11 +11,17 @@ template Field::get_view_type<double *****, Device> Field::get_view<double *****
 template Field::get_view_type<double ******, Device> Field::get_view<double ******, Device>() const;
 
 template Field::get_view_type<const double, Device> Field::get_view<const double, Device>() const;
-template Field::get_view_type<const double *, Device> Field::get_view<const double *, Device>() const;
-template Field::get_view_type<const double **, Device> Field::get_view<const double **, Device>() const;
-template Field::get_view_type<const double ***, Device> Field::get_view<const double ***, Device>() const;
-template Field::get_view_type<const double ****, Device> Field::get_view<const double ****, Device>() const;
-template Field::get_view_type<const double *****, Device> Field::get_view<const double *****, Device>() const;
-template Field::get_view_type<const double ******, Device> Field::get_view<const double ******, Device>() const;
+template Field::get_view_type<const double *, Device>
+Field::get_view<const double *, Device>() const;
+template Field::get_view_type<const double **, Device>
+Field::get_view<const double **, Device>() const;
+template Field::get_view_type<const double ***, Device>
+Field::get_view<const double ***, Device>() const;
+template Field::get_view_type<const double ****, Device>
+Field::get_view<const double ****, Device>() const;
+template Field::get_view_type<const double *****, Device>
+Field::get_view<const double *****, Device>() const;
+template Field::get_view_type<const double ******, Device>
+Field::get_view<const double ******, Device>() const;
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_view_double_host.cpp w/components/eamxx/src/share/field/eti/field_eti_get_view_double_host.cpp
index 2f6d6f892a..5ca179ab9a 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_view_double_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_view_double_host.cpp
@@ -13,9 +13,13 @@ template Field::get_view_type<double ******, Host> Field::get_view<double ******
 template Field::get_view_type<const double, Host> Field::get_view<const double, Host>() const;
 template Field::get_view_type<const double *, Host> Field::get_view<const double *, Host>() const;
 template Field::get_view_type<const double **, Host> Field::get_view<const double **, Host>() const;
-template Field::get_view_type<const double ***, Host> Field::get_view<const double ***, Host>() const;
-template Field::get_view_type<const double ****, Host> Field::get_view<const double ****, Host>() const;
-template Field::get_view_type<const double *****, Host> Field::get_view<const double *****, Host>() const;
-template Field::get_view_type<const double ******, Host> Field::get_view<const double ******, Host>() const;
+template Field::get_view_type<const double ***, Host>
+Field::get_view<const double ***, Host>() const;
+template Field::get_view_type<const double ****, Host>
+Field::get_view<const double ****, Host>() const;
+template Field::get_view_type<const double *****, Host>
+Field::get_view<const double *****, Host>() const;
+template Field::get_view_type<const double ******, Host>
+Field::get_view<const double ******, Host>() const;
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_view_float_device.cpp w/components/eamxx/src/share/field/eti/field_eti_get_view_float_device.cpp
index eb3cdb9e1d..5a044a210a 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_view_float_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_view_float_device.cpp
@@ -12,10 +12,15 @@ template Field::get_view_type<float ******, Device> Field::get_view<float ******
 
 template Field::get_view_type<const float, Device> Field::get_view<const float, Device>() const;
 template Field::get_view_type<const float *, Device> Field::get_view<const float *, Device>() const;
-template Field::get_view_type<const float **, Device> Field::get_view<const float **, Device>() const;
-template Field::get_view_type<const float ***, Device> Field::get_view<const float ***, Device>() const;
-template Field::get_view_type<const float ****, Device> Field::get_view<const float ****, Device>() const;
-template Field::get_view_type<const float *****, Device> Field::get_view<const float *****, Device>() const;
-template Field::get_view_type<const float ******, Device> Field::get_view<const float ******, Device>() const;
+template Field::get_view_type<const float **, Device>
+Field::get_view<const float **, Device>() const;
+template Field::get_view_type<const float ***, Device>
+Field::get_view<const float ***, Device>() const;
+template Field::get_view_type<const float ****, Device>
+Field::get_view<const float ****, Device>() const;
+template Field::get_view_type<const float *****, Device>
+Field::get_view<const float *****, Device>() const;
+template Field::get_view_type<const float ******, Device>
+Field::get_view<const float ******, Device>() const;
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_view_float_host.cpp w/components/eamxx/src/share/field/eti/field_eti_get_view_float_host.cpp
index 6d07b8787b..0eb758dd30 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_view_float_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_view_float_host.cpp
@@ -14,8 +14,11 @@ template Field::get_view_type<const float, Host> Field::get_view<const float, Ho
 template Field::get_view_type<const float *, Host> Field::get_view<const float *, Host>() const;
 template Field::get_view_type<const float **, Host> Field::get_view<const float **, Host>() const;
 template Field::get_view_type<const float ***, Host> Field::get_view<const float ***, Host>() const;
-template Field::get_view_type<const float ****, Host> Field::get_view<const float ****, Host>() const;
-template Field::get_view_type<const float *****, Host> Field::get_view<const float *****, Host>() const;
-template Field::get_view_type<const float ******, Host> Field::get_view<const float ******, Host>() const;
+template Field::get_view_type<const float ****, Host>
+Field::get_view<const float ****, Host>() const;
+template Field::get_view_type<const float *****, Host>
+Field::get_view<const float *****, Host>() const;
+template Field::get_view_type<const float ******, Host>
+Field::get_view<const float ******, Host>() const;
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_view_int_device.cpp w/components/eamxx/src/share/field/eti/field_eti_get_view_int_device.cpp
index 019c0593d1..b6ca06479e 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_view_int_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_view_int_device.cpp
@@ -14,8 +14,11 @@ template Field::get_view_type<const int, Device> Field::get_view<const int, Devi
 template Field::get_view_type<const int *, Device> Field::get_view<const int *, Device>() const;
 template Field::get_view_type<const int **, Device> Field::get_view<const int **, Device>() const;
 template Field::get_view_type<const int ***, Device> Field::get_view<const int ***, Device>() const;
-template Field::get_view_type<const int ****, Device> Field::get_view<const int ****, Device>() const;
-template Field::get_view_type<const int *****, Device> Field::get_view<const int *****, Device>() const;
-template Field::get_view_type<const int ******, Device> Field::get_view<const int ******, Device>() const;
+template Field::get_view_type<const int ****, Device>
+Field::get_view<const int ****, Device>() const;
+template Field::get_view_type<const int *****, Device>
+Field::get_view<const int *****, Device>() const;
+template Field::get_view_type<const int ******, Device>
+Field::get_view<const int ******, Device>() const;
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_get_view_int_host.cpp w/components/eamxx/src/share/field/eti/field_eti_get_view_int_host.cpp
index 2ff34ae7b4..292621d231 100644
--- i/components/eamxx/src/share/field/eti/field_eti_get_view_int_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_get_view_int_host.cpp
@@ -16,6 +16,7 @@ template Field::get_view_type<const int **, Host> Field::get_view<const int **,
 template Field::get_view_type<const int ***, Host> Field::get_view<const int ***, Host>() const;
 template Field::get_view_type<const int ****, Host> Field::get_view<const int ****, Host>() const;
 template Field::get_view_type<const int *****, Host> Field::get_view<const int *****, Host>() const;
-template Field::get_view_type<const int ******, Host> Field::get_view<const int ******, Host>() const;
+template Field::get_view_type<const int ******, Host>
+Field::get_view<const int ******, Host>() const;
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_double_device.cpp w/components/eamxx/src/share/field/eti/field_eti_update_double_device.cpp
index 292487f3dd..bf45ed97fe 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_double_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_double_device.cpp
@@ -2,8 +2,11 @@
 
 namespace scream {
 
-template void Field::update<CombineMode::Update, Device, double>(const Field &, const double, const double);
-template void Field::update<CombineMode::Multiply, Device, double>(const Field &, const double, const double);
-template void Field::update<CombineMode::Divide, Device, double>(const Field &, const double, const double);
+template void Field::update<CombineMode::Update, Device, double>(const Field &, const double,
+                                                                 const double);
+template void Field::update<CombineMode::Multiply, Device, double>(const Field &, const double,
+                                                                   const double);
+template void Field::update<CombineMode::Divide, Device, double>(const Field &, const double,
+                                                                 const double);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_double_host.cpp w/components/eamxx/src/share/field/eti/field_eti_update_double_host.cpp
index 2eed0d117e..2cc860c64f 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_double_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_double_host.cpp
@@ -2,8 +2,11 @@
 
 namespace scream {
 
-template void Field::update<CombineMode::Update, Host, double>(const Field &, const double, const double);
-template void Field::update<CombineMode::Multiply, Host, double>(const Field &, const double, const double);
-template void Field::update<CombineMode::Divide, Host, double>(const Field &, const double, const double);
+template void Field::update<CombineMode::Update, Host, double>(const Field &, const double,
+                                                               const double);
+template void Field::update<CombineMode::Multiply, Host, double>(const Field &, const double,
+                                                                 const double);
+template void Field::update<CombineMode::Divide, Host, double>(const Field &, const double,
+                                                               const double);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_float_device.cpp w/components/eamxx/src/share/field/eti/field_eti_update_float_device.cpp
index e946be4e76..aeb5dba731 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_float_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_float_device.cpp
@@ -2,8 +2,11 @@
 
 namespace scream {
 
-template void Field::update<CombineMode::Update, Device, float>(const Field &, const float, const float);
-template void Field::update<CombineMode::Multiply, Device, float>(const Field &, const float, const float);
-template void Field::update<CombineMode::Divide, Device, float>(const Field &, const float, const float);
+template void Field::update<CombineMode::Update, Device, float>(const Field &, const float,
+                                                                const float);
+template void Field::update<CombineMode::Multiply, Device, float>(const Field &, const float,
+                                                                  const float);
+template void Field::update<CombineMode::Divide, Device, float>(const Field &, const float,
+                                                                const float);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_float_host.cpp w/components/eamxx/src/share/field/eti/field_eti_update_float_host.cpp
index 7e6a4c1645..ee9769ea7d 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_float_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_float_host.cpp
@@ -2,8 +2,11 @@
 
 namespace scream {
 
-template void Field::update<CombineMode::Update, Host, float>(const Field &, const float, const float);
-template void Field::update<CombineMode::Multiply, Host, float>(const Field &, const float, const float);
-template void Field::update<CombineMode::Divide, Host, float>(const Field &, const float, const float);
+template void Field::update<CombineMode::Update, Host, float>(const Field &, const float,
+                                                              const float);
+template void Field::update<CombineMode::Multiply, Host, float>(const Field &, const float,
+                                                                const float);
+template void Field::update<CombineMode::Divide, Host, float>(const Field &, const float,
+                                                              const float);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_double_device.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_double_device.cpp
index d989c5b38b..58e87eac87 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_double_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_double_device.cpp
@@ -2,25 +2,33 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Device, false, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Device, false, double, double>(const Field &,
+                                                                                     const double,
                                                                                      const double);
-template void Field::update_impl<CombineMode::Multiply, Device, false, double, double>(const Field &, const double,
-                                                                                       const double);
-template void Field::update_impl<CombineMode::Divide, Device, false, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Device, false, double, double>(
+    const Field &, const double, const double);
+template void Field::update_impl<CombineMode::Divide, Device, false, double, double>(const Field &,
+                                                                                     const double,
                                                                                      const double);
 
-template void Field::update_impl<CombineMode::Update, Device, false, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Device, false, double, float>(const Field &,
+                                                                                    const double,
                                                                                     const double);
-template void Field::update_impl<CombineMode::Multiply, Device, false, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Device, false, double, float>(const Field &,
+                                                                                      const double,
                                                                                       const double);
-template void Field::update_impl<CombineMode::Divide, Device, false, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Device, false, double, float>(const Field &,
+                                                                                    const double,
                                                                                     const double);
 
-template void Field::update_impl<CombineMode::Update, Device, false, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Device, false, double, int>(const Field &,
+                                                                                  const double,
                                                                                   const double);
-template void Field::update_impl<CombineMode::Multiply, Device, false, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Device, false, double, int>(const Field &,
+                                                                                    const double,
                                                                                     const double);
-template void Field::update_impl<CombineMode::Divide, Device, false, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Device, false, double, int>(const Field &,
+                                                                                  const double,
                                                                                   const double);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_double_host.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_double_host.cpp
index 70bc3daf2c..d83b6a8f88 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_double_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_double_host.cpp
@@ -2,25 +2,34 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Host, false, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Host, false, double, double>(const Field &,
+                                                                                   const double,
                                                                                    const double);
-template void Field::update_impl<CombineMode::Multiply, Host, false, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Host, false, double, double>(const Field &,
+                                                                                     const double,
                                                                                      const double);
-template void Field::update_impl<CombineMode::Divide, Host, false, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Host, false, double, double>(const Field &,
+                                                                                   const double,
                                                                                    const double);
 
-template void Field::update_impl<CombineMode::Update, Host, false, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Host, false, double, float>(const Field &,
+                                                                                  const double,
                                                                                   const double);
-template void Field::update_impl<CombineMode::Multiply, Host, false, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Host, false, double, float>(const Field &,
+                                                                                    const double,
                                                                                     const double);
-template void Field::update_impl<CombineMode::Divide, Host, false, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Host, false, double, float>(const Field &,
+                                                                                  const double,
                                                                                   const double);
 
-template void Field::update_impl<CombineMode::Update, Host, false, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Host, false, double, int>(const Field &,
+                                                                                const double,
                                                                                 const double);
-template void Field::update_impl<CombineMode::Multiply, Host, false, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Host, false, double, int>(const Field &,
+                                                                                  const double,
                                                                                   const double);
-template void Field::update_impl<CombineMode::Divide, Host, false, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Host, false, double, int>(const Field &,
+                                                                                const double,
                                                                                 const double);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_double_device.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_double_device.cpp
index f622629240..24632f4e62 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_double_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_double_device.cpp
@@ -2,25 +2,34 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Device, true, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Device, true, double, double>(const Field &,
+                                                                                    const double,
                                                                                     const double);
-template void Field::update_impl<CombineMode::Multiply, Device, true, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Device, true, double, double>(const Field &,
+                                                                                      const double,
                                                                                       const double);
-template void Field::update_impl<CombineMode::Divide, Device, true, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Device, true, double, double>(const Field &,
+                                                                                    const double,
                                                                                     const double);
 
-template void Field::update_impl<CombineMode::Update, Device, true, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Device, true, double, float>(const Field &,
+                                                                                   const double,
                                                                                    const double);
-template void Field::update_impl<CombineMode::Multiply, Device, true, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Device, true, double, float>(const Field &,
+                                                                                     const double,
                                                                                      const double);
-template void Field::update_impl<CombineMode::Divide, Device, true, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Device, true, double, float>(const Field &,
+                                                                                   const double,
                                                                                    const double);
 
-template void Field::update_impl<CombineMode::Update, Device, true, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Device, true, double, int>(const Field &,
+                                                                                 const double,
                                                                                  const double);
-template void Field::update_impl<CombineMode::Multiply, Device, true, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Device, true, double, int>(const Field &,
+                                                                                   const double,
                                                                                    const double);
-template void Field::update_impl<CombineMode::Divide, Device, true, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Device, true, double, int>(const Field &,
+                                                                                 const double,
                                                                                  const double);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_double_host.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_double_host.cpp
index c5d96b6d09..814e4ee075 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_double_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_double_host.cpp
@@ -2,25 +2,34 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Host, true, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Host, true, double, double>(const Field &,
+                                                                                  const double,
                                                                                   const double);
-template void Field::update_impl<CombineMode::Multiply, Host, true, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Host, true, double, double>(const Field &,
+                                                                                    const double,
                                                                                     const double);
-template void Field::update_impl<CombineMode::Divide, Host, true, double, double>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Host, true, double, double>(const Field &,
+                                                                                  const double,
                                                                                   const double);
 
-template void Field::update_impl<CombineMode::Update, Host, true, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Host, true, double, float>(const Field &,
+                                                                                 const double,
                                                                                  const double);
-template void Field::update_impl<CombineMode::Multiply, Host, true, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Host, true, double, float>(const Field &,
+                                                                                   const double,
                                                                                    const double);
-template void Field::update_impl<CombineMode::Divide, Host, true, double, float>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Host, true, double, float>(const Field &,
+                                                                                 const double,
                                                                                  const double);
 
-template void Field::update_impl<CombineMode::Update, Host, true, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Update, Host, true, double, int>(const Field &,
+                                                                               const double,
                                                                                const double);
-template void Field::update_impl<CombineMode::Multiply, Host, true, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Multiply, Host, true, double, int>(const Field &,
+                                                                                 const double,
                                                                                  const double);
-template void Field::update_impl<CombineMode::Divide, Host, true, double, int>(const Field &, const double,
+template void Field::update_impl<CombineMode::Divide, Host, true, double, int>(const Field &,
+                                                                               const double,
                                                                                const double);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_float_device.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_float_device.cpp
index 823e80fc90..0915c23047 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_float_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_float_device.cpp
@@ -2,18 +2,24 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Device, true, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Update, Device, true, float, float>(const Field &,
+                                                                                  const float,
                                                                                   const float);
-template void Field::update_impl<CombineMode::Multiply, Device, true, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Multiply, Device, true, float, float>(const Field &,
+                                                                                    const float,
                                                                                     const float);
-template void Field::update_impl<CombineMode::Divide, Device, true, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Divide, Device, true, float, float>(const Field &,
+                                                                                  const float,
                                                                                   const float);
 
-template void Field::update_impl<CombineMode::Update, Device, true, float, int>(const Field &, const float,
+template void Field::update_impl<CombineMode::Update, Device, true, float, int>(const Field &,
+                                                                                const float,
                                                                                 const float);
-template void Field::update_impl<CombineMode::Multiply, Device, true, float, int>(const Field &, const float,
+template void Field::update_impl<CombineMode::Multiply, Device, true, float, int>(const Field &,
+                                                                                  const float,
                                                                                   const float);
-template void Field::update_impl<CombineMode::Divide, Device, true, float, int>(const Field &, const float,
+template void Field::update_impl<CombineMode::Divide, Device, true, float, int>(const Field &,
+                                                                                const float,
                                                                                 const float);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_float_host.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_float_host.cpp
index 786a76615b..4c391ed627 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_float_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_float_host.cpp
@@ -2,16 +2,24 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Host, true, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Update, Host, true, float, float>(const Field &,
+                                                                                const float,
                                                                                 const float);
-template void Field::update_impl<CombineMode::Multiply, Host, true, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Multiply, Host, true, float, float>(const Field &,
+                                                                                  const float,
                                                                                   const float);
-template void Field::update_impl<CombineMode::Divide, Host, true, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Divide, Host, true, float, float>(const Field &,
+                                                                                const float,
                                                                                 const float);
 
-template void Field::update_impl<CombineMode::Update, Host, true, float, int>(const Field &, const float, const float);
-template void Field::update_impl<CombineMode::Multiply, Host, true, float, int>(const Field &, const float,
+template void Field::update_impl<CombineMode::Update, Host, true, float, int>(const Field &,
+                                                                              const float,
+                                                                              const float);
+template void Field::update_impl<CombineMode::Multiply, Host, true, float, int>(const Field &,
+                                                                                const float,
                                                                                 const float);
-template void Field::update_impl<CombineMode::Divide, Host, true, float, int>(const Field &, const float, const float);
+template void Field::update_impl<CombineMode::Divide, Host, true, float, int>(const Field &,
+                                                                              const float,
+                                                                              const float);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_int_device.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_int_device.cpp
index 4dfb46d1da..1d1b589a06 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_int_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_int_device.cpp
@@ -2,8 +2,12 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Device, true, int, int>(const Field &, const int, const int);
-template void Field::update_impl<CombineMode::Multiply, Device, true, int, int>(const Field &, const int, const int);
-template void Field::update_impl<CombineMode::Divide, Device, true, int, int>(const Field &, const int, const int);
+template void Field::update_impl<CombineMode::Update, Device, true, int, int>(const Field &,
+                                                                              const int, const int);
+template void Field::update_impl<CombineMode::Multiply, Device, true, int, int>(const Field &,
+                                                                                const int,
+                                                                                const int);
+template void Field::update_impl<CombineMode::Divide, Device, true, int, int>(const Field &,
+                                                                              const int, const int);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_int_host.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_int_host.cpp
index f2dcaa5372..453ac8aa69 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_int_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_fill_int_host.cpp
@@ -2,8 +2,11 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Host, true, int, int>(const Field &, const int, const int);
-template void Field::update_impl<CombineMode::Multiply, Host, true, int, int>(const Field &, const int, const int);
-template void Field::update_impl<CombineMode::Divide, Host, true, int, int>(const Field &, const int, const int);
+template void Field::update_impl<CombineMode::Update, Host, true, int, int>(const Field &,
+                                                                            const int, const int);
+template void Field::update_impl<CombineMode::Multiply, Host, true, int, int>(const Field &,
+                                                                              const int, const int);
+template void Field::update_impl<CombineMode::Divide, Host, true, int, int>(const Field &,
+                                                                            const int, const int);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_float_device.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_float_device.cpp
index 6748351c33..23df294834 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_float_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_float_device.cpp
@@ -2,18 +2,24 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Device, false, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Update, Device, false, float, float>(const Field &,
+                                                                                   const float,
                                                                                    const float);
-template void Field::update_impl<CombineMode::Multiply, Device, false, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Multiply, Device, false, float, float>(const Field &,
+                                                                                     const float,
                                                                                      const float);
-template void Field::update_impl<CombineMode::Divide, Device, false, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Divide, Device, false, float, float>(const Field &,
+                                                                                   const float,
                                                                                    const float);
 
-template void Field::update_impl<CombineMode::Update, Device, false, float, int>(const Field &, const float,
+template void Field::update_impl<CombineMode::Update, Device, false, float, int>(const Field &,
+                                                                                 const float,
                                                                                  const float);
-template void Field::update_impl<CombineMode::Multiply, Device, false, float, int>(const Field &, const float,
+template void Field::update_impl<CombineMode::Multiply, Device, false, float, int>(const Field &,
+                                                                                   const float,
                                                                                    const float);
-template void Field::update_impl<CombineMode::Divide, Device, false, float, int>(const Field &, const float,
+template void Field::update_impl<CombineMode::Divide, Device, false, float, int>(const Field &,
+                                                                                 const float,
                                                                                  const float);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_float_host.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_float_host.cpp
index 9b1f401902..3f9ec0130f 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_float_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_float_host.cpp
@@ -2,16 +2,24 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Host, false, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Update, Host, false, float, float>(const Field &,
+                                                                                 const float,
                                                                                  const float);
-template void Field::update_impl<CombineMode::Multiply, Host, false, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Multiply, Host, false, float, float>(const Field &,
+                                                                                   const float,
                                                                                    const float);
-template void Field::update_impl<CombineMode::Divide, Host, false, float, float>(const Field &, const float,
+template void Field::update_impl<CombineMode::Divide, Host, false, float, float>(const Field &,
+                                                                                 const float,
                                                                                  const float);
 
-template void Field::update_impl<CombineMode::Update, Host, false, float, int>(const Field &, const float, const float);
-template void Field::update_impl<CombineMode::Multiply, Host, false, float, int>(const Field &, const float,
+template void Field::update_impl<CombineMode::Update, Host, false, float, int>(const Field &,
+                                                                               const float,
+                                                                               const float);
+template void Field::update_impl<CombineMode::Multiply, Host, false, float, int>(const Field &,
+                                                                                 const float,
                                                                                  const float);
-template void Field::update_impl<CombineMode::Divide, Host, false, float, int>(const Field &, const float, const float);
+template void Field::update_impl<CombineMode::Divide, Host, false, float, int>(const Field &,
+                                                                               const float,
+                                                                               const float);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_int_device.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_int_device.cpp
index ce8eb228b0..c98c8ba066 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_int_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_int_device.cpp
@@ -2,8 +2,14 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Device, false, int, int>(const Field &, const int, const int);
-template void Field::update_impl<CombineMode::Multiply, Device, false, int, int>(const Field &, const int, const int);
-template void Field::update_impl<CombineMode::Divide, Device, false, int, int>(const Field &, const int, const int);
+template void Field::update_impl<CombineMode::Update, Device, false, int, int>(const Field &,
+                                                                               const int,
+                                                                               const int);
+template void Field::update_impl<CombineMode::Multiply, Device, false, int, int>(const Field &,
+                                                                                 const int,
+                                                                                 const int);
+template void Field::update_impl<CombineMode::Divide, Device, false, int, int>(const Field &,
+                                                                               const int,
+                                                                               const int);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_impl_int_host.cpp w/components/eamxx/src/share/field/eti/field_eti_update_impl_int_host.cpp
index 7cae1b472a..61f0f20236 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_impl_int_host.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_impl_int_host.cpp
@@ -2,8 +2,12 @@
 
 namespace scream {
 
-template void Field::update_impl<CombineMode::Update, Host, false, int, int>(const Field &, const int, const int);
-template void Field::update_impl<CombineMode::Multiply, Host, false, int, int>(const Field &, const int, const int);
-template void Field::update_impl<CombineMode::Divide, Host, false, int, int>(const Field &, const int, const int);
+template void Field::update_impl<CombineMode::Update, Host, false, int, int>(const Field &,
+                                                                             const int, const int);
+template void Field::update_impl<CombineMode::Multiply, Host, false, int, int>(const Field &,
+                                                                               const int,
+                                                                               const int);
+template void Field::update_impl<CombineMode::Divide, Host, false, int, int>(const Field &,
+                                                                             const int, const int);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/eti/field_eti_update_int_device.cpp w/components/eamxx/src/share/field/eti/field_eti_update_int_device.cpp
index 21e7a5320b..004da7aecc 100644
--- i/components/eamxx/src/share/field/eti/field_eti_update_int_device.cpp
+++ w/components/eamxx/src/share/field/eti/field_eti_update_int_device.cpp
@@ -3,7 +3,8 @@
 namespace scream {
 
 template void Field::update<CombineMode::Update, Device, int>(const Field &, const int, const int);
-template void Field::update<CombineMode::Multiply, Device, int>(const Field &, const int, const int);
+template void Field::update<CombineMode::Multiply, Device, int>(const Field &, const int,
+                                                                const int);
 template void Field::update<CombineMode::Divide, Device, int>(const Field &, const int, const int);
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/field.cpp w/components/eamxx/src/share/field/field.cpp
index ec61e5fa58..5d629a1378 100644
--- i/components/eamxx/src/share/field/field.cpp
+++ w/components/eamxx/src/share/field/field.cpp
@@ -23,7 +23,9 @@ Field Field::alias(const std::string &name) const {
   return f;
 }
 
-Field Field::clone(const std::string &name) const { return clone(name, get_header().get_identifier().get_grid_name()); }
+Field Field::clone(const std::string &name) const {
+  return clone(name, get_header().get_identifier().get_grid_name());
+}
 
 Field Field::clone(const std::string &name, const std::string &grid_name) const {
   // Create new field
@@ -50,18 +52,21 @@ Field Field::clone(const std::string &name, const std::string &grid_name) const
   return f;
 }
 
-Field Field::subfield(const std::string &sf_name, const ekat::units::Units &sf_units, const int idim, const int index,
-                      const bool dynamic) const {
+Field Field::subfield(const std::string &sf_name, const ekat::units::Units &sf_units,
+                      const int idim, const int index, const bool dynamic) const {
 
   const auto &id = m_header->get_identifier();
   const auto &lt = id.get_layout();
 
   // Sanity checks
-  EKAT_REQUIRE_MSG(is_allocated(), "Error! Input field must be allocated in order to subview it.\n");
-  EKAT_REQUIRE_MSG(idim == 0 || idim == 1, "Error! Subview dimension index must be either 0 or 1.\n");
+  EKAT_REQUIRE_MSG(is_allocated(),
+                   "Error! Input field must be allocated in order to subview it.\n");
+  EKAT_REQUIRE_MSG(idim == 0 || idim == 1,
+                   "Error! Subview dimension index must be either 0 or 1.\n");
 
   // Create identifier for subfield
-  FieldIdentifier sf_id(sf_name, lt.clone().strip_dim(idim), sf_units, id.get_grid_name(), id.data_type());
+  FieldIdentifier sf_id(sf_name, lt.clone().strip_dim(idim), sf_units, id.get_grid_name(),
+                        id.data_type());
 
   // Create empty subfield, then set header and views
   // Note: we can access protected members, since it's the same type
@@ -70,7 +75,8 @@ Field Field::subfield(const std::string &sf_name, const ekat::units::Units &sf_u
   sf.m_data         = m_data;
   sf.m_is_read_only = m_is_read_only;
 
-  if (not sf.m_header->get_alloc_properties().contiguous() and not sf.host_and_device_share_memory_space()) {
+  if (not sf.m_header->get_alloc_properties().contiguous() and
+      not sf.host_and_device_share_memory_space()) {
     // If subfield is not contiguous and Host and Device do not
     // share a memory space, we must initialize the helper field
     // for sync_to functions.
@@ -80,7 +86,8 @@ Field Field::subfield(const std::string &sf_name, const ekat::units::Units &sf_u
   return sf;
 }
 
-Field Field::subfield(const std::string &sf_name, const int idim, const int index, const bool dynamic) const {
+Field Field::subfield(const std::string &sf_name, const int idim, const int index,
+                      const bool dynamic) const {
   const auto &id = m_header->get_identifier();
   return subfield(sf_name, id.get_units(), idim, index, dynamic);
 }
@@ -97,14 +104,15 @@ Field Field::subfield(const FieldTag tag, const int index, const bool dynamic) c
 // slice at index idim, extracting the N = (index_end - index_beg) entries
 // written in math notation: [index_beg, index_end)
 // or equivalently, subF = F(index_beg, ... , index_beg + N)
-Field Field::subfield(const std::string &sf_name, const ekat::units::Units &sf_units, const int idim,
-                      const int index_beg, const int index_end) const {
+Field Field::subfield(const std::string &sf_name, const ekat::units::Units &sf_units,
+                      const int idim, const int index_beg, const int index_end) const {
 
   const auto &id = m_header->get_identifier();
   const auto &lt = id.get_layout();
 
   // Sanity checks
-  EKAT_REQUIRE_MSG(is_allocated(), "Error! Input field must be allocated in order to subview it.\n");
+  EKAT_REQUIRE_MSG(is_allocated(),
+                   "Error! Input field must be allocated in order to subview it.\n");
 
   auto sf_layout = lt.clone();
   sf_layout.reset_dim(idim, index_end - index_beg);
@@ -118,7 +126,8 @@ Field Field::subfield(const std::string &sf_name, const ekat::units::Units &sf_u
   sf.m_header = create_subfield_header(sf_id, m_header, idim, index_beg, index_end);
   sf.m_data   = m_data;
 
-  if (not sf.m_header->get_alloc_properties().contiguous() and not sf.host_and_device_share_memory_space()) {
+  if (not sf.m_header->get_alloc_properties().contiguous() and
+      not sf.host_and_device_share_memory_space()) {
     // If subfield is not contiguous and Host and Device do not
     // share a memory space, we must initialize the helper field
     // for sync_to functions.
@@ -128,7 +137,8 @@ Field Field::subfield(const std::string &sf_name, const ekat::units::Units &sf_u
   return sf;
 }
 
-Field Field::subfield(const std::string &sf_name, const int idim, const int index_beg, const int index_end) const {
+Field Field::subfield(const std::string &sf_name, const int idim, const int index_beg,
+                      const int index_end) const {
   const auto &id = m_header->get_identifier();
   return subfield(sf_name, id.get_units(), idim, index_beg, index_end);
 }
@@ -140,13 +150,14 @@ Field Field::subfield(const int idim, const int index_beg, const int index_end)
 Field Field::get_component(const int i, const bool dynamic) {
   const auto &layout = get_header().get_identifier().get_layout();
   const auto &fname  = get_header().get_identifier().name();
-  EKAT_REQUIRE_MSG(layout.is_vector_layout(), "Error! 'get_component' available only for vector fields.\n"
-                                              "       Layout of '" +
-                                                  fname + "': " + e2str(layout.type()) + "\n");
+  EKAT_REQUIRE_MSG(layout.is_vector_layout(),
+                   "Error! 'get_component' available only for vector fields.\n"
+                   "       Layout of '" +
+                       fname + "': " + e2str(layout.type()) + "\n");
 
   const int idim = layout.get_vector_component_idx();
-  EKAT_REQUIRE_MSG(i >= 0 && i < layout.dim(idim),
-                   "Error! Component index out of bounds [0," + std::to_string(layout.dim(idim)) + ").\n");
+  EKAT_REQUIRE_MSG(i >= 0 && i < layout.dim(idim), "Error! Component index out of bounds [0," +
+                                                       std::to_string(layout.dim(idim)) + ").\n");
 
   // Add _$i to the field name, to avoid issues if the subfield is stored
   // in some structure that requires unique names (e.g., a remapper)
@@ -156,13 +167,15 @@ Field Field::get_component(const int i, const bool dynamic) {
 Field Field::get_components(const int beg, const int end) {
   const auto &layout = get_header().get_identifier().get_layout();
   const auto &fname  = get_header().get_identifier().name();
-  EKAT_REQUIRE_MSG(layout.is_vector_layout(), "Error! 'get_component' available only for vector fields.\n"
-                                              "       Layout of '" +
-                                                  fname + "': " + e2str(layout.type()) + "\n");
+  EKAT_REQUIRE_MSG(layout.is_vector_layout(),
+                   "Error! 'get_component' available only for vector fields.\n"
+                   "       Layout of '" +
+                       fname + "': " + e2str(layout.type()) + "\n");
 
   const int idim = layout.get_vector_component_idx();
   EKAT_REQUIRE_MSG(beg >= 0 && end < layout.dim(idim),
-                   "Error! Component index range out of bounds [0," + std::to_string(layout.dim(idim)) + ").\n");
+                   "Error! Component index range out of bounds [0," +
+                       std::to_string(layout.dim(idim)) + ").\n");
   EKAT_REQUIRE_MSG(beg < end, "Error! Invalid component indices (beg >= end).\n");
 
   // Add _$beg-$end to the field name, to avoid issues if the subfield is stored
diff --git i/components/eamxx/src/share/field/field.hpp w/components/eamxx/src/share/field/field.hpp
index 1bec90421e..bee9ab5bdc 100644
--- i/components/eamxx/src/share/field/field.hpp
+++ w/components/eamxx/src/share/field/field.hpp
@@ -40,7 +40,8 @@ public:
   template <typename T, int N> using data_nd_t = typename ekat::DataND<T, N>::type;
 
   // Types of device and host views given data type and memory traits
-  template <typename DT, typename MT = Kokkos::MemoryManaged> using view_dev_t = typename kt_dev::template view<DT, MT>;
+  template <typename DT, typename MT = Kokkos::MemoryManaged>
+  using view_dev_t = typename kt_dev::template view<DT, MT>;
   template <typename DT, typename MT = Kokkos::MemoryManaged>
   using view_host_t = typename kt_host::template view<DT, MT>;
 
@@ -57,8 +58,12 @@ private:
     view_dev_t<DT, MT> d_view;
     view_host_t<DT, MT> h_view;
 
-    template <HostOrDevice HD> const if_t<HD == Device, view_dev_t<DT, MT>> &get_view() const { return d_view; }
-    template <HostOrDevice HD> const if_t<HD == Host, view_host_t<DT, MT>> &get_view() const { return h_view; }
+    template <HostOrDevice HD> const if_t<HD == Device, view_dev_t<DT, MT>> &get_view() const {
+      return d_view;
+    }
+    template <HostOrDevice HD> const if_t<HD == Host, view_host_t<DT, MT>> &get_view() const {
+      return h_view;
+    }
   };
 
 public:
@@ -67,7 +72,8 @@ public:
   using get_view_type = cond_t<HD == Device, view_dev_t<DT, MT>, view_host_t<DT, MT>>;
 
   template <typename DT, HostOrDevice HD, typename MT = Kokkos::MemoryManaged>
-  using get_strided_view_type = cond_t<HD == Device, strided_view_dev_t<DT, MT>, strided_view_host_t<DT, MT>>;
+  using get_strided_view_type =
+      cond_t<HD == Device, strided_view_dev_t<DT, MT>, strided_view_host_t<DT, MT>>;
 
   // Field stack classes types
   using header_type     = FieldHeader;
@@ -113,7 +119,8 @@ public:
   // This is safer to use for fields that could be a subfield of another one, since a
   // rank-1 view that is the subview of a 2d one along the 2nd index cannot have
   // LayoutRight, and must have LayoutStride instead.
-  template <typename DT, HostOrDevice HD = Device> get_strided_view_type<DT, HD> get_strided_view() const;
+  template <typename DT, HostOrDevice HD = Device>
+  get_strided_view_type<DT, HD> get_strided_view() const;
 
   // These two getters are convenience function for commonly accessed metadata.
   // The same info can be extracted from the metadata stored in the FieldHeader
@@ -139,21 +146,23 @@ public:
   template <typename ST, HostOrDevice HD = Device> ST *get_internal_view_data() const {
     // Check that the scalar type is correct
     using nonconst_ST = typename std::remove_const<ST>::type;
-    EKAT_REQUIRE_MSG((field_valid_data_types().at<nonconst_ST>() == m_header->get_identifier().data_type() or
-                      std::is_same<nonconst_ST, char>::value),
-                     "Error! Attempt to access raw field pointer with the wrong scalar type.\n"
-                     " - field name: " +
-                         name() +
-                         "\n"
-                         " - field data type: " +
-                         e2str(data_type()) +
-                         "\n"
-                         " - requested type : " +
-                         e2str(field_valid_data_types().at<nonconst_ST>()) + "\n");
-    EKAT_REQUIRE_MSG(not m_is_read_only || std::is_const<ST>::value,
-                     "Error! Cannot get a non-const raw pointer to the field data if the field is read-only.\n"
-                     " - field name: " +
-                         name() + "\n");
+    EKAT_REQUIRE_MSG(
+        (field_valid_data_types().at<nonconst_ST>() == m_header->get_identifier().data_type() or
+         std::is_same<nonconst_ST, char>::value),
+        "Error! Attempt to access raw field pointer with the wrong scalar type.\n"
+        " - field name: " +
+            name() +
+            "\n"
+            " - field data type: " +
+            e2str(data_type()) +
+            "\n"
+            " - requested type : " +
+            e2str(field_valid_data_types().at<nonconst_ST>()) + "\n");
+    EKAT_REQUIRE_MSG(
+        not m_is_read_only || std::is_const<ST>::value,
+        "Error! Cannot get a non-const raw pointer to the field data if the field is read-only.\n"
+        " - field name: " +
+            name() + "\n");
 
     return reinterpret_cast<ST *>(get_view_impl<HD>().data());
   }
@@ -168,7 +177,8 @@ public:
   template <typename ST, HostOrDevice HD = Device> ST *get_internal_view_data_unsafe() const {
     // Check that the scalar type is correct
     using nonconst_ST = typename std::remove_const<ST>::type;
-    EKAT_REQUIRE_MSG((std::is_same<nonconst_ST, char>::value or std::is_same<nonconst_ST, void>::value or
+    EKAT_REQUIRE_MSG((std::is_same<nonconst_ST, char>::value or
+                      std::is_same<nonconst_ST, void>::value or
                       (field_valid_data_types().has_t<nonconst_ST>() and
                        get_data_type<nonconst_ST>() == m_header->get_identifier().data_type())),
                      "Error! Attempt to access raw field pointer with the wrong scalar type.\n"
@@ -203,10 +213,13 @@ public:
   // Like the above one, but only sets the value where the mask is active
   // NOTE: mask field must have data type IntType, and hold the extra data
   // "true_value", to specify where the mask is active
-  template <HostOrDevice HD = Device, typename ST = void> void deep_copy(const ST value, const Field &mask);
+  template <HostOrDevice HD = Device, typename ST = void>
+  void deep_copy(const ST value, const Field &mask);
 
   // Copy the data from one field to this field (recycle update method)
-  template <HostOrDevice HD = Device> void deep_copy(const Field &src) { update<CombineMode::Replace, HD>(src, 1, 0); }
+  template <HostOrDevice HD = Device> void deep_copy(const Field &src) {
+    update<CombineMode::Replace, HD>(src, 1, 0);
+  }
 
   // Updates this field y as y=combine(x,y,alpha,beta)
   // See share/util/eamxx_combine_ops.hpp for more details on CombineMode options
@@ -224,10 +237,14 @@ public:
   }
 
   // Scale a field y as y=y*x where x is also a field
-  template <HostOrDevice HD = Device> void scale(const Field &x) { update<CombineMode::Multiply, HD>(x, 1, 1); }
+  template <HostOrDevice HD = Device> void scale(const Field &x) {
+    update<CombineMode::Multiply, HD>(x, 1, 1);
+  }
 
   // Scale a field y as y=y/x where x is also a field
-  template <HostOrDevice HD = Device> void scale_inv(const Field &x) { update<CombineMode::Divide, HD>(x, 1, 1); }
+  template <HostOrDevice HD = Device> void scale_inv(const Field &x) {
+    update<CombineMode::Divide, HD>(x, 1, 1);
+  }
 
   // Returns a subview of this field, slicing at entry k along dimension idim
   // NOTES:
@@ -245,17 +262,19 @@ public:
   //     specializes view's traits for LayoutRight of rank 1, not allowing
   //     to store a stride for the slowest dimension.
   //   - If dynamic = true, it is possible to "reset" the slice index (k) at runtime.
-  Field subfield(const std::string &sf_name, const ekat::units::Units &sf_units, const int idim, const int index,
+  Field subfield(const std::string &sf_name, const ekat::units::Units &sf_units, const int idim,
+                 const int index, const bool dynamic = false) const;
+  Field subfield(const std::string &sf_name, const int idim, const int index,
                  const bool dynamic = false) const;
-  Field subfield(const std::string &sf_name, const int idim, const int index, const bool dynamic = false) const;
   Field subfield(const int idim, const int k, const bool dynamic = false) const;
   Field subfield(const FieldTag tag, const int k, const bool dynamic = false) const;
   // extracts a subfield composed of multiple slices in a continuous range of indices
   // e.g., (in matlab syntax) subf = f.subfield(:, 1:3, :)
   // but NOT subf = f.subfield(:, [1, 3, 4], :)
-  Field subfield(const std::string &sf_name, const ekat::units::Units &sf_units, const int idim, const int index_beg,
+  Field subfield(const std::string &sf_name, const ekat::units::Units &sf_units, const int idim,
+                 const int index_beg, const int index_end) const;
+  Field subfield(const std::string &sf_name, const int idim, const int index_beg,
                  const int index_end) const;
-  Field subfield(const std::string &sf_name, const int idim, const int index_beg, const int index_end) const;
   Field subfield(const int idim, const int index_beg, const int index_end) const;
   // If this field is a vector field, get a subfield for the ith component.
   // If dynamic = true, it is possible to "reset" the component index at runtime.
@@ -312,7 +331,8 @@ protected:
 #endif
   template <typename ST, HostOrDevice From, HostOrDevice To> void sync_views_impl() const;
 
-  template <HostOrDevice HD, bool use_mask, typename ST> void deep_copy_impl(const ST value, const Field &mask);
+  template <HostOrDevice HD, bool use_mask, typename ST>
+  void deep_copy_impl(const ST value, const Field &mask);
 
   // The update method calls this, with ST matching this field data type.
   // Note: use_fill is used to determine *at compile time* whether to use
@@ -329,14 +349,14 @@ protected:
   // These SFINAE impl of get_subview are needed since subview_1 does not
   // exist for rank2 (or less) views.
   template <HostOrDevice HD, typename T, int N>
-  if_t<(N > 2), get_view_type<data_nd_t<T, N - 1>, HD>> get_subview_1(const get_view_type<data_nd_t<T, N>, HD> &v,
-                                                                      const int k) const {
+  if_t<(N > 2), get_view_type<data_nd_t<T, N - 1>, HD>>
+  get_subview_1(const get_view_type<data_nd_t<T, N>, HD> &v, const int k) const {
     return ekat::subview_1(v, k);
   }
 
   template <HostOrDevice HD, typename T, int N>
-  if_t<(N <= 2), get_view_type<data_nd_t<T, N - 1>, HD>> get_subview_1(const get_view_type<data_nd_t<T, N>, HD> &,
-                                                                       const int) const {
+  if_t<(N <= 2), get_view_type<data_nd_t<T, N - 1>, HD>>
+  get_subview_1(const get_view_type<data_nd_t<T, N>, HD> &, const int) const {
     EKAT_ERROR_MSG("Error! Cannot subview a rank2 view along the second "
                    "dimension without losing LayoutRight.\n");
     return get_view_type<data_nd_t<T, N - 1>, HD>();
@@ -377,42 +397,54 @@ inline bool operator==(const Field &lhs, const Field &rhs) {
 
 // Inform the compiler that we will instantiate some template methods in some translation unit (TU).
 // This prevents the decl in field_impl.hpp from being compiled for every TU.
-// NOTE: field_impl.hpp is still included, so you can call other specializations (e.g., update for CM=Max)
+// NOTE: field_impl.hpp is still included, so you can call other specializations (e.g., update for
+// CM=Max)
 //       and the compiler will implicitly instantiate. However, these are the most common use cases,
 //       so it helps to do ETI for those.
 // NOTE: for update, we only specialize for CM being Update, Multiply, and Divide,
-#define EAMXX_FIELD_ETI_DECL_UPDATE(S, T)                                                           \
-  extern template void Field::update<CombineMode::Update, S, T>(const Field &, const T, const T);   \
-  extern template void Field::update<CombineMode::Multiply, S, T>(const Field &, const T, const T); \
+#define EAMXX_FIELD_ETI_DECL_UPDATE(S, T)                                                         \
+  extern template void Field::update<CombineMode::Update, S, T>(const Field &, const T, const T); \
+  extern template void Field::update<CombineMode::Multiply, S, T>(const Field &, const T,         \
+                                                                  const T);                       \
   extern template void Field::update<CombineMode::Divide, S, T>(const Field &, const T, const T)
 
-#define EAMXX_FIELD_ETI_DECL_UPDATE_IMPL(S, T1, T2)                                                                    \
-  extern template void Field::update_impl<CombineMode::Update, S, true, T1, T2>(const Field &, const T1, const T1);    \
-  extern template void Field::update_impl<CombineMode::Multiply, S, true, T1, T2>(const Field &, const T1, const T1);  \
-  extern template void Field::update_impl<CombineMode::Divide, S, true, T1, T2>(const Field &, const T1, const T1);    \
-  extern template void Field::update_impl<CombineMode::Update, S, false, T1, T2>(const Field &, const T1, const T1);   \
-  extern template void Field::update_impl<CombineMode::Multiply, S, false, T1, T2>(const Field &, const T1, const T1); \
-  extern template void Field::update_impl<CombineMode::Divide, S, false, T1, T2>(const Field &, const T1, const T1)
+#define EAMXX_FIELD_ETI_DECL_UPDATE_IMPL(S, T1, T2)                                 \
+  extern template void Field::update_impl<CombineMode::Update, S, true, T1, T2>(    \
+      const Field &, const T1, const T1);                                           \
+  extern template void Field::update_impl<CombineMode::Multiply, S, true, T1, T2>(  \
+      const Field &, const T1, const T1);                                           \
+  extern template void Field::update_impl<CombineMode::Divide, S, true, T1, T2>(    \
+      const Field &, const T1, const T1);                                           \
+  extern template void Field::update_impl<CombineMode::Update, S, false, T1, T2>(   \
+      const Field &, const T1, const T1);                                           \
+  extern template void Field::update_impl<CombineMode::Multiply, S, false, T1, T2>( \
+      const Field &, const T1, const T1);                                           \
+  extern template void Field::update_impl<CombineMode::Divide, S, false, T1, T2>(   \
+      const Field &, const T1, const T1)
 
 #define EAMXX_FIELD_ETI_DECL_DEEP_COPY(S, T)                                      \
   extern template void Field::deep_copy_impl<S, true, T>(const T, const Field &); \
   extern template void Field::deep_copy_impl<S, false, T>(const T, const Field &)
 
-#define EAMXX_FIELD_ETI_DECL_GET_VIEW(S, T)                                                             \
-  extern template Field::get_view_type<T, S> Field::get_view<T, S>() const;                             \
-  extern template Field::get_view_type<T *, S> Field::get_view<T *, S>() const;                         \
-  extern template Field::get_view_type<T **, S> Field::get_view<T **, S>() const;                       \
-  extern template Field::get_view_type<T ***, S> Field::get_view<T ***, S>() const;                     \
-  extern template Field::get_view_type<T ****, S> Field::get_view<T ****, S>() const;                   \
-  extern template Field::get_view_type<T *****, S> Field::get_view<T *****, S>() const;                 \
-  extern template Field::get_view_type<T ******, S> Field::get_view<T ******, S>() const;               \
-  extern template Field::get_strided_view_type<T, S> Field::get_strided_view<T, S>() const;             \
-  extern template Field::get_strided_view_type<T *, S> Field::get_strided_view<T *, S>() const;         \
-  extern template Field::get_strided_view_type<T **, S> Field::get_strided_view<T **, S>() const;       \
-  extern template Field::get_strided_view_type<T ***, S> Field::get_strided_view<T ***, S>() const;     \
-  extern template Field::get_strided_view_type<T ****, S> Field::get_strided_view<T ****, S>() const;   \
-  extern template Field::get_strided_view_type<T *****, S> Field::get_strided_view<T *****, S>() const; \
-  extern template Field::get_strided_view_type<T ******, S> Field::get_strided_view<T ******, S>() const
+#define EAMXX_FIELD_ETI_DECL_GET_VIEW(S, T)                                                        \
+  extern template Field::get_view_type<T, S> Field::get_view<T, S>() const;                        \
+  extern template Field::get_view_type<T *, S> Field::get_view<T *, S>() const;                    \
+  extern template Field::get_view_type<T **, S> Field::get_view<T **, S>() const;                  \
+  extern template Field::get_view_type<T ***, S> Field::get_view<T ***, S>() const;                \
+  extern template Field::get_view_type<T ****, S> Field::get_view<T ****, S>() const;              \
+  extern template Field::get_view_type<T *****, S> Field::get_view<T *****, S>() const;            \
+  extern template Field::get_view_type<T ******, S> Field::get_view<T ******, S>() const;          \
+  extern template Field::get_strided_view_type<T, S> Field::get_strided_view<T, S>() const;        \
+  extern template Field::get_strided_view_type<T *, S> Field::get_strided_view<T *, S>() const;    \
+  extern template Field::get_strided_view_type<T **, S> Field::get_strided_view<T **, S>() const;  \
+  extern template Field::get_strided_view_type<T ***, S> Field::get_strided_view<T ***, S>()       \
+      const;                                                                                       \
+  extern template Field::get_strided_view_type<T ****, S> Field::get_strided_view<T ****, S>()     \
+      const;                                                                                       \
+  extern template Field::get_strided_view_type<T *****, S> Field::get_strided_view<T *****, S>()   \
+      const;                                                                                       \
+  extern template Field::get_strided_view_type<T ******, S> Field::get_strided_view<T ******, S>() \
+      const
 
 #define EAMXX_FIELD_ETI_DECL_FOR_ONE_TYPE(T)      \
   EAMXX_FIELD_ETI_DECL_UPDATE(Device, T);         \
diff --git i/components/eamxx/src/share/field/field_alloc_prop.cpp w/components/eamxx/src/share/field/field_alloc_prop.cpp
index e8a3cd3bce..ab09446842 100644
--- i/components/eamxx/src/share/field/field_alloc_prop.cpp
+++ w/components/eamxx/src/share/field/field_alloc_prop.cpp
@@ -3,14 +3,15 @@
 namespace scream {
 
 FieldAllocProp::FieldAllocProp(const int scalar_size)
-    : m_layout(FieldLayout::invalid()), m_value_type_sizes(1, scalar_size), m_scalar_type_size(scalar_size),
-      m_pack_size_max(1), m_alloc_size(0), m_committed(false) {
+    : m_layout(FieldLayout::invalid()), m_value_type_sizes(1, scalar_size),
+      m_scalar_type_size(scalar_size), m_pack_size_max(1), m_alloc_size(0), m_committed(false) {
   // Nothing to do here
 }
 
 FieldAllocProp &FieldAllocProp::operator=(const FieldAllocProp &src) {
   if (&src != this) {
-    EKAT_REQUIRE_MSG(not m_committed, "Error! Cannot assign FieldAllocProp once the dst obj is committed.\n");
+    EKAT_REQUIRE_MSG(not m_committed,
+                     "Error! Cannot assign FieldAllocProp once the dst obj is committed.\n");
 
     m_layout           = src.m_layout;
     m_value_type_sizes = src.m_value_type_sizes;
@@ -27,9 +28,11 @@ FieldAllocProp &FieldAllocProp::operator=(const FieldAllocProp &src) {
 
 FieldAllocProp FieldAllocProp::subview(const int idim, const int k, const bool dynamic) const {
   EKAT_REQUIRE_MSG(is_committed(), "Error! Subview requires alloc properties to be committed.\n");
-  EKAT_REQUIRE_MSG(idim == 0 || idim == 1, "Error! Subviewing is only allowed along first or second dimension.\n");
+  EKAT_REQUIRE_MSG(idim == 0 || idim == 1,
+                   "Error! Subviewing is only allowed along first or second dimension.\n");
   EKAT_REQUIRE_MSG(idim < m_layout.rank(), "Error! Dimension index out of bounds.\n");
-  EKAT_REQUIRE_MSG(k >= 0 && k < m_layout.dim(idim), "Error! Index along the dimension is out of bounds.\n");
+  EKAT_REQUIRE_MSG(k >= 0 && k < m_layout.dim(idim),
+                   "Error! Index along the dimension is out of bounds.\n");
 
   // Set new layout basic stuff
   FieldAllocProp props(m_scalar_type_size);
@@ -64,7 +67,8 @@ FieldAllocProp FieldAllocProp::subview(const int idim, const int k, const bool d
   return props;
 }
 
-FieldAllocProp FieldAllocProp::subview(const int idim, const int index_beg, const int index_end) const {
+FieldAllocProp FieldAllocProp::subview(const int idim, const int index_beg,
+                                       const int index_end) const {
   EKAT_REQUIRE_MSG(is_committed(), "Error! Subview requires alloc properties to be committed.\n");
   EKAT_REQUIRE_MSG(idim < m_layout.rank(), "Error! Dimension index out of bounds.\n");
   EKAT_REQUIRE_MSG(index_beg < index_end, "Error! Slice indices are invalid (non-increasing).\n");
@@ -101,7 +105,8 @@ FieldAllocProp FieldAllocProp::subview(const int idim, const int index_beg, cons
 void FieldAllocProp::request_allocation(const int pack_size) {
   using ekat::ScalarTraits;
 
-  EKAT_REQUIRE_MSG(!m_committed, "Error! Cannot change allocation properties after they have been committed.\n");
+  EKAT_REQUIRE_MSG(!m_committed,
+                   "Error! Cannot change allocation properties after they have been committed.\n");
 
   const int vts = m_scalar_type_size * pack_size;
 
@@ -118,16 +123,20 @@ void FieldAllocProp::request_allocation(const FieldAllocProp &src) {
 }
 
 int FieldAllocProp::get_padding() const {
-  EKAT_REQUIRE_MSG(is_committed(), "Error! You cannot query the allocation padding until after calling commit().");
+  EKAT_REQUIRE_MSG(is_committed(),
+                   "Error! You cannot query the allocation padding until after calling commit().");
   int padding = m_layout.rank() == 0 ? 0 : m_last_extent - m_layout.dims().back();
   return padding;
 }
 
 void FieldAllocProp::reset_subview_idx(const int idx) {
-  EKAT_REQUIRE_MSG(is_committed(), "Error! Cannot reset subview idx on a non-committed allocation.\n");
+  EKAT_REQUIRE_MSG(is_committed(),
+                   "Error! Cannot reset subview idx on a non-committed allocation.\n");
   EKAT_REQUIRE_MSG(is_subfield(), "Error! Cannot reset subview idx if this is not a subfield.\n");
-  EKAT_REQUIRE_MSG(is_dynamic_subfield(), "Error! Cannot reset subview idx for non-dynamic subfields.\n");
-  EKAT_REQUIRE_MSG(idx >= 0 && idx < m_subview_info.dim_extent, "Error! Subview slice idx out of bounds.\n");
+  EKAT_REQUIRE_MSG(is_dynamic_subfield(),
+                   "Error! Cannot reset subview idx for non-dynamic subfields.\n");
+  EKAT_REQUIRE_MSG(idx >= 0 && idx < m_subview_info.dim_extent,
+                   "Error! Subview slice idx out of bounds.\n");
 
   // Note: all the other allocation properties are unchanged.
   m_subview_info.slice_idx = idx;
@@ -139,10 +148,13 @@ void FieldAllocProp::commit(const layout_type &layout) {
     return;
   }
 
-  // Sanity checks: we must have requested at least one value type, and the identifier needs all dimensions set by now.
-  EKAT_REQUIRE_MSG(m_value_type_sizes.size() > 0, "Error! No value types requested for the allocation.\n");
-  EKAT_REQUIRE_MSG(layout.are_dimensions_set(),
-                   "Error! You need all field dimensions set before committing the allocation properties.\n");
+  // Sanity checks: we must have requested at least one value type, and the identifier needs all
+  // dimensions set by now.
+  EKAT_REQUIRE_MSG(m_value_type_sizes.size() > 0,
+                   "Error! No value types requested for the allocation.\n");
+  EKAT_REQUIRE_MSG(
+      layout.are_dimensions_set(),
+      "Error! You need all field dimensions set before committing the allocation properties.\n");
 
   // Store layout for future use (in case subview is called)
   m_layout = layout;
@@ -175,8 +187,9 @@ void FieldAllocProp::commit(const layout_type &layout) {
     }
 
     if (m_layout.size() > 0) {
-      m_alloc_size = m_layout.size() / last_phys_extent    // All except the last dimension
-                     * m_last_extent * m_scalar_type_size; // Last dimension must account for padding (if any)
+      m_alloc_size = m_layout.size() / last_phys_extent // All except the last dimension
+                     * m_last_extent *
+                     m_scalar_type_size; // Last dimension must account for padding (if any)
     } else {
       m_alloc_size = 0;
     }
@@ -188,17 +201,22 @@ void FieldAllocProp::commit(const layout_type &layout) {
 }
 
 long long FieldAllocProp::get_alloc_size() const {
-  EKAT_REQUIRE_MSG(is_committed(), "Error! You cannot query the allocation properties until they have been committed.");
+  EKAT_REQUIRE_MSG(
+      is_committed(),
+      "Error! You cannot query the allocation properties until they have been committed.");
   return m_alloc_size;
 }
 
 int FieldAllocProp::get_largest_pack_size() const {
-  EKAT_REQUIRE_MSG(is_committed(), "Error! You cannot query the allocation properties until they have been committed.");
+  EKAT_REQUIRE_MSG(
+      is_committed(),
+      "Error! You cannot query the allocation properties until they have been committed.");
   return m_pack_size_max;
 }
 
 int FieldAllocProp::get_last_extent() const {
-  EKAT_REQUIRE_MSG(is_committed(), "Error! You cannot query the allocation strides until after calling commit().");
+  EKAT_REQUIRE_MSG(is_committed(),
+                   "Error! You cannot query the allocation strides until after calling commit().");
   return m_last_extent;
 }
 
diff --git i/components/eamxx/src/share/field/field_alloc_prop.hpp w/components/eamxx/src/share/field/field_alloc_prop.hpp
index f4bef08b9b..5c0656fecc 100644
--- i/components/eamxx/src/share/field/field_alloc_prop.hpp
+++ w/components/eamxx/src/share/field/field_alloc_prop.hpp
@@ -86,7 +86,8 @@ inline bool operator==(const SubviewInfo &lhs, const SubviewInfo &rhs) {
   return lhs.dim_idx == rhs.dim_idx && lhs.slice_idx == rhs.slice_idx &&
          //  slice_idx_end == -1 for single slice, and the ending index when
          // it's a multi-slice
-         lhs.slice_idx_end == rhs.slice_idx_end && lhs.dim_extent == rhs.dim_extent && lhs.dynamic == rhs.dynamic;
+         lhs.slice_idx_end == rhs.slice_idx_end && lhs.dim_extent == rhs.dim_extent &&
+         lhs.dynamic == rhs.dynamic;
 }
 
 class FieldAllocProp {
diff --git i/components/eamxx/src/share/field/field_group_info.hpp w/components/eamxx/src/share/field/field_group_info.hpp
index dcf3f4c6a7..885f7da655 100644
--- i/components/eamxx/src/share/field/field_group_info.hpp
+++ w/components/eamxx/src/share/field/field_group_info.hpp
@@ -29,7 +29,8 @@ struct FieldGroupInfo {
 
   // Default initialize everything
   FieldGroupInfo(const ci_string &group_name)
-      : m_group_name(group_name), m_fields_names{}, m_monolithic_allocation(false), m_subview_dim(-1), m_subview_idx{} {
+      : m_group_name(group_name), m_fields_names{}, m_monolithic_allocation(false),
+        m_subview_dim(-1), m_subview_idx{} {
     // Nothing to do here
   }
 
@@ -69,8 +70,8 @@ struct FieldGroupInfo {
 
 inline bool operator==(const FieldGroupInfo &lhs, const FieldGroupInfo &rhs) {
   return lhs.m_group_name == rhs.m_group_name && lhs.m_fields_names == rhs.m_fields_names &&
-         lhs.m_monolithic_allocation == rhs.m_monolithic_allocation && lhs.m_subview_dim == rhs.m_subview_dim &&
-         lhs.m_subview_idx == rhs.m_subview_idx;
+         lhs.m_monolithic_allocation == rhs.m_monolithic_allocation &&
+         lhs.m_subview_dim == rhs.m_subview_dim && lhs.m_subview_idx == rhs.m_subview_idx;
 }
 
 } // namespace scream
diff --git i/components/eamxx/src/share/field/field_header.cpp w/components/eamxx/src/share/field/field_header.cpp
index e46cb8c7e1..44f79da941 100644
--- i/components/eamxx/src/share/field/field_header.cpp
+++ w/components/eamxx/src/share/field/field_header.cpp
@@ -4,7 +4,8 @@
 
 namespace scream {
 
-FieldHeader::FieldHeader(const identifier_type &id) : m_identifier(id), m_tracking(create_tracking()) {
+FieldHeader::FieldHeader(const identifier_type &id)
+    : m_identifier(id), m_tracking(create_tracking()) {
   m_alloc_prop = std::make_shared<FieldAllocProp>(get_type_size(id.data_type()));
   m_extra_data = std::make_shared<extra_data_type>();
 
@@ -14,12 +15,14 @@ FieldHeader::FieldHeader(const identifier_type &id) : m_identifier(id), m_tracki
   set_extra_data("io: string attributes", stratts_t());
 }
 
-void FieldHeader::set_extra_data(const std::string &key, const ekat::any &data, const bool throw_if_existing) {
+void FieldHeader::set_extra_data(const std::string &key, const ekat::any &data,
+                                 const bool throw_if_existing) {
   if (throw_if_existing) {
-    EKAT_REQUIRE_MSG(m_extra_data->find(key) == m_extra_data->end(), "Error! Key '" + key +
-                                                                         "' already existing in "
-                                                                         "the extra data map of field '" +
-                                                                         m_identifier.get_id_string() + "'.\n");
+    EKAT_REQUIRE_MSG(m_extra_data->find(key) == m_extra_data->end(),
+                     "Error! Key '" + key +
+                         "' already existing in "
+                         "the extra data map of field '" +
+                         m_identifier.get_id_string() + "'.\n");
     (*m_extra_data)[key] = data;
   } else {
     (*m_extra_data)[key] = data;
@@ -38,13 +41,15 @@ bool FieldHeader::is_aliasing(const FieldHeader &rhs) const {
   if (this == &rhs)
     return true;
 
-  if (m_tracking == rhs.m_tracking and m_alloc_prop == rhs.m_alloc_prop and m_extra_data == rhs.m_extra_data)
+  if (m_tracking == rhs.m_tracking and m_alloc_prop == rhs.m_alloc_prop and
+      m_extra_data == rhs.m_extra_data)
     return true;
 
   auto p     = get_parent();
   auto rhs_p = rhs.get_parent();
   if (p != nullptr and rhs_p != nullptr) {
-    return p->is_aliasing(*rhs_p) and m_alloc_prop->get_subview_info() == rhs.m_alloc_prop->get_subview_info();
+    return p->is_aliasing(*rhs_p) and
+           m_alloc_prop->get_subview_info() == rhs.m_alloc_prop->get_subview_info();
   }
 
   return false;
@@ -52,8 +57,10 @@ bool FieldHeader::is_aliasing(const FieldHeader &rhs) const {
 
 // ---------------- Free function -------------------- //
 
-std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &id, std::shared_ptr<FieldHeader> parent,
-                                                    const int idim, const int k, const bool dynamic) {
+std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &id,
+                                                    std::shared_ptr<FieldHeader> parent,
+                                                    const int idim, const int k,
+                                                    const bool dynamic) {
   // Sanity checks
   EKAT_REQUIRE_MSG(parent != nullptr, "Error! Invalid pointer for parent header.\n");
 
@@ -69,14 +76,17 @@ std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &id, s
   }
 
   // Create alloc props
-  fh->m_alloc_prop = std::make_shared<FieldAllocProp>(parent->get_alloc_properties().subview(idim, k, dynamic));
+  fh->m_alloc_prop =
+      std::make_shared<FieldAllocProp>(parent->get_alloc_properties().subview(idim, k, dynamic));
 
   return fh;
 }
 
 // subfield with multiple, contiguous slices
-std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &id, std::shared_ptr<FieldHeader> parent,
-                                                    const int idim, const int k_beg, const int k_end) {
+std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &id,
+                                                    std::shared_ptr<FieldHeader> parent,
+                                                    const int idim, const int k_beg,
+                                                    const int k_end) {
   // Sanity checks
   EKAT_REQUIRE_MSG(parent != nullptr, "Error! Invalid pointer for parent header.\n");
   EKAT_REQUIRE_MSG(k_end > k_beg, "Error! Slice indices are invalid (non-increasing).\n");
@@ -93,7 +103,8 @@ std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &id, s
   }
 
   // Create alloc props
-  fh->m_alloc_prop = std::make_shared<FieldAllocProp>(parent->get_alloc_properties().subview(idim, k_beg, k_end));
+  fh->m_alloc_prop =
+      std::make_shared<FieldAllocProp>(parent->get_alloc_properties().subview(idim, k_beg, k_end));
 
   return fh;
 }
diff --git i/components/eamxx/src/share/field/field_header.hpp w/components/eamxx/src/share/field/field_header.hpp
index 70f130f866..0c962638aa 100644
--- i/components/eamxx/src/share/field/field_header.hpp
+++ w/components/eamxx/src/share/field/field_header.hpp
@@ -46,7 +46,8 @@ public:
   FieldHeader &operator=(const FieldHeader &) = delete;
 
   // Set extra data
-  void set_extra_data(const std::string &key, const ekat::any &data, const bool throw_if_existing = false);
+  void set_extra_data(const std::string &key, const ekat::any &data,
+                      const bool throw_if_existing = false);
 
   template <typename T>
   void set_extra_data(const std::string &key, const T &data, const bool throw_if_existing = false) {
@@ -84,11 +85,14 @@ public:
 
 protected:
   // Friend this function, so it can set up a subfield header
-  friend std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &, std::shared_ptr<FieldHeader>,
+  friend std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &,
+                                                             std::shared_ptr<FieldHeader>,
                                                              const int, const int, const bool);
   // for creating multi-slice subfield (continuous indices)
-  friend std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &, std::shared_ptr<FieldHeader>,
-                                                             const int idim, const int k_beg, const int k_end);
+  friend std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &,
+                                                             std::shared_ptr<FieldHeader>,
+                                                             const int idim, const int k_beg,
+                                                             const int k_end);
 
   // NOTE: the identifier *cannot* be a shared_ptr, b/c we
   //       don't foresee sharing an identifier between two
@@ -169,10 +173,14 @@ template <typename... Args> inline std::shared_ptr<FieldHeader> create_header(co
 // Use this free function to create a header for a field that
 // is the subfield of another field, that is, for something
 // that (in matlab syntax) looks like sf = f(:,1,:)
-std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &id, std::shared_ptr<FieldHeader> parent,
-                                                    const int idim, const int k, const bool dynamic);
-std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &id, std::shared_ptr<FieldHeader> parent,
-                                                    const int idim, const int k_beg, const int k_end);
+std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &id,
+                                                    std::shared_ptr<FieldHeader> parent,
+                                                    const int idim, const int k,
+                                                    const bool dynamic);
+std::shared_ptr<FieldHeader> create_subfield_header(const FieldIdentifier &id,
+                                                    std::shared_ptr<FieldHeader> parent,
+                                                    const int idim, const int k_beg,
+                                                    const int k_end);
 
 } // namespace scream
 
diff --git i/components/eamxx/src/share/field/field_identifier.cpp w/components/eamxx/src/share/field/field_identifier.cpp
index f488556a8b..99efa8ac8d 100644
--- i/components/eamxx/src/share/field/field_identifier.cpp
+++ w/components/eamxx/src/share/field/field_identifier.cpp
@@ -3,15 +3,17 @@
 
 namespace scream {
 
-FieldIdentifier::FieldIdentifier(const std::string &name, const layout_type &layout, const Units &units,
-                                 const std::string &grid_name)
+FieldIdentifier::FieldIdentifier(const std::string &name, const layout_type &layout,
+                                 const Units &units, const std::string &grid_name)
     : FieldIdentifier(name, layout, units, grid_name, DataType::RealType) {
   // Nothing to do here
 }
 
-FieldIdentifier::FieldIdentifier(const std::string &name, const layout_type &layout, const Units &units,
-                                 const std::string &grid_name, const DataType data_type)
-    : m_name(name), m_layout(layout), m_units(units), m_grid_name(grid_name), m_data_type(data_type) {
+FieldIdentifier::FieldIdentifier(const std::string &name, const layout_type &layout,
+                                 const Units &units, const std::string &grid_name,
+                                 const DataType data_type)
+    : m_name(name), m_layout(layout), m_units(units), m_grid_name(grid_name),
+      m_data_type(data_type) {
   update_identifier();
 }
 
diff --git i/components/eamxx/src/share/field/field_identifier.hpp w/components/eamxx/src/share/field/field_identifier.hpp
index 92c40cdb44..2655ac0af9 100644
--- i/components/eamxx/src/share/field/field_identifier.hpp
+++ w/components/eamxx/src/share/field/field_identifier.hpp
@@ -44,10 +44,11 @@ public:
   FieldIdentifier()                        = delete;
   FieldIdentifier(const FieldIdentifier &) = default;
 
-  FieldIdentifier(const std::string &name, const layout_type &layout, const Units &units, const std::string &grid_name);
+  FieldIdentifier(const std::string &name, const layout_type &layout, const Units &units,
+                  const std::string &grid_name);
 
-  FieldIdentifier(const std::string &name, const layout_type &layout, const Units &units, const std::string &grid_name,
-                  const DataType data_type);
+  FieldIdentifier(const std::string &name, const layout_type &layout, const Units &units,
+                  const std::string &grid_name, const DataType data_type);
 
   // Delete assignment, to prevent overwriting identifiers sneakyly
   FieldIdentifier &operator=(const FieldIdentifier &) = delete;
@@ -92,7 +93,9 @@ protected:
 };
 
 bool operator==(const FieldIdentifier &fid1, const FieldIdentifier &fid2);
-inline bool operator!=(const FieldIdentifier &fid1, const FieldIdentifier &fid2) { return !(fid1 == fid2); }
+inline bool operator!=(const FieldIdentifier &fid1, const FieldIdentifier &fid2) {
+  return !(fid1 == fid2);
+}
 
 } // namespace scream
 
diff --git i/components/eamxx/src/share/field/field_impl.hpp w/components/eamxx/src/share/field/field_impl.hpp
index 35885808e3..ce78ec514e 100644
--- i/components/eamxx/src/share/field/field_impl.hpp
+++ w/components/eamxx/src/share/field/field_impl.hpp
@@ -10,7 +10,8 @@
 
 namespace scream {
 
-template <typename ViewT, typename> Field::Field(const identifier_type &id, const ViewT &view_d) : Field(id) {
+template <typename ViewT, typename>
+Field::Field(const identifier_type &id, const ViewT &view_d) : Field(id) {
   constexpr int N = ViewT::rank;
   using ScalarT   = typename ViewT::traits::value_type;
   using ExeSpace  = typename ViewT::traits::execution_space;
@@ -18,50 +19,54 @@ template <typename ViewT, typename> Field::Field(const identifier_type &id, cons
   EKAT_REQUIRE_MSG((std::is_same<ExeSpace, typename device_t::execution_space>::value),
                    "Error! This constructor of Field requires a view from device.\n");
 
-  EKAT_REQUIRE_MSG(id.data_type() == get_data_type<ScalarT>(),
-                   "Error! Input view data type does not match what is stored in the field identifier.\n"
+  EKAT_REQUIRE_MSG(
+      id.data_type() == get_data_type<ScalarT>(),
+      "Error! Input view data type does not match what is stored in the field identifier.\n"
+      " - field name: " +
+          id.name() +
+          "\n"
+          " - field data type: " +
+          e2str(id.data_type()) + "\n");
+
+  const auto &fl = id.get_layout();
+  EKAT_REQUIRE_MSG(N == fl.rank(),
+                   "Error! This constructor of Field requires a device view of the correct rank.\n"
                    " - field name: " +
                        id.name() +
                        "\n"
-                       " - field data type: " +
-                       e2str(id.data_type()) + "\n");
-
-  const auto &fl = id.get_layout();
-  EKAT_REQUIRE_MSG(N == fl.rank(), "Error! This constructor of Field requires a device view of the correct rank.\n"
-                                   " - field name: " +
-                                       id.name() +
-                                       "\n"
-                                       " - field rank: " +
-                                       std::to_string(fl.rank()) +
-                                       "\n"
-                                       " - view rank : " +
-                                       std::to_string(N) + "\n");
+                       " - field rank: " +
+                       std::to_string(fl.rank()) +
+                       "\n"
+                       " - view rank : " +
+                       std::to_string(N) + "\n");
   for (int i = 0; i < (N - 1); ++i) {
-    EKAT_REQUIRE_MSG(view_d.extent_int(i) == fl.dims()[i], "Error! Input view has the wrong i-th extent.\n"
-                                                           " - field name: " +
-                                                               id.name() +
-                                                               "\n"
-                                                               " - idim: " +
-                                                               std::to_string(i) +
-                                                               "\n"
-                                                               " - layout i-th dim: " +
-                                                               std::to_string(fl.dims()[i]) +
-                                                               "\n"
-                                                               " - view i-th dim: " +
-                                                               std::to_string(view_d.extent(i)) + "\n");
+    EKAT_REQUIRE_MSG(view_d.extent_int(i) == fl.dims()[i],
+                     "Error! Input view has the wrong i-th extent.\n"
+                     " - field name: " +
+                         id.name() +
+                         "\n"
+                         " - idim: " +
+                         std::to_string(i) +
+                         "\n"
+                         " - layout i-th dim: " +
+                         std::to_string(fl.dims()[i]) +
+                         "\n"
+                         " - view i-th dim: " +
+                         std::to_string(view_d.extent(i)) + "\n");
   }
 
   auto &alloc_prop = m_header->get_alloc_properties();
   if (N > 0 and view_d.extent_int(N - 1) != fl.dims().back()) {
-    EKAT_REQUIRE_MSG(view_d.extent_int(N - 1) >= fl.dims()[N - 1], "Error! Input view has the wrong last extent.\n"
-                                                                   " - field name: " +
-                                                                       id.name() +
-                                                                       "\n"
-                                                                       " - layout last dim: " +
-                                                                       std::to_string(fl.dims()[N - 1]) +
-                                                                       "\n"
-                                                                       " - view last dim: " +
-                                                                       std::to_string(view_d.extent(N - 1)) + "\n");
+    EKAT_REQUIRE_MSG(view_d.extent_int(N - 1) >= fl.dims()[N - 1],
+                     "Error! Input view has the wrong last extent.\n"
+                     " - field name: " +
+                         id.name() +
+                         "\n"
+                         " - layout last dim: " +
+                         std::to_string(fl.dims()[N - 1]) +
+                         "\n"
+                         " - view last dim: " +
+                         std::to_string(view_d.extent(N - 1)) + "\n");
 
     // We have a padded view. We don't know what the pack size was, so we pick the largest
     // power of 2 that divides the last extent
@@ -106,7 +111,8 @@ template <typename DT, HostOrDevice HD> auto Field::get_view() const -> get_view
   constexpr int DstRankDynamic = DstView::rank_dynamic;
 
   // Make sure input field is allocated
-  EKAT_REQUIRE_MSG(is_allocated(), "Error! Cannot extract a field's view before allocation happens.\n");
+  EKAT_REQUIRE_MSG(is_allocated(),
+                   "Error! Cannot extract a field's view before allocation happens.\n");
 
   EKAT_REQUIRE_MSG(not m_is_read_only || std::is_const<DstValueType>::value,
                    "Error! Cannot get a view to non-const data if the field is read-only.\n");
@@ -116,11 +122,13 @@ template <typename DT, HostOrDevice HD> auto Field::get_view() const -> get_view
   const auto &field_layout = m_header->get_identifier().get_layout();
 
   EKAT_REQUIRE_MSG(DstRank == field_layout.rank(),
-                   "Error! You can only reshape to a view of the correct rank (equal to the FieldLayout's one).\n");
+                   "Error! You can only reshape to a view of the correct rank (equal to the "
+                   "FieldLayout's one).\n");
 
   // Check the reinterpret cast makes sense for the Dst value types (need integer sizes ratio)
-  EKAT_REQUIRE_MSG(alloc_prop.template is_compatible<DstValueType>(),
-                   "Error! Source field allocation is not compatible with the requested value type.\n");
+  EKAT_REQUIRE_MSG(
+      alloc_prop.template is_compatible<DstValueType>(),
+      "Error! Source field allocation is not compatible with the requested value type.\n");
 
   // Start by reshaping into a ND view with all dynamic extents
   const auto view_ND = get_ND_view<HD, DstValueType, DstRank>();
@@ -156,7 +164,8 @@ template <typename DT, HostOrDevice HD> auto Field::get_view() const -> get_view
   return DstView(view_ND);
 }
 
-template <typename DT, HostOrDevice HD> auto Field::get_strided_view() const -> get_strided_view_type<DT, HD> {
+template <typename DT, HostOrDevice HD>
+auto Field::get_strided_view() const -> get_strided_view_type<DT, HD> {
   // The destination view type on correct mem space
   using DstView = get_strided_view_type<DT, HD>;
   // The dst value types
@@ -170,7 +179,8 @@ template <typename DT, HostOrDevice HD> auto Field::get_strided_view() const ->
     const auto &fl         = m_header->get_identifier().get_layout();
 
     // Checks
-    EKAT_REQUIRE_MSG(is_allocated(), "Error! Cannot extract a field's view before allocation happens.\n");
+    EKAT_REQUIRE_MSG(is_allocated(),
+                     "Error! Cannot extract a field's view before allocation happens.\n");
     EKAT_REQUIRE_MSG(not m_is_read_only || std::is_const<DstValueType>::value,
                      "Error! Cannot get a view to non-const data if the field is "
                      "read-only.\n");
@@ -204,7 +214,8 @@ template <typename DT, HostOrDevice HD> auto Field::get_strided_view() const ->
         auto v_np1 = f.get_ND_view<HD, DstValueType, DstRank + 1>();
 
         // As of now, we can only single-slice subview at first or second dimension.
-        EKAT_REQUIRE_MSG(idim == 0 || idim == 1, "Error! Subview dimension index is out of bounds.\n");
+        EKAT_REQUIRE_MSG(idim == 0 || idim == 1,
+                         "Error! Subview dimension index is out of bounds.\n");
 
         // Use correct subview utility
         if (idim == 0) {
@@ -215,8 +226,9 @@ template <typename DT, HostOrDevice HD> auto Field::get_strided_view() const ->
         // k_end has been set, so we're multi-slicing
       } else if (k_end > 0) {
         // rank doesn't change for multi-slice
-        EKAT_REQUIRE_MSG(DstRank == fl.rank(), "Error! Destination view rank must be equal to parent "
-                                               "field's rank for multi-sliced subview.\n");
+        EKAT_REQUIRE_MSG(DstRank == fl.rank(),
+                         "Error! Destination view rank must be equal to parent "
+                         "field's rank for multi-sliced subview.\n");
         auto v_fullsize = f.get_ND_view<HD, DstValueType, DstRank>();
 
         return DstView(ekat::subview(v_fullsize, Kokkos::make_pair<int, int>(k, k_end), idim));
@@ -254,13 +266,16 @@ template <typename ST, HostOrDevice From, HostOrDevice To> void Field::sync_view
       Kokkos::deep_copy(DeviceExecSpace(), get_view<ST ***, To>(), get_view<const ST ***, From>());
       break;
     case 4:
-      Kokkos::deep_copy(DeviceExecSpace(), get_view<ST ****, To>(), get_view<const ST ****, From>());
+      Kokkos::deep_copy(DeviceExecSpace(), get_view<ST ****, To>(),
+                        get_view<const ST ****, From>());
       break;
     case 5:
-      Kokkos::deep_copy(DeviceExecSpace(), get_view<ST *****, To>(), get_view<const ST *****, From>());
+      Kokkos::deep_copy(DeviceExecSpace(), get_view<ST *****, To>(),
+                        get_view<const ST *****, From>());
       break;
     case 6:
-      Kokkos::deep_copy(DeviceExecSpace(), get_view<ST ******, To>(), get_view<const ST ******, From>());
+      Kokkos::deep_copy(DeviceExecSpace(), get_view<ST ******, To>(),
+                        get_view<const ST ******, From>());
       break;
     default:
       EKAT_ERROR_MSG("Error! Unsupported field rank in Field::sync_to_host.\n");
@@ -401,7 +416,8 @@ template <HostOrDevice HD, typename ST> void Field::deep_copy(const ST value, co
   }
 }
 
-template <HostOrDevice HD, bool use_mask, typename ST> void Field::deep_copy_impl(const ST value, const Field &mask) {
+template <HostOrDevice HD, bool use_mask, typename ST>
+void Field::deep_copy_impl(const ST value, const Field &mask) {
   const auto &layout = get_header().get_identifier().get_layout();
   const auto rank    = layout.rank();
   const auto &dims   = layout.dims();
@@ -413,7 +429,8 @@ template <HostOrDevice HD, bool use_mask, typename ST> void Field::deep_copy_imp
       if (contig)
         details::svm<use_mask>(get_view<ST, HD>(), value, dims, mask.get_view<const int, HD>());
       else
-        details::svm<use_mask>(get_strided_view<ST, HD>(), value, dims, mask.get_view<const int, HD>());
+        details::svm<use_mask>(get_strided_view<ST, HD>(), value, dims,
+                               mask.get_view<const int, HD>());
     } else {
       if (contig)
         details::svm<use_mask>(get_view<ST, HD>(), value, dims);
@@ -426,7 +443,8 @@ template <HostOrDevice HD, bool use_mask, typename ST> void Field::deep_copy_imp
       if (contig)
         details::svm<use_mask>(get_view<ST *, HD>(), value, dims, mask.get_view<const int *, HD>());
       else
-        details::svm<use_mask>(get_strided_view<ST *, HD>(), value, dims, mask.get_view<const int *, HD>());
+        details::svm<use_mask>(get_strided_view<ST *, HD>(), value, dims,
+                               mask.get_view<const int *, HD>());
     } else {
       if (contig)
         details::svm<use_mask>(get_view<ST *, HD>(), value, dims);
@@ -437,9 +455,11 @@ template <HostOrDevice HD, bool use_mask, typename ST> void Field::deep_copy_imp
   case 2:
     if constexpr (use_mask) {
       if (contig)
-        details::svm<use_mask>(get_view<ST **, HD>(), value, dims, mask.get_view<const int **, HD>());
+        details::svm<use_mask>(get_view<ST **, HD>(), value, dims,
+                               mask.get_view<const int **, HD>());
       else
-        details::svm<use_mask>(get_strided_view<ST **, HD>(), value, dims, mask.get_view<const int **, HD>());
+        details::svm<use_mask>(get_strided_view<ST **, HD>(), value, dims,
+                               mask.get_view<const int **, HD>());
     } else {
       if (contig)
         details::svm<use_mask>(get_view<ST **, HD>(), value, dims);
@@ -450,9 +470,11 @@ template <HostOrDevice HD, bool use_mask, typename ST> void Field::deep_copy_imp
   case 3:
     if constexpr (use_mask) {
       if (contig)
-        details::svm<use_mask>(get_view<ST ***, HD>(), value, dims, mask.get_view<const int ***, HD>());
+        details::svm<use_mask>(get_view<ST ***, HD>(), value, dims,
+                               mask.get_view<const int ***, HD>());
       else
-        details::svm<use_mask>(get_strided_view<ST ***, HD>(), value, dims, mask.get_view<const int ***, HD>());
+        details::svm<use_mask>(get_strided_view<ST ***, HD>(), value, dims,
+                               mask.get_view<const int ***, HD>());
     } else {
       if (contig)
         details::svm<use_mask>(get_view<ST ***, HD>(), value, dims);
@@ -463,9 +485,11 @@ template <HostOrDevice HD, bool use_mask, typename ST> void Field::deep_copy_imp
   case 4:
     if constexpr (use_mask) {
       if (contig)
-        details::svm<use_mask>(get_view<ST ****, HD>(), value, dims, mask.get_view<const int ****, HD>());
+        details::svm<use_mask>(get_view<ST ****, HD>(), value, dims,
+                               mask.get_view<const int ****, HD>());
       else
-        details::svm<use_mask>(get_strided_view<ST ****, HD>(), value, dims, mask.get_view<const int ****, HD>());
+        details::svm<use_mask>(get_strided_view<ST ****, HD>(), value, dims,
+                               mask.get_view<const int ****, HD>());
     } else {
       if (contig)
         details::svm<use_mask>(get_view<ST ****, HD>(), value, dims);
@@ -476,9 +500,11 @@ template <HostOrDevice HD, bool use_mask, typename ST> void Field::deep_copy_imp
   case 5:
     if constexpr (use_mask) {
       if (contig)
-        details::svm<use_mask>(get_view<ST *****, HD>(), value, dims, mask.get_view<const int *****, HD>());
+        details::svm<use_mask>(get_view<ST *****, HD>(), value, dims,
+                               mask.get_view<const int *****, HD>());
       else
-        details::svm<use_mask>(get_strided_view<ST *****, HD>(), value, dims, mask.get_view<const int *****, HD>());
+        details::svm<use_mask>(get_strided_view<ST *****, HD>(), value, dims,
+                               mask.get_view<const int *****, HD>());
     } else {
       if (contig)
         details::svm<use_mask>(get_view<ST *****, HD>(), value, dims);
@@ -489,9 +515,11 @@ template <HostOrDevice HD, bool use_mask, typename ST> void Field::deep_copy_imp
   case 6:
     if constexpr (use_mask) {
       if (contig)
-        details::svm<use_mask>(get_view<ST ******, HD>(), value, dims, mask.get_view<const int ******, HD>());
+        details::svm<use_mask>(get_view<ST ******, HD>(), value, dims,
+                               mask.get_view<const int ******, HD>());
       else
-        details::svm<use_mask>(get_strided_view<ST ******, HD>(), value, dims, mask.get_view<const int ******, HD>());
+        details::svm<use_mask>(get_strided_view<ST ******, HD>(), value, dims,
+                               mask.get_view<const int ******, HD>());
     } else {
       if (contig)
         details::svm<use_mask>(get_view<ST ******, HD>(), value, dims);
@@ -521,28 +549,31 @@ void Field::update(const Field &x, const ST alpha, const ST beta) {
   // will use such large factors).
   // Similarly, we allow updating a field Y with another X as long as converting the data type of X
   // to the data type of Y does not require narrowing
-  EKAT_REQUIRE_MSG(not is_narrowing_conversion(dt_st, dt),
-                   "Error! Coefficients alpha/beta may be narrowed when converted to x/y data type.\n"
-                   " - x/y data type  : " +
-                       e2str(dt) +
-                       "\n"
-                       " - coeff data type: " +
-                       e2str(dt_st) + "\n");
-  EKAT_REQUIRE_MSG(not is_narrowing_conversion(rhs_dt, dt),
-                   "Error! Right hand side data type may be narrowed when converted to x data type.\n"
-                   " - rhs data type: " +
-                       e2str(rhs_dt) +
-                       "\n"
-                       " - lhs data type: " +
-                       e2str(dt) + "\n");
+  EKAT_REQUIRE_MSG(
+      not is_narrowing_conversion(dt_st, dt),
+      "Error! Coefficients alpha/beta may be narrowed when converted to x/y data type.\n"
+      " - x/y data type  : " +
+          e2str(dt) +
+          "\n"
+          " - coeff data type: " +
+          e2str(dt_st) + "\n");
+  EKAT_REQUIRE_MSG(
+      not is_narrowing_conversion(rhs_dt, dt),
+      "Error! Right hand side data type may be narrowed when converted to x data type.\n"
+      " - rhs data type: " +
+          e2str(rhs_dt) +
+          "\n"
+          " - lhs data type: " +
+          e2str(dt) + "\n");
 
   // Check x/y are allocated
   EKAT_REQUIRE_MSG(is_allocated(), "Error! Cannot update field, since it is not allocated.\n"
                                    " - field name: " +
                                        name() + "\n");
-  EKAT_REQUIRE_MSG(x.is_allocated(), "Error! Cannot update field, since source field is not allocated.\n"
-                                     " - field name: " +
-                                         x.name() + "\n");
+  EKAT_REQUIRE_MSG(x.is_allocated(),
+                   "Error! Cannot update field, since source field is not allocated.\n"
+                   " - field name: " +
+                       x.name() + "\n");
 
   const auto &y_l = get_header().get_identifier().get_layout();
   const auto &x_l = x.get_header().get_identifier().get_layout();
@@ -560,7 +591,8 @@ void Field::update(const Field &x, const ST alpha, const ST beta) {
                                    y_l.to_string() + "\n");
 
   // Determine if there is a FillValue that requires extra treatment.
-  bool use_fill = get_header().has_extra_data("mask_value") or x.get_header().has_extra_data("mask_value");
+  bool use_fill =
+      get_header().has_extra_data("mask_value") or x.get_header().has_extra_data("mask_value");
 
   if (dt == DataType::IntType) {
     if (use_fill) {
@@ -629,95 +661,109 @@ void Field::update_impl(const Field &x, const ST alpha, const ST beta) {
   switch (layout.rank()) {
   case 0:
     if (x_contig and y_contig)
-      details::cvh<CM, use_fill>(get_view<ST, HD>(), x.get_view<const XST, HD>(), alpha, beta, fill_val, dims);
+      details::cvh<CM, use_fill>(get_view<ST, HD>(), x.get_view<const XST, HD>(), alpha, beta,
+                                 fill_val, dims);
     else if (x_contig)
-      details::cvh<CM, use_fill>(get_strided_view<ST, HD>(), x.get_view<const XST, HD>(), alpha, beta, fill_val, dims);
+      details::cvh<CM, use_fill>(get_strided_view<ST, HD>(), x.get_view<const XST, HD>(), alpha,
+                                 beta, fill_val, dims);
     else if (y_contig)
-      details::cvh<CM, use_fill>(get_view<ST, HD>(), x.get_strided_view<const XST, HD>(), alpha, beta, fill_val, dims);
+      details::cvh<CM, use_fill>(get_view<ST, HD>(), x.get_strided_view<const XST, HD>(), alpha,
+                                 beta, fill_val, dims);
     else
-      details::cvh<CM, use_fill>(get_strided_view<ST, HD>(), x.get_strided_view<const XST, HD>(), alpha, beta, fill_val,
-                                 dims);
+      details::cvh<CM, use_fill>(get_strided_view<ST, HD>(), x.get_strided_view<const XST, HD>(),
+                                 alpha, beta, fill_val, dims);
     break;
   case 1:
     if (x_contig and y_contig)
-      details::cvh<CM, use_fill>(get_view<ST *, HD>(), x.get_view<const XST *, HD>(), alpha, beta, fill_val, dims);
-    else if (x_contig)
-      details::cvh<CM, use_fill>(get_strided_view<ST *, HD>(), x.get_view<const XST *, HD>(), alpha, beta, fill_val,
-                                 dims);
-    else if (y_contig)
-      details::cvh<CM, use_fill>(get_view<ST *, HD>(), x.get_strided_view<const XST *, HD>(), alpha, beta, fill_val,
-                                 dims);
-    else
-      details::cvh<CM, use_fill>(get_strided_view<ST *, HD>(), x.get_strided_view<const XST *, HD>(), alpha, beta,
+      details::cvh<CM, use_fill>(get_view<ST *, HD>(), x.get_view<const XST *, HD>(), alpha, beta,
                                  fill_val, dims);
+    else if (x_contig)
+      details::cvh<CM, use_fill>(get_strided_view<ST *, HD>(), x.get_view<const XST *, HD>(), alpha,
+                                 beta, fill_val, dims);
+    else if (y_contig)
+      details::cvh<CM, use_fill>(get_view<ST *, HD>(), x.get_strided_view<const XST *, HD>(), alpha,
+                                 beta, fill_val, dims);
+    else
+      details::cvh<CM, use_fill>(get_strided_view<ST *, HD>(),
+                                 x.get_strided_view<const XST *, HD>(), alpha, beta, fill_val,
+                                 dims);
     break;
   case 2:
     if (x_contig and y_contig)
-      details::cvh<CM, use_fill>(get_view<ST **, HD>(), x.get_view<const XST **, HD>(), alpha, beta, fill_val, dims);
-    else if (x_contig)
-      details::cvh<CM, use_fill>(get_strided_view<ST **, HD>(), x.get_view<const XST **, HD>(), alpha, beta, fill_val,
-                                 dims);
-    else if (y_contig)
-      details::cvh<CM, use_fill>(get_view<ST **, HD>(), x.get_strided_view<const XST **, HD>(), alpha, beta, fill_val,
-                                 dims);
-    else
-      details::cvh<CM, use_fill>(get_strided_view<ST **, HD>(), x.get_strided_view<const XST **, HD>(), alpha, beta,
+      details::cvh<CM, use_fill>(get_view<ST **, HD>(), x.get_view<const XST **, HD>(), alpha, beta,
                                  fill_val, dims);
+    else if (x_contig)
+      details::cvh<CM, use_fill>(get_strided_view<ST **, HD>(), x.get_view<const XST **, HD>(),
+                                 alpha, beta, fill_val, dims);
+    else if (y_contig)
+      details::cvh<CM, use_fill>(get_view<ST **, HD>(), x.get_strided_view<const XST **, HD>(),
+                                 alpha, beta, fill_val, dims);
+    else
+      details::cvh<CM, use_fill>(get_strided_view<ST **, HD>(),
+                                 x.get_strided_view<const XST **, HD>(), alpha, beta, fill_val,
+                                 dims);
     break;
   case 3:
     if (x_contig and y_contig)
-      details::cvh<CM, use_fill>(get_view<ST ***, HD>(), x.get_view<const XST ***, HD>(), alpha, beta, fill_val, dims);
+      details::cvh<CM, use_fill>(get_view<ST ***, HD>(), x.get_view<const XST ***, HD>(), alpha,
+                                 beta, fill_val, dims);
     else if (x_contig)
-      details::cvh<CM, use_fill>(get_strided_view<ST ***, HD>(), x.get_view<const XST ***, HD>(), alpha, beta, fill_val,
-                                 dims);
+      details::cvh<CM, use_fill>(get_strided_view<ST ***, HD>(), x.get_view<const XST ***, HD>(),
+                                 alpha, beta, fill_val, dims);
     else if (y_contig)
-      details::cvh<CM, use_fill>(get_view<ST ***, HD>(), x.get_strided_view<const XST ***, HD>(), alpha, beta, fill_val,
-                                 dims);
+      details::cvh<CM, use_fill>(get_view<ST ***, HD>(), x.get_strided_view<const XST ***, HD>(),
+                                 alpha, beta, fill_val, dims);
     else
-      details::cvh<CM, use_fill>(get_strided_view<ST ***, HD>(), x.get_strided_view<const XST ***, HD>(), alpha, beta,
-                                 fill_val, dims);
+      details::cvh<CM, use_fill>(get_strided_view<ST ***, HD>(),
+                                 x.get_strided_view<const XST ***, HD>(), alpha, beta, fill_val,
+                                 dims);
     break;
   case 4:
     if (x_contig and y_contig)
-      details::cvh<CM, use_fill>(get_view<ST ****, HD>(), x.get_view<const XST ****, HD>(), alpha, beta, fill_val,
-                                 dims);
+      details::cvh<CM, use_fill>(get_view<ST ****, HD>(), x.get_view<const XST ****, HD>(), alpha,
+                                 beta, fill_val, dims);
     else if (x_contig)
-      details::cvh<CM, use_fill>(get_strided_view<ST ****, HD>(), x.get_view<const XST ****, HD>(), alpha, beta,
-                                 fill_val, dims);
+      details::cvh<CM, use_fill>(get_strided_view<ST ****, HD>(), x.get_view<const XST ****, HD>(),
+                                 alpha, beta, fill_val, dims);
     else if (y_contig)
-      details::cvh<CM, use_fill>(get_view<ST ****, HD>(), x.get_strided_view<const XST ****, HD>(), alpha, beta,
-                                 fill_val, dims);
+      details::cvh<CM, use_fill>(get_view<ST ****, HD>(), x.get_strided_view<const XST ****, HD>(),
+                                 alpha, beta, fill_val, dims);
     else
-      details::cvh<CM, use_fill>(get_strided_view<ST ****, HD>(), x.get_strided_view<const XST ****, HD>(), alpha, beta,
-                                 fill_val, dims);
+      details::cvh<CM, use_fill>(get_strided_view<ST ****, HD>(),
+                                 x.get_strided_view<const XST ****, HD>(), alpha, beta, fill_val,
+                                 dims);
     break;
   case 5:
     if (x_contig and y_contig)
-      details::cvh<CM, use_fill>(get_view<ST *****, HD>(), x.get_view<const XST *****, HD>(), alpha, beta, fill_val,
-                                 dims);
-    else if (x_contig)
-      details::cvh<CM, use_fill>(get_strided_view<ST *****, HD>(), x.get_view<const XST *****, HD>(), alpha, beta,
-                                 fill_val, dims);
-    else if (y_contig)
-      details::cvh<CM, use_fill>(get_view<ST *****, HD>(), x.get_strided_view<const XST *****, HD>(), alpha, beta,
-                                 fill_val, dims);
-    else
-      details::cvh<CM, use_fill>(get_strided_view<ST *****, HD>(), x.get_strided_view<const XST *****, HD>(), alpha,
+      details::cvh<CM, use_fill>(get_view<ST *****, HD>(), x.get_view<const XST *****, HD>(), alpha,
                                  beta, fill_val, dims);
+    else if (x_contig)
+      details::cvh<CM, use_fill>(get_strided_view<ST *****, HD>(),
+                                 x.get_view<const XST *****, HD>(), alpha, beta, fill_val, dims);
+    else if (y_contig)
+      details::cvh<CM, use_fill>(get_view<ST *****, HD>(),
+                                 x.get_strided_view<const XST *****, HD>(), alpha, beta, fill_val,
+                                 dims);
+    else
+      details::cvh<CM, use_fill>(get_strided_view<ST *****, HD>(),
+                                 x.get_strided_view<const XST *****, HD>(), alpha, beta, fill_val,
+                                 dims);
     break;
   case 6:
     if (x_contig and y_contig)
-      details::cvh<CM, use_fill>(get_view<ST ******, HD>(), x.get_view<const XST ******, HD>(), alpha, beta, fill_val,
-                                 dims);
+      details::cvh<CM, use_fill>(get_view<ST ******, HD>(), x.get_view<const XST ******, HD>(),
+                                 alpha, beta, fill_val, dims);
     else if (x_contig)
-      details::cvh<CM, use_fill>(get_strided_view<ST ******, HD>(), x.get_view<const XST ******, HD>(), alpha, beta,
-                                 fill_val, dims);
+      details::cvh<CM, use_fill>(get_strided_view<ST ******, HD>(),
+                                 x.get_view<const XST ******, HD>(), alpha, beta, fill_val, dims);
     else if (y_contig)
-      details::cvh<CM, use_fill>(get_view<ST ******, HD>(), x.get_strided_view<const XST ******, HD>(), alpha, beta,
-                                 fill_val, dims);
+      details::cvh<CM, use_fill>(get_view<ST ******, HD>(),
+                                 x.get_strided_view<const XST ******, HD>(), alpha, beta, fill_val,
+                                 dims);
     else
-      details::cvh<CM, use_fill>(get_strided_view<ST ******, HD>(), x.get_strided_view<const XST ******, HD>(), alpha,
-                                 beta, fill_val, dims);
+      details::cvh<CM, use_fill>(get_strided_view<ST ******, HD>(),
+                                 x.get_strided_view<const XST ******, HD>(), alpha, beta, fill_val,
+                                 dims);
     break;
   default:
     EKAT_ERROR_MSG("Error! Rank not supported in update_field.\n"
@@ -756,8 +802,9 @@ auto Field::get_ND_view() const -> if_t<(N < MaxRank), get_view_type<data_nd_t<T
     // So far we can only subview at first or second dimension.
     EKAT_REQUIRE_MSG(idim == 0 || idim == 1, "Error! Subview dimension index is out of bounds.\n");
 
-    EKAT_REQUIRE_MSG(idim == 0 || N > 1, "Error! Cannot subview a rank-2 (or less) view along 2nd dimension "
-                                         "without losing LayoutRight.\n");
+    EKAT_REQUIRE_MSG(idim == 0 || N > 1,
+                     "Error! Cannot subview a rank-2 (or less) view along 2nd dimension "
+                     "without losing LayoutRight.\n");
 
     // Use SFINAE-ed get_subview helper function to pick correct
     // subview impl. If N+1<=2 and idim!=0, the code craps out in the check above.
@@ -796,8 +843,9 @@ auto Field::get_ND_view() const -> if_t<N == MaxRank, get_view_type<data_nd_t<T,
                    "Error! Input Rank must either be 1 (flat array) or the actual field rank.\n");
 
   // Given that N==MaxRank, this field cannot be a subview of another field
-  EKAT_REQUIRE_MSG(m_header->get_parent() == nullptr, "Error! A view of rank " + std::to_string(MaxRank) +
-                                                          " should not be the subview of another field.\n");
+  EKAT_REQUIRE_MSG(m_header->get_parent() == nullptr,
+                   "Error! A view of rank " + std::to_string(MaxRank) +
+                       " should not be the subview of another field.\n");
 
   // Compute extents from FieldLayout
   const auto &alloc_prop = m_header->get_alloc_properties();
diff --git i/components/eamxx/src/share/field/field_impl_details.hpp w/components/eamxx/src/share/field/field_impl_details.hpp
index 604ea3b658..407529314f 100644
--- i/components/eamxx/src/share/field/field_impl_details.hpp
+++ w/components/eamxx/src/share/field/field_impl_details.hpp
@@ -9,14 +9,17 @@ namespace scream {
 
 namespace details {
 
-template <CombineMode CM, bool use_fill, typename LhsView, typename RhsView, typename ST> struct CombineViewsHelper {
+template <CombineMode CM, bool use_fill, typename LhsView, typename RhsView, typename ST>
+struct CombineViewsHelper {
 
   using exec_space = typename LhsView::traits::execution_space;
 
   static constexpr int N = LhsView::rank();
 
   template <int M>
-  using MDRange = Kokkos::MDRangePolicy<exec_space, Kokkos::Rank<M, Kokkos::Iterate::Right, Kokkos::Iterate::Right>>;
+  using MDRange =
+      Kokkos::MDRangePolicy<exec_space,
+                            Kokkos::Rank<M, Kokkos::Iterate::Right, Kokkos::Iterate::Right>>;
 
   void run(const std::vector<int> &dims) const {
     if constexpr (N == 0) {
@@ -125,7 +128,9 @@ template <typename LhsView, typename MaskView, bool use_mask> struct SetValueMas
   static constexpr int N = LhsView::rank();
 
   template <int M>
-  using MDRange = Kokkos::MDRangePolicy<exec_space, Kokkos::Rank<M, Kokkos::Iterate::Right, Kokkos::Iterate::Right>>;
+  using MDRange =
+      Kokkos::MDRangePolicy<exec_space,
+                            Kokkos::Rank<M, Kokkos::Iterate::Right, Kokkos::Iterate::Right>>;
 
   void run(const std::vector<int> &dims) const {
     if constexpr (N == 0) {
@@ -208,8 +213,9 @@ void svm(LhsView lhs, typename LhsView::traits::value_type value, const std::vec
   helper.mask  = mask;
   helper.value = value;
 
-  EKAT_REQUIRE_MSG(not use_mask or mask.data() != nullptr,
-                   "Error! Calling scream::details::svm with use_mask=true, but input mask view is invalid.\n");
+  EKAT_REQUIRE_MSG(
+      not use_mask or mask.data() != nullptr,
+      "Error! Calling scream::details::svm with use_mask=true, but input mask view is invalid.\n");
 
   helper.run(dims);
 }
diff --git i/components/eamxx/src/share/field/field_layout.cpp w/components/eamxx/src/share/field/field_layout.cpp
index d2a84243c7..34c9134a0b 100644
--- i/components/eamxx/src/share/field/field_layout.cpp
+++ w/components/eamxx/src/share/field/field_layout.cpp
@@ -23,12 +23,13 @@ FieldLayout::FieldLayout(const std::vector<FieldTag> &tags, const std::vector<in
                                                    "  dims size: " +
                                                    std::to_string(dims.size()) + "\n");
 
-  EKAT_REQUIRE_MSG(names.size() == tags.size(), "Error! Tags and names vectors dimensions mismatch.\n"
-                                                "  tags size : " +
-                                                    std::to_string(tags.size()) +
-                                                    "\n"
-                                                    "  names size: " +
-                                                    std::to_string(names.size()) + "\n");
+  EKAT_REQUIRE_MSG(names.size() == tags.size(),
+                   "Error! Tags and names vectors dimensions mismatch.\n"
+                   "  tags size : " +
+                       std::to_string(tags.size()) +
+                       "\n"
+                       "  names size: " +
+                       std::to_string(names.size()) + "\n");
 
   set_extents();
   compute_type();
@@ -39,15 +40,18 @@ bool FieldLayout::is_vector_layout() const {
   return ekat::count(m_tags, CMP) == 1;
 }
 
-bool FieldLayout::is_tensor_layout() const { return m_type == LayoutType::Tensor2D || m_type == LayoutType::Tensor3D; }
+bool FieldLayout::is_tensor_layout() const {
+  return m_type == LayoutType::Tensor2D || m_type == LayoutType::Tensor3D;
+}
 
 // get the index of the CMP (Components) tag in the FieldLayout
 // e.g., for FieldLayout f({COL, CMP, LEV}, {...});
 // we have get_vector_component_idx(f) = 1
 int FieldLayout::get_vector_component_idx() const {
-  EKAT_REQUIRE_MSG(is_vector_layout(), "Error! 'get_vector_dim' available only for vector layouts.\n"
-                                       "       Current layout: " +
-                                           e2str(type()) + "\n");
+  EKAT_REQUIRE_MSG(is_vector_layout(),
+                   "Error! 'get_vector_dim' available only for vector layouts.\n"
+                   "       Current layout: " +
+                       e2str(type()) + "\n");
 
   using namespace ShortFieldTagsNames;
   return std::distance(m_tags.begin(), ekat::find(m_tags, CMP));
@@ -65,12 +69,13 @@ int FieldLayout::get_vector_dim() const {
 FieldTag FieldLayout::get_vector_tag() const { return m_tags[get_vector_component_idx()]; }
 
 std::vector<int> FieldLayout::get_tensor_components_ids() const {
-  EKAT_REQUIRE_MSG(is_tensor_layout(), "Error! 'get_tensor_dims' available only for tensor layouts.\n"
-                                       "       Current layout: " +
-                                           to_string() +
-                                           "\n"
-                                           "       Layout type   : " +
-                                           e2str(m_type) + "\n");
+  EKAT_REQUIRE_MSG(is_tensor_layout(),
+                   "Error! 'get_tensor_dims' available only for tensor layouts.\n"
+                   "       Current layout: " +
+                       to_string() +
+                       "\n"
+                       "       Layout type   : " +
+                       e2str(m_type) + "\n");
 
   using namespace ShortFieldTagsNames;
 
@@ -117,23 +122,25 @@ FieldLayout &FieldLayout::strip_dim(const FieldTag t, const bool throw_if_not_fo
     }
   }
 
-  EKAT_REQUIRE_MSG(any_match or not throw_if_not_found, "Error! No match found when attempting to strip dim.\n"
-                                                        "  - input tag: " +
-                                                            e2str(t) +
-                                                            "\n"
-                                                            "  - layout   : " +
-                                                            to_string() + "\n");
+  EKAT_REQUIRE_MSG(any_match or not throw_if_not_found,
+                   "Error! No match found when attempting to strip dim.\n"
+                   "  - input tag: " +
+                       e2str(t) +
+                       "\n"
+                       "  - layout   : " +
+                       to_string() + "\n");
 
   return *this;
 }
 
 FieldLayout &FieldLayout::strip_dim(const int idim) {
-  EKAT_REQUIRE_MSG(idim >= 0 and idim < m_rank, "Error! Cannot strip dimension, because it is out of bounds.\n"
-                                                "  - input dim index: " +
-                                                    std::to_string(idim) +
-                                                    "\n"
-                                                    "  - layout rank    : " +
-                                                    std::to_string(m_rank) + "\n");
+  EKAT_REQUIRE_MSG(idim >= 0 and idim < m_rank,
+                   "Error! Cannot strip dimension, because it is out of bounds.\n"
+                   "  - input dim index: " +
+                       std::to_string(idim) +
+                       "\n"
+                       "  - layout rank    : " +
+                       std::to_string(m_rank) + "\n");
 
   m_tags.erase(m_tags.begin() + idim);
   m_names.erase(m_names.begin() + idim);
@@ -145,7 +152,9 @@ FieldLayout &FieldLayout::strip_dim(const int idim) {
   return *this;
 }
 
-FieldLayout &FieldLayout::append_dim(const FieldTag t, const int extent) { return append_dim(t, extent, e2str(t)); }
+FieldLayout &FieldLayout::append_dim(const FieldTag t, const int extent) {
+  return append_dim(t, extent, e2str(t));
+}
 
 FieldLayout &FieldLayout::append_dim(const FieldTag t, const int extent, const std::string &name) {
   m_tags.push_back(t);
@@ -167,7 +176,8 @@ FieldLayout &FieldLayout::rename_dim(const int idim, const std::string &n) {
   return *this;
 }
 
-FieldLayout &FieldLayout::rename_dim(const FieldTag t, const std::string &n, const bool throw_if_not_found) {
+FieldLayout &FieldLayout::rename_dim(const FieldTag t, const std::string &n,
+                                     const bool throw_if_not_found) {
   bool any_match = false;
   for (int i = 0; i < rank(); ++i) {
     if (m_tags[i] == t) {
@@ -176,12 +186,13 @@ FieldLayout &FieldLayout::rename_dim(const FieldTag t, const std::string &n, con
     }
   }
 
-  EKAT_REQUIRE_MSG(any_match or not throw_if_not_found, "Error! No match found when attempting to rename dim.\n"
-                                                        "  - input tag: " +
-                                                            e2str(t) +
-                                                            "\n"
-                                                            "  - layout   : " +
-                                                            to_string() + "\n");
+  EKAT_REQUIRE_MSG(any_match or not throw_if_not_found,
+                   "Error! No match found when attempting to rename dim.\n"
+                   "  - input tag: " +
+                       e2str(t) +
+                       "\n"
+                       "  - layout   : " +
+                       to_string() + "\n");
 
   return *this;
 }
@@ -211,7 +222,8 @@ FieldLayout &FieldLayout::reset_dim(const int idim, const int extent) {
   return *this;
 }
 
-FieldLayout &FieldLayout::reset_dim(const FieldTag t, const int extent, const bool throw_if_not_found) {
+FieldLayout &FieldLayout::reset_dim(const FieldTag t, const int extent,
+                                    const bool throw_if_not_found) {
   bool any_match = false;
   for (int i = 0; i < rank(); ++i) {
     if (m_tags[i] == t) {
diff --git i/components/eamxx/src/share/field/field_layout.hpp w/components/eamxx/src/share/field/field_layout.hpp
index 7de09b3712..d078c9bf3f 100644
--- i/components/eamxx/src/share/field/field_layout.hpp
+++ w/components/eamxx/src/share/field/field_layout.hpp
@@ -87,7 +87,8 @@ public:
   FieldLayout();
   FieldLayout(const FieldLayout &) = default;
   FieldLayout(const std::vector<FieldTag> &tags, const std::vector<int> &dims);
-  FieldLayout(const std::vector<FieldTag> &tags, const std::vector<int> &dims, const std::vector<std::string> &names);
+  FieldLayout(const std::vector<FieldTag> &tags, const std::vector<int> &dims,
+              const std::vector<std::string> &names);
 
   // Assignment (defaulted)
   FieldLayout &operator=(const FieldLayout &) = default;
@@ -151,13 +152,16 @@ public:
   FieldLayout &append_dim(const FieldTag t, const int extent);
   FieldLayout &append_dim(const FieldTag t, const int extent, const std::string &name);
   FieldLayout &rename_dim(const int idim, const std::string &n);
-  FieldLayout &rename_dim(const FieldTag tag, const std::string &n, const bool throw_if_not_found = true);
+  FieldLayout &rename_dim(const FieldTag tag, const std::string &n,
+                          const bool throw_if_not_found = true);
   FieldLayout &reset_dim(const int idim, const int extent);
   FieldLayout &reset_dim(const FieldTag t, const int extent, const bool throw_if_not_found = true);
 
-  // These overload allow to remove/rename dims *if found*. They won't throw if layout does not have them
-  FieldLayout &strip_dims(const std::vector<FieldTag> &tags);                 // Does not throw if not found
-  FieldLayout &rename_dims(const std::map<FieldTag, std::string> &new_names); // Does not throw if not found
+  // These overload allow to remove/rename dims *if found*. They won't throw if layout does not have
+  // them
+  FieldLayout &strip_dims(const std::vector<FieldTag> &tags); // Does not throw if not found
+  FieldLayout &
+  rename_dims(const std::map<FieldTag, std::string> &new_names); // Does not throw if not found
 
   FieldLayout clone() const;
 
@@ -188,12 +192,13 @@ bool operator==(const FieldLayout &fl1, const FieldLayout &fl2);
 
 inline int FieldLayout::dim_idx(const FieldTag t) const {
   // Check exactly one tag (no ambiguity)
-  EKAT_REQUIRE_MSG(ekat::count(m_tags, t) == 1, "Error! FieldTag::dim_idx requires that the tag appears exactly once.\n"
-                                                "  - field tag: " +
-                                                    e2str(t) +
-                                                    "\n"
-                                                    "  - tag count: " +
-                                                    std::to_string(ekat::count(m_tags, t)) + "\n");
+  EKAT_REQUIRE_MSG(ekat::count(m_tags, t) == 1,
+                   "Error! FieldTag::dim_idx requires that the tag appears exactly once.\n"
+                   "  - field tag: " +
+                       e2str(t) +
+                       "\n"
+                       "  - tag count: " +
+                       std::to_string(ekat::count(m_tags, t)) + "\n");
 
   return std::distance(m_tags.begin(), ekat::find(m_tags, t));
 }
diff --git i/components/eamxx/src/share/field/field_manager.cpp w/components/eamxx/src/share/field/field_manager.cpp
index 4d0e3ab0dd..7ba602da83 100644
--- i/components/eamxx/src/share/field/field_manager.cpp
+++ w/components/eamxx/src/share/field/field_manager.cpp
@@ -25,10 +25,12 @@ void FieldManager::register_field(const FieldRequest &req) {
   const auto &grid_name = id.get_grid_name();
 
   // Sanity checks
-  EKAT_REQUIRE_MSG(m_repo_state != RepoState::Clean,
-                   "Error! Repo state is not 'Open' yet. You must call registration_begins() first.\n");
-  EKAT_REQUIRE_MSG(m_repo_state != RepoState::Closed,
-                   "Error! Repo state is not 'Open' anymore. You already called registration_ends().\n");
+  EKAT_REQUIRE_MSG(
+      m_repo_state != RepoState::Clean,
+      "Error! Repo state is not 'Open' yet. You must call registration_begins() first.\n");
+  EKAT_REQUIRE_MSG(
+      m_repo_state != RepoState::Closed,
+      "Error! Repo state is not 'Open' anymore. You already called registration_ends().\n");
 
   // Make sure this FM contains a grid corresponding to the input grid name
   EKAT_REQUIRE_MSG(m_grids_mgr->has_grid(grid_name),
@@ -40,7 +42,8 @@ void FieldManager::register_field(const FieldRequest &req) {
                        m_grids_mgr->print_available_grids() + "\n");
 
   // FieldManager does not allow incomplete requests
-  EKAT_REQUIRE_MSG(not req.incomplete, "Error! FieldManager does not allow registering incomplete FieldRequest.\n");
+  EKAT_REQUIRE_MSG(not req.incomplete,
+                   "Error! FieldManager does not allow registering incomplete FieldRequest.\n");
 
   // Get or create the new field
   if (!has_field(id.name(), grid_name)) {
@@ -55,32 +58,34 @@ void FieldManager::register_field(const FieldRequest &req) {
     //       However, in the future, we *may* allow different units, providing
     //       the users with conversion routines perhaps.
     const auto id0 = m_fields[grid_name][id.name()]->get_header().get_identifier();
-    EKAT_REQUIRE_MSG(id.get_units() == id0.get_units(),
-                     "Error! Field '" + id.name() +
-                         "' already registered with different units:\n"
-                         "         - input field units:  " +
-                         id.get_units().to_string() +
-                         "\n"
-                         "         - stored field units: " +
-                         id0.get_units().to_string() +
-                         "\n"
-                         "       Please, check and make sure all atmosphere processes use the same units.\n");
-
     EKAT_REQUIRE_MSG(
-        id.get_layout() == id0.get_layout(),
+        id.get_units() == id0.get_units(),
         "Error! Field '" + id.name() +
-            "' already registered with different layout:\n"
-            "         - input id:  " +
-            id.get_id_string() +
+            "' already registered with different units:\n"
+            "         - input field units:  " +
+            id.get_units().to_string() +
             "\n"
-            "         - stored id: " +
-            id0.get_id_string() +
+            "         - stored field units: " +
+            id0.get_units().to_string() +
             "\n"
-            "       Please, check and make sure all atmosphere processes use the same layout for a given field.\n");
+            "       Please, check and make sure all atmosphere processes use the same units.\n");
+
+    EKAT_REQUIRE_MSG(id.get_layout() == id0.get_layout(),
+                     "Error! Field '" + id.name() +
+                         "' already registered with different layout:\n"
+                         "         - input id:  " +
+                         id.get_id_string() +
+                         "\n"
+                         "         - stored id: " +
+                         id0.get_id_string() +
+                         "\n"
+                         "       Please, check and make sure all atmosphere processes use the same "
+                         "layout for a given field.\n");
   }
 
   // Make sure the field can accommodate the requested value type
-  m_fields[grid_name][id.name()]->get_header().get_alloc_properties().request_allocation(req.pack_size);
+  m_fields[grid_name][id.name()]->get_header().get_alloc_properties().request_allocation(
+      req.pack_size);
 
   // Finally, add the field to the given groups
   // Note: we do *not* set the group info struct in the field header yet.
@@ -105,7 +110,8 @@ void FieldManager::register_field(const FieldRequest &req) {
     }
 
     // Ensure that each group in m_field_group_info also appears in the m_group_requests map by
-    // adding a "trivial" GroupRequest for this group, meaning no monolithic allocation and pack size 1.
+    // adding a "trivial" GroupRequest for this group, meaning no monolithic allocation and pack
+    // size 1.
     register_group(GroupRequest(group_name, grid_name));
   }
 }
@@ -139,8 +145,9 @@ void FieldManager::register_group(const GroupRequest &req) {
 
 void FieldManager::add_to_group(const std::string &field_name, const std::string &grid_name,
                                 const std::string &group_name) {
-  EKAT_REQUIRE_MSG(m_repo_state == RepoState::Closed,
-                   "Error! You cannot call 'add_to_group' until after 'registration_ends' has been called.\n");
+  EKAT_REQUIRE_MSG(
+      m_repo_state == RepoState::Closed,
+      "Error! You cannot call 'add_to_group' until after 'registration_ends' has been called.\n");
   auto &group = m_field_group_info[group_name];
   if (not group) {
     group = std::make_shared<FieldGroupInfo>(group_name);
@@ -153,16 +160,17 @@ void FieldManager::add_to_group(const std::string &field_name, const std::string
                        "   group name: " +
                        group_name + "\n");
 
-  EKAT_REQUIRE_MSG(has_field(field_name, grid_name),
-                   "Error! Cannot add field to group, since the field is not present in this FieldManager.\n"
-                   "   field name: " +
-                       field_name +
-                       "\n"
-                       "   grid name:  " +
-                       grid_name +
-                       "\n"
-                       "   group name: " +
-                       group_name + "\n");
+  EKAT_REQUIRE_MSG(
+      has_field(field_name, grid_name),
+      "Error! Cannot add field to group, since the field is not present in this FieldManager.\n"
+      "   field name: " +
+          field_name +
+          "\n"
+          "   grid name:  " +
+          grid_name +
+          "\n"
+          "   group name: " +
+          group_name + "\n");
 
   if (not ekat::contains(group->m_fields_names, field_name)) {
     group->m_fields_names.push_back(field_name);
@@ -194,45 +202,53 @@ bool FieldManager::has_group(const std::string &group_name, const std::string &g
 }
 
 Field FieldManager::get_field(const std::string &name, const std::string &grid_name) const {
-  EKAT_REQUIRE_MSG(m_repo_state == RepoState::Closed,
-                   "Error! Cannot get fields from the repo while registration has not yet completed.\n");
-  EKAT_REQUIRE_MSG(has_field(name, grid_name), "Error! Field " + name + " on grid " + grid_name + " not found.\n");
+  EKAT_REQUIRE_MSG(
+      m_repo_state == RepoState::Closed,
+      "Error! Cannot get fields from the repo while registration has not yet completed.\n");
+  EKAT_REQUIRE_MSG(has_field(name, grid_name),
+                   "Error! Field " + name + " on grid " + grid_name + " not found.\n");
 
   return *m_fields.at(grid_name).at(name);
 }
 
 Field &FieldManager::get_field(const std::string &name, const std::string &grid_name) {
-  EKAT_REQUIRE_MSG(m_repo_state == RepoState::Closed,
-                   "Error! Cannot get fields from the repo while registration has not yet completed.\n");
-  EKAT_REQUIRE_MSG(has_field(name, grid_name), "Error! Field " + name + " on grid " + grid_name + " not found.\n");
+  EKAT_REQUIRE_MSG(
+      m_repo_state == RepoState::Closed,
+      "Error! Cannot get fields from the repo while registration has not yet completed.\n");
+  EKAT_REQUIRE_MSG(has_field(name, grid_name),
+                   "Error! Field " + name + " on grid " + grid_name + " not found.\n");
 
   return *m_fields.at(grid_name).at(name);
 }
 
-FieldGroupInfo FieldManager::get_group_info(const std::string &group_name, const std::string &grid_name) const {
+FieldGroupInfo FieldManager::get_group_info(const std::string &group_name,
+                                            const std::string &grid_name) const {
   // Sanity checks
-  EKAT_REQUIRE_MSG(m_repo_state == RepoState::Closed,
-                   "Error! Cannot get field groups from the repo while registration has not yet completed.\n");
-  EKAT_REQUIRE_MSG(has_group(group_name, grid_name),
-                   "Error! Field group '" + group_name + "' on grid '" + grid_name + "' not found.\n");
+  EKAT_REQUIRE_MSG(
+      m_repo_state == RepoState::Closed,
+      "Error! Cannot get field groups from the repo while registration has not yet completed.\n");
+  EKAT_REQUIRE_MSG(has_group(group_name, grid_name), "Error! Field group '" + group_name +
+                                                         "' on grid '" + grid_name +
+                                                         "' not found.\n");
 
   auto info = *m_field_group_info.at(group_name);
 
   if (info.m_monolithic_allocation) {
     // All fields in a group with a monolithic allocation should exist on any grid in that group
     for (const auto &fname : info.m_fields_names) {
-      EKAT_REQUIRE_MSG(has_field(fname, grid_name),
-                       "Internal FieldManager Error! Groups with monolithic allocation must contain all "
-                       "fields in m_fields_names on any grid from m_grids_in_group.\n"
-                       "The following field should, but does not, exist:\n"
-                       "  - Group: " +
-                           group_name +
-                           "\n"
-                           "  - Field: " +
-                           fname +
-                           "\n"
-                           "  - Grid:  " +
-                           grid_name + "\n");
+      EKAT_REQUIRE_MSG(
+          has_field(fname, grid_name),
+          "Internal FieldManager Error! Groups with monolithic allocation must contain all "
+          "fields in m_fields_names on any grid from m_grids_in_group.\n"
+          "The following field should, but does not, exist:\n"
+          "  - Group: " +
+              group_name +
+              "\n"
+              "  - Field: " +
+              fname +
+              "\n"
+              "  - Grid:  " +
+              grid_name + "\n");
     }
   } else {
     // For all other groups, remove fields in the group
@@ -253,12 +269,15 @@ FieldGroupInfo FieldManager::get_group_info(const std::string &group_name, const
   return info;
 }
 
-FieldGroup FieldManager::get_field_group(const std::string &group_name, const std::string &grid_name) {
+FieldGroup FieldManager::get_field_group(const std::string &group_name,
+                                         const std::string &grid_name) {
   // Sanity checks
-  EKAT_REQUIRE_MSG(m_repo_state == RepoState::Closed,
-                   "Error! Cannot get field groups from the repo while registration has not yet completed.\n");
-  EKAT_REQUIRE_MSG(has_group(group_name, grid_name),
-                   "Error! Field group '" + group_name + "' on grid '" + grid_name + "' not found.\n");
+  EKAT_REQUIRE_MSG(
+      m_repo_state == RepoState::Closed,
+      "Error! Cannot get field groups from the repo while registration has not yet completed.\n");
+  EKAT_REQUIRE_MSG(has_group(group_name, grid_name), "Error! Field group '" + group_name +
+                                                         "' on grid '" + grid_name +
+                                                         "' not found.\n");
 
   // If FieldGroup has already been built, return that
   if (m_field_groups.at(grid_name).find(group_name) != m_field_groups.at(grid_name).end()) {
@@ -280,10 +299,11 @@ FieldGroup FieldManager::get_field_group(const std::string &group_name, const st
   // Fetch the monolithic field (if applicable)
   if (group->m_info->m_monolithic_allocation) {
     // All fields in a group have the same parent, get the parent from the 1st one
-    const auto &parent_header = group->m_individual_fields.begin()->second->get_header().get_parent();
+    const auto &parent_header =
+        group->m_individual_fields.begin()->second->get_header().get_parent();
 
-    EKAT_REQUIRE_MSG(parent_header != nullptr,
-                     "Error! A field belonging to a field group with monolithic allocation is missing its 'parent'.\n");
+    EKAT_REQUIRE_MSG(parent_header != nullptr, "Error! A field belonging to a field group with "
+                                               "monolithic allocation is missing its 'parent'.\n");
 
     const auto &parent_id = parent_header->get_identifier();
 
@@ -327,7 +347,8 @@ FieldGroup FieldManager::get_field_group(const std::string &group_name, const st
       // subfield of the parent group containing indices of group fields
       std::vector<int> ordered_subview_indices;
       for (auto fn : group->m_info->m_fields_names) {
-        const auto parent_child_index = m_field_group_info.at(parent_field->name())->m_subview_idx.at(fn);
+        const auto parent_child_index =
+            m_field_group_info.at(parent_field->name())->m_subview_idx.at(fn);
         ordered_subview_indices.push_back(parent_child_index);
       }
       std::sort(ordered_subview_indices.begin(), ordered_subview_indices.end());
@@ -335,11 +356,12 @@ FieldGroup FieldManager::get_field_group(const std::string &group_name, const st
       // Check that all subview indices are contiguous
       size_t span = ordered_subview_indices.back() - ordered_subview_indices.front() + 1;
       EKAT_REQUIRE_MSG(ordered_subview_indices.size() == span,
-                       "Error! Non-contiguous subview indices found in group \"" + group_name + "\"\n");
+                       "Error! Non-contiguous subview indices found in group \"" + group_name +
+                           "\"\n");
 
-      group->m_monolithic_field = std::make_shared<Field>(
-          parent_field->subfield(group_name, parent_header->get_identifier().get_units(), group->m_info->m_subview_dim,
-                                 ordered_subview_indices.front(), ordered_subview_indices.back() + 1));
+      group->m_monolithic_field = std::make_shared<Field>(parent_field->subfield(
+          group_name, parent_header->get_identifier().get_units(), group->m_info->m_subview_dim,
+          ordered_subview_indices.front(), ordered_subview_indices.back() + 1));
     }
   }
 
@@ -377,7 +399,8 @@ void FieldManager::registration_ends() {
   // For group requests on different grids, we consider the group members to be the union of all
   // fields registered to a particular group, over all grids. So if fields A and B are registered
   // as part of group G on grid1, and field C is registered as a part of G on grid2, both G on grid1
-  // and G on grid2 will contain fields A,B,C, and we ensure that the subview index matches over grids.
+  // and G on grid2 will contain fields A,B,C, and we ensure that the subview index matches over
+  // grids.
 
   // This is the sequence of operations that allows us to establish if (and how) we can honor
   // all the requests:
@@ -408,7 +431,8 @@ void FieldManager::registration_ends() {
 
   // Start by processing group request. This function checks that all group fields are properly
   // registered on the appropriate grid and the FieldGroupInfo is up to date. If group G is
-  // requested, we make sure to register the union of all fields in group G on any grids they appear.
+  // requested, we make sure to register the union of all fields in group G on any grids they
+  // appear.
   pre_process_monolithic_group_requests();
 
   // Gather a list of groups whose fields require monolithic allocation
@@ -445,10 +469,10 @@ void FieldManager::registration_ends() {
     auto it = ekat::find(groups_with_monolithic_allocation, "tracers");
     std::swap(*it, groups_with_monolithic_allocation.front());
 
-    // Adding the 'fake' group G=(qv) at the front of groups_with_monolithic_allocation ensures qv won't be put
-    // in the middle of the tracers group. We use a highly unlikely group name, to avoid clashing
-    // with a real group name. Later, after having found an global ordering for the tracers fields,
-    // we will remove this group.
+    // Adding the 'fake' group G=(qv) at the front of groups_with_monolithic_allocation ensures qv
+    // won't be put in the middle of the tracers group. We use a highly unlikely group name, to
+    // avoid clashing with a real group name. Later, after having found an global ordering for the
+    // tracers fields, we will remove this group.
     groups_with_monolithic_allocation.push_front("__qv__");
     m_field_group_info.emplace("__qv__", std::make_shared<FieldGroupInfo>("__qv__"));
     m_field_group_info.at("__qv__")->m_fields_names.push_back("qv");
@@ -531,10 +555,12 @@ void FieldManager::registration_ends() {
         EKAT_ERROR_MSG(" -- ERROR --\n");
       }
 
-      // Ok, if we got here, it means we can allocate the cluster as a field, and then subview all the groups
-      // Steps:
-      //  - check if there's a group in the cluster containing all the fields. If yes, use that group
-      //    name for the grouped field, otherwise make one up from the names of all groups in the cluster.
+      // Ok, if we got here, it means we can allocate the cluster as a field, and then subview all
+      // the groups Steps:
+      //  - check if there's a group in the cluster containing all the fields. If yes, use that
+      //  group
+      //    name for the grouped field, otherwise make one up from the names of all groups in the
+      //    cluster.
       //  - allocate the cluster field F.
       //  - loop over the groups in the cluster, and subview F at the proper (contiguous) indices.
 
@@ -544,10 +570,12 @@ void FieldManager::registration_ends() {
         auto qv_it = ekat::find(cluster_ordered_fields, "qv");
         if (qv_it != cluster_ordered_fields.end()) {
           // Check that qv comes first or last (if last, reverse the list). If not, error out.
-          // NOTE: I *think* this should not happen, unless 'tracers' is a subgroup of a bigger group.
-          EKAT_REQUIRE_MSG(qv_it == cluster_ordered_fields.begin() ||
-                               std::next(qv_it, 1) == cluster_ordered_fields.end(),
-                           "Error! The water vapor field has to be the first tracer, but it is not.\n");
+          // NOTE: I *think* this should not happen, unless 'tracers' is a subgroup of a bigger
+          // group.
+          EKAT_REQUIRE_MSG(
+              qv_it == cluster_ordered_fields.begin() ||
+                  std::next(qv_it, 1) == cluster_ordered_fields.end(),
+              "Error! The water vapor field has to be the first tracer, but it is not.\n");
 
           if (qv_it != cluster_ordered_fields.begin()) {
             // Note: reversing the order of the fields preserves subgroups contiguity
@@ -565,7 +593,8 @@ void FieldManager::registration_ends() {
       // Check if there is a group with all the fields. Notice that it is enough to check
       // if any list in the LOL has the same length as cluster_ordered_fields.
       // If not, we will set cluster_name = $group1_name | $group2_name | ...
-      // Note: cluster_name will be the name of the field allocating all fields in the cluster's groups
+      // Note: cluster_name will be the name of the field allocating all fields in the cluster's
+      // groups
       std::string cluster_name;
       for (const auto &gn : cluster) {
         // Start building cluster_name by "or-ing" all gn's.
@@ -624,18 +653,20 @@ void FieldManager::registration_ends() {
         }
 
         EKAT_REQUIRE_MSG(lt == LayoutType::Scalar2D || lt == LayoutType::Scalar3D,
-                         "Error! We can only monolithically allocate scalar fields. Found " + e2str(lt) +
-                             " fields instead.\n");
+                         "Error! We can only monolithically allocate scalar fields. Found " +
+                             e2str(lt) + " fields instead.\n");
 
         FieldLayout c_layout = FieldLayout::invalid();
         if (lt == LayoutType::Scalar2D) {
           c_layout = cluster_grid->get_2d_vector_layout(cluster_ordered_fields.size());
         } else {
-          c_layout = cluster_grid->get_3d_vector_layout(f_layout.tags().back() == LEV, cluster_ordered_fields.size());
+          c_layout = cluster_grid->get_3d_vector_layout(f_layout.tags().back() == LEV,
+                                                        cluster_ordered_fields.size());
         }
 
         // The units for the monolithic field are nondimensional, cause checking whether
-        // all fields in the group have the same units so we can use those is too long and pointless.
+        // all fields in the group have the same units so we can use those is too long and
+        // pointless.
         auto nondim = ekat::units::Units::nondimensional();
 
         // Allocate cluster field
@@ -652,7 +683,8 @@ void FieldManager::registration_ends() {
           C_ap.request_allocation(f->get_header().get_alloc_properties());
         }
         for (const auto &gn : cluster) {
-          if (m_group_requests.at(cluster_grid_name).find(gn) != m_group_requests.at(cluster_grid_name).end()) {
+          if (m_group_requests.at(cluster_grid_name).find(gn) !=
+              m_group_requests.at(cluster_grid_name).end()) {
             for (const auto &req : m_group_requests.at(cluster_grid_name).at(gn)) {
               C_ap.request_allocation(req.pack_size);
             }
@@ -667,7 +699,8 @@ void FieldManager::registration_ends() {
         const auto &C_tags = C->get_header().get_identifier().get_layout().tags();
         const int idim     = std::distance(C_tags.begin(), ekat::find(C_tags, CMP));
         // See below where we assume idim is 1
-        EKAT_REQUIRE_MSG(idim == 1, "Error! idim is assumed to be 1 in FieldManager::registration_ends().\n");
+        EKAT_REQUIRE_MSG(idim == 1,
+                         "Error! idim is assumed to be 1 in FieldManager::registration_ends().\n");
 
         // Create all individual subfields
         for (const auto &fn : cluster_ordered_fields) {
@@ -699,9 +732,10 @@ void FieldManager::registration_ends() {
         const auto n = info.size();
 
         // Find the first field of this group in the ordered cluster names.
-        auto first = std::find_first_of(cluster_ordered_fields.begin(), cluster_ordered_fields.end(),
-                                        info.m_fields_names.begin(), info.m_fields_names.end());
-        auto last  = std::next(first, n);
+        auto first =
+            std::find_first_of(cluster_ordered_fields.begin(), cluster_ordered_fields.end(),
+                               info.m_fields_names.begin(), info.m_fields_names.end());
+        auto last = std::next(first, n);
 
         // Some sanity checks: info.m_fields_names should be a rearrangement of what is
         // in cluster_odered_fields[first,last)
@@ -710,11 +744,14 @@ void FieldManager::registration_ends() {
                          "       Group name: " +
                              gn + "\n");
         EKAT_REQUIRE_MSG(std::distance(last, cluster_ordered_fields.end()) >= 0,
-                         "Error! Something went wrong while looking for fields of this group in the ordered cluster.\n"
+                         "Error! Something went wrong while looking for fields of this group in "
+                         "the ordered cluster.\n"
                          "       Group name: " +
                              gn + "\n");
-        EKAT_REQUIRE_MSG(std::is_permutation(first, last, info.m_fields_names.begin(), info.m_fields_names.end()),
-                         "Error! Something went wrong while looking for fields of this group in the ordered cluster.\n"
+        EKAT_REQUIRE_MSG(std::is_permutation(first, last, info.m_fields_names.begin(),
+                                             info.m_fields_names.end()),
+                         "Error! Something went wrong while looking for fields of this group in "
+                         "the ordered cluster.\n"
                          "       Group name: " +
                              gn + "\n");
 
@@ -803,29 +840,34 @@ void FieldManager::add_field(const Field &f) {
                        m_grids_mgr->print_available_grids() + "\n");
   EKAT_REQUIRE_MSG(not(m_repo_state == RepoState::Open),
                    "Error! The method 'add_field' can only be called on a closed repo.\n");
-  EKAT_REQUIRE_MSG(f.is_allocated(),
-                   "Error! The method 'add_field' requires the input field to be already allocated.\n");
-  EKAT_REQUIRE_MSG(m_grids_mgr->get_grid(grid_name)->is_valid_layout(f.get_header().get_identifier().get_layout()),
-                   "Error! Input field to 'add_field' has a layout not compatible with the stored grid.\n"
-                   "  - input field name : " +
-                       f.name() +
-                       "\n"
-                       "  - field manager grid: " +
-                       grid_name +
-                       "\n"
-                       "  - input field layout:   " +
-                       f.get_header().get_identifier().get_layout().to_string() + "\n");
-  EKAT_REQUIRE_MSG(not has_field(f.name(), grid_name),
-                   "Error! The method 'add_field' requires the input field to not be already existing.\n"
-                   "  - field name: " +
-                       f.get_header().get_identifier().name() + "\n");
-  EKAT_REQUIRE_MSG(f.get_header().get_tracking().get_groups_info().size() == 0 ||
-                       m_group_requests.at(grid_name).size() == 0,
-                   "Error! When calling 'add_field', one of the following must be true:\n"
-                   "  - the input field is not be part of any group,\n"
-                   "  - there were no group requests for this field manager.\n"
-                   "The reason for this is that otherwise we *might* have missed some inclusion dependency\n"
-                   "when we allocated the fields for one of those groups.\n");
+  EKAT_REQUIRE_MSG(
+      f.is_allocated(),
+      "Error! The method 'add_field' requires the input field to be already allocated.\n");
+  EKAT_REQUIRE_MSG(
+      m_grids_mgr->get_grid(grid_name)->is_valid_layout(
+          f.get_header().get_identifier().get_layout()),
+      "Error! Input field to 'add_field' has a layout not compatible with the stored grid.\n"
+      "  - input field name : " +
+          f.name() +
+          "\n"
+          "  - field manager grid: " +
+          grid_name +
+          "\n"
+          "  - input field layout:   " +
+          f.get_header().get_identifier().get_layout().to_string() + "\n");
+  EKAT_REQUIRE_MSG(
+      not has_field(f.name(), grid_name),
+      "Error! The method 'add_field' requires the input field to not be already existing.\n"
+      "  - field name: " +
+          f.get_header().get_identifier().name() + "\n");
+  EKAT_REQUIRE_MSG(
+      f.get_header().get_tracking().get_groups_info().size() == 0 ||
+          m_group_requests.at(grid_name).size() == 0,
+      "Error! When calling 'add_field', one of the following must be true:\n"
+      "  - the input field is not be part of any group,\n"
+      "  - there were no group requests for this field manager.\n"
+      "The reason for this is that otherwise we *might* have missed some inclusion dependency\n"
+      "when we allocated the fields for one of those groups.\n");
 
   // All good, add the field to the repo
   m_fields[grid_name][f.get_header().get_identifier().name()] = std::make_shared<Field>(f);
@@ -871,7 +913,8 @@ void FieldManager::pre_process_monolithic_group_requests() {
 
           // Check that we haven't found 2 other grids which registered this field
           EKAT_REQUIRE_MSG(registered_grid == "" or registered_grid == other_grid_name,
-                           "Error! Before registration_end(), FieldManager requires a field within a group to be "
+                           "Error! Before registration_end(), FieldManager requires a field within "
+                           "a group to be "
                            "registered on a single grid.\n"
                            "  - Field name: " +
                                field_name +
@@ -887,8 +930,9 @@ void FieldManager::pre_process_monolithic_group_requests() {
 
         // Get a FID for this grid by asking for an equivalent layout
         // to the layout on the src grid
-        const auto src_fid = m_fields.at(registered_grid).at(field_name)->get_header().get_identifier();
-        const auto fl      = m_grids_mgr->get_grid(grid_name)->equivalent_layout(src_fid.get_layout());
+        const auto src_fid =
+            m_fields.at(registered_grid).at(field_name)->get_header().get_identifier();
+        const auto fl = m_grids_mgr->get_grid(grid_name)->equivalent_layout(src_fid.get_layout());
         FieldIdentifier fid(field_name, fl, src_fid.get_units(), grid_name);
 
         // Register the field for each group req
diff --git i/components/eamxx/src/share/field/field_manager.hpp w/components/eamxx/src/share/field/field_manager.hpp
index 8d0b15a000..7caddd580c 100644
--- i/components/eamxx/src/share/field/field_manager.hpp
+++ w/components/eamxx/src/share/field/field_manager.hpp
@@ -69,7 +69,8 @@ public:
   // Adds $field_name on $grid_name to group $group_name (creating the group, if necessary).
   // NOTE: if $group_name is allocated as a monolithic field, this throws.
   // NOTE: must be called after registration ends
-  void add_to_group(const std::string &field_name, const std::string &grid_name, const std::string &group_name);
+  void add_to_group(const std::string &field_name, const std::string &grid_name,
+                    const std::string &group_name);
   void add_to_group(const identifier_type &id, const std::string &group_name) {
     add_to_group(id.name(), id.get_grid_name(), group_name);
   }
@@ -77,62 +78,66 @@ public:
   // Query for a particular field or group of fields
   bool has_field(const std::string &field_name, const std::string &grid_name) const;
   bool has_field(const std::string &field_name) const {
-    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1,
-                    "Error! More than one grid exists for FieldManager, must specify grid name to query for field.\n"
-                    "  - Field name: " +
-                        field_name +
-                        "\n"
-                        "  - Grids in FM: " +
-                        m_grids_mgr->print_available_grids() + "\n");
+    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1, "Error! More than one grid exists for FieldManager, "
+                                              "must specify grid name to query for field.\n"
+                                              "  - Field name: " +
+                                                  field_name +
+                                                  "\n"
+                                                  "  - Grids in FM: " +
+                                                  m_grids_mgr->print_available_grids() + "\n");
     return has_field(field_name, m_grids_mgr->get_repo().begin()->second->name());
   }
   bool has_group(const std::string &group_name, const std::string &grid_name) const;
   bool has_group(const std::string &group_name) const {
-    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1,
-                    "Error! More than one grid exists for FieldManager, must specify grid name to query for group.\n"
-                    "  - Group name: " +
-                        group_name +
-                        "\n"
-                        "  - Grids in FM: " +
-                        m_grids_mgr->print_available_grids() + "\n");
+    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1, "Error! More than one grid exists for FieldManager, "
+                                              "must specify grid name to query for group.\n"
+                                              "  - Group name: " +
+                                                  group_name +
+                                                  "\n"
+                                                  "  - Grids in FM: " +
+                                                  m_grids_mgr->print_available_grids() + "\n");
     return has_group(group_name, m_grids_mgr->get_repo().begin()->second->name());
   }
 
   Field get_field(const std::string &name, const std::string &grid_name) const;
-  Field get_field(const identifier_type &id) const { return get_field(id.name(), id.get_grid_name()); }
+  Field get_field(const identifier_type &id) const {
+    return get_field(id.name(), id.get_grid_name());
+  }
   Field get_field(const std::string &name) const {
-    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1,
-                    "Error! More than one grid exists for FieldManager, must specify grid name to get field.\n"
-                    "  - Field name: " +
-                        name +
-                        "\n"
-                        "  - Grids in FM: " +
-                        m_grids_mgr->print_available_grids() + "\n");
+    EKAT_ASSERT_MSG(
+        m_grids_mgr->size() == 1,
+        "Error! More than one grid exists for FieldManager, must specify grid name to get field.\n"
+        "  - Field name: " +
+            name +
+            "\n"
+            "  - Grids in FM: " +
+            m_grids_mgr->print_available_grids() + "\n");
     return get_field(name, m_grids_mgr->get_repo().begin()->second->name());
   }
 
   Field &get_field(const std::string &name, const std::string &grid_name);
   Field &get_field(const identifier_type &id) { return get_field(id.name(), id.get_grid_name()); }
   Field &get_field(const std::string &name) {
-    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1,
-                    "Error! More than one grid exists for FieldManager, must specify grid name to get field.\n"
-                    "  - Field name: " +
-                        name +
-                        "\n"
-                        "  - Grids in FM: " +
-                        m_grids_mgr->print_available_grids() + "\n");
+    EKAT_ASSERT_MSG(
+        m_grids_mgr->size() == 1,
+        "Error! More than one grid exists for FieldManager, must specify grid name to get field.\n"
+        "  - Field name: " +
+            name +
+            "\n"
+            "  - Grids in FM: " +
+            m_grids_mgr->print_available_grids() + "\n");
     return get_field(name, m_grids_mgr->get_repo().begin()->second->name());
   }
 
   FieldGroupInfo get_group_info(const std::string &group_name) const {
-    EKAT_ASSERT_MSG(
-        m_grids_mgr->size() == 1,
-        "Error! More than one grid exists for FieldManager, must specify grid name to query for FieldGroupInfo.\n"
-        "  - Group name: " +
-            group_name +
-            "\n"
-            "  - Grids in FM: " +
-            m_grids_mgr->print_available_grids() + "\n");
+    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1,
+                    "Error! More than one grid exists for FieldManager, must specify grid name to "
+                    "query for FieldGroupInfo.\n"
+                    "  - Group name: " +
+                        group_name +
+                        "\n"
+                        "  - Grids in FM: " +
+                        m_grids_mgr->print_available_grids() + "\n");
     return get_group_info(group_name, m_grids_mgr->get_repo().begin()->second->name());
   }
   FieldGroupInfo get_group_info(const std::string &group_name, const std::string &grid_name) const;
@@ -140,23 +145,24 @@ public:
   FieldGroup get_field_group(const std::string &name, const std::string &grid_name);
 
   const std::map<ci_string, std::shared_ptr<Field>> &get_repo() const {
-    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1,
-                    "Error! More than one grid exists for FieldManager, must specify grid name to get field repo.\n"
-                    "  - Grids in FM: " +
-                        m_grids_mgr->print_available_grids() + "\n");
+    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1, "Error! More than one grid exists for FieldManager, "
+                                              "must specify grid name to get field repo.\n"
+                                              "  - Grids in FM: " +
+                                                  m_grids_mgr->print_available_grids() + "\n");
     return m_fields.at(m_grids_mgr->get_repo().begin()->second->name());
   }
   const std::map<ci_string, std::shared_ptr<Field>> &get_repo(const std::string &grid_name) const {
     EKAT_REQUIRE_MSG(m_grids_mgr->has_grid(grid_name),
-                     "Error! This field manager does not contain data on grid \"" + grid_name + "\"\n");
+                     "Error! This field manager does not contain data on grid \"" + grid_name +
+                         "\"\n");
     return m_fields.at(grid_name);
   }
 
   const std::shared_ptr<const AbstractGrid> get_grid() const {
-    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1,
-                    "Error! More than one grid exists for FieldManager, must access grid through grids manager.\n"
-                    "  - Grids in FM: " +
-                        m_grids_mgr->print_available_grids() + "\n");
+    EKAT_ASSERT_MSG(m_grids_mgr->size() == 1, "Error! More than one grid exists for FieldManager, "
+                                              "must access grid through grids manager.\n"
+                                              "  - Grids in FM: " +
+                                                  m_grids_mgr->print_available_grids() + "\n");
     return m_grids_mgr->get_repo().begin()->second;
   }
 
diff --git i/components/eamxx/src/share/field/field_request.hpp w/components/eamxx/src/share/field/field_request.hpp
index b17a217e06..6de4fc3a75 100644
--- i/components/eamxx/src/share/field/field_request.hpp
+++ w/components/eamxx/src/share/field/field_request.hpp
@@ -46,7 +46,8 @@ struct GroupRequest {
   //  - grid: the grid where the group is requested
   //  - ps: the pack size that the allocation of the fields in the group
   //        (and the monolithic field, if any) should accommodate (see field_alloc_prop.hpp)
-  //  - monolithic_alloc: whether the group should be allocated as a monolithic group (see field_group.hpp)
+  //  - monolithic_alloc: whether the group should be allocated as a monolithic group (see
+  //  field_group.hpp)
   GroupRequest(const std::string &name_, const std::string &grid_, const int ps,
                const MonolithicAlloc monolithic_alloc_ = MonolithicAlloc::NotRequired)
       : name(name_), grid(grid_), pack_size(ps), monolithic_alloc(monolithic_alloc_) {
@@ -61,10 +62,11 @@ struct GroupRequest {
   GroupRequest(const GroupRequest &) = default;
 
   // Main parts of a group request
-  std::string name;                 // Group name
-  std::string grid;                 // Grid name
-  int pack_size;                    // Request an allocation that can accomodate Pack<Real,pack_size>
-  MonolithicAlloc monolithic_alloc; // Whether the group should be allocated as a single n+1 dimensional field
+  std::string name; // Group name
+  std::string grid; // Grid name
+  int pack_size;    // Request an allocation that can accomodate Pack<Real,pack_size>
+  MonolithicAlloc
+      monolithic_alloc; // Whether the group should be allocated as a single n+1 dimensional field
 };
 
 // In order to use GroupRequest in std sorted containers (like std::set),
@@ -109,35 +111,40 @@ struct FieldRequest {
   // Main constructor. Here is what the args are:
   //  - fid: the FieldIdentifier for the requested field (see field_identifier.hpp)
   //  - groups_: a list of groups that this field should be added to (see field_group.hpp)
-  //  - ps: the pack size that the allocation of the field should accommodate (see field_alloc_prop.hpp)
+  //  - ps: the pack size that the allocation of the field should accommodate (see
+  //  field_alloc_prop.hpp)
   FieldRequest(const FID &fid_, const std::list<std::string> &groups_, const int ps)
       : fid(fid_), pack_size(ps), groups(groups_) {
     // Sanity checks
     EKAT_REQUIRE_MSG(ps >= 1, "Error! Pack sizes must be >= 1.\n");
     // This seems funky, but write down a pow of 2 in binary format, and you'll see why it works
-    EKAT_REQUIRE_MSG((ps & (ps - 1)) == 0, "Error! We only support pack sizes that are (positive) powers of 2.\n");
+    EKAT_REQUIRE_MSG((ps & (ps - 1)) == 0,
+                     "Error! We only support pack sizes that are (positive) powers of 2.\n");
   }
 
   // Convenience constructors.
-  // They first three allow defaulting ps/groups_ and/or allow simpler sintax for single-group requests.
-  // The last three do the same, but also allow to build a FieldIdentifier on the fly.
+  // They first three allow defaulting ps/groups_ and/or allow simpler sintax for single-group
+  // requests. The last three do the same, but also allow to build a FieldIdentifier on the fly.
   FieldRequest(const FID &fid, const int ps = 1)
       : FieldRequest(fid, std::list<std::string>{}, ps) { /* Nothing to do here */ }
   FieldRequest(const FID &fid, const std::list<std::string> &groups_)
       : FieldRequest(fid, groups_, 1) { /* Nothing to do here */ }
   FieldRequest(const FID &fid, const std::string &group, const int ps = 1)
       : FieldRequest(fid, std::list<std::string>{group}, ps) { /* Nothing to do here */ }
-  FieldRequest(const std::string &name, const FieldLayout &layout, const Units &u, const std::string &grid,
-               const std::list<std::string> &groups_, const int ps = 1)
+  FieldRequest(const std::string &name, const FieldLayout &layout, const Units &u,
+               const std::string &grid, const std::list<std::string> &groups_, const int ps = 1)
       : FieldRequest(FID(name, layout, u, grid), groups_, ps) { /* Nothing to do here */ }
-  FieldRequest(const std::string &name, const FieldLayout &layout, const Units &u, const std::string &grid,
-               const int ps = 1)
-      : FieldRequest(FID(name, layout, u, grid), std::list<std::string>{}, ps) { /* Nothing to do here */ }
-  FieldRequest(const std::string &name, const FieldLayout &layout, const Units &u, const std::string &grid,
-               const std::string &group, const int ps = 1)
-      : FieldRequest(FID(name, layout, u, grid), std::list<std::string>{group}, ps) { /* Nothing to do here */ }
+  FieldRequest(const std::string &name, const FieldLayout &layout, const Units &u,
+               const std::string &grid, const int ps = 1)
+      : FieldRequest(FID(name, layout, u, grid), std::list<std::string>{},
+                     ps) { /* Nothing to do here */ }
+  FieldRequest(const std::string &name, const FieldLayout &layout, const Units &u,
+               const std::string &grid, const std::string &group, const int ps = 1)
+      : FieldRequest(FID(name, layout, u, grid), std::list<std::string>{group},
+                     ps) { /* Nothing to do here */ }
 
-  FieldRequest(const FID &fid, const FieldRequest &parent, int idim, int k, bool dynamic) : FieldRequest(fid) {
+  FieldRequest(const FID &fid, const FieldRequest &parent, int idim, int k, bool dynamic)
+      : FieldRequest(fid) {
     subview_info.dim_idx    = idim;
     subview_info.slice_idx  = k;
     subview_info.dim_extent = parent.fid.get_layout().dim(idim);
@@ -146,14 +153,16 @@ struct FieldRequest {
     parent_name = parent.fid.name();
   }
 
-  FieldRequest(const std::string &field_name, const std::string &grid_name, const std::list<std::string> &groups = {},
-               const int ps = 1)
+  FieldRequest(const std::string &field_name, const std::string &grid_name,
+               const std::list<std::string> &groups = {}, const int ps = 1)
       : FieldRequest(incomplete_fid(field_name, grid_name), groups, ps) {
     incomplete = true;
   }
 
-  static FieldIdentifier incomplete_fid(const std::string &field_name, const std::string &grid_name) {
-    return FieldIdentifier(field_name, FieldLayout::invalid(), Units::invalid(), grid_name, DataType::Invalid);
+  static FieldIdentifier incomplete_fid(const std::string &field_name,
+                                        const std::string &grid_name) {
+    return FieldIdentifier(field_name, FieldLayout::invalid(), Units::invalid(), grid_name,
+                           DataType::Invalid);
   }
 
   // Data
diff --git i/components/eamxx/src/share/field/field_sync.cpp w/components/eamxx/src/share/field/field_sync.cpp
index 6391781e31..9b00a60b16 100644
--- i/components/eamxx/src/share/field/field_sync.cpp
+++ w/components/eamxx/src/share/field/field_sync.cpp
@@ -4,7 +4,9 @@ namespace scream {
 
 void Field::sync_to_host(const bool fence) const {
   // Sanity check
-  EKAT_REQUIRE_MSG(is_allocated(), "Error! Input field must be allocated in order to sync host and device views.\n");
+  EKAT_REQUIRE_MSG(
+      is_allocated(),
+      "Error! Input field must be allocated in order to sync host and device views.\n");
 
   // Check for early return if Host and Device are the same memory space
   if (host_and_device_share_memory_space())
@@ -37,7 +39,9 @@ void Field::sync_to_host(const bool fence) const {
 
 void Field::sync_to_dev(const bool fence) const {
   // Sanity check
-  EKAT_REQUIRE_MSG(is_allocated(), "Error! Input field must be allocated in order to sync host and device views.\n");
+  EKAT_REQUIRE_MSG(
+      is_allocated(),
+      "Error! Input field must be allocated in order to sync host and device views.\n");
 
   // Check for early return if Host and Device are the same memory space
   if (host_and_device_share_memory_space())
diff --git i/components/eamxx/src/share/field/field_tracking.cpp w/components/eamxx/src/share/field/field_tracking.cpp
index c30834b9ef..87821a8eeb 100644
--- i/components/eamxx/src/share/field/field_tracking.cpp
+++ w/components/eamxx/src/share/field/field_tracking.cpp
@@ -2,16 +2,23 @@
 
 namespace scream {
 
-void FieldTracking::add_provider(const std::weak_ptr<AtmosphereProcess> &provider) { m_providers.insert(provider); }
+void FieldTracking::add_provider(const std::weak_ptr<AtmosphereProcess> &provider) {
+  m_providers.insert(provider);
+}
 
-void FieldTracking::add_customer(const std::weak_ptr<AtmosphereProcess> &customer) { m_customers.insert(customer); }
+void FieldTracking::add_customer(const std::weak_ptr<AtmosphereProcess> &customer) {
+  m_customers.insert(customer);
+}
 
-void FieldTracking::add_to_group(const std::shared_ptr<const FieldGroupInfo> &group) { m_groups.insert(group); }
+void FieldTracking::add_to_group(const std::shared_ptr<const FieldGroupInfo> &group) {
+  m_groups.insert(group);
+}
 
 void FieldTracking::update_time_stamp(const TimeStamp &ts) {
   // We check that the given time stamp is not in the past.
   // This is to prevent users from tampering with time stamps (e.g., rewinding time).
-  EKAT_REQUIRE_MSG(!m_time_stamp.is_valid() || !(ts < m_time_stamp), "Error! Input time stamp is in the past.\n");
+  EKAT_REQUIRE_MSG(!m_time_stamp.is_valid() || !(ts < m_time_stamp),
+                   "Error! Input time stamp is in the past.\n");
 
   m_time_stamp = ts;
 
@@ -29,8 +36,9 @@ void FieldTracking::invalidate_time_stamp() {
 }
 
 void FieldTracking::set_accum_start_time(const TimeStamp &t_start) {
-  EKAT_REQUIRE_MSG(not m_time_stamp.is_valid() || m_time_stamp <= t_start,
-                   "Error! Accumulation start time is older than current timestamp of the field.\n");
+  EKAT_REQUIRE_MSG(
+      not m_time_stamp.is_valid() || m_time_stamp <= t_start,
+      "Error! Accumulation start time is older than current timestamp of the field.\n");
   m_accum_start = t_start;
 }
 
diff --git i/components/eamxx/src/share/field/field_tracking.hpp w/components/eamxx/src/share/field/field_tracking.hpp
index 3950255402..e6b124e6c8 100644
--- i/components/eamxx/src/share/field/field_tracking.hpp
+++ w/components/eamxx/src/share/field/field_tracking.hpp
@@ -55,9 +55,11 @@ public:
   // Add the field to a given group
   void add_to_group(const std::shared_ptr<const FieldGroupInfo> &group);
 
-  // Set the time stamp for this field. This can only be called once, due to TimeStamp implementation.
-  // NOTE: if the field has 'children' (see FamilyTracking), their ts will be updated too.
-  //       However, if the field has a 'parent' (see FamilyTracking), the parent's ts will not be updated.
+  // Set the time stamp for this field. This can only be called once, due to TimeStamp
+  // implementation. NOTE: if the field has 'children' (see FamilyTracking), their ts will be
+  // updated too.
+  //       However, if the field has a 'parent' (see FamilyTracking), the parent's ts will not be
+  //       updated.
   void update_time_stamp(const TimeStamp &ts);
   void invalidate_time_stamp();
 
@@ -76,9 +78,9 @@ protected:
   TimeStamp m_accum_start;
   ci_string m_accum_type;
 
-  // List of provider/customer processes. A provider is an atm process that computes/updates the field.
-  // A customer is an atm process that uses the field just as an input.
-  // NOTE: do NOT use shared_ptr, since you would create circular references.
+  // List of provider/customer processes. A provider is an atm process that computes/updates the
+  // field. A customer is an atm process that uses the field just as an input. NOTE: do NOT use
+  // shared_ptr, since you would create circular references.
   atm_proc_set_type m_providers;
   atm_proc_set_type m_customers;
 
@@ -93,7 +95,8 @@ protected:
 
 // Use this free function to exploit features of enable_shared_from_this,
 // as well as features from FamilyTracking.
-template <typename... Args> inline std::shared_ptr<FieldTracking> create_tracking(const Args &...args) {
+template <typename... Args>
+inline std::shared_ptr<FieldTracking> create_tracking(const Args &...args) {
   auto ptr = std::make_shared<FieldTracking>(args...);
   ptr->setSelfPointer(ptr);
   return ptr;
diff --git i/components/eamxx/src/share/field/field_utils.hpp w/components/eamxx/src/share/field/field_utils.hpp
index dbcf44aad9..6ba94072a6 100644
--- i/components/eamxx/src/share/field/field_utils.hpp
+++ w/components/eamxx/src/share/field/field_utils.hpp
@@ -28,7 +28,8 @@ inline bool views_are_equal(const Field &f1, const Field &f2, const ekat::Comm *
 }
 
 template <typename Engine, typename PDF> void randomize(const Field &f, Engine &engine, PDF &&pdf) {
-  EKAT_REQUIRE_MSG(f.is_allocated(), "Error! Cannot randomize the values of a field not yet allocated.\n");
+  EKAT_REQUIRE_MSG(f.is_allocated(),
+                   "Error! Cannot randomize the values of a field not yet allocated.\n");
 
   // Deduce scalar type from pdf
   using ST = decltype(pdf(engine));
@@ -59,7 +60,8 @@ template <typename Engine, typename PDF> void randomize(const Field &f, Engine &
 template <typename Engine, typename PDF, typename MaskType>
 void perturb(Field &f, Engine &engine, PDF &&pdf, const int base_seed, const MaskType &level_mask,
              const Field &dof_gids = Field()) {
-  EKAT_REQUIRE_MSG(f.is_allocated(), "Error! Cannot perturb the values of a field not yet allocated.\n");
+  EKAT_REQUIRE_MSG(f.is_allocated(),
+                   "Error! Cannot perturb the values of a field not yet allocated.\n");
 
   // Deduce scalar type from pdf
   using ST = decltype(pdf(engine));
@@ -98,16 +100,17 @@ void perturb(Field &f, Engine &engine, PDF &&pdf, const int base_seed, const Mas
                                            fl.to_string() + "\n");
 
     const auto &dof_gids_fl = dof_gids.get_header().get_identifier().get_layout();
-    EKAT_REQUIRE_MSG(dof_gids_fl.dim(0) == fl.dim(COL), "Error! Field of DoF GIDs should have the same size as "
-                                                        "perturbed field's column dimension.\n"
-                                                        "  - dof_gids dim: " +
-                                                            std::to_string(dof_gids_fl.dim(0)) +
-                                                            "\n"
-                                                            "  - field name: " +
-                                                            f.name() +
-                                                            "\n"
-                                                            "  - field layout: " +
-                                                            fl.to_string() + "\n");
+    EKAT_REQUIRE_MSG(dof_gids_fl.dim(0) == fl.dim(COL),
+                     "Error! Field of DoF GIDs should have the same size as "
+                     "perturbed field's column dimension.\n"
+                     "  - dof_gids dim: " +
+                         std::to_string(dof_gids_fl.dim(0)) +
+                         "\n"
+                         "  - field name: " +
+                         f.name() +
+                         "\n"
+                         "  - field layout: " +
+                         fl.to_string() + "\n");
     EKAT_REQUIRE_MSG(dof_gids.data_type() == DataType::IntType,
                      "Error! DoF GIDs field must have \"int\" as data type.\n");
   }
@@ -122,7 +125,8 @@ void perturb(Field &f, Engine &engine, PDF &&pdf, const int base_seed, const Mas
 // - The first dimension is for the columns (COL)
 // - There can be only up to 3 dimensions of f_in
 template <typename ST>
-void horiz_contraction(const Field &f_out, const Field &f_in, const Field &weight, const ekat::Comm *comm = nullptr) {
+void horiz_contraction(const Field &f_out, const Field &f_in, const Field &weight,
+                       const ekat::Comm *comm = nullptr) {
   using namespace ShortFieldTagsNames;
 
   const auto &l_out = f_out.get_header().get_identifier().get_layout();
@@ -135,33 +139,38 @@ void horiz_contraction(const Field &f_out, const Field &f_in, const Field &weigh
   EKAT_REQUIRE_MSG(l_w.rank() == 1, "Error! The weight field must be rank-1.\n"
                                     "The input weight has rank "
                                         << l_w.rank() << ".\n");
-  EKAT_REQUIRE_MSG(l_w.tags() == std::vector<FieldTag>({COL}), "Error! The weight field must have a column dimension.\n"
-                                                               "The input field has layout "
-                                                                   << l_w.tags() << ".\n");
+  EKAT_REQUIRE_MSG(l_w.tags() == std::vector<FieldTag>({COL}),
+                   "Error! The weight field must have a column dimension.\n"
+                   "The input field has layout "
+                       << l_w.tags() << ".\n");
   EKAT_REQUIRE_MSG(l_in.rank() <= 3, "Error! The input field must be at most rank-3.\n"
                                      "The input field's rank is "
                                          << l_in.rank() << ".\n");
   EKAT_REQUIRE_MSG(l_in.tags()[0] == COL, "Error! The input field must have a column dimension.\n"
                                           "The input field's layout is "
                                               << l_in.to_string() << ".\n");
-  EKAT_REQUIRE_MSG(l_w.dim(0) == l_in.dim(0), "Error! input and weight fields must have the same dimension along "
-                                              "which we are reducing the field.\n"
-                                              "The weight field has dimension "
-                                                  << l_w.dim(0)
-                                                  << " while "
-                                                     "the input field has dimension "
-                                                  << l_in.dim(0) << ".\n");
-  EKAT_REQUIRE_MSG(l_in.dim(0) > 0, "Error! The input field must have a non-zero column dimension.\n"
-                                    "The input field's layout is "
-                                        << l_in.to_string() << ".\n");
+  EKAT_REQUIRE_MSG(l_w.dim(0) == l_in.dim(0),
+                   "Error! input and weight fields must have the same dimension along "
+                   "which we are reducing the field.\n"
+                   "The weight field has dimension "
+                       << l_w.dim(0)
+                       << " while "
+                          "the input field has dimension "
+                       << l_in.dim(0) << ".\n");
+  EKAT_REQUIRE_MSG(l_in.dim(0) > 0,
+                   "Error! The input field must have a non-zero column dimension.\n"
+                   "The input field's layout is "
+                       << l_in.to_string() << ".\n");
   EKAT_REQUIRE_MSG(l_out == l_in.clone().strip_dim(0),
                    "Error! The output field must have the same layout as the input field "
                    "without the column dimension.\n"
                    "The input field's layout is "
-                       << l_in.to_string() << " and the output field's layout is " << l_out.to_string() << ".\n");
+                       << l_in.to_string() << " and the output field's layout is "
+                       << l_out.to_string() << ".\n");
   EKAT_REQUIRE_MSG(f_out.is_allocated() && f_in.is_allocated() && weight.is_allocated(),
                    "Error! All fields must be allocated.");
-  EKAT_REQUIRE_MSG(f_out.data_type() == f_in.data_type(), "Error! In/out fields must have matching data types.");
+  EKAT_REQUIRE_MSG(f_out.data_type() == f_in.data_type(),
+                   "Error! In/out fields must have matching data types.");
   EKAT_REQUIRE_MSG(f_out.data_type() == weight.data_type(),
                    "Error! Weight field must have the same data type as input fields.");
 
@@ -179,7 +188,8 @@ void horiz_contraction(const Field &f_out, const Field &f_in, const Field &weigh
 //   - rank-1, with only LEV/ILEV dimension
 //   - rank-2, with only COL and LEV/ILEV dimensions
 template <typename ST>
-void vert_contraction(const Field &f_out, const Field &f_in, const Field &weight, const ekat::Comm *comm = nullptr) {
+void vert_contraction(const Field &f_out, const Field &f_in, const Field &weight,
+                      const ekat::Comm *comm = nullptr) {
   using namespace ShortFieldTagsNames;
 
   const auto &l_out = f_out.get_header().get_identifier().get_layout();
@@ -203,8 +213,8 @@ void vert_contraction(const Field &f_out, const Field &f_in, const Field &weight
   EKAT_REQUIRE_MSG(l_in.rank() >= l_w.rank(), "Error! The input field must have at least as many "
                                               "dimensions as the weight field.\n"
                                               "The input field rank is "
-                                                  << l_in.rank() << " and the weight field rank is " << l_w.rank()
-                                                  << ".\n");
+                                                  << l_in.rank() << " and the weight field rank is "
+                                                  << l_w.rank() << ".\n");
   EKAT_REQUIRE_MSG(l_in.tags().back() == LEV or l_in.tags().back() == ILEV,
                    "Error! The input field must have a level dimension.\n"
                    "The input field layout is "
@@ -217,25 +227,29 @@ void vert_contraction(const Field &f_out, const Field &f_in, const Field &weight
                        << " while "
                           "the input field has last dimension "
                        << l_in.dims().back() << ".\n");
-  EKAT_REQUIRE_MSG(l_in.dims().back() > 0, "Error! The input field must have a non-zero level dimension.\n"
-                                           "The input field layout is "
-                                               << l_in.to_string() << ".\n");
+  EKAT_REQUIRE_MSG(l_in.dims().back() > 0,
+                   "Error! The input field must have a non-zero level dimension.\n"
+                   "The input field layout is "
+                       << l_in.to_string() << ".\n");
   if (l_w.rank() == 2) {
-    EKAT_REQUIRE_MSG(l_w.congruent(l_in.clone().strip_dim(CMP, false)), "Error! Incompatible layouts\n"
-                                                                        "  field in: " +
-                                                                            l_in.to_string() +
-                                                                            "\n"
-                                                                            "  weight: " +
-                                                                            l_w.to_string() + "\n");
+    EKAT_REQUIRE_MSG(l_w.congruent(l_in.clone().strip_dim(CMP, false)),
+                     "Error! Incompatible layouts\n"
+                     "  field in: " +
+                         l_in.to_string() +
+                         "\n"
+                         "  weight: " +
+                         l_w.to_string() + "\n");
   }
   EKAT_REQUIRE_MSG(l_out == l_in.clone().strip_dim(l_in.rank() - 1),
                    "Error! The output field must have the same layout as the input field "
                    "without the level dimension.\n"
                    "The input field layout is "
-                       << l_in.to_string() << " and the output field layout is " << l_out.to_string() << ".\n");
+                       << l_in.to_string() << " and the output field layout is "
+                       << l_out.to_string() << ".\n");
   EKAT_REQUIRE_MSG(f_out.is_allocated() && f_in.is_allocated() && weight.is_allocated(),
                    "Error! All fields must be allocated.");
-  EKAT_REQUIRE_MSG(f_out.data_type() == f_in.data_type(), "Error! In/out fields must have matching data types.");
+  EKAT_REQUIRE_MSG(f_out.data_type() == f_in.data_type(),
+                   "Error! In/out fields must have matching data types.");
   EKAT_REQUIRE_MSG(f_out.data_type() == weight.data_type(),
                    "Error! Weight field must have the same data type as input field.");
 
@@ -297,19 +311,21 @@ template <typename ST> ST field_min(const Field &f, const ekat::Comm *comm = nul
 // those tags, and print it. E.g., f might be a <COL,LEV> field, and the tags/indices
 // refer to a single column, in which case we'll print a whole column worth of data.
 inline void print_field_hyperslab(const Field &f, const std::vector<FieldTag> &tags = {},
-                                  const std::vector<int> &indices = {}, std::ostream &out = std::cout) {
+                                  const std::vector<int> &indices = {},
+                                  std::ostream &out               = std::cout) {
   const auto dt   = f.data_type();
   const auto rank = f.rank();
 
-  EKAT_REQUIRE_MSG(rank >= static_cast<int>(tags.size()), "Error! Requested location incompatible with field rank.\n"
-                                                          "  - field name: " +
-                                                              f.name() +
-                                                              "\n"
-                                                              "  - field rank: " +
-                                                              std::to_string(rank) +
-                                                              "\n"
-                                                              "  - requested indices: (" +
-                                                              ekat::join(indices, ",") + "\n");
+  EKAT_REQUIRE_MSG(rank >= static_cast<int>(tags.size()),
+                   "Error! Requested location incompatible with field rank.\n"
+                   "  - field name: " +
+                       f.name() +
+                       "\n"
+                       "  - field rank: " +
+                       std::to_string(rank) +
+                       "\n"
+                       "  - requested indices: (" +
+                       ekat::join(indices, ",") + "\n");
 
   switch (dt) {
   case DataType::IntType:
@@ -328,35 +344,38 @@ inline void print_field_hyperslab(const Field &f, const std::vector<FieldTag> &t
   }
 }
 
-template <Comparison CMP, typename ST> void compute_mask(const Field &x, const ST value, Field &mask) {
+template <Comparison CMP, typename ST>
+void compute_mask(const Field &x, const ST value, Field &mask) {
   // Sanity checks
   EKAT_REQUIRE_MSG(x.is_allocated(), "Error! Input field was not yet allocated.\n");
   EKAT_REQUIRE_MSG(mask.is_allocated(), "Error! Mask field was not yet allocated.\n");
   EKAT_REQUIRE_MSG(not mask.is_read_only(), "Error! Cannot update mask field, as it is read-only.\n"
                                             " - mask name: " +
                                                 mask.name() + "\n");
-  EKAT_REQUIRE_MSG(mask.data_type() == DataType::IntType, "Error! The data type of the mask field must be 'int'.\n"
-                                                          " - mask field name: "
-                                                              << mask.name()
-                                                              << "\n"
-                                                                 " - mask field data type: "
-                                                              << etoi(mask.data_type()) << "\n");
+  EKAT_REQUIRE_MSG(mask.data_type() == DataType::IntType,
+                   "Error! The data type of the mask field must be 'int'.\n"
+                   " - mask field name: "
+                       << mask.name()
+                       << "\n"
+                          " - mask field data type: "
+                       << etoi(mask.data_type()) << "\n");
 
   const auto &x_layout = x.get_header().get_identifier().get_layout();
   const auto &m_layout = mask.get_header().get_identifier().get_layout();
 
-  EKAT_REQUIRE_MSG(m_layout.congruent(x_layout), "Error! Mask field layout is incompatible with this field.\n"
-                                                 " - field name  : " +
-                                                     x.name() +
-                                                     "\n"
-                                                     " - mask name   : " +
-                                                     mask.name() +
-                                                     "\n"
-                                                     " - field layout: " +
-                                                     x_layout.to_string() +
-                                                     "\n"
-                                                     " - mask layout : " +
-                                                     m_layout.to_string() + "\n");
+  EKAT_REQUIRE_MSG(m_layout.congruent(x_layout),
+                   "Error! Mask field layout is incompatible with this field.\n"
+                   " - field name  : " +
+                       x.name() +
+                       "\n"
+                       " - mask name   : " +
+                       mask.name() +
+                       "\n"
+                       " - field layout: " +
+                       x_layout.to_string() +
+                       "\n"
+                       " - mask layout : " +
+                       m_layout.to_string() + "\n");
 
   const auto x_dt   = x.data_type();
   const auto val_dt = get_data_type<ST>();
diff --git i/components/eamxx/src/share/field/field_utils_impl.hpp w/components/eamxx/src/share/field/field_utils_impl.hpp
index a7a7e526ad..e695983a75 100644
--- i/components/eamxx/src/share/field/field_utils_impl.hpp
+++ w/components/eamxx/src/share/field/field_utils_impl.hpp
@@ -16,7 +16,8 @@ namespace scream {
 // NOTE: if the field is padded, padding entries are NOT checked.
 namespace impl {
 
-template <typename ST> bool views_are_equal(const Field &f1, const Field &f2, const ekat::Comm *comm) {
+template <typename ST>
+bool views_are_equal(const Field &f1, const Field &f2, const ekat::Comm *comm) {
   // Get physical layout (shoudl be the same for both fields)
   const auto &l1 = f1.get_header().get_identifier().get_layout();
   const auto &l2 = f2.get_header().get_identifier().get_layout();
@@ -147,7 +148,8 @@ template <typename ST> bool views_are_equal(const Field &f1, const Field &f2, co
   }
 }
 
-template <typename ST, typename Engine, typename PDF> void randomize(const Field &f, Engine &engine, PDF &&pdf) {
+template <typename ST, typename Engine, typename PDF>
+void randomize(const Field &f, Engine &engine, PDF &&pdf) {
   const auto &fl = f.get_header().get_identifier().get_layout();
   switch (fl.rank()) {
   case 0: {
@@ -229,8 +231,8 @@ template <typename ST, typename Engine, typename PDF> void randomize(const Field
 }
 
 template <typename ST, typename Engine, typename PDF, typename MaskType>
-void perturb(Field &f, Engine &engine, PDF &&pdf, const unsigned int base_seed, const MaskType &level_mask,
-             const Field &dof_gids) {
+void perturb(Field &f, Engine &engine, PDF &&pdf, const unsigned int base_seed,
+             const MaskType &level_mask, const Field &dof_gids) {
   const auto &fl = f.get_header().get_identifier().get_layout();
 
   // Check to see if field has a column dimension
@@ -248,7 +250,8 @@ void perturb(Field &f, Engine &engine, PDF &&pdf, const unsigned int base_seed,
     // Create a field to store perturbation values with layout
     // the same as f, but stripped of column and level dimension.
     auto perturb_fl = fl.clone().strip_dims({COL, LEV});
-    FieldIdentifier perturb_fid("perturb_field", perturb_fl, ekat::units::Units::nondimensional(), "");
+    FieldIdentifier perturb_fid("perturb_field", perturb_fl, ekat::units::Units::nondimensional(),
+                                "");
     Field perturb_f(perturb_fid);
     perturb_f.allocate_view();
 
@@ -279,7 +282,8 @@ void perturb(Field &f, Engine &engine, PDF &&pdf, const unsigned int base_seed,
     // Create a field to store perturbation values with layout
     // the same as f, but stripped of level dimension.
     auto perturb_fl = fl.clone().strip_dim(LEV);
-    FieldIdentifier perturb_fid("perturb_field", perturb_fl, ekat::units::Units::nondimensional(), "");
+    FieldIdentifier perturb_fid("perturb_field", perturb_fl, ekat::units::Units::nondimensional(),
+                                "");
     Field perturb_f(perturb_fid);
     perturb_f.allocate_view();
 
@@ -300,7 +304,8 @@ void perturb(Field &f, Engine &engine, PDF &&pdf, const unsigned int base_seed,
 }
 
 template <typename ST>
-void horiz_contraction(const Field &f_out, const Field &f_in, const Field &weight, const ekat::Comm *comm) {
+void horiz_contraction(const Field &f_out, const Field &f_in, const Field &weight,
+                       const ekat::Comm *comm) {
   using KT          = ekat::KokkosTypes<DefaultDevice>;
   using RangePolicy = Kokkos::RangePolicy<Field::device_t::execution_space>;
   using TeamPolicy  = Kokkos::TeamPolicy<Field::device_t::execution_space>;
@@ -319,7 +324,8 @@ void horiz_contraction(const Field &f_out, const Field &f_in, const Field &weigh
     auto v_in  = f_in.get_view<const ST *>();
     auto v_out = f_out.get_view<ST>();
     Kokkos::parallel_reduce(
-        f_out.name(), RangePolicy(0, ncols), KOKKOS_LAMBDA(const int i, ST &ls) { ls += v_w(i) * v_in(i); }, v_out);
+        f_out.name(), RangePolicy(0, ncols),
+        KOKKOS_LAMBDA(const int i, ST &ls) { ls += v_w(i) * v_in(i); }, v_out);
   } break;
   case 2: {
     auto v_in    = f_in.get_view<const ST **>();
@@ -330,7 +336,8 @@ void horiz_contraction(const Field &f_out, const Field &f_in, const Field &weigh
         f_out.name(), p, KOKKOS_LAMBDA(const TeamMember &tm) {
           const int j = tm.league_rank();
           Kokkos::parallel_reduce(
-              Kokkos::TeamVectorRange(tm, ncols), [&](int i, ST &ac) { ac += v_w(i) * v_in(i, j); }, v_out(j));
+              Kokkos::TeamVectorRange(tm, ncols), [&](int i, ST &ac) { ac += v_w(i) * v_in(i, j); },
+              v_out(j));
         });
   } break;
   case 3: {
@@ -345,7 +352,8 @@ void horiz_contraction(const Field &f_out, const Field &f_in, const Field &weigh
           const int j   = idx / d2;
           const int k   = idx % d2;
           Kokkos::parallel_reduce(
-              Kokkos::TeamVectorRange(tm, ncols), [&](int i, ST &ac) { ac += v_w(i) * v_in(i, j, k); }, v_out(j, k));
+              Kokkos::TeamVectorRange(tm, ncols),
+              [&](int i, ST &ac) { ac += v_w(i) * v_in(i, j, k); }, v_out(j, k));
         });
   } break;
   default:
@@ -364,7 +372,8 @@ void horiz_contraction(const Field &f_out, const Field &f_in, const Field &weigh
 }
 
 template <typename ST>
-void vert_contraction(const Field &f_out, const Field &f_in, const Field &weight, const ekat::Comm *comm) {
+void vert_contraction(const Field &f_out, const Field &f_in, const Field &weight,
+                      const ekat::Comm *comm) {
   using KT          = ekat::KokkosTypes<DefaultDevice>;
   using RangePolicy = Kokkos::RangePolicy<Field::device_t::execution_space>;
   using TeamPolicy  = Kokkos::TeamPolicy<Field::device_t::execution_space>;
@@ -394,7 +403,8 @@ void vert_contraction(const Field &f_out, const Field &f_in, const Field &weight
     auto v_in  = f_in.get_view<const ST *>();
     auto v_out = f_out.get_view<ST>();
     Kokkos::parallel_reduce(
-        f_out.name(), RangePolicy(0, nlevs), KOKKOS_LAMBDA(const int i, ST &ls) { ls += v_w(i) * v_in(i); }, v_out);
+        f_out.name(), RangePolicy(0, nlevs),
+        KOKKOS_LAMBDA(const int i, ST &ls) { ls += v_w(i) * v_in(i); }, v_out);
   } break;
   case 2: {
     auto v_in    = f_in.get_view<const ST **>();
@@ -406,7 +416,8 @@ void vert_contraction(const Field &f_out, const Field &f_in, const Field &weight
           const int i = tm.league_rank();
           Kokkos::parallel_reduce(
               Kokkos::TeamVectorRange(tm, nlevs),
-              [&](int j, ST &ac) { ac += w_is_1d ? w1d(j) * v_in(i, j) : w2d(i, j) * v_in(i, j); }, v_out(i));
+              [&](int j, ST &ac) { ac += w_is_1d ? w1d(j) * v_in(i, j) : w2d(i, j) * v_in(i, j); },
+              v_out(i));
         });
   } break;
   case 3: {
@@ -422,7 +433,10 @@ void vert_contraction(const Field &f_out, const Field &f_in, const Field &weight
           const int j   = idx % d1;
           Kokkos::parallel_reduce(
               Kokkos::TeamVectorRange(tm, nlevs),
-              [&](int k, ST &ac) { ac += w_is_1d ? w1d(k) * v_in(i, j, k) : w2d(i, k) * v_in(i, j, k); }, v_out(i, j));
+              [&](int k, ST &ac) {
+                ac += w_is_1d ? w1d(k) * v_in(i, j, k) : w2d(i, k) * v_in(i, j, k);
+              },
+              v_out(i, j));
         });
   } break;
   default:
@@ -831,8 +845,8 @@ template <typename ST> ST field_min(const Field &f, const ekat::Comm *comm) {
 }
 
 template <typename T>
-void print_field_hyperslab(const Field &f, std::vector<FieldTag> tags, std::vector<int> indices, std::ostream &out,
-                           const int orig_rank, const size_t curr_idx) {
+void print_field_hyperslab(const Field &f, std::vector<FieldTag> tags, std::vector<int> indices,
+                           std::ostream &out, const int orig_rank, const size_t curr_idx) {
   // General idea: call f.subfield with the proper index, and recurse
   // until all indices are exausted, then print the field that is left.
   //
@@ -843,7 +857,8 @@ void print_field_hyperslab(const Field &f, std::vector<FieldTag> tags, std::vect
   //   f(0,:,1):
   //     0.123, 0.456, 0.789
 
-  EKAT_REQUIRE_MSG(tags.size() == indices.size(), "Error! Tags vector size differs from indices vector size.\n");
+  EKAT_REQUIRE_MSG(tags.size() == indices.size(),
+                   "Error! Tags vector size differs from indices vector size.\n");
 
   const auto &layout = f.get_header().get_identifier().get_layout();
 
@@ -1033,7 +1048,9 @@ template <Comparison CMP, typename ViewT, typename MaskT> struct SetMaskHelper {
   using MaskST     = typename MaskT::traits::non_const_value_type;
 
   template <int M>
-  using MDRange = Kokkos::MDRangePolicy<exec_space, Kokkos::Rank<M, Kokkos::Iterate::Right, Kokkos::Iterate::Right>>;
+  using MDRange =
+      Kokkos::MDRangePolicy<exec_space,
+                            Kokkos::Rank<M, Kokkos::Iterate::Right, Kokkos::Iterate::Right>>;
 
   static constexpr int N = ViewT::rank;
 
@@ -1096,7 +1113,9 @@ template <Comparison CMP, typename ViewT, typename MaskT> struct SetMaskHelper {
   KOKKOS_INLINE_FUNCTION
   void operator()(int i, int j, int k, int l) const { set_mask(x(i, j, k, l), m(i, j, k, l)); }
   KOKKOS_INLINE_FUNCTION
-  void operator()(int i, int j, int k, int l, int n) const { set_mask(x(i, j, k, l, n), m(i, j, k, l, n)); }
+  void operator()(int i, int j, int k, int l, int n) const {
+    set_mask(x(i, j, k, l, n), m(i, j, k, l, n));
+  }
   KOKKOS_INLINE_FUNCTION
   void operator()(int i, int j, int k, int l, int n, int p) const {
     set_mask(x(i, j, k, l, n, p), m(i, j, k, l, n, p));
@@ -1108,8 +1127,8 @@ template <Comparison CMP, typename ViewT, typename MaskT> struct SetMaskHelper {
 };
 
 template <Comparison CMP, typename ViewT, typename MaskT>
-void setMaskHelper(const ViewT &x, const MaskT &m, const FieldHeader &mh, typename ViewT::traits::value_type val,
-                   const std::vector<int> &dims) {
+void setMaskHelper(const ViewT &x, const MaskT &m, const FieldHeader &mh,
+                   typename ViewT::traits::value_type val, const std::vector<int> &dims) {
   SetMaskHelper<CMP, ViewT, MaskT> helper;
   helper.m   = m;
   helper.x   = x;
@@ -1146,25 +1165,29 @@ template <Comparison CMP, typename ST> void compute_mask(const Field &x, const S
     if (contiguous)
       setMaskHelper<CMP>(x.get_view<const ST ***>(), m.get_view<int ***>(), mh, value, dims);
     else
-      setMaskHelper<CMP>(x.get_strided_view<const ST ***>(), m.get_view<int ***>(), mh, value, dims);
+      setMaskHelper<CMP>(x.get_strided_view<const ST ***>(), m.get_view<int ***>(), mh, value,
+                         dims);
     break;
   case 4:
     if (contiguous)
       setMaskHelper<CMP>(x.get_view<const ST ****>(), m.get_view<int ****>(), mh, value, dims);
     else
-      setMaskHelper<CMP>(x.get_strided_view<const ST ****>(), m.get_view<int ****>(), mh, value, dims);
+      setMaskHelper<CMP>(x.get_strided_view<const ST ****>(), m.get_view<int ****>(), mh, value,
+                         dims);
     break;
   case 5:
     if (contiguous)
       setMaskHelper<CMP>(x.get_view<const ST *****>(), m.get_view<int *****>(), mh, value, dims);
     else
-      setMaskHelper<CMP>(x.get_strided_view<const ST *****>(), m.get_view<int *****>(), mh, value, dims);
+      setMaskHelper<CMP>(x.get_strided_view<const ST *****>(), m.get_view<int *****>(), mh, value,
+                         dims);
     break;
   case 6:
     if (contiguous)
       setMaskHelper<CMP>(x.get_view<const ST ******>(), m.get_view<int ******>(), mh, value, dims);
     else
-      setMaskHelper<CMP>(x.get_strided_view<const ST ******>(), m.get_view<int ******>(), mh, value, dims);
+      setMaskHelper<CMP>(x.get_strided_view<const ST ******>(), m.get_view<int ******>(), mh, value,
+                         dims);
     break;
   default:
     EKAT_ERROR_MSG("Unsupported field rank in compute_mask.\n"
diff --git i/components/eamxx/src/share/grid/abstract_grid.cpp w/components/eamxx/src/share/grid/abstract_grid.cpp
index 11dc64d38a..8469e782d4 100644
--- i/components/eamxx/src/share/grid/abstract_grid.cpp
+++ w/components/eamxx/src/share/grid/abstract_grid.cpp
@@ -12,7 +12,8 @@ namespace scream {
 // Constructor(s) & Destructor
 AbstractGrid::AbstractGrid(const std::string &name, const GridType type, const int num_local_dofs,
                            const int num_vertical_lev, const ekat::Comm &comm)
-    : m_type(type), m_name(name), m_num_local_dofs(num_local_dofs), m_num_vert_levs(num_vertical_lev), m_comm(comm) {
+    : m_type(type), m_name(name), m_num_local_dofs(num_local_dofs),
+      m_num_vert_levs(num_vertical_lev), m_comm(comm) {
   // Sanity checks
   EKAT_REQUIRE_MSG(m_num_local_dofs >= 0, "Error! Number of local dofs must be non-negative.\n");
 
@@ -28,22 +29,24 @@ AbstractGrid::AbstractGrid(const std::string &name, const GridType type, const i
 }
 
 AbstractGrid::AbstractGrid(const std::string &name, const GridType type, const int num_local_dofs,
-                           const int num_global_dofs, const int num_vertical_lev, const ekat::Comm &comm)
+                           const int num_global_dofs, const int num_vertical_lev,
+                           const ekat::Comm &comm)
     : AbstractGrid(name, type, num_local_dofs, num_vertical_lev, comm) {
   m_num_global_dofs = num_global_dofs;
 #ifndef NDEBUG
   int max_nldofs = m_num_local_dofs;
   m_comm.all_reduce(&max_nldofs, 1, MPI_MAX);
-  EKAT_REQUIRE_MSG(max_nldofs <= m_num_global_dofs,
-                   "Error! The number of global dof is smaller than the local number of dofs on some ranks.\n"
-                   " - grid name: " +
-                       name +
-                       "\n"
-                       " - num global dofs: " +
-                       std::to_string(m_num_global_dofs) +
-                       "\n"
-                       " - max num local dofs: " +
-                       std::to_string(max_nldofs) + "\n");
+  EKAT_REQUIRE_MSG(
+      max_nldofs <= m_num_global_dofs,
+      "Error! The number of global dof is smaller than the local number of dofs on some ranks.\n"
+      " - grid name: " +
+          name +
+          "\n"
+          " - num global dofs: " +
+          std::to_string(m_num_global_dofs) +
+          "\n"
+          " - max num local dofs: " +
+          std::to_string(max_nldofs) + "\n");
 #endif
 }
 
@@ -84,7 +87,8 @@ FieldLayout AbstractGrid::get_3d_vector_layout(const bool midpoints, const int v
   return get_3d_vector_layout(midpoints, vector_dim, e2str(CMP));
 }
 
-FieldLayout AbstractGrid::get_3d_tensor_layout(const bool midpoints, const std::vector<int> &cmp_dims) const {
+FieldLayout AbstractGrid::get_3d_tensor_layout(const bool midpoints,
+                                               const std::vector<int> &cmp_dims) const {
   using namespace ShortFieldTagsNames;
   std::vector<std::string> names(cmp_dims.size(), e2str(CMP));
   return get_3d_tensor_layout(midpoints, cmp_dims, names);
@@ -95,11 +99,13 @@ FieldLayout AbstractGrid::equivalent_layout(const FieldLayout &template_layout)
 
   FieldLayout ret_layout = FieldLayout::invalid();
 
-  const bool midpoints   = template_layout.has_tag(LEV);
-  const auto names       = template_layout.names();
-  const auto vec_cmp     = template_layout.is_vector_layout() ? template_layout.get_vector_component_idx() : -1;
-  const auto vec_dim     = template_layout.is_vector_layout() ? template_layout.get_vector_dim() : -1;
-  const auto tensor_dims = template_layout.is_tensor_layout() ? template_layout.get_tensor_dims() : std::vector<int>{};
+  const bool midpoints = template_layout.has_tag(LEV);
+  const auto names     = template_layout.names();
+  const auto vec_cmp =
+      template_layout.is_vector_layout() ? template_layout.get_vector_component_idx() : -1;
+  const auto vec_dim = template_layout.is_vector_layout() ? template_layout.get_vector_dim() : -1;
+  const auto tensor_dims =
+      template_layout.is_tensor_layout() ? template_layout.get_tensor_dims() : std::vector<int>{};
   std::vector<std::string> tdims_names;
   if (template_layout.is_tensor_layout()) {
     for (auto idx : template_layout.get_tensor_components_ids()) {
@@ -304,19 +310,20 @@ Field AbstractGrid::get_geometry_data(const std::string &name) const {
 Field AbstractGrid::create_geometry_data(const FieldIdentifier &fid, const int pack_size) {
   const auto &name = fid.name();
 
-  EKAT_REQUIRE_MSG(not has_geometry_data(name),
-                   "Error! Cannot create geometry data, since it already exists.\n"
-                   "  - grid name: " +
-                       this->name() +
-                       "\n"
-                       "  - geo data name: " +
-                       name +
-                       "\n"
-                       "  - geo data layout: " +
-                       m_geo_fields.at(name).get_header().get_identifier().get_layout().to_string() +
-                       "\n"
-                       "  - input layout: " +
-                       fid.get_layout().to_string() + "\n");
+  EKAT_REQUIRE_MSG(
+      not has_geometry_data(name),
+      "Error! Cannot create geometry data, since it already exists.\n"
+      "  - grid name: " +
+          this->name() +
+          "\n"
+          "  - geo data name: " +
+          name +
+          "\n"
+          "  - geo data layout: " +
+          m_geo_fields.at(name).get_header().get_identifier().get_layout().to_string() +
+          "\n"
+          "  - input layout: " +
+          fid.get_layout().to_string() + "\n");
 
   // Create field and the read only copy as well
   auto &f = m_geo_fields[name] = Field(fid);
@@ -326,23 +333,25 @@ Field AbstractGrid::create_geometry_data(const FieldIdentifier &fid, const int p
 }
 
 void AbstractGrid::delete_geometry_data(const std::string &name) {
-  EKAT_REQUIRE_MSG(has_geometry_data(name), "Error! Cannot delete geometry data, since it is does not exist.\n"
-                                            "  - grid name: " +
-                                                this->name() +
-                                                "\n"
-                                                "  - geo data name: " +
-                                                name + "\n");
+  EKAT_REQUIRE_MSG(has_geometry_data(name),
+                   "Error! Cannot delete geometry data, since it is does not exist.\n"
+                   "  - grid name: " +
+                       this->name() +
+                       "\n"
+                       "  - geo data name: " +
+                       name + "\n");
 
   m_geo_fields.erase(name);
 }
 
 void AbstractGrid::set_geometry_data(const Field &f) const {
-  EKAT_REQUIRE_MSG(not has_geometry_data(f.name()), "Error! Cannot set geometry data, since it already exists.\n"
-                                                    "  - grid name: " +
-                                                        this->name() +
-                                                        "\n"
-                                                        "  - geo data name: " +
-                                                        f.name() + "\n");
+  EKAT_REQUIRE_MSG(not has_geometry_data(f.name()),
+                   "Error! Cannot set geometry data, since it already exists.\n"
+                   "  - grid name: " +
+                       this->name() +
+                       "\n"
+                       "  - geo data name: " +
+                       f.name() + "\n");
 
   m_geo_fields[f.name()] = f;
 }
@@ -383,15 +392,16 @@ std::vector<AbstractGrid::gid_type> AbstractGrid::get_unique_gids() const {
   for (int pid = 1; pid <= m_comm.size(); ++pid) {
     offsets[pid] = offsets[pid - 1] + ngids[pid - 1];
   }
-  EKAT_REQUIRE_MSG(offsets[m_comm.size()] == m_num_global_dofs,
-                   "Error! Something went wrong while computing offsets in AbstractGrid::get_unique_grid.\n");
+  EKAT_REQUIRE_MSG(
+      offsets[m_comm.size()] == m_num_global_dofs,
+      "Error! Something went wrong while computing offsets in AbstractGrid::get_unique_grid.\n");
 
   // Gather all dofs
   const auto mpi_gid_t = ekat::get_mpi_type<gid_type>();
   std::vector<gid_type> all_gids(m_num_global_dofs);
   auto dofs_gids_h = m_dofs_gids.get_view<const gid_type *, Host>();
-  MPI_Allgatherv(dofs_gids_h.data(), m_num_local_dofs, mpi_gid_t, all_gids.data(), ngids.data(), offsets.data(),
-                 mpi_gid_t, m_comm.mpi_comm());
+  MPI_Allgatherv(dofs_gids_h.data(), m_num_local_dofs, mpi_gid_t, all_gids.data(), ngids.data(),
+                 offsets.data(), mpi_gid_t, m_comm.mpi_comm());
 
   // Figure out unique dofs
   std::vector<gid_type> unique_dofs;
@@ -536,15 +546,16 @@ void AbstractGrid::get_remote_pids_and_lids(const gid_view_h &gids, std::vector<
       }
     }
   }
-  EKAT_REQUIRE_MSG(num_found == num_unique_gids, "Error! Could not locate the owner of one of the input GIDs.\n"
-                                                 "  - rank: " +
-                                                     std::to_string(comm.rank()) +
-                                                     "\n"
-                                                     "  - num found: " +
-                                                     std::to_string(num_found) +
-                                                     "\n"
-                                                     "  - num unique gids in: " +
-                                                     std::to_string(num_unique_gids) + "\n");
+  EKAT_REQUIRE_MSG(num_found == num_unique_gids,
+                   "Error! Could not locate the owner of one of the input GIDs.\n"
+                   "  - rank: " +
+                       std::to_string(comm.rank()) +
+                       "\n"
+                       "  - num found: " +
+                       std::to_string(num_found) +
+                       "\n"
+                       "  - num unique gids in: " +
+                       std::to_string(num_unique_gids) + "\n");
 }
 
 void AbstractGrid::create_dof_fields(const int scalar2d_layout_rank) {
@@ -556,8 +567,9 @@ void AbstractGrid::create_dof_fields(const int scalar2d_layout_rank) {
   // lid2idx is the rank of a 2d scalar layout.
   FieldLayout dof_layout({COL}, {get_num_local_dofs()});
   FieldLayout lid2idx_layout({COL, CMP}, {get_num_local_dofs(), scalar2d_layout_rank});
-  m_dofs_gids  = Field(FieldIdentifier("gids", dof_layout, units, m_name, DataType::IntType));
-  m_lid_to_idx = Field(FieldIdentifier("lid2idx", lid2idx_layout, units, m_name, DataType::IntType));
+  m_dofs_gids = Field(FieldIdentifier("gids", dof_layout, units, m_name, DataType::IntType));
+  m_lid_to_idx =
+      Field(FieldIdentifier("lid2idx", lid2idx_layout, units, m_name, DataType::IntType));
 
   m_dofs_gids.allocate_view();
   m_lid_to_idx.allocate_view();
diff --git i/components/eamxx/src/share/grid/abstract_grid.hpp w/components/eamxx/src/share/grid/abstract_grid.hpp
index fe89713039..47d9e9e92f 100644
--- i/components/eamxx/src/share/grid/abstract_grid.hpp
+++ w/components/eamxx/src/share/grid/abstract_grid.hpp
@@ -45,12 +45,12 @@ public:
   using gid_view_h = Field::view_host_t<const gid_type *>;
 
   // Constructor(s) & Destructor
-  AbstractGrid(const std::string &name, const GridType type, const int num_local_dofs, const int num_vertical_lev,
-               const ekat::Comm &comm);
-
-  AbstractGrid(const std::string &name, const GridType type, const int num_local_dofs, const int num_global_dofs,
+  AbstractGrid(const std::string &name, const GridType type, const int num_local_dofs,
                const int num_vertical_lev, const ekat::Comm &comm);
 
+  AbstractGrid(const std::string &name, const GridType type, const int num_local_dofs,
+               const int num_global_dofs, const int num_vertical_lev, const ekat::Comm &comm);
+
   virtual ~AbstractGrid() = default;
 
   // Grid description utilities
@@ -64,17 +64,21 @@ public:
   // E.g., for a scalar 2d field on a SE grid, this will be (nelem,np,np),
   //       for a vector 3d field on a Point grid it will be (ncols,vector_dim,nlevs)
   FieldLayout get_vertical_layout(const bool midpoints) const;
-  FieldLayout get_vertical_layout(const bool midpoints, const int vector_dim,
-                                  const std::string &vec_dim_name = e2str(FieldTag::Component)) const;
-  virtual FieldLayout get_2d_scalar_layout() const                                                      = 0;
-  virtual FieldLayout get_2d_vector_layout(const int vector_dim, const std::string &vec_dim_name) const = 0;
-  virtual FieldLayout get_2d_tensor_layout(const std::vector<int> &cmp_dims,
-                                           const std::vector<std::string> &cmp_dims_names) const        = 0;
-  virtual FieldLayout get_3d_scalar_layout(const bool midpoints) const                                  = 0;
+  FieldLayout
+  get_vertical_layout(const bool midpoints, const int vector_dim,
+                      const std::string &vec_dim_name = e2str(FieldTag::Component)) const;
+  virtual FieldLayout get_2d_scalar_layout() const                                = 0;
+  virtual FieldLayout get_2d_vector_layout(const int vector_dim,
+                                           const std::string &vec_dim_name) const = 0;
+  virtual FieldLayout
+  get_2d_tensor_layout(const std::vector<int> &cmp_dims,
+                       const std::vector<std::string> &cmp_dims_names) const      = 0;
+  virtual FieldLayout get_3d_scalar_layout(const bool midpoints) const            = 0;
   virtual FieldLayout get_3d_vector_layout(const bool midpoints, const int vector_dim,
-                                           const std::string &vec_dim_name) const                       = 0;
-  virtual FieldLayout get_3d_tensor_layout(const bool midpoints, const std::vector<int> &cmp_dims,
-                                           const std::vector<std::string> &cmp_dims_names) const        = 0;
+                                           const std::string &vec_dim_name) const = 0;
+  virtual FieldLayout
+  get_3d_tensor_layout(const bool midpoints, const std::vector<int> &cmp_dims,
+                       const std::vector<std::string> &cmp_dims_names) const = 0;
 
   // Some shortcut versions of the above ones, where the name of the vector/tensor
   // components are all equal to e2str(CMP)
@@ -132,8 +136,10 @@ public:
   Field create_geometry_data(const FieldIdentifier &fid, const int pack_size = 1);
   Field create_geometry_data(const std::string &name, const FieldLayout &layout,
                              const ekat::units::Units &units = ekat::units::Units::invalid(),
-                             const DataType data_type = DataType::RealType, const int pack_size = 1) {
-    return create_geometry_data(FieldIdentifier(name, layout, units, this->name(), data_type), pack_size);
+                             const DataType data_type        = DataType::RealType,
+                             const int pack_size             = 1) {
+    return create_geometry_data(FieldIdentifier(name, layout, units, this->name(), data_type),
+                                pack_size);
   }
 
   // Sets pre-existing field as geometry data.
@@ -143,14 +149,17 @@ public:
   void set_geometry_data(const Field &f) const;
   void delete_geometry_data(const std::string &name);
 
-  bool has_geometry_data(const std::string &name) const { return m_geo_fields.find(name) != m_geo_fields.end(); }
+  bool has_geometry_data(const std::string &name) const {
+    return m_geo_fields.find(name) != m_geo_fields.end();
+  }
 
   // Get list of currently stored geometry data views
   std::list<std::string> get_geometry_data_names() const;
 
   // Creates a copy of this grid. If shallow=true, the copy shares views with
   // *this, otherwise each stored array is deep copied
-  virtual std::shared_ptr<AbstractGrid> clone(const std::string &clone_name, const bool shallow) const = 0;
+  virtual std::shared_ptr<AbstractGrid> clone(const std::string &clone_name,
+                                              const bool shallow) const = 0;
 
   // Allows to change the number of vertical levels associated with this grid.
   void reset_num_vertical_lev(const int num_vertical_lev);
@@ -167,7 +176,8 @@ public:
     return get_owners(gids_v);
   }
 
-  void get_remote_pids_and_lids(const gid_view_h &gids, std::vector<int> &pids, std::vector<int> &lids) const;
+  void get_remote_pids_and_lids(const gid_view_h &gids, std::vector<int> &pids,
+                                std::vector<int> &lids) const;
   void get_remote_pids_and_lids(const std::vector<gid_type> &gids, std::vector<int> &pids,
                                 std::vector<int> &lids) const {
     gid_view_h gids_v(gids.data(), gids.size());
@@ -240,7 +250,8 @@ protected:
   // Mutable, for lazy calculation
   mutable std::map<gid_type, int> m_gid2lid;
 
-  // For thread safety in modifying mutable items (just in case someone ever runs this code in threaded regions)
+  // For thread safety in modifying mutable items (just in case someone ever runs this code in
+  // threaded regions)
   mutable std::mutex m_mutex;
 
   // The MPI comm containing the ranks across which the global mesh is partitioned
diff --git i/components/eamxx/src/share/grid/grid_import_export.cpp w/components/eamxx/src/share/grid/grid_import_export.cpp
index e44ea0d3ae..8ddd11b470 100644
--- i/components/eamxx/src/share/grid/grid_import_export.cpp
+++ w/components/eamxx/src/share/grid/grid_import_export.cpp
@@ -73,15 +73,16 @@ GridImportExport::GridImportExport(const std::shared_ptr<const AbstractGrid> &un
       }
     }
   }
-  EKAT_REQUIRE_MSG(num_ov_gids == num_imports, "Error! Could not locate the owner of one of the dst grid GIDs.\n"
-                                               "  - rank: " +
-                                                   std::to_string(m_comm.rank()) +
-                                                   "\n"
-                                                   "  - num found: " +
-                                                   std::to_string(num_imports) +
-                                                   "\n"
-                                                   "  - num dst gids: " +
-                                                   std::to_string(num_ov_gids) + "\n");
+  EKAT_REQUIRE_MSG(num_ov_gids == num_imports,
+                   "Error! Could not locate the owner of one of the dst grid GIDs.\n"
+                   "  - rank: " +
+                       std::to_string(m_comm.rank()) +
+                       "\n"
+                       "  - num found: " +
+                       std::to_string(num_imports) +
+                       "\n"
+                       "  - num dst gids: " +
+                       std::to_string(num_ov_gids) + "\n");
   for (int pid = 0, pos = 0; pid < m_comm.size(); ++pid) {
     const auto &lids = pid2lids[pid];
     for (size_t i = 0; i < lids.size(); ++i, ++pos) {
diff --git i/components/eamxx/src/share/grid/grid_import_export.hpp w/components/eamxx/src/share/grid/grid_import_export.hpp
index 9b8850d570..d3ac69bbb5 100644
--- i/components/eamxx/src/share/grid/grid_import_export.hpp
+++ w/components/eamxx/src/share/grid/grid_import_export.hpp
@@ -115,7 +115,8 @@ protected:
 // in opposite directions.
 
 template <typename T>
-void GridImportExport::scatter(const MPI_Datatype mpi_data_t, const std::map<int, std::vector<T>> &src,
+void GridImportExport::scatter(const MPI_Datatype mpi_data_t,
+                               const std::map<int, std::vector<T>> &src,
                                std::map<int, std::vector<T>> &dst) const {
   const auto tag = 0;
 
@@ -241,7 +242,8 @@ void GridImportExport::scatter(const MPI_Datatype mpi_data_t, const std::map<int
 }
 
 template <typename T>
-void GridImportExport::gather(const MPI_Datatype mpi_data_t, const std::map<int, std::vector<T>> &src,
+void GridImportExport::gather(const MPI_Datatype mpi_data_t,
+                              const std::map<int, std::vector<T>> &src,
                               std::map<int, std::vector<T>> &dst) const {
   const auto tag = 0;
 
diff --git i/components/eamxx/src/share/grid/grids_manager.cpp w/components/eamxx/src/share/grid/grids_manager.cpp
index 3433bd7d03..25c01da905 100644
--- i/components/eamxx/src/share/grid/grids_manager.cpp
+++ w/components/eamxx/src/share/grid/grids_manager.cpp
@@ -3,7 +3,8 @@
 namespace scream {
 
 auto GridsManager::get_grid(const std::string &name) const -> grid_ptr_type {
-  EKAT_REQUIRE_MSG(has_grid(name), "Error! Grids manager '" + this->name() + "' does not provide grid '" + name +
+  EKAT_REQUIRE_MSG(has_grid(name), "Error! Grids manager '" + this->name() +
+                                       "' does not provide grid '" + name +
                                        "'.\n"
                                        "       Avaialble grids are: " +
                                        print_available_grids() + "\n");
@@ -36,10 +37,13 @@ bool GridsManager::has_grid(const std::string &grid_name) const {
   return false;
 }
 
-auto GridsManager::create_remapper(const grid_ptr_type &from_grid, const grid_ptr_type &to_grid) const
+auto GridsManager::create_remapper(const grid_ptr_type &from_grid,
+                                   const grid_ptr_type &to_grid) const
     -> GridsManager::remapper_ptr_type {
-  EKAT_REQUIRE_MSG(has_grid(from_grid->name()), "Error! Source grid '" + from_grid->name() + "' is not supported.\n");
-  EKAT_REQUIRE_MSG(has_grid(to_grid->name()), "Error! Target grid '" + to_grid->name() + "' is not supported.\n");
+  EKAT_REQUIRE_MSG(has_grid(from_grid->name()),
+                   "Error! Source grid '" + from_grid->name() + "' is not supported.\n");
+  EKAT_REQUIRE_MSG(has_grid(to_grid->name()),
+                   "Error! Target grid '" + to_grid->name() + "' is not supported.\n");
 
   remapper_ptr_type remapper;
 
@@ -50,10 +54,11 @@ auto GridsManager::create_remapper(const grid_ptr_type &from_grid, const grid_pt
     remapper = do_create_remapper(from_grid, to_grid);
   }
 
-  EKAT_REQUIRE_MSG(remapper != nullptr,
-                   "Error! A remapper from grid '" + from_grid->name() + "' to grid '" + to_grid->name() +
-                       "' is not available.\n"
-                       "       Perhaps you forgot to add its creation to the implementation of the grids manager?\n");
+  EKAT_REQUIRE_MSG(remapper != nullptr, "Error! A remapper from grid '" + from_grid->name() +
+                                            "' to grid '" + to_grid->name() +
+                                            "' is not available.\n"
+                                            "       Perhaps you forgot to add its creation to the "
+                                            "implementation of the grids manager?\n");
 
   return remapper;
 }
@@ -76,7 +81,8 @@ void GridsManager::add_grid(grid_ptr_type grid) {
 }
 
 auto GridsManager::get_grid_nonconst(const std::string &name) const -> nonconstgrid_ptr_type {
-  EKAT_REQUIRE_MSG(has_grid(name), "Error! Grids manager '" + this->name() + "' does not provide grid '" + name +
+  EKAT_REQUIRE_MSG(has_grid(name), "Error! Grids manager '" + this->name() +
+                                       "' does not provide grid '" + name +
                                        "'.\n"
                                        "       Avaialble grids are: " +
                                        print_available_grids() + "\n");
@@ -116,15 +122,16 @@ void GridsManager::alias_grid(const std::string &grid_name, const std::string &g
   }
 
   auto g = get_grid_nonconst(grid_name);
-  EKAT_REQUIRE_MSG(not has_grid(grid_alias), "Cannot alias grid, since another grid with alias name already exists.\n"
-                                             "  - grids manager: " +
-                                                 this->name() +
-                                                 "\n"
-                                                 "  - grid name    : " +
-                                                 grid_name +
-                                                 "\n"
-                                                 "  - grid alias   : " +
-                                                 grid_alias + "\n");
+  EKAT_REQUIRE_MSG(not has_grid(grid_alias),
+                   "Cannot alias grid, since another grid with alias name already exists.\n"
+                   "  - grids manager: " +
+                       this->name() +
+                       "\n"
+                       "  - grid name    : " +
+                       grid_name +
+                       "\n"
+                       "  - grid alias   : " +
+                       grid_alias + "\n");
 
   g->add_alias(grid_alias);
 }
diff --git i/components/eamxx/src/share/grid/grids_manager.hpp w/components/eamxx/src/share/grid/grids_manager.hpp
index 3902fd9723..5512bf5db1 100644
--- i/components/eamxx/src/share/grid/grids_manager.hpp
+++ w/components/eamxx/src/share/grid/grids_manager.hpp
@@ -40,9 +40,11 @@ public:
 
   virtual void build_grids() = 0;
 
-  remapper_ptr_type create_remapper(const grid_ptr_type &from_grid, const grid_ptr_type &to_grid) const;
+  remapper_ptr_type create_remapper(const grid_ptr_type &from_grid,
+                                    const grid_ptr_type &to_grid) const;
 
-  remapper_ptr_type create_remapper(const std::string &from_grid, const std::string &to_grid) const {
+  remapper_ptr_type create_remapper(const std::string &from_grid,
+                                    const std::string &to_grid) const {
     return create_remapper(get_grid(from_grid), get_grid(to_grid));
   }
 
@@ -59,7 +61,8 @@ protected:
   void add_grid(grid_ptr_type grid);
   void alias_grid(const std::string &grid_name, const std::string &grid_alias);
 
-  virtual remapper_ptr_type do_create_remapper(const grid_ptr_type from_grid, const grid_ptr_type to_grid) const = 0;
+  virtual remapper_ptr_type do_create_remapper(const grid_ptr_type from_grid,
+                                               const grid_ptr_type to_grid) const = 0;
 
 private:
   grid_repo_type m_grids;
@@ -67,8 +70,9 @@ private:
 };
 
 // A short name for the factory for grid managers
-using GridsManagerFactory = ekat::Factory<GridsManager, ekat::CaseInsensitiveString, std::shared_ptr<GridsManager>,
-                                          const ekat::Comm &, const ekat::ParameterList &>;
+using GridsManagerFactory =
+    ekat::Factory<GridsManager, ekat::CaseInsensitiveString, std::shared_ptr<GridsManager>,
+                  const ekat::Comm &, const ekat::ParameterList &>;
 
 } // namespace scream
 
diff --git i/components/eamxx/src/share/grid/library_grids_manager.hpp w/components/eamxx/src/share/grid/library_grids_manager.hpp
index ae1c8820d6..68c31ece90 100644
--- i/components/eamxx/src/share/grid/library_grids_manager.hpp
+++ w/components/eamxx/src/share/grid/library_grids_manager.hpp
@@ -30,7 +30,8 @@ public:
   }
 
 protected:
-  remapper_ptr_type do_create_remapper(const grid_ptr_type from_grid, const grid_ptr_type to_grid) const {
+  remapper_ptr_type do_create_remapper(const grid_ptr_type from_grid,
+                                       const grid_ptr_type to_grid) const {
     EKAT_ERROR_MSG("Error! LibraryGridsManager is not capable of creating remappers.\n"
                    " - from_grid: " +
                    from_grid->name() +
diff --git i/components/eamxx/src/share/grid/mesh_free_grids_manager.cpp w/components/eamxx/src/share/grid/mesh_free_grids_manager.cpp
index 22557a1a89..4a00d7fd6f 100644
--- i/components/eamxx/src/share/grid/mesh_free_grids_manager.cpp
+++ w/components/eamxx/src/share/grid/mesh_free_grids_manager.cpp
@@ -21,7 +21,8 @@ MeshFreeGridsManager::MeshFreeGridsManager(const ekat::Comm &comm, const ekat::P
 }
 
 MeshFreeGridsManager::remapper_ptr_type
-MeshFreeGridsManager::do_create_remapper(const grid_ptr_type /* from_grid */, const grid_ptr_type /* to_grid */) const {
+MeshFreeGridsManager::do_create_remapper(const grid_ptr_type /* from_grid */,
+                                         const grid_ptr_type /* to_grid */) const {
   EKAT_ERROR_MSG("Error! MeshFreeGridsManager does not offer any remapper.\n");
   return nullptr;
 }
@@ -105,7 +106,7 @@ void MeshFreeGridsManager::build_se_grid(const std::string &name, ekat::Paramete
 void MeshFreeGridsManager::build_point_grid(const std::string &name, ekat::ParameterList &params) {
   const int num_global_cols     = params.get<int>("number_of_global_columns");
   const int num_vertical_levels = params.get<int>("number_of_vertical_levels");
-  auto pt_grid                  = create_point_grid(name, num_global_cols, num_vertical_levels, m_comm);
+  auto pt_grid = create_point_grid(name, num_global_cols, num_vertical_levels, m_comm);
 
   const auto units = ekat::units::Units::nondimensional();
 
@@ -173,7 +174,8 @@ void MeshFreeGridsManager::add_geo_data(const nonconstgrid_ptr_type &grid) const
   }
 }
 
-void MeshFreeGridsManager::load_lat_lon(const nonconstgrid_ptr_type &grid, const std::string &filename) const {
+void MeshFreeGridsManager::load_lat_lon(const nonconstgrid_ptr_type &grid,
+                                        const std::string &filename) const {
   using geo_view_host = AtmosphereInput::view_1d_host;
   const auto units    = ekat::units::Units::nondimensional();
 
@@ -185,8 +187,9 @@ void MeshFreeGridsManager::load_lat_lon(const nonconstgrid_ptr_type &grid, const
                                                      {"lon", lon.get_view<Real *, Host>()}};
 
   // Store view layouts
-  std::map<std::string, FieldLayout> layouts = {{"lat", lat.get_header().get_identifier().get_layout()},
-                                                {"lon", lon.get_header().get_identifier().get_layout()}};
+  std::map<std::string, FieldLayout> layouts = {
+      {"lat", lat.get_header().get_identifier().get_layout()},
+      {"lon", lon.get_header().get_identifier().get_layout()}};
 
   // Read lat/lon into host views
   ekat::ParameterList lat_lon_reader_pl;
@@ -240,10 +243,11 @@ void MeshFreeGridsManager::load_vertical_coordinates(const nonconstgrid_ptr_type
 
   // Store view layouts
   using namespace ShortFieldTagsNames;
-  std::map<std::string, FieldLayout> layouts = {{"hyam", hyam.get_header().get_identifier().get_layout()},
-                                                {"hybm", hybm.get_header().get_identifier().get_layout()},
-                                                {"hyai", hyai.get_header().get_identifier().get_layout()},
-                                                {"hybi", hybi.get_header().get_identifier().get_layout()}};
+  std::map<std::string, FieldLayout> layouts = {
+      {"hyam", hyam.get_header().get_identifier().get_layout()},
+      {"hybm", hybm.get_header().get_identifier().get_layout()},
+      {"hyai", hyai.get_header().get_identifier().get_layout()},
+      {"hybi", hybi.get_header().get_identifier().get_layout()}};
 
   // Read hyam/hybm into host views
   ekat::ParameterList vcoord_reader_pl;
@@ -292,9 +296,9 @@ void MeshFreeGridsManager::load_vertical_coordinates(const nonconstgrid_ptr_type
 #endif
 }
 
-std::shared_ptr<GridsManager> create_mesh_free_grids_manager(const ekat::Comm &comm, const int num_local_elems,
-                                                             const int num_gp, const int num_vertical_levels,
-                                                             const int num_global_cols) {
+std::shared_ptr<GridsManager>
+create_mesh_free_grids_manager(const ekat::Comm &comm, const int num_local_elems, const int num_gp,
+                               const int num_vertical_levels, const int num_global_cols) {
   ekat::ParameterList gm_params;
   std::vector<std::string> grids_names;
   if (num_local_elems >= 2) {
diff --git i/components/eamxx/src/share/grid/mesh_free_grids_manager.hpp w/components/eamxx/src/share/grid/mesh_free_grids_manager.hpp
index 2b328cbb82..ea90ce61f2 100644
--- i/components/eamxx/src/share/grid/mesh_free_grids_manager.hpp
+++ w/components/eamxx/src/share/grid/mesh_free_grids_manager.hpp
@@ -34,12 +34,16 @@ protected:
 
   void add_geo_data(const nonconstgrid_ptr_type &grid) const;
 
-  std::string get_reference_grid_name() const { return m_params.get<std::string>("reference_grid"); }
+  std::string get_reference_grid_name() const {
+    return m_params.get<std::string>("reference_grid");
+  }
 
-  remapper_ptr_type do_create_remapper(const grid_ptr_type from_grid, const grid_ptr_type to_grid) const;
+  remapper_ptr_type do_create_remapper(const grid_ptr_type from_grid,
+                                       const grid_ptr_type to_grid) const;
 
   void load_lat_lon(const nonconstgrid_ptr_type &grid, const std::string &filename) const;
-  void load_vertical_coordinates(const nonconstgrid_ptr_type &grid, const std::string &filename) const;
+  void load_vertical_coordinates(const nonconstgrid_ptr_type &grid,
+                                 const std::string &filename) const;
   remap_repo_type m_remappers;
 
   ekat::ParameterList m_params;
@@ -53,9 +57,9 @@ inline std::shared_ptr<GridsManager> create_mesh_free_grids_manager(const ekat::
 }
 
 // Shortcut creator function, for the sake of unit tests
-std::shared_ptr<GridsManager> create_mesh_free_grids_manager(const ekat::Comm &comm, const int num_local_elems,
-                                                             const int num_gp, const int num_vertical_levels,
-                                                             const int num_global_cols);
+std::shared_ptr<GridsManager>
+create_mesh_free_grids_manager(const ekat::Comm &comm, const int num_local_elems, const int num_gp,
+                               const int num_vertical_levels, const int num_global_cols);
 
 inline void register_mesh_free_grids_manager() {
   // A simple grids manager, useful to run physics-only unit tests
diff --git i/components/eamxx/src/share/grid/point_grid.cpp w/components/eamxx/src/share/grid/point_grid.cpp
index 994c01f56a..671c7b153a 100644
--- i/components/eamxx/src/share/grid/point_grid.cpp
+++ w/components/eamxx/src/share/grid/point_grid.cpp
@@ -6,8 +6,8 @@
 
 namespace scream {
 
-PointGrid::PointGrid(const std::string &grid_name, const int num_my_cols, const int num_vertical_levels,
-                     const ekat::Comm &comm)
+PointGrid::PointGrid(const std::string &grid_name, const int num_my_cols,
+                     const int num_vertical_levels, const ekat::Comm &comm)
     : AbstractGrid(grid_name, GridType::Point, num_my_cols, num_vertical_levels, comm) {
   create_dof_fields(get_2d_scalar_layout().rank());
 
@@ -23,7 +23,8 @@ PointGrid::PointGrid(const std::string &grid_name, const int num_my_cols, const
 
 PointGrid::PointGrid(const std::string &grid_name, const int num_my_cols, const int num_global_cols,
                      const int num_vertical_levels, const ekat::Comm &comm)
-    : AbstractGrid(grid_name, GridType::Point, num_my_cols, num_global_cols, num_vertical_levels, comm) {
+    : AbstractGrid(grid_name, GridType::Point, num_my_cols, num_global_cols, num_vertical_levels,
+                   comm) {
   create_dof_fields(get_2d_scalar_layout().rank());
 
   // The lid->idx map is the identity map.
@@ -39,7 +40,8 @@ FieldLayout PointGrid::get_2d_scalar_layout() const {
   return FieldLayout({COL}, {get_num_local_dofs()}).rename_dims(m_special_tag_names);
 }
 
-FieldLayout PointGrid::get_2d_vector_layout(const int vector_dim, const std::string &vec_dim_name) const {
+FieldLayout PointGrid::get_2d_vector_layout(const int vector_dim,
+                                            const std::string &vec_dim_name) const {
   using namespace ShortFieldTagsNames;
 
   FieldLayout fl({COL, CMP}, {get_num_local_dofs(), vector_dim});
@@ -120,14 +122,17 @@ FieldLayout PointGrid::get_3d_tensor_layout(const bool midpoints, const std::vec
   return fl.rename_dims(m_special_tag_names);
 }
 
-std::shared_ptr<AbstractGrid> PointGrid::clone(const std::string &clone_name, const bool shallow) const {
-  auto grid = std::make_shared<PointGrid>(clone_name, get_num_local_dofs(), get_num_vertical_levels(), get_comm());
+std::shared_ptr<AbstractGrid> PointGrid::clone(const std::string &clone_name,
+                                               const bool shallow) const {
+  auto grid = std::make_shared<PointGrid>(clone_name, get_num_local_dofs(),
+                                          get_num_vertical_levels(), get_comm());
   grid->copy_data(*this, shallow);
   return grid;
 }
 
-std::shared_ptr<PointGrid> create_point_grid(const std::string &grid_name, const int num_global_cols,
-                                             const int num_vertical_lev, const ekat::Comm &comm) {
+std::shared_ptr<PointGrid> create_point_grid(const std::string &grid_name,
+                                             const int num_global_cols, const int num_vertical_lev,
+                                             const ekat::Comm &comm) {
   // Compute how many columns are owned by this rank
   const int num_procs = comm.size();
 
diff --git i/components/eamxx/src/share/grid/point_grid.hpp w/components/eamxx/src/share/grid/point_grid.hpp
index 32dc441eea..73317a6fef 100644
--- i/components/eamxx/src/share/grid/point_grid.hpp
+++ w/components/eamxx/src/share/grid/point_grid.hpp
@@ -24,7 +24,8 @@ namespace scream {
 
 class PointGrid : public AbstractGrid {
 public:
-  PointGrid(const std::string &grid_name, const int num_my_cols, const int num_vertical_levels, const ekat::Comm &comm);
+  PointGrid(const std::string &grid_name, const int num_my_cols, const int num_vertical_levels,
+            const ekat::Comm &comm);
 
   PointGrid(const std::string &grid_name, const int num_my_cols, const int num_global_cols,
             const int num_vertical_levels, const ekat::Comm &comm);
@@ -34,7 +35,8 @@ public:
   // Native layout of a dof. This is the natural way to index a dof in the grid.
   // E.g., for a 2d structured grid, this could be a set of 2 indices.
   FieldLayout get_2d_scalar_layout() const override;
-  FieldLayout get_2d_vector_layout(const int vector_dim, const std::string &vec_dim_name) const override;
+  FieldLayout get_2d_vector_layout(const int vector_dim,
+                                   const std::string &vec_dim_name) const override;
   FieldLayout get_2d_tensor_layout(const std::vector<int> &cmp_dims,
                                    const std::vector<std::string> &cmp_names) const override;
   FieldLayout get_3d_scalar_layout(const bool midpoints) const override;
@@ -47,7 +49,8 @@ public:
   int get_partitioned_dim_local_size() const override { return get_num_local_dofs(); }
   int get_partitioned_dim_global_size() const override { return get_num_global_dofs(); }
 
-  std::shared_ptr<AbstractGrid> clone(const std::string &clone_name, const bool shallow) const override;
+  std::shared_ptr<AbstractGrid> clone(const std::string &clone_name,
+                                      const bool shallow) const override;
 };
 
 // Create a point grid, with linear range of gids, evenly partitioned
diff --git i/components/eamxx/src/share/grid/remap/abstract_remapper.cpp w/components/eamxx/src/share/grid/remap/abstract_remapper.cpp
index cf6cc5c19b..19970be3d7 100644
--- i/components/eamxx/src/share/grid/remap/abstract_remapper.cpp
+++ w/components/eamxx/src/share/grid/remap/abstract_remapper.cpp
@@ -7,8 +7,9 @@ AbstractRemapper::AbstractRemapper(const grid_ptr_type &src_grid, const grid_ptr
 }
 
 void AbstractRemapper::registration_begins() {
-  EKAT_REQUIRE_MSG(m_state == RepoState::Clean, "Error! Cannot start registration on a non-clean repo.\n"
-                                                "       Did you call 'registration_begins' already?\n");
+  EKAT_REQUIRE_MSG(m_state == RepoState::Clean,
+                   "Error! Cannot start registration on a non-clean repo.\n"
+                   "       Did you call 'registration_begins' already?\n");
 
   m_state = RepoState::Open;
 }
@@ -16,7 +17,8 @@ void AbstractRemapper::registration_begins() {
 void AbstractRemapper::register_field(const Field &src, const Field &tgt) {
   EKAT_REQUIRE_MSG(m_state == RepoState::Open,
                    "Error! Cannot register fields in the remapper at this time.\n"
-                   "       Did you forget to call 'registration_begins' or called 'registeration_ends' already?");
+                   "       Did you forget to call 'registration_begins' or called "
+                   "'registeration_ends' already?");
 
   EKAT_REQUIRE_MSG(src.is_allocated(), "Error! Source field is not yet allocated.\n");
   EKAT_REQUIRE_MSG(tgt.is_allocated(), "Error! Target field is not yet allocated.\n");
@@ -35,18 +37,19 @@ void AbstractRemapper::register_field(const Field &src, const Field &tgt) {
                                                         "\n"
                                                         " - field layout: " +
                                                         tgt_layout.to_string() + "\n");
-  EKAT_REQUIRE_MSG(compatible_layouts(src_layout, tgt_layout), "Error! Source and target layouts are not compatible.\n"
-                                                               " - src name: " +
-                                                                   src.name() +
-                                                                   "\n"
-                                                                   " - tgt name: " +
-                                                                   tgt.name() +
-                                                                   "\n"
-                                                                   " - src layout: " +
-                                                                   src_layout.to_string() +
-                                                                   "\n"
-                                                                   " - tgt layout: " +
-                                                                   tgt_layout.to_string() + "\n");
+  EKAT_REQUIRE_MSG(compatible_layouts(src_layout, tgt_layout),
+                   "Error! Source and target layouts are not compatible.\n"
+                   " - src name: " +
+                       src.name() +
+                       "\n"
+                       " - tgt name: " +
+                       tgt.name() +
+                       "\n"
+                       " - src layout: " +
+                       src_layout.to_string() +
+                       "\n"
+                       " - tgt layout: " +
+                       tgt_layout.to_string() + "\n");
 
   if (src.is_read_only()) {
     m_has_read_only_src_fields = true;
@@ -88,8 +91,9 @@ void AbstractRemapper::register_field_from_tgt(const Field &tgt) {
 }
 
 void AbstractRemapper::registration_ends() {
-  EKAT_REQUIRE_MSG(m_state != RepoState::Closed, "Error! Cannot call registration_ends at this time.\n"
-                                                 "       Did you accidentally call 'registration_ends' already?");
+  EKAT_REQUIRE_MSG(m_state != RepoState::Closed,
+                   "Error! Cannot call registration_ends at this time.\n"
+                   "       Did you accidentally call 'registration_ends' already?");
 
   // Call derived class impl first. They may register extra/internal fields,
   // so we must keep the repo OPEN until they're done.
@@ -99,25 +103,29 @@ void AbstractRemapper::registration_ends() {
 }
 
 void AbstractRemapper::remap_fwd() {
-  EKAT_REQUIRE_MSG(m_state != RepoState::Open, "Error! Cannot perform remapping at this time.\n"
-                                               "       Did you forget to call 'registration_ends'?\n");
+  EKAT_REQUIRE_MSG(m_state != RepoState::Open,
+                   "Error! Cannot perform remapping at this time.\n"
+                   "       Did you forget to call 'registration_ends'?\n");
 
   if (m_state != RepoState::Clean) {
     EKAT_REQUIRE_MSG(m_fwd_allowed, "Error! Forward remap is not allowed by this remapper.\n");
     EKAT_REQUIRE_MSG(not m_has_read_only_tgt_fields,
-                     "Error! Forward remap IS allowed by this remapper, but some of the tgt fields are read-only\n");
+                     "Error! Forward remap IS allowed by this remapper, but some of the tgt fields "
+                     "are read-only\n");
     remap_fwd_impl();
   }
 }
 
 void AbstractRemapper::remap_bwd() {
-  EKAT_REQUIRE_MSG(m_state != RepoState::Open, "Error! Cannot perform remapping at this time.\n"
-                                               "       Did you forget to call 'registration_ends'?\n");
+  EKAT_REQUIRE_MSG(m_state != RepoState::Open,
+                   "Error! Cannot perform remapping at this time.\n"
+                   "       Did you forget to call 'registration_ends'?\n");
 
   if (m_state != RepoState::Clean) {
     EKAT_REQUIRE_MSG(m_bwd_allowed, "Error! Backward remap is not allowed by this remapper.\n");
     EKAT_REQUIRE_MSG(not m_has_read_only_src_fields,
-                     "Error! Backward remap IS allowed by this remapper, but some of the src fields are read-only\n");
+                     "Error! Backward remap IS allowed by this remapper, but some of the src "
+                     "fields are read-only\n");
     remap_bwd_impl();
   }
 }
@@ -159,23 +167,27 @@ FieldIdentifier AbstractRemapper::create_tgt_fid(const FieldIdentifier &src_fid)
 }
 
 FieldLayout AbstractRemapper::create_src_layout(const FieldLayout &tgt_layout) const {
-  EKAT_REQUIRE_MSG(m_src_grid != nullptr, "Error! Cannot create source layout until the source grid has been set.\n");
+  EKAT_REQUIRE_MSG(m_src_grid != nullptr,
+                   "Error! Cannot create source layout until the source grid has been set.\n");
 
-  EKAT_REQUIRE_MSG(is_valid_tgt_layout(tgt_layout),
-                   "[HorizInterpRemapperBase] Error! Input target layout is not valid for this remapper.\n"
-                   " - input layout: " +
-                       tgt_layout.to_string());
+  EKAT_REQUIRE_MSG(
+      is_valid_tgt_layout(tgt_layout),
+      "[HorizInterpRemapperBase] Error! Input target layout is not valid for this remapper.\n"
+      " - input layout: " +
+          tgt_layout.to_string());
 
   return create_layout(tgt_layout, m_src_grid);
 }
 
 FieldLayout AbstractRemapper::create_tgt_layout(const FieldLayout &src_layout) const {
-  EKAT_REQUIRE_MSG(m_tgt_grid != nullptr, "Error! Cannot create target layout until the target grid has been set.\n");
+  EKAT_REQUIRE_MSG(m_tgt_grid != nullptr,
+                   "Error! Cannot create target layout until the target grid has been set.\n");
 
-  EKAT_REQUIRE_MSG(is_valid_src_layout(src_layout),
-                   "[HorizInterpRemapperBase] Error! Input source layout is not valid for this remapper.\n"
-                   " - input layout: " +
-                       src_layout.to_string());
+  EKAT_REQUIRE_MSG(
+      is_valid_src_layout(src_layout),
+      "[HorizInterpRemapperBase] Error! Input source layout is not valid for this remapper.\n"
+      " - input layout: " +
+          src_layout.to_string());
 
   return create_layout(src_layout, m_tgt_grid);
 }
@@ -193,7 +205,8 @@ bool AbstractRemapper::compatible_layouts(const FieldLayout &src, const FieldLay
   return true;
 }
 
-FieldLayout AbstractRemapper::create_layout(const FieldLayout &from_layout, const grid_ptr_type &to_grid) const {
+FieldLayout AbstractRemapper::create_layout(const FieldLayout &from_layout,
+                                            const grid_ptr_type &to_grid) const {
   return to_grid->equivalent_layout(from_layout);
 }
 
diff --git i/components/eamxx/src/share/grid/remap/abstract_remapper.hpp w/components/eamxx/src/share/grid/remap/abstract_remapper.hpp
index 2f2edc7177..b13ba8ab88 100644
--- i/components/eamxx/src/share/grid/remap/abstract_remapper.hpp
+++ w/components/eamxx/src/share/grid/remap/abstract_remapper.hpp
@@ -70,11 +70,16 @@ public:
   virtual FieldLayout create_src_layout(const FieldLayout &tgt_layout) const;
   virtual FieldLayout create_tgt_layout(const FieldLayout &src_layout) const;
   virtual bool compatible_layouts(const FieldLayout &src, const FieldLayout &tgt) const;
-  virtual bool is_valid_src_layout(const FieldLayout &layout) const { return m_src_grid->is_valid_layout(layout); }
-  virtual bool is_valid_tgt_layout(const FieldLayout &layout) const { return m_tgt_grid->is_valid_layout(layout); }
+  virtual bool is_valid_src_layout(const FieldLayout &layout) const {
+    return m_src_grid->is_valid_layout(layout);
+  }
+  virtual bool is_valid_tgt_layout(const FieldLayout &layout) const {
+    return m_tgt_grid->is_valid_layout(layout);
+  }
 
 protected:
-  virtual FieldLayout create_layout(const FieldLayout &from_layout, const grid_ptr_type &to_grid) const;
+  virtual FieldLayout create_layout(const FieldLayout &from_layout,
+                                    const grid_ptr_type &to_grid) const;
 
   void set_grids(const grid_ptr_type &src_grid, const grid_ptr_type &tgt_grid);
 
@@ -84,11 +89,15 @@ protected:
 
   // Override this method to implement the forward remapping process using
   // the protected data members of this class.
-  virtual void remap_fwd_impl() { EKAT_ERROR_MSG("Error! Missing override of remap_fwd_impl for this remapper.\n"); }
+  virtual void remap_fwd_impl() {
+    EKAT_ERROR_MSG("Error! Missing override of remap_fwd_impl for this remapper.\n");
+  }
 
   // Override this method to implement the backward/inverse remapping process
   // using the protected data members of this class.
-  virtual void remap_bwd_impl() { EKAT_ERROR_MSG("Error! Missing override of remap_bwd_impl for this remapper.\n"); }
+  virtual void remap_bwd_impl() {
+    EKAT_ERROR_MSG("Error! Missing override of remap_bwd_impl for this remapper.\n");
+  }
 
   // By default, assume both are allowed.
   bool m_fwd_allowed = true;
@@ -115,8 +124,9 @@ private:
 };
 
 // A short name for an AbstractRemapper factory
-using RemapperFactory = ekat::Factory<AbstractRemapper, ekat::CaseInsensitiveString, std::shared_ptr<AbstractRemapper>,
-                                      const ekat::ParameterList &>;
+using RemapperFactory =
+    ekat::Factory<AbstractRemapper, ekat::CaseInsensitiveString, std::shared_ptr<AbstractRemapper>,
+                  const ekat::ParameterList &>;
 
 } // namespace scream
 
diff --git i/components/eamxx/src/share/grid/remap/coarsening_remapper.cpp w/components/eamxx/src/share/grid/remap/coarsening_remapper.cpp
index bacd222f42..d585e02a98 100644
--- i/components/eamxx/src/share/grid/remap/coarsening_remapper.cpp
+++ w/components/eamxx/src/share/grid/remap/coarsening_remapper.cpp
@@ -34,15 +34,15 @@ CoarseningRemapper::CoarseningRemapper(const grid_ptr_type &src_grid, const std:
       if (layout.tags().empty()) {
         // This is a scalar field, so won't be coarsened.
         // Simply copy it in the tgt grid, but we still need to assign the new grid name.
-        FieldIdentifier tgt_data_fid(src_data_fid.name(), src_data_fid.get_layout(), src_data_fid.get_units(),
-                                     m_tgt_grid->name());
+        FieldIdentifier tgt_data_fid(src_data_fid.name(), src_data_fid.get_layout(),
+                                     src_data_fid.get_units(), m_tgt_grid->name());
         auto tgt_data = m_coarse_grid->create_geometry_data(tgt_data_fid);
         tgt_data.deep_copy(src_data);
       } else if (layout.tags()[0] != COL) {
         // Not a field to be coarsened (perhaps a vertical coordinate field).
         // Simply copy it in the tgt grid, but we still need to assign the new grid name.
-        FieldIdentifier tgt_data_fid(src_data_fid.name(), src_data_fid.get_layout(), src_data_fid.get_units(),
-                                     m_tgt_grid->name());
+        FieldIdentifier tgt_data_fid(src_data_fid.name(), src_data_fid.get_layout(),
+                                     src_data_fid.get_units(), m_tgt_grid->name());
         auto tgt_data = m_coarse_grid->create_geometry_data(tgt_data_fid);
         tgt_data.deep_copy(src_data);
       } else {
@@ -84,10 +84,10 @@ void CoarseningRemapper::registration_ends_impl() {
     return;
   }
 
-  // We store masks (src-tgt) here, and register them AFTER we parse all currently registered fields.
-  // That makes the for loop below easier, since we can take references without worrring that they
-  // would get invalidated. In fact, if you call register_field inside the loop, the src/tgt fields
-  // vectors will grow, which may cause reallocation and references invalidation
+  // We store masks (src-tgt) here, and register them AFTER we parse all currently registered
+  // fields. That makes the for loop below easier, since we can take references without worrring
+  // that they would get invalidated. In fact, if you call register_field inside the loop, the
+  // src/tgt fields vectors will grow, which may cause reallocation and references invalidation
   std::vector<std::pair<Field, Field>> masks;
 
   auto get_mask_idx = [&](const FieldIdentifier &src_mask_fid) {
@@ -129,24 +129,26 @@ void CoarseningRemapper::registration_ends_impl() {
     const auto &f_lt = src.get_header().get_identifier().get_layout();
     const auto &m_lt = src_mask.get_header().get_identifier().get_layout();
     using namespace ShortFieldTagsNames;
-    EKAT_REQUIRE_MSG(f_lt.has_tag(COL) == m_lt.has_tag(COL), "Error! Incompatible field and mask layouts.\n"
-                                                             "  - field name: " +
-                                                                 src.name() +
-                                                                 "\n"
-                                                                 "  - field layout: " +
-                                                                 f_lt.to_string() +
-                                                                 "\n"
-                                                                 "  - mask layout: " +
-                                                                 m_lt.to_string() + "\n");
-    EKAT_REQUIRE_MSG(f_lt.has_tag(LEV) == m_lt.has_tag(LEV), "Error! Incompatible field and mask layouts.\n"
-                                                             "  - field name: " +
-                                                                 src.name() +
-                                                                 "\n"
-                                                                 "  - field layout: " +
-                                                                 f_lt.to_string() +
-                                                                 "\n"
-                                                                 "  - mask layout: " +
-                                                                 m_lt.to_string() + "\n");
+    EKAT_REQUIRE_MSG(f_lt.has_tag(COL) == m_lt.has_tag(COL),
+                     "Error! Incompatible field and mask layouts.\n"
+                     "  - field name: " +
+                         src.name() +
+                         "\n"
+                         "  - field layout: " +
+                         f_lt.to_string() +
+                         "\n"
+                         "  - mask layout: " +
+                         m_lt.to_string() + "\n");
+    EKAT_REQUIRE_MSG(f_lt.has_tag(LEV) == m_lt.has_tag(LEV),
+                     "Error! Incompatible field and mask layouts.\n"
+                     "  - field name: " +
+                         src.name() +
+                         "\n"
+                         "  - field layout: " +
+                         f_lt.to_string() +
+                         "\n"
+                         "  - mask layout: " +
+                         m_lt.to_string() + "\n");
 
     // If not there, set mask value in the tgt field too
     if (tgt.get_header().has_extra_data("mask_value")) {
@@ -198,9 +200,10 @@ void CoarseningRemapper::remap_fwd_impl() {
   // is done packing before us, we can start receiving their data
   if (not m_recv_req.empty()) {
     int ierr = MPI_Startall(m_recv_req.size(), m_recv_req.data());
-    EKAT_REQUIRE_MSG(ierr == MPI_SUCCESS, "Error! Something whent wrong while starting persistent recv requests.\n"
-                                          "  - recv rank: " +
-                                              std::to_string(m_comm.rank()) + "\n");
+    EKAT_REQUIRE_MSG(ierr == MPI_SUCCESS,
+                     "Error! Something whent wrong while starting persistent recv requests.\n"
+                     "  - recv rank: " +
+                         std::to_string(m_comm.rank()) + "\n");
   }
 
   // TODO: Add check that if there are mask values they are either 1's or 0's for unmasked/masked.
@@ -248,9 +251,10 @@ void CoarseningRemapper::remap_fwd_impl() {
   // Wait for all sends to be completed
   if (not m_send_req.empty()) {
     int ierr = MPI_Waitall(m_send_req.size(), m_send_req.data(), MPI_STATUSES_IGNORE);
-    EKAT_REQUIRE_MSG(ierr == MPI_SUCCESS, "Error! Something whent wrong while waiting on persistent send requests.\n"
-                                          "  - send rank: " +
-                                              std::to_string(m_comm.rank()) + "\n");
+    EKAT_REQUIRE_MSG(ierr == MPI_SUCCESS,
+                     "Error! Something whent wrong while waiting on persistent send requests.\n"
+                     "  - send rank: " +
+                         std::to_string(m_comm.rank()) + "\n");
   }
 
   // Rescale any fields that had the mask applied.
@@ -270,7 +274,8 @@ void CoarseningRemapper::remap_fwd_impl() {
   }
 }
 
-template <int PackSize> void CoarseningRemapper::rescale_masked_fields(const Field &x, const Field &mask) const {
+template <int PackSize>
+void CoarseningRemapper::rescale_masked_fields(const Field &x, const Field &mask) const {
   using RangePolicy = typename KT::RangePolicy;
   using MemberType  = typename KT::MemberType;
   using ESU         = ekat::ExeSpaceUtils<typename KT::ExeSpace>;
@@ -284,10 +289,12 @@ template <int PackSize> void CoarseningRemapper::rescale_masked_fields(const Fie
   if (x.get_header().has_extra_data("mask_value")) {
     mask_val = x.get_header().get_extra_data<Real>("mask_value");
   } else {
-    EKAT_ERROR_MSG("ERROR! Field " + x.name() + " is masked, but stores no mask_value extra data.\n");
+    EKAT_ERROR_MSG("ERROR! Field " + x.name() +
+                   " is masked, but stores no mask_value extra data.\n");
   }
-  const Real mask_threshold = std::numeric_limits<Real>::epsilon(); // TODO: Should we not hardcode the threshold for
-                                                                    // simply masking out the column.
+  const Real mask_threshold =
+      std::numeric_limits<Real>::epsilon(); // TODO: Should we not hardcode the threshold for
+                                            // simply masking out the column.
 
   switch (rank) {
   case 1: {
@@ -327,7 +334,8 @@ template <int PackSize> void CoarseningRemapper::rescale_masked_fields(const Fie
           if (mask1d) {
             auto mask = mask_1d(icol);
             if (mask > mask_threshold) {
-              Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1), [&](const int j) { x_sub(j) /= mask; });
+              Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1),
+                                   [&](const int j) { x_sub(j) /= mask; });
             }
           } else {
             auto m_sub = ekat::subview(mask_2d, icol);
@@ -409,28 +417,30 @@ template <int PackSize> void CoarseningRemapper::rescale_masked_fields(const Fie
           if (mask1d) {
             auto mask = mask_1d(icol);
             if (mask > mask_threshold) {
-              Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3), [&](const int idx) {
-                const int j = (idx / dim3) / dim2;
-                const int k = (idx / dim3) % dim2;
-                const int l = idx % dim3;
-                auto x_sub  = ekat::subview(x_view, icol, j, k);
-                x_sub(l) /= mask;
-              });
+              Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3),
+                                   [&](const int idx) {
+                                     const int j = (idx / dim3) / dim2;
+                                     const int k = (idx / dim3) % dim2;
+                                     const int l = idx % dim3;
+                                     auto x_sub  = ekat::subview(x_view, icol, j, k);
+                                     x_sub(l) /= mask;
+                                   });
             }
           } else {
             auto m_sub = ekat::subview(mask_2d, icol);
-            Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3), [&](const int idx) {
-              const int j = (idx / dim3) / dim2;
-              const int k = (idx / dim3) % dim2;
-              const int l = idx % dim3;
-              auto x_sub  = ekat::subview(x_view, icol, j, k);
-              auto masked = m_sub(l) > mask_threshold;
+            Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3),
+                                 [&](const int idx) {
+                                   const int j = (idx / dim3) / dim2;
+                                   const int k = (idx / dim3) % dim2;
+                                   const int l = idx % dim3;
+                                   auto x_sub  = ekat::subview(x_view, icol, j, k);
+                                   auto masked = m_sub(l) > mask_threshold;
 
-              if (masked.any()) {
-                x_sub(l).set(masked, x_sub(l) / m_sub(l));
-              }
-              x_sub(l).set(!masked, mask_val);
-            });
+                                   if (masked.any()) {
+                                     x_sub(l).set(masked, x_sub(l) / m_sub(l));
+                                   }
+                                   x_sub(l).set(!masked, mask_val);
+                                 });
           }
         });
     break;
@@ -496,8 +506,8 @@ void CoarseningRemapper::local_mat_vec(const Field &x, const Field &y, const Fie
           const auto beg = row_offsets(row);
           const auto end = row_offsets(row + 1);
           Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1), [&](const int j) {
-            y_view(row, j) =
-                weights(beg) * x_view(col_lids(beg), j) * (mask1d ? mask_1d(col_lids(beg)) : mask_2d(col_lids(beg), j));
+            y_view(row, j) = weights(beg) * x_view(col_lids(beg), j) *
+                             (mask1d ? mask_1d(col_lids(beg)) : mask_2d(col_lids(beg), j));
             for (int icol = beg + 1; icol < end; ++icol) {
               y_view(row, j) += weights(icol) * x_view(col_lids(icol), j) *
                                 (mask1d ? mask_1d(col_lids(icol)) : mask_2d(col_lids(icol), j));
@@ -566,22 +576,26 @@ void CoarseningRemapper::local_mat_vec(const Field &x, const Field &y, const Fie
 
           const auto beg = row_offsets(row);
           const auto end = row_offsets(row + 1);
-          Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3), [&](const int idx) {
-            const int j          = (idx / dim3) / dim2;
-            const int k          = (idx / dim3) % dim2;
-            const int l          = idx % dim3;
-            y_view(row, j, k, l) = weights(beg) * x_view(col_lids(beg), j, k, l) *
-                                   (mask1d ? mask_1d(col_lids(beg)) : mask_2d(col_lids(beg), l));
-            for (int icol = beg + 1; icol < end; ++icol) {
-              y_view(row, j, k, l) += weights(icol) * x_view(col_lids(icol), j, k, l) *
-                                      (mask1d ? mask_1d(col_lids(icol)) : mask_2d(col_lids(icol), l));
-            }
-          });
+          Kokkos::parallel_for(
+              Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3), [&](const int idx) {
+                const int j = (idx / dim3) / dim2;
+                const int k = (idx / dim3) % dim2;
+                const int l = idx % dim3;
+                y_view(row, j, k, l) =
+                    weights(beg) * x_view(col_lids(beg), j, k, l) *
+                    (mask1d ? mask_1d(col_lids(beg)) : mask_2d(col_lids(beg), l));
+                for (int icol = beg + 1; icol < end; ++icol) {
+                  y_view(row, j, k, l) +=
+                      weights(icol) * x_view(col_lids(icol), j, k, l) *
+                      (mask1d ? mask_1d(col_lids(icol)) : mask_2d(col_lids(icol), l));
+                }
+              });
         });
     break;
   }
   default: {
-    EKAT_ERROR_MSG("Error::coarsening_remapper::local_mat_vec doesn't support fields of rank 4 or greater");
+    EKAT_ERROR_MSG(
+        "Error::coarsening_remapper::local_mat_vec doesn't support fields of rank 4 or greater");
   }
   }
 }
@@ -633,8 +647,9 @@ void CoarseningRemapper::pack_and_send() {
             const int lidpos = i - pid_lid_start(pid);
             const int offset = f_pid_offsets(pid);
 
-            Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1),
-                                 [&](const int idim) { buf(offset + lidpos * dim1 + idim) = v(lid, idim); });
+            Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1), [&](const int idim) {
+              buf(offset + lidpos * dim1 + idim) = v(lid, idim);
+            });
           });
     } break;
     case 3: {
@@ -671,13 +686,14 @@ void CoarseningRemapper::pack_and_send() {
             const int lidpos = i - pid_lid_start(pid);
             const int offset = f_pid_offsets(pid);
 
-            Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3), [&](const int idx) {
-              const int idim = (idx / dim3) / dim2;
-              const int jdim = (idx / dim3) % dim2;
-              const int ilev = idx % dim3;
-              buf(offset + lidpos * dim1 * dim2 * dim3 + idim * dim2 * dim3 + jdim * dim3 + ilev) =
-                  v(lid, idim, jdim, ilev);
-            });
+            Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3),
+                                 [&](const int idx) {
+                                   const int idim          = (idx / dim3) / dim2;
+                                   const int jdim          = (idx / dim3) % dim2;
+                                   const int ilev          = idx % dim3;
+                                   buf(offset + lidpos * dim1 * dim2 * dim3 + idim * dim2 * dim3 +
+                                       jdim * dim3 + ilev) = v(lid, idim, jdim, ilev);
+                                 });
           });
     } break;
 
@@ -704,18 +720,20 @@ void CoarseningRemapper::pack_and_send() {
 
   if (not m_send_req.empty()) {
     int ierr = MPI_Startall(m_send_req.size(), m_send_req.data());
-    EKAT_REQUIRE_MSG(ierr == MPI_SUCCESS, "Error! Something whent wrong while starting persistent send requests.\n"
-                                          "  - send rank: " +
-                                              std::to_string(m_comm.rank()) + "\n");
+    EKAT_REQUIRE_MSG(ierr == MPI_SUCCESS,
+                     "Error! Something whent wrong while starting persistent send requests.\n"
+                     "  - send rank: " +
+                         std::to_string(m_comm.rank()) + "\n");
   }
 }
 
 void CoarseningRemapper::recv_and_unpack() {
   if (not m_recv_req.empty()) {
     int ierr = MPI_Waitall(m_recv_req.size(), m_recv_req.data(), MPI_STATUSES_IGNORE);
-    EKAT_REQUIRE_MSG(ierr == MPI_SUCCESS, "Error! Something whent wrong while waiting on persistent recv requests.\n"
-                                          "  - recv rank: " +
-                                              std::to_string(m_comm.rank()) + "\n");
+    EKAT_REQUIRE_MSG(ierr == MPI_SUCCESS,
+                     "Error! Something whent wrong while waiting on persistent recv requests.\n"
+                     "  - recv rank: " +
+                         std::to_string(m_comm.rank()) + "\n");
   }
   // If MPI does not use dev pointers, we need to deep copy from host to dev
   if (not MpiOnDev) {
@@ -814,12 +832,14 @@ void CoarseningRemapper::recv_and_unpack() {
               const int lidpos = recv_lids_pidpos(irecv, 1);
               const int offset = f_pid_offsets(pid) + lidpos * dim1 * dim2 * dim3;
 
-              Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3), [&](const int idx) {
-                const int idim = (idx / dim3) / dim2;
-                const int jdim = (idx / dim3) % dim2;
-                const int ilev = idx % dim3;
-                v(lid, idim, jdim, ilev) += buf(offset + idim * dim2 * dim3 + jdim * dim3 + ilev);
-              });
+              Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3),
+                                   [&](const int idx) {
+                                     const int idim = (idx / dim3) / dim2;
+                                     const int jdim = (idx / dim3) % dim2;
+                                     const int ilev = idx % dim3;
+                                     v(lid, idim, jdim, ilev) +=
+                                         buf(offset + idim * dim2 * dim3 + jdim * dim3 + ilev);
+                                   });
             }
           });
     } break;
@@ -851,8 +871,8 @@ std::vector<int> CoarseningRemapper::get_pids_for_recv(const std::vector<int> &s
   // Gather all the pids that each rank is sending data to
   auto nglobal_sends = std::accumulate(num_sends.begin(), num_sends.end(), 0);
   std::vector<int> global_send_pids(nglobal_sends, -1);
-  MPI_Allgatherv(send_to_pids.data(), send_to_pids.size(), MPI_INT, global_send_pids.data(), num_sends.data(),
-                 sends_offsets.data(), MPI_INT, m_comm.mpi_comm());
+  MPI_Allgatherv(send_to_pids.data(), send_to_pids.size(), MPI_INT, global_send_pids.data(),
+                 num_sends.data(), sends_offsets.data(), MPI_INT, m_comm.mpi_comm());
 
   // Loop over all the ranks, and all the pids they send to, and look for my pid
   std::vector<int> recv_from_pids;
@@ -871,8 +891,8 @@ std::vector<int> CoarseningRemapper::get_pids_for_recv(const std::vector<int> &s
   return recv_from_pids;
 }
 
-std::map<int, std::vector<int>>
-CoarseningRemapper::recv_gids_from_pids(const std::map<int, std::vector<int>> &pid2gids_send) const {
+std::map<int, std::vector<int>> CoarseningRemapper::recv_gids_from_pids(
+    const std::map<int, std::vector<int>> &pid2gids_send) const {
   const auto comm = m_comm.mpi_comm();
 
   // First, figure out which PIDs I need to recv from
@@ -986,15 +1006,17 @@ void CoarseningRemapper::setup_mpi_data_structures() {
 
     // At the end, pos must match the total amount of data in the overlapped fields
     if (pid == last_rank) {
-      EKAT_REQUIRE_MSG(pos == num_ov_gids * sum_fields_col_sizes,
-                       "Error! Something went wrong in CoarseningRemapper::setup_mpi_structures.\n");
+      EKAT_REQUIRE_MSG(
+          pos == num_ov_gids * sum_fields_col_sizes,
+          "Error! Something went wrong in CoarseningRemapper::setup_mpi_structures.\n");
     }
   }
   Kokkos::deep_copy(m_send_f_pid_offsets, send_f_pid_offsets_h);
 
   // 4. Allocate send buffers
-  m_send_buffer     = view_1d<Real>("", sum_fields_col_sizes * num_ov_gids);
-  m_mpi_send_buffer = Kokkos::create_mirror_view(decltype(m_mpi_send_buffer)::execution_space(), m_send_buffer);
+  m_send_buffer = view_1d<Real>("", sum_fields_col_sizes * num_ov_gids);
+  m_mpi_send_buffer =
+      Kokkos::create_mirror_view(decltype(m_mpi_send_buffer)::execution_space(), m_send_buffer);
 
   // 5. Setup send requests
   m_send_req.reserve(num_send_pids);
@@ -1050,8 +1072,9 @@ void CoarseningRemapper::setup_mpi_data_structures() {
     const int gid      = tgt_dofs_h[i];
     for (auto pid : lid2pids_recv[i]) {
       auto it = std::find(pid2gids_recv.at(pid).begin(), pid2gids_recv.at(pid).end(), gid);
-      EKAT_REQUIRE_MSG(it != pid2gids_recv.at(pid).end(),
-                       "Error! Something went wrong in CoarseningRemapper::setup_mpi_structures.\n");
+      EKAT_REQUIRE_MSG(
+          it != pid2gids_recv.at(pid).end(),
+          "Error! Something went wrong in CoarseningRemapper::setup_mpi_structures.\n");
       recv_lids_pidpos_h(pos, 0)   = pid;
       recv_lids_pidpos_h(pos++, 1) = std::distance(pid2gids_recv.at(pid).begin(), it);
     }
@@ -1083,15 +1106,17 @@ void CoarseningRemapper::setup_mpi_data_structures() {
 
     // // At the end, pos must match the total amount of data received
     if (pid == last_rank) {
-      EKAT_REQUIRE_MSG(pos == num_total_recv_gids * sum_fields_col_sizes,
-                       "Error! Something went wrong in CoarseningRemapper::setup_mpi_structures.\n");
+      EKAT_REQUIRE_MSG(
+          pos == num_total_recv_gids * sum_fields_col_sizes,
+          "Error! Something went wrong in CoarseningRemapper::setup_mpi_structures.\n");
     }
   }
   Kokkos::deep_copy(m_recv_f_pid_offsets, recv_f_pid_offsets_h);
 
   // 5. Allocate recv buffers
-  m_recv_buffer     = view_1d<Real>("", sum_fields_col_sizes * num_total_recv_gids);
-  m_mpi_recv_buffer = Kokkos::create_mirror_view(decltype(m_mpi_recv_buffer)::execution_space(), m_recv_buffer);
+  m_recv_buffer = view_1d<Real>("", sum_fields_col_sizes * num_total_recv_gids);
+  m_mpi_recv_buffer =
+      Kokkos::create_mirror_view(decltype(m_mpi_recv_buffer)::execution_space(), m_recv_buffer);
 
   // 6. Setup recv requests
   m_recv_req.reserve(num_recv_pids);
diff --git i/components/eamxx/src/share/grid/remap/coarsening_remapper.hpp w/components/eamxx/src/share/grid/remap/coarsening_remapper.hpp
index 29f33cfbab..e72bcc22a0 100644
--- i/components/eamxx/src/share/grid/remap/coarsening_remapper.hpp
+++ w/components/eamxx/src/share/grid/remap/coarsening_remapper.hpp
@@ -39,8 +39,8 @@ namespace scream {
 
 class CoarseningRemapper : public HorizInterpRemapperBase {
 public:
-  CoarseningRemapper(const grid_ptr_type &src_grid, const std::string &map_file, const bool track_mask = false,
-                     const bool populate_tgt_grid_geo_data = true);
+  CoarseningRemapper(const grid_ptr_type &src_grid, const std::string &map_file,
+                     const bool track_mask = false, const bool populate_tgt_grid_geo_data = true);
 
   ~CoarseningRemapper();
 
@@ -55,7 +55,8 @@ protected:
 
   std::vector<int> get_pids_for_recv(const std::vector<int> &send_to_pids) const;
 
-  std::map<int, std::vector<int>> recv_gids_from_pids(const std::map<int, std::vector<int>> &pid2gids_send) const;
+  std::map<int, std::vector<int>>
+  recv_gids_from_pids(const std::map<int, std::vector<int>> &pid2gids_send) const;
 
   // This class uses itself to remap src grid geo data to the tgt grid. But in order
   // to not pollute the remapper for later use, we must be able to clean it up after
@@ -65,7 +66,8 @@ protected:
 #ifdef KOKKOS_ENABLE_CUDA
 public:
 #endif
-  template <int N> void local_mat_vec(const Field &f_src, const Field &f_tgt, const Field &mask) const;
+  template <int N>
+  void local_mat_vec(const Field &f_src, const Field &f_tgt, const Field &mask) const;
   template <int N> void rescale_masked_fields(const Field &f_tgt, const Field &f_mask) const;
   void pack_and_send();
   void recv_and_unpack();
@@ -77,7 +79,8 @@ protected:
 
   // If MpiOnDev=true, we can pass device pointers to MPI. Otherwise, we need host mirrors.
   template <typename T>
-  using mpi_view_1d = typename std::conditional<MpiOnDev, view_1d<T>, typename view_1d<T>::HostMirror>::type;
+  using mpi_view_1d =
+      typename std::conditional<MpiOnDev, view_1d<T>, typename view_1d<T>::HostMirror>::type;
 
   // Mask fields, if needed
   bool m_track_mask;
diff --git i/components/eamxx/src/share/grid/remap/horiz_interp_remapper_base.cpp w/components/eamxx/src/share/grid/remap/horiz_interp_remapper_base.cpp
index 77a6b9935d..120c3038ff 100644
--- i/components/eamxx/src/share/grid/remap/horiz_interp_remapper_base.cpp
+++ w/components/eamxx/src/share/grid/remap/horiz_interp_remapper_base.cpp
@@ -10,8 +10,8 @@
 
 namespace scream {
 
-HorizInterpRemapperBase::HorizInterpRemapperBase(const grid_ptr_type &fine_grid, const std::string &map_file,
-                                                 const InterpType type)
+HorizInterpRemapperBase::HorizInterpRemapperBase(const grid_ptr_type &fine_grid,
+                                                 const std::string &map_file, const InterpType type)
     : m_fine_grid(fine_grid), m_map_file(map_file), m_type(type), m_comm(fine_grid->get_comm()) {
   // Sanity checks
   EKAT_REQUIRE_MSG(fine_grid->type() == GridType::Point,
@@ -21,7 +21,8 @@ HorizInterpRemapperBase::HorizInterpRemapperBase(const grid_ptr_type &fine_grid,
                        "\n"
                        "  - fine_grid_type: " +
                        e2str(fine_grid->type()) + "\n");
-  EKAT_REQUIRE_MSG(fine_grid->is_unique(), "Error! HorizInterpRemapperBase requires a unique fine grid.\n");
+  EKAT_REQUIRE_MSG(fine_grid->is_unique(),
+                   "Error! HorizInterpRemapperBase requires a unique fine grid.\n");
 
   // This is a special remapper. We only go in one direction
   m_bwd_allowed = false;
@@ -86,19 +87,20 @@ void HorizInterpRemapperBase::registration_ends_impl() {
   for (int i = 0; i < m_num_fields; ++i) {
     const auto &src_dt = m_src_fields[i].get_header().get_identifier().data_type();
     const auto &tgt_dt = m_tgt_fields[i].get_header().get_identifier().data_type();
-    EKAT_REQUIRE_MSG(src_dt == DataType::RealType and tgt_dt == DataType::RealType,
-                     "Error! HorizInterpRmapperBase requires src/tgt fields to have Real data type.\n"
-                     "  - src field name: " +
-                         m_src_fields[i].name() +
-                         "\n"
-                         "  - tgt field name: " +
-                         m_tgt_fields[i].name() +
-                         "\n"
-                         "  - src data type : " +
-                         e2str(src_dt) +
-                         "\n"
-                         "  - tgt data type : " +
-                         e2str(tgt_dt) + "\n");
+    EKAT_REQUIRE_MSG(
+        src_dt == DataType::RealType and tgt_dt == DataType::RealType,
+        "Error! HorizInterpRmapperBase requires src/tgt fields to have Real data type.\n"
+        "  - src field name: " +
+            m_src_fields[i].name() +
+            "\n"
+            "  - tgt field name: " +
+            m_tgt_fields[i].name() +
+            "\n"
+            "  - src data type : " +
+            e2str(src_dt) +
+            "\n"
+            "  - tgt data type : " +
+            e2str(tgt_dt) + "\n");
   }
 
   create_ov_fields();
@@ -125,7 +127,8 @@ void HorizInterpRemapperBase::create_ov_fields() {
   }
 }
 
-template <int PackSize> void HorizInterpRemapperBase::local_mat_vec(const Field &x, const Field &y) const {
+template <int PackSize>
+void HorizInterpRemapperBase::local_mat_vec(const Field &x, const Field &y) const {
   using RangePolicy = typename KT::RangePolicy;
   using MemberType  = typename KT::MemberType;
   using ESU         = ekat::ExeSpaceUtils<typename KT::ExeSpace>;
@@ -219,20 +222,22 @@ template <int PackSize> void HorizInterpRemapperBase::local_mat_vec(const Field
 
           const auto beg = row_offsets(row);
           const auto end = row_offsets(row + 1);
-          Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3), [&](const int idx) {
-            const int j          = (idx / dim3) / dim2;
-            const int k          = (idx / dim3) % dim2;
-            const int l          = idx % dim3;
-            y_view(row, j, k, l) = weights(beg) * x_view(col_lids(beg), j, k, l);
-            for (int icol = beg + 1; icol < end; ++icol) {
-              y_view(row, j, k, l) += weights(icol) * x_view(col_lids(icol), j, k, l);
-            }
-          });
+          Kokkos::parallel_for(
+              Kokkos::TeamVectorRange(team, dim1 * dim2 * dim3), [&](const int idx) {
+                const int j          = (idx / dim3) / dim2;
+                const int k          = (idx / dim3) % dim2;
+                const int l          = idx % dim3;
+                y_view(row, j, k, l) = weights(beg) * x_view(col_lids(beg), j, k, l);
+                for (int icol = beg + 1; icol < end; ++icol) {
+                  y_view(row, j, k, l) += weights(icol) * x_view(col_lids(icol), j, k, l);
+                }
+              });
         });
     break;
   }
   default: {
-    EKAT_ERROR_MSG("[HorizInterpRemapperBase::local_mat_vec] Error! Fields of rank 4 or greater are not supported.\n");
+    EKAT_ERROR_MSG("[HorizInterpRemapperBase::local_mat_vec] Error! Fields of rank 4 or greater "
+                   "are not supported.\n");
   }
   }
 }
@@ -254,7 +259,8 @@ std::map<std::string, HorizRemapperData> HorizInterpRemapperBase::s_remapper_dat
 template void HorizInterpRemapperBase::local_mat_vec<1>(const Field &, const Field &) const;
 
 #if SCREAM_PACK_SIZE > 1
-template void HorizInterpRemapperBase::local_mat_vec<SCREAM_PACK_SIZE>(const Field &, const Field &) const;
+template void HorizInterpRemapperBase::local_mat_vec<SCREAM_PACK_SIZE>(const Field &,
+                                                                       const Field &) const;
 #endif
 
 } // namespace scream
diff --git i/components/eamxx/src/share/grid/remap/horiz_interp_remapper_base.hpp w/components/eamxx/src/share/grid/remap/horiz_interp_remapper_base.hpp
index f1adbbb57e..c95bf525fe 100644
--- i/components/eamxx/src/share/grid/remap/horiz_interp_remapper_base.hpp
+++ w/components/eamxx/src/share/grid/remap/horiz_interp_remapper_base.hpp
@@ -16,7 +16,8 @@ namespace scream {
 
 class HorizInterpRemapperBase : public AbstractRemapper {
 public:
-  HorizInterpRemapperBase(const grid_ptr_type &fine_grid, const std::string &map_file, const InterpType type);
+  HorizInterpRemapperBase(const grid_ptr_type &fine_grid, const std::string &map_file,
+                          const InterpType type);
 
   ~HorizInterpRemapperBase();
 
diff --git i/components/eamxx/src/share/grid/remap/horiz_interp_remapper_data.cpp w/components/eamxx/src/share/grid/remap/horiz_interp_remapper_data.cpp
index 9e204a497d..1f7d07be59 100644
--- i/components/eamxx/src/share/grid/remap/horiz_interp_remapper_data.cpp
+++ w/components/eamxx/src/share/grid/remap/horiz_interp_remapper_data.cpp
@@ -10,7 +10,8 @@ namespace scream {
 
 // --------------- HorizRemapperData ---------------- //
 
-void HorizRemapperData::build(const std::string &map_file, const std::shared_ptr<const AbstractGrid> &fine_grid_in,
+void HorizRemapperData::build(const std::string &map_file,
+                              const std::shared_ptr<const AbstractGrid> &fine_grid_in,
                               const ekat::Comm &comm_in, const InterpType type_in) {
   comm      = comm_in;
   fine_grid = fine_grid_in;
@@ -251,12 +252,13 @@ void HorizRemapperData::create_crs_matrix_structures(std::vector<Triplet> &tripl
     ++row_counts[row_gid2lid.at(triplets[i].row)];
   }
   std::partial_sum(row_counts.begin(), row_counts.end(), row_offsets_h.data() + 1);
-  EKAT_REQUIRE_MSG(row_offsets_h(num_rows) == nnz, "Error! Something went wrong while computing row offsets.\n"
-                                                   "  - local nnz       : " +
-                                                       std::to_string(nnz) +
-                                                       "\n"
-                                                       "  - row_offsets(end): " +
-                                                       std::to_string(row_offsets_h(num_rows)) + "\n");
+  EKAT_REQUIRE_MSG(row_offsets_h(num_rows) == nnz,
+                   "Error! Something went wrong while computing row offsets.\n"
+                   "  - local nnz       : " +
+                       std::to_string(nnz) +
+                       "\n"
+                       "  - row_offsets(end): " +
+                       std::to_string(row_offsets_h(num_rows)) + "\n");
 
   Kokkos::deep_copy(row_offsets, row_offsets_h);
 }
diff --git i/components/eamxx/src/share/grid/remap/horiz_interp_remapper_data.hpp w/components/eamxx/src/share/grid/remap/horiz_interp_remapper_data.hpp
index d3d4858aa3..afd9e78de1 100644
--- i/components/eamxx/src/share/grid/remap/horiz_interp_remapper_data.hpp
+++ w/components/eamxx/src/share/grid/remap/horiz_interp_remapper_data.hpp
@@ -20,8 +20,8 @@ struct HorizRemapperData {
   using KT                            = KokkosTypes<DefaultDevice>;
   template <typename T> using view_1d = typename KT::template view_1d<T>;
 
-  void build(const std::string &map_file, const std::shared_ptr<const AbstractGrid> &fine_grid, const ekat::Comm &comm,
-             const InterpType type);
+  void build(const std::string &map_file, const std::shared_ptr<const AbstractGrid> &fine_grid,
+             const ekat::Comm &comm, const InterpType type);
 
   // The coarse grid data
   std::shared_ptr<AbstractGrid> coarse_grid;
diff --git i/components/eamxx/src/share/grid/remap/identity_remapper.cpp w/components/eamxx/src/share/grid/remap/identity_remapper.cpp
index 9ceaf73c07..0d177b2b50 100644
--- i/components/eamxx/src/share/grid/remap/identity_remapper.cpp
+++ w/components/eamxx/src/share/grid/remap/identity_remapper.cpp
@@ -2,13 +2,15 @@
 
 namespace scream {
 
-IdentityRemapper::IdentityRemapper(const grid_ptr_type grid, const Aliasing aliasing) : AbstractRemapper(grid, grid) {
+IdentityRemapper::IdentityRemapper(const grid_ptr_type grid, const Aliasing aliasing)
+    : AbstractRemapper(grid, grid) {
   set_aliasing(aliasing);
 }
 
 void IdentityRemapper::set_aliasing(const Aliasing aliasing) {
-  EKAT_REQUIRE_MSG(get_state() == RepoState::Clean,
-                   "Error! Aliasing in IdentityRemapper must be set *before* registration starts.\n");
+  EKAT_REQUIRE_MSG(
+      get_state() == RepoState::Clean,
+      "Error! Aliasing in IdentityRemapper must be set *before* registration starts.\n");
   m_aliasing = aliasing;
 }
 
@@ -39,7 +41,8 @@ void IdentityRemapper::registration_ends_impl() {
       const auto &tgt = m_tgt_fields[i];
       EKAT_REQUIRE_MSG(
           src.is_aliasing(tgt),
-          "Error! Input fields are not aliasing each other, but aliasing was requested in the IdentityRemapper.\n"
+          "Error! Input fields are not aliasing each other, but aliasing was requested in the "
+          "IdentityRemapper.\n"
           "       To register field when aliasing is active, use register_field_from_tgt/src.\n");
     }
   }
diff --git i/components/eamxx/src/share/grid/remap/inverse_remapper.hpp w/components/eamxx/src/share/grid/remap/inverse_remapper.hpp
index 4b315c5d02..940c511d28 100644
--- i/components/eamxx/src/share/grid/remap/inverse_remapper.hpp
+++ w/components/eamxx/src/share/grid/remap/inverse_remapper.hpp
@@ -32,8 +32,12 @@ public:
   bool compatible_layouts(const FieldLayout &src, const FieldLayout &tgt) const override {
     return m_remapper->compatible_layouts(tgt, src);
   }
-  virtual bool is_valid_src_layout(const FieldLayout &layout) const { return m_remapper->is_valid_tgt_layout(layout); }
-  virtual bool is_valid_tgt_layout(const FieldLayout &layout) const { return m_remapper->is_valid_src_layout(layout); }
+  virtual bool is_valid_src_layout(const FieldLayout &layout) const {
+    return m_remapper->is_valid_tgt_layout(layout);
+  }
+  virtual bool is_valid_tgt_layout(const FieldLayout &layout) const {
+    return m_remapper->is_valid_src_layout(layout);
+  }
 
 protected:
   void remap_fwd_impl() override { m_remapper->remap_bwd(); }
diff --git i/components/eamxx/src/share/grid/remap/iop_remapper.cpp w/components/eamxx/src/share/grid/remap/iop_remapper.cpp
index 0c38e351e4..d1aa86ebd1 100644
--- i/components/eamxx/src/share/grid/remap/iop_remapper.cpp
+++ w/components/eamxx/src/share/grid/remap/iop_remapper.cpp
@@ -20,14 +20,16 @@ template <> MPI_Datatype get_mpi_type<RealInt>() {
 
 namespace scream {
 
-IOPRemapper::IOPRemapper(const grid_ptr_type src_grid, const grid_ptr_type tgt_grid, const Real lat, const Real lon)
+IOPRemapper::IOPRemapper(const grid_ptr_type src_grid, const grid_ptr_type tgt_grid, const Real lat,
+                         const Real lon)
     : AbstractRemapper(src_grid, tgt_grid) {
   m_bwd_allowed = false;
 
   EKAT_REQUIRE_MSG(src_grid->has_geometry_data("lat") and src_grid->has_geometry_data("lon"),
                    "Error! IOP remapper requires lat/lon geometry data in the source grid.\n");
-  EKAT_REQUIRE_MSG(src_grid->get_num_vertical_levels() == tgt_grid->get_num_vertical_levels(),
-                   "Error! IOP remapper requires src/tgt grid to have the same number of vertical levels.\n");
+  EKAT_REQUIRE_MSG(
+      src_grid->get_num_vertical_levels() == tgt_grid->get_num_vertical_levels(),
+      "Error! IOP remapper requires src/tgt grid to have the same number of vertical levels.\n");
   EKAT_REQUIRE_MSG(src_grid->type() == GridType::Point and tgt_grid->type() == GridType::Point,
                    "Error! IOP remapper requires src/tgt grid to be PointGrid instances.\n");
 
@@ -53,10 +55,10 @@ void IOPRemapper::setup_closest_col_info(const Real lat, const Real lon) {
                        "\n"
                        " - actual layout  : " +
                        e2str(lon_f.get_header().get_identifier().get_layout().type()) + "\n");
-  EKAT_REQUIRE_MSG(-90 <= lat and lat <= 90,
-                   "Error! IOPRemapper lat=" + std::to_string(lat) + " outside of expected range [-90, 90].\n");
-  EKAT_REQUIRE_MSG(0 <= lon and lon <= 360,
-                   "Error! IOPRemapper lon=" + std::to_string(lon) + " outside of expected range [0, 360].\n");
+  EKAT_REQUIRE_MSG(-90 <= lat and lat <= 90, "Error! IOPRemapper lat=" + std::to_string(lat) +
+                                                 " outside of expected range [-90, 90].\n");
+  EKAT_REQUIRE_MSG(0 <= lon and lon <= 360, "Error! IOPRemapper lon=" + std::to_string(lon) +
+                                                " outside of expected range [0, 360].\n");
 
   auto lat_v           = lat_f.get_view<const Real *>();
   auto lon_v           = lon_f.get_view<const Real *>();
diff --git i/components/eamxx/src/share/grid/remap/iop_remapper.hpp w/components/eamxx/src/share/grid/remap/iop_remapper.hpp
index f694d85565..bf1aa1f214 100644
--- i/components/eamxx/src/share/grid/remap/iop_remapper.hpp
+++ w/components/eamxx/src/share/grid/remap/iop_remapper.hpp
@@ -15,7 +15,8 @@ namespace scream {
 
 class IOPRemapper : public AbstractRemapper {
 public:
-  IOPRemapper(const grid_ptr_type src_grid, const grid_ptr_type tgt_grid, const Real lat, const Real lon);
+  IOPRemapper(const grid_ptr_type src_grid, const grid_ptr_type tgt_grid, const Real lat,
+              const Real lon);
 
   ~IOPRemapper() = default;
 
diff --git i/components/eamxx/src/share/grid/remap/refining_remapper_p2p.cpp w/components/eamxx/src/share/grid/remap/refining_remapper_p2p.cpp
index cacfbb45b1..44faf3c185 100644
--- i/components/eamxx/src/share/grid/remap/refining_remapper_p2p.cpp
+++ w/components/eamxx/src/share/grid/remap/refining_remapper_p2p.cpp
@@ -106,7 +106,8 @@ void RefiningRemapperP2P::setup_mpi_data_structures() {
   // Create the recv buffer(s)
   auto recv_buf_size = ncols_recv * total_col_size;
   m_recv_buffer      = decltype(m_recv_buffer)("RefiningRemapperP2P::recv_buf", recv_buf_size);
-  m_mpi_recv_buffer  = Kokkos::create_mirror_view(decltype(m_mpi_recv_buffer)::execution_space(), m_recv_buffer);
+  m_mpi_recv_buffer =
+      Kokkos::create_mirror_view(decltype(m_mpi_recv_buffer)::execution_space(), m_recv_buffer);
 
   // ----------- Compute SEND metadata -------------- //
 
@@ -122,7 +123,8 @@ void RefiningRemapperP2P::setup_mpi_data_structures() {
   // Create the send buffer(s)
   auto send_buf_size = pids_send_offsets_h(nranks) * total_col_size;
   m_send_buffer      = decltype(m_send_buffer)("RefiningRemapperP2P::send_buf", send_buf_size);
-  m_mpi_send_buffer  = Kokkos::create_mirror_view(decltype(m_mpi_send_buffer)::execution_space(), m_send_buffer);
+  m_mpi_send_buffer =
+      Kokkos::create_mirror_view(decltype(m_mpi_send_buffer)::execution_space(), m_send_buffer);
 
   // ----------- Create Requests ------------ //
 
@@ -176,8 +178,9 @@ void RefiningRemapperP2P::pack_and_send() {
         auto icol           = export_lids(iexp);
         auto pid_offset     = pids_send_offsets(pid);
         auto pos_within_pid = iexp - pid_offset;
-        auto offset         = pid_offset * total_col_size + ncols_send(pid) * f_col_sizes_scan_sum + pos_within_pid;
-        send_buf(offset)    = v(icol);
+        auto offset =
+            pid_offset * total_col_size + ncols_send(pid) * f_col_sizes_scan_sum + pos_within_pid;
+        send_buf(offset) = v(icol);
       };
       Kokkos::parallel_for(RangePolicy(0, num_exports), pack);
       break;
@@ -192,7 +195,8 @@ void RefiningRemapperP2P::pack_and_send() {
         const int pid       = export_pids(iexp);
         auto pid_offset     = pids_send_offsets(pid);
         auto pos_within_pid = iexp - pid_offset;
-        auto offset   = pid_offset * total_col_size + ncols_send(pid) * f_col_sizes_scan_sum + pos_within_pid * dim1;
+        auto offset         = pid_offset * total_col_size + ncols_send(pid) * f_col_sizes_scan_sum +
+                      pos_within_pid * dim1;
         auto col_pack = [&](const int &k) { send_buf(offset + k) = v(icol, k); };
         auto tvr      = Kokkos::TeamVectorRange(team, dim1);
         Kokkos::parallel_for(tvr, col_pack);
@@ -212,8 +216,8 @@ void RefiningRemapperP2P::pack_and_send() {
         const int pid       = export_pids(iexp);
         auto pid_offset     = pids_send_offsets(pid);
         auto pos_within_pid = iexp - pid_offset;
-        auto offset =
-            pid_offset * total_col_size + ncols_send(pid) * f_col_sizes_scan_sum + pos_within_pid * f_col_size;
+        auto offset         = pid_offset * total_col_size + ncols_send(pid) * f_col_sizes_scan_sum +
+                      pos_within_pid * f_col_size;
         auto col_pack = [&](const int &idx) {
           const int j            = idx / dim2;
           const int k            = idx % dim2;
@@ -238,8 +242,8 @@ void RefiningRemapperP2P::pack_and_send() {
         const int pid       = export_pids(iexp);
         auto pid_offset     = pids_send_offsets(pid);
         auto pos_within_pid = iexp - pid_offset;
-        auto offset =
-            pid_offset * total_col_size + ncols_send(pid) * f_col_sizes_scan_sum + pos_within_pid * f_col_size;
+        auto offset         = pid_offset * total_col_size + ncols_send(pid) * f_col_sizes_scan_sum +
+                      pos_within_pid * f_col_size;
         auto col_pack = [&](const int &idx) {
           const int j            = (idx / dim3) / dim2;
           const int k            = (idx / dim3) % dim2;
@@ -318,8 +322,9 @@ void RefiningRemapperP2P::recv_and_unpack() {
         const int icol            = import_lids(idx);
         const auto pid_offset     = pids_recv_offsets(pid);
         const auto pos_within_pid = idx - pid_offset;
-        auto offset = pid_offset * total_col_size + ncols_recv(pid) * f_col_sizes_scan_sum + pos_within_pid;
-        v(icol)     = recv_buf(offset);
+        auto offset =
+            pid_offset * total_col_size + ncols_recv(pid) * f_col_sizes_scan_sum + pos_within_pid;
+        v(icol) = recv_buf(offset);
       };
       Kokkos::parallel_for(RangePolicy(0, num_imports), unpack);
       break;
@@ -334,7 +339,8 @@ void RefiningRemapperP2P::recv_and_unpack() {
         const int icol            = import_lids(idx);
         const auto pid_offset     = pids_recv_offsets(pid);
         const auto pos_within_pid = idx - pid_offset;
-        auto offset     = pid_offset * total_col_size + ncols_recv(pid) * f_col_sizes_scan_sum + pos_within_pid * dim1;
+        auto offset = pid_offset * total_col_size + ncols_recv(pid) * f_col_sizes_scan_sum +
+                      pos_within_pid * dim1;
         auto col_unpack = [&](const int &k) { v(icol, k) = recv_buf(offset + k); };
         auto tvr        = Kokkos::TeamVectorRange(team, dim1);
         Kokkos::parallel_for(tvr, col_unpack);
@@ -354,8 +360,8 @@ void RefiningRemapperP2P::recv_and_unpack() {
         const int icol            = import_lids(idx);
         const auto pid_offset     = pids_recv_offsets(pid);
         const auto pos_within_pid = idx - pid_offset;
-        auto offset =
-            pid_offset * total_col_size + ncols_recv(pid) * f_col_sizes_scan_sum + pos_within_pid * f_col_size;
+        auto offset = pid_offset * total_col_size + ncols_recv(pid) * f_col_sizes_scan_sum +
+                      pos_within_pid * f_col_size;
         auto col_unpack = [&](const int &idx) {
           const int j   = idx / dim2;
           const int k   = idx % dim2;
@@ -380,8 +386,8 @@ void RefiningRemapperP2P::recv_and_unpack() {
         const int icol            = import_lids(idx);
         const auto pid_offset     = pids_recv_offsets(pid);
         const auto pos_within_pid = idx - pid_offset;
-        auto offset =
-            pid_offset * total_col_size + ncols_recv(pid) * f_col_sizes_scan_sum + pos_within_pid * f_col_size;
+        auto offset = pid_offset * total_col_size + ncols_recv(pid) * f_col_sizes_scan_sum +
+                      pos_within_pid * f_col_size;
         auto col_unpack = [&](const int &idx) {
           const int j      = (idx / dim3) / dim2;
           const int k      = (idx / dim3) % dim2;
diff --git i/components/eamxx/src/share/grid/remap/refining_remapper_p2p.hpp w/components/eamxx/src/share/grid/remap/refining_remapper_p2p.hpp
index a6e70be935..7b73deaef3 100644
--- i/components/eamxx/src/share/grid/remap/refining_remapper_p2p.hpp
+++ w/components/eamxx/src/share/grid/remap/refining_remapper_p2p.hpp
@@ -71,7 +71,8 @@ protected:
   // If MpiOnDev=true, we pass device pointers to MPI. Otherwise, we use host mirrors.
   static constexpr bool MpiOnDev = SCREAM_MPI_ON_DEVICE;
   template <typename T>
-  using mpi_view_1d = typename std::conditional<MpiOnDev, view_1d<T>, typename view_1d<T>::HostMirror>::type;
+  using mpi_view_1d =
+      typename std::conditional<MpiOnDev, view_1d<T>, typename view_1d<T>::HostMirror>::type;
 
   // ----- Data structures for pack/unpack and MPI ----- //
 
diff --git i/components/eamxx/src/share/grid/remap/refining_remapper_rma.cpp w/components/eamxx/src/share/grid/remap/refining_remapper_rma.cpp
index f6b5fadeed..def9d3aeb2 100644
--- i/components/eamxx/src/share/grid/remap/refining_remapper_rma.cpp
+++ w/components/eamxx/src/share/grid/remap/refining_remapper_rma.cpp
@@ -20,8 +20,10 @@ RefiningRemapperRMA::~RefiningRemapperRMA() { clean_up(); }
 void RefiningRemapperRMA::remap_fwd_impl() {
   // Start RMA epoch on each field
   for (int i = 0; i < m_num_fields; ++i) {
-    check_mpi_call(MPI_Win_post(m_mpi_group, 0, m_mpi_win[i]), "MPI_Win_post for field: " + m_src_fields[i].name());
-    check_mpi_call(MPI_Win_start(m_mpi_group, 0, m_mpi_win[i]), "MPI_Win_start for field: " + m_src_fields[i].name());
+    check_mpi_call(MPI_Win_post(m_mpi_group, 0, m_mpi_win[i]),
+                   "MPI_Win_post for field: " + m_src_fields[i].name());
+    check_mpi_call(MPI_Win_start(m_mpi_group, 0, m_mpi_win[i]),
+                   "MPI_Win_start for field: " + m_src_fields[i].name());
   }
 
   // Loop over fields, and grab data
@@ -36,15 +38,16 @@ void RefiningRemapperRMA::remap_fwd_impl() {
     for (int icol = 0; icol < m_ov_coarse_grid->get_num_local_dofs(); ++icol) {
       const int pid = m_remote_pids[icol];
       const int lid = m_remote_lids[icol];
-      check_mpi_call(
-          MPI_Get(ov_data + icol * col_size, col_size, dt, pid, lid * col_stride + col_offset, col_size, dt, win),
-          "MPI_Get for field: " + m_ov_fields[i].name());
+      check_mpi_call(MPI_Get(ov_data + icol * col_size, col_size, dt, pid,
+                             lid * col_stride + col_offset, col_size, dt, win),
+                     "MPI_Get for field: " + m_ov_fields[i].name());
     }
   }
 
   // Close access RMA epoch on each field (exposure is still open)
   for (int i = 0; i < m_num_fields; ++i) {
-    check_mpi_call(MPI_Win_complete(m_mpi_win[i]), "MPI_Win_complete for field: " + m_ov_fields[i].name());
+    check_mpi_call(MPI_Win_complete(m_mpi_win[i]),
+                   "MPI_Win_complete for field: " + m_ov_fields[i].name());
   }
 
   // Helpef function, to establish if a field can be handled with packs
@@ -124,11 +127,13 @@ void RefiningRemapperRMA::setup_mpi_data_structures() {
     }
 
     auto data = f.get_internal_view_data<Real, Host>();
-    check_mpi_call(MPI_Win_create(data, win_size, sizeof(Real), MPI_INFO_NULL, mpi_comm, &m_mpi_win[i]),
-                   "[RefiningRemapperRMA::setup_mpi_data_structures] MPI_Win_create");
+    check_mpi_call(
+        MPI_Win_create(data, win_size, sizeof(Real), MPI_INFO_NULL, mpi_comm, &m_mpi_win[i]),
+        "[RefiningRemapperRMA::setup_mpi_data_structures] MPI_Win_create");
 #ifndef EKAT_MPI_ERRORS_ARE_FATAL
     check_mpi_call(MPI_Win_set_errhandler(m_mpi_win[i], MPI_ERRORS_RETURN),
-                   "[RefiningRemapperRMA::setup_mpi_data_structure] setting MPI_ERRORS_RETURN handler on MPI_Win");
+                   "[RefiningRemapperRMA::setup_mpi_data_structure] setting MPI_ERRORS_RETURN "
+                   "handler on MPI_Win");
 #endif
   }
 }
diff --git i/components/eamxx/src/share/grid/remap/refining_remapper_rma.hpp w/components/eamxx/src/share/grid/remap/refining_remapper_rma.hpp
index 94cc016fbb..d697853677 100644
--- i/components/eamxx/src/share/grid/remap/refining_remapper_rma.hpp
+++ w/components/eamxx/src/share/grid/remap/refining_remapper_rma.hpp
@@ -62,8 +62,9 @@ protected:
   // Wrap a pointer in an MPI_Win
   template <typename T> MPI_Win get_mpi_window(T *v, int n) const {
     MPI_Win win;
-    check_mpi_call(MPI_Win_create(v, n * sizeof(T), sizeof(T), MPI_INFO_NULL, m_comm.mpi_comm(), &win),
-                   "MPI_Win_create");
+    check_mpi_call(
+        MPI_Win_create(v, n * sizeof(T), sizeof(T), MPI_INFO_NULL, m_comm.mpi_comm(), &win),
+        "MPI_Win_create");
     return win;
   }
 
diff --git i/components/eamxx/src/share/grid/remap/vertical_remapper.cpp w/components/eamxx/src/share/grid/remap/vertical_remapper.cpp
index 8f9aa10945..e7c9e33e08 100644
--- i/components/eamxx/src/share/grid/remap/vertical_remapper.cpp
+++ w/components/eamxx/src/share/grid/remap/vertical_remapper.cpp
@@ -68,8 +68,9 @@ void VerticalRemapper::set_extrapolation_type(const ExtrapType etype, const TopB
 }
 
 void VerticalRemapper::set_mask_value(const Real mask_val) {
-  EKAT_REQUIRE_MSG(not ekat::is_invalid(mask_val),
-                   "[VerticalRemapper::set_mask_value] Error! Input mask value must be a valid number.\n");
+  EKAT_REQUIRE_MSG(
+      not ekat::is_invalid(mask_val),
+      "[VerticalRemapper::set_mask_value] Error! Input mask value must be a valid number.\n");
 
   m_mask_val = mask_val;
 }
@@ -82,7 +83,8 @@ void VerticalRemapper::set_target_pressure(const Field &p, const ProfileType pty
   set_pressure(p, "target", ptype);
 }
 
-void VerticalRemapper::set_pressure(const Field &p, const std::string &src_or_tgt, const ProfileType ptype) {
+void VerticalRemapper::set_pressure(const Field &p, const std::string &src_or_tgt,
+                                    const ProfileType ptype) {
   using namespace ShortFieldTagsNames;
   using PackT = ekat::Pack<Real, SCREAM_PACK_SIZE>;
 
@@ -101,7 +103,8 @@ void VerticalRemapper::set_pressure(const Field &p, const std::string &src_or_tg
                        " - pack size: " +
                        std::to_string(SCREAM_PACK_SIZE) + "\n");
 
-  const int nlevs      = src ? m_src_grid->get_num_vertical_levels() : m_tgt_grid->get_num_vertical_levels();
+  const int nlevs =
+      src ? m_src_grid->get_num_vertical_levels() : m_tgt_grid->get_num_vertical_levels();
   const auto &p_layout = p.get_header().get_identifier().get_layout();
   const auto vtag      = p_layout.tags().back();
   const auto vdim      = p_layout.dims().back();
@@ -141,18 +144,20 @@ void VerticalRemapper::set_pressure(const Field &p, const std::string &src_or_tg
     }
     break;
   default:
-    EKAT_ERROR_MSG("[VerticalRemapper::set_source_pressure] Error! Unrecognized value for 'ptype'.\n");
+    EKAT_ERROR_MSG(
+        "[VerticalRemapper::set_source_pressure] Error! Unrecognized value for 'ptype'.\n");
   }
-  EKAT_REQUIRE_MSG(vtag == expected_tag and vdim == expected_dim, msg_prefix +
-                                                                      "Invalid pressure layout.\n"
-                                                                      "  - layout: " +
-                                                                      p_layout.to_string() +
-                                                                      "\n"
-                                                                      "  - expected last layout tag: " +
-                                                                      e2str(expected_tag) +
-                                                                      "\n"
-                                                                      "  - expected last layout dim: " +
-                                                                      std::to_string(expected_dim) + "\n");
+  EKAT_REQUIRE_MSG(vtag == expected_tag and vdim == expected_dim,
+                   msg_prefix +
+                       "Invalid pressure layout.\n"
+                       "  - layout: " +
+                       p_layout.to_string() +
+                       "\n"
+                       "  - expected last layout tag: " +
+                       e2str(expected_tag) +
+                       "\n"
+                       "  - expected last layout dim: " +
+                       std::to_string(expected_dim) + "\n");
 }
 
 void VerticalRemapper::registration_ends_impl() {
@@ -168,23 +173,26 @@ void VerticalRemapper::registration_ends_impl() {
 
     if (src_layout.has_tag(LEV) or src_layout.has_tag(ILEV)) {
       // Determine if this field can be handled with packs, and whether it's at midpoints
-      // NOTE: we don't know if mid==int on src or tgt. If it is, we use the other to determine mid-vs-int
-      // Add mask tracking to the target field. The mask tracks location of tgt pressure levs that are outside the
-      // bounds of the src pressure field, and hence cannot be recovered by interpolation
+      // NOTE: we don't know if mid==int on src or tgt. If it is, we use the other to determine
+      // mid-vs-int Add mask tracking to the target field. The mask tracks location of tgt pressure
+      // levs that are outside the bounds of the src pressure field, and hence cannot be recovered
+      // by interpolation
       auto &ft     = m_field2type[src.name()];
-      ft.midpoints = m_src_int_same_as_mid ? tgt.get_header().get_identifier().get_layout().has_tag(LEV)
-                                           : src.get_header().get_identifier().get_layout().has_tag(LEV);
+      ft.midpoints = m_src_int_same_as_mid
+                         ? tgt.get_header().get_identifier().get_layout().has_tag(LEV)
+                         : src.get_header().get_identifier().get_layout().has_tag(LEV);
       ft.packed    = src.get_header().get_alloc_properties().is_compatible<PackT>() and
                   tgt.get_header().get_alloc_properties().is_compatible<PackT>();
 
       if (m_etype_top == Mask or m_etype_bot == Mask) {
         // NOTE: for now we assume that masking is determined only by the COL,LEV location in space
-        //       and that fields with multiple components will have the same masking for each component
-        //       at a specific COL,LEV
+        //       and that fields with multiple components will have the same masking for each
+        //       component at a specific COL,LEV
         src_layout.strip_dims({CMP});
 
         // I this mask has already been created, retrieve it, otherwise create it
-        const auto mask_name = m_tgt_grid->name() + "_" + ekat::join(src_layout.names(), "_") + "_mask";
+        const auto mask_name =
+            m_tgt_grid->name() + "_" + ekat::join(src_layout.names(), "_") + "_mask";
         Field tgt_mask;
         if (m_field2type.count(mask_name) == 0) {
           auto nondim = ekat::units::Units::nondimensional();
@@ -217,39 +225,39 @@ void VerticalRemapper::registration_ends_impl() {
           }
         }
 
-        EKAT_REQUIRE_MSG(
-            not tgt.get_header().has_extra_data("mask_data"),
-            "[VerticalRemapper::registration_ends_impl] Error! Target field already has mask data assigned.\n"
-            " - tgt field name: " +
-                tgt.name() + "\n");
-        EKAT_REQUIRE_MSG(
-            not tgt.get_header().has_extra_data("mask_value"),
-            "[VerticalRemapper::registration_ends_impl] Error! Target field already has mask value assigned.\n"
-            " - tgt field name: " +
-                tgt.name() + "\n");
+        EKAT_REQUIRE_MSG(not tgt.get_header().has_extra_data("mask_data"),
+                         "[VerticalRemapper::registration_ends_impl] Error! Target field already "
+                         "has mask data assigned.\n"
+                         " - tgt field name: " +
+                             tgt.name() + "\n");
+        EKAT_REQUIRE_MSG(not tgt.get_header().has_extra_data("mask_value"),
+                         "[VerticalRemapper::registration_ends_impl] Error! Target field already "
+                         "has mask value assigned.\n"
+                         " - tgt field name: " +
+                             tgt.name() + "\n");
 
         tgt.get_header().set_extra_data("mask_data", tgt_mask);
         tgt.get_header().set_extra_data("mask_value", m_mask_val);
       }
     } else {
-      // If a field does not have LEV or ILEV it may still have mask tracking assigned from somewhere else.
-      // For instance, this could be a 2d field computed by FieldAtPressureLevel diagnostic.
-      // In those cases we want to copy that mask tracking to the target field.
+      // If a field does not have LEV or ILEV it may still have mask tracking assigned from
+      // somewhere else. For instance, this could be a 2d field computed by FieldAtPressureLevel
+      // diagnostic. In those cases we want to copy that mask tracking to the target field.
       if (src.get_header().has_extra_data("mask_data")) {
-        EKAT_REQUIRE_MSG(
-            not tgt.get_header().has_extra_data("mask_data"),
-            "[VerticalRemapper::registration_ends_impl] Error! Target field already has mask data assigned.\n"
-            " - tgt field name: " +
-                tgt.name() + "\n");
+        EKAT_REQUIRE_MSG(not tgt.get_header().has_extra_data("mask_data"),
+                         "[VerticalRemapper::registration_ends_impl] Error! Target field already "
+                         "has mask data assigned.\n"
+                         " - tgt field name: " +
+                             tgt.name() + "\n");
         auto src_mask = src.get_header().get_extra_data<Field>("mask_data");
         tgt.get_header().set_extra_data("mask_data", src_mask);
       }
       if (src.get_header().has_extra_data("mask_value")) {
-        EKAT_REQUIRE_MSG(
-            not tgt.get_header().has_extra_data("mask_value"),
-            "[VerticalRemapper::registration_ends_impl] Error! Target field already has mask value assigned.\n"
-            " - tgt field name: " +
-                tgt.name() + "\n");
+        EKAT_REQUIRE_MSG(not tgt.get_header().has_extra_data("mask_value"),
+                         "[VerticalRemapper::registration_ends_impl] Error! Target field already "
+                         "has mask value assigned.\n"
+                         " - tgt field name: " +
+                             tgt.name() + "\n");
         auto src_mask_val = src.get_header().get_extra_data<Real>("mask_value");
         tgt.get_header().set_extra_data("mask_value", src_mask_val);
       }
@@ -263,12 +271,15 @@ void VerticalRemapper::create_lin_interp() {
   auto beg = m_field2type.begin();
   auto end = m_field2type.end();
 
-  int num_packed_mid = std::count_if(
-      beg, end, [](const std::pair<std::string, FType> &it) { return it.second.midpoints and it.second.packed; });
-  int num_packed_int = std::count_if(
-      beg, end, [](const std::pair<std::string, FType> &it) { return not it.second.midpoints and it.second.packed; });
-  int num_scalar_mid = std::count_if(
-      beg, end, [](const std::pair<std::string, FType> &it) { return it.second.midpoints and not it.second.packed; });
+  int num_packed_mid = std::count_if(beg, end, [](const std::pair<std::string, FType> &it) {
+    return it.second.midpoints and it.second.packed;
+  });
+  int num_packed_int = std::count_if(beg, end, [](const std::pair<std::string, FType> &it) {
+    return not it.second.midpoints and it.second.packed;
+  });
+  int num_scalar_mid = std::count_if(beg, end, [](const std::pair<std::string, FType> &it) {
+    return it.second.midpoints and not it.second.packed;
+  });
   int num_scalar_int = std::count_if(beg, end, [](const std::pair<std::string, FType> &it) {
     return not it.second.midpoints and not it.second.packed;
   });
@@ -279,27 +290,33 @@ void VerticalRemapper::create_lin_interp() {
   const auto nlevs_tgt = m_tgt_grid->get_num_vertical_levels();
 
   if (num_packed_mid > 0) {
-    m_lin_interp_mid_packed = std::make_shared<ekat::LinInterp<Real, SCREAM_PACK_SIZE>>(ncols, nlevs_src, nlevs_tgt);
+    m_lin_interp_mid_packed =
+        std::make_shared<ekat::LinInterp<Real, SCREAM_PACK_SIZE>>(ncols, nlevs_src, nlevs_tgt);
   }
   if (num_scalar_mid > 0) {
-    m_lin_interp_mid_scalar = std::make_shared<ekat::LinInterp<Real, 1>>(ncols, nlevs_src, nlevs_tgt);
+    m_lin_interp_mid_scalar =
+        std::make_shared<ekat::LinInterp<Real, 1>>(ncols, nlevs_src, nlevs_tgt);
   }
   if (num_packed_int > 0) {
-    m_lin_interp_int_packed = std::make_shared<ekat::LinInterp<Real, SCREAM_PACK_SIZE>>(ncols, nlevs_src, nlevs_tgt);
+    m_lin_interp_int_packed =
+        std::make_shared<ekat::LinInterp<Real, SCREAM_PACK_SIZE>>(ncols, nlevs_src, nlevs_tgt);
   }
   if (num_scalar_int > 0) {
-    m_lin_interp_int_scalar = std::make_shared<ekat::LinInterp<Real, 1>>(ncols, nlevs_src, nlevs_tgt);
+    m_lin_interp_int_scalar =
+        std::make_shared<ekat::LinInterp<Real, 1>>(ncols, nlevs_src, nlevs_tgt);
   }
 }
 
 bool VerticalRemapper::is_valid_tgt_layout(const FieldLayout &layout) const {
   using namespace ShortFieldTagsNames;
-  return !(m_tgt_int_same_as_mid and layout.has_tag(ILEV)) and AbstractRemapper::is_valid_tgt_layout(layout);
+  return !(m_tgt_int_same_as_mid and layout.has_tag(ILEV)) and
+         AbstractRemapper::is_valid_tgt_layout(layout);
 }
 
 bool VerticalRemapper::is_valid_src_layout(const FieldLayout &layout) const {
   using namespace ShortFieldTagsNames;
-  return !(m_src_int_same_as_mid and layout.has_tag(ILEV)) and AbstractRemapper::is_valid_src_layout(layout);
+  return !(m_src_int_same_as_mid and layout.has_tag(ILEV)) and
+         AbstractRemapper::is_valid_src_layout(layout);
 }
 
 bool VerticalRemapper::compatible_layouts(const FieldLayout &src, const FieldLayout &tgt) const {
@@ -314,25 +331,27 @@ bool VerticalRemapper::compatible_layouts(const FieldLayout &src, const FieldLay
   return src.rank() == tgt.rank() and src_stripped.congruent(tgt_stripped);
 }
 
-FieldLayout VerticalRemapper::create_layout(const FieldLayout &from_layout,
-                                            const std::shared_ptr<const AbstractGrid> &to_grid) const {
+FieldLayout
+VerticalRemapper::create_layout(const FieldLayout &from_layout,
+                                const std::shared_ptr<const AbstractGrid> &to_grid) const {
   using namespace ShortFieldTagsNames;
 
   // Detect if for the output grid we distinguish between midpoints and interfaces or not
   // If we don't distinguish, we just use the LEV tag (for layout with the vertical dim)
-  auto from_grid              = to_grid == m_src_grid ? m_tgt_grid : m_src_grid;
-  bool output_int_same_as_mid = to_grid == m_src_grid ? m_src_int_same_as_mid : m_tgt_int_same_as_mid;
-  bool input_int_same_as_mid  = from_grid == m_src_grid ? m_src_int_same_as_mid : m_tgt_int_same_as_mid;
+  auto from_grid = to_grid == m_src_grid ? m_tgt_grid : m_src_grid;
+  bool output_int_same_as_mid =
+      to_grid == m_src_grid ? m_src_int_same_as_mid : m_tgt_int_same_as_mid;
+  bool input_int_same_as_mid =
+      from_grid == m_src_grid ? m_src_int_same_as_mid : m_tgt_int_same_as_mid;
 
   // If the input layout does not distinguish between LEV/ILEV, we cannot deduce the output layout
-  EKAT_REQUIRE_MSG(
-      not input_int_same_as_mid,
-      "[VerticalRemapper::create_layout] Error! Starting layout does not distinguish between LEV and ILEV.\n"
-      "  - from grid: " +
-          from_grid->name() +
-          "\n"
-          "  - to grid  : " +
-          to_grid->name() + "\n");
+  EKAT_REQUIRE_MSG(not input_int_same_as_mid, "[VerticalRemapper::create_layout] Error! Starting "
+                                              "layout does not distinguish between LEV and ILEV.\n"
+                                              "  - from grid: " +
+                                                  from_grid->name() +
+                                                  "\n"
+                                                  "  - to grid  : " +
+                                                  to_grid->name() + "\n");
 
   auto to_layout = FieldLayout::invalid();
   bool midpoints;
@@ -400,16 +419,20 @@ void VerticalRemapper::remap_fwd_impl() {
       // Dispatch interpolation to the proper lin interp object
       if (type.midpoints) {
         if (type.packed) {
-          apply_vertical_interpolation(*m_lin_interp_mid_packed, f_src, f_tgt, m_src_pmid, m_tgt_pmid);
+          apply_vertical_interpolation(*m_lin_interp_mid_packed, f_src, f_tgt, m_src_pmid,
+                                       m_tgt_pmid);
         } else {
-          apply_vertical_interpolation(*m_lin_interp_mid_scalar, f_src, f_tgt, m_src_pmid, m_tgt_pmid);
+          apply_vertical_interpolation(*m_lin_interp_mid_scalar, f_src, f_tgt, m_src_pmid,
+                                       m_tgt_pmid);
         }
         extrapolate(f_src, f_tgt, m_src_pmid, m_tgt_pmid, m_mask_val);
       } else {
         if (type.packed) {
-          apply_vertical_interpolation(*m_lin_interp_int_packed, f_src, f_tgt, m_src_pint, m_tgt_pint);
+          apply_vertical_interpolation(*m_lin_interp_int_packed, f_src, f_tgt, m_src_pint,
+                                       m_tgt_pint);
         } else {
-          apply_vertical_interpolation(*m_lin_interp_int_scalar, f_src, f_tgt, m_src_pint, m_tgt_pint);
+          apply_vertical_interpolation(*m_lin_interp_int_scalar, f_src, f_tgt, m_src_pint,
+                                       m_tgt_pint);
         }
         extrapolate(f_src, f_tgt, m_src_pint, m_tgt_pint, m_mask_val);
       }
@@ -435,16 +458,20 @@ void VerticalRemapper::remap_fwd_impl() {
     // Dispatch interpolation to the proper lin interp object
     if (type.midpoints) {
       if (type.packed) {
-        apply_vertical_interpolation(*m_lin_interp_mid_packed, f_src, f_tgt, m_src_pmid, m_tgt_pmid);
+        apply_vertical_interpolation(*m_lin_interp_mid_packed, f_src, f_tgt, m_src_pmid,
+                                     m_tgt_pmid);
       } else {
-        apply_vertical_interpolation(*m_lin_interp_mid_scalar, f_src, f_tgt, m_src_pmid, m_tgt_pmid);
+        apply_vertical_interpolation(*m_lin_interp_mid_scalar, f_src, f_tgt, m_src_pmid,
+                                     m_tgt_pmid);
       }
       extrapolate(f_src, f_tgt, m_src_pmid, m_tgt_pmid, 0);
     } else {
       if (type.packed) {
-        apply_vertical_interpolation(*m_lin_interp_int_packed, f_src, f_tgt, m_src_pint, m_tgt_pint);
+        apply_vertical_interpolation(*m_lin_interp_int_packed, f_src, f_tgt, m_src_pint,
+                                     m_tgt_pint);
       } else {
-        apply_vertical_interpolation(*m_lin_interp_int_scalar, f_src, f_tgt, m_src_pint, m_tgt_pint);
+        apply_vertical_interpolation(*m_lin_interp_int_scalar, f_src, f_tgt, m_src_pint,
+                                     m_tgt_pint);
       }
       extrapolate(f_src, f_tgt, m_src_pint, m_tgt_pint, 0);
     }
@@ -452,8 +479,8 @@ void VerticalRemapper::remap_fwd_impl() {
 }
 
 template <int Packsize>
-void VerticalRemapper::setup_lin_interp(const ekat::LinInterp<Real, Packsize> &lin_interp, const Field &p_src,
-                                        const Field &p_tgt) const {
+void VerticalRemapper::setup_lin_interp(const ekat::LinInterp<Real, Packsize> &lin_interp,
+                                        const Field &p_src, const Field &p_tgt) const {
   using LI_t   = ekat::LinInterp<Real, Packsize>;
   using ESU    = ekat::ExeSpaceUtils<DefaultDevice::execution_space>;
   using PackT  = ekat::Pack<Real, Packsize>;
@@ -497,9 +524,9 @@ void VerticalRemapper::setup_lin_interp(const ekat::LinInterp<Real, Packsize> &l
 }
 
 template <int Packsize>
-void VerticalRemapper::apply_vertical_interpolation(const ekat::LinInterp<Real, Packsize> &lin_interp,
-                                                    const Field &f_src, const Field &f_tgt, const Field &p_src,
-                                                    const Field &p_tgt) const {
+void VerticalRemapper::apply_vertical_interpolation(
+    const ekat::LinInterp<Real, Packsize> &lin_interp, const Field &f_src, const Field &f_tgt,
+    const Field &p_src, const Field &p_tgt) const {
   // Note: if Packsize==1, we grab packs of size 1, which are for sure
   //       compatible with the allocation
   using LI_t  = ekat::LinInterp<Real, Packsize>;
@@ -579,17 +606,18 @@ void VerticalRemapper::apply_vertical_interpolation(const ekat::LinInterp<Real,
     break;
   }
   default:
-    EKAT_ERROR_MSG("[VerticalRemapper::apply_vertical_interpolation] Error! Unsupported field rank.\n"
-                   " - src field name: " +
-                   f_src.name() +
-                   "\n"
-                   " - src field rank: " +
-                   std::to_string(f_src.rank()) + "\n");
+    EKAT_ERROR_MSG(
+        "[VerticalRemapper::apply_vertical_interpolation] Error! Unsupported field rank.\n"
+        " - src field name: " +
+        f_src.name() +
+        "\n"
+        " - src field rank: " +
+        std::to_string(f_src.rank()) + "\n");
   }
 }
 
-void VerticalRemapper::extrapolate(const Field &f_src, const Field &f_tgt, const Field &p_src, const Field &p_tgt,
-                                   const Real mask_val) const {
+void VerticalRemapper::extrapolate(const Field &f_src, const Field &f_tgt, const Field &p_src,
+                                   const Field &p_tgt, const Real mask_val) const {
   using ESU = ekat::ExeSpaceUtils<DefaultDevice::execution_space>;
 
   using view2d = typename KokkosTypes<DefaultDevice>::view<const Real **>;
diff --git i/components/eamxx/src/share/grid/remap/vertical_remapper.hpp w/components/eamxx/src/share/grid/remap/vertical_remapper.hpp
index 8023191c03..dbd5a862e8 100644
--- i/components/eamxx/src/share/grid/remap/vertical_remapper.hpp
+++ w/components/eamxx/src/share/grid/remap/vertical_remapper.hpp
@@ -51,7 +51,8 @@ public:
   Field get_target_pressure(bool midpoints) const { return midpoints ? m_tgt_pmid : m_tgt_pint; }
 
   // This method simply creates the tgt grid from a map file
-  static std::shared_ptr<AbstractGrid> create_tgt_grid(const grid_ptr_type &src_grid, const std::string &map_file);
+  static std::shared_ptr<AbstractGrid> create_tgt_grid(const grid_ptr_type &src_grid,
+                                                       const std::string &map_file);
 
   bool compatible_layouts(const FieldLayout &src, const FieldLayout &tgt) const override;
 
@@ -71,14 +72,16 @@ protected:
 public:
 #endif
   template <int N>
-  void apply_vertical_interpolation(const ekat::LinInterp<Real, N> &lin_interp, const Field &f_src, const Field &f_tgt,
-                                    const Field &p_src, const Field &p_tgt) const;
+  void apply_vertical_interpolation(const ekat::LinInterp<Real, N> &lin_interp, const Field &f_src,
+                                    const Field &f_tgt, const Field &p_src,
+                                    const Field &p_tgt) const;
 
   void extrapolate(const Field &f_src, const Field &f_tgt, const Field &p_src, const Field &p_tgt,
                    const Real mask_val) const;
 
   template <int N>
-  void setup_lin_interp(const ekat::LinInterp<Real, N> &lin_interp, const Field &p_src, const Field &p_tgt) const;
+  void setup_lin_interp(const ekat::LinInterp<Real, N> &lin_interp, const Field &p_src,
+                        const Field &p_tgt) const;
 
 protected:
   void create_lin_interp();
diff --git i/components/eamxx/src/share/grid/se_grid.cpp w/components/eamxx/src/share/grid/se_grid.cpp
index 23fa51cb17..d580254c26 100644
--- i/components/eamxx/src/share/grid/se_grid.cpp
+++ w/components/eamxx/src/share/grid/se_grid.cpp
@@ -7,12 +7,13 @@ namespace scream {
 
 SEGrid::SEGrid(const std::string &grid_name, const int num_my_elements, const int num_gauss_pts,
                const int num_vertical_levels, const ekat::Comm &comm)
-    : AbstractGrid(grid_name, GridType::SE, num_my_elements * num_gauss_pts * num_gauss_pts, num_vertical_levels,
-                   comm) {
+    : AbstractGrid(grid_name, GridType::SE, num_my_elements * num_gauss_pts * num_gauss_pts,
+                   num_vertical_levels, comm) {
   // Sanity checks
   EKAT_REQUIRE_MSG(num_my_elements >= 0, "Error! Number of local elements must be non-negative.\n");
   EKAT_REQUIRE_MSG(num_gauss_pts >= 2, "Error! Number of gauss points must be at least 2.\n");
-  EKAT_REQUIRE_MSG(num_vertical_levels >= 2, "Error! Number of vertical levels must be at least 2.\n");
+  EKAT_REQUIRE_MSG(num_vertical_levels >= 2,
+                   "Error! Number of vertical levels must be at least 2.\n");
 
   m_num_local_elem = num_my_elements;
   m_num_gp         = num_gauss_pts;
@@ -24,22 +25,24 @@ SEGrid::SEGrid(const std::string &grid_name, const int num_my_elements, const in
   // Create the cg dofs field
   using namespace ShortFieldTagsNames;
   const auto units = ekat::units::Units::nondimensional();
-  m_cg_dofs_gids   = Field(
-      FieldIdentifier("cg_gids", FieldLayout({CMP}, {get_num_local_dofs()}), units, this->name(), DataType::IntType));
+  m_cg_dofs_gids   = Field(FieldIdentifier("cg_gids", FieldLayout({CMP}, {get_num_local_dofs()}),
+                                           units, this->name(), DataType::IntType));
   m_cg_dofs_gids.allocate_view();
 
-  m_partitioned_dim_gids =
-      Field(FieldIdentifier("el_gids", FieldLayout({EL}, {m_num_local_elem}), units, this->name(), DataType::IntType));
+  m_partitioned_dim_gids = Field(FieldIdentifier("el_gids", FieldLayout({EL}, {m_num_local_elem}),
+                                                 units, this->name(), DataType::IntType));
   m_partitioned_dim_gids.allocate_view();
 }
 
 FieldLayout SEGrid::get_2d_scalar_layout() const {
   using namespace ShortFieldTagsNames;
 
-  return FieldLayout({EL, GP, GP}, {m_num_local_elem, m_num_gp, m_num_gp}).rename_dims(m_special_tag_names);
+  return FieldLayout({EL, GP, GP}, {m_num_local_elem, m_num_gp, m_num_gp})
+      .rename_dims(m_special_tag_names);
 }
 
-FieldLayout SEGrid::get_2d_vector_layout(const int vector_dim, const std::string &vec_dim_name) const {
+FieldLayout SEGrid::get_2d_vector_layout(const int vector_dim,
+                                         const std::string &vec_dim_name) const {
   using namespace ShortFieldTagsNames;
 
   FieldLayout fl({EL, CMP, GP, GP}, {m_num_local_elem, vector_dim, m_num_gp, m_num_gp});
@@ -80,7 +83,8 @@ FieldLayout SEGrid::get_3d_scalar_layout(const bool midpoints) const {
   int nvl = this->get_num_vertical_levels() + (midpoints ? 0 : 1);
   auto VL = midpoints ? LEV : ILEV;
 
-  return FieldLayout({EL, GP, GP, VL}, {m_num_local_elem, m_num_gp, m_num_gp, nvl}).rename_dims(m_special_tag_names);
+  return FieldLayout({EL, GP, GP, VL}, {m_num_local_elem, m_num_gp, m_num_gp, nvl})
+      .rename_dims(m_special_tag_names);
 }
 
 FieldLayout SEGrid::get_3d_vector_layout(const bool midpoints, const int vector_dim,
@@ -126,8 +130,10 @@ FieldLayout SEGrid::get_3d_tensor_layout(const bool midpoints, const std::vector
   return fl.rename_dims(m_special_tag_names);
 }
 
-std::shared_ptr<AbstractGrid> SEGrid::clone(const std::string &clone_name, const bool shallow) const {
-  auto grid = std::make_shared<SEGrid>(clone_name, m_num_local_elem, m_num_gp, get_num_vertical_levels(), get_comm());
+std::shared_ptr<AbstractGrid> SEGrid::clone(const std::string &clone_name,
+                                            const bool shallow) const {
+  auto grid = std::make_shared<SEGrid>(clone_name, m_num_local_elem, m_num_gp,
+                                       get_num_vertical_levels(), get_comm());
 
   grid->copy_data(*this, shallow);
 
diff --git i/components/eamxx/src/share/grid/se_grid.hpp w/components/eamxx/src/share/grid/se_grid.hpp
index 355f2d8e13..34122647f5 100644
--- i/components/eamxx/src/share/grid/se_grid.hpp
+++ w/components/eamxx/src/share/grid/se_grid.hpp
@@ -15,7 +15,8 @@ public:
 
   // Native layout of a dof. This is the natural way to index a dof in the grid.
   FieldLayout get_2d_scalar_layout() const override;
-  FieldLayout get_2d_vector_layout(const int vector_dim, const std::string &vec_dim_name) const override;
+  FieldLayout get_2d_vector_layout(const int vector_dim,
+                                   const std::string &vec_dim_name) const override;
   FieldLayout get_2d_tensor_layout(const std::vector<int> &cmp_dims,
                                    const std::vector<std::string> &cmp_names) const override;
   FieldLayout get_3d_scalar_layout(const bool midpoints) const override;
@@ -32,7 +33,8 @@ public:
   Field get_cg_dofs_gids() { return m_cg_dofs_gids; }
   Field get_cg_dofs_gids() const { return m_cg_dofs_gids.get_const(); }
 
-  std::shared_ptr<AbstractGrid> clone(const std::string &clone_name, const bool shallow) const override;
+  std::shared_ptr<AbstractGrid> clone(const std::string &clone_name,
+                                      const bool shallow) const override;
 
   bool check_valid_dofs() const override;
   bool check_valid_lid_to_idx() const override;
diff --git i/components/eamxx/src/share/io/eamxx_io_control.hpp w/components/eamxx/src/share/io/eamxx_io_control.hpp
index 14bda48743..3fbc38e981 100644
--- i/components/eamxx/src/share/io/eamxx_io_control.hpp
+++ w/components/eamxx/src/share/io/eamxx_io_control.hpp
@@ -16,7 +16,8 @@ struct IOControl {
   int frequency               = -1;
   std::string frequency_units = "none";
 
-  int nsamples_since_last_write = 0; // Needed when updating output data, such as with the OAT::Average flag
+  int nsamples_since_last_write =
+      0; // Needed when updating output data, such as with the OAT::Average flag
 
   util::TimeStamp next_write_ts;
   util::TimeStamp last_write_ts;
@@ -24,7 +25,8 @@ struct IOControl {
   // At run time, set dt in the struct, so we can compute next_write_ts correctly,
   // even if freq_units is "nsteps"
   // NOTE: this ASSUMES dt is constant throughout the run (i.e., no time adaptivity).
-  //       An error will be thrown if dt changes, so developers can fix this if we ever support variable dt
+  //       An error will be thrown if dt changes, so developers can fix this if we ever support
+  //       variable dt
   double dt = 0;
 
   bool output_enabled() const { return frequency_units != "none" && frequency_units != "never"; }
@@ -32,9 +34,9 @@ struct IOControl {
   bool is_write_step(const util::TimeStamp &ts) const {
     if (not output_enabled())
       return false;
-    return frequency_units == "nsteps"
-               ? ts.get_num_steps() == next_write_ts.get_num_steps()
-               : (ts.get_date() == next_write_ts.get_date() and ts.get_time() == next_write_ts.get_time());
+    return frequency_units == "nsteps" ? ts.get_num_steps() == next_write_ts.get_num_steps()
+                                       : (ts.get_date() == next_write_ts.get_date() and
+                                          ts.get_time() == next_write_ts.get_time());
   }
 
   void set_frequency_units(const std::string &freq_unit) {
@@ -61,7 +63,8 @@ struct IOControl {
   }
 
   void set_dt(const double dt_in) {
-    EKAT_REQUIRE_MSG(dt == 0 or dt == dt_in, "[IOControl::set_dt] Error! Cannot reset dt once it is set.\n");
+    EKAT_REQUIRE_MSG(dt == 0 or dt == dt_in,
+                     "[IOControl::set_dt] Error! Cannot reset dt once it is set.\n");
 
     dt = dt_in;
   }
diff --git i/components/eamxx/src/share/io/eamxx_io_file_specs.hpp w/components/eamxx/src/share/io/eamxx_io_file_specs.hpp
index 66f8949a7f..4dc43dbb65 100644
--- i/components/eamxx/src/share/io/eamxx_io_file_specs.hpp
+++ w/components/eamxx/src/share/io/eamxx_io_file_specs.hpp
@@ -106,13 +106,16 @@ struct IOFileSpecs {
   int flush_frequency = std::numeric_limits<int>::max();
 
   bool file_needs_flush() const {
-    return storage.num_snapshots_in_file > 0 and storage.num_snapshots_in_file % flush_frequency == 0;
+    return storage.num_snapshots_in_file > 0 and
+           storage.num_snapshots_in_file % flush_frequency == 0;
   }
 
   // Whether it is a model output, model restart, or history restart file
   FileType ftype = FileType::Unset;
 
-  bool is_restart_file() const { return ftype == FileType::ModelRestart or ftype == FileType::HistoryRestart; }
+  bool is_restart_file() const {
+    return ftype == FileType::ModelRestart or ftype == FileType::HistoryRestart;
+  }
 
   std::string suffix() const {
     if (ftype == FileType::HistoryRestart)
diff --git i/components/eamxx/src/share/io/eamxx_io_utils.cpp w/components/eamxx/src/share/io/eamxx_io_utils.cpp
index 467d94522f..48f641980e 100644
--- i/components/eamxx/src/share/io/eamxx_io_utils.cpp
+++ w/components/eamxx/src/share/io/eamxx_io_utils.cpp
@@ -11,8 +11,9 @@
 namespace scream {
 
 std::string find_filename_in_rpointer(const std::string &filename_prefix, const bool model_restart,
-                                      const ekat::Comm &comm, const util::TimeStamp &run_t0, const bool allow_not_found,
-                                      const OutputAvgType avg_type, const IOControl &control) {
+                                      const ekat::Comm &comm, const util::TimeStamp &run_t0,
+                                      const bool allow_not_found, const OutputAvgType avg_type,
+                                      const IOControl &control) {
   std::string filename;
   bool found = false;
   std::string content;
@@ -22,16 +23,19 @@ std::string find_filename_in_rpointer(const std::string &filename_prefix, const
   // The AD will pass a default constructed control, since it doesn't know the values
   // of REST_N/REST_OPTION used in the previous run. Also, model restart is *always* INSTANT.
   if (model_restart) {
-    EKAT_REQUIRE_MSG(avg_type == OutputAvgType::Instant, "Error! Model restart output should have INSTANT avg type.\n"
-                                                         " - input avg_type: " +
-                                                             e2str(avg_type) + "\n");
+    EKAT_REQUIRE_MSG(avg_type == OutputAvgType::Instant,
+                     "Error! Model restart output should have INSTANT avg type.\n"
+                     " - input avg_type: " +
+                         e2str(avg_type) + "\n");
     pattern_str += e2str(OutputAvgType::Instant) + R"(.n(step|sec|min|hour|day|month|year)s_x\d+)";
   } else {
-    EKAT_REQUIRE_MSG(control.output_enabled(),
-                     "Error! When restarting an output stream, we need a valid IOControl structure.\n"
-                     " - filename prefix: " +
-                         filename_prefix + "\n");
-    pattern_str += e2str(avg_type) + "." + control.frequency_units + "_x" + std::to_string(control.frequency);
+    EKAT_REQUIRE_MSG(
+        control.output_enabled(),
+        "Error! When restarting an output stream, we need a valid IOControl structure.\n"
+        " - filename prefix: " +
+            filename_prefix + "\n");
+    pattern_str +=
+        e2str(avg_type) + "." + control.frequency_units + "_x" + std::to_string(control.frequency);
   }
   if (is_scream_standalone()) {
     pattern_str += ".np" + std::to_string(comm.size());
@@ -67,18 +71,19 @@ std::string find_filename_in_rpointer(const std::string &filename_prefix, const
     broadcast_string(content, comm, comm.root_rank());
 
     if (model_restart) {
-      EKAT_ERROR_MSG("Error! Restart requested, but no model restart file found in 'rpointer.atm'.\n"
-                     "   model restart filename prefix: " +
-                     filename_prefix +
-                     "\n"
-                     "   model restart filename pattern: " +
-                     pattern_str +
-                     "\n"
-                     "   run t0           : " +
-                     run_t0.to_string() +
-                     "\n"
-                     "   rpointer content:\n" +
-                     content + "\n\n");
+      EKAT_ERROR_MSG(
+          "Error! Restart requested, but no model restart file found in 'rpointer.atm'.\n"
+          "   model restart filename prefix: " +
+          filename_prefix +
+          "\n"
+          "   model restart filename pattern: " +
+          pattern_str +
+          "\n"
+          "   run t0           : " +
+          run_t0.to_string() +
+          "\n"
+          "   rpointer content:\n" +
+          content + "\n\n");
     } else {
       EKAT_ERROR_MSG(
           "Error! Restart requested, but no history restart file found in 'rpointer.atm'.\n"
@@ -103,39 +108,47 @@ std::string find_filename_in_rpointer(const std::string &filename_prefix, const
           "   rpointer content:\n" +
           content +
           "\n\n"
-          " Did you change output specs (avg type, freq, or freq units) across restart? If so, please, remember that "
+          " Did you change output specs (avg type, freq, or freq units) across restart? If so, "
+          "please, remember that "
           "it is not allowed.\n"
-          " It is also possible you are using a rhist file create before commit 6b7d441330d. That commit changed how "
+          " It is also possible you are using a rhist file create before commit 6b7d441330d. That "
+          "commit changed how "
           "rhist file names\n"
-          " are formed. In particular, we no longer use INSTANT.${REST_OPTION}_x${REST_N}, but we use the avg type, "
+          " are formed. In particular, we no longer use INSTANT.${REST_OPTION}_x${REST_N}, but we "
+          "use the avg type, "
           "and freq/freq_option\n"
-          " of the output stream (to avoid name clashes if 2 streams only differ for one of those). If you want to use "
+          " of the output stream (to avoid name clashes if 2 streams only differ for one of "
+          "those). If you want to use "
           "your rhist file,\n"
-          " please rename it, so that the avg-type, freq, and freq_option reflect those of the output stream.\n");
+          " please rename it, so that the avg-type, freq, and freq_option reflect those of the "
+          "output stream.\n");
     }
   }
 
   return filename;
 }
 
-void write_timestamp(const std::string &filename, const std::string &ts_name, const util::TimeStamp &ts,
-                     const bool write_nsteps) {
+void write_timestamp(const std::string &filename, const std::string &ts_name,
+                     const util::TimeStamp &ts, const bool write_nsteps) {
   scorpio::set_attribute(filename, "GLOBAL", ts_name, ts.to_string());
   if (write_nsteps) {
     scorpio::set_attribute(filename, "GLOBAL", ts_name + "_nsteps", ts.get_num_steps());
   }
 }
 
-util::TimeStamp read_timestamp(const std::string &filename, const std::string &ts_name, const bool read_nsteps) {
-  auto ts = util::str_to_time_stamp(scorpio::get_attribute<std::string>(filename, "GLOBAL", ts_name));
+util::TimeStamp read_timestamp(const std::string &filename, const std::string &ts_name,
+                               const bool read_nsteps) {
+  auto ts =
+      util::str_to_time_stamp(scorpio::get_attribute<std::string>(filename, "GLOBAL", ts_name));
   if (read_nsteps and scorpio::has_attribute(filename, "GLOBAL", ts_name + "_nsteps")) {
     ts.set_num_steps(scorpio::get_attribute<int>(filename, "GLOBAL", ts_name + "_nsteps"));
   }
   return ts;
 }
 
-std::shared_ptr<AtmosphereDiagnostic> create_diagnostic(const std::string &diag_field_name,
-                                                        const std::shared_ptr<const AbstractGrid> &grid) {
+std::shared_ptr<AtmosphereDiagnostic>
+create_diagnostic(const std::string &diag_field_name,
+                  const std::shared_ptr<const AbstractGrid> &grid) {
   // Note: use grouping (the (..) syntax), so you can later query the content
   //       of each group in the matches output var!
   // Note: use raw string syntax R"(<string>)" to avoid having to escape the \ character
@@ -197,7 +210,8 @@ std::shared_ptr<AtmosphereDiagnostic> create_diagnostic(const std::string &diag_
     params.set<std::string>("tendency_name", matches[1].str());
   } else if (std::regex_search(diag_field_name, matches, pot_temp)) {
     diag_name = "PotentialTemperature";
-    params.set<std::string>("temperature_kind", matches[1].str() != "" ? matches[1].str() : std::string("Tot"));
+    params.set<std::string>("temperature_kind",
+                            matches[1].str() != "" ? matches[1].str() : std::string("Tot"));
   } else if (std::regex_search(diag_field_name, matches, vert_layer)) {
     diag_name = "VerticalLayer";
     params.set<std::string>("diag_name", matches[1].str());
diff --git i/components/eamxx/src/share/io/eamxx_io_utils.hpp w/components/eamxx/src/share/io/eamxx_io_utils.hpp
index eb2aa5962f..d80dd3d74d 100644
--- i/components/eamxx/src/share/io/eamxx_io_utils.hpp
+++ w/components/eamxx/src/share/io/eamxx_io_utils.hpp
@@ -71,14 +71,15 @@ std::string find_filename_in_rpointer(const std::string &filename_prefix, const
                                       const IOControl &control     = {});
 
 // Shortcut to write/read to/from YYYYMMDD/HHMMSS attributes in the NC file
-void write_timestamp(const std::string &filename, const std::string &ts_name, const util::TimeStamp &ts,
-                     const bool write_nsteps = false);
-util::TimeStamp read_timestamp(const std::string &filename, const std::string &ts_name, const bool read_nsteps = false);
+void write_timestamp(const std::string &filename, const std::string &ts_name,
+                     const util::TimeStamp &ts, const bool write_nsteps = false);
+util::TimeStamp read_timestamp(const std::string &filename, const std::string &ts_name,
+                               const bool read_nsteps = false);
 
 // Create a diagnostic from a string representation of it.
 // E.g., create the diag to compute fieldX_at_500hPa.
-std::shared_ptr<AtmosphereDiagnostic> create_diagnostic(const std::string &diag_name,
-                                                        const std::shared_ptr<const AbstractGrid> &grid);
+std::shared_ptr<AtmosphereDiagnostic>
+create_diagnostic(const std::string &diag_name, const std::shared_ptr<const AbstractGrid> &grid);
 
 } // namespace scream
 #endif // SCREAM_IO_UTILS_HPP
diff --git i/components/eamxx/src/share/io/eamxx_output_manager.cpp w/components/eamxx/src/share/io/eamxx_output_manager.cpp
index 5dbb2c8871..d8b4aa3f1e 100644
--- i/components/eamxx/src/share/io/eamxx_output_manager.cpp
+++ w/components/eamxx/src/share/io/eamxx_output_manager.cpp
@@ -22,8 +22,10 @@ void OutputManager::initialize(const ekat::Comm &io_comm, const ekat::ParameterL
                                const util::TimeStamp &run_t0, const util::TimeStamp &case_t0,
                                const bool is_model_restart_output, const RunType run_type) {
   // Sanity checks
-  EKAT_REQUIRE_MSG(run_t0.is_valid(), "Error! Invalid run_t0 timestamp: " + run_t0.to_string() + "\n");
-  EKAT_REQUIRE_MSG(case_t0.is_valid(), "Error! Invalid case_t0 timestamp: " + case_t0.to_string() + "\n");
+  EKAT_REQUIRE_MSG(run_t0.is_valid(),
+                   "Error! Invalid run_t0 timestamp: " + run_t0.to_string() + "\n");
+  EKAT_REQUIRE_MSG(case_t0.is_valid(),
+                   "Error! Invalid case_t0 timestamp: " + case_t0.to_string() + "\n");
   EKAT_REQUIRE_MSG(case_t0 <= run_t0, "Error! The case_t0 timestamp must precede run_t0.\n"
                                       "   run_t0 : " +
                                           run_t0.to_string() +
@@ -43,7 +45,8 @@ void OutputManager::initialize(const ekat::Comm &io_comm, const ekat::ParameterL
   m_output_control.last_write_ts = m_run_t0;
 }
 
-void OutputManager::setup(const std::shared_ptr<fm_type> &field_mgr, const std::set<std::string> &grid_names) {
+void OutputManager::setup(const std::shared_ptr<fm_type> &field_mgr,
+                          const std::set<std::string> &grid_names) {
   // Read input parameters and setup internal data
   setup_internals(field_mgr, grid_names);
 
@@ -70,10 +73,11 @@ void OutputManager::setup(const std::shared_ptr<fm_type> &field_mgr, const std::
     //       and keep the "fields: Grid: Field Name:" structure
 
     // In this case, require a single grid passed here
-    EKAT_REQUIRE_MSG(grid_names.size() == 1,
-                     "Error! Output requested on multiple grids but no grid information exists in output params.\n");
+    EKAT_REQUIRE_MSG(grid_names.size() == 1, "Error! Output requested on multiple grids but no "
+                                             "grid information exists in output params.\n");
 
-    auto output = std::make_shared<output_type>(m_io_comm, m_params, field_mgr, *grid_names.begin());
+    auto output =
+        std::make_shared<output_type>(m_io_comm, m_params, field_mgr, *grid_names.begin());
     output->set_logger(m_atm_logger);
     m_output_streams.push_back(output);
   } else {
@@ -172,20 +176,23 @@ void OutputManager::setup(const std::shared_ptr<fm_type> &field_mgr, const std::
     auto hist_restart_filename_prefix = restart_pl.get("filename_prefix", m_filename_prefix);
 
     bool skip_restart_if_rhist_not_found = restart_pl.get("skip_restart_if_rhist_not_found", false);
-    auto rhist_file = find_filename_in_rpointer(hist_restart_filename_prefix, false, m_io_comm, m_run_t0,
-                                                skip_restart_if_rhist_not_found, m_avg_type, m_output_control);
+    auto rhist_file =
+        find_filename_in_rpointer(hist_restart_filename_prefix, false, m_io_comm, m_run_t0,
+                                  skip_restart_if_rhist_not_found, m_avg_type, m_output_control);
 
     if (rhist_file == "") {
       if (m_atm_logger) {
-        m_atm_logger->warn("[OutputManager::setup] The rhist file not found in rpointer.atm.\n"
-                           "  Continuing without restart, since 'skip_restart_if_rhist_not_found=true'.\n"
-                           "   - output yaml file for this stream: " +
-                           m_params.name() + "\n");
+        m_atm_logger->warn(
+            "[OutputManager::setup] The rhist file not found in rpointer.atm.\n"
+            "  Continuing without restart, since 'skip_restart_if_rhist_not_found=true'.\n"
+            "   - output yaml file for this stream: " +
+            m_params.name() + "\n");
       }
     } else {
 
       scorpio::register_file(rhist_file, scorpio::Read);
-      // From restart file, get the time of last write, as well as the current size of the avg sample
+      // From restart file, get the time of last write, as well as the current size of the avg
+      // sample
       m_output_control.last_write_ts = read_timestamp(rhist_file, "last_write", true);
       m_output_control.compute_next_write_ts();
       m_output_control.nsamples_since_last_write =
@@ -197,8 +204,10 @@ void OutputManager::setup(const std::shared_ptr<fm_type> &field_mgr, const std::
       }
 
       // If the type/freq of output needs restart data, we need to restart the streams
-      const bool output_every_step   = m_output_control.frequency_units == "nsteps" && m_output_control.frequency == 1;
-      const bool has_checkpoint_data = m_avg_type != OutputAvgType::Instant && not output_every_step;
+      const bool output_every_step =
+          m_output_control.frequency_units == "nsteps" && m_output_control.frequency == 1;
+      const bool has_checkpoint_data =
+          m_avg_type != OutputAvgType::Instant && not output_every_step;
       if (has_checkpoint_data && m_output_control.nsamples_since_last_write > 0) {
         for (auto stream : m_output_streams) {
           stream->restart(rhist_file);
@@ -210,21 +219,23 @@ void OutputManager::setup(const std::shared_ptr<fm_type> &field_mgr, const std::
       // rpointer.atm and set skip_restart_if_rhist_not_found=true
       // NOTE: we do not check that freq/freq_units/avg_type are not changed: since we used
       //       that info to find the correct rhist file, we already know that they match!
-      auto old_storage_type = scorpio::get_attribute<std::string>(rhist_file, "GLOBAL", "file_max_storage_type");
-      EKAT_REQUIRE_MSG(
-          old_storage_type == e2str(m_output_file_specs.storage.type),
-          "Error! Cannot change file storage type when performing history restart.\n"
-          "  - old file_max_storage_type: "
-              << old_storage_type
-              << "\n"
-                 "  - new file_max_storage_type: "
-              << e2str(m_output_file_specs.storage.type)
-              << "\n"
-                 "If you *really* want to change the file storage type, you need to force using a new file, setting\n"
-                 "  restart:\n"
-                 "    force_new_file: true\n");
+      auto old_storage_type =
+          scorpio::get_attribute<std::string>(rhist_file, "GLOBAL", "file_max_storage_type");
+      EKAT_REQUIRE_MSG(old_storage_type == e2str(m_output_file_specs.storage.type),
+                       "Error! Cannot change file storage type when performing history restart.\n"
+                       "  - old file_max_storage_type: "
+                           << old_storage_type
+                           << "\n"
+                              "  - new file_max_storage_type: "
+                           << e2str(m_output_file_specs.storage.type)
+                           << "\n"
+                              "If you *really* want to change the file storage type, you need to "
+                              "force using a new file, setting\n"
+                              "  restart:\n"
+                              "    force_new_file: true\n");
       if (old_storage_type == "num_snapshot") {
-        auto old_max_snaps = scorpio::get_attribute<int>(rhist_file, "GLOBAL", "max_snapshots_per_file");
+        auto old_max_snaps =
+            scorpio::get_attribute<int>(rhist_file, "GLOBAL", "max_snapshots_per_file");
         EKAT_REQUIRE_MSG(
             old_max_snaps == m_output_file_specs.storage.max_snapshots_in_file,
             "Error! Cannot change max snapshots per file when performing history restart.\n"
@@ -234,33 +245,37 @@ void OutputManager::setup(const std::shared_ptr<fm_type> &field_mgr, const std::
                    "  - new max snaps: "
                 << m_output_file_specs.storage.max_snapshots_in_file
                 << "\n"
-                   "If you *really* want to change the file capacity, you need to force using a new file, setting\n"
+                   "If you *really* want to change the file capacity, you need to force using a "
+                   "new file, setting\n"
                    "  restart:\n"
                    "    force_new_file: true\n");
       }
       std::string fp_precision = m_params.get<std::string>("floating_point_precision");
-      auto old_fp_precision    = scorpio::get_attribute<std::string>(rhist_file, "GLOBAL", "fp_precision");
-      EKAT_REQUIRE_MSG(old_fp_precision == fp_precision,
-                       "Error! Cannot change floating point precision when performing history restart.\n"
-                       "  - old fp precision: "
-                           << old_fp_precision
-                           << "\n"
-                              "  - new fp precision: "
-                           << fp_precision << "\n");
+      auto old_fp_precision =
+          scorpio::get_attribute<std::string>(rhist_file, "GLOBAL", "fp_precision");
+      EKAT_REQUIRE_MSG(
+          old_fp_precision == fp_precision,
+          "Error! Cannot change floating point precision when performing history restart.\n"
+          "  - old fp precision: "
+              << old_fp_precision
+              << "\n"
+                 "  - new fp precision: "
+              << fp_precision << "\n");
 
       // Check if the prev run wrote any output file (it may have not, if the restart was written
       // before the 1st output step). If there is a file, check if there's still room in it.
       const auto &last_output_filename =
           scorpio::get_attribute<std::string>(rhist_file, "GLOBAL", "last_output_filename");
-      m_resume_output_file = last_output_filename != "" and not restart_pl.get("force_new_file", true);
+      m_resume_output_file =
+          last_output_filename != "" and not restart_pl.get("force_new_file", true);
       if (m_resume_output_file) {
         m_output_file_specs.storage.num_snapshots_in_file =
             scorpio::get_attribute<int>(rhist_file, "GLOBAL", "last_output_file_num_snaps");
 
         if (m_output_file_specs.storage.snapshot_fits(m_output_control.next_write_ts)) {
           // The setup_file call will not register any new variable (the file is in Append mode,
-          // so all dims/vars must already be in the file). However, it will register decompositions,
-          // since those are a property of the run, not of the file.
+          // so all dims/vars must already be in the file). However, it will register
+          // decompositions, since those are a property of the run, not of the file.
           m_output_file_specs.filename = last_output_filename;
           m_output_file_specs.is_open  = true;
           setup_file(m_output_file_specs, m_output_control);
@@ -278,7 +293,8 @@ void OutputManager::setup(const std::shared_ptr<fm_type> &field_mgr, const std::
     // Init the left hand point of time_bnds based on run/case t0.
     m_time_bnds.resize(2);
     m_time_bnds[0] = m_run_t0.days_from(m_case_t0);
-  } else if (m_output_control.output_enabled() and m_run_type == RunType::Initial and not m_is_model_restart_output and
+  } else if (m_output_control.output_enabled() and m_run_type == RunType::Initial and
+             not m_is_model_restart_output and
              not m_params.sublist("output_control")
                      .get<bool>("skip_t0_output", false)) // This will be true for ERS/ERP tests
   {
@@ -286,7 +302,8 @@ void OutputManager::setup(const std::shared_ptr<fm_type> &field_mgr, const std::
     m_output_control.next_write_ts = m_run_t0;
     // This is in case some diags need to init the timestep. Their output may be meaningless
     // at t0 (e.g., if their input fields are not in the initial condition fields set,
-    // and have yet to be computed), but they may still require the start-of-step timestamp to be valid
+    // and have yet to be computed), but they may still require the start-of-step timestamp to be
+    // valid
     init_timestep(m_run_t0, 0);
     this->run(m_run_t0);
   }
@@ -317,7 +334,8 @@ void OutputManager::init_timestep(const util::TimeStamp &start_of_step, const Re
   m_output_control.set_dt(dt);
 
   if (m_run_type == RunType::Initial and is_first_step and m_avg_type == OutputAvgType::Instant and
-      m_output_file_specs.storage.type != NumSnaps and m_output_control.frequency_units == "nsteps") {
+      m_output_file_specs.storage.type != NumSnaps and
+      m_output_control.frequency_units == "nsteps") {
     // This is the 1st step of the whole run, and a very sneaky corner case. Bear with me.
     // When we call run, we also compute next_write_ts. Then, we use next_write_ts to see if the
     // next output step will fit in the currently open file, and, if not, close it right away.
@@ -325,22 +343,26 @@ void OutputManager::init_timestep(const util::TimeStamp &start_of_step, const Re
     // for freq=nsteps requires to know dt. But at t=case_t0, we did NOT have dt, which means we
     // computed next_write_ts=last_write_ts (in terms of date:time, the num_steps is correct).
     // This means that at that time we deemed that the next_write_ts definitely fit in the same
-    // file as last_write_ts (date/time are the same!), which may or may not be true for non NumSnaps
-    // storage. To fix this, we recompute next_write_ts here, and close the file if it doesn't.
+    // file as last_write_ts (date/time are the same!), which may or may not be true for non
+    // NumSnaps storage. To fix this, we recompute next_write_ts here, and close the file if it
+    // doesn't.
     m_output_control.compute_next_write_ts();
     close_or_flush_if_needed(m_output_file_specs, m_output_control);
   }
 
-  // Note: we need to "init" the timestep if we are going to do something this step, which means we either
+  // Note: we need to "init" the timestep if we are going to do something this step, which means we
+  // either
   //       have INST output and it's a write step, or we have AVG output.
-  const auto end_of_step    = start_of_step + dt;
-  const bool is_output_step = m_output_control.is_write_step(end_of_step) || end_of_step == m_case_t0;
+  const auto end_of_step = start_of_step + dt;
+  const bool is_output_step =
+      m_output_control.is_write_step(end_of_step) || end_of_step == m_case_t0;
   if (not is_output_step and m_avg_type == OutputAvgType::Instant) {
     return;
   }
 
   if (m_atm_logger) {
-    m_atm_logger->debug("[OutputManager::init_timestep] filename_prefix: " + m_filename_prefix + "\n");
+    m_atm_logger->debug("[OutputManager::init_timestep] filename_prefix: " + m_filename_prefix +
+                        "\n");
   }
 
   for (auto s : m_output_streams) {
@@ -355,18 +377,19 @@ void OutputManager::run(const util::TimeStamp &timestamp) {
   }
 
   // Ensure we did not go past the scheduled write time without hitting it
-  EKAT_REQUIRE_MSG((m_output_control.frequency_units == "nsteps"
-                        ? timestamp.get_num_steps() <= m_output_control.next_write_ts.get_num_steps()
-                        : timestamp <= m_output_control.next_write_ts),
-                   "Error! The input timestamp is past the next scheduled write timestamp.\n"
-                   "  - current time stamp   : " +
-                       timestamp.to_string() +
-                       "\n"
-                       "  - next write time stamp: " +
-                       m_output_control.next_write_ts.to_string() +
-                       "\n"
-                       "The most likely cause is an output frequency that is faster than the atm timestep.\n"
-                       "Try to increase 'frequency' and/or 'frequency_units' in your output yaml file.\n");
+  EKAT_REQUIRE_MSG(
+      (m_output_control.frequency_units == "nsteps"
+           ? timestamp.get_num_steps() <= m_output_control.next_write_ts.get_num_steps()
+           : timestamp <= m_output_control.next_write_ts),
+      "Error! The input timestamp is past the next scheduled write timestamp.\n"
+      "  - current time stamp   : " +
+          timestamp.to_string() +
+          "\n"
+          "  - next write time stamp: " +
+          m_output_control.next_write_ts.to_string() +
+          "\n"
+          "The most likely cause is an output frequency that is faster than the atm timestep.\n"
+          "Try to increase 'frequency' and/or 'frequency_units' in your output yaml file.\n");
 
   if (m_atm_logger) {
     m_atm_logger->debug("[OutputManager::run] filename_prefix: " + m_filename_prefix + "\n");
@@ -379,22 +402,25 @@ void OutputManager::run(const util::TimeStamp &timestamp) {
   start_timer("EAMxx::IO::" + m_params.name());
 
   // Check if this is a write step (and what kind)
-  // Note: a full checkpoint not only writes globals in the restart file, but also all the history variables.
-  //       Since we *always* write a history restart file, we can have a non-full checkpoint, if the average
-  //       type is Instant and/or the frequency is every step. A non-full checkpoint will simply write some
-  //       global attribute, such as the time of last write.
-  //       Also, notice that units="nhours" and freq=1 would still output evey step if dt=3600s. However,
-  //       it is somewhat hard to figure out if output happens every step, without having a dt to compare
-  //       against. Therefore, we simply assume that if units!=nsteps OR freq>1, then we don't output every
-  //       timestep. If, in fact, we are outputing every timestep, it's likely a small test, so it's not too
-  //       bad if we write out some extra data.
-  const bool output_every_step       = m_output_control.frequency_units == "nsteps" && m_output_control.frequency == 1;
-  const bool is_t0_output            = timestamp == m_case_t0;
-  const bool is_output_step          = m_output_control.is_write_step(timestamp) || is_t0_output;
-  const bool is_checkpoint_step      = m_checkpoint_control.is_write_step(timestamp) && not is_t0_output;
-  const bool has_checkpoint_data     = m_avg_type != OutputAvgType::Instant && not output_every_step;
-  const bool is_full_checkpoint_step = is_checkpoint_step && has_checkpoint_data && not is_output_step;
-  const bool is_write_step           = is_output_step || is_checkpoint_step;
+  // Note: a full checkpoint not only writes globals in the restart file, but also all the history
+  // variables.
+  //       Since we *always* write a history restart file, we can have a non-full checkpoint, if the
+  //       average type is Instant and/or the frequency is every step. A non-full checkpoint will
+  //       simply write some global attribute, such as the time of last write. Also, notice that
+  //       units="nhours" and freq=1 would still output evey step if dt=3600s. However, it is
+  //       somewhat hard to figure out if output happens every step, without having a dt to compare
+  //       against. Therefore, we simply assume that if units!=nsteps OR freq>1, then we don't
+  //       output every timestep. If, in fact, we are outputing every timestep, it's likely a small
+  //       test, so it's not too bad if we write out some extra data.
+  const bool output_every_step =
+      m_output_control.frequency_units == "nsteps" && m_output_control.frequency == 1;
+  const bool is_t0_output       = timestamp == m_case_t0;
+  const bool is_output_step     = m_output_control.is_write_step(timestamp) || is_t0_output;
+  const bool is_checkpoint_step = m_checkpoint_control.is_write_step(timestamp) && not is_t0_output;
+  const bool has_checkpoint_data = m_avg_type != OutputAvgType::Instant && not output_every_step;
+  const bool is_full_checkpoint_step =
+      is_checkpoint_step && has_checkpoint_data && not is_output_step;
+  const bool is_write_step = is_output_step || is_checkpoint_step;
 
   // Update counters
   ++m_output_control.nsamples_since_last_write;
@@ -448,10 +474,12 @@ void OutputManager::run(const util::TimeStamp &timestamp) {
             "Error! Cannot find rpointer.atm file to append history restart file in.\n"
             " Model restart output is supposed to be in charge of creating rpointer.atm.\n"
             " There are two possible causes:\n"
-            "   1. You have a 'checkpoint_control' list in your output stream, but no Scorpio::model_restart\n"
+            "   1. You have a 'checkpoint_control' list in your output stream, but no "
+            "Scorpio::model_restart\n"
             "      section in the input yaml file. This makes no sense, please correct.\n"
             "   2. The current implementation assumes that the model restart OutputManager runs\n"
-            "      *before* any other output stream (so it can nuke rpointer.atm if already existing).\n"
+            "      *before* any other output stream (so it can nuke rpointer.atm if already "
+            "existing).\n"
             "      If this has changed, we need to revisit this piece of the code.\n");
         rpointer.open("rpointer.atm", std::ofstream::app); // Open rpointer file and append to it
       }
@@ -482,15 +510,17 @@ void OutputManager::run(const util::TimeStamp &timestamp) {
 
   // Run the output streams
   start_timer(timer_root + "::run_output_streams");
-  const auto &fields_write_filename = is_output_step ? m_output_file_specs.filename : m_checkpoint_file_specs.filename;
+  const auto &fields_write_filename =
+      is_output_step ? m_output_file_specs.filename : m_checkpoint_file_specs.filename;
   for (auto &it : m_output_streams) {
-    // Note: filename only matters if is_output_step || is_full_checkpoint_step=true. In that case, it will definitely
-    // point to a valid file name.
+    // Note: filename only matters if is_output_step || is_full_checkpoint_step=true. In that case,
+    // it will definitely point to a valid file name.
     if (m_atm_logger) {
-      m_atm_logger->debug("[OutputManager]: writing fields from grid " + it->get_io_grid()->name() + "...\n");
+      m_atm_logger->debug("[OutputManager]: writing fields from grid " + it->get_io_grid()->name() +
+                          "...\n");
     }
-    it->run(fields_write_filename, is_output_step, is_full_checkpoint_step, m_output_control.nsamples_since_last_write,
-            is_t0_output);
+    it->run(fields_write_filename, is_output_step, is_full_checkpoint_step,
+            m_output_control.nsamples_since_last_write, is_t0_output);
   }
   stop_timer(timer_root + "::run_output_streams");
 
@@ -523,18 +553,23 @@ void OutputManager::run(const util::TimeStamp &timestamp) {
         if (filespecs.ftype == FileType::HistoryRestart) {
           // Update the date of last write and sample size
           write_timestamp(filespecs.filename, "last_write", m_output_control.last_write_ts, true);
-          scorpio::set_attribute(filespecs.filename, "GLOBAL", "last_output_filename", m_output_file_specs.filename);
+          scorpio::set_attribute(filespecs.filename, "GLOBAL", "last_output_filename",
+                                 m_output_file_specs.filename);
           scorpio::set_attribute(filespecs.filename, "GLOBAL", "num_snapshots_since_last_write",
                                  m_output_control.nsamples_since_last_write);
           scorpio::set_attribute(filespecs.filename, "GLOBAL", "last_output_file_num_snaps",
                                  m_output_file_specs.storage.num_snapshots_in_file);
         }
-        // Write these in both output and rhist file. The former, b/c we need these info when we postprocess
-        // output, and the latter b/c we want to make sure these params don't change across restarts
+        // Write these in both output and rhist file. The former, b/c we need these info when we
+        // postprocess output, and the latter b/c we want to make sure these params don't change
+        // across restarts
         set_attribute(filespecs.filename, "GLOBAL", "averaging_type", e2str(m_avg_type));
-        set_attribute(filespecs.filename, "GLOBAL", "averaging_frequency_units", m_output_control.frequency_units);
-        set_attribute(filespecs.filename, "GLOBAL", "averaging_frequency", m_output_control.frequency);
-        set_attribute(filespecs.filename, "GLOBAL", "file_max_storage_type", e2str(m_output_file_specs.storage.type));
+        set_attribute(filespecs.filename, "GLOBAL", "averaging_frequency_units",
+                      m_output_control.frequency_units);
+        set_attribute(filespecs.filename, "GLOBAL", "averaging_frequency",
+                      m_output_control.frequency);
+        set_attribute(filespecs.filename, "GLOBAL", "file_max_storage_type",
+                      e2str(m_output_file_specs.storage.type));
         if (m_output_file_specs.storage.type == NumSnaps) {
           set_attribute(filespecs.filename, "GLOBAL", "max_snapshots_per_file",
                         m_output_file_specs.storage.max_snapshots_in_file);
@@ -573,7 +608,8 @@ void OutputManager::run(const util::TimeStamp &timestamp) {
       // NOTE: for checkpoint files, unless we write restart data, we did not update time,
       //       which means we cannot write any variable (the check var.num_records==time.length
       //       would fail)
-      if (m_time_bnds.size() > 0 and (filespecs.ftype != FileType::HistoryRestart or is_full_checkpoint_step)) {
+      if (m_time_bnds.size() > 0 and
+          (filespecs.ftype != FileType::HistoryRestart or is_full_checkpoint_step)) {
         scorpio::write_var(filespecs.filename, "time_bnds", m_time_bnds.data());
       }
 
@@ -644,7 +680,8 @@ long long OutputManager::res_dep_memory_footprint() const {
   return mf;
 }
 
-std::string OutputManager::compute_filename(const IOFileSpecs &file_specs, const util::TimeStamp &timestamp) const {
+std::string OutputManager::compute_filename(const IOFileSpecs &file_specs,
+                                            const util::TimeStamp &timestamp) const {
   auto filename       = m_filename_prefix + file_specs.suffix();
   const auto &control = m_output_control;
 
@@ -703,9 +740,9 @@ void OutputManager::setup_internals(const std::shared_ptr<fm_type> &field_mgr,
       // There may be no RESTART group on this grid
       if (field_mgr->has_group("RESTART", gname)) {
         auto restart_group = field_mgr->get_group_info("RESTART", gname);
-        EKAT_REQUIRE_MSG(
-            not fields_pl.isParameter(gname),
-            "Error! For restart output, don't specify the fields names. We will create this info internally.\n");
+        EKAT_REQUIRE_MSG(not fields_pl.isParameter(gname),
+                         "Error! For restart output, don't specify the fields names. We will "
+                         "create this info internally.\n");
         for (const auto &n : restart_group.m_fields_names) {
           fnames.push_back(n);
         }
@@ -758,9 +795,9 @@ void OutputManager::setup_internals(const std::shared_ptr<fm_type> &field_mgr,
   }
 
   // Output control
-  EKAT_REQUIRE_MSG(m_params.isSublist("output_control"), "Error! The output control YAML file for " +
-                                                             m_filename_prefix +
-                                                             " is missing the sublist 'output_control'");
+  EKAT_REQUIRE_MSG(m_params.isSublist("output_control"),
+                   "Error! The output control YAML file for " + m_filename_prefix +
+                       " is missing the sublist 'output_control'");
   auto &out_control_pl = m_params.sublist("output_control");
   m_output_control.set_frequency_units(out_control_pl.get<std::string>("frequency_units"));
 
@@ -769,13 +806,14 @@ void OutputManager::setup_internals(const std::shared_ptr<fm_type> &field_mgr,
     return;
   }
   m_output_control.frequency = out_control_pl.get<int>("frequency");
-  EKAT_REQUIRE_MSG(m_output_control.frequency > 0, "Error! Invalid frequency (" +
-                                                       std::to_string(m_output_control.frequency) +
-                                                       ") in Output Control. Please, use positive number.\n");
+  EKAT_REQUIRE_MSG(m_output_control.frequency > 0,
+                   "Error! Invalid frequency (" + std::to_string(m_output_control.frequency) +
+                       ") in Output Control. Please, use positive number.\n");
 
   // File specs
-  m_save_grid_data          = out_control_pl.get("save_grid_data", !m_is_model_restart_output);
-  m_output_file_specs.ftype = m_is_model_restart_output ? FileType::ModelRestart : FileType::ModelOutput;
+  m_save_grid_data = out_control_pl.get("save_grid_data", !m_is_model_restart_output);
+  m_output_file_specs.ftype =
+      m_is_model_restart_output ? FileType::ModelRestart : FileType::ModelOutput;
 
   if (m_params.isSublist("checkpoint_control")) {
     auto &pl = m_params.sublist("checkpoint_control");
@@ -783,9 +821,10 @@ void OutputManager::setup_internals(const std::shared_ptr<fm_type> &field_mgr,
 
     if (m_checkpoint_control.output_enabled()) {
       m_checkpoint_control.frequency = pl.get<int>("frequency");
-      EKAT_REQUIRE_MSG(m_output_control.frequency > 0, "Error! Invalid frequency (" +
-                                                           std::to_string(m_checkpoint_control.frequency) +
-                                                           ") in checkpoint_control. Please, use positive number.\n");
+      EKAT_REQUIRE_MSG(m_output_control.frequency > 0,
+                       "Error! Invalid frequency (" +
+                           std::to_string(m_checkpoint_control.frequency) +
+                           ") in checkpoint_control. Please, use positive number.\n");
 
       m_checkpoint_control.last_write_ts = m_run_t0;
       m_checkpoint_control.compute_next_write_ts();
@@ -808,7 +847,8 @@ void OutputManager::setup_internals(const std::shared_ptr<fm_type> &field_mgr,
 void OutputManager::setup_file(IOFileSpecs &filespecs, const IOControl &control) {
   const bool is_checkpoint_step = &control == &m_checkpoint_control;
 
-  std::string fp_precision = is_checkpoint_step ? "real" : m_params.get<std::string>("floating_point_precision");
+  std::string fp_precision =
+      is_checkpoint_step ? "real" : m_params.get<std::string>("floating_point_precision");
 
   const auto &filename = filespecs.filename;
   // Register new netCDF file for output. Check if we need to append to an existing file
@@ -836,7 +876,8 @@ void OutputManager::setup_file(IOFileSpecs &filespecs, const IOControl &control)
     scorpio::redef(filename);
   } else {
     // Register time (and possibly time_bnds) var(s)
-    auto time_units = "days since " + m_case_t0.get_date_string() + " " + m_case_t0.get_time_string();
+    auto time_units =
+        "days since " + m_case_t0.get_date_string() + " " + m_case_t0.get_time_string();
     scorpio::define_time(filename, time_units, "time");
 
     scorpio::define_var(filename, "time", time_units, {}, "double", "double", true);
@@ -852,7 +893,8 @@ void OutputManager::setup_file(IOFileSpecs &filespecs, const IOControl &control)
       scorpio::define_var(filename, "time_bnds", time_units, {"dim2"}, "double", "double", true);
 
       // Make it clear how the time_bnds should be interpreted
-      scorpio::set_attribute<std::string>(filename, "time_bnds", "note", "right endpoint accumulation");
+      scorpio::set_attribute<std::string>(filename, "time_bnds", "note",
+                                          "right endpoint accumulation");
 
       // I'm not sure what's the point of this, but CF conventions seem to require it
       scorpio::set_attribute<std::string>(filename, "time", "bounds", "time_bnds");
@@ -861,7 +903,8 @@ void OutputManager::setup_file(IOFileSpecs &filespecs, const IOControl &control)
     write_timestamp(filename, "case_t0", m_case_t0);
     write_timestamp(filename, "run_t0", m_run_t0);
     scorpio::set_attribute(filename, "GLOBAL", "averaging_type", e2str(m_avg_type));
-    scorpio::set_attribute(filename, "GLOBAL", "averaging_frequency_units", m_output_control.frequency_units);
+    scorpio::set_attribute(filename, "GLOBAL", "averaging_frequency_units",
+                           m_output_control.frequency_units);
     scorpio::set_attribute(filename, "GLOBAL", "averaging_frequency", m_output_control.frequency);
     scorpio::set_attribute(filespecs.filename, "GLOBAL", "file_max_storage_type",
                            e2str(m_output_file_specs.storage.type));
@@ -930,7 +973,8 @@ void OutputManager::set_file_header(const IOFileSpecs &file_specs) {
   set_str_att("Conventions", "CF-1.8");
   set_str_att("product", e2str(file_specs.ftype));
 }
-void OutputManager::close_or_flush_if_needed(IOFileSpecs &file_specs, const IOControl &control) const {
+void OutputManager::close_or_flush_if_needed(IOFileSpecs &file_specs,
+                                             const IOControl &control) const {
   if (not file_specs.storage.snapshot_fits(control.next_write_ts)) {
     scorpio::release_file(file_specs.filename);
     file_specs.close();
@@ -962,12 +1006,13 @@ void OutputManager::push_to_logger() {
   m_atm_logger->info("         Is Restart File ?: " + bool_to_string(m_is_model_restart_output));
   m_atm_logger->info("                 Run type : " + rt_to_string(m_run_type));
   m_atm_logger->info("            averaging_type: " + e2str(m_avg_type));
-  m_atm_logger->info("          Output Frequency: " + std::to_string(m_output_control.frequency) + " " +
-                     m_output_control.frequency_units);
+  m_atm_logger->info("          Output Frequency: " + std::to_string(m_output_control.frequency) +
+                     " " + m_output_control.frequency_units);
   switch (m_output_file_specs.storage.type) {
   case NumSnaps: {
     auto ms = m_output_file_specs.storage.max_snapshots_in_file;
-    m_atm_logger->info("             File Capacity: " + (ms > 0 ? std::to_string(ms) + "snapshots" : "UNLIMITED"));
+    m_atm_logger->info("             File Capacity: " +
+                       (ms > 0 ? std::to_string(ms) + "snapshots" : "UNLIMITED"));
     break;
   }
   case Monthly:
diff --git i/components/eamxx/src/share/io/eamxx_output_manager.hpp w/components/eamxx/src/share/io/eamxx_output_manager.hpp
index e017928f79..54781696e5 100644
--- i/components/eamxx/src/share/io/eamxx_output_manager.hpp
+++ w/components/eamxx/src/share/io/eamxx_output_manager.hpp
@@ -75,17 +75,19 @@ public:
   //  - case_t0: the timestamp of the start of the overall simulation (precedes run_r0 for
   //             a restarted simulation. Restart logic is triggered *only* if case_t0<run_t0.
   //  - is_model_restart_output: whether this output stream is to write a model restart file
-  void initialize(const ekat::Comm &io_comm, const ekat::ParameterList &params, const util::TimeStamp &run_t0,
-                  const util::TimeStamp &case_t0, const bool is_model_restart_output, const RunType run_type);
+  void initialize(const ekat::Comm &io_comm, const ekat::ParameterList &params,
+                  const util::TimeStamp &run_t0, const util::TimeStamp &case_t0,
+                  const bool is_model_restart_output, const RunType run_type);
 
   // This overloads are to make certain unit tests easier
-  void initialize(const ekat::Comm &io_comm, const ekat::ParameterList &params, const util::TimeStamp &run_t0,
-                  const util::TimeStamp &case_t0, const bool is_model_restart_output) {
+  void initialize(const ekat::Comm &io_comm, const ekat::ParameterList &params,
+                  const util::TimeStamp &run_t0, const util::TimeStamp &case_t0,
+                  const bool is_model_restart_output) {
     auto run_type = case_t0 < run_t0 ? RunType::Restart : RunType::Initial;
     initialize(io_comm, params, run_t0, case_t0, is_model_restart_output, run_type);
   }
-  void initialize(const ekat::Comm &io_comm, const ekat::ParameterList &params, const util::TimeStamp &run_t0,
-                  const bool is_model_restart_output) {
+  void initialize(const ekat::Comm &io_comm, const ekat::ParameterList &params,
+                  const util::TimeStamp &run_t0, const bool is_model_restart_output) {
     initialize(io_comm, params, run_t0, run_t0, is_model_restart_output, RunType::Initial);
   }
 
@@ -95,7 +97,9 @@ public:
   //  - grid_names: grid names used for output
   void setup(const std::shared_ptr<fm_type> &field_mgr, const std::set<std::string> &grid_names);
 
-  void set_logger(const std::shared_ptr<ekat::logger::LoggerBase> &atm_logger) { m_atm_logger = atm_logger; }
+  void set_logger(const std::shared_ptr<ekat::logger::LoggerBase> &atm_logger) {
+    m_atm_logger = atm_logger;
+  }
   void add_global(const std::string &name, const ekat::any &global);
 
   void init_timestep(const util::TimeStamp &start_of_step, const Real dt);
@@ -111,13 +115,15 @@ public:
   const IOFileSpecs &output_file_specs() const { return m_output_file_specs; }
 
 protected:
-  std::string compute_filename(const IOFileSpecs &file_specs, const util::TimeStamp &timestamp) const;
+  std::string compute_filename(const IOFileSpecs &file_specs,
+                               const util::TimeStamp &timestamp) const;
 
   void set_file_header(const IOFileSpecs &file_specs);
 
   // Set internal class variables and processes the field_mgr for restart fields
   // to add to the parameter list for a model restart managers.
-  void setup_internals(const std::shared_ptr<fm_type> &field_mgr, const std::set<std::string> &grid_names);
+  void setup_internals(const std::shared_ptr<fm_type> &field_mgr,
+                       const std::set<std::string> &grid_names);
 
   void setup_file(IOFileSpecs &filespecs, const IOControl &control);
 
diff --git i/components/eamxx/src/share/io/eamxx_scorpio_interface.cpp w/components/eamxx/src/share/io/eamxx_scorpio_interface.cpp
index 6fa0b6c148..a8054a6e88 100644
--- i/components/eamxx/src/share/io/eamxx_scorpio_interface.cpp
+++ w/components/eamxx/src/share/io/eamxx_scorpio_interface.cpp
@@ -61,52 +61,56 @@ template <typename S, typename D> void copy_data(const S *src, D *dst, int n) {
 }
 
 // Utility for common IO operation failure
-void check_scorpio_noerr(const int err, const std::string &func_name, const std::string &pioc_func_name) {
-  EKAT_REQUIRE_MSG(err == PIO_NOERR, "Error! Something went wrong while performing a pio operation.\n"
-                                     " - pio error code: " +
-                                         std::to_string(err) +
-                                         "\n"
-                                         " - from interface function: scorpio::" +
-                                         func_name +
-                                         "\n"
-                                         " - calling PIOc function: PIOc_" +
-                                         pioc_func_name + "\n");
+void check_scorpio_noerr(const int err, const std::string &func_name,
+                         const std::string &pioc_func_name) {
+  EKAT_REQUIRE_MSG(err == PIO_NOERR,
+                   "Error! Something went wrong while performing a pio operation.\n"
+                   " - pio error code: " +
+                       std::to_string(err) +
+                       "\n"
+                       " - from interface function: scorpio::" +
+                       func_name +
+                       "\n"
+                       " - calling PIOc function: PIOc_" +
+                       pioc_func_name + "\n");
 }
 
 void check_scorpio_noerr(const int err, const std::string &filename, const std::string &func_name,
                          const std::string &pioc_func_name) {
-  EKAT_REQUIRE_MSG(err == PIO_NOERR, "Error! Something went wrong while performing a pio operation.\n"
-                                     " - pio error code: " +
-                                         std::to_string(err) +
-                                         "\n"
-                                         " - filename: " +
-                                         filename +
-                                         "\n"
-                                         " - from interface function: scorpio::" +
-                                         func_name +
-                                         "\n"
-                                         " - calling PIOc function: " +
-                                         pioc_func_name + "\n");
+  EKAT_REQUIRE_MSG(err == PIO_NOERR,
+                   "Error! Something went wrong while performing a pio operation.\n"
+                   " - pio error code: " +
+                       std::to_string(err) +
+                       "\n"
+                       " - filename: " +
+                       filename +
+                       "\n"
+                       " - from interface function: scorpio::" +
+                       func_name +
+                       "\n"
+                       " - calling PIOc function: " +
+                       pioc_func_name + "\n");
 }
 
 void check_scorpio_noerr(const int err, const std::string &filename, const std::string &entity_type,
                          const std::string &entity_name, const std::string &func_name,
                          const std::string &pioc_func_name) {
-  EKAT_REQUIRE_MSG(err == PIO_NOERR, "Error! Something went wrong while performing a pio operation.\n"
-                                     " - pio error code: " +
-                                         std::to_string(err) +
-                                         "\n"
-                                         " - filename: " +
-                                         filename +
-                                         "\n"
-                                         " - " +
-                                         entity_type + ": " + entity_name +
-                                         "\n"
-                                         " - from interface function: scorpio::" +
-                                         func_name +
-                                         "\n"
-                                         " - calling PIOc function: " +
-                                         pioc_func_name + "\n");
+  EKAT_REQUIRE_MSG(err == PIO_NOERR,
+                   "Error! Something went wrong while performing a pio operation.\n"
+                   " - pio error code: " +
+                       std::to_string(err) +
+                       "\n"
+                       " - filename: " +
+                       filename +
+                       "\n"
+                       " - " +
+                       entity_type + ": " + entity_name +
+                       "\n"
+                       " - from interface function: scorpio::" +
+                       func_name +
+                       "\n"
+                       " - calling PIOc function: " +
+                       pioc_func_name + "\n");
 }
 
 // Return name of a shared ptr to PIO entity (to use inside ekat::join)
@@ -162,7 +166,9 @@ template <typename T> int nctype() {
 }
 
 template <typename T> const void *ncdata(const T &v) { return reinterpret_cast<const void *>(&v); }
-template <> const void *ncdata(const std::string &v) { return reinterpret_cast<const void *>(v.data()); }
+template <> const void *ncdata(const std::string &v) {
+  return reinterpret_cast<const void *>(v.data());
+}
 
 template <typename T> PIO_Offset nclen(const T &v) { return 1; }
 template <> PIO_Offset nclen(const std::string &v) { return v.size(); }
@@ -262,51 +268,56 @@ struct PeekFile {
 PIOFile &get_file(const std::string &filename, const std::string &context) {
   auto &s = ScorpioSession::instance();
 
-  EKAT_REQUIRE_MSG(s.files.count(filename) == 1, "Error! Could not retrieve the file. File not open.\n"
-                                                 " - filename: " +
-                                                     filename +
-                                                     "\n"
-                                                     "Context:\n"
-                                                     " " +
-                                                     context + "\n");
+  EKAT_REQUIRE_MSG(s.files.count(filename) == 1,
+                   "Error! Could not retrieve the file. File not open.\n"
+                   " - filename: " +
+                       filename +
+                       "\n"
+                       "Context:\n"
+                       " " +
+                       context + "\n");
 
   return s.files.at(filename);
 }
 
-PIODim &get_dim(const std::string &filename, const std::string &dimname, const std::string &context) {
+PIODim &get_dim(const std::string &filename, const std::string &dimname,
+                const std::string &context) {
   const auto &f = get_file(filename, context);
-  EKAT_REQUIRE_MSG(f.dims.count(dimname) == 1, "Error! Could not retrieve dimension. Dimension not found.\n"
-                                               " - filename: " +
-                                                   filename +
-                                                   "\n"
-                                                   " - dimname : " +
-                                                   dimname +
-                                                   "\n"
-                                                   " - dims on file: " +
-                                                   print_map_keys(f.dims) +
-                                                   "\n"
-                                                   "Context:\n"
-                                                   " " +
-                                                   context + "\n");
+  EKAT_REQUIRE_MSG(f.dims.count(dimname) == 1,
+                   "Error! Could not retrieve dimension. Dimension not found.\n"
+                   " - filename: " +
+                       filename +
+                       "\n"
+                       " - dimname : " +
+                       dimname +
+                       "\n"
+                       " - dims on file: " +
+                       print_map_keys(f.dims) +
+                       "\n"
+                       "Context:\n"
+                       " " +
+                       context + "\n");
 
   return *f.dims.at(dimname);
 }
 
-PIOVar &get_var(const std::string &filename, const std::string &varname, const std::string &context) {
+PIOVar &get_var(const std::string &filename, const std::string &varname,
+                const std::string &context) {
   const auto &f = get_file(filename, context);
-  EKAT_REQUIRE_MSG(f.vars.count(varname) == 1, "Error! Could not retrieve variable. Variable not found.\n"
-                                               " - filename: " +
-                                                   filename +
-                                                   "\n"
-                                                   " - varname : " +
-                                                   varname +
-                                                   "\n"
-                                                   " - vars on file : " +
-                                                   print_map_keys(f.vars) +
-                                                   "\n"
-                                                   "Context:\n"
-                                                   " " +
-                                                   context + "\n");
+  EKAT_REQUIRE_MSG(f.vars.count(varname) == 1,
+                   "Error! Could not retrieve variable. Variable not found.\n"
+                   " - filename: " +
+                       filename +
+                       "\n"
+                       " - varname : " +
+                       varname +
+                       "\n"
+                       " - vars on file : " +
+                       print_map_keys(f.vars) +
+                       "\n"
+                       "Context:\n"
+                       " " +
+                       context + "\n");
 
   return *f.vars.at(varname);
 }
@@ -341,7 +352,8 @@ void init_subsystem(const ekat::Comm &comm, const int atm_id) {
 #error "Standalone EAMxx requires either PNETCDF or NETCDF iotype to be available in Scorpio"
 #endif
 
-  auto err = PIOc_Init_Intracomm(comm.mpi_comm(), comm.size(), stride, base, s.pio_rearranger, &s.pio_sysid);
+  auto err = PIOc_Init_Intracomm(comm.mpi_comm(), comm.size(), stride, base, s.pio_rearranger,
+                                 &s.pio_sysid);
   check_scorpio_noerr(err, "init_subsystem", "Init_Intracomm");
 
   // Unused in standalone mode
@@ -363,18 +375,20 @@ void finalize_subsystem() {
   EKAT_REQUIRE_MSG(s.pio_sysid != -1, "Error! PIO subsystem was already finalized.\n");
 
   for (auto &it : s.files) {
-    EKAT_REQUIRE_MSG(it.second.num_customers == 0,
-                     "Error! ScorpioSession::finalize called, but a file is still in use elsewhere.\n"
-                     " - filename: " +
-                         it.first + "\n");
+    EKAT_REQUIRE_MSG(
+        it.second.num_customers == 0,
+        "Error! ScorpioSession::finalize called, but a file is still in use elsewhere.\n"
+        " - filename: " +
+            it.first + "\n");
   }
   s.files.clear();
 
   for (auto &it : s.decomps) {
-    EKAT_REQUIRE_MSG(it.second.use_count() == 1,
-                     "Error! ScorpioSession::finalize called, but a decomp is still stored elsewhere.\n"
-                     " - decomp name: " +
-                         it.first + "\n");
+    EKAT_REQUIRE_MSG(
+        it.second.use_count() == 1,
+        "Error! ScorpioSession::finalize called, but a decomp is still stored elsewhere.\n"
+        " - decomp name: " +
+            it.first + "\n");
 
     int err = PIOc_freedecomp(s.pio_sysid, it.second->ncid);
     check_scorpio_noerr(err, "finalize_subsystem", "freedecomp");
@@ -397,24 +411,26 @@ void finalize_subsystem() {
 void register_file(const std::string &filename, const FileMode mode, const IOType iotype) {
   auto &s = ScorpioSession::instance();
   auto &f = s.files[filename];
-  EKAT_REQUIRE_MSG(f.mode == Unset || f.mode == mode, "Error! File was already opened with a different mode.\n"
-                                                      " - filename: " +
-                                                          filename +
-                                                          "\n"
-                                                          " - old mode: " +
-                                                          e2str(f.mode) +
-                                                          "\n"
-                                                          " - new mode: " +
-                                                          e2str(mode) + "\n");
-  EKAT_REQUIRE_MSG(f.mode == Unset || f.iotype == iotype, "Error! File was already opened with a different iotype.\n"
-                                                          " - filename: " +
-                                                              filename +
-                                                              "\n"
-                                                              " - old type: " +
-                                                              iotype2str(f.iotype) +
-                                                              "\n"
-                                                              " - new type: " +
-                                                              iotype2str(iotype) + "\n");
+  EKAT_REQUIRE_MSG(f.mode == Unset || f.mode == mode,
+                   "Error! File was already opened with a different mode.\n"
+                   " - filename: " +
+                       filename +
+                       "\n"
+                       " - old mode: " +
+                       e2str(f.mode) +
+                       "\n"
+                       " - new mode: " +
+                       e2str(mode) + "\n");
+  EKAT_REQUIRE_MSG(f.mode == Unset || f.iotype == iotype,
+                   "Error! File was already opened with a different iotype.\n"
+                   " - filename: " +
+                       filename +
+                       "\n"
+                       " - old type: " +
+                       iotype2str(f.iotype) +
+                       "\n"
+                       " - new type: " +
+                       iotype2str(iotype) + "\n");
 
   if (f.mode == Unset) {
     // First time we ask for this file. Call PIO open routine(s)
@@ -571,9 +587,10 @@ void flush_file(const std::string &filename) {
 void redef(const std::string &filename) {
   auto &f = impl::get_file(filename, "scorpio::redef");
 
-  EKAT_REQUIRE_MSG(f.mode & Write, "Error! Could not call redef on the input file. File is read-only.\n"
-                                   " - filename: " +
-                                       filename + "\n");
+  EKAT_REQUIRE_MSG(f.mode & Write,
+                   "Error! Could not call redef on the input file. File is read-only.\n"
+                   " - filename: " +
+                       filename + "\n");
 
   if (f.enddef) {
     int err = PIOc_redef(f.ncid);
@@ -618,12 +635,13 @@ void define_dim(const std::string &filename, const std::string &dimname, const i
   bool unlimited = length == 0;
 
   if (dim == nullptr) {
-    EKAT_REQUIRE_MSG(f.mode != Append, "Error! Cannot add a new dim when the file is open in append mode.\n"
-                                       " - filename: " +
-                                           filename +
-                                           "\n"
-                                           " - dimname : " +
-                                           dimname + "\n");
+    EKAT_REQUIRE_MSG(f.mode != Append,
+                     "Error! Cannot add a new dim when the file is open in append mode.\n"
+                     " - filename: " +
+                         filename +
+                         "\n"
+                         " - dimname : " +
+                         dimname + "\n");
     // Create new dimension
     dim            = std::make_shared<PIODim>();
     dim->name      = dimname;
@@ -636,18 +654,19 @@ void define_dim(const std::string &filename, const std::string &dimname, const i
     check_scorpio_noerr(err, f.name, "dimension", dimname, "define_dim", "def_dim");
   } else {
     // Already defined. Check that the dim specs are the same.
-    EKAT_REQUIRE_MSG(unlimited == dim->unlimited, "Error! Redefining dimension with different unlimited flag.\n"
-                                                  " - filename: " +
-                                                      filename +
-                                                      "\n"
-                                                      " - dimname : " +
-                                                      dimname +
-                                                      "\n"
-                                                      " - old unlimited:" +
-                                                      (dim->unlimited ? "yes" : "no") +
-                                                      "\n"
-                                                      " - new unlimited:" +
-                                                      (unlimited ? "yes" : "no") + "\n");
+    EKAT_REQUIRE_MSG(unlimited == dim->unlimited,
+                     "Error! Redefining dimension with different unlimited flag.\n"
+                     " - filename: " +
+                         filename +
+                         "\n"
+                         " - dimname : " +
+                         dimname +
+                         "\n"
+                         " - old unlimited:" +
+                         (dim->unlimited ? "yes" : "no") +
+                         "\n"
+                         " - new unlimited:" +
+                         (unlimited ? "yes" : "no") + "\n");
 
     EKAT_REQUIRE_MSG(unlimited || length == dim->length,
                      "Error! Redefining dimension with a different (local) length.\n"
@@ -699,13 +718,14 @@ int get_dimlen_local(const std::string &filename, const std::string &dimname) {
   // If file wasn't open, open it on the fly. See comment in PeekFile class above.
   impl::PeekFile pf(filename);
 
-  EKAT_REQUIRE_MSG(has_dim(filename, dimname),
-                   "Error! Could not inquire dimension local length. The dimension is not in the file.\n"
-                   " - filename: " +
-                       filename +
-                       "\n"
-                       " - dimname : " +
-                       dimname + "\n");
+  EKAT_REQUIRE_MSG(
+      has_dim(filename, dimname),
+      "Error! Could not inquire dimension local length. The dimension is not in the file.\n"
+      " - filename: " +
+          filename +
+          "\n"
+          " - dimname : " +
+          dimname + "\n");
 
   const auto &dim = pf.file->dims.at(dimname);
   return dim->offsets == nullptr ? dim->length : dim->offsets->size();
@@ -719,10 +739,11 @@ bool has_time_dim(const std::string &filename) {
 }
 
 int get_time_len(const std::string &filename) {
-  EKAT_REQUIRE_MSG(has_time_dim(filename),
-                   "Error! Could not inquire time dimension length. The time dimension is not in the file.\n"
-                   " - filename: " +
-                       filename + "\n");
+  EKAT_REQUIRE_MSG(
+      has_time_dim(filename),
+      "Error! Could not inquire time dimension length. The time dimension is not in the file.\n"
+      " - filename: " +
+          filename + "\n");
 
   // If file wasn't open, open it on the fly. See comment in PeekFile class above.
   impl::PeekFile pf(filename);
@@ -734,19 +755,21 @@ std::string get_time_name(const std::string &filename) {
   // If file wasn't open, open it on the fly. See comment in PeekFile class above.
   impl::PeekFile pf(filename);
 
-  EKAT_REQUIRE_MSG(pf.file->time_dim != nullptr,
-                   "Error! Could not inquire time dimension name. The time dimension is not in the file.\n"
-                   " - filename: " +
-                       filename + "\n");
+  EKAT_REQUIRE_MSG(
+      pf.file->time_dim != nullptr,
+      "Error! Could not inquire time dimension name. The time dimension is not in the file.\n"
+      " - filename: " +
+          filename + "\n");
 
   return pf.file->time_dim->name;
 }
 
 void reset_time_dim_len(const std::string &filename, const int new_length) {
-  EKAT_REQUIRE_MSG(has_time_dim(filename),
-                   "Error! Could not reset time dimension length. The time dimension is not in the file.\n"
-                   " - filename: " +
-                       filename + "\n");
+  EKAT_REQUIRE_MSG(
+      has_time_dim(filename),
+      "Error! Could not reset time dimension length. The time dimension is not in the file.\n"
+      " - filename: " +
+          filename + "\n");
 
   auto &f = impl::get_file(filename, "scorpio::reset_time_dim_len");
 
@@ -795,7 +818,8 @@ void set_var_decomp(PIOVar &var, const std::string &filename) {
                          var.dims[i]->name + "\n");
   }
   EKAT_REQUIRE_MSG(var.dims[0]->offsets != nullptr,
-                   "Error! Calling set_var_decomp, but the var first dimension does not appear to be decomposed.\n"
+                   "Error! Calling set_var_decomp, but the var first dimension does not appear to "
+                   "be decomposed.\n"
                    " - filename: " +
                        filename +
                        "\n"
@@ -834,18 +858,19 @@ void set_var_decomp(PIOVar &var, const std::string &filename) {
   const auto &comm = ScorpioSession::instance().comm;
   comm.all_reduce(&found, &min_found, 1, MPI_MIN);
   comm.all_reduce(&found, &max_found, 1, MPI_MAX);
-  EKAT_REQUIRE_MSG(min_found == max_found, "Error! Decomposition already present on some ranks but not all.\n"
-                                           " - filename: " +
-                                               filename +
-                                               "\n"
-                                               " - varname : " +
-                                               var.name +
-                                               "\n"
-                                               " - var dims: " +
-                                               ekat::join(var.dims, get_entity_name, ",") +
-                                               "\n"
-                                               " - decopm tag: " +
-                                               decomp_tag + "\n");
+  EKAT_REQUIRE_MSG(min_found == max_found,
+                   "Error! Decomposition already present on some ranks but not all.\n"
+                   " - filename: " +
+                       filename +
+                       "\n"
+                       " - varname : " +
+                       var.name +
+                       "\n"
+                       " - var dims: " +
+                       ekat::join(var.dims, get_entity_name, ",") +
+                       "\n"
+                       " - decopm tag: " +
+                       decomp_tag + "\n");
 #endif
 
   if (decomp == nullptr) {
@@ -879,8 +904,8 @@ void set_var_decomp(PIOVar &var, const std::string &filename) {
     // Create PIO decomp
     int maplen          = decomp->offsets.size();
     PIO_Offset *compmap = reinterpret_cast<PIO_Offset *>(decomp->offsets.data());
-    int err = PIOc_init_decomp(s.pio_sysid, nctype(var.dtype), ndims, gdimlen.data(), maplen, compmap, &decomp->ncid,
-                               s.pio_rearranger, nullptr, nullptr);
+    int err = PIOc_init_decomp(s.pio_sysid, nctype(var.dtype), ndims, gdimlen.data(), maplen,
+                               compmap, &decomp->ncid, s.pio_rearranger, nullptr, nullptr);
 
     check_scorpio_noerr(err, filename, "decomp", decomp_tag, "set_var_decomp", "InitDecomp");
   }
@@ -889,8 +914,8 @@ void set_var_decomp(PIOVar &var, const std::string &filename) {
   var.decomp = decomp;
 }
 
-void set_dim_decomp(const std::string &filename, const std::string &dimname, const std::vector<offset_t> &my_offsets,
-                    const bool allow_reset) {
+void set_dim_decomp(const std::string &filename, const std::string &dimname,
+                    const std::vector<offset_t> &my_offsets, const bool allow_reset) {
   auto &s   = ScorpioSession::instance();
   auto &f   = impl::get_file(filename, "scorpio::set_decomp");
   auto &dim = impl::get_dim(filename, dimname, "scorpio::set_dim_decomp");
@@ -929,15 +954,17 @@ void set_dim_decomp(const std::string &filename, const std::string &dimname, con
       int same         = *dim.offsets == my_offsets;
       const auto &comm = ScorpioSession::instance().comm;
       comm.all_reduce(&same, 1, MPI_MIN);
-      EKAT_REQUIRE_MSG(same == 1, "Error! Attempt to redefine a decomposition with a different dofs distribution.\n"
-                                  " - filename: " +
-                                      filename +
-                                      "\n"
-                                      " - dimname : " +
-                                      dimname +
-                                      "\n"
-                                      "If you are attempting to redefine the decomp, call this function with "
-                                      "throw_if_changing_decomp=false.\n");
+      EKAT_REQUIRE_MSG(
+          same == 1,
+          "Error! Attempt to redefine a decomposition with a different dofs distribution.\n"
+          " - filename: " +
+              filename +
+              "\n"
+              " - dimname : " +
+              dimname +
+              "\n"
+              "If you are attempting to redefine the decomp, call this function with "
+              "throw_if_changing_decomp=false.\n");
 
       // Same decomposition, so we can just return
       return;
@@ -946,18 +973,19 @@ void set_dim_decomp(const std::string &filename, const std::string &dimname, con
 
   // Check that offsets are less than the global dimension length
   for (auto o : my_offsets) {
-    EKAT_REQUIRE_MSG(o >= 0 && o < dim.length, "Error! Offset for dimension decomposition is out of bounds.\n"
-                                               " - filename: " +
-                                                   filename +
-                                                   "\n"
-                                                   " - dimname : " +
-                                                   dimname +
-                                                   "\n"
-                                                   " - dim glen: " +
-                                                   std::to_string(dim.length) +
-                                                   "\n"
-                                                   " - offset  : " +
-                                                   std::to_string(o) + "\n");
+    EKAT_REQUIRE_MSG(o >= 0 && o < dim.length,
+                     "Error! Offset for dimension decomposition is out of bounds.\n"
+                     " - filename: " +
+                         filename +
+                         "\n"
+                         " - dimname : " +
+                         dimname +
+                         "\n"
+                         " - dim glen: " +
+                         std::to_string(dim.length) +
+                         "\n"
+                         " - offset  : " +
+                         std::to_string(o) + "\n");
   }
 
   dim.offsets = std::make_shared<std::vector<offset_t>>(my_offsets);
@@ -971,14 +999,15 @@ void set_dim_decomp(const std::string &filename, const std::string &dimname, con
   }
 }
 
-void set_dim_decomp(const std::string &filename, const std::string &dimname, const offset_t start, const offset_t count,
-                    const bool allow_reset) {
+void set_dim_decomp(const std::string &filename, const std::string &dimname, const offset_t start,
+                    const offset_t count, const bool allow_reset) {
   std::vector<offset_t> offsets(count);
   std::iota(offsets.begin(), offsets.end(), start);
   set_dim_decomp(filename, dimname, offsets, allow_reset);
 }
 
-void set_dim_decomp(const std::string &filename, const std::string &dimname, const bool allow_reset) {
+void set_dim_decomp(const std::string &filename, const std::string &dimname,
+                    const bool allow_reset) {
   const auto &comm = ScorpioSession::instance().comm;
 
   const int glen = get_dimlen(filename, dimname);
@@ -998,8 +1027,8 @@ void set_dim_decomp(const std::string &filename, const std::string &dimname, con
 
 // Define var on output file (cannot call on Read/Append files)
 void define_var(const std::string &filename, const std::string &varname, const std::string &units,
-                const std::vector<std::string> &dimensions, const std::string &dtype, const std::string &nc_dtype,
-                const bool time_dep) {
+                const std::vector<std::string> &dimensions, const std::string &dtype,
+                const std::string &nc_dtype, const bool time_dep) {
   auto &f = impl::get_file(filename, "scorpio::define_var");
 
   EKAT_REQUIRE_MSG(f.mode & Write, "Error! Could not define variable. File is read-only.\n"
@@ -1018,12 +1047,13 @@ void define_var(const std::string &filename, const std::string &varname, const s
                        varname + "\n");
 
   if (f.vars.count(varname) == 0) {
-    EKAT_REQUIRE_MSG(f.mode != Append, "Error! Cannot add a new var when the file is open in append mode.\n"
-                                       " - filename: " +
-                                           filename +
-                                           "\n"
-                                           " - varname : " +
-                                           varname + "\n");
+    EKAT_REQUIRE_MSG(f.mode != Append,
+                     "Error! Cannot add a new var when the file is open in append mode.\n"
+                     " - filename: " +
+                         filename +
+                         "\n"
+                         " - varname : " +
+                         varname + "\n");
     // Create new variable
     auto var      = std::make_shared<PIOVar>();
     var->name     = varname;
@@ -1038,25 +1068,27 @@ void define_var(const std::string &filename, const std::string &varname, const s
       dimids.push_back(f.time_dim->ncid);
     }
     for (const auto &dname : dimensions) {
-      EKAT_REQUIRE_MSG(has_dim(filename, dname), "Error! Cannot create variable. Dimension not found.\n"
-                                                 " - filename : " +
-                                                     filename +
-                                                     "\n"
-                                                     " - varname  : " +
-                                                     varname +
-                                                     "\n"
-                                                     " - var dims : " +
-                                                     ekat::join(dimensions, ",") +
-                                                     "\n"
-                                                     " - file dims: " +
-                                                     print_map_keys(f.dims) + "\n");
+      EKAT_REQUIRE_MSG(has_dim(filename, dname),
+                       "Error! Cannot create variable. Dimension not found.\n"
+                       " - filename : " +
+                           filename +
+                           "\n"
+                           " - varname  : " +
+                           varname +
+                           "\n"
+                           " - var dims : " +
+                           ekat::join(dimensions, ",") +
+                           "\n"
+                           " - file dims: " +
+                           print_map_keys(f.dims) + "\n");
       auto dim = f.dims.at(dname);
       var->dims.push_back(dim);
       dimids.push_back(dim->ncid);
     }
 
     // Define the variable in PIO
-    int err = PIOc_def_var(f.ncid, varname.c_str(), nctype(nc_dtype), ndims, dimids.data(), &var->ncid);
+    int err =
+        PIOc_def_var(f.ncid, varname.c_str(), nctype(nc_dtype), ndims, dimids.data(), &var->ncid);
     check_scorpio_noerr(err, f.name, "variable", varname, "define_var", "def_var");
 
     f.vars[varname] = var;
@@ -1072,18 +1104,19 @@ void define_var(const std::string &filename, const std::string &varname, const s
   } else {
     const auto &var = f.vars.at(varname);
     // The variable was already defined. Check that important metadata is the same
-    EKAT_REQUIRE_MSG(var->units == units, "Error! Attempt to redefine variable with different units.\n"
-                                          " - filename : " +
-                                              filename +
-                                              "\n"
-                                              " - varname  : " +
-                                              varname +
-                                              "\n"
-                                              " - old units: " +
-                                              var->units +
-                                              "\n"
-                                              " - new units: " +
-                                              units + "\n");
+    EKAT_REQUIRE_MSG(var->units == units,
+                     "Error! Attempt to redefine variable with different units.\n"
+                     " - filename : " +
+                         filename +
+                         "\n"
+                         " - varname  : " +
+                         varname +
+                         "\n"
+                         " - old units: " +
+                         var->units +
+                         "\n"
+                         " - new units: " +
+                         units + "\n");
     EKAT_REQUIRE_MSG(var->dtype == refine_dtype(dtype),
                      "Error! Attempt to redefine variable with different data type.\n"
                      " - filename : " +
@@ -1110,18 +1143,19 @@ void define_var(const std::string &filename, const std::string &varname, const s
                          "\n"
                          " - new pio dtype: " +
                          refine_dtype(nc_dtype) + "\n");
-    EKAT_REQUIRE_MSG(var->time_dep == time_dep, "Error! Attempt to redefine variable with different time dep flag.\n"
-                                                " - filename : " +
-                                                    filename +
-                                                    "\n"
-                                                    " - varname  : " +
-                                                    varname +
-                                                    "\n"
-                                                    " - old time_dep: " +
-                                                    (var->time_dep ? "yes" : "no") +
-                                                    "\n"
-                                                    " - new time_dep: " +
-                                                    (time_dep ? "yes" : "no") + "\n");
+    EKAT_REQUIRE_MSG(var->time_dep == time_dep,
+                     "Error! Attempt to redefine variable with different time dep flag.\n"
+                     " - filename : " +
+                         filename +
+                         "\n"
+                         " - varname  : " +
+                         varname +
+                         "\n"
+                         " - old time_dep: " +
+                         (var->time_dep ? "yes" : "no") +
+                         "\n"
+                         " - new time_dep: " +
+                         (time_dep ? "yes" : "no") + "\n");
     const auto var_dims = ekat::join(var->dims, get_entity_name, ",");
     EKAT_REQUIRE_MSG(var_dims == ekat::join(dimensions, ","),
                      "Error! Attempt to redefine variable with different dimensions.\n"
@@ -1139,8 +1173,9 @@ void define_var(const std::string &filename, const std::string &varname, const s
   }
 }
 
-void define_var(const std::string &filename, const std::string &varname, const std::vector<std::string> &dimensions,
-                const std::string &dtype, const bool time_dependent) {
+void define_var(const std::string &filename, const std::string &varname,
+                const std::vector<std::string> &dimensions, const std::string &dtype,
+                const bool time_dependent) {
   define_var(filename, varname, "", dimensions, dtype, dtype, time_dependent);
 }
 
@@ -1160,7 +1195,8 @@ void change_var_dtype(PIOVar &var, const std::string &dtype, const std::string &
   }
 }
 
-void change_var_dtype(const std::string &filename, const std::string &varname, const std::string &dtype) {
+void change_var_dtype(const std::string &filename, const std::string &varname,
+                      const std::string &dtype) {
   auto &var = impl::get_var(filename, varname, "scorpio::change_var_dtype");
   change_var_dtype(var, dtype, filename);
 }
@@ -1176,7 +1212,8 @@ const PIOVar &get_var(const std::string &filename, const std::string &varname) {
   return impl::get_var(filename, varname, "scorpio::get_var");
 }
 
-void define_time(const std::string &filename, const std::string &units, const std::string &time_name) {
+void define_time(const std::string &filename, const std::string &units,
+                 const std::string &time_name) {
   auto &f = impl::get_file(filename, "scorpio::define_time");
   EKAT_REQUIRE_MSG(f.time_dim == nullptr, "Error! Attempt to redeclare unlimited dimension.\n"
                                           " - filename: " +
@@ -1191,23 +1228,25 @@ void define_time(const std::string &filename, const std::string &units, const st
 void mark_dim_as_time(const std::string &filename, const std::string &dimname) {
   auto &f = impl::get_file(filename, "scorpio::mark_dim_as_time");
 
-  EKAT_REQUIRE_MSG(not has_time_dim(filename),
-                   "Error! Resetting the time dimension is not allowed once set (even if it's the same).\n"
-                   " - filename: " +
+  EKAT_REQUIRE_MSG(
+      not has_time_dim(filename),
+      "Error! Resetting the time dimension is not allowed once set (even if it's the same).\n"
+      " - filename: " +
+          filename +
+          "\n"
+          " - old time dim name: " +
+          f.time_dim->name +
+          "\n"
+          " - new time dim name: " +
+          dimname + "\n");
+
+  EKAT_REQUIRE_MSG(f.mode == Read,
+                   "Error! Cannot interpret dimension as 'time' dim. File not in Read mode.\n"
+                   " - filename : " +
                        filename +
                        "\n"
-                       " - old time dim name: " +
-                       f.time_dim->name +
-                       "\n"
-                       " - new time dim name: " +
-                       dimname + "\n");
-
-  EKAT_REQUIRE_MSG(f.mode == Read, "Error! Cannot interpret dimension as 'time' dim. File not in Read mode.\n"
-                                   " - filename : " +
-                                       filename +
-                                       "\n"
-                                       " - file mode: " +
-                                       e2str(f.mode) + "\n");
+                       " - file mode: " +
+                       e2str(f.mode) + "\n");
 
   if (f.time_dim == nullptr) {
     EKAT_REQUIRE_MSG(has_dim(filename, dimname),
@@ -1281,13 +1320,15 @@ std::vector<double> get_all_times(const std::string &filename) {
 // If time dim is present, read given time slice (time_index=-1 means "read last record).
 // If time dim is not present, time_index must be -1 (error out otherwise)
 template <typename T>
-void read_var(const std::string &filename, const std::string &varname, T *buf, const int time_index) {
-  EKAT_REQUIRE_MSG(buf != nullptr, "Error! Cannot read from provided pointer. Invalid buffer pointer.\n"
-                                   " - filename: " +
-                                       filename +
-                                       "\n"
-                                       " - varname : " +
-                                       varname + "\n");
+void read_var(const std::string &filename, const std::string &varname, T *buf,
+              const int time_index) {
+  EKAT_REQUIRE_MSG(buf != nullptr,
+                   "Error! Cannot read from provided pointer. Invalid buffer pointer.\n"
+                   " - filename: " +
+                       filename +
+                       "\n"
+                       " - varname : " +
+                       varname + "\n");
 
   const auto &f = impl::get_file(filename, "scorpio::read_var");
   auto &var     = impl::get_var(filename, varname, "scorpio::read_var");
@@ -1318,7 +1359,7 @@ void read_var(const std::string &filename, const std::string &varname, T *buf, c
   std::string pioc_func;
   if (var.decomp) {
     // A decomposed variable, requires read_darray
-    err       = PIOc_read_darray(f.ncid, var.ncid, var.decomp->ncid, var.decomp->offsets.size(), buf);
+    err = PIOc_read_darray(f.ncid, var.ncid, var.decomp->ncid, var.decomp->offsets.size(), buf);
     pioc_func = "read_darray";
   } else {
     // A non-decomposed variable, use PIOc_get_var(a)
@@ -1370,13 +1411,15 @@ void read_var(const std::string &filename, const std::string &varname, T *buf, c
 
 // Write data from user provided buffer into the requested variable
 template <typename T>
-void write_var(const std::string &filename, const std::string &varname, const T *buf, const T *fillValue) {
-  EKAT_REQUIRE_MSG(buf != nullptr, "Error! Cannot write in provided pointer. Invalid buffer pointer.\n"
-                                   " - filename: " +
-                                       filename +
-                                       "\n"
-                                       " - varname : " +
-                                       varname + "\n");
+void write_var(const std::string &filename, const std::string &varname, const T *buf,
+               const T *fillValue) {
+  EKAT_REQUIRE_MSG(buf != nullptr,
+                   "Error! Cannot write in provided pointer. Invalid buffer pointer.\n"
+                   " - filename: " +
+                       filename +
+                       "\n"
+                       " - varname : " +
+                       varname + "\n");
 
   const auto &f = impl::get_file(filename, "scorpio::write_var");
   auto &var     = impl::get_var(filename, varname, "scorpio::write_var");
@@ -1408,7 +1451,8 @@ void write_var(const std::string &filename, const std::string &varname, const T
   std::string pioc_func;
   if (var.decomp) {
     // A decomposed variable, requires write_darray
-    err       = PIOc_write_darray(f.ncid, var.ncid, var.decomp->ncid, var.decomp->offsets.size(), buf, fillValue);
+    err = PIOc_write_darray(f.ncid, var.ncid, var.decomp->ncid, var.decomp->offsets.size(), buf,
+                            fillValue);
     pioc_func = "write_darray";
   } else {
     // A non-decomposed variable, use PIOc_put_var(a)
@@ -1464,9 +1508,12 @@ template void read_var<double>(const std::string &, const std::string &, double
 template void read_var<char>(const std::string &, const std::string &, char *, const int);
 
 template void write_var<int>(const std::string &, const std::string &, const int *, const int *);
-template void write_var<long long>(const std::string &, const std::string &, const long long *, const long long *);
-template void write_var<float>(const std::string &, const std::string &, const float *, const float *);
-template void write_var<double>(const std::string &, const std::string &, const double *, const double *);
+template void write_var<long long>(const std::string &, const std::string &, const long long *,
+                                   const long long *);
+template void write_var<float>(const std::string &, const std::string &, const float *,
+                               const float *);
+template void write_var<double>(const std::string &, const std::string &, const double *,
+                                const double *);
 template void write_var<char>(const std::string &, const std::string &, const char *, const char *);
 
 // =============== Attributes operations ================== //
@@ -1475,7 +1522,8 @@ bool has_global_attribute(const std::string &filename, const std::string &attnam
   return has_attribute(filename, "GLOBAL", attname);
 }
 
-bool has_attribute(const std::string &filename, const std::string &varname, const std::string &attname) {
+bool has_attribute(const std::string &filename, const std::string &varname,
+                   const std::string &attname) {
   // If file wasn't open, open it on the fly. See comment in PeekFile class above.
   impl::PeekFile pf(filename);
 
@@ -1513,7 +1561,8 @@ bool has_attribute(const std::string &filename, const std::string &varname, cons
 }
 
 template <typename T>
-T get_attribute(const std::string &filename, const std::string &varname, const std::string &attname) {
+T get_attribute(const std::string &filename, const std::string &varname,
+                const std::string &attname) {
   // If file wasn't open, open it on the fly. See comment in PeekFile class above.
   impl::PeekFile pf(filename);
 
@@ -1524,8 +1573,8 @@ T get_attribute(const std::string &filename, const std::string &varname, const s
     varid = impl::get_var(filename, varname, "scorpio::get_attribute").ncid;
   }
 
-  // If the attribute type does not match T, we need a temporary, since we can't pass T* where pio expects
-  // a different type of pointer
+  // If the attribute type does not match T, we need a temporary, since we can't pass T* where pio
+  // expects a different type of pointer
   int att_type, err;
   err = PIOc_inq_atttype(pf.file->ncid, varid, attname.c_str(), &att_type);
   check_scorpio_noerr(err, filename, "attribute", attname, "get_attribute", "inq_atttype");
@@ -1576,15 +1625,19 @@ T get_attribute(const std::string &filename, const std::string &varname, const s
 }
 
 // Explicit instantiation
-template int get_attribute(const std::string &filename, const std::string &varname, const std::string &attname);
+template int get_attribute(const std::string &filename, const std::string &varname,
+                           const std::string &attname);
 template std::int64_t get_attribute(const std::string &filename, const std::string &varname,
                                     const std::string &attname);
-template float get_attribute(const std::string &filename, const std::string &varname, const std::string &attname);
-template double get_attribute(const std::string &filename, const std::string &varname, const std::string &attname);
+template float get_attribute(const std::string &filename, const std::string &varname,
+                             const std::string &attname);
+template double get_attribute(const std::string &filename, const std::string &varname,
+                              const std::string &attname);
 
 // Full specialization for strings
 template <>
-std::string get_attribute(const std::string &filename, const std::string &varname, const std::string &attname) {
+std::string get_attribute(const std::string &filename, const std::string &varname,
+                          const std::string &attname) {
   // If file wasn't open, open it on the fly. See comment in PeekFile class above.
   impl::PeekFile pf(filename);
 
@@ -1609,7 +1662,8 @@ std::string get_attribute(const std::string &filename, const std::string &varnam
 }
 
 template <typename T>
-void set_attribute(const std::string &filename, const std::string &varname, const std::string &attname, const T &att) {
+void set_attribute(const std::string &filename, const std::string &varname,
+                   const std::string &attname, const T &att) {
   const auto &f = impl::get_file(filename, "scorpio::set_any_attribute");
 
   int varid;
@@ -1634,16 +1688,16 @@ void set_attribute(const std::string &filename, const std::string &varname, cons
 }
 
 // Explicit instantiation
-template void set_attribute(const std::string &filename, const std::string &varname, const std::string &attname,
-                            const int &att);
-template void set_attribute(const std::string &filename, const std::string &varname, const std::string &attname,
-                            const std::int64_t &att);
-template void set_attribute(const std::string &filename, const std::string &varname, const std::string &attname,
-                            const float &att);
-template void set_attribute(const std::string &filename, const std::string &varname, const std::string &attname,
-                            const double &att);
-template void set_attribute(const std::string &filename, const std::string &varname, const std::string &attname,
-                            const std::string &att);
+template void set_attribute(const std::string &filename, const std::string &varname,
+                            const std::string &attname, const int &att);
+template void set_attribute(const std::string &filename, const std::string &varname,
+                            const std::string &attname, const std::int64_t &att);
+template void set_attribute(const std::string &filename, const std::string &varname,
+                            const std::string &attname, const float &att);
+template void set_attribute(const std::string &filename, const std::string &varname,
+                            const std::string &attname, const double &att);
+template void set_attribute(const std::string &filename, const std::string &varname,
+                            const std::string &attname, const std::string &att);
 
 } // namespace scorpio
 } // namespace scream
diff --git i/components/eamxx/src/share/io/eamxx_scorpio_interface.hpp w/components/eamxx/src/share/io/eamxx_scorpio_interface.hpp
index 64c7910464..f8cd3045b3 100644
--- i/components/eamxx/src/share/io/eamxx_scorpio_interface.hpp
+++ w/components/eamxx/src/share/io/eamxx_scorpio_interface.hpp
@@ -70,7 +70,8 @@ void finalize_subsystem();
 // =================== File operations ================= //
 
 // Opens a file, returns const handle to it (useful for Read mode, to get dims/vars)
-void register_file(const std::string &filename, const FileMode mode, const IOType iotype = IOType::DefaultIOType);
+void register_file(const std::string &filename, const FileMode mode,
+                   const IOType iotype = IOType::DefaultIOType);
 
 // Release a file (if in Write mode, sync and close the file);
 void release_file(const std::string &filename);
@@ -90,7 +91,8 @@ void enddef(const std::string &filename);
 // Define dim on output file (cannot call on Read/Append files)
 void define_dim(const std::string &filename, const std::string &dimname, const int length);
 
-// Check that the given dimension is in the file. If length>0, also check that the length is as expected.
+// Check that the given dimension is in the file. If length>0, also check that the length is as
+// expected.
 bool has_dim(const std::string &filename, const std::string &dimname, const int length = -1);
 
 int get_dimlen(const std::string &filename, const std::string &dimname);
@@ -130,24 +132,26 @@ std::string get_time_name(const std::string &filename);
 // - if allow_reset=true, we simply reset the decomposition (if present).
 // - if allow_reset=false, if a decomposition for this dim is already set, we error out
 
-void set_dim_decomp(const std::string &filename, const std::string &dimname, const std::vector<offset_t> &my_offsets,
-                    const bool allow_reset = false);
+void set_dim_decomp(const std::string &filename, const std::string &dimname,
+                    const std::vector<offset_t> &my_offsets, const bool allow_reset = false);
 
-void set_dim_decomp(const std::string &filename, const std::string &dimname, const offset_t start, const offset_t count,
-                    const bool allow_reset = false);
+void set_dim_decomp(const std::string &filename, const std::string &dimname, const offset_t start,
+                    const offset_t count, const bool allow_reset = false);
 
-void set_dim_decomp(const std::string &filename, const std::string &dimname, const bool allow_reset = false);
+void set_dim_decomp(const std::string &filename, const std::string &dimname,
+                    const bool allow_reset = false);
 
 // ================== Variable operations ================== //
 
 // Define var on output file (cannot call on Read/Append files)
 void define_var(const std::string &filename, const std::string &varname, const std::string &units,
-                const std::vector<std::string> &dimensions, const std::string &dtype, const std::string &nc_dtype,
-                const bool time_dependent = false);
+                const std::vector<std::string> &dimensions, const std::string &dtype,
+                const std::string &nc_dtype, const bool time_dependent = false);
 
 // Shortcut when units are not used, and dtype==nc_dtype
-void define_var(const std::string &filename, const std::string &varname, const std::vector<std::string> &dimensions,
-                const std::string &dtype, const bool time_dependent = false);
+void define_var(const std::string &filename, const std::string &varname,
+                const std::vector<std::string> &dimensions, const std::string &dtype,
+                const bool time_dependent = false);
 
 // This is useful when reading data sets. E.g., if the pio file is storing
 // a var as float, but we need to read it as double, we need to call this.
@@ -157,7 +161,8 @@ void define_var(const std::string &filename, const std::string &varname, const s
 //       the var WILL be read/written as decomposed, you should call this method
 //       BEFORE calling set_dim_decomp, so that the decomp is built directly
 //       with the correct data type (PIO decomps depend on var dtype).
-void change_var_dtype(const std::string &filename, const std::string &varname, const std::string &dtype);
+void change_var_dtype(const std::string &filename, const std::string &varname,
+                      const std::string &dtype);
 
 // Check that the given variable is in the file.
 bool has_var(const std::string &filename, const std::string &varname);
@@ -182,12 +187,14 @@ std::vector<double> get_all_times(const std::string &filename);
 // first dimension (which is not unlimited).
 // NOTE: ETI in the cpp file for int, float, double.
 template <typename T>
-void read_var(const std::string &filename, const std::string &varname, T *buf, const int time_index = -1);
+void read_var(const std::string &filename, const std::string &varname, T *buf,
+              const int time_index = -1);
 
 // Write data from user provided buffer into the requested variable
 // NOTE: ETI in the cpp file for int, float, double.
 template <typename T>
-void write_var(const std::string &filename, const std::string &varname, const T *buf, const T *fillValue = nullptr);
+void write_var(const std::string &filename, const std::string &varname, const T *buf,
+               const T *fillValue = nullptr);
 
 // =============== Attributes operations ================== //
 
@@ -196,19 +203,22 @@ void write_var(const std::string &filename, const std::string &varname, const T
 //       with Explicit Instantiation only for:
 //         int, std::int64_t, float, double, std::string
 
-bool has_attribute(const std::string &filename, const std::string &varname, const std::string &attname);
+bool has_attribute(const std::string &filename, const std::string &varname,
+                   const std::string &attname);
 
 template <typename T>
-T get_attribute(const std::string &filename, const std::string &varname, const std::string &attname);
+T get_attribute(const std::string &filename, const std::string &varname,
+                const std::string &attname);
 
 template <typename T>
-void set_attribute(const std::string &filename, const std::string &varname, const std::string &attname, const T &att);
+void set_attribute(const std::string &filename, const std::string &varname,
+                   const std::string &attname, const T &att);
 
 // Shortcut, to allow calling set_attribute with compile-time strings, like so
 //   set_attribute(my_file,my_var,my_att_name,"my_value");
 template <int N>
-inline void set_attribute(const std::string &filename, const std::string &varname, const std::string &attname,
-                          const char (&att)[N]) {
+inline void set_attribute(const std::string &filename, const std::string &varname,
+                          const std::string &attname, const char (&att)[N]) {
   set_attribute<std::string>(filename, varname, attname, att);
 }
 
diff --git i/components/eamxx/src/share/io/scorpio_input.cpp w/components/eamxx/src/share/io/scorpio_input.cpp
index 18a88bf26d..946e8b01ae 100644
--- i/components/eamxx/src/share/io/scorpio_input.cpp
+++ w/components/eamxx/src/share/io/scorpio_input.cpp
@@ -9,17 +9,20 @@
 
 namespace scream {
 
-AtmosphereInput::AtmosphereInput(const ekat::ParameterList &params, const std::shared_ptr<const fm_type> &field_mgr) {
+AtmosphereInput::AtmosphereInput(const ekat::ParameterList &params,
+                                 const std::shared_ptr<const fm_type> &field_mgr) {
   init(params, field_mgr);
 }
 
-AtmosphereInput::AtmosphereInput(const ekat::ParameterList &params, const std::shared_ptr<const grid_type> &grid,
+AtmosphereInput::AtmosphereInput(const ekat::ParameterList &params,
+                                 const std::shared_ptr<const grid_type> &grid,
                                  const std::map<std::string, view_1d_host> &host_views_1d,
                                  const std::map<std::string, FieldLayout> &layouts) {
   init(params, grid, host_views_1d, layouts);
 }
 
-AtmosphereInput::AtmosphereInput(const std::string &filename, const std::shared_ptr<const grid_type> &grid,
+AtmosphereInput::AtmosphereInput(const std::string &filename,
+                                 const std::shared_ptr<const grid_type> &grid,
                                  const std::vector<Field> &fields, const bool skip_grid_checks) {
   // Create param list and field manager on the fly
   ekat::ParameterList params;
@@ -50,11 +53,14 @@ AtmosphereInput::~AtmosphereInput() {
   }
 }
 
-void AtmosphereInput::init(const ekat::ParameterList &params, const std::shared_ptr<const fm_type> &field_mgr) {
+void AtmosphereInput::init(const ekat::ParameterList &params,
+                           const std::shared_ptr<const fm_type> &field_mgr) {
   EKAT_REQUIRE_MSG(field_mgr->get_grids_manager()->size() == 1,
                    "Error! AtmosphereInput expects FieldManager defined only on a single grid.\n");
-  EKAT_REQUIRE_MSG(not m_inited_with_views, "Error! Input class was already inited (with user-provided views).\n");
-  EKAT_REQUIRE_MSG(not m_inited_with_fields, "Error! Input class was already inited (with fields).\n");
+  EKAT_REQUIRE_MSG(not m_inited_with_views,
+                   "Error! Input class was already inited (with user-provided views).\n");
+  EKAT_REQUIRE_MSG(not m_inited_with_fields,
+                   "Error! Input class was already inited (with fields).\n");
 
   m_params       = params;
   m_fields_names = m_params.get<decltype(m_fields_names)>("field_names");
@@ -69,11 +75,14 @@ void AtmosphereInput::init(const ekat::ParameterList &params, const std::shared_
   init_scorpio_structures();
 }
 
-void AtmosphereInput::init(const ekat::ParameterList &params, const std::shared_ptr<const grid_type> &grid,
+void AtmosphereInput::init(const ekat::ParameterList &params,
+                           const std::shared_ptr<const grid_type> &grid,
                            const std::map<std::string, view_1d_host> &host_views_1d,
                            const std::map<std::string, FieldLayout> &layouts) {
-  EKAT_REQUIRE_MSG(not m_inited_with_views, "Error! Input class was already inited (with user-provided views).\n");
-  EKAT_REQUIRE_MSG(not m_inited_with_fields, "Error! Input class was already inited (with fields).\n");
+  EKAT_REQUIRE_MSG(not m_inited_with_views,
+                   "Error! Input class was already inited (with user-provided views).\n");
+  EKAT_REQUIRE_MSG(not m_inited_with_fields,
+                   "Error! Input class was already inited (with fields).\n");
 
   m_params   = params;
   m_filename = m_params.get<std::string>("filename");
@@ -124,12 +133,12 @@ void AtmosphereInput::set_field_manager(const std::shared_ptr<const fm_type> &fi
       // Check Layouts
       auto lay_curr = field_curr.get_header().get_identifier().get_layout();
       auto lay_new  = field_new.get_header().get_identifier().get_layout();
-      EKAT_REQUIRE_MSG(
-          lay_curr == lay_new,
-          "ERROR!! AtmosphereInput::set_field_manager - setting new field manager which has different layout for field "
-              << name << "\n"
-              << "    Old Layout: " << lay_curr.to_string() << "\n"
-              << "    New Layout: " << lay_new.to_string() << "\n");
+      EKAT_REQUIRE_MSG(lay_curr == lay_new,
+                       "ERROR!! AtmosphereInput::set_field_manager - setting new field manager "
+                       "which has different layout for field "
+                           << name << "\n"
+                           << "    Old Layout: " << lay_curr.to_string() << "\n"
+                           << "    New Layout: " << lay_new.to_string() << "\n");
     }
   }
 
@@ -189,19 +198,21 @@ void AtmosphereInput::set_grid(const std::shared_ptr<const AbstractGrid> &grid)
   EKAT_REQUIRE_MSG(grid, "Error! Input grid pointer is invalid.\n");
   const bool skip_grid_chk = m_params.get<bool>("skip_grid_checks", false);
   if (!skip_grid_chk) {
-    EKAT_REQUIRE_MSG(grid->is_unique(), "Error! I/O only supports grids which are 'unique', meaning that the\n"
-                                        "       map dof_gid->proc_id is well defined.\n");
-    EKAT_REQUIRE_MSG((grid->get_global_max_dof_gid() - grid->get_global_min_dof_gid() + 1) ==
-                         grid->get_num_global_dofs(),
-                     "Error! IO requires DOF gids to (globally)  be in interval [gid_0,gid_0+num_global_dofs).\n"
-                     "   - global min GID : " +
-                         std::to_string(grid->get_global_min_dof_gid()) +
-                         "\n"
-                         "   - global max GID : " +
-                         std::to_string(grid->get_global_max_dof_gid()) +
-                         "\n"
-                         "   - num global dofs: " +
-                         std::to_string(grid->get_num_global_dofs()) + "\n");
+    EKAT_REQUIRE_MSG(grid->is_unique(),
+                     "Error! I/O only supports grids which are 'unique', meaning that the\n"
+                     "       map dof_gid->proc_id is well defined.\n");
+    EKAT_REQUIRE_MSG(
+        (grid->get_global_max_dof_gid() - grid->get_global_min_dof_gid() + 1) ==
+            grid->get_num_global_dofs(),
+        "Error! IO requires DOF gids to (globally)  be in interval [gid_0,gid_0+num_global_dofs).\n"
+        "   - global min GID : " +
+            std::to_string(grid->get_global_min_dof_gid()) +
+            "\n"
+            "   - global max GID : " +
+            std::to_string(grid->get_global_max_dof_gid()) +
+            "\n"
+            "   - num global dofs: " +
+            std::to_string(grid->get_num_global_dofs()) + "\n");
   }
 
   // The grid is good. Store it.
@@ -223,8 +234,9 @@ void AtmosphereInput::read_variables(const int time_index) {
       m_atm_logger->info("  time idx : " + std::to_string(time_index));
     }
   }
-  EKAT_REQUIRE_MSG(m_inited_with_views || m_inited_with_fields,
-                   "Error! Scorpio structures not inited yet. Did you forget to call 'init(..)'?\n");
+  EKAT_REQUIRE_MSG(
+      m_inited_with_views || m_inited_with_fields,
+      "Error! Scorpio structures not inited yet. Did you forget to call 'init(..)'?\n");
 
   for (auto const &name : m_fields_names) {
 
@@ -303,7 +315,8 @@ void AtmosphereInput::read_variables(const int time_index) {
         case 5: {
           // Reshape temp_view to a 5d view, then copy
           auto dst = f.get_view<Real *****, Host>();
-          auto src = view_Nd_host<5>(view_1d.data(), fl.dim(0), fl.dim(1), fl.dim(2), fl.dim(3), fl.dim(4));
+          auto src = view_Nd_host<5>(view_1d.data(), fl.dim(0), fl.dim(1), fl.dim(2), fl.dim(3),
+                                     fl.dim(4));
           for (int i = 0; i < fl.dim(0); ++i) {
             for (int j = 0; j < fl.dim(1); ++j) {
               for (int k = 0; k < fl.dim(2); ++k) {
@@ -320,7 +333,8 @@ void AtmosphereInput::read_variables(const int time_index) {
         case 6: {
           // Reshape temp_view to a 6d view, then copy
           auto dst = f.get_view<Real ******, Host>();
-          auto src = view_Nd_host<6>(view_1d.data(), fl.dim(0), fl.dim(1), fl.dim(2), fl.dim(3), fl.dim(4), fl.dim(5));
+          auto src = view_Nd_host<6>(view_1d.data(), fl.dim(0), fl.dim(1), fl.dim(2), fl.dim(3),
+                                     fl.dim(4), fl.dim(5));
           for (int i = 0; i < fl.dim(0); ++i) {
             for (int j = 0; j < fl.dim(1); ++j) {
               for (int k = 0; k < fl.dim(2); ++k) {
@@ -347,7 +361,8 @@ void AtmosphereInput::read_variables(const int time_index) {
   }
   auto func_finish = std::chrono::steady_clock::now();
   if (m_atm_logger) {
-    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(func_finish - func_start) / 1000.0;
+    auto duration =
+        std::chrono::duration_cast<std::chrono::milliseconds>(func_finish - func_start) / 1000.0;
     m_atm_logger->info("  Done! Elapsed time: " + std::to_string(duration.count()) + " seconds");
   }
 }
@@ -392,32 +407,35 @@ void AtmosphereInput::init_scorpio_structures() {
     auto vec_of_dims = get_vec_of_dims(layout);
 
     // Check that the variable is in the file.
-    EKAT_REQUIRE_MSG(scorpio::has_var(m_filename, name), "Error! Input file does not store a required variable.\n"
-                                                         " - filename: " +
-                                                             m_filename +
-                                                             "\n"
-                                                             " - varname : " +
-                                                             name + "\n");
+    EKAT_REQUIRE_MSG(scorpio::has_var(m_filename, name),
+                     "Error! Input file does not store a required variable.\n"
+                     " - filename: " +
+                         m_filename +
+                         "\n"
+                         " - varname : " +
+                         name + "\n");
 
     const auto &var = scorpio::get_var(m_filename, name);
-    EKAT_REQUIRE_MSG(var.dim_names() == vec_of_dims, "Error! Layout mismatch for input file variable.\n"
-                                                     " - filename: " +
-                                                         m_filename +
-                                                         "\n"
-                                                         " - varname : " +
-                                                         name +
-                                                         "\n"
-                                                         " - expected dims : " +
-                                                         ekat::join(vec_of_dims, ",") +
-                                                         "\n"
-                                                         " - dims from file: " +
-                                                         ekat::join(var.dim_names(), ",") + "\n");
+    EKAT_REQUIRE_MSG(var.dim_names() == vec_of_dims,
+                     "Error! Layout mismatch for input file variable.\n"
+                     " - filename: " +
+                         m_filename +
+                         "\n"
+                         " - varname : " +
+                         name +
+                         "\n"
+                         " - expected dims : " +
+                         ekat::join(vec_of_dims, ",") +
+                         "\n"
+                         " - dims from file: " +
+                         ekat::join(var.dim_names(), ",") + "\n");
 
     // Check that all dims for this var match the ones on file
     for (int i = 0; i < layout.rank(); ++i) {
       const int file_len     = scorpio::get_dimlen(m_filename, vec_of_dims[i]);
       const bool partitioned = m_io_grid->get_partitioned_dim_tag() == layout.tag(i);
-      const int eamxx_len    = partitioned ? m_io_grid->get_partitioned_dim_global_size() : layout.dim(i);
+      const int eamxx_len =
+          partitioned ? m_io_grid->get_partitioned_dim_global_size() : layout.dim(i);
       EKAT_REQUIRE_MSG(eamxx_len == file_len, "Error! Dimension mismatch for input file variable.\n"
                                               " - filename : " +
                                                   m_filename +
@@ -454,8 +472,9 @@ std::vector<std::string> AtmosphereInput::get_vec_of_dims(const FieldLayout &lay
   std::vector<std::string> dims_names;
   dims_names.reserve(layout.rank());
   for (int i = 0; i < layout.rank(); ++i) {
-    const auto t  = layout.tag(i);
-    std::string n = m_io_grid->has_special_tag_name(t) ? m_io_grid->get_special_tag_name(t) : layout.names()[i];
+    const auto t = layout.tag(i);
+    std::string n =
+        m_io_grid->has_special_tag_name(t) ? m_io_grid->get_special_tag_name(t) : layout.names()[i];
 
     // If t==CMP, and the name stored in the layout is the default ("dim"),
     // we append also the extent, to allow different vector dims in the file
@@ -488,9 +507,10 @@ void AtmosphereInput::set_decompositions() {
   }
 
   // Set the decomposition for the partitioned dimension
-  const int local_dim = m_io_grid->get_partitioned_dim_local_size();
-  std::string decomp_dim =
-      m_io_grid->has_special_tag_name(decomp_tag) ? m_io_grid->get_special_tag_name(decomp_tag) : e2str(decomp_tag);
+  const int local_dim    = m_io_grid->get_partitioned_dim_local_size();
+  std::string decomp_dim = m_io_grid->has_special_tag_name(decomp_tag)
+                               ? m_io_grid->get_special_tag_name(decomp_tag)
+                               : e2str(decomp_tag);
 
   auto gids_f  = m_io_grid->get_partitioned_dim_gids();
   auto gids_h  = gids_f.get_view<const AbstractGrid::gid_type *, Host>();
diff --git i/components/eamxx/src/share/io/scorpio_input.hpp w/components/eamxx/src/share/io/scorpio_input.hpp
index 582f717d12..b3130e658c 100644
--- i/components/eamxx/src/share/io/scorpio_input.hpp
+++ w/components/eamxx/src/share/io/scorpio_input.hpp
@@ -25,8 +25,8 @@
  *  -----
  *  The meaning of these parameters is the following:
  *   - filename: the name of the input file to be read.
- *   - field_names: list of names of fields to load from file. Should match the name in the file and the name in the
- * field manager.
+ *   - field_names: list of names of fields to load from file. Should match the name in the file and
+ * the name in the field manager.
  *
  *  TODO: add a rename option if variable names differ in file and field manager.
  *
@@ -49,7 +49,8 @@ public:
   // --- Constructor(s) & Destructor --- //
   // NOTE: non-trivial constructors simply call the corresponding init method
   AtmosphereInput() = default;
-  AtmosphereInput(const ekat::ParameterList &params, const std::shared_ptr<const fm_type> &field_mgr);
+  AtmosphereInput(const ekat::ParameterList &params,
+                  const std::shared_ptr<const fm_type> &field_mgr);
   AtmosphereInput(const ekat::ParameterList &params, const std::shared_ptr<const grid_type> &grid,
                   const std::map<std::string, view_1d_host> &host_views_1d,
                   const std::map<std::string, FieldLayout> &layouts);
@@ -57,7 +58,8 @@ public:
                   const std::vector<Field> &fields, const bool skip_grid_checks = false);
   // This constructor only sets the minimal info, deferring initialization
   // to when set_field_manager/reset_fields and reset_filename are called
-  AtmosphereInput(const std::vector<std::string> &fields_names, const std::shared_ptr<const grid_type> &grid);
+  AtmosphereInput(const std::vector<std::string> &fields_names,
+                  const std::shared_ptr<const grid_type> &grid);
 
   // Due to resource acquisition (in scorpio), avoid copies
   AtmosphereInput(const AtmosphereInput &) = delete;
@@ -91,7 +93,9 @@ public:
   void finalize();
 
   // Getters
-  std::string get_filename() { return m_filename; } // Simple getter to query the filename for this stream.
+  std::string get_filename() {
+    return m_filename;
+  } // Simple getter to query the filename for this stream.
 
   // Expose the ability to set/reset fields/field_manager for cases like data interpolation,
   // where we swap pointers but all the scorpio data structures are unchanged.
@@ -100,7 +104,9 @@ public:
   void reset_filename(const std::string &filename);
 
   // Option to add a logger
-  void set_logger(const std::shared_ptr<ekat::logger::LoggerBase> &atm_logger) { m_atm_logger = atm_logger; }
+  void set_logger(const std::shared_ptr<ekat::logger::LoggerBase> &atm_logger) {
+    m_atm_logger = atm_logger;
+  }
 
 protected:
   void set_grid(const std::shared_ptr<const AbstractGrid> &grid);
diff --git i/components/eamxx/src/share/io/scorpio_output.cpp w/components/eamxx/src/share/io/scorpio_output.cpp
index 2e84c776cb..97f439f806 100644
--- i/components/eamxx/src/share/io/scorpio_output.cpp
+++ w/components/eamxx/src/share/io/scorpio_output.cpp
@@ -41,7 +41,8 @@ void combine(const Real &new_val, Real &curr_val, const OutputAvgType avg_type)
 }
 // This one covers cases where a variable might be masked.
 KOKKOS_INLINE_FUNCTION
-void combine_and_fill(const Real &new_val, Real &curr_val, const OutputAvgType avg_type, const Real fill_value) {
+void combine_and_fill(const Real &new_val, Real &curr_val, const OutputAvgType avg_type,
+                      const Real fill_value) {
   const bool new_fill  = new_val == fill_value;
   const bool curr_fill = curr_val == fill_value;
   if (curr_fill && new_fill) {
@@ -75,8 +76,10 @@ void combine_and_fill(const Real &new_val, Real &curr_val, const OutputAvgType a
 void sort_and_check(std::vector<std::string> &fields) {
   std::sort(fields.begin(), fields.end());
   const bool hasDuplicates = std::adjacent_find(fields.begin(), fields.end()) != fields.end();
-  EKAT_REQUIRE_MSG(!hasDuplicates, "ERROR!!! scorpio_output::check_for_duplicates - One of the output yaml files has "
-                                   "duplicate field entries.  Please check");
+  EKAT_REQUIRE_MSG(
+      !hasDuplicates,
+      "ERROR!!! scorpio_output::check_for_duplicates - One of the output yaml files has "
+      "duplicate field entries.  Please check");
 }
 
 AtmosphereOutput::AtmosphereOutput(const ekat::Comm &comm, const std::vector<Field> &fields,
@@ -107,7 +110,8 @@ AtmosphereOutput::AtmosphereOutput(const ekat::Comm &comm, const std::vector<Fie
 }
 
 AtmosphereOutput::AtmosphereOutput(const ekat::Comm &comm, const ekat::ParameterList &params,
-                                   const std::shared_ptr<const fm_type> &field_mgr, const std::string &grid_name)
+                                   const std::shared_ptr<const fm_type> &field_mgr,
+                                   const std::string &grid_name)
     : m_comm(comm), m_add_time_dim(true) {
   using vos_t = std::vector<std::string>;
 
@@ -156,7 +160,9 @@ AtmosphereOutput::AtmosphereOutput(const ekat::Comm &comm, const ekat::Parameter
         break;
       }
     }
-    EKAT_REQUIRE_MSG(grid_found, "Error! Bad formatting of output yaml file. Missing 'fields->$grid_name` sublist.\n");
+    EKAT_REQUIRE_MSG(
+        grid_found,
+        "Error! Bad formatting of output yaml file. Missing 'fields->$grid_name` sublist.\n");
   }
   sort_and_check(m_fields_names);
 
@@ -168,13 +174,15 @@ AtmosphereOutput::AtmosphereOutput(const ekat::Comm &comm, const ekat::Parameter
   const bool use_vertical_remap_from_file = params.isParameter("vertical_remap_file");
   const bool use_horiz_remap_from_file    = params.isParameter("horiz_remap_file");
   const bool use_online_remapper =
-      io_grid->name() != fm_grid->name(); // TODO: QUESTION, Do we anticipate online remapping w/ horiz_remap_from file?
-  // Check that we are not requesting online remapping w/ horiz and/or vertical remapping.  Which is not currently
-  // supported.
+      io_grid->name() !=
+      fm_grid
+          ->name(); // TODO: QUESTION, Do we anticipate online remapping w/ horiz_remap_from file?
+  // Check that we are not requesting online remapping w/ horiz and/or vertical remapping.  Which is
+  // not currently supported.
   if (use_online_remapper) {
-    EKAT_REQUIRE_MSG(
-        !use_vertical_remap_from_file and !use_horiz_remap_from_file,
-        "ERROR: scorpio_output - online remapping not supported with vertical and/or horizontal remapping from file");
+    EKAT_REQUIRE_MSG(!use_vertical_remap_from_file and !use_horiz_remap_from_file,
+                     "ERROR: scorpio_output - online remapping not supported with vertical and/or "
+                     "horizontal remapping from file");
   }
 
   // Try to set the IO grid (checks will be performed)
@@ -211,8 +219,8 @@ AtmosphereOutput::AtmosphereOutput(const ekat::Comm &comm, const ekat::Parameter
   auto transfer_io_str_atts = [&](const Field &src, Field &tgt) {
     const std::string io_string_atts_key = "io: string attributes";
     using stratts_t                      = std::map<std::string, std::string>;
-    const auto &src_atts                 = src.get_header().get_extra_data<stratts_t>(io_string_atts_key);
-    auto &dst_atts                       = tgt.get_header().get_extra_data<stratts_t>(io_string_atts_key);
+    const auto &src_atts = src.get_header().get_extra_data<stratts_t>(io_string_atts_key);
+    auto &dst_atts       = tgt.get_header().get_extra_data<stratts_t>(io_string_atts_key);
     for (const auto &[name, val] : src_atts) {
       dst_atts[name] = val;
     }
@@ -265,13 +273,16 @@ AtmosphereOutput::AtmosphereOutput(const ekat::Comm &comm, const ekat::Parameter
     set_field_manager(io_fm, io_grid->name(), "after_vertical_remap");
   }
 
-  // Online remapper and horizontal remapper follow a similar pattern so we check in the same conditional.
+  // Online remapper and horizontal remapper follow a similar pattern so we check in the same
+  // conditional.
   if (use_online_remapper || use_horiz_remap_from_file) {
 
     // Whic FM is the one pre-horiz-remap depends on whether we did vert remap or not
-    const auto fm_pre_hremap =
-        use_vertical_remap_from_file ? get_field_manager("after_vertical_remap") : get_field_manager("sim");
-    const auto gn = use_vertical_remap_from_file ? m_fm_grid_name.at("after_vertical_remap") : m_fm_grid_name.at("sim");
+    const auto fm_pre_hremap = use_vertical_remap_from_file
+                                   ? get_field_manager("after_vertical_remap")
+                                   : get_field_manager("sim");
+    const auto gn = use_vertical_remap_from_file ? m_fm_grid_name.at("after_vertical_remap")
+                                                 : m_fm_grid_name.at("sim");
     set_field_manager(fm_pre_hremap, gn, "before_horizontal_remap");
 
     // We build a remapper, to remap fields from the fm grid to the io grid
@@ -307,7 +318,8 @@ AtmosphereOutput::AtmosphereOutput(const ekat::Comm &comm, const ekat::Parameter
     for (const auto &fname : m_fields_names) {
       const auto src = get_field(fname, "before_horizontal_remap");
       const auto tgt = io_fm->get_field(src.name(), io_grid->name());
-      EKAT_REQUIRE_MSG(src.data_type() == DataType::RealType, "Error! I/O supports only Real data, for now.\n");
+      EKAT_REQUIRE_MSG(src.data_type() == DataType::RealType,
+                       "Error! I/O supports only Real data, for now.\n");
       m_horiz_remapper->register_field(src, tgt);
     }
     m_horiz_remapper->registration_ends();
@@ -345,8 +357,8 @@ void AtmosphereOutput::init() {
     register_dimensions(var_name);
   }
 
-  // Now that the fields have been gathered register the local views which will be used to determine output data to be
-  // written.
+  // Now that the fields have been gathered register the local views which will be used to determine
+  // output data to be written.
   register_views();
 }
 
@@ -356,8 +368,9 @@ void AtmosphereOutput::init_timestep(const util::TimeStamp &start_of_step) {
   }
 }
 
-void AtmosphereOutput::run(const std::string &filename, const bool output_step, const bool checkpoint_step,
-                           const int nsteps_since_last_output, const bool allow_invalid_fields) {
+void AtmosphereOutput::run(const std::string &filename, const bool output_step,
+                           const bool checkpoint_step, const int nsteps_since_last_output,
+                           const bool allow_invalid_fields) {
   // If we do INSTANT output, but this is not an write step,
   // we can immediately return
   const bool is_write_step = output_step or checkpoint_step;
@@ -458,15 +471,16 @@ void AtmosphereOutput::run(const std::string &filename, const bool output_step,
       if (allow_invalid_fields) {
         field.deep_copy(m_fill_value);
       } else {
-        EKAT_REQUIRE_MSG(!m_add_time_dim,
-                         "Error! Time-dependent output field '" + name + "' has not been initialized yet\n.");
+        EKAT_REQUIRE_MSG(!m_add_time_dim, "Error! Time-dependent output field '" + name +
+                                              "' has not been initialized yet\n.");
       }
     }
 
-    const bool is_diagnostic          = (m_diagnostics.find(name) != m_diagnostics.end());
-    const bool is_aliasing_field_view = m_avg_type == OutputAvgType::Instant &&
-                                        field.get_header().get_alloc_properties().get_padding() == 0 &&
-                                        field.get_header().get_parent() == nullptr && not is_diagnostic;
+    const bool is_diagnostic = (m_diagnostics.find(name) != m_diagnostics.end());
+    const bool is_aliasing_field_view =
+        m_avg_type == OutputAvgType::Instant &&
+        field.get_header().get_alloc_properties().get_padding() == 0 &&
+        field.get_header().get_parent() == nullptr && not is_diagnostic;
 
     // Manually update the 'running-tally' views with data from the field,
     // by combining new data with current avg values.
@@ -546,7 +560,8 @@ void AtmosphereOutput::run(const std::string &filename, const bool output_step,
               int i, j, k, l;
               unflatten_idx(idx, extents, i, j, k, l);
               if (do_avg_cnt) {
-                combine_and_fill(new_view_4d(i, j, k, l), avg_view_4d(i, j, k, l), avg_type, fill_value);
+                combine_and_fill(new_view_4d(i, j, k, l), avg_view_4d(i, j, k, l), avg_type,
+                                 fill_value);
               } else {
                 combine(new_view_4d(i, j, k, l), avg_view_4d(i, j, k, l), avg_type);
               }
@@ -561,7 +576,8 @@ void AtmosphereOutput::run(const std::string &filename, const bool output_step,
               int i, j, k, l, m;
               unflatten_idx(idx, extents, i, j, k, l, m);
               if (do_avg_cnt) {
-                combine_and_fill(new_view_5d(i, j, k, l, m), avg_view_5d(i, j, k, l, m), avg_type, fill_value);
+                combine_and_fill(new_view_5d(i, j, k, l, m), avg_view_5d(i, j, k, l, m), avg_type,
+                                 fill_value);
               } else {
                 combine(new_view_5d(i, j, k, l, m), avg_view_5d(i, j, k, l, m), avg_type);
               }
@@ -570,13 +586,15 @@ void AtmosphereOutput::run(const std::string &filename, const bool output_step,
       }
       case 6: {
         auto new_view_6d = field.get_view<const Real ******, Device>();
-        auto avg_view_6d = view_Nd_dev<6>(data, dims[0], dims[1], dims[2], dims[3], dims[4], dims[5]);
+        auto avg_view_6d =
+            view_Nd_dev<6>(data, dims[0], dims[1], dims[2], dims[3], dims[4], dims[5]);
         Kokkos::parallel_for(
             policy, KOKKOS_LAMBDA(int idx) {
               int i, j, k, l, m, n;
               unflatten_idx(idx, extents, i, j, k, l, m, n);
               if (do_avg_cnt) {
-                combine_and_fill(new_view_6d(i, j, k, l, m, n), avg_view_6d(i, j, k, l, m, n), avg_type, fill_value);
+                combine_and_fill(new_view_6d(i, j, k, l, m, n), avg_view_6d(i, j, k, l, m, n),
+                                 avg_type, fill_value);
               } else {
                 combine(new_view_6d(i, j, k, l, m, n), avg_view_6d(i, j, k, l, m, n), avg_type);
               }
@@ -584,7 +602,8 @@ void AtmosphereOutput::run(const std::string &filename, const bool output_step,
         break;
       }
       default:
-        EKAT_ERROR_MSG("Error! Field rank (" + std::to_string(rank) + ") not supported by AtmosphereOutput.\n");
+        EKAT_ERROR_MSG("Error! Field rank (" + std::to_string(rank) +
+                       ") not supported by AtmosphereOutput.\n");
       }
     }
 
@@ -606,7 +625,8 @@ void AtmosphereOutput::run(const std::string &filename, const bool output_step,
               });
         } else {
           // Divide by steps count only when the summation is complete
-          Kokkos::parallel_for(policy, KOKKOS_LAMBDA(int i) { data[i] /= nsteps_since_last_output; });
+          Kokkos::parallel_for(
+              policy, KOKKOS_LAMBDA(int i) { data[i] /= nsteps_since_last_output; });
         }
       }
       // Bring data to host
@@ -614,8 +634,9 @@ void AtmosphereOutput::run(const std::string &filename, const bool output_step,
       Kokkos::deep_copy(view_host, view_dev);
       auto func_start = std::chrono::steady_clock::now();
       scorpio::write_var(filename, name, view_host.data());
-      auto func_finish  = std::chrono::steady_clock::now();
-      auto duration_loc = std::chrono::duration_cast<std::chrono::milliseconds>(func_finish - func_start);
+      auto func_finish = std::chrono::steady_clock::now();
+      auto duration_loc =
+          std::chrono::duration_cast<std::chrono::milliseconds>(func_finish - func_start);
       duration_write += duration_loc.count();
     }
   }
@@ -628,14 +649,16 @@ void AtmosphereOutput::run(const std::string &filename, const bool output_step,
       Kokkos::deep_copy(view_host, view_dev);
       auto func_start = std::chrono::steady_clock::now();
       scorpio::write_var(filename, name, view_host.data());
-      auto func_finish  = std::chrono::steady_clock::now();
-      auto duration_loc = std::chrono::duration_cast<std::chrono::milliseconds>(func_finish - func_start);
+      auto func_finish = std::chrono::steady_clock::now();
+      auto duration_loc =
+          std::chrono::duration_cast<std::chrono::milliseconds>(func_finish - func_start);
       duration_write += duration_loc.count();
     }
   }
   if (is_write_step) {
     if (m_atm_logger) {
-      m_atm_logger->info("  Done! Elapsed time: " + std::to_string(duration_write / 1000.0) + " seconds");
+      m_atm_logger->info("  Done! Elapsed time: " + std::to_string(duration_write / 1000.0) +
+                         " seconds");
     }
   }
 } // run
@@ -685,7 +708,8 @@ long long AtmosphereOutput::res_dep_memory_footprint() const {
   return rdmf;
 }
 /* ---------------------------------------------------------- */
-void AtmosphereOutput::set_field_manager(const std::shared_ptr<const fm_type> &field_mgr, const std::string &grid_name,
+void AtmosphereOutput::set_field_manager(const std::shared_ptr<const fm_type> &field_mgr,
+                                         const std::string &grid_name,
                                          const std::vector<std::string> &modes) {
 
   // Sanity checks
@@ -706,16 +730,18 @@ void AtmosphereOutput::set_field_manager(const std::shared_ptr<const fm_type> &f
   }
 }
 /* ---------------------------------------------------------- */
-void AtmosphereOutput::set_field_manager(const std::shared_ptr<const fm_type> &field_mgr, const std::string &grid_name,
-                                         const std::string &mode) {
+void AtmosphereOutput::set_field_manager(const std::shared_ptr<const fm_type> &field_mgr,
+                                         const std::string &grid_name, const std::string &mode) {
   const std::vector<std::string> modes = {mode};
   set_field_manager(field_mgr, grid_name, modes);
 }
 
-std::shared_ptr<const FieldManager> AtmosphereOutput::get_field_manager(const std::string &mode) const {
+std::shared_ptr<const FieldManager>
+AtmosphereOutput::get_field_manager(const std::string &mode) const {
   auto it = m_field_mgrs.find(mode);
-  EKAT_REQUIRE_MSG(it != m_field_mgrs.end(), "ERROR! AtmosphereOutput::get_field_manager FM for mode = " + mode +
-                                                 " not found in list of available field managers!.");
+  EKAT_REQUIRE_MSG(it != m_field_mgrs.end(),
+                   "ERROR! AtmosphereOutput::get_field_manager FM for mode = " + mode +
+                       " not found in list of available field managers!.");
   return it->second;
 }
 
@@ -724,11 +750,14 @@ std::shared_ptr<const FieldManager> AtmosphereOutput::get_field_manager(const st
 void AtmosphereOutput::set_grid(const std::shared_ptr<const AbstractGrid> &grid) {
   // Sanity checks
   EKAT_REQUIRE_MSG(grid, "Error! Input grid pointer is invalid.\n");
-  EKAT_REQUIRE_MSG(grid->is_unique(), "Error! I/O only supports grids which are 'unique', meaning that the\n"
-                                      "       map dof_gid->proc_id is well defined.\n");
-  EKAT_REQUIRE_MSG((grid->get_global_max_dof_gid() - grid->get_global_min_dof_gid() + 1) == grid->get_num_global_dofs(),
-                   "Error! In order for IO to work, the grid must (globally) have dof gids in interval "
-                   "[gid_0,gid_0+num_global_dofs).\n");
+  EKAT_REQUIRE_MSG(grid->is_unique(),
+                   "Error! I/O only supports grids which are 'unique', meaning that the\n"
+                   "       map dof_gid->proc_id is well defined.\n");
+  EKAT_REQUIRE_MSG(
+      (grid->get_global_max_dof_gid() - grid->get_global_min_dof_gid() + 1) ==
+          grid->get_num_global_dofs(),
+      "Error! In order for IO to work, the grid must (globally) have dof gids in interval "
+      "[gid_0,gid_0+num_global_dofs).\n");
 
   // The grid is good. Store it.
   m_io_grid = grid;
@@ -739,7 +768,8 @@ void AtmosphereOutput::register_dimensions(const std::string &name) {
    * Checks that the dimensions associated with a specific variable will be registered with IO file.
    * INPUT:
    *   field_manager: is a pointer to the field_manager for this simulation.
-   *   name: is a string name of the variable who is to be added to the list of variables in this IO stream.
+   *   name: is a string name of the variable who is to be added to the list of variables in this IO
+   * stream.
    */
   using namespace ShortFieldTagsNames;
 
@@ -753,27 +783,29 @@ void AtmosphereOutput::register_dimensions(const std::string &name) {
   const auto &dims = layout.dims();
   for (int i = 0; i < layout.rank(); ++i) {
     // check tag against m_dims map.  If not in there, then add it.
-    std::string tag_name =
-        m_io_grid->has_special_tag_name(tags[i]) ? m_io_grid->get_special_tag_name(tags[i]) : layout.names()[i];
+    std::string tag_name = m_io_grid->has_special_tag_name(tags[i])
+                               ? m_io_grid->get_special_tag_name(tags[i])
+                               : layout.names()[i];
 
     // If t==CMP, and the name stored in the layout is the default ("dim"),
     // we append also the extent, to allow different vector dims in the file
     tag_name += tag_name == "dim" ? std::to_string(dims[i]) : "";
 
     auto is_partitioned = m_io_grid->get_partitioned_dim_tag() == tags[i];
-    int dim_len         = is_partitioned ? m_io_grid->get_partitioned_dim_global_size() : layout.dim(i);
-    auto it_bool        = m_dims.emplace(tag_name, dim_len);
-    EKAT_REQUIRE_MSG(it_bool.second or it_bool.first->second == dim_len,
-                     "Error! Dimension " + tag_name + " on field " + name +
-                         " has conflicting lengths.\n"
-                         "  - old length: " +
-                         std::to_string(m_dims[tag_name]) +
-                         "\n"
-                         "  - new length: " +
-                         std::to_string(dim_len) +
-                         "\n"
-                         "If same name applies to different dims (e.g. physics_gll and physics_pg2 define "
-                         "\"ncol\" at different lengths), reset tag name for one of the grids.\n");
+    int dim_len  = is_partitioned ? m_io_grid->get_partitioned_dim_global_size() : layout.dim(i);
+    auto it_bool = m_dims.emplace(tag_name, dim_len);
+    EKAT_REQUIRE_MSG(
+        it_bool.second or it_bool.first->second == dim_len,
+        "Error! Dimension " + tag_name + " on field " + name +
+            " has conflicting lengths.\n"
+            "  - old length: " +
+            std::to_string(m_dims[tag_name]) +
+            "\n"
+            "  - new length: " +
+            std::to_string(dim_len) +
+            "\n"
+            "If same name applies to different dims (e.g. physics_gll and physics_pg2 define "
+            "\"ncol\" at different lengths), reset tag name for one of the grids.\n");
   }
 } // register_dimensions
 /* ---------------------------------------------------------- */
@@ -811,8 +843,9 @@ void AtmosphereOutput::register_views() {
     }
 
     if (m_track_avg_cnt) {
-      // Now create and store a dev view to track the averaging count for this layout (if we are tracking)
-      // We don't need to track average counts for files that are not tracking the time dim
+      // Now create and store a dev view to track the averaging count for this layout (if we are
+      // tracking) We don't need to track average counts for files that are not tracking the time
+      // dim
       set_avg_cnt_tracking(name, layout);
     }
   }
@@ -838,17 +871,17 @@ void AtmosphereOutput::set_avg_cnt_tracking(const std::string &name, const Field
     return;
   }
 
-  // Now create and store a dev view to track the averaging count for this layout (if we are tracking)
-  // We don't need to track average counts for files that are not tracking the time dim
+  // Now create and store a dev view to track the averaging count for this layout (if we are
+  // tracking) We don't need to track average counts for files that are not tracking the time dim
   const auto &avg_cnt_suffix = m_field_to_avg_cnt_suffix[name];
   const auto size            = layout.size();
   const auto tags            = layout.tags();
   if (m_track_avg_cnt) {
     std::string avg_cnt_name = "avg_count" + avg_cnt_suffix;
     for (int i = 0; i < layout.rank(); ++i) {
-      const auto t = layout.tag(i);
-      std::string tag_name =
-          m_io_grid->has_special_tag_name(t) ? m_io_grid->get_special_tag_name(t) : layout.names()[i];
+      const auto t         = layout.tag(i);
+      std::string tag_name = m_io_grid->has_special_tag_name(t) ? m_io_grid->get_special_tag_name(t)
+                                                                : layout.names()[i];
 
       // If t==CMP, and the name stored in the layout is the default ("dim"),
       // we append also the extent, to allow different vector dims in the file
@@ -856,12 +889,14 @@ void AtmosphereOutput::set_avg_cnt_tracking(const std::string &name, const Field
 
       avg_cnt_name += "_" + tag_name;
     }
-    if (std::find(m_avg_cnt_names.begin(), m_avg_cnt_names.end(), avg_cnt_name) == m_avg_cnt_names.end()) {
+    if (std::find(m_avg_cnt_names.begin(), m_avg_cnt_names.end(), avg_cnt_name) ==
+        m_avg_cnt_names.end()) {
       m_avg_cnt_names.push_back(avg_cnt_name);
     }
     m_field_to_avg_cnt_map.emplace(name, avg_cnt_name);
-    m_dev_views_1d.emplace(avg_cnt_name,
-                           view_1d_dev("", size)); // Note, emplace will only add a new key if one isn't already there
+    m_dev_views_1d.emplace(
+        avg_cnt_name,
+        view_1d_dev("", size)); // Note, emplace will only add a new key if one isn't already there
     m_host_views_1d.emplace(avg_cnt_name, Kokkos::create_mirror(m_dev_views_1d[avg_cnt_name]));
     m_layouts.emplace(avg_cnt_name, layout);
   }
@@ -895,7 +930,8 @@ void AtmosphereOutput::reset_dev_views() {
   }
 }
 /* ---------------------------------------------------------- */
-void AtmosphereOutput::register_variables(const std::string &filename, const std::string &fp_precision,
+void AtmosphereOutput::register_variables(const std::string &filename,
+                                          const std::string &fp_precision,
                                           const scorpio::FileMode mode) {
   using namespace ShortFieldTagsNames;
   using strvec_t = std::vector<std::string>;
@@ -912,7 +948,8 @@ void AtmosphereOutput::register_variables(const std::string &filename, const std
     std::vector<std::string> vec_of_dims;
     for (int i = 0; i < layout.rank(); ++i) {
       const auto t  = layout.tag(i);
-      auto tag_name = m_io_grid->has_special_tag_name(t) ? m_io_grid->get_special_tag_name(t) : layout.names()[i];
+      auto tag_name = m_io_grid->has_special_tag_name(t) ? m_io_grid->get_special_tag_name(t)
+                                                         : layout.names()[i];
       if (tag_name == "dim") {
         tag_name += std::to_string(layout.dim(i));
       }
@@ -949,18 +986,19 @@ void AtmosphereOutput::register_variables(const std::string &filename, const std
                            "  - varname  : " +
                            name + "\n");
       const auto &var = scorpio::get_var(filename, name);
-      EKAT_REQUIRE_MSG(var.dim_names() == vec_of_dims, "Error! Cannot append, due to variable dimensions mismatch.\n"
-                                                       "  - filename : " +
-                                                           filename +
-                                                           "\n"
-                                                           "  - varname  : " +
-                                                           name +
-                                                           "\n"
-                                                           "  - var dims : " +
-                                                           ekat::join(vec_of_dims, ",") +
-                                                           "\n"
-                                                           "  - var dims from file: " +
-                                                           ekat::join(var.dim_names(), ",") + "\n");
+      EKAT_REQUIRE_MSG(var.dim_names() == vec_of_dims,
+                       "Error! Cannot append, due to variable dimensions mismatch.\n"
+                       "  - filename : " +
+                           filename +
+                           "\n"
+                           "  - varname  : " +
+                           name +
+                           "\n"
+                           "  - var dims : " +
+                           ekat::join(vec_of_dims, ",") +
+                           "\n"
+                           "  - var dims from file: " +
+                           ekat::join(var.dim_names(), ",") + "\n");
       EKAT_REQUIRE_MSG(var.units == units, "Error! Cannot append, due to variable units mismatch.\n"
                                            "  - filename : " +
                                                filename +
@@ -973,24 +1011,26 @@ void AtmosphereOutput::register_variables(const std::string &filename, const std
                                                "\n"
                                                "  - var units from file: " +
                                                var.units + "\n");
-      EKAT_REQUIRE_MSG(var.time_dep == m_add_time_dim, "Error! Cannot append, due to time dependency mismatch.\n"
-                                                       "  - filename : " +
-                                                           filename +
-                                                           "\n"
-                                                           "  - varname  : " +
-                                                           name +
-                                                           "\n"
-                                                           "  - var time dep: " +
-                                                           (m_add_time_dim ? "yes" : "no") +
-                                                           "\n"
-                                                           "  - var time dep from file: " +
-                                                           (var.time_dep ? "yes" : "no") + "\n");
+      EKAT_REQUIRE_MSG(var.time_dep == m_add_time_dim,
+                       "Error! Cannot append, due to time dependency mismatch.\n"
+                       "  - filename : " +
+                           filename +
+                           "\n"
+                           "  - varname  : " +
+                           name +
+                           "\n"
+                           "  - var time dep: " +
+                           (m_add_time_dim ? "yes" : "no") +
+                           "\n"
+                           "  - var time dep from file: " +
+                           (var.time_dep ? "yes" : "no") + "\n");
     } else {
       scorpio::define_var(filename, name, units, vec_of_dims, "real", fp_precision, m_add_time_dim);
 
       // Add FillValue as an attribute of each variable
       // FillValue is a protected metadata, do not add it if it already existed
-      if (fp_precision == "double" or (fp_precision == "real" and std::is_same<Real, double>::value)) {
+      if (fp_precision == "double" or
+          (fp_precision == "real" and std::is_same<Real, double>::value)) {
         double fill_value = m_fill_value;
         scorpio::set_attribute(filename, name, "_FillValue", fill_value);
       } else {
@@ -1015,7 +1055,8 @@ void AtmosphereOutput::register_variables(const std::string &filename, const std
         scorpio::set_attribute(filename, name, "sub_fields", children_list);
       }
 
-      // If tracking average count variables then add the name of the tracking variable for this variable
+      // If tracking average count variables then add the name of the tracking variable for this
+      // variable
       if (m_track_avg_cnt) {
         const auto lookup = m_field_to_avg_cnt_map.at(name);
         scorpio::set_attribute(filename, name, "averaging_count_tracker", lookup);
@@ -1048,7 +1089,8 @@ void AtmosphereOutput::register_variables(const std::string &filename, const std
       const auto layout = m_layouts.at(name);
       auto vec_of_dims  = set_vec_of_dims(layout);
       if (mode == scorpio::FileMode::Append) {
-        // Similar to the regular fields above, check that the var is in the file, and has the right properties
+        // Similar to the regular fields above, check that the var is in the file, and has the right
+        // properties
         EKAT_REQUIRE_MSG(scorpio::has_var(filename, name),
                          "Error! Cannot append, due to variable missing from the file.\n"
                          "  - filename : " +
@@ -1057,47 +1099,51 @@ void AtmosphereOutput::register_variables(const std::string &filename, const std
                              "  - varname  : " +
                              name + "\n");
         const auto &var = scorpio::get_var(filename, name);
-        EKAT_REQUIRE_MSG(var.dim_names() == vec_of_dims, "Error! Cannot append, due to variable dimensions mismatch.\n"
-                                                         "  - filename : " +
-                                                             filename +
-                                                             "\n"
-                                                             "  - varname  : " +
-                                                             name +
-                                                             "\n"
-                                                             "  - var dims : " +
-                                                             ekat::join(vec_of_dims, ",") +
-                                                             "\n"
-                                                             "  - var dims from file: " +
-                                                             ekat::join(var.dim_names(), ",") + "\n");
-        EKAT_REQUIRE_MSG(var.units == unitless, "Error! Cannot append, due to variable units mismatch.\n"
-                                                "  - filename : " +
-                                                    filename +
-                                                    "\n"
-                                                    "  - varname  : " +
-                                                    name +
-                                                    "\n"
-                                                    "  - var units: " +
-                                                    unitless +
-                                                    "\n"
-                                                    "  - var units from file: " +
-                                                    var.units + "\n");
-        EKAT_REQUIRE_MSG(var.time_dep == m_add_time_dim, "Error! Cannot append, due to time dependency mismatch.\n"
-                                                         "  - filename : " +
-                                                             filename +
-                                                             "\n"
-                                                             "  - varname  : " +
-                                                             name +
-                                                             "\n"
-                                                             "  - var time dep: " +
-                                                             (m_add_time_dim ? "yes" : "no") +
-                                                             "\n"
-                                                             "  - var time dep from file: " +
-                                                             (var.time_dep ? "yes" : "no") + "\n");
+        EKAT_REQUIRE_MSG(var.dim_names() == vec_of_dims,
+                         "Error! Cannot append, due to variable dimensions mismatch.\n"
+                         "  - filename : " +
+                             filename +
+                             "\n"
+                             "  - varname  : " +
+                             name +
+                             "\n"
+                             "  - var dims : " +
+                             ekat::join(vec_of_dims, ",") +
+                             "\n"
+                             "  - var dims from file: " +
+                             ekat::join(var.dim_names(), ",") + "\n");
+        EKAT_REQUIRE_MSG(var.units == unitless,
+                         "Error! Cannot append, due to variable units mismatch.\n"
+                         "  - filename : " +
+                             filename +
+                             "\n"
+                             "  - varname  : " +
+                             name +
+                             "\n"
+                             "  - var units: " +
+                             unitless +
+                             "\n"
+                             "  - var units from file: " +
+                             var.units + "\n");
+        EKAT_REQUIRE_MSG(var.time_dep == m_add_time_dim,
+                         "Error! Cannot append, due to time dependency mismatch.\n"
+                         "  - filename : " +
+                             filename +
+                             "\n"
+                             "  - varname  : " +
+                             name +
+                             "\n"
+                             "  - var time dep: " +
+                             (m_add_time_dim ? "yes" : "no") +
+                             "\n"
+                             "  - var time dep from file: " +
+                             (var.time_dep ? "yes" : "no") + "\n");
       } else {
         // Note, unlike with regular output variables, for the average counting
         // variables we don't need to add all of the extra metadata.  So we simply
         // define the variable.
-        scorpio::define_var(filename, name, unitless, vec_of_dims, "real", fp_precision, m_add_time_dim);
+        scorpio::define_var(filename, name, unitless, vec_of_dims, "real", fp_precision,
+                            m_add_time_dim);
       }
     }
   }
@@ -1206,12 +1252,13 @@ void AtmosphereOutput::set_decompositions(const std::string &filename) {
   }
 
   // Set the decomposition for the partitioned dimension
-  const int local_dim = m_io_grid->get_partitioned_dim_local_size();
-  std::string decomp_dim =
-      m_io_grid->has_special_tag_name(decomp_tag) ? m_io_grid->get_special_tag_name(decomp_tag) : e2str(decomp_tag);
-  auto gids_f  = m_io_grid->get_partitioned_dim_gids();
-  auto gids_h  = gids_f.get_view<const AbstractGrid::gid_type *, Host>();
-  auto min_gid = m_io_grid->get_global_min_partitioned_dim_gid();
+  const int local_dim    = m_io_grid->get_partitioned_dim_local_size();
+  std::string decomp_dim = m_io_grid->has_special_tag_name(decomp_tag)
+                               ? m_io_grid->get_special_tag_name(decomp_tag)
+                               : e2str(decomp_tag);
+  auto gids_f            = m_io_grid->get_partitioned_dim_gids();
+  auto gids_h            = gids_f.get_view<const AbstractGrid::gid_type *, Host>();
+  auto min_gid           = m_io_grid->get_global_min_partitioned_dim_gid();
   std::vector<scorpio::offset_t> offsets(local_dim);
   for (int idof = 0; idof < local_dim; ++idof) {
     offsets[idof] = gids_h[idof] - min_gid;
@@ -1219,18 +1266,20 @@ void AtmosphereOutput::set_decompositions(const std::string &filename) {
   scorpio::set_dim_decomp(filename, decomp_dim, offsets);
 }
 
-void AtmosphereOutput::setup_output_file(const std::string &filename, const std::string &fp_precision,
+void AtmosphereOutput::setup_output_file(const std::string &filename,
+                                         const std::string &fp_precision,
                                          const scorpio::FileMode mode) {
   // Register dimensions with netCDF file.
   for (auto it : m_dims) {
     if (mode == scorpio::FileMode::Append) {
       // Simply check that the dim is in the file, and has the right extent
-      EKAT_REQUIRE_MSG(scorpio::has_dim(filename, it.first), "Error! Cannot append, due to missing dim in the file.\n"
-                                                             "  - filename: " +
-                                                                 filename +
-                                                                 "\n"
-                                                                 "  - dimname : " +
-                                                                 it.first + "\n");
+      EKAT_REQUIRE_MSG(scorpio::has_dim(filename, it.first),
+                       "Error! Cannot append, due to missing dim in the file.\n"
+                       "  - filename: " +
+                           filename +
+                           "\n"
+                           "  - dimname : " +
+                           it.first + "\n");
       EKAT_REQUIRE_MSG(scorpio::get_dimlen(filename, it.first) == it.second,
                        "Error! Cannot append, due to mismatch dim length.\n"
                        "  - filename: " +
@@ -1258,7 +1307,8 @@ void AtmosphereOutput::setup_output_file(const std::string &filename, const std:
 /* ---------------------------------------------------------- */
 // This routine will evaluate the diagnostics stored in this
 // output instance.
-void AtmosphereOutput::compute_diagnostic(const std::string &name, const bool allow_invalid_fields) {
+void AtmosphereOutput::compute_diagnostic(const std::string &name,
+                                          const bool allow_invalid_fields) {
   auto skip_diag = m_diag_computed[name];
   if (skip_diag) {
     // Diagnostic already computed, just return
@@ -1332,7 +1382,8 @@ void AtmosphereOutput::set_diagnostics() {
 }
 
 /* ---------------------------------------------------------- */
-std::shared_ptr<AtmosphereDiagnostic> AtmosphereOutput::create_diagnostic(const std::string &diag_field_name) {
+std::shared_ptr<AtmosphereDiagnostic>
+AtmosphereOutput::create_diagnostic(const std::string &diag_field_name) {
   // We need scream scope resolution, since this->create_diagnostic is hiding it
   auto sim_grid = get_field_manager("sim")->get_grids_manager()->get_grid(m_fm_grid_name.at("sim"));
   auto diag     = scream::create_diagnostic(diag_field_name, sim_grid);
@@ -1342,12 +1393,13 @@ std::shared_ptr<AtmosphereDiagnostic> AtmosphereOutput::create_diagnostic(const
   auto &params                  = diag->get_params();
   if (diag->name() == "FieldAtPressureLevel") {
     params.set<double>("mask_value", m_fill_value);
-    diag_avg_cnt_name = "_" + params.get<std::string>("pressure_value") + params.get<std::string>("pressure_units");
-    m_track_avg_cnt   = m_track_avg_cnt || m_avg_type != OutputAvgType::Instant;
+    diag_avg_cnt_name =
+        "_" + params.get<std::string>("pressure_value") + params.get<std::string>("pressure_units");
+    m_track_avg_cnt = m_track_avg_cnt || m_avg_type != OutputAvgType::Instant;
   } else if (diag->name() == "FieldAtHeight") {
     if (params.get<std::string>("surface_reference") == "sealevel") {
-      diag_avg_cnt_name =
-          "_" + params.get<std::string>("height_value") + params.get<std::string>("height_units") + "_above_sealevel";
+      diag_avg_cnt_name = "_" + params.get<std::string>("height_value") +
+                          params.get<std::string>("height_units") + "_above_sealevel";
       m_track_avg_cnt = m_track_avg_cnt || m_avg_type != OutputAvgType::Instant;
     }
   }
diff --git i/components/eamxx/src/share/io/scorpio_output.hpp w/components/eamxx/src/share/io/scorpio_output.hpp
index f6082939aa..0802077a8e 100644
--- i/components/eamxx/src/share/io/scorpio_output.hpp
+++ w/components/eamxx/src/share/io/scorpio_output.hpp
@@ -13,7 +13,8 @@
 #include "ekat/ekat_parameter_list.hpp"
 #include "ekat/mpi/ekat_comm.hpp"
 /*  The AtmosphereOutput class handles an output stream in SCREAM.
- *  Typical usage is to register an AtmosphereOutput object with the OutputManager (see eamxx_output_manager.hpp
+ *  Typical usage is to register an AtmosphereOutput object with the OutputManager (see
+ eamxx_output_manager.hpp
  *
  *  Similar to other SCREAM classes, output streams have a init, run and finalize routines.
  *  These routines are called during the homonymous steps of the AD.
@@ -55,7 +56,8 @@
  *      min     - minimum value of the field over time interval.
  *      max     - maximum value of the field over time interval.
  *    Here, 'time interval' is described by ${Output frequency} and ${Output frequency_units}.
- *    E.g., with 'Output frequency'=10 and 'Output frequency_units'="Days", the time interval is 10 days.
+ *    E.g., with 'Output frequency'=10 and 'Output frequency_units'="Days", the time interval is 10
+ days.
  *  - fields: parameters specifying fields to output
  *     - GRID_NAME: parameters specifyign fields to output from grid $GRID_NAME
  *        - field_names: names of fields defined on grid $grid_name that need to be outputed
@@ -64,9 +66,11 @@
  *  - max_snapshots_per_file: the maximum number of snapshots saved per file. After this many
  *    snapshots, the current files is closed and a new file created.
  *  - Output: parameters for output control
- *    - frequency: the frequency of output writes (in the units specified by ${Output frequency_units})
+ *    - frequency: the frequency of output writes (in the units specified by ${Output
+ frequency_units})
  *    - frequency_units: the units of output frequency (nsteps, nmonths, nyears, nhours, ndays,...)
- *      snapshots have been written on a single nc file, the class will close the file, and open a new one
+ *      snapshots have been written on a single nc file, the class will close the file, and open a
+ new one
  *  - Checkpointing: parameters for checkpointing control
  *    - frequency: the frequenct of checkpoints writes. This option is used/matters only if
  *      if averaging_type is *not* instant. A value of 0 is interpreted as 'no checkpointing'.
@@ -88,7 +92,8 @@
  *      - item_N
  *
  *   - in case of single-grid tests, you can specify fields names by adding 'field_names' directly
- *     in the top-level parameter list. In that case, you can also add 'io_grid_name' in the top-level
+ *     in the top-level parameter list. In that case, you can also add 'io_grid_name' in the
+ top-level
  *     parameter list.
  *   - each instance of this class can only handle ONE grid, so if multiple grids are specified,
  *     you will need one instance per grid.
@@ -133,7 +138,8 @@ public:
   void init();
   void reset_dev_views();
   void update_avg_cnt_view(const Field &, view_1d_dev &dev_view);
-  void setup_output_file(const std::string &filename, const std::string &fp_precision, const scorpio::FileMode mode);
+  void setup_output_file(const std::string &filename, const std::string &fp_precision,
+                         const scorpio::FileMode mode);
 
   void init_timestep(const util::TimeStamp &start_of_step);
   void run(const std::string &filename, const bool output_step, const bool checkpoint_step,
@@ -144,20 +150,23 @@ public:
   std::shared_ptr<const AbstractGrid> get_io_grid() const { return m_io_grid; }
 
   // Option to add a logger
-  void set_logger(const std::shared_ptr<ekat::logger::LoggerBase> &atm_logger) { m_atm_logger = atm_logger; }
+  void set_logger(const std::shared_ptr<ekat::logger::LoggerBase> &atm_logger) {
+    m_atm_logger = atm_logger;
+  }
 
 protected:
   // Internal functions
   void set_grid(const std::shared_ptr<const AbstractGrid> &grid);
-  void set_field_manager(const std::shared_ptr<const fm_type> &field_mgr, const std::string &grid_name,
-                         const std::string &mode);
-  void set_field_manager(const std::shared_ptr<const fm_type> &field_mgr, const std::string &grid_name,
-                         const std::vector<std::string> &modes);
+  void set_field_manager(const std::shared_ptr<const fm_type> &field_mgr,
+                         const std::string &grid_name, const std::string &mode);
+  void set_field_manager(const std::shared_ptr<const fm_type> &field_mgr,
+                         const std::string &grid_name, const std::vector<std::string> &modes);
 
   std::shared_ptr<const fm_type> get_field_manager(const std::string &mode) const;
 
   void register_dimensions(const std::string &name);
-  void register_variables(const std::string &filename, const std::string &fp_precision, const scorpio::FileMode mode);
+  void register_variables(const std::string &filename, const std::string &fp_precision,
+                          const scorpio::FileMode mode);
   void set_decompositions(const std::string &filename);
   std::vector<scorpio::offset_t> get_var_dof_offsets(const FieldLayout &layout);
   void register_views();
@@ -188,9 +197,11 @@ protected:
 
   // How to combine multiple snapshots in the output: instant, Max, Min, Average
   OutputAvgType m_avg_type;
-  Real m_avg_coeff_threshold = 0.5; // % of unfilled values required to not just assign value as FillValue
+  Real m_avg_coeff_threshold =
+      0.5; // % of unfilled values required to not just assign value as FillValue
 
-  // Internal maps to the output fields, how the columns are distributed, the file dimensions and the global ids.
+  // Internal maps to the output fields, how the columns are distributed, the file dimensions and
+  // the global ids.
   std::vector<std::string> m_fields_names;
   std::vector<std::string> m_avg_cnt_names;
   std::map<std::string, std::string> m_field_to_avg_cnt_map;
diff --git i/components/eamxx/src/share/io/scorpio_scm_input.cpp w/components/eamxx/src/share/io/scorpio_scm_input.cpp
index e0190dcfb7..de1b4af121 100644
--- i/components/eamxx/src/share/io/scorpio_scm_input.cpp
+++ w/components/eamxx/src/share/io/scorpio_scm_input.cpp
@@ -28,8 +28,8 @@ template <> MPI_Datatype get_mpi_type<RealInt>() {
 
 namespace scream {
 
-SCMInput::SCMInput(const std::string &filename, const double lat, const double lon, const std::vector<Field> &fields,
-                   const ekat::Comm &comm)
+SCMInput::SCMInput(const std::string &filename, const double lat, const double lon,
+                   const std::vector<Field> &fields, const ekat::Comm &comm)
     : m_comm(comm), m_filename(filename) {
   auto iotype = scorpio::str2iotype("default");
   scorpio::register_file(m_filename, scorpio::Read, iotype);
@@ -53,15 +53,17 @@ SCMInput::SCMInput(const std::string &filename, const double lat, const double l
     const auto &fid = fh.get_identifier();
     const auto &fl  = fid.get_layout();
 
-    EKAT_REQUIRE_MSG(fl.tags()[0] == FieldTag::Column, "Error! SCMInput only works for physics-type layouts.\n"
-                                                       "  - field name: " +
-                                                           f.name() +
-                                                           "\n"
-                                                           "  - field layout: " +
-                                                           fl.to_string() + "\n");
+    EKAT_REQUIRE_MSG(fl.tags()[0] == FieldTag::Column,
+                     "Error! SCMInput only works for physics-type layouts.\n"
+                     "  - field name: " +
+                         f.name() +
+                         "\n"
+                         "  - field layout: " +
+                         fl.to_string() + "\n");
 
     m_fields.push_back(f.subfield(0, 0));
-    FieldIdentifier fid_io(f.name(), fl.clone().reset_dim(0, ncols), fid.get_units(), m_io_grid->name());
+    FieldIdentifier fid_io(f.name(), fl.clone().reset_dim(0, ncols), fid.get_units(),
+                           m_io_grid->name());
     auto &f_io = m_io_fields.emplace_back(fid_io);
     f_io.allocate_view();
   }
@@ -73,11 +75,13 @@ SCMInput::SCMInput(const std::string &filename, const double lat, const double l
 SCMInput::~SCMInput() { scorpio::release_file(m_filename); }
 
 void SCMInput::create_io_grid() {
-  EKAT_REQUIRE_MSG(scorpio::has_dim(m_filename, "ncol"), "Error! Dimension 'ncol' not found in input file.\n"
-                                                         "  - filename: " +
-                                                             m_filename + "\n");
+  EKAT_REQUIRE_MSG(scorpio::has_dim(m_filename, "ncol"),
+                   "Error! Dimension 'ncol' not found in input file.\n"
+                   "  - filename: " +
+                       m_filename + "\n");
   const int ncols = scorpio::get_dimlen(m_filename, "ncol");
-  const int nlevs = scorpio::has_dim(m_filename, "lev") ? scorpio::get_dimlen(m_filename, "lev") : 1;
+  const int nlevs =
+      scorpio::has_dim(m_filename, "lev") ? scorpio::get_dimlen(m_filename, "lev") : 1;
 
   m_io_grid = create_point_grid("scm_io_grid", ncols, nlevs, m_comm);
 }
@@ -159,7 +163,8 @@ void SCMInput::read_variables(const int time_index) {
 
   auto func_finish = std::chrono::steady_clock::now();
   if (m_atm_logger) {
-    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(func_finish - func_start) / 1000.0;
+    auto duration =
+        std::chrono::duration_cast<std::chrono::milliseconds>(func_finish - func_start) / 1000.0;
     m_atm_logger->info("  Done! Elapsed time: " + std::to_string(duration.count()) + " seconds");
   }
 }
@@ -180,26 +185,28 @@ void SCMInput::init_scorpio_structures() {
     }
 
     // Check that the variable is in the file.
-    EKAT_REQUIRE_MSG(scorpio::has_var(m_filename, f.name()), "Error! Input file does not store a required variable.\n"
-                                                             " - filename: " +
-                                                                 m_filename +
-                                                                 "\n"
-                                                                 " - varname : " +
-                                                                 f.name() + "\n");
+    EKAT_REQUIRE_MSG(scorpio::has_var(m_filename, f.name()),
+                     "Error! Input file does not store a required variable.\n"
+                     " - filename: " +
+                         m_filename +
+                         "\n"
+                         " - varname : " +
+                         f.name() + "\n");
 
     const auto &var = scorpio::get_var(m_filename, f.name());
-    EKAT_REQUIRE_MSG(var.dim_names() == dim_names, "Error! Layout mismatch for input file variable.\n"
-                                                   " - filename: " +
-                                                       m_filename +
-                                                       "\n"
-                                                       " - varname : " +
-                                                       f.name() +
-                                                       "\n"
-                                                       " - expected dims : " +
-                                                       ekat::join(dim_names, ",") +
-                                                       "\n"
-                                                       " - dims from file: " +
-                                                       ekat::join(var.dim_names(), ",") + "\n");
+    EKAT_REQUIRE_MSG(var.dim_names() == dim_names,
+                     "Error! Layout mismatch for input file variable.\n"
+                     " - filename: " +
+                         m_filename +
+                         "\n"
+                         " - varname : " +
+                         f.name() +
+                         "\n"
+                         " - expected dims : " +
+                         ekat::join(dim_names, ",") +
+                         "\n"
+                         " - dims from file: " +
+                         ekat::join(var.dim_names(), ",") + "\n");
 
     // Check that all dims for this var match the ones on file
     for (int i = 0; i < layout.rank(); ++i) {
@@ -255,9 +262,10 @@ void SCMInput::set_decompositions() {
   }
 
   // Set the decomposition for the partitioned dimension
-  const int local_dim = m_io_grid->get_partitioned_dim_local_size();
-  std::string decomp_dim =
-      m_io_grid->has_special_tag_name(decomp_tag) ? m_io_grid->get_special_tag_name(decomp_tag) : e2str(decomp_tag);
+  const int local_dim    = m_io_grid->get_partitioned_dim_local_size();
+  std::string decomp_dim = m_io_grid->has_special_tag_name(decomp_tag)
+                               ? m_io_grid->get_special_tag_name(decomp_tag)
+                               : e2str(decomp_tag);
 
   auto gids_f  = m_io_grid->get_partitioned_dim_gids();
   auto gids_h  = gids_f.get_view<const AbstractGrid::gid_type *, Host>();
diff --git i/components/eamxx/src/share/io/scorpio_scm_input.hpp w/components/eamxx/src/share/io/scorpio_scm_input.hpp
index 94974c3ac5..397075102c 100644
--- i/components/eamxx/src/share/io/scorpio_scm_input.hpp
+++ w/components/eamxx/src/share/io/scorpio_scm_input.hpp
@@ -14,8 +14,8 @@ namespace scream {
 class SCMInput {
 public:
   // --- Constructor(s) & Destructor --- //
-  SCMInput(const std::string &filename, const double lat, const double lon, const std::vector<Field> &fields,
-           const ekat::Comm &comm);
+  SCMInput(const std::string &filename, const double lat, const double lon,
+           const std::vector<Field> &fields, const ekat::Comm &comm);
 
   ~SCMInput();
 
@@ -27,7 +27,9 @@ public:
   void read_variables(const int time_index = -1);
 
   // Option to add a logger
-  void set_logger(const std::shared_ptr<ekat::logger::LoggerBase> &atm_logger) { m_atm_logger = atm_logger; }
+  void set_logger(const std::shared_ptr<ekat::logger::LoggerBase> &atm_logger) {
+    m_atm_logger = atm_logger;
+  }
 
 #ifndef KOKKOS_ENABLE_CUDA
   // Cuda requires methods enclosing __device__ lambda's to be public
diff --git i/components/eamxx/src/share/io/tests/create_diag.cpp w/components/eamxx/src/share/io/tests/create_diag.cpp
index 2ec66899e7..660f5f0866 100644
--- i/components/eamxx/src/share/io/tests/create_diag.cpp
+++ w/components/eamxx/src/share/io/tests/create_diag.cpp
@@ -44,9 +44,10 @@ TEST_CASE("create_diag") {
     auto d8 = create_diagnostic("BlaH_123_at_10m_above_surface", grid);
     REQUIRE(std::dynamic_pointer_cast<FieldAtHeight>(d8) != nullptr);
 
-    REQUIRE_THROWS(create_diagnostic("BlaH_123_at_10.5m", grid));                // missing _above_X
-    REQUIRE_THROWS(create_diagnostic("BlaH_123_at_1km_above_sealevel", grid));   // invalid units
-    REQUIRE_THROWS(create_diagnostic("BlaH_123_at_1m_above_the_surface", grid)); // invalid reference
+    REQUIRE_THROWS(create_diagnostic("BlaH_123_at_10.5m", grid));              // missing _above_X
+    REQUIRE_THROWS(create_diagnostic("BlaH_123_at_1km_above_sealevel", grid)); // invalid units
+    REQUIRE_THROWS(
+        create_diagnostic("BlaH_123_at_1m_above_the_surface", grid)); // invalid reference
   }
 
   SECTION("precip_mass_flux") {
diff --git i/components/eamxx/src/share/io/tests/io_basic.cpp w/components/eamxx/src/share/io/tests/io_basic.cpp
index 4167f68396..bf8007b893 100644
--- i/components/eamxx/src/share/io/tests/io_basic.cpp
+++ w/components/eamxx/src/share/io/tests/io_basic.cpp
@@ -70,8 +70,8 @@ std::shared_ptr<const GridsManager> get_gm(const ekat::Comm &comm) {
   return gm;
 }
 
-std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid, const util::TimeStamp &t0,
-                                     const int seed) {
+std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid,
+                                     const util::TimeStamp &t0, const int seed) {
   using FL  = FieldLayout;
   using FID = FieldIdentifier;
   using namespace ShortFieldTagsNames;
@@ -117,8 +117,8 @@ std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &
 }
 
 // Returns fields after initialization
-void write(const std::string &avg_type, const std::string &freq_units, const int freq, const int seed,
-           const ekat::Comm &comm) {
+void write(const std::string &avg_type, const std::string &freq_units, const int freq,
+           const int seed, const ekat::Comm &comm) {
   // Create grid
   auto gm   = get_gm(comm);
   auto grid = gm->get_grid("point_grid");
@@ -190,8 +190,8 @@ void write(const std::string &avg_type, const std::string &freq_units, const int
   om.finalize();
 }
 
-void read(const std::string &avg_type, const std::string &freq_units, const int freq, const int seed,
-          const ekat::Comm &comm) {
+void read(const std::string &avg_type, const std::string &freq_units, const int freq,
+          const int seed, const ekat::Comm &comm) {
   // Only INSTANT writes at t=0
   bool instant = avg_type == "INSTANT";
 
@@ -215,8 +215,8 @@ void read(const std::string &avg_type, const std::string &freq_units, const int
   // Create reader pl
   ekat::ParameterList reader_pl;
   std::string casename = "io_basic";
-  auto filename        = casename + "." + avg_type + "." + freq_units + "_x" + std::to_string(freq) + ".np" +
-                  std::to_string(comm.size()) + "." + t0.to_string() + ".nc";
+  auto filename = casename + "." + avg_type + "." + freq_units + "_x" + std::to_string(freq) +
+                  ".np" + std::to_string(comm.size()) + "." + t0.to_string() + ".nc";
   reader_pl.set("filename", filename);
   reader_pl.set("field_names", fnames);
   AtmosphereInput reader(reader_pl, fm);
diff --git i/components/eamxx/src/share/io/tests/io_diags.cpp w/components/eamxx/src/share/io/tests/io_diags.cpp
index a46544ce18..92fce65119 100644
--- i/components/eamxx/src/share/io/tests/io_diags.cpp
+++ w/components/eamxx/src/share/io/tests/io_diags.cpp
@@ -28,7 +28,8 @@ namespace scream {
 
 class MyDiag : public AtmosphereDiagnostic {
 public:
-  MyDiag(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereDiagnostic(comm, params) {
+  MyDiag(const ekat::Comm &comm, const ekat::ParameterList &params)
+      : AtmosphereDiagnostic(comm, params) {
     // Do nothing
   }
 
@@ -103,8 +104,9 @@ std::shared_ptr<const GridsManager> get_gm(const ekat::Comm &comm) {
   return gm;
 }
 
-std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid, const util::TimeStamp &t0,
-                                     const int seed, const bool add_diag_field = false) {
+std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid,
+                                     const util::TimeStamp &t0, const int seed,
+                                     const bool add_diag_field = false) {
   using FL  = FieldLayout;
   using FID = FieldIdentifier;
   using namespace ShortFieldTagsNames;
@@ -229,7 +231,8 @@ void read(const int seed, const ekat::Comm &comm) {
   // Create reader pl
   ekat::ParameterList reader_pl;
   std::string casename = "io_diags";
-  auto filename = casename + ".INSTANT.nsteps_x1" + ".np" + std::to_string(comm.size()) + "." + t0.to_string() + ".nc";
+  auto filename = casename + ".INSTANT.nsteps_x1" + ".np" + std::to_string(comm.size()) + "." +
+                  t0.to_string() + ".nc";
   reader_pl.set("filename", filename);
   reader_pl.set("field_names", fnames);
   AtmosphereInput reader(reader_pl, fm);
diff --git i/components/eamxx/src/share/io/tests/io_filled.cpp w/components/eamxx/src/share/io/tests/io_filled.cpp
index bdde49aed2..28a954a61f 100644
--- i/components/eamxx/src/share/io/tests/io_filled.cpp
+++ w/components/eamxx/src/share/io/tests/io_filled.cpp
@@ -72,8 +72,8 @@ std::shared_ptr<const GridsManager> get_gm(const ekat::Comm &comm) {
   return gm;
 }
 
-std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid, const util::TimeStamp &t0,
-                                     const int seed) {
+std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid,
+                                     const util::TimeStamp &t0, const int seed) {
   using FL  = FieldLayout;
   using FID = FieldIdentifier;
   using namespace ShortFieldTagsNames;
@@ -100,8 +100,8 @@ std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &
 }
 
 // Returns fields after initialization
-void write(const std::string &avg_type, const std::string &freq_units, const int freq, const int seed,
-           const ekat::Comm &comm) {
+void write(const std::string &avg_type, const std::string &freq_units, const int freq,
+           const int seed, const ekat::Comm &comm) {
   // Create grid
   auto gm   = get_gm(comm);
   auto grid = gm->get_grid("point_grid");
@@ -158,8 +158,8 @@ void write(const std::string &avg_type, const std::string &freq_units, const int
   om.finalize();
 }
 
-void read(const std::string &avg_type, const std::string &freq_units, const int freq, const int seed,
-          const ekat::Comm &comm) {
+void read(const std::string &avg_type, const std::string &freq_units, const int freq,
+          const int seed, const ekat::Comm &comm) {
   // Only INSTANT writes at t=0
   bool instant = avg_type == "INSTANT";
 
@@ -183,18 +183,19 @@ void read(const std::string &avg_type, const std::string &freq_units, const int
   // Create reader pl
   ekat::ParameterList reader_pl;
   std::string casename = "io_filled";
-  auto filename        = casename + "." + avg_type + "." + freq_units + "_x" + std::to_string(freq) + ".np" +
-                  std::to_string(comm.size()) + "." + t0.to_string() + ".nc";
+  auto filename = casename + "." + avg_type + "." + freq_units + "_x" + std::to_string(freq) +
+                  ".np" + std::to_string(comm.size()) + "." + t0.to_string() + ".nc";
   reader_pl.set("filename", filename);
   reader_pl.set("field_names", fnames);
   AtmosphereInput reader(reader_pl, fm);
 
-  // We set the value n to each input field for each odd valued timestep and FillValue for each even valued timestep
-  // Hence, at output step N = snap*freq, we should get
+  // We set the value n to each input field for each odd valued timestep and FillValue for each even
+  // valued timestep Hence, at output step N = snap*freq, we should get
   //  avg=INSTANT: output = N if (N%2=0), else Fillvalue
   //  avg=MAX:     output = N if (N%2=0), else N-1
   //  avg=MIN:     output = N + 1, where n is the first timesnap of the Nth output step.
-  //                        we add + 1 more in cases where (N%2=0) because that means the first snap was filled.
+  //                        we add + 1 more in cases where (N%2=0) because that means the first snap
+  //                        was filled.
   //  avg=AVERAGE: output = a + M+1 = a + M*(M+1)/M
   // The last one comes from
   //   a + 2*(1 + 2 +..+M)/M =
diff --git i/components/eamxx/src/share/io/tests/io_monthly.cpp w/components/eamxx/src/share/io/tests/io_monthly.cpp
index f019a7f68d..a6229d7487 100644
--- i/components/eamxx/src/share/io/tests/io_monthly.cpp
+++ w/components/eamxx/src/share/io/tests/io_monthly.cpp
@@ -46,8 +46,8 @@ std::shared_ptr<const GridsManager> get_gm(const ekat::Comm &comm) {
   return gm;
 }
 
-std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid, const util::TimeStamp &t0,
-                                     const int seed) {
+std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid,
+                                     const util::TimeStamp &t0, const int seed) {
   using FL  = FieldLayout;
   using FID = FieldIdentifier;
   using namespace ShortFieldTagsNames;
@@ -166,8 +166,9 @@ void read(const int seed, const ekat::Comm &comm) {
   // Get filename from timestamp
   std::string casename = "io_monthly";
   auto get_filename    = [&](const util::TimeStamp &t) {
-    auto t_str        = t.to_string().substr(0, 7);
-    std::string fname = casename + ".INSTANT.nsteps_x1" + ".np" + std::to_string(comm.size()) + "." + t_str + ".nc";
+    auto t_str = t.to_string().substr(0, 7);
+    std::string fname =
+        casename + ".INSTANT.nsteps_x1" + ".np" + std::to_string(comm.size()) + "." + t_str + ".nc";
     return fname;
   };
 
diff --git i/components/eamxx/src/share/io/tests/io_packed.cpp w/components/eamxx/src/share/io/tests/io_packed.cpp
index acc1f6286a..0f6e350cfc 100644
--- i/components/eamxx/src/share/io/tests/io_packed.cpp
+++ w/components/eamxx/src/share/io/tests/io_packed.cpp
@@ -43,8 +43,8 @@ std::shared_ptr<const GridsManager> get_gm(const ekat::Comm &comm) {
   return gm;
 }
 
-std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid, const util::TimeStamp &t0,
-                                     const int seed, const int ps) {
+std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid,
+                                     const util::TimeStamp &t0, const int seed, const int ps) {
   using FL  = FieldLayout;
   using FID = FieldIdentifier;
   using namespace ShortFieldTagsNames;
@@ -66,7 +66,8 @@ std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &
   const int nlcols = grid->get_num_local_dofs();
   const int nlevs  = grid->get_num_vertical_levels();
 
-  std::vector<FL> layouts = {FL({COL, LEV}, {nlcols, nlevs}), FL({COL, CMP, ILEV}, {nlcols, 2, nlevs + 1})};
+  std::vector<FL> layouts = {FL({COL, LEV}, {nlcols, nlevs}),
+                             FL({COL, CMP, ILEV}, {nlcols, 2, nlevs + 1})};
 
   auto fm = std::make_shared<FieldManager>(grid);
 
@@ -123,7 +124,8 @@ void write(const int freq, const int seed, const int ps, const ekat::Comm &comm)
   om.finalize();
 }
 
-void read(const int freq, const int seed, const int ps_write, const int ps_read, const ekat::Comm &comm) {
+void read(const int freq, const int seed, const int ps_write, const int ps_read,
+          const ekat::Comm &comm) {
   // Time quantities
   auto t0 = get_t0();
 
@@ -143,8 +145,8 @@ void read(const int freq, const int seed, const int ps_write, const int ps_read,
   // Create reader pl
   ekat::ParameterList reader_pl;
   std::string casename = "io_packed_ps" + std::to_string(ps_write);
-  auto filename = casename + ".INSTANT.nsteps" + "_x" + std::to_string(freq) + ".np" + std::to_string(comm.size()) +
-                  "." + t0.to_string() + ".nc";
+  auto filename        = casename + ".INSTANT.nsteps" + "_x" + std::to_string(freq) + ".np" +
+                  std::to_string(comm.size()) + "." + t0.to_string() + ".nc";
   reader_pl.set("filename", filename);
   reader_pl.set("field_names", fnames);
   AtmosphereInput reader(reader_pl, fm);
diff --git i/components/eamxx/src/share/io/tests/io_remap_test.cpp w/components/eamxx/src/share/io/tests/io_remap_test.cpp
index 92e650b3fb..4e65113df8 100644
--- i/components/eamxx/src/share/io/tests/io_remap_test.cpp
+++ w/components/eamxx/src/share/io/tests/io_remap_test.cpp
@@ -19,23 +19,25 @@ using stratts_t        = std::map<std::string, std::string>;
 
 Real set_pressure(const Real p_top, const Real p_bot, const int nlevs, const int level);
 
-std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &io_comm, const Int num_gcols, const Int num_levs);
+std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &io_comm, const Int num_gcols,
+                                          const Int num_levs);
 
-std::shared_ptr<FieldManager> get_test_fm(std::shared_ptr<const AbstractGrid> grid, const bool midonly,
-                                          const int p_ref = -1);
+std::shared_ptr<FieldManager> get_test_fm(std::shared_ptr<const AbstractGrid> grid,
+                                          const bool midonly, const int p_ref = -1);
 
 Real calculate_output(const Real pressure, const int col, const int cmp);
 
-ekat::ParameterList set_output_params(const std::string &name, const std::string &remap_filename, const int p_ref,
-                                      const bool vert_remap, const bool horiz_remap);
-ekat::ParameterList set_input_params(const std::string &name, ekat::Comm &comm, const std::string &tstamp,
-                                     const int p_ref);
+ekat::ParameterList set_output_params(const std::string &name, const std::string &remap_filename,
+                                      const int p_ref, const bool vert_remap,
+                                      const bool horiz_remap);
+ekat::ParameterList set_input_params(const std::string &name, ekat::Comm &comm,
+                                     const std::string &tstamp, const int p_ref);
 
 bool approx(const Real a, const Real b) {
   const Real tol = std::numeric_limits<Real>::epsilon() * 100000;
   if (std::abs(a - b) >= tol) {
-    printf("Error::approx - difference of |%e - %e| = %e is greater than the max tolerance of %e\n", a, b,
-           std::abs(a - b), tol);
+    printf("Error::approx - difference of |%e - %e| = %e is greater than the max tolerance of %e\n",
+           a, b, std::abs(a - b), tol);
   }
   return std::abs(a - b) < tol;
 }
@@ -135,7 +137,8 @@ TEST_CASE("io_remap_test", "io_remap_test") {
    *
    *            /  p_bot                        for |x| > 4
    *   p_surf = |  0.5*(p_top+p_bot)            for |x| < 2
-   *            \  p_bot - (-sign(x)*m + b)     otherwise, where m = (p_top+p_bot)/4.0 and b = p_top+p_bot
+   *            \  p_bot - (-sign(x)*m + b)     otherwise, where m = (p_top+p_bot)/4.0 and b =
+   * p_top+p_bot
    *
    *
    *                             ----
@@ -233,7 +236,8 @@ TEST_CASE("io_remap_test", "io_remap_test") {
   const int p_ref = (int)set_pressure(p_top, p_bot, nlevs_src + 1, nlevs_src - 1);
 
   print("    -> source data ... \n", io_comm);
-  auto source_remap_control = set_output_params("remap_source", remap_filename, p_ref, false, false);
+  auto source_remap_control =
+      set_output_params("remap_source", remap_filename, p_ref, false, false);
   om_source.initialize(io_comm, source_remap_control, t0, false);
   om_source.setup(field_manager, gm->get_grid_names());
   io_comm.barrier();
@@ -253,7 +257,8 @@ TEST_CASE("io_remap_test", "io_remap_test") {
   print("    -> vertical remap ... done\n", io_comm);
 
   print("    -> horizontal remap ... \n", io_comm);
-  auto horiz_remap_control = set_output_params("remap_horizontal", remap_filename, p_ref, false, true);
+  auto horiz_remap_control =
+      set_output_params("remap_horizontal", remap_filename, p_ref, false, true);
   om_horiz.initialize(io_comm, horiz_remap_control, t0, false);
   om_horiz.setup(field_manager, gm->get_grid_names());
   io_comm.barrier();
@@ -263,7 +268,8 @@ TEST_CASE("io_remap_test", "io_remap_test") {
   print("    -> horizontal remap ... done\n", io_comm);
 
   print("    -> vertical-horizontal remap ... \n", io_comm);
-  auto vert_horiz_remap_control = set_output_params("remap_vertical_horizontal", remap_filename, p_ref, true, true);
+  auto vert_horiz_remap_control =
+      set_output_params("remap_vertical_horizontal", remap_filename, p_ref, true, true);
   om_vert_horiz.initialize(io_comm, vert_horiz_remap_control, t0, false);
   om_vert_horiz.setup(field_manager, gm->get_grid_names());
   io_comm.barrier();
@@ -281,8 +287,9 @@ TEST_CASE("io_remap_test", "io_remap_test") {
   //                                    ---  Vertical Remapping ---
   {
     // Note, the vertical remapper defaults to a mask value of std numeric limits scaled by 0.1;
-    const float mask_val = vert_remap_control.isParameter("Fill Value") ? vert_remap_control.get<double>("Fill Value")
-                                                                        : constants::DefaultFillValue<float>().value;
+    const float mask_val = vert_remap_control.isParameter("Fill Value")
+                               ? vert_remap_control.get<double>("Fill Value")
+                               : constants::DefaultFillValue<float>().value;
     print("    -> vertical remap ... \n", io_comm);
     auto gm_vert   = get_test_gm(io_comm, ncols_src, nlevs_tgt);
     auto grid_vert = gm_vert->get_grid("point_grid");
@@ -301,18 +308,19 @@ TEST_CASE("io_remap_test", "io_remap_test") {
       REQUIRE(att_val == fname);
     }
     std::string f_at_lev_name = "Y_int_at_" + std::to_string(p_ref) + "Pa";
-    att_val                   = scorpio::get_attribute<std::string>(filename, f_at_lev_name, "test");
+    att_val = scorpio::get_attribute<std::string>(filename, f_at_lev_name, "test");
     REQUIRE(att_val == "Y_int");
 
     test_input.finalize();
 
     // Test vertically remapped output.
-    // The single flat variable, "Y_flat" should match the source value exactly.  No vertical interpolation.
-    // The other 4 variables should interpolate onto the expected value given the target pressure.  Note, if
-    // there isn't a source pressure pair that contains a target pressure value then the verticallyi interpolated
-    // value is expected to be masked.
+    // The single flat variable, "Y_flat" should match the source value exactly.  No vertical
+    // interpolation. The other 4 variables should interpolate onto the expected value given the
+    // target pressure.  Note, if there isn't a source pressure pair that contains a target pressure
+    // value then the verticallyi interpolated value is expected to be masked.
     //
-    // NOTE: For scorpio_output.cpp the mask value for vertical remapping is std::numeric_limits<Real>::max()/10.0
+    // NOTE: For scorpio_output.cpp the mask value for vertical remapping is
+    // std::numeric_limits<Real>::max()/10.0
     const auto &Yf_f_vert = fm_vert->get_field("Y_flat");
     const auto &Ys_f_vert = fm_vert->get_field("Y_int_at_" + std::to_string(p_ref) + "Pa");
     const auto &Ym_f_vert = fm_vert->get_field("Y_mid");
@@ -340,8 +348,10 @@ TEST_CASE("io_remap_test", "io_remap_test") {
         REQUIRE(approx(Ym_v_vert(ii, jj), (mid_masked ? mask_val : calculate_output(p_jj, ii, 0))));
         REQUIRE(approx(Yi_v_vert(ii, jj), (int_masked ? mask_val : calculate_output(p_jj, ii, 0))));
         for (int cc = 0; cc < 2; cc++) {
-          REQUIRE(approx(Vm_v_vert(ii, cc, jj), (mid_masked ? mask_val : calculate_output(p_jj, ii, cc + 1))));
-          REQUIRE(approx(Vi_v_vert(ii, cc, jj), (int_masked ? mask_val : calculate_output(p_jj, ii, cc + 1))));
+          REQUIRE(approx(Vm_v_vert(ii, cc, jj),
+                         (mid_masked ? mask_val : calculate_output(p_jj, ii, cc + 1))));
+          REQUIRE(approx(Vi_v_vert(ii, cc, jj),
+                         (int_masked ? mask_val : calculate_output(p_jj, ii, cc + 1))));
         }
       }
     }
@@ -351,8 +361,9 @@ TEST_CASE("io_remap_test", "io_remap_test") {
   //                                    ---  Horizontal Remapping ---
   {
     // Note, the vertical remapper defaults to a mask value of std numeric limits scaled by 0.1;
-    const float mask_val = horiz_remap_control.isParameter("Fill Value") ? horiz_remap_control.get<double>("Fill Value")
-                                                                         : constants::DefaultFillValue<float>().value;
+    const float mask_val = horiz_remap_control.isParameter("Fill Value")
+                               ? horiz_remap_control.get<double>("Fill Value")
+                               : constants::DefaultFillValue<float>().value;
     print("    -> horizontal remap ... \n", io_comm);
     auto gm_horiz   = get_test_gm(io_comm, ncols_tgt, nlevs_src);
     auto grid_horiz = gm_horiz->get_grid("point_grid");
@@ -371,16 +382,16 @@ TEST_CASE("io_remap_test", "io_remap_test") {
       REQUIRE(att_val == fname);
     }
     std::string f_at_lev_name = "Y_int_at_" + std::to_string(p_ref) + "Pa";
-    att_val                   = scorpio::get_attribute<std::string>(filename, f_at_lev_name, "test");
+    att_val = scorpio::get_attribute<std::string>(filename, f_at_lev_name, "test");
     REQUIRE(att_val == "Y_int");
     test_input.finalize();
 
     // Test horizontally remapped output.
-    // The remap we are testing is rather simple, each pair of subsequent columns are remapped to a single
-    // column using `wgt` and `1-wgt` respectively.
+    // The remap we are testing is rather simple, each pair of subsequent columns are remapped to a
+    // single column using `wgt` and `1-wgt` respectively.
     //
-    // Note: For horizontal remapping we added the variable Y_min_at_XPa to check that this diagnostic does
-    // provide some masking, since it applies vertical remapping.
+    // Note: For horizontal remapping we added the variable Y_min_at_XPa to check that this
+    // diagnostic does provide some masking, since it applies vertical remapping.
     const auto &Yf_f_horiz = fm_horiz->get_field("Y_flat");
     const auto &Ys_f_horiz = fm_horiz->get_field("Y_int_at_" + std::to_string(p_ref) + "Pa");
     const auto &Ym_f_horiz = fm_horiz->get_field("Y_mid");
@@ -401,15 +412,18 @@ TEST_CASE("io_remap_test", "io_remap_test") {
       REQUIRE(approx(Yf_v_horiz(ii), Yf_v(col1) * wgt + Yf_v(col2) * (1.0 - wgt)));
       REQUIRE(approx(Yi_v_horiz(ii, 0), Yi_v(col1, 0) * wgt + Yi_v(col2, 0) * (1.0 - wgt)));
       for (int cc = 0; cc < 2; cc++) {
-        REQUIRE(approx(Vi_v_horiz(ii, cc, 0), Vi_v(col1, cc, 0) * wgt + Vi_v(col2, cc, 0) * (1.0 - wgt)));
+        REQUIRE(approx(Vi_v_horiz(ii, cc, 0),
+                       Vi_v(col1, cc, 0) * wgt + Vi_v(col2, cc, 0) * (1.0 - wgt)));
       }
       for (int jj = 0; jj < nlevs_src; jj++) {
         REQUIRE(approx(Ym_v_horiz(ii, jj), Ym_v(col1, jj) * wgt + Ym_v(col2, jj) * (1.0 - wgt)));
-        REQUIRE(approx(Yi_v_horiz(ii, jj + 1), Yi_v(col1, jj + 1) * wgt + Yi_v(col2, jj + 1) * (1.0 - wgt)));
+        REQUIRE(approx(Yi_v_horiz(ii, jj + 1),
+                       Yi_v(col1, jj + 1) * wgt + Yi_v(col2, jj + 1) * (1.0 - wgt)));
         for (int cc = 0; cc < 2; cc++) {
-          REQUIRE(approx(Vm_v_horiz(ii, cc, jj), Vm_v(col1, cc, jj) * wgt + Vm_v(col2, cc, jj) * (1.0 - wgt)));
-          REQUIRE(
-              approx(Vi_v_horiz(ii, cc, jj + 1), Vi_v(col1, cc, jj + 1) * wgt + Vi_v(col2, cc, jj + 1) * (1.0 - wgt)));
+          REQUIRE(approx(Vm_v_horiz(ii, cc, jj),
+                         Vm_v(col1, cc, jj) * wgt + Vm_v(col2, cc, jj) * (1.0 - wgt)));
+          REQUIRE(approx(Vi_v_horiz(ii, cc, jj + 1),
+                         Vi_v(col1, cc, jj + 1) * wgt + Vi_v(col2, cc, jj + 1) * (1.0 - wgt)));
         }
       }
       // For the pressured sliced variable we expect some masking which needs to be checked.
@@ -459,18 +473,20 @@ TEST_CASE("io_remap_test", "io_remap_test") {
       REQUIRE(att_val == fname);
     }
     std::string f_at_lev_name = "Y_int_at_" + std::to_string(p_ref) + "Pa";
-    att_val                   = scorpio::get_attribute<std::string>(filename, f_at_lev_name, "test");
+    att_val = scorpio::get_attribute<std::string>(filename, f_at_lev_name, "test");
     REQUIRE(att_val == "Y_int");
     test_input.finalize();
 
     // Test vertically + horizontally remapped output.
     // This test is a combination of the vertical test and horizontal test above.
     // There should be maksing in the vertical in all locations where the target pressure
-    // is lower/higher than the min/max of the surface pressure, just like in the vertical test.  This should
-    // also translate to more masking in the horizontal reamapping.  So we must check for potential
-    // masking for all variables rather than just the Y_int_at_XPa variable for the horizontal interpolation.
+    // is lower/higher than the min/max of the surface pressure, just like in the vertical test.
+    // This should also translate to more masking in the horizontal reamapping.  So we must check
+    // for potential masking for all variables rather than just the Y_int_at_XPa variable for the
+    // horizontal interpolation.
     //
-    // NOTE: For scorpio_output.cpp the mask value for vertical remapping is std::numeric_limits<Real>::max()/10.0
+    // NOTE: For scorpio_output.cpp the mask value for vertical remapping is
+    // std::numeric_limits<Real>::max()/10.0
     const auto &Yf_f_vh = fm_vh->get_field("Y_flat");
     const auto &Ys_f_vh = fm_vh->get_field("Y_int_at_" + std::to_string(p_ref) + "Pa");
     const auto &Ym_f_vh = fm_vh->get_field("Y_mid");
@@ -536,8 +552,8 @@ TEST_CASE("io_remap_test", "io_remap_test") {
           REQUIRE(approx(Vi_v_vh(ii, cc, jj), test_int));
         }
       }
-      // For the pressured sliced variable we expect it to match the solution from horizontal mapping only so we use the
-      // same syntax.
+      // For the pressured sliced variable we expect it to match the solution from horizontal
+      // mapping only so we use the same syntax.
       Real Ys_exp = 0.0;
       Real Ys_wgt = 0.0;
       bool found  = false;
@@ -578,14 +594,15 @@ Real calculate_output(const Real pressure, const int col, const int cmp) {
   return p_slp * pressure + x_slp * col + c_slp * cmp;
 }
 /*==========================================================================================================*/
-std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &io_comm, const Int num_gcols, const Int num_levs) {
+std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &io_comm, const Int num_gcols,
+                                          const Int num_levs) {
   auto gm = create_mesh_free_grids_manager(io_comm, 0, 0, num_levs, num_gcols);
   gm->build_grids();
   return gm;
 }
 /*==========================================================================================================*/
-std::shared_ptr<FieldManager> get_test_fm(std::shared_ptr<const AbstractGrid> grid, const bool midonly,
-                                          const int p_ref) {
+std::shared_ptr<FieldManager> get_test_fm(std::shared_ptr<const AbstractGrid> grid,
+                                          const bool midonly, const int p_ref) {
   using namespace ekat::units;
   using namespace ShortFieldTagsNames;
   using FL = FieldLayout;
@@ -625,7 +642,8 @@ std::shared_ptr<FieldManager> get_test_fm(std::shared_ptr<const AbstractGrid> gr
   FieldIdentifier fid_Vi("V_int", FL{tag_3d_i, dims_3d_i}, m, gn);
 
   // Register fields with fm
-  // Make sure packsize isn't bigger than the packsize for this machine, but not so big that we end up with only 1 pack.
+  // Make sure packsize isn't bigger than the packsize for this machine, but not so big that we end
+  // up with only 1 pack.
   fm->registration_begins();
   fm->register_field(FR{fid_ps, "output"});
   fm->register_field(FR{fid_pm, "output", Pack::n});
@@ -678,8 +696,9 @@ std::shared_ptr<FieldManager> get_test_fm(std::shared_ptr<const AbstractGrid> gr
   return fm;
 }
 /*==========================================================================================================*/
-ekat::ParameterList set_output_params(const std::string &name, const std::string &remap_filename, const int p_ref,
-                                      const bool vert_remap, const bool horiz_remap) {
+ekat::ParameterList set_output_params(const std::string &name, const std::string &remap_filename,
+                                      const int p_ref, const bool vert_remap,
+                                      const bool horiz_remap) {
   using vos_type = std::vector<std::string>;
   ekat::ParameterList params;
 
@@ -703,20 +722,23 @@ ekat::ParameterList set_output_params(const std::string &name, const std::string
   params.set<vos_type>("field_names", fields_out);
 
   if (vert_remap) {
-    params.set<std::string>("vertical_remap_file", remap_filename); // TODO, make this work for general np=?
+    params.set<std::string>("vertical_remap_file",
+                            remap_filename); // TODO, make this work for general np=?
   }
   if (horiz_remap) {
-    params.set<std::string>("horiz_remap_file", remap_filename); // TODO, make this work for general np=?
+    params.set<std::string>("horiz_remap_file",
+                            remap_filename); // TODO, make this work for general np=?
   }
 
   return params;
 }
 /*==========================================================================================================*/
-ekat::ParameterList set_input_params(const std::string &name, ekat::Comm &comm, const std::string &tstamp,
-                                     const int p_ref) {
+ekat::ParameterList set_input_params(const std::string &name, ekat::Comm &comm,
+                                     const std::string &tstamp, const int p_ref) {
   using vos_type = std::vector<std::string>;
   ekat::ParameterList in_params("Input Parameters");
-  std::string filename = name + ".INSTANT.nsteps_x1.np" + std::to_string(comm.size()) + "." + tstamp + ".nc";
+  std::string filename =
+      name + ".INSTANT.nsteps_x1.np" + std::to_string(comm.size()) + "." + tstamp + ".nc";
   in_params.set<std::string>("filename", filename);
   vos_type fields_in = {"Y_flat", "Y_mid", "Y_int", "V_mid", "V_int"};
   if (p_ref >= 0) {
diff --git i/components/eamxx/src/share/io/tests/io_scm_reader.cpp w/components/eamxx/src/share/io/tests/io_scm_reader.cpp
index 203d31dbc8..9bc7105a5f 100644
--- i/components/eamxx/src/share/io/tests/io_scm_reader.cpp
+++ w/components/eamxx/src/share/io/tests/io_scm_reader.cpp
@@ -57,7 +57,8 @@ void write(const int seed, const ekat::Comm &comm) {
 
   scorpio::define_var(filename, "var", {"ncol", "lev"}, "real");
 
-  auto my_col_gids = grid->get_partitioned_dim_gids().get_view<const AbstractGrid::gid_type *, Host>();
+  auto my_col_gids =
+      grid->get_partitioned_dim_gids().get_view<const AbstractGrid::gid_type *, Host>();
   std::vector<scorpio::offset_t> my_offsets(my_col_gids.size());
   for (size_t i = 0; i < my_offsets.size(); ++i) {
     my_offsets[i] = my_col_gids[i] - grid->get_global_min_partitioned_dim_gid();
diff --git i/components/eamxx/src/share/io/tests/io_se_grid.cpp w/components/eamxx/src/share/io/tests/io_se_grid.cpp
index 9056ff649c..1dfff59b15 100644
--- i/components/eamxx/src/share/io/tests/io_se_grid.cpp
+++ w/components/eamxx/src/share/io/tests/io_se_grid.cpp
@@ -27,11 +27,11 @@ using namespace ekat::units;
 const int packsize = SCREAM_PACK_SIZE;
 using Pack         = ekat::Pack<Real, packsize>;
 
-std::shared_ptr<FieldManager> get_test_fm(const std::shared_ptr<const AbstractGrid> &grid, const util::TimeStamp &t0,
-                                          const bool do_randomize);
+std::shared_ptr<FieldManager> get_test_fm(const std::shared_ptr<const AbstractGrid> &grid,
+                                          const util::TimeStamp &t0, const bool do_randomize);
 
-std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &io_comm, const int num_my_elems, const int np,
-                                          const int num_levs);
+std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &io_comm, const int num_my_elems,
+                                          const int np, const int num_levs);
 
 ekat::ParameterList get_in_params(const ekat::Comm &comm, const util::TimeStamp &t0);
 
@@ -97,8 +97,8 @@ TEST_CASE("se_grid_io") {
 }
 
 /*===================================================================================================*/
-std::shared_ptr<FieldManager> get_test_fm(const std::shared_ptr<const AbstractGrid> &grid, const util::TimeStamp &t0,
-                                          const bool do_randomize) {
+std::shared_ptr<FieldManager> get_test_fm(const std::shared_ptr<const AbstractGrid> &grid,
+                                          const util::TimeStamp &t0, const bool do_randomize) {
   using namespace ShortFieldTagsNames;
   using FL = FieldLayout;
   using FR = FieldRequest;
@@ -154,8 +154,8 @@ std::shared_ptr<FieldManager> get_test_fm(const std::shared_ptr<const AbstractGr
   return fm;
 }
 /*==========================================================================================================*/
-std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &io_comm, const int num_my_elems, const int np,
-                                          const int num_levs) {
+std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &io_comm, const int num_my_elems,
+                                          const int np, const int num_levs) {
   auto gm = create_mesh_free_grids_manager(io_comm, num_my_elems, np, num_levs, 0);
   gm->build_grids();
 
@@ -166,7 +166,8 @@ ekat::ParameterList get_in_params(const ekat::Comm &comm, const util::TimeStamp
   using vos_type = std::vector<std::string>;
   ekat::ParameterList in_params("Input Parameters");
 
-  std::string filename = "io_se_grid.INSTANT.nsteps_x1.np" + std::to_string(comm.size()) + "." + t0.to_string() + ".nc";
+  std::string filename = "io_se_grid.INSTANT.nsteps_x1.np" + std::to_string(comm.size()) + "." +
+                         t0.to_string() + ".nc";
 
   in_params.set<std::string>("filename", filename);
   in_params.set<vos_type>("field_names", {"field_1", "field_2", "field_3", "field_packed"});
diff --git i/components/eamxx/src/share/io/tests/io_utils.cpp w/components/eamxx/src/share/io/tests/io_utils.cpp
index 714ba66b7e..a8a27fbcf8 100644
--- i/components/eamxx/src/share/io/tests/io_utils.cpp
+++ w/components/eamxx/src/share/io/tests/io_utils.cpp
@@ -39,16 +39,24 @@ TEST_CASE("find_filename_in_rpointer") {
   rpointer.close();
 
   // Now test find_filename_in_rpointer with different inputs
+  REQUIRE_THROWS(find_filename_in_rpointer("baz", false, comm, t0, false,
+                                           AVG)); // missing control (needed for rhist files)
   REQUIRE_THROWS(
-      find_filename_in_rpointer("baz", false, comm, t0, false, AVG)); // missing control (needed for rhist files)
-  REQUIRE_THROWS(find_filename_in_rpointer("baz", false, comm, t0, false, AVG, bar_c));   // wrong prefix
-  REQUIRE_THROWS(find_filename_in_rpointer("bar", false, comm, t1, false, AVG, bar_c));   // wrong timestamp
-  REQUIRE_THROWS(find_filename_in_rpointer("bar", true, comm, t0, false, AVG, bar_c));    // bar is not model restart
-  REQUIRE_THROWS(find_filename_in_rpointer("bar", false, comm, t0, false, INST, bar_c));  // wrong avg type
-  REQUIRE_THROWS(find_filename_in_rpointer("bar", false, comm, t0, false, INST, bar2_c)); // wrong freq specs
-  REQUIRE_THROWS(find_filename_in_rpointer("foo", false, comm, t0, false, INST, foo_c));  // foo is model restart
-  REQUIRE_THROWS(find_filename_in_rpointer("foo", true, comm, t0, false, AVG)); // model restart MUST be INSTANT
-  auto not_found = find_filename_in_rpointer("bar", false, comm, t0, true, INST, bar2_c); // Allowed to not find it
+      find_filename_in_rpointer("baz", false, comm, t0, false, AVG, bar_c)); // wrong prefix
+  REQUIRE_THROWS(
+      find_filename_in_rpointer("bar", false, comm, t1, false, AVG, bar_c)); // wrong timestamp
+  REQUIRE_THROWS(find_filename_in_rpointer("bar", true, comm, t0, false, AVG,
+                                           bar_c)); // bar is not model restart
+  REQUIRE_THROWS(
+      find_filename_in_rpointer("bar", false, comm, t0, false, INST, bar_c)); // wrong avg type
+  REQUIRE_THROWS(
+      find_filename_in_rpointer("bar", false, comm, t0, false, INST, bar2_c)); // wrong freq specs
+  REQUIRE_THROWS(find_filename_in_rpointer("foo", false, comm, t0, false, INST,
+                                           foo_c)); // foo is model restart
+  REQUIRE_THROWS(find_filename_in_rpointer("foo", true, comm, t0, false,
+                                           AVG)); // model restart MUST be INSTANT
+  auto not_found = find_filename_in_rpointer("bar", false, comm, t0, true, INST,
+                                             bar2_c); // Allowed to not find it
   REQUIRE(not_found == "");
 
   REQUIRE(find_filename_in_rpointer("bar", false, comm, t0, false, AVG, bar_c) == bar_fname);
diff --git i/components/eamxx/src/share/io/tests/output_restart.cpp w/components/eamxx/src/share/io/tests/output_restart.cpp
index 5acc5b5b9a..36c951f847 100644
--- i/components/eamxx/src/share/io/tests/output_restart.cpp
+++ w/components/eamxx/src/share/io/tests/output_restart.cpp
@@ -33,11 +33,13 @@ std::shared_ptr<FieldManager> get_test_fm(const std::shared_ptr<const AbstractGr
 
 std::shared_ptr<FieldManager> clone_fm(const std::shared_ptr<const FieldManager> &fm);
 
-std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &comm, const Int num_gcols, const Int num_levs);
+std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &comm, const Int num_gcols,
+                                          const Int num_levs);
 
 template <typename Engine> void randomize_fields(const FieldManager &fm, Engine &engine);
 
-void time_advance(const FieldManager &fm, const std::list<ekat::CaseInsensitiveString> &fnames, const int dt);
+void time_advance(const FieldManager &fm, const std::list<ekat::CaseInsensitiveString> &fnames,
+                  const int dt);
 
 TEST_CASE("output_restart", "io") {
   ekat::Comm comm(MPI_COMM_WORLD);
@@ -69,7 +71,8 @@ TEST_CASE("output_restart", "io") {
   // Create output params (some options are set below, depending on the run type
   ekat::ParameterList output_params;
   output_params.set<std::string>("floating_point_precision", "real");
-  output_params.set<std::vector<std::string>>("field_names", {"field_1", "field_2", "field_3", "field_4", "field_5"});
+  output_params.set<std::vector<std::string>>(
+      "field_names", {"field_1", "field_2", "field_3", "field_4", "field_5"});
   output_params.set<double>("fill_value", FillValue);
   output_params.set<int>("flush_frequency", 1);
   output_params.sublist("restart").set<bool>("force_new_file", false);
@@ -80,8 +83,8 @@ TEST_CASE("output_restart", "io") {
   output_params.sublist("checkpoint_control").set<bool>("is_unit_testing", "true");
 
   // Creates and runs an OM from output_params and given inputs
-  auto run = [&](std::shared_ptr<FieldManager> fm, const util::TimeStamp &case_t0, const util::TimeStamp &run_t0,
-                 const int nsteps) {
+  auto run = [&](std::shared_ptr<FieldManager> fm, const util::TimeStamp &case_t0,
+                 const util::TimeStamp &run_t0, const int nsteps) {
     OutputManager output_manager;
     output_manager.initialize(comm, output_params, run_t0, case_t0, false);
     output_manager.setup(fm, gm->get_grid_names());
@@ -219,13 +222,15 @@ template <typename Engine> void randomize_fields(const FieldManager &fm, Engine
 }
 
 /*=============================================================================================*/
-std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &comm, const Int num_gcols, const Int num_levs) {
+std::shared_ptr<GridsManager> get_test_gm(const ekat::Comm &comm, const Int num_gcols,
+                                          const Int num_levs) {
   auto gm = create_mesh_free_grids_manager(comm, 0, 0, num_levs, num_gcols);
   gm->build_grids();
   return gm;
 }
 /*===================================================================================================*/
-void time_advance(const FieldManager &fm, const std::list<ekat::CaseInsensitiveString> &fnames, const int dt) {
+void time_advance(const FieldManager &fm, const std::list<ekat::CaseInsensitiveString> &fnames,
+                  const int dt) {
   for (const auto &fname : fnames) {
     auto f = fm.get_field(fname);
     f.sync_to_host();
@@ -253,7 +258,8 @@ void time_advance(const FieldManager &fm, const std::list<ekat::CaseInsensitiveS
             if (fname == "field_5") {
               // field_5 is used to test restarts w/ filled values, so
               // we cycle between filled and unfilled states.
-              v(i, j, k) = (v(i, j, k) == FillValue) ? dt : ((v(i, j, k) == 1.0) ? 2.0 * dt : FillValue);
+              v(i, j, k) =
+                  (v(i, j, k) == FillValue) ? dt : ((v(i, j, k) == 1.0) ? 2.0 * dt : FillValue);
             } else {
               v(i, j, k) += dt;
             }
diff --git i/components/eamxx/src/share/io/tests/scorpio_interface_tests.cpp w/components/eamxx/src/share/io/tests/scorpio_interface_tests.cpp
index 1907060a92..dbddb613b0 100644
--- i/components/eamxx/src/share/io/tests/scorpio_interface_tests.cpp
+++ w/components/eamxx/src/share/io/tests/scorpio_interface_tests.cpp
@@ -38,7 +38,8 @@ TEST_CASE("write_and_read") {
   // Write phase
   {
     register_file(filename, Write);
-    REQUIRE_THROWS(register_file(filename, Read)); // ERROR: cannot open in both read and write modes
+    REQUIRE_THROWS(
+        register_file(filename, Read)); // ERROR: cannot open in both read and write modes
     REQUIRE(is_file_open(filename));
     REQUIRE(is_file_open(filename, Write));
     REQUIRE(not is_file_open(filename, Read));
@@ -53,16 +54,21 @@ TEST_CASE("write_and_read") {
 
     set_dim_decomp(filename, "dim3", my_offsets);
 
-    REQUIRE_THROWS(define_var(filename, "var1", {"dim1"}, "double", true));   // ERROR: no time dimension (yet)
-    REQUIRE_THROWS(define_var(filename, "var1", {"dim0"}, "double", false));  // ERROR: dim0 not found
-    REQUIRE_THROWS(define_var(filename, "var1", {"dim1"}, "complex", false)); // ERROR: unsupported dtype
+    REQUIRE_THROWS(
+        define_var(filename, "var1", {"dim1"}, "double", true)); // ERROR: no time dimension (yet)
+    REQUIRE_THROWS(
+        define_var(filename, "var1", {"dim0"}, "double", false)); // ERROR: dim0 not found
+    REQUIRE_THROWS(
+        define_var(filename, "var1", {"dim1"}, "complex", false)); // ERROR: unsupported dtype
     define_var(filename, "var1", {"dim1"}, "double", false);
-    define_var(filename, "var1", {"dim1"}, "double", false);                 // OK, same specs
-    REQUIRE_THROWS(define_var(filename, "var1", {"dim2"}, "double", false)); // ERROR: changing var dimensions
-    REQUIRE_THROWS(define_var(filename, "var1", {"dim1"}, "int", false));    // ERROR: changing dtype
+    define_var(filename, "var1", {"dim1"}, "double", false); // OK, same specs
+    REQUIRE_THROWS(
+        define_var(filename, "var1", {"dim2"}, "double", false)); // ERROR: changing var dimensions
+    REQUIRE_THROWS(define_var(filename, "var1", {"dim1"}, "int", false)); // ERROR: changing dtype
 
     define_time(filename, "some_units", "the_time");
-    REQUIRE_THROWS(define_time(filename, "", "another_name")); // ERROR: time already defined with another name
+    REQUIRE_THROWS(
+        define_time(filename, "", "another_name")); // ERROR: time already defined with another name
 
     define_var(filename, "var2", {"dim1", "dim2"}, "float", true);
     define_var(filename, "var3", {}, "int", true);
@@ -89,7 +95,8 @@ TEST_CASE("write_and_read") {
     write_var(filename, "var4", var45.data());
     write_var(filename, "var5", var45.data());
 
-    REQUIRE_THROWS(write_var(filename, "var3", static_cast<int *>(nullptr))); // ERROR: invalid pointer
+    REQUIRE_THROWS(
+        write_var(filename, "var3", static_cast<int *>(nullptr))); // ERROR: invalid pointer
 
     // Write second time slice
     update_time(filename, 0.5);
@@ -174,8 +181,9 @@ TEST_CASE("write_and_read") {
     REQUIRE(tgt_var1 == var1);
 
     // Read first time slice
-    REQUIRE_THROWS(read_var(filename, "var3", var3.data(), 3));              // ERROR: time_idx out of bounds
-    REQUIRE_THROWS(read_var(filename, "var3", static_cast<int *>(nullptr))); // ERROR: invalid pointer
+    REQUIRE_THROWS(read_var(filename, "var3", var3.data(), 3)); // ERROR: time_idx out of bounds
+    REQUIRE_THROWS(
+        read_var(filename, "var3", static_cast<int *>(nullptr))); // ERROR: invalid pointer
 
     read_var(filename, "var2", var2.data(), 0);
     REQUIRE(tgt_var2 == var2);
diff --git i/components/eamxx/src/share/property_checks/field_lower_bound_check.hpp w/components/eamxx/src/share/property_checks/field_lower_bound_check.hpp
index 1d6f00654b..d6e621a58b 100644
--- i/components/eamxx/src/share/property_checks/field_lower_bound_check.hpp
+++ w/components/eamxx/src/share/property_checks/field_lower_bound_check.hpp
@@ -14,9 +14,11 @@ public:
   // Constructor with lower bound. By default, this property check
   // can *NOT* repair fields that fail the check. If can_repair is true,
   // this class will overwrite values out of bounds with the stored lower bound
-  FieldLowerBoundCheck(const Field &field, const std::shared_ptr<const AbstractGrid> &grid, const double lower_bound,
-                       const bool can_repair = false, const double lb_repairable = -s_max)
-      : FieldWithinIntervalCheck(field, grid, lower_bound, s_max, can_repair, lb_repairable, s_max) {
+  FieldLowerBoundCheck(const Field &field, const std::shared_ptr<const AbstractGrid> &grid,
+                       const double lower_bound, const bool can_repair = false,
+                       const double lb_repairable = -s_max)
+      : FieldWithinIntervalCheck(field, grid, lower_bound, s_max, can_repair, lb_repairable,
+                                 s_max) {
     // Do Nothing
   }
 
diff --git i/components/eamxx/src/share/property_checks/field_nan_check.cpp w/components/eamxx/src/share/property_checks/field_nan_check.cpp
index 97e547088b..71d50b3b44 100644
--- i/components/eamxx/src/share/property_checks/field_nan_check.cpp
+++ w/components/eamxx/src/share/property_checks/field_nan_check.cpp
@@ -6,7 +6,8 @@
 
 namespace scream {
 
-FieldNaNCheck::FieldNaNCheck(const Field &f, const std::shared_ptr<const AbstractGrid> &grid) : m_grid(grid) {
+FieldNaNCheck::FieldNaNCheck(const Field &f, const std::shared_ptr<const AbstractGrid> &grid)
+    : m_grid(grid) {
   // Sanity checks
   EKAT_REQUIRE_MSG(f.rank() <= 6, "Error in FieldNaNCheck constructor: unsupported field rank.\n"
                                   "  - Field name: " +
@@ -22,8 +23,10 @@ FieldNaNCheck::FieldNaNCheck(const Field &f, const std::shared_ptr<const Abstrac
                           "  - Field rank: " +
                               std::to_string(f.rank()) + "\n");
 
-  EKAT_REQUIRE_MSG(grid == nullptr || f.get_header().get_identifier().get_grid_name() == grid->name(),
-                   "Error! The name of the input grid does not match the grid name stored in the field identifier.\n"
+  EKAT_REQUIRE_MSG(grid == nullptr ||
+                       f.get_header().get_identifier().get_grid_name() == grid->name(),
+                   "Error! The name of the input grid does not match the grid name stored in the "
+                   "field identifier.\n"
                    "  - Field name: " +
                        f.name() +
                        "\n"
@@ -158,8 +161,8 @@ template <typename ST> PropertyCheck::ResultAndMsg FieldNaNCheck::check_impl() c
       if (has_latlon) {
         auto lat = m_grid->get_geometry_data("lat").get_internal_view_data<const Real, Host>();
         auto lon = m_grid->get_geometry_data("lon").get_internal_view_data<const Real, Host>();
-        res_and_msg.msg +=
-            "  - lat/lon: (" + std::to_string(lat[col_lid]) + ", " + std::to_string(lon[col_lid]) + ")\n";
+        res_and_msg.msg += "  - lat/lon: (" + std::to_string(lat[col_lid]) + ", " +
+                           std::to_string(lon[col_lid]) + ")\n";
       }
       bool has_additional_col_info = not additional_data_fields().empty();
       if (has_additional_col_info) {
diff --git i/components/eamxx/src/share/property_checks/field_upper_bound_check.hpp w/components/eamxx/src/share/property_checks/field_upper_bound_check.hpp
index a17a054556..2a483ead8e 100644
--- i/components/eamxx/src/share/property_checks/field_upper_bound_check.hpp
+++ w/components/eamxx/src/share/property_checks/field_upper_bound_check.hpp
@@ -14,9 +14,11 @@ public:
   // Constructor with lower bound. By default, this property check
   // can *NOT* repair fields that fail the check. If can_repair is true,
   // this class will overwrite values out of bounds with the stored upper bound
-  FieldUpperBoundCheck(const Field &field, const std::shared_ptr<const AbstractGrid> &grid, const double upper_bound,
-                       const bool can_repair = false, const double ub_repairable = s_max)
-      : FieldWithinIntervalCheck(field, grid, -s_max, upper_bound, can_repair, -s_max, ub_repairable) {
+  FieldUpperBoundCheck(const Field &field, const std::shared_ptr<const AbstractGrid> &grid,
+                       const double upper_bound, const bool can_repair = false,
+                       const double ub_repairable = s_max)
+      : FieldWithinIntervalCheck(field, grid, -s_max, upper_bound, can_repair, -s_max,
+                                 ub_repairable) {
     // Do Nothing
   }
 
diff --git i/components/eamxx/src/share/property_checks/field_within_interval_check.cpp w/components/eamxx/src/share/property_checks/field_within_interval_check.cpp
index 2380b37ffe..18a4c07c58 100644
--- i/components/eamxx/src/share/property_checks/field_within_interval_check.cpp
+++ w/components/eamxx/src/share/property_checks/field_within_interval_check.cpp
@@ -8,18 +8,22 @@
 
 namespace scream {
 
-FieldWithinIntervalCheck::FieldWithinIntervalCheck(const Field &f, const std::shared_ptr<const AbstractGrid> &grid,
-                                                   const double lower_bound, const double upper_bound,
-                                                   const bool can_repair, const double lb_repairable,
+FieldWithinIntervalCheck::FieldWithinIntervalCheck(const Field &f,
+                                                   const std::shared_ptr<const AbstractGrid> &grid,
+                                                   const double lower_bound,
+                                                   const double upper_bound, const bool can_repair,
+                                                   const double lb_repairable,
                                                    const double ub_repairable)
-    : m_lb(lower_bound), m_ub(upper_bound), m_lb_repairable(lower_bound), m_ub_repairable(upper_bound), m_grid(grid) {
+    : m_lb(lower_bound), m_ub(upper_bound), m_lb_repairable(lower_bound),
+      m_ub_repairable(upper_bound), m_grid(grid) {
   // Sanity checks
-  EKAT_REQUIRE_MSG(f.rank() <= 6, "Error in FieldWithinIntervalCheck constructor: unsupported field rank.\n"
-                                  "  - Field name: " +
-                                          f.name()
-                                      << "\n"
-                                         "  - Field rank: " +
-                                             std::to_string(f.rank()) + "\n");
+  EKAT_REQUIRE_MSG(f.rank() <= 6,
+                   "Error in FieldWithinIntervalCheck constructor: unsupported field rank.\n"
+                   "  - Field name: " +
+                           f.name()
+                       << "\n"
+                          "  - Field rank: " +
+                              std::to_string(f.rank()) + "\n");
   EKAT_REQUIRE_MSG(field_valid_data_types().has_v(f.data_type()),
                    "Error in FieldWithinIntervalCheck constructor: field data type not supported.\n"
                    "  - Field name: " +
@@ -27,10 +31,13 @@ FieldWithinIntervalCheck::FieldWithinIntervalCheck(const Field &f, const std::sh
                        << "\n"
                           "  - Field rank: " +
                               std::to_string(f.rank()) + "\n");
-  EKAT_ASSERT_MSG(lower_bound <= upper_bound, "lower_bound must be less than or equal to upper_bound.");
+  EKAT_ASSERT_MSG(lower_bound <= upper_bound,
+                  "lower_bound must be less than or equal to upper_bound.");
 
-  EKAT_REQUIRE_MSG(grid == nullptr || f.get_header().get_identifier().get_grid_name() == grid->name(),
-                   "Error! The name of the input grid does not match the grid name stored in the field identifier.\n"
+  EKAT_REQUIRE_MSG(grid == nullptr ||
+                       f.get_header().get_identifier().get_grid_name() == grid->name(),
+                   "Error! The name of the input grid does not match the grid name stored in the "
+                   "field identifier.\n"
                    "  - Field name: " +
                        f.name() +
                        "\n"
@@ -46,25 +53,27 @@ FieldWithinIntervalCheck::FieldWithinIntervalCheck(const Field &f, const std::sh
     std::stringstream lb, lbrep;
     lb << m_lb;
     lbrep << lb_repairable;
-    EKAT_REQUIRE_MSG(lb_repairable <= m_lb, "Error! The repairable lower bound is tighter than the lower bound.\n"
-                                            "       The idea is that the check fails, but it is still repairable\n"
-                                            "       if lb_repairable <= F < lb.\n"
-                                            "  - Lower bound: " +
-                                                lb.str() +
-                                                "\n"
-                                                "  - Repairable lower bound: " +
-                                                lbrep.str() + "\n");
+    EKAT_REQUIRE_MSG(lb_repairable <= m_lb,
+                     "Error! The repairable lower bound is tighter than the lower bound.\n"
+                     "       The idea is that the check fails, but it is still repairable\n"
+                     "       if lb_repairable <= F < lb.\n"
+                     "  - Lower bound: " +
+                         lb.str() +
+                         "\n"
+                         "  - Repairable lower bound: " +
+                         lbrep.str() + "\n");
     std::stringstream ub, ubrep;
     ub << m_ub;
     ubrep << ub_repairable;
-    EKAT_REQUIRE_MSG(ub_repairable >= m_ub, "Error! The repairable upper bound is tighter than the upper bound.\n"
-                                            "       The idea is that the check fails, but it is still repairable\n"
-                                            "       if ub < F <= ub_repairable.\n"
-                                            "  - Upper bound: " +
-                                                ub.str() +
-                                                "\n"
-                                                "  - Repairable upper bound: " +
-                                                ubrep.str() + "\n");
+    EKAT_REQUIRE_MSG(ub_repairable >= m_ub,
+                     "Error! The repairable upper bound is tighter than the upper bound.\n"
+                     "       The idea is that the check fails, but it is still repairable\n"
+                     "       if ub < F <= ub_repairable.\n"
+                     "  - Upper bound: " +
+                         ub.str() +
+                         "\n"
+                         "  - Repairable upper bound: " +
+                         ubrep.str() + "\n");
 
     m_ub_repairable = ub_repairable;
     m_lb_repairable = lb_repairable;
diff --git i/components/eamxx/src/share/property_checks/field_within_interval_check.hpp w/components/eamxx/src/share/property_checks/field_within_interval_check.hpp
index fd62ae3ec9..1de921a18e 100644
--- i/components/eamxx/src/share/property_checks/field_within_interval_check.hpp
+++ w/components/eamxx/src/share/property_checks/field_within_interval_check.hpp
@@ -26,8 +26,9 @@ public:
   // they are set equal to lb/ub). If field is outside [lb,ub], but inside
   // [lb_rep,ub_rep], we return a "Repairable" check result, rather than a Fail.
   FieldWithinIntervalCheck(const Field &field, const std::shared_ptr<const AbstractGrid> &grid,
-                           const double lower_bound, const double upper_bound, const bool can_repair = false,
-                           const double lb_repairable = -s_max, const double ub_repairable = s_max);
+                           const double lower_bound, const double upper_bound,
+                           const bool can_repair = false, const double lb_repairable = -s_max,
+                           const double ub_repairable = s_max);
 
   // The name of the property check
   std::string name() const override;
diff --git i/components/eamxx/src/share/property_checks/mass_and_energy_column_conservation_check.cpp w/components/eamxx/src/share/property_checks/mass_and_energy_column_conservation_check.cpp
index de5f772d6e..c9b66016fb 100644
--- i/components/eamxx/src/share/property_checks/mass_and_energy_column_conservation_check.cpp
+++ w/components/eamxx/src/share/property_checks/mass_and_energy_column_conservation_check.cpp
@@ -7,11 +7,13 @@
 namespace scream {
 
 MassAndEnergyColumnConservationCheck::MassAndEnergyColumnConservationCheck(
-    const std::shared_ptr<const AbstractGrid> &grid, const Real mass_error_tolerance, const Real energy_error_tolerance,
-    const Field &pseudo_density, const Field &ps, const Field &phis, const Field &horiz_winds, const Field &T_mid,
-    const Field &qv, const Field &qc, const Field &qr, const Field &qi, const Field &vapor_flux,
+    const std::shared_ptr<const AbstractGrid> &grid, const Real mass_error_tolerance,
+    const Real energy_error_tolerance, const Field &pseudo_density, const Field &ps,
+    const Field &phis, const Field &horiz_winds, const Field &T_mid, const Field &qv,
+    const Field &qc, const Field &qr, const Field &qi, const Field &vapor_flux,
     const Field &water_flux, const Field &ice_flux, const Field &heat_flux)
-    : m_grid(grid), m_dt(std::nan("")), m_mass_tol(mass_error_tolerance), m_energy_tol(energy_error_tolerance) {
+    : m_grid(grid), m_dt(std::nan("")), m_mass_tol(mass_error_tolerance),
+      m_energy_tol(energy_error_tolerance) {
   m_num_cols = m_grid->get_num_local_dofs();
   m_num_levs = m_grid->get_num_vertical_levels();
 
@@ -55,7 +57,8 @@ void MassAndEnergyColumnConservationCheck::compute_current_mass() {
         const auto qi_i             = ekat::subview(qi, i);
         const auto qr_i             = ekat::subview(qr, i);
 
-        mass(i) = compute_total_mass_on_column(team, nlevs, pseudo_density_i, qv_i, qc_i, qi_i, qr_i);
+        mass(i) =
+            compute_total_mass_on_column(team, nlevs, pseudo_density_i, qv_i, qc_i, qi_i, qr_i);
       });
 }
 
@@ -85,8 +88,8 @@ void MassAndEnergyColumnConservationCheck::compute_current_energy() {
         const auto qc_i             = ekat::subview(qc, i);
         const auto qr_i             = ekat::subview(qr, i);
 
-        energy(i) = compute_total_energy_on_column(team, nlevs, pseudo_density_i, T_mid_i, horiz_winds_i, qv_i, qc_i,
-                                                   qr_i, ps(i), phis(i));
+        energy(i) = compute_total_energy_on_column(team, nlevs, pseudo_density_i, T_mid_i,
+                                                   horiz_winds_i, qv_i, qc_i, qr_i, ps(i), phis(i));
       });
 }
 
@@ -96,8 +99,9 @@ PropertyCheck::ResultAndMsg MassAndEnergyColumnConservationCheck::check() const
   const auto ncols = m_num_cols;
   const auto nlevs = m_num_levs;
 
-  EKAT_REQUIRE_MSG(!std::isnan(m_dt), "Error! Timestep dt must be set in MassAndEnergyConservationCheck "
-                                      "before running check().");
+  EKAT_REQUIRE_MSG(!std::isnan(m_dt),
+                   "Error! Timestep dt must be set in MassAndEnergyConservationCheck "
+                   "before running check().");
   auto dt = m_dt;
 
   const auto pseudo_density = m_fields.at("pseudo_density").get_view<const Real **>();
@@ -135,14 +139,16 @@ PropertyCheck::ResultAndMsg MassAndEnergyColumnConservationCheck::check() const
         const auto qr_i             = ekat::subview(qr, i);
 
         // Calculate total mass
-        const Real tm          = compute_total_mass_on_column(team, nlevs, pseudo_density_i, qv_i, qc_i, qi_i, qr_i);
+        const Real tm =
+            compute_total_mass_on_column(team, nlevs, pseudo_density_i, qv_i, qc_i, qi_i, qr_i);
         const Real previous_tm = mass(i);
 
         // Calculate expected total mass. Here, dt should be set to the timestep of the
         // subcycle for the process that called this check. This effectively scales the boundary
         // fluxes by 1/num_subcycles (dt = model_dt/num_subcycles) so that we only include
         // the expected change after one substep (not a full timestep).
-        const Real tm_exp = previous_tm + compute_mass_boundary_flux_on_column(vapor_flux(i), water_flux(i)) * dt;
+        const Real tm_exp =
+            previous_tm + compute_mass_boundary_flux_on_column(vapor_flux(i), water_flux(i)) * dt;
 
         // Calculate relative error of total mass
         const Real rel_err_mass = std::abs(tm - tm_exp) / previous_tm;
@@ -169,14 +175,16 @@ PropertyCheck::ResultAndMsg MassAndEnergyColumnConservationCheck::check() const
         const auto qr_i             = ekat::subview(qr, i);
 
         // Calculate total energy
-        const Real te = compute_total_energy_on_column(team, nlevs, pseudo_density_i, T_mid_i, horiz_winds_i, qv_i,
-                                                       qc_i, qr_i, ps(i), phis(i));
+        const Real te =
+            compute_total_energy_on_column(team, nlevs, pseudo_density_i, T_mid_i, horiz_winds_i,
+                                           qv_i, qc_i, qr_i, ps(i), phis(i));
         const Real previous_te = energy(i);
 
         // Calculate expected total energy. See the comment above for an explanation of dt.
         const Real te_exp =
-            previous_te +
-            compute_energy_boundary_flux_on_column(vapor_flux(i), water_flux(i), ice_flux(i), heat_flux(i)) * dt;
+            previous_te + compute_energy_boundary_flux_on_column(vapor_flux(i), water_flux(i),
+                                                                 ice_flux(i), heat_flux(i)) *
+                              dt;
 
         // Calculate relative error of total energy
         const Real rel_err_energy = std::abs(te - te_exp) / previous_te;
@@ -235,14 +243,16 @@ PropertyCheck::ResultAndMsg MassAndEnergyColumnConservationCheck::check() const
       msg << "\n    END OF ADDITIONAL DATA\n";
     }
     res_and_msg.fail_loc_indices.resize(1, maxloc_mass.loc);
-    res_and_msg.fail_loc_tags = m_fields.at("phis").get_header().get_identifier().get_layout().tags();
+    res_and_msg.fail_loc_tags =
+        m_fields.at("phis").get_header().get_identifier().get_layout().tags();
   }
   if (not energy_below_tol) {
     msg << "  - energy error tolerance: " << m_energy_tol << "\n";
     msg << "  - energy relative error: " << maxloc_energy.val << "\n"
         << "    - global dof: " << gids(maxloc_energy.loc) << "\n";
     if (has_latlon) {
-      msg << "    - (lat, lon): (" << lat(maxloc_energy.loc) << ", " << lon(maxloc_energy.loc) << ")\n";
+      msg << "    - (lat, lon): (" << lat(maxloc_energy.loc) << ", " << lon(maxloc_energy.loc)
+          << ")\n";
     }
     if (has_additional_col_info) {
       msg << "    - additional data (w/ local column index):\n";
@@ -254,7 +264,8 @@ PropertyCheck::ResultAndMsg MassAndEnergyColumnConservationCheck::check() const
       msg << "\n    END OF ADDITIONAL DATA\n";
     }
     res_and_msg.fail_loc_indices.resize(1, maxloc_energy.loc);
-    res_and_msg.fail_loc_tags = m_fields.at("phis").get_header().get_identifier().get_layout().tags();
+    res_and_msg.fail_loc_tags =
+        m_fields.at("phis").get_header().get_identifier().get_layout().tags();
   }
 
   res_and_msg.msg = msg.str();
@@ -263,12 +274,10 @@ PropertyCheck::ResultAndMsg MassAndEnergyColumnConservationCheck::check() const
 }
 
 KOKKOS_INLINE_FUNCTION
-Real MassAndEnergyColumnConservationCheck::compute_total_mass_on_column(const KT::MemberType &team, const int nlevs,
-                                                                        const uview_1d<const Real> &pseudo_density,
-                                                                        const uview_1d<const Real> &qv,
-                                                                        const uview_1d<const Real> &qc,
-                                                                        const uview_1d<const Real> &qi,
-                                                                        const uview_1d<const Real> &qr) {
+Real MassAndEnergyColumnConservationCheck::compute_total_mass_on_column(
+    const KT::MemberType &team, const int nlevs, const uview_1d<const Real> &pseudo_density,
+    const uview_1d<const Real> &qv, const uview_1d<const Real> &qc, const uview_1d<const Real> &qi,
+    const uview_1d<const Real> &qr) {
   using PC = scream::physics::Constants<Real>;
 
   const Real gravit = PC::gravit;
@@ -279,8 +288,8 @@ Real MassAndEnergyColumnConservationCheck::compute_total_mass_on_column(const KT
 }
 
 KOKKOS_INLINE_FUNCTION
-Real MassAndEnergyColumnConservationCheck::compute_mass_boundary_flux_on_column(const Real vapor_flux,
-                                                                                const Real water_flux) {
+Real MassAndEnergyColumnConservationCheck::compute_mass_boundary_flux_on_column(
+    const Real vapor_flux, const Real water_flux) {
   using PC           = scream::physics::Constants<Real>;
   const Real RHO_H2O = PC::RHO_H2O;
 
@@ -290,32 +299,32 @@ Real MassAndEnergyColumnConservationCheck::compute_mass_boundary_flux_on_column(
 KOKKOS_INLINE_FUNCTION
 Real MassAndEnergyColumnConservationCheck::compute_total_energy_on_column(
     const KT::MemberType &team, const int nlevs, const uview_1d<const Real> &pseudo_density,
-    const uview_1d<const Real> &T_mid, const uview_2d<const Real> &horiz_winds, const uview_1d<const Real> &qv,
-    const uview_1d<const Real> &qc, const uview_1d<const Real> &qr, const Real ps, const Real phis) {
+    const uview_1d<const Real> &T_mid, const uview_2d<const Real> &horiz_winds,
+    const uview_1d<const Real> &qv, const uview_1d<const Real> &qc, const uview_1d<const Real> &qr,
+    const Real ps, const Real phis) {
   using PC          = scream::physics::Constants<Real>;
   const Real LatVap = PC::LatVap;
   const Real LatIce = PC::LatIce;
   const Real gravit = PC::gravit;
   const Real Cpair  = PC::Cpair;
 
-  Real total_energy = ExeSpaceUtils::parallel_reduce<Real>(team, 0, nlevs, [&](const int lev, Real &local_energy) {
-    const auto u2 = horiz_winds(0, lev) * horiz_winds(0, lev);
-    const auto v2 = horiz_winds(1, lev) * horiz_winds(1, lev);
+  Real total_energy =
+      ExeSpaceUtils::parallel_reduce<Real>(team, 0, nlevs, [&](const int lev, Real &local_energy) {
+        const auto u2 = horiz_winds(0, lev) * horiz_winds(0, lev);
+        const auto v2 = horiz_winds(1, lev) * horiz_winds(1, lev);
 
-    local_energy +=
-        (T_mid(lev) * Cpair + 0.5 * (u2 + v2) + (LatVap + LatIce) * qv(lev) + LatIce * (qc(lev) + qr(lev))) *
-        pseudo_density(lev) / gravit;
-  });
+        local_energy += (T_mid(lev) * Cpair + 0.5 * (u2 + v2) + (LatVap + LatIce) * qv(lev) +
+                         LatIce * (qc(lev) + qr(lev))) *
+                        pseudo_density(lev) / gravit;
+      });
   total_energy += phis * ps / gravit;
 
   return total_energy;
 }
 
 KOKKOS_INLINE_FUNCTION
-Real MassAndEnergyColumnConservationCheck::compute_energy_boundary_flux_on_column(const Real vapor_flux,
-                                                                                  const Real water_flux,
-                                                                                  const Real ice_flux,
-                                                                                  const Real heat_flux) {
+Real MassAndEnergyColumnConservationCheck::compute_energy_boundary_flux_on_column(
+    const Real vapor_flux, const Real water_flux, const Real ice_flux, const Real heat_flux) {
   using PC           = scream::physics::Constants<Real>;
   const Real LatVap  = PC::LatVap;
   const Real LatIce  = PC::LatIce;
diff --git i/components/eamxx/src/share/property_checks/mass_and_energy_column_conservation_check.hpp w/components/eamxx/src/share/property_checks/mass_and_energy_column_conservation_check.hpp
index c74b2e3825..58c136b87a 100644
--- i/components/eamxx/src/share/property_checks/mass_and_energy_column_conservation_check.hpp
+++ w/components/eamxx/src/share/property_checks/mass_and_energy_column_conservation_check.hpp
@@ -24,13 +24,13 @@ class MassAndEnergyColumnConservationCheck : public PropertyCheck {
 
 public:
   // Constructor
-  MassAndEnergyColumnConservationCheck(const std::shared_ptr<const AbstractGrid> &grid, const Real mass_error_tolerance,
-                                       const Real energy_error_tolerance, const Field &pseudo_density_ptr,
-                                       const Field &ps_ptr, const Field &phis_ptr, const Field &horiz_winds_ptr,
-                                       const Field &T_mid_ptr, const Field &qv_ptr, const Field &qc_ptr,
-                                       const Field &qr_ptr, const Field &qi_ptr, const Field &vapor_flux_ptr,
-                                       const Field &water_flux_ptr, const Field &ice_flux_ptr,
-                                       const Field &heat_flux_ptr);
+  MassAndEnergyColumnConservationCheck(
+      const std::shared_ptr<const AbstractGrid> &grid, const Real mass_error_tolerance,
+      const Real energy_error_tolerance, const Field &pseudo_density_ptr, const Field &ps_ptr,
+      const Field &phis_ptr, const Field &horiz_winds_ptr, const Field &T_mid_ptr,
+      const Field &qv_ptr, const Field &qc_ptr, const Field &qr_ptr, const Field &qi_ptr,
+      const Field &vapor_flux_ptr, const Field &water_flux_ptr, const Field &ice_flux_ptr,
+      const Field &heat_flux_ptr);
 
   // The name of the property check
   std::string name() const override { return "Mass and energy column conservation check"; }
@@ -66,23 +66,25 @@ protected:
 
   KOKKOS_INLINE_FUNCTION
   static Real compute_total_mass_on_column(const KT::MemberType &team, const int nlevs,
-                                           const uview_1d<const Real> &pseudo_density, const uview_1d<const Real> &qv,
-                                           const uview_1d<const Real> &qc, const uview_1d<const Real> &qi,
+                                           const uview_1d<const Real> &pseudo_density,
+                                           const uview_1d<const Real> &qv,
+                                           const uview_1d<const Real> &qc,
+                                           const uview_1d<const Real> &qi,
                                            const uview_1d<const Real> &qr);
 
   KOKKOS_INLINE_FUNCTION
   static Real compute_mass_boundary_flux_on_column(const Real vapor_flux, const Real water_flux);
 
   KOKKOS_INLINE_FUNCTION
-  static Real compute_total_energy_on_column(const KT::MemberType &team, const int nlevs,
-                                             const uview_1d<const Real> &pseudo_density,
-                                             const uview_1d<const Real> &T_mid, const uview_2d<const Real> &horiz_winds,
-                                             const uview_1d<const Real> &qv, const uview_1d<const Real> &qc,
-                                             const uview_1d<const Real> &qr, const Real ps, const Real phis);
+  static Real compute_total_energy_on_column(
+      const KT::MemberType &team, const int nlevs, const uview_1d<const Real> &pseudo_density,
+      const uview_1d<const Real> &T_mid, const uview_2d<const Real> &horiz_winds,
+      const uview_1d<const Real> &qv, const uview_1d<const Real> &qc,
+      const uview_1d<const Real> &qr, const Real ps, const Real phis);
 
   KOKKOS_INLINE_FUNCTION
-  static Real compute_energy_boundary_flux_on_column(const Real vapor_flux, const Real water_flux, const Real ice_flux,
-                                                     const Real heat_flux);
+  static Real compute_energy_boundary_flux_on_column(const Real vapor_flux, const Real water_flux,
+                                                     const Real ice_flux, const Real heat_flux);
 
 protected:
   std::shared_ptr<const AbstractGrid> m_grid;
diff --git i/components/eamxx/src/share/property_checks/property_check.cpp w/components/eamxx/src/share/property_checks/property_check.cpp
index 0e78aa94ad..1f6c767c4f 100644
--- i/components/eamxx/src/share/property_checks/property_check.cpp
+++ w/components/eamxx/src/share/property_checks/property_check.cpp
@@ -20,19 +20,21 @@ void PropertyCheck::set_fields(const std::list<Field> &fields, const std::list<b
   EKAT_REQUIRE_MSG(fields.size() > 0, "Error! Input fields list is empty.\n"
                                       "  - PropertyCheck name: " +
                                           name() + "\n");
-  EKAT_REQUIRE_MSG(repairable.size() == fields.size(), "Error! The method 'set_fields' requires lists of same size.\n"
-                                                       "  - Fields list size: " +
-                                                           std::to_string(fields.size()) +
-                                                           "\n"
-                                                           "  - Repairable list size: " +
-                                                           std::to_string(repairable.size()) + "\n");
+  EKAT_REQUIRE_MSG(repairable.size() == fields.size(),
+                   "Error! The method 'set_fields' requires lists of same size.\n"
+                   "  - Fields list size: " +
+                       std::to_string(fields.size()) +
+                       "\n"
+                       "  - Repairable list size: " +
+                       std::to_string(repairable.size()) + "\n");
   for (const auto &f : fields) {
-    EKAT_REQUIRE_MSG(f.is_allocated(), "Error! Fields must be allocated *before* being set in a PropertyCheck.\n"
-                                       "  - PropertyCheck name: " +
-                                           name() +
-                                           "\n"
-                                           "  - Field name: " +
-                                           f.name() + "\n");
+    EKAT_REQUIRE_MSG(f.is_allocated(),
+                     "Error! Fields must be allocated *before* being set in a PropertyCheck.\n"
+                     "  - PropertyCheck name: " +
+                         name() +
+                         "\n"
+                         "  - Field name: " +
+                         f.name() + "\n");
   }
 
   // Do an additional sanity check: the repairable fields must be
@@ -42,12 +44,13 @@ void PropertyCheck::set_fields(const std::list<Field> &fields, const std::list<b
   auto it_b = repairable.begin();
   for (; it_b != repairable.end(); ++it_b, ++it_f) {
     if (*it_b) {
-      EKAT_REQUIRE_MSG(not it_f->is_read_only(), "Error! One of the repairable fields is read only.\n"
-                                                 "  - PropertyCheck name: " +
-                                                     name() +
-                                                     "\n"
-                                                     "  - Field name: " +
-                                                     it_f->name() + "\n");
+      EKAT_REQUIRE_MSG(not it_f->is_read_only(),
+                       "Error! One of the repairable fields is read only.\n"
+                       "  - PropertyCheck name: " +
+                           name() +
+                           "\n"
+                           "  - Field name: " +
+                           it_f->name() + "\n");
 
       m_repairable_fields.push_back(&(*it_f));
     }
@@ -56,12 +59,13 @@ void PropertyCheck::set_fields(const std::list<Field> &fields, const std::list<b
 
 void PropertyCheck::set_additional_data_field(const Field &data_field) {
   EKAT_REQUIRE_MSG(data_field.get_header().get_identifier().get_layout().has_tag(FieldTag::Column),
-                   "Error! Additional data field \"" + data_field.name() + "\" for property check \"" + name() +
-                       "\" must be defined on columns.\n");
+                   "Error! Additional data field \"" + data_field.name() +
+                       "\" for property check \"" + name() + "\" must be defined on columns.\n");
 
   // Only add field if it currently does not exist in additional fields list.
-  const bool found_field_in_list = std::find(m_additional_data_fields.begin(), m_additional_data_fields.end(),
-                                             data_field) != m_additional_data_fields.end();
+  const bool found_field_in_list =
+      std::find(m_additional_data_fields.begin(), m_additional_data_fields.end(), data_field) !=
+      m_additional_data_fields.end();
   if (not found_field_in_list) {
     m_additional_data_fields.push_back(data_field);
   }
@@ -69,9 +73,10 @@ void PropertyCheck::set_additional_data_field(const Field &data_field) {
 
 // If a check fails, attempt to repair things. Default is to throw.
 void PropertyCheck::repair() const {
-  EKAT_REQUIRE_MSG(can_repair(), "Error! The method 'repair' was called despite can_repair() returns false.\n"
-                                 "  PropertyCheck name: " +
-                                     name() + "\n");
+  EKAT_REQUIRE_MSG(can_repair(),
+                   "Error! The method 'repair' was called despite can_repair() returns false.\n"
+                   "  PropertyCheck name: " +
+                       name() + "\n");
 
   repair_impl();
 }
diff --git i/components/eamxx/src/share/tests/atm_process_tests.cpp w/components/eamxx/src/share/tests/atm_process_tests.cpp
index abca5df184..383694a2a7 100644
--- i/components/eamxx/src/share/tests/atm_process_tests.cpp
+++ w/components/eamxx/src/share/tests/atm_process_tests.cpp
@@ -67,7 +67,8 @@ std::shared_ptr<GridsManager> create_gm(const ekat::Comm &comm) {
 class DummyDiag : public AtmosphereDiagnostic {
 
 public:
-  DummyDiag(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereDiagnostic(comm, params) {
+  DummyDiag(const ekat::Comm &comm, const ekat::ParameterList &params)
+      : AtmosphereDiagnostic(comm, params) {
     m_name      = params.name();
     m_grid_name = params.get<std::string>("grid_name");
   }
@@ -120,7 +121,8 @@ protected:
 
 class DiagIdentity : public DummyDiag {
 public:
-  DiagIdentity(const ekat::Comm &comm, const ekat::ParameterList &params) : DummyDiag(comm, params) {
+  DiagIdentity(const ekat::Comm &comm, const ekat::ParameterList &params)
+      : DummyDiag(comm, params) {
     // Nothing to do here
   }
 
@@ -190,7 +192,8 @@ protected:
 // A dummy atm proc
 class DummyProcess : public scream::AtmosphereProcess {
 public:
-  DummyProcess(const ekat::Comm &comm, const ekat::ParameterList &params) : AtmosphereProcess(comm, params) {
+  DummyProcess(const ekat::Comm &comm, const ekat::ParameterList &params)
+      : AtmosphereProcess(comm, params) {
     m_name      = params.name();
     m_grid_name = params.get<std::string>("grid_name");
   }
diff --git i/components/eamxx/src/share/tests/coarsening_remapper_tests.cpp w/components/eamxx/src/share/tests/coarsening_remapper_tests.cpp
index 56c9da8fb1..3a6d8ba8c0 100644
--- i/components/eamxx/src/share/tests/coarsening_remapper_tests.cpp
+++ w/components/eamxx/src/share/tests/coarsening_remapper_tests.cpp
@@ -49,7 +49,8 @@ void root_print(const std::string &msg, const ekat::Comm &comm) {
 // Create a source grid given number of global dofs.
 // Dofs are scattered around randomly
 template <typename Engine>
-std::shared_ptr<AbstractGrid> build_src_grid(const ekat::Comm &comm, const int ngdofs, Engine &engine) {
+std::shared_ptr<AbstractGrid> build_src_grid(const ekat::Comm &comm, const int ngdofs,
+                                             Engine &engine) {
   using gid_type  = AbstractGrid::gid_type;
   const int nlevs = 20;
 
@@ -79,7 +80,8 @@ std::shared_ptr<AbstractGrid> build_src_grid(const ekat::Comm &comm, const int n
 constexpr int vec_dim   = 2;
 constexpr int tens_dim1 = 3;
 constexpr int tens_dim2 = 4;
-Field create_field(const std::string &name, const LayoutType lt, const AbstractGrid &grid, const bool midpoints) {
+Field create_field(const std::string &name, const LayoutType lt, const AbstractGrid &grid,
+                   const bool midpoints) {
   const auto u   = ekat::units::Units::nondimensional();
   const auto &gn = grid.name();
   Field f;
@@ -102,7 +104,8 @@ Field create_field(const std::string &name, const LayoutType lt, const AbstractG
     f.get_header().get_alloc_properties().request_allocation(SCREAM_PACK_SIZE);
     break;
   case LayoutType::Tensor3D:
-    f = Field(FieldIdentifier(name, grid.get_3d_tensor_layout(midpoints, {tens_dim1, tens_dim2}), u, gn));
+    f = Field(
+        FieldIdentifier(name, grid.get_3d_tensor_layout(midpoints, {tens_dim1, tens_dim2}), u, gn));
     f.get_header().get_alloc_properties().request_allocation(SCREAM_PACK_SIZE);
     break;
   default:
@@ -114,8 +117,8 @@ Field create_field(const std::string &name, const LayoutType lt, const AbstractG
 }
 
 template <typename Engine>
-Field create_field(const std::string &name, const LayoutType lt, const AbstractGrid &grid, const bool midpoints,
-                   Engine &engine) {
+Field create_field(const std::string &name, const LayoutType lt, const AbstractGrid &grid,
+                   const bool midpoints, Engine &engine) {
   auto f = create_field(name, lt, grid, midpoints);
 
   // Use discrete_distribution to get an integer, then use that as exponent for 2^-n.
diff --git i/components/eamxx/src/share/tests/column_ops.cpp w/components/eamxx/src/share/tests/column_ops.cpp
index c444b2805e..2443068fc8 100644
--- i/components/eamxx/src/share/tests/column_ops.cpp
+++ w/components/eamxx/src/share/tests/column_ops.cpp
@@ -258,7 +258,8 @@ TEST_CASE("column_ops_ps_1") {
           auto v_i       = ekat::subview(v_int, icol);
           auto v_m       = ekat::subview(v_mid, icol);
 
-          column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m, 2 * num_levs + 1, v_i);
+          column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m,
+                                                                 2 * num_levs + 1, v_i);
         });
     Kokkos::fence();
 
@@ -277,7 +278,8 @@ TEST_CASE("column_ops_ps_1") {
           auto v_m = [&](const int k) -> pack_type { return v_mid(icol, k); };
           auto v_i = ekat::subview(v_int, icol);
 
-          column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m, 2 * num_levs + 1, v_i);
+          column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m,
+                                                                 2 * num_levs + 1, v_i);
         });
     Kokkos::fence();
 
@@ -333,7 +335,8 @@ TEST_CASE("column_ops_ps_1") {
 
           column_ops::compute_midpoint_values(team, num_levs, v_i, v_m);
           team.team_barrier();
-          column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m, 2 * num_levs + 1, v_i);
+          column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m,
+                                                                 2 * num_levs + 1, v_i);
         });
     Kokkos::fence();
 
@@ -595,7 +598,8 @@ TEST_CASE("column_ops_ps_N") {
               auto v_m       = ekat::subview(v_mid, icol);
               auto dz        = ekat::subview(dz_mid, icol);
 
-              column_ops::compute_interface_values_linear(team, num_levs, v_m, dz, bc_top, bc_bot, v_i);
+              column_ops::compute_interface_values_linear(team, num_levs, v_m, dz, bc_top, bc_bot,
+                                                          v_i);
             });
         Kokkos::fence();
 
@@ -635,7 +639,8 @@ TEST_CASE("column_ops_ps_N") {
 
               column_ops::compute_midpoint_values(team, num_levs, v_i, v_m);
               team.team_barrier();
-              column_ops::compute_interface_values_linear(team, num_levs, v_m, dz, bc_top, bc_bot, v_i);
+              column_ops::compute_interface_values_linear(team, num_levs, v_m, dz, bc_top, bc_bot,
+                                                          v_i);
             });
         Kokkos::fence();
 
@@ -716,7 +721,8 @@ TEST_CASE("column_ops_ps_N") {
               auto v_i       = ekat::subview(v_int, icol);
               auto v_m       = ekat::subview(v_mid, icol);
 
-              column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m, 2 * num_levs + 1, v_i);
+              column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m,
+                                                                     2 * num_levs + 1, v_i);
             });
         Kokkos::fence();
 
@@ -737,7 +743,8 @@ TEST_CASE("column_ops_ps_N") {
               auto v_m = [&](const int k) -> pack_type { return v_mid(icol, k); };
               auto v_i = ekat::subview(v_int, icol);
 
-              column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m, 2 * num_levs + 1, v_i);
+              column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m,
+                                                                     2 * num_levs + 1, v_i);
             });
         Kokkos::fence();
 
@@ -801,7 +808,8 @@ TEST_CASE("column_ops_ps_N") {
 
               column_ops::compute_midpoint_values(team, num_levs, v_i, v_m);
               team.team_barrier();
-              column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m, 2 * num_levs + 1, v_i);
+              column_ops::compute_interface_values_compatible<false>(team, num_levs, v_m,
+                                                                     2 * num_levs + 1, v_i);
             });
         Kokkos::fence();
 
diff --git i/components/eamxx/src/share/tests/common_physics_functions_tests.cpp w/components/eamxx/src/share/tests/common_physics_functions_tests.cpp
index bfcf7666e2..3bfc60f4df 100644
--- i/components/eamxx/src/share/tests/common_physics_functions_tests.cpp
+++ w/components/eamxx/src/share/tests/common_physics_functions_tests.cpp
@@ -16,7 +16,9 @@ namespace {
 
 template <typename ScalarT, int NumLevels> struct ChecksHelpers {
 
-  static bool is_non_negative(const ScalarT &s, const int k) { return not(k < NumLevels && (s < 0 || std::isnan(s))); }
+  static bool is_non_negative(const ScalarT &s, const int k) {
+    return not(k < NumLevels && (s < 0 || std::isnan(s)));
+  }
   static bool equal(const ScalarT &lhs, const ScalarT &rhs) { return lhs == rhs; }
   static bool approx_equal(const ScalarT lhs, const ScalarT rhs, const int k, const ScalarT tol) {
     using std::abs;
@@ -49,10 +51,10 @@ template <typename T, int N, int NumLevels> struct ChecksHelpers<ekat::Pack<T, N
 
 template <typename DeviceT> void run_scalar_valued_fns(std::mt19937_64 &engine) {
   /*
-  Most of the common physics functions are templated to operate on scalars or on packs of vertical indices.
-  The functions tested here don't include any vertical dimension (e.g. they handle variables only defined
-  at the surface), so are only defined for scalar reals. This is fundamentally different than the other
-  functions, so these functions get their own run test.
+  Most of the common physics functions are templated to operate on scalars or on packs of vertical
+  indices. The functions tested here don't include any vertical dimension (e.g. they handle
+  variables only defined at the surface), so are only defined for scalar reals. This is
+  fundamentally different than the other functions, so these functions get their own run test.
   */
 
   using RealType = scream::Real;
@@ -83,10 +85,13 @@ template <typename DeviceT> void run_scalar_valued_fns(std::mt19937_64 &engine)
 
   // lapse_T_for_psl property tests:
   // If T_ground = 0, T_ground_tmp should be 255/2 and lapse should be 0.0065 Really cold case.
-  // If T_ground = 300 K with phi_ground>0 m2/s2, lapse = 0 and T_ground_tmp=0.5*(290.5+T_ground). Really hot case.
-  // If T_ground = 290 K and phi_ground=10000 m2/s2, T_ground_tmp=T_ground and lapse
-  //    is such that T_sl=T_ground+lapse*phi_ground/gravit is within roundoff of 290.5 K. Marginally hot case.
-  // If T_ground = 280 K and phi_ground=100 m2/s2, T_ground_tmp=T_ground and lapse=6.5 K/km (typical conditions)
+  // If T_ground = 300 K with phi_ground>0 m2/s2, lapse = 0 and T_ground_tmp=0.5*(290.5+T_ground).
+  // Really hot case. If T_ground = 290 K and phi_ground=10000 m2/s2, T_ground_tmp=T_ground and
+  // lapse
+  //    is such that T_sl=T_ground+lapse*phi_ground/gravit is within roundoff of 290.5 K. Marginally
+  //    hot case.
+  // If T_ground = 280 K and phi_ground=100 m2/s2, T_ground_tmp=T_ground and lapse=6.5 K/km (typical
+  // conditions)
   RealType lapse;
   RealType T_ground_tmp;
   RealType T_ground   = 0;
@@ -148,11 +153,12 @@ template <typename DeviceT> void run_scalar_valued_fns(std::mt19937_64 &engine)
   lat = 45.0;
   REQUIRE(Check::approx_equal(PF::calculate_dx_from_area(area, lat), coeff_1 - coeff_3, test_tol));
   lat = 22.5;
-  REQUIRE(
-      Check::approx_equal(PF::calculate_dx_from_area(area, lat), coeff_1 - std::sqrt(2.0) / 2.0 * coeff_2, test_tol));
+  REQUIRE(Check::approx_equal(PF::calculate_dx_from_area(area, lat),
+                              coeff_1 - std::sqrt(2.0) / 2.0 * coeff_2, test_tol));
   lat  = pdf_lat(engine);
   area = pdf_area(engine);
-  REQUIRE(Check::equal(PF::calculate_dx_from_area(area, lat), PF::calculate_dx_from_area(area, -lat)));
+  REQUIRE(
+      Check::equal(PF::calculate_dx_from_area(area, lat), PF::calculate_dx_from_area(area, -lat)));
 }
 
 //-----------------------------------------------------------------------------------------------//
@@ -186,30 +192,34 @@ template <typename ScalarT, typename DeviceT> void run(std::mt19937_64 &engine)
   using Check = ChecksHelpers<ScalarT, num_levs>;
 
   // Input (randomized) views
-  view_1d temperature("temperature", num_mid_packs), height("height", num_mid_packs), qv("qv", num_mid_packs),
-      qv_dry("qv_dry", num_mid_packs), qv_wet("qv_wet", num_mid_packs), pressure("pressure", num_mid_packs),
-      pseudo_density("pseudo_density", num_mid_packs), dz_for_testing("dz_for_testing", num_mid_packs),
+  view_1d temperature("temperature", num_mid_packs), height("height", num_mid_packs),
+      qv("qv", num_mid_packs), qv_dry("qv_dry", num_mid_packs), qv_wet("qv_wet", num_mid_packs),
+      pressure("pressure", num_mid_packs), pseudo_density("pseudo_density", num_mid_packs),
+      dz_for_testing("dz_for_testing", num_mid_packs),
       mmr_for_testing("mass_mixing_ratio_for_testing", num_mid_packs),
       wetmmr_for_testing("wet_mass_mixing_ratio_for_testing", num_mid_packs);
   // Output views
-  view_1d exner("exner", num_mid_packs), theta("theta", num_mid_packs), T_from_Theta("T_from_Theta", num_mid_packs),
-      Tv("T_virtual", num_mid_packs), T_from_Tv("T_from_T_virtual", num_mid_packs), dse("dse", num_mid_packs),
-      T_from_dse("T_from_dse", num_mid_packs), dz("dz", num_mid_packs), z_int("z_int", num_int_packs),
-      vmr("volume_mixing_ratio", num_mid_packs), mmr("mass_mixing_ratio", num_mid_packs),
-      wetmmr("wet_mass_mixing_ratio", num_mid_packs), drymmr("dry_mass_mixing_ratio", num_mid_packs),
-      density("density", num_mid_packs);
+  view_1d exner("exner", num_mid_packs), theta("theta", num_mid_packs),
+      T_from_Theta("T_from_Theta", num_mid_packs), Tv("T_virtual", num_mid_packs),
+      T_from_Tv("T_from_T_virtual", num_mid_packs), dse("dse", num_mid_packs),
+      T_from_dse("T_from_dse", num_mid_packs), dz("dz", num_mid_packs),
+      z_int("z_int", num_int_packs), vmr("volume_mixing_ratio", num_mid_packs),
+      mmr("mass_mixing_ratio", num_mid_packs), wetmmr("wet_mass_mixing_ratio", num_mid_packs),
+      drymmr("dry_mass_mixing_ratio", num_mid_packs), density("density", num_mid_packs);
 
   auto dview_as_real = [&](const view_1d &v) -> rview_1d {
     return rview_1d(reinterpret_cast<RealType *>(v.data()), v.size() * pack_size);
   };
   auto hview_as_real = [&](const typename view_1d::HostMirror &v) -> typename rview_1d::HostMirror {
-    return typename rview_1d::HostMirror(reinterpret_cast<RealType *>(v.data()), v.size() * pack_size);
+    return
+        typename rview_1d::HostMirror(reinterpret_cast<RealType *>(v.data()), v.size() * pack_size);
   };
 
   // Construct random input data
   using RPDF = std::uniform_real_distribution<RealType>;
-  RPDF pdf_qv(1e-6, 1e-3), pdf_dp(1.0, 100.0), pdf_pres(0.0, PC::P0), pdf_temp(200.0, 400.0), pdf_height(0.0, 1e5),
-      pdf_dz(1.0, 1e5), pdf_surface(100.0, 400.0), pdf_mmr(0, 0.99), pdf_dse(1e5, 5e5);
+  RPDF pdf_qv(1e-6, 1e-3), pdf_dp(1.0, 100.0), pdf_pres(0.0, PC::P0), pdf_temp(200.0, 400.0),
+      pdf_height(0.0, 1e5), pdf_dz(1.0, 1e5), pdf_surface(100.0, 400.0), pdf_mmr(0, 0.99),
+      pdf_dse(1e5, 5e5);
 
   // contruct random integers
   using IPDF = std::uniform_int_distribution<int>;
@@ -285,8 +295,10 @@ template <typename ScalarT, typename DeviceT> void run(std::mt19937_64 &engine)
   REQUIRE(Check::equal(PF::calculate_theta_from_T(zero, p), zero));
   REQUIRE(Check::equal(PF::calculate_T_from_theta(theta0, p0), theta0));
   REQUIRE(Check::equal(PF::calculate_T_from_theta(zero, p), zero));
-  REQUIRE(Check::approx_equal(PF::calculate_T_from_theta(PF::calculate_theta_from_T(T0, p), p), T0, test_tol));
-  REQUIRE(Check::approx_equal(PF::calculate_theta_from_T(PF::calculate_T_from_theta(theta0, p), p), theta0, test_tol));
+  REQUIRE(Check::approx_equal(PF::calculate_T_from_theta(PF::calculate_theta_from_T(T0, p), p), T0,
+                              test_tol));
+  REQUIRE(Check::approx_equal(PF::calculate_theta_from_T(PF::calculate_T_from_theta(theta0, p), p),
+                              theta0, test_tol));
 
   // Virtual temperature property tests:
   //  - T_virt(T=0) = 0.0
@@ -306,25 +318,32 @@ template <typename ScalarT, typename DeviceT> void run(std::mt19937_64 &engine)
   tmp = PF::calculate_temperature_from_virtual_temperature(T0, qv0);
   REQUIRE(Check::approx_equal(PF::calculate_virtual_temperature(tmp, qv0), T0, test_tol));
   tmp = PF::calculate_virtual_temperature(T0, qv0);
-  REQUIRE(Check::approx_equal(PF::calculate_temperature_from_virtual_temperature(tmp, qv0), T0, test_tol));
+  REQUIRE(Check::approx_equal(PF::calculate_temperature_from_virtual_temperature(tmp, qv0), T0,
+                              test_tol));
 
   // DSE property tests:
   //  - calculate_dse(T=0.0, z=0.0) = surf_height
   //  - calculate_dse(T=1/cp, z=1/gravity) = surf_height+2
-  //  - calculate_temperature_from_dse(dse=cp, z=cp/gravity) = -1.0*surf_height/cp (up to roundoff errors)
-  //  - calculate_dse and calculate_temperature_from_dse are one the inverse of the other (up to roundoff errors)
+  //  - calculate_temperature_from_dse(dse=cp, z=cp/gravity) = -1.0*surf_height/cp (up to roundoff
+  //  errors)
+  //  - calculate_dse and calculate_temperature_from_dse are one the inverse of the other (up to
+  //  roundoff errors)
   surf_height = pdf_surface(engine);
   z0          = pdf_height(engine);
   dse0        = pdf_dse(engine);
   T0          = pdf_temp(engine);
   REQUIRE(Check::equal(PF::calculate_dse(zero, zero, surf_height), ScalarT(surf_height)));
-  REQUIRE(Check::equal(PF::calculate_dse(ScalarT(inv_cp), ScalarT(1 / g), surf_height), ScalarT(surf_height + 2.0)));
-  REQUIRE(Check::approx_equal(PF::calculate_temperature_from_dse(ScalarT(cp), ScalarT(cp / g), surf_height),
-                              ScalarT(-1.0 * surf_height / cp), test_tol));
+  REQUIRE(Check::equal(PF::calculate_dse(ScalarT(inv_cp), ScalarT(1 / g), surf_height),
+                       ScalarT(surf_height + 2.0)));
   REQUIRE(Check::approx_equal(
-      PF::calculate_dse(PF::calculate_temperature_from_dse(dse0, z0, surf_height), z0, surf_height), dse0, test_tol));
+      PF::calculate_temperature_from_dse(ScalarT(cp), ScalarT(cp / g), surf_height),
+      ScalarT(-1.0 * surf_height / cp), test_tol));
   REQUIRE(Check::approx_equal(
-      PF::calculate_temperature_from_dse(PF::calculate_dse(T0, z0, surf_height), z0, surf_height), T0, test_tol));
+      PF::calculate_dse(PF::calculate_temperature_from_dse(dse0, z0, surf_height), z0, surf_height),
+      dse0, test_tol));
+  REQUIRE(Check::approx_equal(
+      PF::calculate_temperature_from_dse(PF::calculate_dse(T0, z0, surf_height), z0, surf_height),
+      T0, test_tol));
 
   // WETMMR to DRYMMR (and vice versa) property tests
   wetmmr0 = pdf_mmr(engine); // get initial wet mmr
@@ -333,17 +352,21 @@ template <typename ScalarT, typename DeviceT> void run(std::mt19937_64 &engine)
   qv_dry0 = pdf_qv(engine);  // get initial qv in dry mmr
   // mmr_test1: For zero drymmr, wetmmr should be zero
   // mmr_test2: For zero wetmmr, drymmr should be zero
-  // mmr_test3: Compute drymmr from wetmmr0 and then use the result to compute wetmmr, which should be approximately
-  //            equal to wetmmr0. NOTE: calculate_wetmmr_from_drymmr takes qv in dry mmr as an argument and
-  //            calculate_drymmr_from_wetmmr takes qv in wet mmr as an argument. Therefore, we need to convert
-  //            qv from wet mmr to dry mmr as well as part of these conversions
+  // mmr_test3: Compute drymmr from wetmmr0 and then use the result to compute wetmmr, which should
+  // be approximately
+  //            equal to wetmmr0. NOTE: calculate_wetmmr_from_drymmr takes qv in dry mmr as an
+  //            argument and calculate_drymmr_from_wetmmr takes qv in wet mmr as an argument.
+  //            Therefore, we need to convert qv from wet mmr to dry mmr as well as part of these
+  //            conversions
 
   REQUIRE(Check::equal(PF::calculate_wetmmr_from_drymmr(zero, qv_dry0), zero)); // mmr_test1
   REQUIRE(Check::equal(PF::calculate_drymmr_from_wetmmr(zero, qv_wet0), zero)); // mmr_test2
 
   // mmr_test3
-  drymmr0 = PF::calculate_drymmr_from_wetmmr(wetmmr0, qv_wet0); // get drymmr from wetmmr0 using qv_wet0
-  // Now convert qv wet mmr to qv dry mmr as qv dry mmr is an input for the "calculate_wetmmr_from_drymmr" function
+  drymmr0 =
+      PF::calculate_drymmr_from_wetmmr(wetmmr0, qv_wet0); // get drymmr from wetmmr0 using qv_wet0
+  // Now convert qv wet mmr to qv dry mmr as qv dry mmr is an input for the
+  // "calculate_wetmmr_from_drymmr" function
   qv_dry0 = PF::calculate_drymmr_from_wetmmr(qv_wet0, qv_wet0);
   tmp     = PF::calculate_wetmmr_from_drymmr(drymmr0, qv_dry0); // convert it back to wetmmr0
   REQUIRE(Check::approx_equal(tmp, wetmmr0, test_tol));         // wetmmr0 should be equal to tmp
@@ -366,11 +389,11 @@ template <typename ScalarT, typename DeviceT> void run(std::mt19937_64 &engine)
   //  - calculate_vmr_from_mmr(mmr=0) = 0
   //  - calculate_mmr_from_vmr(vmr=0) = 0
   //  - calculate_vmr_from_mmr(calculate_mmr_from_vmr(gas_name="h2o",vmr0)) = vmr
-  //  - calculate_vmr_from_mmr(calculate_mmr_from_vmr(gas_name="o2",vmr0)) = vmr, test that changing gas name changes
-  //  the result.
+  //  - calculate_vmr_from_mmr(calculate_mmr_from_vmr(gas_name="o2",vmr0)) = vmr, test that changing
+  //  gas name changes the result.
   //  - calculate_mmr_from_vmr(calculate_vmr_from_mmr(gas_name="h2o",mmr0)) = vmr
-  //  - calculate_mmr_from_vmr(calculate_vmr_from_mmr(gas_name="o2",mmr0)) != vmr, test that changing gas name changes
-  //  the result.
+  //  - calculate_mmr_from_vmr(calculate_vmr_from_mmr(gas_name="o2",mmr0)) != vmr, test that
+  //  changing gas name changes the result.
   mmr0               = pdf_mmr(engine);
   vmr0               = pdf_mmr(engine);
   qv0                = pdf_qv(engine);
diff --git i/components/eamxx/src/share/tests/data_interpolation_setup.cpp w/components/eamxx/src/share/tests/data_interpolation_setup.cpp
index be3dd7c55f..3acda29b73 100644
--- i/components/eamxx/src/share/tests/data_interpolation_setup.cpp
+++ w/components/eamxx/src/share/tests/data_interpolation_setup.cpp
@@ -20,7 +20,8 @@ TEST_CASE("data_interpolation_setup") {
   scorpio::init_subsystem(comm);
 
   // We use raw scorpio calls without decomp, so ensure we're in serial case
-  EKAT_REQUIRE_MSG(comm.size() == 1, "Error! You should run the data_interpolation_setup test with ONE rank.\n");
+  EKAT_REQUIRE_MSG(comm.size() == 1,
+                   "Error! You should run the data_interpolation_setup test with ONE rank.\n");
 
   // Create grid
   std::shared_ptr<const AbstractGrid> grid = create_point_grid("pg", ngcols, nlevs, comm);
@@ -79,7 +80,8 @@ TEST_CASE("data_interpolation_setup") {
     //   - two to be used for linear-hystory interp
     util::TimeStamp time = get_first_slice_time();
 
-    // We keep pressures fields NOT time-dep, so we write outside the loop. Also write hyam/hybm here
+    // We keep pressures fields NOT time-dep, so we write outside the loop. Also write hyam/hybm
+    // here
     auto p1d  = base_fields[6];
     auto p3d  = base_fields[2].alias("p3d");
     auto p2d  = base_fields[0].alias("p2d");
diff --git i/components/eamxx/src/share/tests/data_interpolation_tests.cpp w/components/eamxx/src/share/tests/data_interpolation_tests.cpp
index c5185a6ef7..e2a40975d4 100644
--- i/components/eamxx/src/share/tests/data_interpolation_tests.cpp
+++ w/components/eamxx/src/share/tests/data_interpolation_tests.cpp
@@ -44,8 +44,9 @@ void root_print(const ekat::Comm &comm, const std::string &msg) {
 }
 
 // Run the data interpolation to the input grid, and check against expected values
-void run_tests(const std::shared_ptr<const AbstractGrid> &grid, const strvec_t &input_files, util::TimeStamp t_beg,
-               const util::TimeLine timeline, const DataInterpolation::VRemapType vr_type = DataInterpolation::None) {
+void run_tests(const std::shared_ptr<const AbstractGrid> &grid, const strvec_t &input_files,
+               util::TimeStamp t_beg, const util::TimeLine timeline,
+               const DataInterpolation::VRemapType vr_type = DataInterpolation::None) {
   auto t_end = t_beg + t_beg.days_in_curr_month() * spd;
   auto t0    = t_beg + (t_end - t_beg) / 2;
 
@@ -229,7 +230,8 @@ TEST_CASE("exceptions") {
   auto interp = create_interp(grid, fields);
 
   strvec_t files = {"/etc/shadow"};
-  REQUIRE_THROWS(interp->setup_time_database(files, util::TimeLine::Linear)); // Input file not readable
+  REQUIRE_THROWS(
+      interp->setup_time_database(files, util::TimeLine::Linear)); // Input file not readable
 
   interp->setup_time_database({"./data_interpolation_0.nc"}, util::TimeLine::Linear);
   util::TimeStamp t0({2000, 1, 1}, {0, 0, 0});
diff --git i/components/eamxx/src/share/tests/data_interpolation_tests.hpp w/components/eamxx/src/share/tests/data_interpolation_tests.hpp
index abcb1c5014..adc6ae78c6 100644
--- i/components/eamxx/src/share/tests/data_interpolation_tests.hpp
+++ w/components/eamxx/src/share/tests/data_interpolation_tests.hpp
@@ -42,8 +42,9 @@ inline util::TimeStamp get_last_slice_time() {
   return t;
 }
 
-std::vector<Field> create_fields(const std::shared_ptr<const AbstractGrid> &grid, const bool init_values,
-                                 const bool int_same_as_mid = false, const bool pad_for_packing = true) {
+std::vector<Field> create_fields(const std::shared_ptr<const AbstractGrid> &grid,
+                                 const bool init_values, const bool int_same_as_mid = false,
+                                 const bool pad_for_packing = true) {
   constexpr auto m = ekat::units::m;
   const auto &gn   = grid->name();
 
@@ -103,7 +104,8 @@ std::vector<Field> create_fields(const std::shared_ptr<const AbstractGrid> &grid
         for (int icmp = 0; icmp < ncmps; ++icmp) {
           v3d_m.get_view<Real ***, Host>()(icol, icmp, ilev) = h_value * (v_value + dv / 2) + icmp;
           if (int_same_as_mid) {
-            v3d_i.get_view<Real ***, Host>()(icol, icmp, ilev) = h_value * (v_value + dv / 2) + icmp;
+            v3d_i.get_view<Real ***, Host>()(icol, icmp, ilev) =
+                h_value * (v_value + dv / 2) + icmp;
           } else {
             v3d_i.get_view<Real ***, Host>()(icol, icmp, ilev) = h_value * (v_value) + icmp;
           }
diff --git i/components/eamxx/src/share/tests/eamxx_time_interpolation_tests.cpp w/components/eamxx/src/share/tests/eamxx_time_interpolation_tests.cpp
index fa5e0624eb..03129f876d 100644
--- i/components/eamxx/src/share/tests/eamxx_time_interpolation_tests.cpp
+++ w/components/eamxx/src/share/tests/eamxx_time_interpolation_tests.cpp
@@ -20,21 +20,23 @@
 namespace scream {
 
 // Test Constants
-constexpr Real tol        = std::numeric_limits<Real>::epsilon() * 1e5;
-constexpr int slp_switch  = 4; // The frequency that we change the slope of the data written to file.
-constexpr int dt          = 100;
+constexpr Real tol       = std::numeric_limits<Real>::epsilon() * 1e5;
+constexpr int slp_switch = 4; // The frequency that we change the slope of the data written to file.
+constexpr int dt         = 100;
 constexpr int total_snaps = 10;
 constexpr int snap_freq   = 4;
-constexpr int slope_freq =
-    snap_freq; // We will change the slope every slope_freq steps to ensure that the data is not all on the same line.
+constexpr int slope_freq  = snap_freq; // We will change the slope every slope_freq steps to ensure
+                                       // that the data is not all on the same line.
 constexpr int snaps_per_file = 3;
 
 // Functions needed to set the test up
-std::shared_ptr<const GridsManager> get_gm(const ekat::Comm &comm, const int ncols, const int nlevs);
-std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid, const util::TimeStamp &t0,
-                                     const int seed);
+std::shared_ptr<const GridsManager> get_gm(const ekat::Comm &comm, const int ncols,
+                                           const int nlevs);
+std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid,
+                                     const util::TimeStamp &t0, const int seed);
 util::TimeStamp init_timestamp();
-std::vector<std::string> create_test_data_files(const ekat::Comm &comm, const std::shared_ptr<const GridsManager> &gm,
+std::vector<std::string> create_test_data_files(const ekat::Comm &comm,
+                                                const std::shared_ptr<const GridsManager> &gm,
                                                 const util::TimeStamp &t0, const int seed);
 
 // Functions needed to run the test
@@ -215,10 +217,11 @@ TEST_CASE("eamxx_time_interpolation_data_from_file") {
       auto field_deep = fields_man_deep->get_field(name);
       // Check that the shallow copies match the expected values
       REQUIRE(views_are_approx_equal(field, time_interpolator.get_field(name), tol));
-      // Check that the deep fields which were not updated directly are the same as the ones stored in the time
-      // interpolator.
+      // Check that the deep fields which were not updated directly are the same as the ones stored
+      // in the time interpolator.
       REQUIRE(views_are_equal(field_deep, time_interpolator_deep.get_field(name)));
-      // Check that the deep and shallow fields match showing that both approaches got the correct answer.
+      // Check that the deep and shallow fields match showing that both approaches got the correct
+      // answer.
       REQUIRE(views_are_equal(field, field_deep));
     }
   }
@@ -239,15 +242,17 @@ TEST_CASE("eamxx_time_interpolation_data_from_file") {
 bool views_are_approx_equal(const Field &f0, const Field &f1, const Real tol) {
   const auto &l0 = f0.get_header().get_identifier().get_layout();
   const auto &l1 = f1.get_header().get_identifier().get_layout();
-  EKAT_REQUIRE_MSG(l0 == l1, "Error! views_are_approx_equal - the two fields don't have matching layouts.");
-  // Take advantage of field utils update, min and max to assess the max difference between the two fields
-  // simply.
+  EKAT_REQUIRE_MSG(l0 == l1,
+                   "Error! views_are_approx_equal - the two fields don't have matching layouts.");
+  // Take advantage of field utils update, min and max to assess the max difference between the two
+  // fields simply.
   auto ft = f0.clone();
   ft.update(f1, 1.0, -1.0);
   auto d_min = field_min<Real>(ft);
   auto d_max = field_max<Real>(ft);
   if (std::abs(d_min) > tol or std::abs(d_max) > tol) {
-    printf("The two copies of (%16s) are NOT approx equal within a tolerance of %e.\n     The min and max errors are "
+    printf("The two copies of (%16s) are NOT approx equal within a tolerance of %e.\n     The min "
+           "and max errors are "
            "%e and %e respectively.\n",
            f0.name().c_str(), tol, d_min, d_max);
     return false;
@@ -292,7 +297,8 @@ void update_field_data(const Real slope, const Real dt, Field &field) {
 util::TimeStamp init_timestamp() { return util::TimeStamp({2023, 5, 16}, {0, 0, 0}); }
 /*-----------------------------------------------------------------------------------------------*/
 /* Create a grids manager for the test */
-std::shared_ptr<const GridsManager> get_gm(const ekat::Comm &comm, const int ncols, const int nlevs) {
+std::shared_ptr<const GridsManager> get_gm(const ekat::Comm &comm, const int ncols,
+                                           const int nlevs) {
   using vos_t = std::vector<std::string>;
   ekat::ParameterList gm_params;
   gm_params.set("grids_names", vos_t{"point_grid"});
@@ -307,8 +313,8 @@ std::shared_ptr<const GridsManager> get_gm(const ekat::Comm &comm, const int nco
 }
 /*-----------------------------------------------------------------------------------------------*/
 /* Create a fields manager for the test */
-std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid, const util::TimeStamp &t0,
-                                     const int seed) {
+std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &grid,
+                                     const util::TimeStamp &t0, const int seed) {
   using FL  = FieldLayout;
   using FID = FieldIdentifier;
   using namespace ShortFieldTagsNames;
@@ -350,7 +356,8 @@ std::shared_ptr<FieldManager> get_fm(const std::shared_ptr<const AbstractGrid> &
 /* Construct data for multiple time snaps and write the data to file, to be used for testing
  * the capability of TimeInterpolation to handle data read from multiple files.
  */
-std::vector<std::string> create_test_data_files(const ekat::Comm &comm, const std::shared_ptr<const GridsManager> &gm,
+std::vector<std::string> create_test_data_files(const ekat::Comm &comm,
+                                                const std::shared_ptr<const GridsManager> &gm,
                                                 const util::TimeStamp &t0, const int seed) {
   // We initialize a local field manager to use for output
   auto fm = get_fm(gm->get_grid("point_grid"), t0, seed);
diff --git i/components/eamxx/src/share/tests/field_tests.cpp w/components/eamxx/src/share/tests/field_tests.cpp
index 39bd5d2c05..7fee66b6fa 100644
--- i/components/eamxx/src/share/tests/field_tests.cpp
+++ w/components/eamxx/src/share/tests/field_tests.cpp
@@ -236,7 +236,8 @@ TEST_CASE("field", "") {
     REQUIRE(f2.is_allocated());
     REQUIRE(&f1.get_header().get_tracking() == &f2.get_header().get_tracking());
     REQUIRE(&f1.get_header().get_alloc_properties() == &f2.get_header().get_alloc_properties());
-    REQUIRE(f1.get_header().get_identifier().get_layout() == f2.get_header().get_identifier().get_layout());
+    REQUIRE(f1.get_header().get_identifier().get_layout() ==
+            f2.get_header().get_identifier().get_layout());
     REQUIRE(f1.get_internal_view_data<Real>() == f2.get_internal_view_data<Real>());
 
     // Identifiers are separate objects though
@@ -515,8 +516,10 @@ TEST_CASE("field_mgr", "") {
   REQUIRE_THROWS(field_mgr.get_field(bad1));              // Not in field_mgr
   REQUIRE_THROWS(field_mgr.get_field("field1", "grid3")); // Wrong grid
 
-  // Check that the groups names are in the header. While at it, make sure that case insensitive works fine.
-  auto has_group = [](const ekat::WeakPtrSet<const FieldGroupInfo> &groups, const std::string &name) -> bool {
+  // Check that the groups names are in the header. While at it, make sure that case insensitive
+  // works fine.
+  auto has_group = [](const ekat::WeakPtrSet<const FieldGroupInfo> &groups,
+                      const std::string &name) -> bool {
     for (auto it : groups) {
       if (it.lock()->m_group_name == name) {
         return true;
@@ -966,7 +969,8 @@ TEST_CASE("sync_subfields") {
   constexpr int nlevs = 8;
 
   // Create field with (col, cmp, lev)
-  FID fid("V", FL({COL, CMP, LEV}, {ncols, ndims, nlevs}), Units::nondimensional(), "the_grid", DataType::IntType);
+  FID fid("V", FL({COL, CMP, LEV}, {ncols, ndims, nlevs}), Units::nondimensional(), "the_grid",
+          DataType::IntType);
   Field f(fid);
   f.allocate_view();
 
@@ -1018,7 +1022,8 @@ TEST_CASE("sync_subfields") {
   for (int c = 1; c < ndims; ++c) {
     auto device_subview = f.get_component(c).get_view<int **, Device>();
     Kokkos::parallel_for(
-        Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {ncols, nlevs}), KOKKOS_LAMBDA(const int icol, const int ilev) {
+        Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {ncols, nlevs}),
+        KOKKOS_LAMBDA(const int icol, const int ilev) {
           if (shared_mem_space)
             EKAT_KERNEL_ASSERT(device_subview(icol, ilev) == c);
           else
diff --git i/components/eamxx/src/share/tests/field_utils.cpp w/components/eamxx/src/share/tests/field_utils.cpp
index 4321e51fed..809553237e 100644
--- i/components/eamxx/src/share/tests/field_utils.cpp
+++ w/components/eamxx/src/share/tests/field_utils.cpp
@@ -215,17 +215,20 @@ TEST_CASE("utils") {
     // Test higher-order cases
     result = field_z.clone();
     horiz_contraction<Real>(result, field10, field00);
-    REQUIRE(result.get_header().get_identifier().get_layout().tags() == std::vector<FieldTag>({CMP}));
+    REQUIRE(result.get_header().get_identifier().get_layout().tags() ==
+            std::vector<FieldTag>({CMP}));
     REQUIRE(result.get_header().get_identifier().get_layout().dim(0) == dim1);
 
     result = field_y.clone();
     horiz_contraction<Real>(result, field11, field00);
-    REQUIRE(result.get_header().get_identifier().get_layout().tags() == std::vector<FieldTag>({LEV}));
+    REQUIRE(result.get_header().get_identifier().get_layout().tags() ==
+            std::vector<FieldTag>({LEV}));
     REQUIRE(result.get_header().get_identifier().get_layout().dim(0) == dim2);
 
     result = field_w.clone();
     horiz_contraction<Real>(result, field20, field00);
-    REQUIRE(result.get_header().get_identifier().get_layout().tags() == std::vector<FieldTag>({CMP, LEV}));
+    REQUIRE(result.get_header().get_identifier().get_layout().tags() ==
+            std::vector<FieldTag>({CMP, LEV}));
     REQUIRE(result.get_header().get_identifier().get_layout().dim(0) == dim1);
     REQUIRE(result.get_header().get_identifier().get_layout().dim(1) == dim2);
 
@@ -348,7 +351,8 @@ TEST_CASE("utils") {
       // Test higher-order cases
       result = field_x.clone();
       vert_contraction<Real>(result, field10, field00);
-      REQUIRE(result.get_header().get_identifier().get_layout().tags() == std::vector<FieldTag>({COL}));
+      REQUIRE(result.get_header().get_identifier().get_layout().tags() ==
+              std::vector<FieldTag>({COL}));
       REQUIRE(result.get_header().get_identifier().get_layout().dim(0) == dim0);
 
       // Check a 2D case with 1D weight
@@ -369,12 +373,14 @@ TEST_CASE("utils") {
 
       result = field_y.clone();
       vert_contraction<Real>(result, field11, field00);
-      REQUIRE(result.get_header().get_identifier().get_layout().tags() == std::vector<FieldTag>({CMP}));
+      REQUIRE(result.get_header().get_identifier().get_layout().tags() ==
+              std::vector<FieldTag>({CMP}));
       REQUIRE(result.get_header().get_identifier().get_layout().dim(0) == dim1);
 
       result = field_z.clone();
       vert_contraction<Real>(result, field20, field00);
-      REQUIRE(result.get_header().get_identifier().get_layout().tags() == std::vector<FieldTag>({COL, CMP}));
+      REQUIRE(result.get_header().get_identifier().get_layout().tags() ==
+              std::vector<FieldTag>({COL, CMP}));
       REQUIRE(result.get_header().get_identifier().get_layout().dim(0) == dim0);
       REQUIRE(result.get_header().get_identifier().get_layout().dim(1) == dim1);
 
@@ -399,7 +405,8 @@ TEST_CASE("utils") {
       // Check a 3D case with 2D weight
       result = field_z.clone();
       vert_contraction<Real>(result, field20, field10);
-      REQUIRE(result.get_header().get_identifier().get_layout().tags() == std::vector<FieldTag>({COL, CMP}));
+      REQUIRE(result.get_header().get_identifier().get_layout().tags() ==
+              std::vector<FieldTag>({COL, CMP}));
       REQUIRE(result.get_header().get_identifier().get_layout().dim(0) == dim0);
       REQUIRE(result.get_header().get_identifier().get_layout().dim(1) == dim1);
 
@@ -441,8 +448,8 @@ TEST_CASE("utils") {
     // (a+1)^2+(a+2)^2+...
     // which ultimately gives
     // N*a^2 + 2a*(1+2+...+N)
-    Real lsum =
-        offset * offset * lsize + 2 * offset * lsize * (lsize + 1) / 2 + lsize * (lsize + 1) * (2 * lsize + 1) / 6.0;
+    Real lsum = offset * offset * lsize + 2 * offset * lsize * (lsize + 1) / 2 +
+                lsize * (lsize + 1) * (2 * lsize + 1) / 6.0;
     Real gsum = gsize * (gsize + 1) * (2 * gsize + 1) / 6.0;
 
     REQUIRE(frobenius_norm<Real>(f1) == std::sqrt(lsum));
@@ -506,16 +513,20 @@ TEST_CASE("utils") {
 
     // Create 1d, 2d, 3d fields with a level dimension, and set all to 1
     FieldIdentifier fid1("f_1d", FieldLayout({LEV}, {nlevs}), Units::nondimensional(), "");
-    FieldIdentifier fid2a("f_2d_a", FieldLayout({CMP, LEV}, {ncmps, nlevs}), Units::nondimensional(), "");
-    FieldIdentifier fid2b("f_2d_b", FieldLayout({COL, LEV}, {ncols, nlevs}), Units::nondimensional(), "");
-    FieldIdentifier fid3("f_3d", FieldLayout({COL, CMP, LEV}, {ncols, ncmps, nlevs}), Units::nondimensional(), "");
+    FieldIdentifier fid2a("f_2d_a", FieldLayout({CMP, LEV}, {ncmps, nlevs}),
+                          Units::nondimensional(), "");
+    FieldIdentifier fid2b("f_2d_b", FieldLayout({COL, LEV}, {ncols, nlevs}),
+                          Units::nondimensional(), "");
+    FieldIdentifier fid3("f_3d", FieldLayout({COL, CMP, LEV}, {ncols, ncmps, nlevs}),
+                         Units::nondimensional(), "");
     Field f1(fid1), f2a(fid2a), f2b(fid2b), f3(fid3);
     f1.allocate_view(), f2a.allocate_view(), f2b.allocate_view(), f3.allocate_view();
     f1.deep_copy(1), f2a.deep_copy(1), f2b.deep_copy(1), f3.deep_copy(1);
 
     // We need GIDs for fields with COL component. This test is not over
     // multiple ranks, so just set as [0, ncols-1].
-    Field gids(FieldIdentifier("gids", FieldLayout({COL}, {ncols}), Units::nondimensional(), "", DataType::IntType));
+    Field gids(FieldIdentifier("gids", FieldLayout({COL}, {ncols}), Units::nondimensional(), "",
+                               DataType::IntType));
     gids.allocate_view();
     auto gids_data = gids.get_internal_view_data<int, Host>();
     std::iota(gids_data, gids_data + ncols, 0);
@@ -605,7 +616,8 @@ TEST_CASE("utils") {
   }
 
   SECTION("wrong_st") {
-    using wrong_real = typename std::conditional<std::is_same<Real, double>::value, float, double>::type;
+    using wrong_real =
+        typename std::conditional<std::is_same<Real, double>::value, float, double>::type;
     REQUIRE_THROWS(field_min<int>(f1));
     REQUIRE_THROWS(field_max<int>(f1));
     REQUIRE_THROWS(field_sum<wrong_real>(f1));
diff --git i/components/eamxx/src/share/tests/iop_remapper_tests.cpp w/components/eamxx/src/share/tests/iop_remapper_tests.cpp
index be57674610..8cac296bad 100644
--- i/components/eamxx/src/share/tests/iop_remapper_tests.cpp
+++ w/components/eamxx/src/share/tests/iop_remapper_tests.cpp
@@ -19,8 +19,8 @@ constexpr int tens_dim1 = 3;
 constexpr int tens_dim2 = 4;
 
 template <typename Engine, typename PDF>
-Field create_field(const std::string &name, const LayoutType lt, const AbstractGrid &grid, const bool midpoints,
-                   Engine &engine, PDF &pdf) {
+Field create_field(const std::string &name, const LayoutType lt, const AbstractGrid &grid,
+                   const bool midpoints, Engine &engine, PDF &pdf) {
   const auto u   = ekat::units::Units::nondimensional();
   const auto &gn = grid.name();
   Field f;
@@ -43,7 +43,8 @@ Field create_field(const std::string &name, const LayoutType lt, const AbstractG
     f.get_header().get_alloc_properties().request_allocation(SCREAM_PACK_SIZE);
     break;
   case LayoutType::Tensor3D:
-    f = Field(FieldIdentifier(name, grid.get_3d_tensor_layout(midpoints, {tens_dim1, tens_dim2}), u, gn));
+    f = Field(
+        FieldIdentifier(name, grid.get_3d_tensor_layout(midpoints, {tens_dim1, tens_dim2}), u, gn));
     f.get_header().get_alloc_properties().request_allocation(SCREAM_PACK_SIZE);
     break;
   default:
diff --git i/components/eamxx/src/share/tests/refining_remapper_p2p_tests.cpp w/components/eamxx/src/share/tests/refining_remapper_p2p_tests.cpp
index 621f02a9af..48eee9a39e 100644
--- i/components/eamxx/src/share/tests/refining_remapper_p2p_tests.cpp
+++ w/components/eamxx/src/share/tests/refining_remapper_p2p_tests.cpp
@@ -46,7 +46,8 @@ Field create_field(const std::string &name, const LayoutType lt, const AbstractG
 }
 
 template <typename Engine>
-Field create_field(const std::string &name, const LayoutType lt, const AbstractGrid &grid, Engine &engine) {
+Field create_field(const std::string &name, const LayoutType lt, const AbstractGrid &grid,
+                   Engine &engine) {
   auto f = create_field(name, lt, grid);
 
   // Use discrete_distribution to get an integer, then use that as exponent for 2^-n.
@@ -194,10 +195,10 @@ TEST_CASE("refining_remapper") {
     auto r        = std::make_shared<RefiningRemapperP2PTester>(tgt_grid, filename);
     auto src_grid = r->get_src_grid();
     r->registration_begins();
-    Field bad_src(
-        FieldIdentifier("", src_grid->get_2d_scalar_layout(), ekat::units::m, src_grid->name(), DataType::IntType));
-    Field bad_tgt(
-        FieldIdentifier("", tgt_grid->get_2d_scalar_layout(), ekat::units::m, tgt_grid->name(), DataType::IntType));
+    Field bad_src(FieldIdentifier("", src_grid->get_2d_scalar_layout(), ekat::units::m,
+                                  src_grid->name(), DataType::IntType));
+    Field bad_tgt(FieldIdentifier("", tgt_grid->get_2d_scalar_layout(), ekat::units::m,
+                                  tgt_grid->name(), DataType::IntType));
     CHECK_THROWS(r->register_field(bad_src, bad_tgt)); // not allocated
     bad_src.allocate_view();
     bad_tgt.allocate_view();
diff --git i/components/eamxx/src/share/tests/refining_remapper_rma_tests.cpp w/components/eamxx/src/share/tests/refining_remapper_rma_tests.cpp
index 0adf91dc92..8148ed4821 100644
--- i/components/eamxx/src/share/tests/refining_remapper_rma_tests.cpp
+++ w/components/eamxx/src/share/tests/refining_remapper_rma_tests.cpp
@@ -53,7 +53,8 @@ public:
     auto row_offsets_h = cmvdc(m_row_offsets);
     auto col_lids_h    = cmvdc(m_col_lids);
     auto weights_h     = cmvdc(m_weights);
-    auto col_gids_h    = m_ov_coarse_grid->get_dofs_gids().get_view<const AbstractGrid::gid_type *, Host>();
+    auto col_gids_h =
+        m_ov_coarse_grid->get_dofs_gids().get_view<const AbstractGrid::gid_type *, Host>();
 
     auto row_gids_h = m_tgt_grid->get_dofs_gids().get_view<const AbstractGrid::gid_type *, Host>();
     for (int i = 0; i < nldofs_tgt; ++i) {
@@ -101,7 +102,8 @@ Field create_field(const std::string &name, const LayoutType lt, const AbstractG
 }
 
 template <typename Engine>
-Field create_field(const std::string &name, const LayoutType lt, const AbstractGrid &grid, Engine &engine) {
+Field create_field(const std::string &name, const LayoutType lt, const AbstractGrid &grid,
+                   Engine &engine) {
   auto f = create_field(name, lt, grid);
 
   // Use discrete_distribution to get an integer, then use that as exponent for 2^-n.
@@ -249,10 +251,10 @@ TEST_CASE("refining_remapper") {
     auto r        = std::make_shared<RefiningRemapperRMATester>(tgt_grid, filename);
     auto src_grid = r->get_src_grid();
     r->registration_begins();
-    Field bad_src(
-        FieldIdentifier("", src_grid->get_2d_scalar_layout(), ekat::units::m, src_grid->name(), DataType::IntType));
-    Field bad_tgt(
-        FieldIdentifier("", tgt_grid->get_2d_scalar_layout(), ekat::units::m, tgt_grid->name(), DataType::IntType));
+    Field bad_src(FieldIdentifier("", src_grid->get_2d_scalar_layout(), ekat::units::m,
+                                  src_grid->name(), DataType::IntType));
+    Field bad_tgt(FieldIdentifier("", tgt_grid->get_2d_scalar_layout(), ekat::units::m,
+                                  tgt_grid->name(), DataType::IntType));
     CHECK_THROWS(r->register_field(bad_src, bad_tgt)); // not allocated
     bad_src.allocate_view();
     bad_tgt.allocate_view();
diff --git i/components/eamxx/src/share/tests/subfield_tests.cpp w/components/eamxx/src/share/tests/subfield_tests.cpp
index 245b33ce12..8f781cefd8 100644
--- i/components/eamxx/src/share/tests/subfield_tests.cpp
+++ w/components/eamxx/src/share/tests/subfield_tests.cpp
@@ -281,7 +281,8 @@ TEST_CASE("field", "") {
               for (int l = l1; l < l2; l++) {
                 for (int m = m1; m < m2; m++) {
                   for (int n = n1; n < n2; n++) {
-                    REQUIRE(v6d_h(i, j, k, l, m, n) == sv_h(i - i1, j - j1, k - k1, l - l1, m - m1, n - n1));
+                    REQUIRE(v6d_h(i, j, k, l, m, n) ==
+                            sv_h(i - i1, j - j1, k - k1, l - l1, m - m1, n - n1));
                     REQUIRE((sv_h.extent_int(0) == (i2 - i1) && sv_h.extent_int(1) == (j2 - j1) &&
                              sv_h.extent_int(2) == (k2 - k1) && sv_h.extent_int(3) == (l2 - l1) &&
                              sv_h.extent_int(4) == (m2 - m1) && sv_h.extent_int(5) == (n2 - n1)));
diff --git i/components/eamxx/src/share/tests/utils_tests.cpp w/components/eamxx/src/share/tests/utils_tests.cpp
index 6b49fd695a..dd63e5c2a0 100644
--- i/components/eamxx/src/share/tests/utils_tests.cpp
+++ w/components/eamxx/src/share/tests/utils_tests.cpp
@@ -129,7 +129,8 @@ TEST_CASE("time_stamp") {
     REQUIRE(ts2.get_seconds() == (ts1.get_seconds() + 1));
     REQUIRE(ts2.get_minutes() == (ts1.get_minutes() + 1));
     REQUIRE(ts2.get_hours() == (ts1.get_hours() + 1));
-    REQUIRE(ts2.get_day() == (ts1.get_day() + 1 + 20 - 31)); // Add 20 days, subtract Oct 31 days (carry)
+    REQUIRE(ts2.get_day() ==
+            (ts1.get_day() + 1 + 20 - 31)); // Add 20 days, subtract Oct 31 days (carry)
     REQUIRE(ts2.get_month() == (ts1.get_month() + 1));
     REQUIRE(ts2.get_year() == ts1.get_year());
 
@@ -137,7 +138,8 @@ TEST_CASE("time_stamp") {
     REQUIRE(ts2.get_seconds() == ts1.get_seconds() + 1);
     REQUIRE(ts2.get_minutes() == (ts1.get_minutes() + 1));
     REQUIRE(ts2.get_hours() == (ts1.get_hours() + 1));
-    REQUIRE(ts2.get_day() == (ts1.get_day() + 1 + 20 - 31)); // Add 20 days, subtract Oct 31 days (carry)
+    REQUIRE(ts2.get_day() ==
+            (ts1.get_day() + 1 + 20 - 31)); // Add 20 days, subtract Oct 31 days (carry)
     REQUIRE(ts2.get_month() == (ts1.get_month() + 1));
     REQUIRE(ts2.get_year() == (ts1.get_year() + 1));
 
diff --git i/components/eamxx/src/share/tests/vertical_remapper_tests.cpp w/components/eamxx/src/share/tests/vertical_remapper_tests.cpp
index b0a2e4ea05..44b329779a 100644
--- i/components/eamxx/src/share/tests/vertical_remapper_tests.cpp
+++ w/components/eamxx/src/share/tests/vertical_remapper_tests.cpp
@@ -17,7 +17,8 @@ constexpr auto Bot      = VerticalRemapper::Bot;
 constexpr auto TopBot   = VerticalRemapper::TopAndBot;
 constexpr Real mask_val = -99999.0;
 
-template <typename... Args> void print(const std::string &fmt, const ekat::Comm &comm, Args &&...args) {
+template <typename... Args>
+void print(const std::string &fmt, const ekat::Comm &comm, Args &&...args) {
   if (comm.am_i_root()) {
     printf(fmt.c_str(), std::forward<Args>(args)...);
   }
@@ -30,7 +31,8 @@ void print(const std::string &fmt, const ekat::Comm &comm) {
 }
 
 // Helper function to create a grid given the number of dof's and a comm group.
-std::shared_ptr<AbstractGrid> build_grid(const ekat::Comm &comm, const int nldofs, const int nlevs) {
+std::shared_ptr<AbstractGrid> build_grid(const ekat::Comm &comm, const int nldofs,
+                                         const int nlevs) {
   using gid_type = AbstractGrid::gid_type;
 
   auto grid = std::make_shared<PointGrid>("src", nldofs, nlevs, comm);
@@ -44,13 +46,14 @@ std::shared_ptr<AbstractGrid> build_grid(const ekat::Comm &comm, const int nldof
 }
 
 // Helper function to create fields
-Field create_field(const std::string &name, const std::shared_ptr<const AbstractGrid> &grid, const bool twod,
-                   const bool vec, const bool mid = false, const int ps = 1) {
+Field create_field(const std::string &name, const std::shared_ptr<const AbstractGrid> &grid,
+                   const bool twod, const bool vec, const bool mid = false, const int ps = 1) {
   using namespace ShortFieldTagsNames;
   constexpr int vec_dim = 3;
   constexpr auto units  = ekat::units::Units::nondimensional();
-  auto fl               = twod ? (vec ? grid->get_2d_vector_layout(vec_dim) : grid->get_2d_scalar_layout())
-                               : (vec ? grid->get_3d_vector_layout(mid, vec_dim) : grid->get_3d_scalar_layout(mid));
+  auto fl =
+      twod ? (vec ? grid->get_2d_vector_layout(vec_dim) : grid->get_2d_scalar_layout())
+           : (vec ? grid->get_3d_vector_layout(mid, vec_dim) : grid->get_3d_scalar_layout(mid));
   FieldIdentifier fid(name, fl, units, grid->name());
   Field f(fid);
   f.get_header().get_alloc_properties().request_allocation(ps);
@@ -64,8 +67,9 @@ Real data_func(const int col, const int vec, const Real pres) {
   //   - col, the horizontal column,
   //   - vec, the vector dimension, and
   //   - pres, the current pressure
-  // Should ensure that the interpolated values match exactly, since vertical interp is also a linear interpolator.
-  // Note, we don't use the level, because here the vertical interpolation is over pressure, so it represents the level.
+  // Should ensure that the interpolated values match exactly, since vertical interp is also a
+  // linear interpolator. Note, we don't use the level, because here the vertical interpolation is
+  // over pressure, so it represents the level.
   return (col + 1) * pres + vec * 100.0;
 }
 
@@ -129,7 +133,8 @@ void compute_field(const Field &f, const Field &p) {
   f.sync_to_dev();
 }
 
-void extrapolate(const Field &p_src, const Field &p_tgt, const Field &f, const VerticalRemapper::ExtrapType etype_top,
+void extrapolate(const Field &p_src, const Field &p_tgt, const Field &f,
+                 const VerticalRemapper::ExtrapType etype_top,
                  const VerticalRemapper::ExtrapType etype_bot) {
   Field::view_host_t<const Real *> p1d_src, p1d_tgt;
   Field::view_host_t<const Real **> p2d_src, p2d_tgt;
@@ -200,8 +205,8 @@ void extrapolate(const Field &p_src, const Field &p_tgt, const Field &f, const V
 }
 
 // Helper function to create a remap file
-void create_remap_file(const std::string &filename, const int nlevs, const std::vector<std::int64_t> &dofs_p,
-                       const std::vector<Real> &p_tgt) {
+void create_remap_file(const std::string &filename, const int nlevs,
+                       const std::vector<std::int64_t> &dofs_p, const std::vector<Real> &p_tgt) {
   scorpio::register_file(filename, scorpio::FileMode::Write);
   scorpio::define_dim(filename, "lev", nlevs);
   scorpio::define_var(filename, "p_levs", {"lev"}, "real");
@@ -229,8 +234,8 @@ TEST_CASE("create_tgt_grid") {
   // -------------------------------------- //
 
   const int nlevs_src =
-      2 * SCREAM_PACK_SIZE +
-      2; // Make sure we check what happens when the vertical extent is a little larger than the max PACK SIZE
+      2 * SCREAM_PACK_SIZE + 2; // Make sure we check what happens when the vertical extent is a
+                                // little larger than the max PACK SIZE
   const int nlevs_tgt = nlevs_src / 2;
   const int nldofs    = 1;
 
@@ -310,8 +315,8 @@ TEST_CASE("vertical_remapper") {
   // -------------------------------------- //
 
   const int nlevs_src =
-      2 * SCREAM_PACK_SIZE +
-      2; // Make sure we check what happens when the vertical extent is a little larger than the max PACK SIZE
+      2 * SCREAM_PACK_SIZE + 2; // Make sure we check what happens when the vertical extent is a
+                                // little larger than the max PACK SIZE
   const int nldofs = 1;
 
   // -------------------------------------- //
@@ -324,7 +329,8 @@ TEST_CASE("vertical_remapper") {
   print(" -> creating src grid ...done!\n", comm);
 
   // Tgt grid must have same 2d layout as src grid
-  REQUIRE_THROWS(std::make_shared<VerticalRemapper>(src_grid, build_grid(comm, nldofs + 1, nlevs_src)));
+  REQUIRE_THROWS(
+      std::make_shared<VerticalRemapper>(src_grid, build_grid(comm, nldofs + 1, nlevs_src)));
 
   // Helper lambda, to create p_int profile. If it is a 3d field, make same profile on each col
   auto create_pint = [&](const auto &grid, const bool one_d, const Real ptop, const Real pbot) {
diff --git i/components/eamxx/src/share/util/eamxx_ad_test.cpp w/components/eamxx/src/share/util/eamxx_ad_test.cpp
index 60206ed465..624feaeb9a 100644
--- i/components/eamxx/src/share/util/eamxx_ad_test.cpp
+++ w/components/eamxx/src/share/util/eamxx_ad_test.cpp
@@ -70,7 +70,8 @@ TEST_CASE("scream_ad_test") {
     ad.run(dt);
     if (atm_comm.am_i_root()) {
       std::cout << "  - Iteration " << std::setfill(' ') << std::setw(3) << i + 1 << " completed";
-      std::cout << "       [" << std::setfill(' ') << std::setw(3) << 100 * (i + 1) / nsteps << "%]\n";
+      std::cout << "       [" << std::setfill(' ') << std::setw(3) << 100 * (i + 1) / nsteps
+                << "%]\n";
     }
   }
   ad.finalize();
diff --git i/components/eamxx/src/share/util/eamxx_array_utils.hpp w/components/eamxx/src/share/util/eamxx_array_utils.hpp
index 97c5544b17..807a41ff97 100644
--- i/components/eamxx/src/share/util/eamxx_array_utils.hpp
+++ w/components/eamxx/src/share/util/eamxx_array_utils.hpp
@@ -51,16 +51,18 @@ inline std::vector<int> unflatten_idx(const std::vector<int> &dims, const int id
 // Kokkos-friendly versions of the above function, taking a Kokkos::View
 // for the array dimensions, and unpacking directly into N integers.
 template <typename... Props>
-KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims,
-                                          int &i) {
+KOKKOS_INLINE_FUNCTION void
+unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims,
+              int &i) {
   EKAT_KERNEL_ASSERT_MSG(dims.size() == 1, "Error! Wrong overload of unflatten_idx called.\n");
   i = idx;
   EKAT_KERNEL_ASSERT_MSG(i >= 0 && i < dims[0], "Error! Flatten index out of bounds.\n");
 }
 
 template <typename... Props>
-KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims,
-                                          int &i, int &j) {
+KOKKOS_INLINE_FUNCTION void
+unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims, int &i,
+              int &j) {
   EKAT_KERNEL_ASSERT_MSG(dims.size() == 2, "Error! Wrong overload of unflatten_idx called.\n");
 
   i = idx / dims[1];
@@ -71,8 +73,9 @@ KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int
 }
 
 template <typename... Props>
-KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims,
-                                          int &i, int &j, int &k) {
+KOKKOS_INLINE_FUNCTION void
+unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims, int &i,
+              int &j, int &k) {
   EKAT_KERNEL_ASSERT_MSG(dims.size() == 3, "Error! Wrong overload of unflatten_idx called.\n");
 
   i = (idx / dims[2]) / dims[1];
@@ -85,8 +88,9 @@ KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int
 }
 
 template <typename... Props>
-KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims,
-                                          int &i, int &j, int &k, int &l) {
+KOKKOS_INLINE_FUNCTION void
+unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims, int &i,
+              int &j, int &k, int &l) {
   EKAT_KERNEL_ASSERT_MSG(dims.size() == 4, "Error! Wrong overload of unflatten_idx called.\n");
 
   i = ((idx / dims[3]) / dims[2]) / dims[1];
@@ -101,8 +105,9 @@ KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int
 }
 
 template <typename... Props>
-KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims,
-                                          int &i, int &j, int &k, int &l, int &m) {
+KOKKOS_INLINE_FUNCTION void
+unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims, int &i,
+              int &j, int &k, int &l, int &m) {
   EKAT_KERNEL_ASSERT_MSG(dims.size() == 5, "Error! Wrong overload of unflatten_idx called.\n");
 
   i = (((idx / dims[4]) / dims[3]) / dims[2]) / dims[1];
@@ -119,8 +124,9 @@ KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int
 }
 
 template <typename... Props>
-KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims,
-                                          int &i, int &j, int &k, int &l, int &m, int &n) {
+KOKKOS_INLINE_FUNCTION void
+unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims, int &i,
+              int &j, int &k, int &l, int &m, int &n) {
   EKAT_KERNEL_ASSERT_MSG(dims.size() == 6, "Error! Wrong overload of unflatten_idx called.\n");
 
   i = ((((idx / dims[5]) / dims[4]) / dims[3]) / dims[2]) / dims[1];
@@ -139,8 +145,9 @@ KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int
 }
 
 template <typename... Props>
-KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims,
-                                          int *indices) {
+KOKKOS_INLINE_FUNCTION void
+unflatten_idx(const int idx, const Kokkos::View<int *, Kokkos::LayoutRight, Props...> &dims,
+              int *indices) {
   const int rank = dims.size();
   switch (rank) {
   case 1:
@@ -159,7 +166,8 @@ KOKKOS_INLINE_FUNCTION void unflatten_idx(const int idx, const Kokkos::View<int
     unflatten_idx(idx, dims, indices[0], indices[1], indices[2], indices[3], indices[4]);
     break;
   case 6:
-    unflatten_idx(idx, dims, indices[0], indices[1], indices[2], indices[3], indices[4], indices[5]);
+    unflatten_idx(idx, dims, indices[0], indices[1], indices[2], indices[3], indices[4],
+                  indices[5]);
     break;
   default:
     EKAT_KERNEL_ERROR_MSG("Error! Unsupported rank.\n");
diff --git i/components/eamxx/src/share/util/eamxx_bfbhash.cpp w/components/eamxx/src/share/util/eamxx_bfbhash.cpp
index 0ecb21755d..491229080a 100644
--- i/components/eamxx/src/share/util/eamxx_bfbhash.cpp
+++ w/components/eamxx/src/share/util/eamxx_bfbhash.cpp
@@ -12,7 +12,8 @@ static void reduce_hash(void *invec, void *inoutvec, int *len, MPI_Datatype * /*
 }
 
 int all_reduce_HashType(MPI_Comm comm, const HashType *sendbuf, HashType *rcvbuf, int count) {
-  static_assert(sizeof(long long int) == sizeof(HashType), "HashType must have size sizeof(long long int).");
+  static_assert(sizeof(long long int) == sizeof(HashType),
+                "HashType must have size sizeof(long long int).");
   MPI_Op op;
   MPI_Op_create(reduce_hash, true, &op);
   const auto stat = MPI_Allreduce(sendbuf, rcvbuf, count, MPI_LONG_LONG_INT, op, comm);
diff --git i/components/eamxx/src/share/util/eamxx_bfbhash.hpp w/components/eamxx/src/share/util/eamxx_bfbhash.hpp
index 49f60a5cd0..992587c37b 100644
--- i/components/eamxx/src/share/util/eamxx_bfbhash.hpp
+++ w/components/eamxx/src/share/util/eamxx_bfbhash.hpp
@@ -33,7 +33,9 @@ template <typename ExecSpace = Kokkos::HostSpace> struct HashReducer {
   typedef Kokkos::View<value_type *, ExecSpace, Kokkos::MemoryUnmanaged> result_view_type;
 
   KOKKOS_INLINE_FUNCTION HashReducer(value_type &value_) : value(value_) {}
-  KOKKOS_INLINE_FUNCTION void join(value_type &dest, const value_type &src) const { hash(src, dest); }
+  KOKKOS_INLINE_FUNCTION void join(value_type &dest, const value_type &src) const {
+    hash(src, dest);
+  }
   KOKKOS_INLINE_FUNCTION void init(value_type &val) const { val = 0; }
   KOKKOS_INLINE_FUNCTION value_type &reference() const { return value; }
   KOKKOS_INLINE_FUNCTION bool references_scalar() const { return true; }
diff --git i/components/eamxx/src/share/util/eamxx_column_ops.hpp w/components/eamxx/src/share/util/eamxx_column_ops.hpp
index 58f6c4c14a..6474bd5e2c 100644
--- i/components/eamxx/src/share/util/eamxx_column_ops.hpp
+++ w/components/eamxx/src/share/util/eamxx_column_ops.hpp
@@ -68,7 +68,9 @@ public:
 
   template <int PackSize> using pack_type = ekat::Pack<scalar_type, PackSize>;
 
-  template <typename ScalarT> static constexpr bool is_simd() { return ekat::ScalarTraits<ScalarT>::is_simd; }
+  template <typename ScalarT> static constexpr bool is_simd() {
+    return ekat::ScalarTraits<ScalarT>::is_simd;
+  }
 
   template <typename ScalarT> KOKKOS_FUNCTION static constexpr int pack_size() {
     return sizeof(ScalarT) / sizeof(scalar_type);
@@ -89,7 +91,8 @@ public:
   static constexpr scalar_type zero() { return scalar_type(0); }
 
   template <typename InputProvider, typename ScalarT, typename MT>
-  KOKKOS_INLINE_FUNCTION static void debug_checks(const int num_levels, const view_1d<ScalarT, MT> &x) {
+  KOKKOS_INLINE_FUNCTION static void debug_checks(const int num_levels,
+                                                  const view_1d<ScalarT, MT> &x) {
 
     // Mini function to check that InputProvider supports op()(int)->pack_type,
     // and that the number of levels is compatible with pack_type and x's size.
@@ -97,8 +100,9 @@ public:
     EKAT_KERNEL_ASSERT_MSG(num_levels >= 0 && pack_size<ScalarT>() * x.extent_int(0) >= num_levels,
                            "Error! Number of levels out of bounds.\n");
 
-    using ret_type     = decltype(std::declval<InputProvider>()(0));
-    using raw_ret_type = typename std::remove_const<typename std::remove_reference<ret_type>::type>::type;
+    using ret_type = decltype(std::declval<InputProvider>()(0));
+    using raw_ret_type =
+        typename std::remove_const<typename std::remove_reference<ret_type>::type>::type;
 
     static_assert(std::is_same<raw_ret_type, ScalarT>::value,
                   "Error! InputProvider should expose op()(int), returning a ScalarT.\n");
@@ -109,29 +113,31 @@ public:
 
   // Compute X at level midpoints, given X at level interfaces
   template <typename InputProvider, typename ScalarT, typename MT>
-  KOKKOS_INLINE_FUNCTION static void compute_midpoint_values(const TeamMember &team, const int num_mid_levels,
-                                                             const InputProvider &x_i,
-                                                             const view_1d<ScalarT, MT> &x_m) {
+  KOKKOS_INLINE_FUNCTION static void
+  compute_midpoint_values(const TeamMember &team, const int num_mid_levels,
+                          const InputProvider &x_i, const view_1d<ScalarT, MT> &x_m) {
     compute_midpoint_values<CombineMode::Replace>(team, num_mid_levels, x_i, x_m, 1, 0);
   }
   // Compute X at level midpoints, given X at level interfaces
   template <CombineMode CM, typename InputProvider, typename ScalarT, typename MT>
-  KOKKOS_INLINE_FUNCTION static void compute_midpoint_values(const TeamMember &team, const int num_mid_levels,
-                                                             const InputProvider &x_i, const view_1d<ScalarT, MT> &x_m,
-                                                             const scalar_type alpha = one(),
-                                                             const scalar_type beta  = zero()) {
+  KOKKOS_INLINE_FUNCTION static void
+  compute_midpoint_values(const TeamMember &team, const int num_mid_levels,
+                          const InputProvider &x_i, const view_1d<ScalarT, MT> &x_m,
+                          const scalar_type alpha = one(), const scalar_type beta = zero()) {
     // Sanity checks
     debug_checks<InputProvider>(num_mid_levels, x_m);
 
-    compute_midpoint_values_impl<CM, InputProvider, ScalarT, MT>(team, num_mid_levels, x_i, x_m, alpha, beta);
+    compute_midpoint_values_impl<CM, InputProvider, ScalarT, MT>(team, num_mid_levels, x_i, x_m,
+                                                                 alpha, beta);
   }
 
   // Compute X at level interfaces, given X at level midpoints and top and bot bc.
   // Note: with proper bc, and with constant dz, then x_int(x_mid(x_int))==x_int.
   template <typename InputProvider1, typename InputProvider2, typename ScalarT, typename MT>
   KOKKOS_INLINE_FUNCTION static void
-  compute_interface_values_linear(const TeamMember &team, const int num_mid_levels, const InputProvider1 &x_m,
-                                  const InputProvider2 &dz, const scalar_type &bc_top, const scalar_type &bc_bot,
+  compute_interface_values_linear(const TeamMember &team, const int num_mid_levels,
+                                  const InputProvider1 &x_m, const InputProvider2 &dz,
+                                  const scalar_type &bc_top, const scalar_type &bc_bot,
                                   const view_1d<ScalarT, MT> &x_i) {
     // Sanity checks
     debug_checks<InputProvider1>(num_mid_levels + 1, x_i);
@@ -151,8 +157,9 @@ public:
   //            "interior" interfaces. E.g., x_m==1, bc=0, yield x_i=[0,2,0,2,...].
   template <bool FixTop, typename InputProvider, typename ScalarT, typename MT>
   KOKKOS_INLINE_FUNCTION static void
-  compute_interface_values_compatible(const TeamMember &team, const int num_mid_levels, const InputProvider &x_m,
-                                      const scalar_type &bc, const view_1d<ScalarT, MT> &x_i) {
+  compute_interface_values_compatible(const TeamMember &team, const int num_mid_levels,
+                                      const InputProvider &x_m, const scalar_type &bc,
+                                      const view_1d<ScalarT, MT> &x_i) {
     // Sanity checks
     debug_checks<InputProvider>(num_mid_levels + 1, x_i);
 
@@ -161,19 +168,19 @@ public:
 
   // Given X at level interfaces, compute dX at level midpoints.
   template <typename InputProvider, typename ScalarT, typename MT>
-  KOKKOS_INLINE_FUNCTION static void compute_midpoint_delta(const TeamMember &team, const int num_mid_levels,
-                                                            const InputProvider &x_i, const view_1d<ScalarT, MT> &dx_m,
-                                                            const scalar_type alpha = one(),
-                                                            const scalar_type beta  = zero()) {
+  KOKKOS_INLINE_FUNCTION static void
+  compute_midpoint_delta(const TeamMember &team, const int num_mid_levels, const InputProvider &x_i,
+                         const view_1d<ScalarT, MT> &dx_m, const scalar_type alpha = one(),
+                         const scalar_type beta = zero()) {
     compute_midpoint_delta<CombineMode::Replace>(team, num_mid_levels, x_i, dx_m, alpha, beta);
   }
 
   // Given X at level interfaces, compute dX at level midpoints.
   template <CombineMode CM, typename InputProvider, typename ScalarT, typename MT>
-  KOKKOS_INLINE_FUNCTION static void compute_midpoint_delta(const TeamMember &team, const int num_mid_levels,
-                                                            const InputProvider &x_i, const view_1d<ScalarT, MT> &dx_m,
-                                                            const scalar_type alpha = one(),
-                                                            const scalar_type beta  = zero()) {
+  KOKKOS_INLINE_FUNCTION static void
+  compute_midpoint_delta(const TeamMember &team, const int num_mid_levels, const InputProvider &x_i,
+                         const view_1d<ScalarT, MT> &dx_m, const scalar_type alpha = one(),
+                         const scalar_type beta = zero()) {
     // Sanity checks
     debug_checks<InputProvider>(num_mid_levels, dx_m);
 
@@ -188,9 +195,9 @@ public:
   //  - InputProvider: must provide an input al all mid levels
   //  - s0: used as bc value at k=0 (FromTop=true) or k=num_mid_levels (FromTop=false)
   template <bool FromTop, typename InputProvider, typename ScalarT, typename MT>
-  KOKKOS_INLINE_FUNCTION static void column_scan(const TeamMember &team, const int num_mid_levels,
-                                                 const InputProvider &dx_m, const view_1d<ScalarT, MT> &x_i,
-                                                 const scalar_type &s0 = zero()) {
+  KOKKOS_INLINE_FUNCTION static void
+  column_scan(const TeamMember &team, const int num_mid_levels, const InputProvider &dx_m,
+              const view_1d<ScalarT, MT> &x_i, const scalar_type &s0 = zero()) {
     // Sanity checks
     debug_checks<InputProvider>(num_mid_levels + 1, x_i);
 
@@ -203,8 +210,9 @@ protected:
 
   template <CombineMode CM, typename InputProvider, typename ScalarT, typename MT>
   KOKKOS_INLINE_FUNCTION static typename std::enable_if<(pack_size<ScalarT>() == 1)>::type
-  compute_midpoint_values_impl(const TeamMember &team, const int num_mid_levels, const InputProvider &x_i,
-                               const view_1d<ScalarT, MT> &x_m, const scalar_type alpha, const scalar_type beta) {
+  compute_midpoint_values_impl(const TeamMember &team, const int num_mid_levels,
+                               const InputProvider &x_i, const view_1d<ScalarT, MT> &x_m,
+                               const scalar_type alpha, const scalar_type beta) {
     // For GPU (or any build with pack size 1), things are simpler
     team_parallel_for(team, num_mid_levels, [&](const int &k) {
       auto tmp = (x_i(k) + x_i(k + 1)) / 2.0;
@@ -214,8 +222,9 @@ protected:
 
   template <CombineMode CM, typename InputProvider, typename ScalarT, typename MT>
   KOKKOS_INLINE_FUNCTION static typename std::enable_if<(pack_size<ScalarT>() > 1)>::type
-  compute_midpoint_values_impl(const TeamMember &team, const int num_mid_levels, const InputProvider &x_i,
-                               const view_1d<ScalarT, MT> &x_m, const scalar_type alpha, const scalar_type beta) {
+  compute_midpoint_values_impl(const TeamMember &team, const int num_mid_levels,
+                               const InputProvider &x_i, const view_1d<ScalarT, MT> &x_m,
+                               const scalar_type alpha, const scalar_type beta) {
     using pack_type = ScalarT;
     using pack_info = ekat::PackInfo<pack_size<ScalarT>()>;
 
@@ -260,8 +269,9 @@ protected:
 
   template <CombineMode CM, typename InputProvider, typename ScalarT, typename MT>
   KOKKOS_INLINE_FUNCTION static typename std::enable_if<(pack_size<ScalarT>() == 1)>::type
-  compute_midpoint_delta_impl(const TeamMember &team, const int num_mid_levels, const InputProvider &x_i,
-                              const view_1d<ScalarT, MT> &dx_m, const scalar_type alpha, const scalar_type beta) {
+  compute_midpoint_delta_impl(const TeamMember &team, const int num_mid_levels,
+                              const InputProvider &x_i, const view_1d<ScalarT, MT> &dx_m,
+                              const scalar_type alpha, const scalar_type beta) {
     // For GPU (or any build with pack size 1), things are simpler
     team_parallel_for(team, num_mid_levels, [&](const int &k) {
       auto tmp = x_i(k + 1) - x_i(k);
@@ -271,8 +281,9 @@ protected:
 
   template <CombineMode CM, typename InputProvider, typename ScalarT, typename MT>
   KOKKOS_INLINE_FUNCTION static typename std::enable_if<(pack_size<ScalarT>() > 1)>::type
-  compute_midpoint_delta_impl(const TeamMember &team, const int num_mid_levels, const InputProvider &x_i,
-                              const view_1d<ScalarT, MT> &dx_m, const scalar_type alpha, const scalar_type beta) {
+  compute_midpoint_delta_impl(const TeamMember &team, const int num_mid_levels,
+                              const InputProvider &x_i, const view_1d<ScalarT, MT> &dx_m,
+                              const scalar_type alpha, const scalar_type beta) {
     using pack_info = ekat::PackInfo<pack_size<ScalarT>()>;
 
     const auto NUM_MID_PACKS = pack_info::num_packs(num_mid_levels);
@@ -317,23 +328,25 @@ protected:
       team_single(team, [&]() { x_i(0) = s0; });
       // No need for a barrier here
 
-      team_parallel_scan(team, num_mid_levels, [&](const int k, ScalarT &accumulator, const bool last) {
-        accumulator += dx_m(k);
-        if (last) {
-          x_i(k + 1) = s0 + accumulator;
-        }
-      });
+      team_parallel_scan(team, num_mid_levels,
+                         [&](const int k, ScalarT &accumulator, const bool last) {
+                           accumulator += dx_m(k);
+                           if (last) {
+                             x_i(k + 1) = s0 + accumulator;
+                           }
+                         });
     } else {
       team_single(team, [&]() { x_i(num_mid_levels) = s0; });
       // No need for a barrier here
 
-      team_parallel_scan(team, num_mid_levels, [&](const int k, ScalarT &accumulator, const bool last) {
-        const auto k_bwd = num_mid_levels - k - 1;
-        accumulator += dx_m(k_bwd);
-        if (last) {
-          x_i(k_bwd) = s0 + accumulator;
-        }
-      });
+      team_parallel_scan(team, num_mid_levels,
+                         [&](const int k, ScalarT &accumulator, const bool last) {
+                           const auto k_bwd = num_mid_levels - k - 1;
+                           accumulator += dx_m(k_bwd);
+                           if (last) {
+                             x_i(k_bwd) = s0 + accumulator;
+                           }
+                         });
     }
   }
 
@@ -341,8 +354,9 @@ protected:
   KOKKOS_INLINE_FUNCTION static typename std::enable_if<(pack_size<ScalarT>() > 1)>::type
   column_scan_impl(const TeamMember &team, const int num_mid_levels, const InputProvider &dx_m,
                    const view_1d<ScalarT, MT> &x_i, const scalar_type &s0 = zero()) {
-    EKAT_KERNEL_ASSERT_MSG(pack_size<ScalarT>() <= num_mid_levels,
-                           "Error! Currently, column_scan_impl() is not implemented for pack_size > num_mid_levels.");
+    EKAT_KERNEL_ASSERT_MSG(
+        pack_size<ScalarT>() <= num_mid_levels,
+        "Error! Currently, column_scan_impl() is not implemented for pack_size > num_mid_levels.");
 
     using pack_type          = ScalarT;
     constexpr int PackLength = pack_size<ScalarT>();
@@ -434,7 +448,8 @@ protected:
           }
         });
         team.team_barrier();
-        column_scan_impl<FromTop>(team, (NUM_MID_PACKS - 1) * PackLength, dx_m, x_i, x_i(NUM_INT_PACKS - 1)[0]);
+        column_scan_impl<FromTop>(team, (NUM_MID_PACKS - 1) * PackLength, dx_m, x_i,
+                                  x_i(NUM_INT_PACKS - 1)[0]);
       } else {
         // In this case, all packs of dx_m are full of meaningful values.
         auto packed_scan_from_bot = [&](const int &k, pack_type &accumulator, const bool last) {
@@ -484,8 +499,9 @@ protected:
 
   template <typename InputProvider1, typename InputProvider2, typename ScalarT, typename MT>
   KOKKOS_INLINE_FUNCTION static typename std::enable_if<(pack_size<ScalarT>() == 1)>::type
-  compute_interface_values_linear_impl(const TeamMember &team, const int num_mid_levels, const InputProvider1 &x_m,
-                                       const InputProvider2 &dz, const scalar_type &bc_top, const scalar_type &bc_bot,
+  compute_interface_values_linear_impl(const TeamMember &team, const int num_mid_levels,
+                                       const InputProvider1 &x_m, const InputProvider2 &dz,
+                                       const scalar_type &bc_top, const scalar_type &bc_bot,
                                        const view_1d<ScalarT, MT> &x_i) {
     // Pack size 1 yields a simple impl
     team_parallel_for(team, num_mid_levels + 1, [&](const int k) {
@@ -500,8 +516,9 @@ protected:
 
   template <typename InputProvider1, typename InputProvider2, typename ScalarT, typename MT>
   KOKKOS_INLINE_FUNCTION static typename std::enable_if<(pack_size<ScalarT>() > 1)>::type
-  compute_interface_values_linear_impl(const TeamMember &team, const int num_mid_levels, const InputProvider1 &x_m,
-                                       const InputProvider2 &dz, const scalar_type &bc_top, const scalar_type &bc_bot,
+  compute_interface_values_linear_impl(const TeamMember &team, const int num_mid_levels,
+                                       const InputProvider1 &x_m, const InputProvider2 &dz,
+                                       const scalar_type &bc_top, const scalar_type &bc_bot,
                                        const view_1d<ScalarT, MT> &x_i) {
     using PackType           = ScalarT;
     constexpr int PackLength = pack_size<PackType>();
@@ -536,8 +553,9 @@ protected:
 
   template <bool FixTop, typename InputProvider, typename ScalarT, typename MT>
   KOKKOS_INLINE_FUNCTION static typename std::enable_if<(pack_size<ScalarT>() == 1)>::type
-  compute_interface_values_compatible_impl(const TeamMember &team, const int num_mid_levels, const InputProvider &x_m,
-                                           const scalar_type &bc, const view_1d<ScalarT, MT> &x_i) {
+  compute_interface_values_compatible_impl(const TeamMember &team, const int num_mid_levels,
+                                           const InputProvider &x_m, const scalar_type &bc,
+                                           const view_1d<ScalarT, MT> &x_i) {
     // Helper function that returns (-1)^k
     auto m1_pow_k = [](const int k) -> scalar_type { return 1 - 2 * (k % 2); };
 
@@ -573,8 +591,9 @@ protected:
 
   template <bool FixTop, typename InputProvider, typename ScalarT, typename MT>
   KOKKOS_INLINE_FUNCTION static typename std::enable_if<(pack_size<ScalarT>() > 1)>::type
-  compute_interface_values_compatible_impl(const TeamMember &team, const int num_mid_levels, const InputProvider &x_m,
-                                           const scalar_type &bc, const view_1d<ScalarT, MT> &x_i) {
+  compute_interface_values_compatible_impl(const TeamMember &team, const int num_mid_levels,
+                                           const InputProvider &x_m, const scalar_type &bc,
+                                           const view_1d<ScalarT, MT> &x_i) {
     using pack_type          = ScalarT;
     constexpr int PackLength = pack_size<ScalarT>();
     using pack_info          = ekat::PackInfo<PackLength>;
@@ -599,14 +618,16 @@ protected:
       //   x_i(k+1) = (-1)^k [ -x_i(0) + 2\Sum_{n=0}^k (-1)^n x_m(n) ]
       // At this stage, x_i(k) contains the part within the \Sum
 
-      team_parallel_for(team, NUM_INT_PACKS, [&](const int k) { x_i(k) = sign * (bc - 2.0 * x_i(k)); });
+      team_parallel_for(team, NUM_INT_PACKS,
+                        [&](const int k) { x_i(k) = sign * (bc - 2.0 * x_i(k)); });
     } else {
       // Final formula:
       //   x_i(k) = (-1)^k [ (-1)^N x_i(N) + 2\Sum_{n=k}^{N-1} (-1)^n x_m(n) ]
       // At this stage, x_i(k) contains the part within the \Sum
 
-      team_parallel_for(team, NUM_INT_PACKS,
-                        [&](const int k) { x_i(k) = sign * (bc * m1_pow_k(num_mid_levels) + 2.0 * x_i(k)); });
+      team_parallel_for(team, NUM_INT_PACKS, [&](const int k) {
+        x_i(k) = sign * (bc * m1_pow_k(num_mid_levels) + 2.0 * x_i(k));
+      });
     }
   }
 
@@ -616,40 +637,44 @@ protected:
 
   // Runs the input lambda with a TeamVectorRange parallel for over [0,count) range
   template <typename Lambda>
-  KOKKOS_INLINE_FUNCTION static void team_parallel_for(const TeamMember &team, const int count, const Lambda &f) {
+  KOKKOS_INLINE_FUNCTION static void team_parallel_for(const TeamMember &team, const int count,
+                                                       const Lambda &f) {
     Kokkos::parallel_for(Kokkos::TeamVectorRange(team, count), f);
   }
 
   // Runs the input lambda with a TeamVectorRange parallel for over [start,end) range
   template <typename Lambda>
-  KOKKOS_INLINE_FUNCTION static void team_parallel_for(const TeamMember &team, const int start, const int end,
-                                                       const Lambda &f) {
+  KOKKOS_INLINE_FUNCTION static void team_parallel_for(const TeamMember &team, const int start,
+                                                       const int end, const Lambda &f) {
     Kokkos::parallel_for(Kokkos::TeamVectorRange(team, start, end), f);
   }
 
   // Runs the input lambda with a TeamVectorRange parallel scan over [0,count) range
   template <typename Lambda>
-  KOKKOS_INLINE_FUNCTION static void team_parallel_scan(const TeamMember &team, const int count, const Lambda &f) {
+  KOKKOS_INLINE_FUNCTION static void team_parallel_scan(const TeamMember &team, const int count,
+                                                        const Lambda &f) {
     team_parallel_scan(team, 0, count, f);
   }
 
   // Runs the input lambda with a TeamVectorRange parallel scan over [start,end) range
   template <typename Lambda>
-  KOKKOS_INLINE_FUNCTION static void team_parallel_scan(const TeamMember &team, const int start, const int end,
-                                                        const Lambda &f) {
+  KOKKOS_INLINE_FUNCTION static void team_parallel_scan(const TeamMember &team, const int start,
+                                                        const int end, const Lambda &f) {
     auto is_pow_of_2 = [](const int n) -> bool {
       // This seems funky, but write down a pow of 2 and a non-pow of 2 in binary (both positive),
       // and you'll see why it works
       return n > 0 && (n & (n - 1)) == 0;
     };
-    EKAT_KERNEL_REQUIRE_MSG(!ekat::OnGpu<typename device_type::execution_space>::value || is_pow_of_2(team.team_size()),
-                            "Error! Team-level parallel_scan on CUDA only works for team sizes that are power of 2.\n"
-                            "       You could try to reduce the team size to the previous pow of 2.\n");
+    EKAT_KERNEL_REQUIRE_MSG(
+        !ekat::OnGpu<typename device_type::execution_space>::value || is_pow_of_2(team.team_size()),
+        "Error! Team-level parallel_scan on CUDA only works for team sizes that are power of 2.\n"
+        "       You could try to reduce the team size to the previous pow of 2.\n");
     Kokkos::parallel_scan(Kokkos::TeamThreadRange(team, start, end), f);
   }
 
   // Runs the input lambda only for one team thread
-  template <typename Lambda> KOKKOS_INLINE_FUNCTION static void team_single(const TeamMember &team, const Lambda &f) {
+  template <typename Lambda>
+  KOKKOS_INLINE_FUNCTION static void team_single(const TeamMember &team, const Lambda &f) {
     Kokkos::single(Kokkos::PerTeam(team), f);
   }
 };
diff --git i/components/eamxx/src/share/util/eamxx_combine_ops.hpp w/components/eamxx/src/share/util/eamxx_combine_ops.hpp
index 5900a2f6ca..9477ebc93f 100644
--- i/components/eamxx/src/share/util/eamxx_combine_ops.hpp
+++ w/components/eamxx/src/share/util/eamxx_combine_ops.hpp
@@ -43,8 +43,8 @@ enum class CombineMode {
 
 template <CombineMode CM, typename ScalarIn, typename ScalarOut,
           typename CoeffType = typename ekat::ScalarTraits<ScalarIn>::scalar_type>
-KOKKOS_FORCEINLINE_FUNCTION void combine(const ScalarIn &newVal, ScalarOut &result, const CoeffType alpha,
-                                         const CoeffType beta) {
+KOKKOS_FORCEINLINE_FUNCTION void combine(const ScalarIn &newVal, ScalarOut &result,
+                                         const CoeffType alpha, const CoeffType beta) {
   switch (CM) {
   case CombineMode::Replace:
     result = alpha * newVal;
@@ -64,8 +64,9 @@ KOKKOS_FORCEINLINE_FUNCTION void combine(const ScalarIn &newVal, ScalarOut &resu
 /* Special version of combine that takes a mask into account */
 template <CombineMode CM, typename ScalarIn, typename ScalarOut,
           typename CoeffType = typename ekat::ScalarTraits<ScalarIn>::scalar_type>
-KOKKOS_FORCEINLINE_FUNCTION void combine_and_fill(const ScalarIn &newVal, ScalarOut &result, const ScalarOut fill_val,
-                                                  const CoeffType alpha, const CoeffType beta) {
+KOKKOS_FORCEINLINE_FUNCTION void combine_and_fill(const ScalarIn &newVal, ScalarOut &result,
+                                                  const ScalarOut fill_val, const CoeffType alpha,
+                                                  const CoeffType beta) {
   switch (CM) {
   case CombineMode::Replace:
     combine<CM>(newVal, result, alpha, beta);
diff --git i/components/eamxx/src/share/util/eamxx_common_physics_functions.hpp w/components/eamxx/src/share/util/eamxx_common_physics_functions.hpp
index 01a639c056..1123422af7 100644
--- i/components/eamxx/src/share/util/eamxx_common_physics_functions.hpp
+++ w/components/eamxx/src/share/util/eamxx_common_physics_functions.hpp
@@ -33,7 +33,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //        routine for a rectangular (or other shape) area.
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_dx_from_area(const ScalarT &area, const ScalarT &lat);
+  KOKKOS_INLINE_FUNCTION static ScalarT calculate_dx_from_area(const ScalarT &area,
+                                                               const ScalarT &lat);
 
   //-----------------------------------------------------------------------------------------------//
   // Determines the density given the definition of pseudo_density passed by the dycore
@@ -45,7 +46,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   g              is the gravitational constant, [m/s2] - defined in physics_constants.hpp
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_density(const ScalarT &pseudo_density, const ScalarT &dz);
+  KOKKOS_INLINE_FUNCTION static ScalarT calculate_density(const ScalarT &pseudo_density,
+                                                          const ScalarT &dz);
 
   //-----------------------------------------------------------------------------------------------//
   // Determines the vertical wind velocity given the vertical pressure velocity
@@ -56,7 +58,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   g              is the gravitational constant, [m/s2] - defined in physics_constants.hpp
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_vertical_velocity(const ScalarT &omega, const ScalarT &density);
+  KOKKOS_INLINE_FUNCTION static ScalarT calculate_vertical_velocity(const ScalarT &omega,
+                                                                    const ScalarT &density);
 
   //-----------------------------------------------------------------------------------------------//
   // Applies Exners Function which follows:
@@ -73,7 +76,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   T  is the temperature, [K]
   //   th is the potential temperature, [K]
   //-----------------------------------------------------------------------------------------------//
-  template <typename ScalarT> KOKKOS_INLINE_FUNCTION static ScalarT exner_function(const ScalarT &pressure);
+  template <typename ScalarT>
+  KOKKOS_INLINE_FUNCTION static ScalarT exner_function(const ScalarT &pressure);
 
   //-----------------------------------------------------------------------------------------------//
   // Converts temperature to potential temperature using Exners function:
@@ -84,7 +88,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   pressure  is the pressure, [Pa].  Used for exners formula, see definition above, unitless
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_theta_from_T(const ScalarT &temperature, const ScalarT &pressure);
+  KOKKOS_INLINE_FUNCTION static ScalarT calculate_theta_from_T(const ScalarT &temperature,
+                                                               const ScalarT &pressure);
 
   //-----------------------------------------------------------------------------------------------//
   // Converts potential temperature to liquid potental temperature:
@@ -96,8 +101,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   and the others are constants
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_thetal_from_theta(const ScalarT &theta, const ScalarT &temperature,
-                                                                    const ScalarT &qc);
+  KOKKOS_INLINE_FUNCTION static ScalarT
+  calculate_thetal_from_theta(const ScalarT &theta, const ScalarT &temperature, const ScalarT &qc);
 
   //-----------------------------------------------------------------------------------------------//
   // Converts potential temperature to temperature using Exners function:
@@ -108,7 +113,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   pressure  is the pressure, [Pa].  Used for exners formula, see definition above, unitless
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_T_from_theta(const ScalarT &theta, const ScalarT &pressure);
+  KOKKOS_INLINE_FUNCTION static ScalarT calculate_T_from_theta(const ScalarT &theta,
+                                                               const ScalarT &pressure);
 
   //-----------------------------------------------------------------------------------------------//
   // Compute temperature from virtual temperature
@@ -120,8 +126,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   temperature is the atmospheric temperature.  Units in [K].
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_temperature_from_virtual_temperature(const ScalarT &T_virtual,
-                                                                                       const ScalarT &qv);
+  KOKKOS_INLINE_FUNCTION static ScalarT
+  calculate_temperature_from_virtual_temperature(const ScalarT &T_virtual, const ScalarT &qv);
 
   //-----------------------------------------------------------------------------------------------//
   // Compute virtual temperature
@@ -133,7 +139,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   T_virtual   is the virtual temperature.  Units in [K].
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_virtual_temperature(const ScalarT &temperature, const ScalarT &qv);
+  KOKKOS_INLINE_FUNCTION static ScalarT calculate_virtual_temperature(const ScalarT &temperature,
+                                                                      const ScalarT &qv);
 
   //-----------------------------------------------------------------------------------------------//
   // Compute dry static energy (DSE).
@@ -162,12 +169,13 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   temperature       is the atmospheric temperature. Units in [K].
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_temperature_from_dse(const ScalarT &dse, const ScalarT &z,
-                                                                       const Real surf_geopotential);
+  KOKKOS_INLINE_FUNCTION static ScalarT
+  calculate_temperature_from_dse(const ScalarT &dse, const ScalarT &z,
+                                 const Real surf_geopotential);
 
   //-----------------------------------------------------------------------------------------------//
-  // Computes drymmr (mass of a constituent divided by mass of dry air; commonly known as mixing ratio)
-  // for any wetmmr constituent (mass of a constituent divided by mass of dry air plus water
+  // Computes drymmr (mass of a constituent divided by mass of dry air; commonly known as mixing
+  // ratio) for any wetmmr constituent (mass of a constituent divided by mass of dry air plus water
   // vapor) using qv_wet (mass of water vapor divided by mass of dry air plus
   // water vapor; see specific humidity):
   //   drymmr = wetmmr / (1 - qv_wet)
@@ -177,7 +185,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   qv_wet         is water vapor wet mass mixing ratio
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_drymmr_from_wetmmr(const ScalarT &wetmmr, const ScalarT &qv_wet);
+  KOKKOS_INLINE_FUNCTION static ScalarT calculate_drymmr_from_wetmmr(const ScalarT &wetmmr,
+                                                                     const ScalarT &qv_wet);
 
   //-----------------------------------------------------------------------------------------------//
   // Computes wetmmr (mass of a constituent divided by mass of dry air plus water vapor)
@@ -191,7 +200,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   qv_dry         is specific humidity of water vapor
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_wetmmr_from_drymmr(const ScalarT &drymmr, const ScalarT &qv_dry);
+  KOKKOS_INLINE_FUNCTION static ScalarT calculate_wetmmr_from_drymmr(const ScalarT &drymmr,
+                                                                     const ScalarT &qv_dry);
 
   //-----------------------------------------------------------------------------------------------//
   // Computes drymmr (mass of a constituent divided by mass of dry air)
@@ -205,9 +215,9 @@ template <typename DeviceT> struct PhysicsFunctions {
   //-----------------------------------------------------------------------------------------------//
 
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_drymmr_from_wetmmr_dp_based(const ScalarT &wetmmr,
-                                                                              const ScalarT &pseudo_density,
-                                                                              const ScalarT &pseudo_density_dry);
+  KOKKOS_INLINE_FUNCTION static ScalarT
+  calculate_drymmr_from_wetmmr_dp_based(const ScalarT &wetmmr, const ScalarT &pseudo_density,
+                                        const ScalarT &pseudo_density_dry);
 
   //-----------------------------------------------------------------------------------------------//
   // Computes wetmmr (mass of a constituent divided by mass of wet air)
@@ -220,9 +230,9 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   pseudo_density_dry is dry pseudodensity (pdeldry)
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_wetmmr_from_drymmr_dp_based(const ScalarT &drymmr,
-                                                                              const ScalarT &pseudo_density,
-                                                                              const ScalarT &pseudo_density_dry);
+  KOKKOS_INLINE_FUNCTION static ScalarT
+  calculate_wetmmr_from_drymmr_dp_based(const ScalarT &drymmr, const ScalarT &pseudo_density,
+                                        const ScalarT &pseudo_density_dry);
 
   //-----------------------------------------------------------------------------------------------//
   // Determines the vertical layer thickness using the equation of state:
@@ -230,19 +240,19 @@ template <typename DeviceT> struct PhysicsFunctions {
   // where
   //   dz             is the vertical layer thickness, [m]
   //   pseudo_density is the pressure level thickness, [Pa]
-  //   T_virtual      is the virtual temperature - calculated using a separate function from this suite, [K]
-  //   p_mid          is the avgerage atmosphere pressure over the level, [Pa]
-  //   g              is the graviational constant, [m s-2]
-  //   Rd             is the universal gas constant for dry air, [J/kg/K]
-  //   T_mid          is the atmospheric temperature, [K] - needed for T_virtual
-  //   qv             is the water vapor mass mixing ratio, [kg/kg] - needed for T_virtual
+  //   T_virtual      is the virtual temperature - calculated using a separate function from this
+  //   suite, [K] p_mid          is the avgerage atmosphere pressure over the level, [Pa] g is the
+  //   graviational constant, [m s-2] Rd             is the universal gas constant for dry air,
+  //   [J/kg/K] T_mid          is the atmospheric temperature, [K] - needed for T_virtual qv is the
+  //   water vapor mass mixing ratio, [kg/kg] - needed for T_virtual
   //
   // Note: the extra negative sign is due to the fact that the pseudo_density
   // in the model is measured in the positive direction.
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_dz(const ScalarT &pseudo_density, const ScalarT &p_mid,
-                                                     const ScalarT &T_mid, const ScalarT &qv);
+  KOKKOS_INLINE_FUNCTION static ScalarT calculate_dz(const ScalarT &pseudo_density,
+                                                     const ScalarT &p_mid, const ScalarT &T_mid,
+                                                     const ScalarT &qv);
 
   //-----------------------------------------------------------------------------------------------//
   // Calculate the volume mixing ratio given the wet mass mixing ratio:
@@ -255,8 +265,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   mol_weight_X   is the molecular weight of X
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_vmr_from_mmr(const Real &gas_mol_weight, const ScalarT &qv,
-                                                               const ScalarT &mmr);
+  KOKKOS_INLINE_FUNCTION static ScalarT
+  calculate_vmr_from_mmr(const Real &gas_mol_weight, const ScalarT &qv, const ScalarT &mmr);
 
   //-----------------------------------------------------------------------------------------------//
   // Calculate wet mass mixing ratio the given the volume mixing ratio:
@@ -267,47 +277,41 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   qv             is the water vapor mass mixing ratio
   //   mol_weight_air is the molecular weight of dry air
   //   mol_weight_X   is the molecular weight of X
-  //   a = mol_weight_X/mol_weight_air is the ratio of the molecular weight of the gas to the molecular weight of dry
-  //   air
+  //   a = mol_weight_X/mol_weight_air is the ratio of the molecular weight of the gas to the
+  //   molecular weight of dry air
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static ScalarT calculate_mmr_from_vmr(const Real &gas_mol_weight, const ScalarT &qv,
-                                                               const ScalarT &vmr);
+  KOKKOS_INLINE_FUNCTION static ScalarT
+  calculate_mmr_from_vmr(const Real &gas_mol_weight, const ScalarT &qv, const ScalarT &vmr);
 
   //-----------------------------------------------------------------------------------------------
   // Calculate T at the bottom of the grid cell closest to the surface for use in PSL computation.
-  // This is done assuming a 6.5 K/km lapse rate, which is a horrible assumption but avoids problems that
-  // computing lapse rate via extrapolation might produce strange answers. It is also what CESM has done
-  // for the last 20 yrs so seems to be sufficient. Don't assume this method is appropriate for any other use.
-  // INPUTS:
-  // T_mid_bot
-  // z_mid_bot
-  // RETURNS:
-  // T at the bottom of the cell nearest the surface (K)
+  // This is done assuming a 6.5 K/km lapse rate, which is a horrible assumption but avoids problems
+  // that computing lapse rate via extrapolation might produce strange answers. It is also what CESM
+  // has done for the last 20 yrs so seems to be sufficient. Don't assume this method is appropriate
+  // for any other use. INPUTS: T_mid_bot z_mid_bot RETURNS: T at the bottom of the cell nearest the
+  // surface (K)
   //-----------------------------------------------------------------------------------------------
   KOKKOS_INLINE_FUNCTION
   static Real calculate_surface_air_T(const Real &T_mid_bot, const Real &z_mid_bot);
 
   //-----------------------------------------------------------------------------------------------//
-  // Compute the lapse rate and effective ground temperature for use in calculating psl. This function should only
-  // be used by calculate_psl.
-  // INPUTS:
-  // T_ground is the air temperature at the bottom of the cell closest to the surface (aka T_int[nlev+1]; K)
-  // phi_ground is the geopotential at surface (aka surf_geopotential; m2/s2)
-  // OUTPUTS:
-  // lapse (K/m) is the lapse rate
-  // T_ground_tmp is the effective ground temperature (K)
+  // Compute the lapse rate and effective ground temperature for use in calculating psl. This
+  // function should only be used by calculate_psl. INPUTS: T_ground is the air temperature at the
+  // bottom of the cell closest to the surface (aka T_int[nlev+1]; K) phi_ground is the geopotential
+  // at surface (aka surf_geopotential; m2/s2) OUTPUTS: lapse (K/m) is the lapse rate T_ground_tmp
+  // is the effective ground temperature (K)
   //-----------------------------------------------------------------------------------------------//
   KOKKOS_INLINE_FUNCTION
-  static void lapse_T_for_psl(const Real &T_ground, const Real &phi_ground, Real &lapse, Real &T_ground_tmp);
+  static void lapse_T_for_psl(const Real &T_ground, const Real &phi_ground, Real &lapse,
+                              Real &T_ground_tmp);
 
   //-----------------------------------------------------------------------------------------------//
   // Calculate sea level pressure assuming dry air between ground and sea level and using a lapse
-  // rate of 6.5K/km except in very warm conditions. See docs/tech_doc/physics/psl/psl_doc.tex for details
-  // INPUTS:
-  // T_ground is the air temperature at the bottom of the cell closest to the surface (aka T_int[nlev+1]; K)
-  // p_ground is the pressure at the bottom of the cell closest to the surface (Pa)
-  // phi_ground is the geopotential at surface (aka surf_geopotential; m2/s2)
+  // rate of 6.5K/km except in very warm conditions. See docs/tech_doc/physics/psl/psl_doc.tex for
+  // details INPUTS: T_ground is the air temperature at the bottom of the cell closest to the
+  // surface (aka T_int[nlev+1]; K) p_ground is the pressure at the bottom of the cell closest to
+  // the surface (Pa) phi_ground is the geopotential at surface (aka surf_geopotential; m2/s2)
   // OUTPUTS:
   // psl is the sea level pressure (Pa)
   //-----------------------------------------------------------------------------------------------//
@@ -328,8 +332,9 @@ template <typename DeviceT> struct PhysicsFunctions {
   // T_mid is the atmospheric temperature at the midpoints [K]
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT>
-  KOKKOS_INLINE_FUNCTION static void apply_rayleigh_friction(const Real dt, const ScalarT &otau, ScalarT &u_wind,
-                                                             ScalarT &v_wind, ScalarT &T_mid);
+  KOKKOS_INLINE_FUNCTION static void apply_rayleigh_friction(const Real dt, const ScalarT &otau,
+                                                             ScalarT &u_wind, ScalarT &v_wind,
+                                                             ScalarT &T_mid);
 
   // ---------------------------------------------------------------- //
   //                     Whole column Functions                       //
@@ -365,90 +370,95 @@ template <typename DeviceT> struct PhysicsFunctions {
   using view_1d = typename KT::template view_1d<ScalarT, MT>;
 
   template <typename ScalarT, typename InputProviderP, typename InputProviderZ>
-  KOKKOS_INLINE_FUNCTION static void calculate_density(const MemberType &team, const InputProviderP &pseudo_density,
-                                                       const InputProviderZ &dz, const view_1d<ScalarT> &density);
+  KOKKOS_INLINE_FUNCTION static void
+  calculate_density(const MemberType &team, const InputProviderP &pseudo_density,
+                    const InputProviderZ &dz, const view_1d<ScalarT> &density);
 
   template <typename ScalarT, typename InputProviderOmega, typename InputProviderRho>
   KOKKOS_INLINE_FUNCTION static void
-  calculate_vertical_velocity(const MemberType &team, const InputProviderOmega &omega, const InputProviderRho &rho,
-                              const view_1d<ScalarT> &w);
+  calculate_vertical_velocity(const MemberType &team, const InputProviderOmega &omega,
+                              const InputProviderRho &rho, const view_1d<ScalarT> &w);
 
   template <typename ScalarT, typename InputProviderP>
-  KOKKOS_INLINE_FUNCTION static void exner_function(const MemberType &team, const InputProviderP &pressure,
+  KOKKOS_INLINE_FUNCTION static void exner_function(const MemberType &team,
+                                                    const InputProviderP &pressure,
                                                     const view_1d<ScalarT> &exner);
 
   template <typename ScalarT, typename InputProviderT, typename InputProviderP>
-  KOKKOS_INLINE_FUNCTION static void calculate_theta_from_T(const MemberType &team, const InputProviderT &temperature,
-                                                            const InputProviderP &pressure,
-                                                            const view_1d<ScalarT> &theta);
+  KOKKOS_INLINE_FUNCTION static void
+  calculate_theta_from_T(const MemberType &team, const InputProviderT &temperature,
+                         const InputProviderP &pressure, const view_1d<ScalarT> &theta);
 
-  template <typename ScalarT, typename InputProviderTheta, typename InputProviderT, typename InputProviderQ>
+  template <typename ScalarT, typename InputProviderTheta, typename InputProviderT,
+            typename InputProviderQ>
   KOKKOS_INLINE_FUNCTION static void
   calculate_thetal_from_theta(const MemberType &team, const InputProviderTheta &theta,
                               const InputProviderT &temperature, const InputProviderQ &qc,
                               const view_1d<ScalarT> &thetal);
   template <typename ScalarT, typename InputProviderT, typename InputProviderP>
-  KOKKOS_INLINE_FUNCTION static void calculate_T_from_theta(const MemberType &team, const InputProviderT &theta,
-                                                            const InputProviderP &pressure,
-                                                            const view_1d<ScalarT> &temperature);
+  KOKKOS_INLINE_FUNCTION static void
+  calculate_T_from_theta(const MemberType &team, const InputProviderT &theta,
+                         const InputProviderP &pressure, const view_1d<ScalarT> &temperature);
+
+  template <typename ScalarT, typename InputProviderT, typename InputProviderQ>
+  KOKKOS_INLINE_FUNCTION static void calculate_temperature_from_virtual_temperature(
+      const MemberType &team, const InputProviderT &T_virtual, const InputProviderQ &qv,
+      const view_1d<ScalarT> &temperature);
 
   template <typename ScalarT, typename InputProviderT, typename InputProviderQ>
   KOKKOS_INLINE_FUNCTION static void
-  calculate_temperature_from_virtual_temperature(const MemberType &team, const InputProviderT &T_virtual,
-                                                 const InputProviderQ &qv, const view_1d<ScalarT> &temperature);
-
-  template <typename ScalarT, typename InputProviderT, typename InputProviderQ>
-  KOKKOS_INLINE_FUNCTION static void
-  calculate_virtual_temperature(const MemberType &team, const InputProviderT &temperature, const InputProviderQ &qv,
-                                const view_1d<ScalarT> &T_virtual);
-
-  template <typename ScalarT, typename InputProviderT, typename InputProviderZ>
-  KOKKOS_INLINE_FUNCTION static void calculate_dse(const MemberType &team, const InputProviderT &temperature,
-                                                   const InputProviderZ &z, const Real surf_geopotential,
-                                                   const view_1d<ScalarT> &dse);
+  calculate_virtual_temperature(const MemberType &team, const InputProviderT &temperature,
+                                const InputProviderQ &qv, const view_1d<ScalarT> &T_virtual);
 
   template <typename ScalarT, typename InputProviderT, typename InputProviderZ>
   KOKKOS_INLINE_FUNCTION static void
-  calculate_temperature_from_dse(const MemberType &team, const InputProviderT &dse, const InputProviderZ &z,
-                                 const Real surf_geopotential, const view_1d<ScalarT> &temperature);
+  calculate_dse(const MemberType &team, const InputProviderT &temperature, const InputProviderZ &z,
+                const Real surf_geopotential, const view_1d<ScalarT> &dse);
+
+  template <typename ScalarT, typename InputProviderT, typename InputProviderZ>
+  KOKKOS_INLINE_FUNCTION static void
+  calculate_temperature_from_dse(const MemberType &team, const InputProviderT &dse,
+                                 const InputProviderZ &z, const Real surf_geopotential,
+                                 const view_1d<ScalarT> &temperature);
 
   template <typename ScalarT, typename InputProviderX, typename InputProviderQ>
-  KOKKOS_INLINE_FUNCTION static void calculate_wetmmr_from_drymmr(const MemberType &team, const InputProviderX &drymmr,
-                                                                  const InputProviderQ &qv,
-                                                                  const view_1d<ScalarT> &wetmmr);
+  KOKKOS_INLINE_FUNCTION static void
+  calculate_wetmmr_from_drymmr(const MemberType &team, const InputProviderX &drymmr,
+                               const InputProviderQ &qv, const view_1d<ScalarT> &wetmmr);
 
   template <typename ScalarT, typename InputProviderX, typename InputProviderQ>
-  KOKKOS_INLINE_FUNCTION static void calculate_drymmr_from_wetmmr(const MemberType &team, const InputProviderX &wetmmr,
-                                                                  const InputProviderQ &qv_wet,
-                                                                  const view_1d<ScalarT> &drymmr);
+  KOKKOS_INLINE_FUNCTION static void
+  calculate_drymmr_from_wetmmr(const MemberType &team, const InputProviderX &wetmmr,
+                               const InputProviderQ &qv_wet, const view_1d<ScalarT> &drymmr);
 
   template <typename ScalarT, typename InputProviderX, typename InputProviderPD>
-  KOKKOS_INLINE_FUNCTION static void
-  calculate_wetmmr_from_drymmr_dp_based(const MemberType &team, const InputProviderX &drymmr,
-                                        const InputProviderPD &pseudo_density,
-                                        const InputProviderPD &pseudo_density_dry, const view_1d<ScalarT> &wetmmr);
+  KOKKOS_INLINE_FUNCTION static void calculate_wetmmr_from_drymmr_dp_based(
+      const MemberType &team, const InputProviderX &drymmr, const InputProviderPD &pseudo_density,
+      const InputProviderPD &pseudo_density_dry, const view_1d<ScalarT> &wetmmr);
 
   template <typename ScalarT, typename InputProviderX, typename InputProviderPD>
+  KOKKOS_INLINE_FUNCTION static void calculate_drymmr_from_wetmmr_dp_based(
+      const MemberType &team, const InputProviderX &wetmmr, const InputProviderPD &pseudo_density,
+      const InputProviderPD &pseudo_density_dry, const view_1d<ScalarT> &drymmr);
+
+  template <typename ScalarT, typename InputProviderPD, typename InputProviderP,
+            typename InputProviderT, typename InputProviderQ, typename MT = Kokkos::MemoryManaged>
   KOKKOS_INLINE_FUNCTION static void
-  calculate_drymmr_from_wetmmr_dp_based(const MemberType &team, const InputProviderX &wetmmr,
-                                        const InputProviderPD &pseudo_density,
-                                        const InputProviderPD &pseudo_density_dry, const view_1d<ScalarT> &drymmr);
-
-  template <typename ScalarT, typename InputProviderPD, typename InputProviderP, typename InputProviderT,
-            typename InputProviderQ, typename MT = Kokkos::MemoryManaged>
-  KOKKOS_INLINE_FUNCTION static void calculate_dz(const MemberType &team, const InputProviderPD &pseudo_density,
-                                                  const InputProviderP &p_mid, const InputProviderT &T_mid,
-                                                  const InputProviderQ &qv, const view_1d<ScalarT, MT> &dz);
+  calculate_dz(const MemberType &team, const InputProviderPD &pseudo_density,
+               const InputProviderP &p_mid, const InputProviderT &T_mid, const InputProviderQ &qv,
+               const view_1d<ScalarT, MT> &dz);
 
   template <typename ScalarT, typename InputProviderQ, typename InputProviderX>
-  KOKKOS_INLINE_FUNCTION static void calculate_vmr_from_mmr(const MemberType &team, const Real gas_mol_weight,
-                                                            const InputProviderQ &qv, const InputProviderX &mmr,
-                                                            const view_1d<ScalarT> &vmr);
+  KOKKOS_INLINE_FUNCTION static void
+  calculate_vmr_from_mmr(const MemberType &team, const Real gas_mol_weight,
+                         const InputProviderQ &qv, const InputProviderX &mmr,
+                         const view_1d<ScalarT> &vmr);
 
   template <typename ScalarT, typename InputProviderQ, typename InputProviderX>
-  KOKKOS_INLINE_FUNCTION static void calculate_mmr_from_vmr(const MemberType &team, const Real gas_mol_weight,
-                                                            const InputProviderQ &qv, const InputProviderX &vmr,
-                                                            const view_1d<ScalarT> &mmr);
+  KOKKOS_INLINE_FUNCTION static void
+  calculate_mmr_from_vmr(const MemberType &team, const Real gas_mol_weight,
+                         const InputProviderQ &qv, const InputProviderX &vmr,
+                         const view_1d<ScalarT> &mmr);
 
   template <typename ScalarT, typename InputProviderOtau, typename MT = Kokkos::MemoryManaged>
   KOKKOS_INLINE_FUNCTION static void
@@ -461,8 +471,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //   z_int = int_0^z(dz)
   // where
   //   dz             is the vertical layer thickness, [m]
-  // Note: because this function does an integral it cannot be run just on a single level.  It requires
-  // the full column wise integration.
+  // Note: because this function does an integral it cannot be run just on a single level.  It
+  // requires the full column wise integration.
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT, typename InputProviderZ, typename MT = Kokkos::MemoryManaged>
   KOKKOS_INLINE_FUNCTION static void calculate_z_int(const MemberType &team, const int num_levs,
@@ -477,7 +487,8 @@ template <typename DeviceT> struct PhysicsFunctions {
   //-----------------------------------------------------------------------------------------------//
   template <typename ScalarT, typename InputProviderZ, typename MT = Kokkos::MemoryManaged>
   KOKKOS_INLINE_FUNCTION static void calculate_z_mid(const MemberType &team, const int num_levs,
-                                                     const InputProviderZ &z_int, const view_1d<ScalarT, MT> &z_mid);
+                                                     const InputProviderZ &z_int,
+                                                     const view_1d<ScalarT, MT> &z_mid);
 
 }; // struct PhysicsFunctions
 
diff --git i/components/eamxx/src/share/util/eamxx_common_physics_functions_impl.hpp w/components/eamxx/src/share/util/eamxx_common_physics_functions_impl.hpp
index 0710804a09..0055f709c3 100644
--- i/components/eamxx/src/share/util/eamxx_common_physics_functions_impl.hpp
+++ w/components/eamxx/src/share/util/eamxx_common_physics_functions_impl.hpp
@@ -8,8 +8,8 @@ namespace scream {
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_dx_from_area(const ScalarT &area,
-                                                                                 const ScalarT &lat) {
+KOKKOS_INLINE_FUNCTION ScalarT
+PhysicsFunctions<DeviceT>::calculate_dx_from_area(const ScalarT &area, const ScalarT &lat) {
   using C = scream::physics::Constants<Real>;
 
   static constexpr auto coeff_1 = C::earth_ellipsoid1;
@@ -23,15 +23,16 @@ KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_dx_from_area
   // Now find meters per degree latitude
   // Below equation finds distance between two points on an ellipsoid, derived from expansion
   // taking into account ellipsoid using World Geodetic System (WGS84) reference
-  auto m_per_degree_lat = coeff_1 - coeff_2 * std::cos(2.0 * lat_in_rad) + coeff_3 * std::cos(4.0 * lat_in_rad);
+  auto m_per_degree_lat =
+      coeff_1 - coeff_2 * std::cos(2.0 * lat_in_rad) + coeff_3 * std::cos(4.0 * lat_in_rad);
   // Note, for the formula we need to convert area from radians to degrees.
   return m_per_degree_lat * std::sqrt(area) * (180.0 / pi);
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_density(const ScalarT &pseudo_density,
-                                                                            const ScalarT &dz) {
+KOKKOS_INLINE_FUNCTION ScalarT
+PhysicsFunctions<DeviceT>::calculate_density(const ScalarT &pseudo_density, const ScalarT &dz) {
   using C = scream::physics::Constants<Real>;
 
   static constexpr auto g = C::gravit;
@@ -41,17 +42,18 @@ KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_density(cons
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderP, typename InputProviderZ>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_density(const MemberType &team, const InputProviderP &pseudo_density,
-                                             const InputProviderZ &dz, const view_1d<ScalarT> &density) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, density.extent(0)),
-                       [&](const int k) { density(k) = calculate_density(pseudo_density(k), dz(k)); });
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_density(
+    const MemberType &team, const InputProviderP &pseudo_density, const InputProviderZ &dz,
+    const view_1d<ScalarT> &density) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, density.extent(0)), [&](const int k) {
+    density(k) = calculate_density(pseudo_density(k), dz(k));
+  });
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_vertical_velocity(const ScalarT &omega,
-                                                                                      const ScalarT &density) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_vertical_velocity(
+    const ScalarT &omega, const ScalarT &density) {
   using C = scream::physics::Constants<Real>;
 
   static constexpr auto g = C::gravit;
@@ -61,9 +63,9 @@ KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_vertical_vel
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderOmega, typename InputProviderRho>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_vertical_velocity(const MemberType &team, const InputProviderOmega &omega,
-                                                       const InputProviderRho &rho, const view_1d<ScalarT> &w) {
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_vertical_velocity(
+    const MemberType &team, const InputProviderOmega &omega, const InputProviderRho &rho,
+    const view_1d<ScalarT> &w) {
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, w.extent(0)),
                        [&](const int k) { w(k) = calculate_vertical_velocity(omega(k), rho(k)); });
 }
@@ -82,25 +84,24 @@ KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::exner_function(const S
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderP>
-KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::exner_function(const MemberType &team,
-                                                                      const InputProviderP &pressure,
-                                                                      const view_1d<ScalarT> &exner) {
+KOKKOS_INLINE_FUNCTION void
+PhysicsFunctions<DeviceT>::exner_function(const MemberType &team, const InputProviderP &pressure,
+                                          const view_1d<ScalarT> &exner) {
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, exner.extent(0)),
                        [&](const int k) { exner(k) = exner_function(pressure(k)); });
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_theta_from_T(const ScalarT &temperature,
-                                                                                 const ScalarT &pressure) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_theta_from_T(
+    const ScalarT &temperature, const ScalarT &pressure) {
   return temperature / exner_function(pressure);
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_thetal_from_theta(const ScalarT &theta,
-                                                                                      const ScalarT &temperature,
-                                                                                      const ScalarT &qc) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_thetal_from_theta(
+    const ScalarT &theta, const ScalarT &temperature, const ScalarT &qc) {
   using C = scream::physics::Constants<Real>;
 
   return theta - (theta / temperature) * (C::LatVap / C::Cpair) * qc;
@@ -108,43 +109,47 @@ KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_thetal_from_
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderT, typename InputProviderP>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_theta_from_T(const MemberType &team, const InputProviderT &temperature,
-                                                  const InputProviderP &pressure, const view_1d<ScalarT> &theta) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, theta.extent(0)),
-                       [&](const int k) { theta(k) = calculate_theta_from_T(temperature(k), pressure(k)); });
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_theta_from_T(
+    const MemberType &team, const InputProviderT &temperature, const InputProviderP &pressure,
+    const view_1d<ScalarT> &theta) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, theta.extent(0)), [&](const int k) {
+    theta(k) = calculate_theta_from_T(temperature(k), pressure(k));
+  });
 }
 
 template <typename DeviceT>
-template <typename ScalarT, typename InputProviderTheta, typename InputProviderT, typename InputProviderQ>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_thetal_from_theta(const MemberType &team, const InputProviderTheta &theta,
-                                                       const InputProviderT &temperature, const InputProviderQ &qc,
-                                                       const view_1d<ScalarT> &thetal) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, thetal.extent(0)),
-                       [&](const int k) { thetal(k) = calculate_thetal_from_theta(theta(k), temperature(k), qc(k)); });
-}
-
-template <typename DeviceT>
-template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_T_from_theta(const ScalarT &theta,
-                                                                                 const ScalarT &pressure) {
-  return theta * exner_function(pressure);
-}
-
-template <typename DeviceT>
-template <typename ScalarT, typename InputProviderT, typename InputProviderP>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_T_from_theta(const MemberType &team, const InputProviderT &theta,
-                                                  const InputProviderP &pressure, const view_1d<ScalarT> &temperature) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, temperature.extent(0)),
-                       [&](const int k) { temperature(k) = calculate_T_from_theta(theta(k), pressure(k)); });
+template <typename ScalarT, typename InputProviderTheta, typename InputProviderT,
+          typename InputProviderQ>
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_thetal_from_theta(
+    const MemberType &team, const InputProviderTheta &theta, const InputProviderT &temperature,
+    const InputProviderQ &qc, const view_1d<ScalarT> &thetal) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, thetal.extent(0)), [&](const int k) {
+    thetal(k) = calculate_thetal_from_theta(theta(k), temperature(k), qc(k));
+  });
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
 KOKKOS_INLINE_FUNCTION ScalarT
-PhysicsFunctions<DeviceT>::calculate_temperature_from_virtual_temperature(const ScalarT &T_virtual, const ScalarT &qv) {
+PhysicsFunctions<DeviceT>::calculate_T_from_theta(const ScalarT &theta, const ScalarT &pressure) {
+  return theta * exner_function(pressure);
+}
+
+template <typename DeviceT>
+template <typename ScalarT, typename InputProviderT, typename InputProviderP>
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_T_from_theta(
+    const MemberType &team, const InputProviderT &theta, const InputProviderP &pressure,
+    const view_1d<ScalarT> &temperature) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, temperature.extent(0)), [&](const int k) {
+    temperature(k) = calculate_T_from_theta(theta(k), pressure(k));
+  });
+}
+
+template <typename DeviceT>
+template <typename ScalarT>
+KOKKOS_INLINE_FUNCTION ScalarT
+PhysicsFunctions<DeviceT>::calculate_temperature_from_virtual_temperature(const ScalarT &T_virtual,
+                                                                          const ScalarT &qv) {
   using C = scream::physics::Constants<Real>;
 
   static constexpr auto ep_2 = C::ep_2;
@@ -156,7 +161,8 @@ PhysicsFunctions<DeviceT>::calculate_temperature_from_virtual_temperature(const
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderT, typename InputProviderQ>
-KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_temperature_from_virtual_temperature(
+KOKKOS_INLINE_FUNCTION void
+PhysicsFunctions<DeviceT>::calculate_temperature_from_virtual_temperature(
     const MemberType &team, const InputProviderT &T_virtual, const InputProviderQ &qv,
     const view_1d<ScalarT> &temperature) {
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, temperature.extent(0)), [&](const int k) {
@@ -166,8 +172,8 @@ KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_temperature_fro
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_virtual_temperature(const ScalarT &temperature,
-                                                                                        const ScalarT &qv) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_virtual_temperature(
+    const ScalarT &temperature, const ScalarT &qv) {
   using C = scream::physics::Constants<Real>;
 
   static constexpr auto ep_2 = C::ep_2;
@@ -179,17 +185,18 @@ KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_virtual_temp
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderT, typename InputProviderQ>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_virtual_temperature(const MemberType &team, const InputProviderT &temperature,
-                                                         const InputProviderQ &qv, const view_1d<ScalarT> &T_virtual) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, T_virtual.extent(0)),
-                       [&](const int k) { T_virtual(k) = calculate_virtual_temperature(temperature(k), qv(k)); });
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_virtual_temperature(
+    const MemberType &team, const InputProviderT &temperature, const InputProviderQ &qv,
+    const view_1d<ScalarT> &T_virtual) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, T_virtual.extent(0)), [&](const int k) {
+    T_virtual(k) = calculate_virtual_temperature(temperature(k), qv(k));
+  });
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_dse(const ScalarT &temperature, const ScalarT &z,
-                                                                        const Real surf_geopotential) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_dse(
+    const ScalarT &temperature, const ScalarT &z, const Real surf_geopotential) {
   using C = scream::physics::Constants<Real>;
 
   static constexpr auto cp = C::CP;
@@ -204,16 +211,16 @@ KOKKOS_INLINE_FUNCTION void
 PhysicsFunctions<DeviceT>::calculate_dse(const MemberType &team, const InputProviderT &temperature,
                                          const InputProviderZ &z, const Real surf_geopotential,
                                          const view_1d<ScalarT> &dse) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dse.extent(0)),
-                       [&](const int k) { dse(k) = calculate_dse(temperature(k), z(k), surf_geopotential); });
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dse.extent(0)), [&](const int k) {
+    dse(k) = calculate_dse(temperature(k), z(k), surf_geopotential);
+  });
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
 
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_temperature_from_dse(const ScalarT &dse,
-                                                                                         const ScalarT &z,
-                                                                                         const Real surf_geopotential) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_temperature_from_dse(
+    const ScalarT &dse, const ScalarT &z, const Real surf_geopotential) {
   using C = scream::physics::Constants<Real>;
 
   static constexpr auto cp = C::CP;
@@ -224,10 +231,9 @@ KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_temperature_
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderT, typename InputProviderZ>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_temperature_from_dse(const MemberType &team, const InputProviderT &dse,
-                                                          const InputProviderZ &z, const Real surf_geopotential,
-                                                          const view_1d<ScalarT> &temperature) {
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_temperature_from_dse(
+    const MemberType &team, const InputProviderT &dse, const InputProviderZ &z,
+    const Real surf_geopotential, const view_1d<ScalarT> &temperature) {
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dse.extent(0)), [&](const int k) {
     temperature(k) = calculate_temperature_from_dse(dse(k), z(k), surf_geopotential);
   });
@@ -235,18 +241,19 @@ PhysicsFunctions<DeviceT>::calculate_temperature_from_dse(const MemberType &team
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_wetmmr_from_drymmr(const ScalarT &drymmr,
-                                                                                       const ScalarT &qv_dry) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_wetmmr_from_drymmr(
+    const ScalarT &drymmr, const ScalarT &qv_dry) {
   return drymmr / (1 + qv_dry);
 }
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderX, typename InputProviderQ>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_wetmmr_from_drymmr(const MemberType &team, const InputProviderX &drymmr,
-                                                        const InputProviderQ &qv_dry, const view_1d<ScalarT> &wetmmr) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, wetmmr.extent(0)),
-                       [&](const int k) { wetmmr(k) = calculate_wetmmr_from_drymmr(drymmr(k), qv_dry(k)); });
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_wetmmr_from_drymmr(
+    const MemberType &team, const InputProviderX &drymmr, const InputProviderQ &qv_dry,
+    const view_1d<ScalarT> &wetmmr) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, wetmmr.extent(0)), [&](const int k) {
+    wetmmr(k) = calculate_wetmmr_from_drymmr(drymmr(k), qv_dry(k));
+  });
 }
 
 template <typename DeviceT>
@@ -262,24 +269,26 @@ KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_wetmmr_from_dry
     const MemberType &team, const InputProviderX &drymmr, const InputProviderPD &pseudo_density,
     const InputProviderPD &pseudo_density_dry, const view_1d<ScalarT> &wetmmr) {
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, wetmmr.extent(0)), [&](const int k) {
-    wetmmr(k) = calculate_wetmmr_from_drymmr_dp_based(drymmr(k), pseudo_density(k), pseudo_density_dry(k));
+    wetmmr(k) =
+        calculate_wetmmr_from_drymmr_dp_based(drymmr(k), pseudo_density(k), pseudo_density_dry(k));
   });
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_drymmr_from_wetmmr(const ScalarT &wetmmr,
-                                                                                       const ScalarT &qv_wet) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_drymmr_from_wetmmr(
+    const ScalarT &wetmmr, const ScalarT &qv_wet) {
   return wetmmr / (1 - qv_wet);
 }
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderX, typename InputProviderQ>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_drymmr_from_wetmmr(const MemberType &team, const InputProviderX &wetmmr,
-                                                        const InputProviderQ &qv_wet, const view_1d<ScalarT> &drymmr) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, drymmr.extent(0)),
-                       [&](const int k) { drymmr(k) = calculate_drymmr_from_wetmmr(wetmmr(k), qv_wet(k)); });
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_drymmr_from_wetmmr(
+    const MemberType &team, const InputProviderX &wetmmr, const InputProviderQ &qv_wet,
+    const view_1d<ScalarT> &drymmr) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, drymmr.extent(0)), [&](const int k) {
+    drymmr(k) = calculate_drymmr_from_wetmmr(wetmmr(k), qv_wet(k));
+  });
 }
 
 template <typename DeviceT>
@@ -295,15 +304,15 @@ KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_drymmr_from_wet
     const MemberType &team, const InputProviderX &wetmmr, const InputProviderPD &pseudo_density,
     const InputProviderPD &pseudo_density_dry, const view_1d<ScalarT> &drymmr) {
   Kokkos::parallel_for(Kokkos::TeamVectorRange(team, drymmr.extent(0)), [&](const int k) {
-    drymmr(k) = calculate_drymmr_from_wetmmr_dp_based(wetmmr(k), pseudo_density(k), pseudo_density_dry(k));
+    drymmr(k) =
+        calculate_drymmr_from_wetmmr_dp_based(wetmmr(k), pseudo_density(k), pseudo_density_dry(k));
   });
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_dz(const ScalarT &pseudo_density,
-                                                                       const ScalarT &p_mid, const ScalarT &T_mid,
-                                                                       const ScalarT &qv) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_dz(
+    const ScalarT &pseudo_density, const ScalarT &p_mid, const ScalarT &T_mid, const ScalarT &qv) {
   using C = scream::physics::Constants<Real>;
 
   const ScalarT &T_virtual = calculate_virtual_temperature(T_mid, qv);
@@ -314,21 +323,22 @@ KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_dz(const Sca
 }
 
 template <typename DeviceT>
-template <typename ScalarT, typename InputProviderPD, typename InputProviderP, typename InputProviderT,
-          typename InputProviderQ, typename MT>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_dz(const MemberType &team, const InputProviderPD &pseudo_density,
-                                        const InputProviderP &p_mid, const InputProviderT &T_mid,
-                                        const InputProviderQ &qv, const view_1d<ScalarT, MT> &dz) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dz.extent(0)),
-                       [&](const int k) { dz(k) = calculate_dz(pseudo_density(k), p_mid(k), T_mid(k), qv(k)); });
+template <typename ScalarT, typename InputProviderPD, typename InputProviderP,
+          typename InputProviderT, typename InputProviderQ, typename MT>
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_dz(
+    const MemberType &team, const InputProviderPD &pseudo_density, const InputProviderP &p_mid,
+    const InputProviderT &T_mid, const InputProviderQ &qv, const view_1d<ScalarT, MT> &dz) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, dz.extent(0)), [&](const int k) {
+    dz(k) = calculate_dz(pseudo_density(k), p_mid(k), T_mid(k), qv(k));
+  });
 }
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderZ, typename MT>
-KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_z_int(const MemberType &team, const int num_levs,
-                                                                       const InputProviderZ &dz, const Real z_surf,
-                                                                       const view_1d<ScalarT, MT> &z_int) {
+KOKKOS_INLINE_FUNCTION void
+PhysicsFunctions<DeviceT>::calculate_z_int(const MemberType &team, const int num_levs,
+                                           const InputProviderZ &dz, const Real z_surf,
+                                           const view_1d<ScalarT, MT> &z_int) {
   using column_ops = ColumnOps<DeviceT, Real>;
   // Note, we set FromTop to false since we are prescribing the *bottom* elevation.
   constexpr bool FromTop = false;
@@ -337,18 +347,18 @@ KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_z_int(const Mem
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProvider, typename MT>
-KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_z_mid(const MemberType &team, const int num_levs,
-                                                                       const InputProvider &z_int,
-                                                                       const view_1d<ScalarT, MT> &z_mid) {
+KOKKOS_INLINE_FUNCTION void
+PhysicsFunctions<DeviceT>::calculate_z_mid(const MemberType &team, const int num_levs,
+                                           const InputProvider &z_int,
+                                           const view_1d<ScalarT, MT> &z_mid) {
   using column_ops = ColumnOps<DeviceT, Real>;
   column_ops::compute_midpoint_values(team, num_levs, z_int, z_mid);
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_vmr_from_mmr(const Real &gas_mol_weight,
-                                                                                 const ScalarT &qv,
-                                                                                 const ScalarT &mmr) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_vmr_from_mmr(
+    const Real &gas_mol_weight, const ScalarT &qv, const ScalarT &mmr) {
   using C                       = scream::physics::Constants<Real>;
   constexpr Real air_mol_weight = C::MWdry;
 
@@ -357,19 +367,18 @@ KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_vmr_from_mmr
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderQ, typename InputProviderX>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_vmr_from_mmr(const MemberType &team, const Real gas_mol_weight,
-                                                  const InputProviderQ &qv, const InputProviderX &mmr,
-                                                  const view_1d<ScalarT> &vmr) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, vmr.extent(0)),
-                       [&](const int k) { vmr(k) = calculate_vmr_from_mmr(gas_mol_weight, qv(k), mmr(k)); });
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_vmr_from_mmr(
+    const MemberType &team, const Real gas_mol_weight, const InputProviderQ &qv,
+    const InputProviderX &mmr, const view_1d<ScalarT> &vmr) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, vmr.extent(0)), [&](const int k) {
+    vmr(k) = calculate_vmr_from_mmr(gas_mol_weight, qv(k), mmr(k));
+  });
 }
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_mmr_from_vmr(const Real &gas_mol_weight,
-                                                                                 const ScalarT &qv,
-                                                                                 const ScalarT &vmr) {
+KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_mmr_from_vmr(
+    const Real &gas_mol_weight, const ScalarT &qv, const ScalarT &vmr) {
   using C                       = scream::physics::Constants<Real>;
   constexpr Real air_mol_weight = C::MWdry;
   const Real mol_weight_ratio   = gas_mol_weight / air_mol_weight;
@@ -379,27 +388,28 @@ KOKKOS_INLINE_FUNCTION ScalarT PhysicsFunctions<DeviceT>::calculate_mmr_from_vmr
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderQ, typename InputProviderX>
-KOKKOS_INLINE_FUNCTION void
-PhysicsFunctions<DeviceT>::calculate_mmr_from_vmr(const MemberType &team, const Real gas_mol_weight,
-                                                  const InputProviderQ &qv, const InputProviderX &vmr,
-                                                  const view_1d<ScalarT> &mmr) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, mmr.extent(0)),
-                       [&](const int k) { mmr(k) = calculate_mmr_from_vmr(gas_mol_weight, qv(k), vmr(k)); });
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::calculate_mmr_from_vmr(
+    const MemberType &team, const Real gas_mol_weight, const InputProviderQ &qv,
+    const InputProviderX &vmr, const view_1d<ScalarT> &mmr) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, mmr.extent(0)), [&](const int k) {
+    mmr(k) = calculate_mmr_from_vmr(gas_mol_weight, qv(k), vmr(k));
+  });
 }
 
 template <typename DeviceT>
-KOKKOS_INLINE_FUNCTION Real PhysicsFunctions<DeviceT>::calculate_surface_air_T(const Real &T_mid_bot,
-                                                                               const Real &z_mid_bot) {
+KOKKOS_INLINE_FUNCTION Real
+PhysicsFunctions<DeviceT>::calculate_surface_air_T(const Real &T_mid_bot, const Real &z_mid_bot) {
   /*Compute temperature at the bottom of the gridcell closest to the ground. The implementation here
     is really clunky and is meant to provide calculate_psl with the values used by CESM... Think
-    twice before using it for anything else. Inputs are T at midpoint of layer closest to the surface (K) and
-    the geometric height at that point (m). Note that z_mid_bot is distance from the surface rather than from
-    sea level!
+    twice before using it for anything else. Inputs are T at midpoint of layer closest to the
+    surface (K) and the geometric height at that point (m). Note that z_mid_bot is distance from the
+    surface rather than from sea level!
   */
 
   // Old version extrapolated off lowest 2 midpoint values (needs different function arguments).
-  // Ditching this version for fear that weird lowest layer T relationships could yield strange surface values.
-  // const Real T_weighting = ( p_int_i(num_levs) - p_mid_i(last_entry))/(p_mid_i(last_entry - 1) - p_mid_i(last_entry)
+  // Ditching this version for fear that weird lowest layer T relationships could yield strange
+  // surface values. const Real T_weighting = ( p_int_i(num_levs) -
+  // p_mid_i(last_entry))/(p_mid_i(last_entry - 1) - p_mid_i(last_entry)
   // ); return T_mid_i(last_entry - 1)*T_weighting + T_mid_i(last_entry)*(1-T_weighting);
 
   // Assume 6.5 K/km lapse rate between cell's midpoint and its bottom edge
@@ -407,8 +417,9 @@ KOKKOS_INLINE_FUNCTION Real PhysicsFunctions<DeviceT>::calculate_surface_air_T(c
 }
 
 template <typename DeviceT>
-KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::lapse_T_for_psl(const Real &T_ground, const Real &phi_ground,
-                                                                       Real &lapse, Real &T_ground_tmp) {
+KOKKOS_INLINE_FUNCTION void
+PhysicsFunctions<DeviceT>::lapse_T_for_psl(const Real &T_ground, const Real &phi_ground,
+                                           Real &lapse, Real &T_ground_tmp) {
   /*
     Choose lapse rate and effective ground temperature to use for sea-level pressure calculation.
     This function should only be used by calculate_psl and is separated from that function solely
@@ -419,34 +430,41 @@ KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::lapse_T_for_psl(const Rea
   constexpr Real gravit = C::gravit;
 
   // Get preliminary surface and sea level temperature to decide on lapse rate
-  auto T_sl    = T_ground + sp(0.0065) * phi_ground / gravit; // start by assuming lapse rate is 6.5 K/km
-  T_ground_tmp = T_ground;                                    // make copy b/c may need to modify later
+  auto T_sl =
+      T_ground + sp(0.0065) * phi_ground / gravit; // start by assuming lapse rate is 6.5 K/km
+  T_ground_tmp = T_ground;                         // make copy b/c may need to modify later
 
   if (T_ground <= 290.5 && T_sl > 290.5) {
-    lapse = gravit / phi_ground * (sp(290.5) - T_ground); // choose lapse rate to make T at sea level 290.5K
+    lapse = gravit / phi_ground *
+            (sp(290.5) - T_ground); // choose lapse rate to make T at sea level 290.5K
   } else if (T_ground > 290.5 && T_sl > 290.5) {
-    lapse        = 0;                                // choose lapse rate = 0 to not make things any worse.
-    T_ground_tmp = sp(0.5) * (sp(290.5) + T_ground); // reduce effective T in a smooth way to avoid unrealistic result
+    lapse = 0; // choose lapse rate = 0 to not make things any worse.
+    T_ground_tmp =
+        sp(0.5) *
+        (sp(290.5) + T_ground); // reduce effective T in a smooth way to avoid unrealistic result
   } else if (T_ground < 255) {
     // Following EAM's treatment for cold cases even though it seems overly crude: what if T_sl>255?
-    // Or phi_ground<0 so positive lapse makes T_sl even colder? We should eventually ditch this entire scheme.
+    // Or phi_ground<0 so positive lapse makes T_sl even colder? We should eventually ditch this
+    // entire scheme.
     lapse        = 0.0065;
     T_ground_tmp = sp(0.5) * (255 + T_ground);
   } else {
-    // note lack of "elif T_ground>290.5 and T_sl<290.5" case (phi_ground<0 and hot) is missing on purpose
-    // because 6.5K/km lapse rate will cool T_sl in that case and that's what we want.
+    // note lack of "elif T_ground>290.5 and T_sl<290.5" case (phi_ground<0 and hot) is missing on
+    // purpose because 6.5K/km lapse rate will cool T_sl in that case and that's what we want.
     lapse = 0.0065; // assume 6.5K/km lapse rate for reasonable temperatures
   }
 }
 
 template <typename DeviceT>
-KOKKOS_INLINE_FUNCTION Real PhysicsFunctions<DeviceT>::calculate_psl(const Real &T_ground, const Real &p_ground,
+KOKKOS_INLINE_FUNCTION Real PhysicsFunctions<DeviceT>::calculate_psl(const Real &T_ground,
+                                                                     const Real &p_ground,
                                                                      const Real &phi_ground) {
   /*
-     Compute sea level pressure (psl) assuming atmosphere below the land surface is dry and has a lapse
-     rate of 6.5K/km unless conditions are very warm. See components/eamxx/docs/tech_doc/physics/psl/
-     for a description. Note that all input/out variables are only defined at the surface rather than
-     being 3d variables so no need to template on InputProvider.
+     Compute sea level pressure (psl) assuming atmosphere below the land surface is dry and has a
+     lapse rate of 6.5K/km unless conditions are very warm. See
+     components/eamxx/docs/tech_doc/physics/psl/ for a description. Note that all input/out
+     variables are only defined at the surface rather than being 3d variables so no need to template
+     on InputProvider.
  */
 
   using C               = scream::physics::Constants<Real>;
@@ -472,9 +490,8 @@ KOKKOS_INLINE_FUNCTION Real PhysicsFunctions<DeviceT>::calculate_psl(const Real
 
 template <typename DeviceT>
 template <typename ScalarT>
-KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::apply_rayleigh_friction(const Real dt, const ScalarT &otau,
-                                                                               ScalarT &u_wind, ScalarT &v_wind,
-                                                                               ScalarT &T_mid) {
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::apply_rayleigh_friction(
+    const Real dt, const ScalarT &otau, ScalarT &u_wind, ScalarT &v_wind, ScalarT &T_mid) {
   using C           = scream::physics::Constants<Real>;
   constexpr Real cp = C::CP;
 
@@ -494,13 +511,13 @@ KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::apply_rayleigh_friction(c
 
 template <typename DeviceT>
 template <typename ScalarT, typename InputProviderOtau, typename MT>
-KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::apply_rayleigh_friction(const MemberType &team, const Real dt,
-                                                                               const InputProviderOtau &otau,
-                                                                               const view_1d<ScalarT, MT> &u_wind,
-                                                                               const view_1d<ScalarT, MT> &v_wind,
-                                                                               const view_1d<ScalarT, MT> &T_mid) {
-  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, T_mid.extent(0)),
-                       [&](const int k) { apply_rayleigh_friction(dt, otau(k), u_wind(k), v_wind(k), T_mid(k)); });
+KOKKOS_INLINE_FUNCTION void PhysicsFunctions<DeviceT>::apply_rayleigh_friction(
+    const MemberType &team, const Real dt, const InputProviderOtau &otau,
+    const view_1d<ScalarT, MT> &u_wind, const view_1d<ScalarT, MT> &v_wind,
+    const view_1d<ScalarT, MT> &T_mid) {
+  Kokkos::parallel_for(Kokkos::TeamVectorRange(team, T_mid.extent(0)), [&](const int k) {
+    apply_rayleigh_friction(dt, otau(k), u_wind(k), v_wind(k), T_mid(k));
+  });
 }
 
 } // namespace scream
diff --git i/components/eamxx/src/share/util/eamxx_data_interpolation.cpp w/components/eamxx/src/share/util/eamxx_data_interpolation.cpp
index 678cfae425..bff3009660 100644
--- i/components/eamxx/src/share/util/eamxx_data_interpolation.cpp
+++ w/components/eamxx/src/share/util/eamxx_data_interpolation.cpp
@@ -28,8 +28,9 @@ DataInterpolation::DataInterpolation(const std::shared_ptr<const AbstractGrid> &
 }
 
 void DataInterpolation::run(const util::TimeStamp &ts) {
-  EKAT_REQUIRE_MSG(m_data_initialized,
-                   "[DataInterpolation] Error! You must call 'init_data_interval' before calling 'run'.\n");
+  EKAT_REQUIRE_MSG(
+      m_data_initialized,
+      "[DataInterpolation] Error! You must call 'init_data_interval' before calling 'run'.\n");
 
   // If we went past the current interval end, we need to update the end state
   if (not m_data_interval.contains(ts)) {
@@ -42,22 +43,23 @@ void DataInterpolation::run(const util::TimeStamp &ts) {
   //       have t_beg>t_end
   util::TimeInterval beg_to_ts(m_data_interval.beg, ts, m_data_interval.timeline);
   double alpha = beg_to_ts.length / m_data_interval.length;
-  EKAT_REQUIRE_MSG(alpha >= 0 and alpha <= 1,
-                   "[DataInterpolation] Error! Input timestamp is outside the current data time interval.\n"
-                   "  data interval beg  ; " +
-                       m_data_interval.beg.to_string() +
-                       "\n"
-                       "  data interval end  ; " +
-                       m_data_interval.end.to_string() +
-                       "\n"
-                       "  input timestamp    ; " +
-                       ts.to_string() +
-                       "\n"
-                       "  interval length    : " +
-                       std::to_string(m_data_interval.length) +
-                       "\n"
-                       "  interpolation coeff: " +
-                       std::to_string(alpha) + "\n");
+  EKAT_REQUIRE_MSG(
+      alpha >= 0 and alpha <= 1,
+      "[DataInterpolation] Error! Input timestamp is outside the current data time interval.\n"
+      "  data interval beg  ; " +
+          m_data_interval.beg.to_string() +
+          "\n"
+          "  data interval end  ; " +
+          m_data_interval.end.to_string() +
+          "\n"
+          "  input timestamp    ; " +
+          ts.to_string() +
+          "\n"
+          "  interval length    : " +
+          std::to_string(m_data_interval.length) +
+          "\n"
+          "  interpolation coeff: " +
+          std::to_string(alpha) + "\n");
 
   for (int i = 0; i < m_nfields; ++i) {
     const auto &beg = m_horiz_remapper_beg->get_tgt_field(i);
@@ -111,8 +113,9 @@ void DataInterpolation::run(const util::TimeStamp &ts) {
     Kokkos::parallel_for(
         "spa_compute_p_src_loop", policy, KOKKOS_LAMBDA(const MemberType &team) {
           const int icol = team.league_rank();
-          Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_vert_packs),
-                               [&](const int k) { p_v(icol, k) = ps_v(icol) * hybm(k) + P0 * hyam(k); });
+          Kokkos::parallel_for(Kokkos::TeamVectorRange(team, num_vert_packs), [&](const int k) {
+            p_v(icol, k) = ps_v(icol) * hybm(k) + P0 * hyam(k);
+          });
         });
   }
 
@@ -153,8 +156,8 @@ void DataInterpolation::update_end_fields() {
 }
 
 void DataInterpolation::init_data_interval(const util::TimeStamp &t0) {
-  EKAT_REQUIRE_MSG(m_remappers_created,
-                   "[DataInterpolation] Error! Cannot call 'init_data_interval' until after remappers creation.\n");
+  EKAT_REQUIRE_MSG(m_remappers_created, "[DataInterpolation] Error! Cannot call "
+                                        "'init_data_interval' until after remappers creation.\n");
 
   // Create a bare reader. Fields and filename are set inside the update_end_fields call
   strvec_t fnames;
@@ -172,7 +175,7 @@ void DataInterpolation::init_data_interval(const util::TimeStamp &t0) {
   // framework can only load the end slice (since that's what we need at runtime).
   // So, load end state for t=t_beg, then call shift_data_interval
   // NOTE: don't compute length now, since beg time point is invalid (we don't need length yet).
-  m_data_interval            = util::TimeInterval(util::TimeStamp(), t_beg, m_time_database.timeline, false);
+  m_data_interval = util::TimeInterval(util::TimeStamp(), t_beg, m_time_database.timeline, false);
   m_curr_interval_idx.second = t0_interval;
   update_end_fields();
   shift_data_interval();
@@ -180,7 +183,8 @@ void DataInterpolation::init_data_interval(const util::TimeStamp &t0) {
   m_data_initialized = true;
 }
 
-void DataInterpolation::setup_time_database(const strvec_t &input_files, const util::TimeLine timeline,
+void DataInterpolation::setup_time_database(const strvec_t &input_files,
+                                            const util::TimeLine timeline,
                                             const util::TimeStamp &ref_ts) {
   // Log the final list of files, so the user know if something went wrong (e.g. a bad regex)
   if (m_dbg_output and m_comm.am_i_root()) {
@@ -209,23 +213,26 @@ void DataInterpolation::setup_time_database(const strvec_t &input_files, const u
   auto ts2str = [](const util::TimeStamp &t) { return t.to_string(); };
   std::vector<std::vector<util::TimeStamp>> times;
   for (const auto &fname : input_files) {
-    EKAT_REQUIRE_MSG(file_readable(input_files.back()), "Error! One of the input files is not readable.\n"
-                                                        " - file   : " +
-                                                            input_files.back() + "\n");
+    EKAT_REQUIRE_MSG(file_readable(input_files.back()),
+                     "Error! One of the input files is not readable.\n"
+                     " - file   : " +
+                         input_files.back() + "\n");
 
     scorpio::register_file(fname, scorpio::Read);
 
     if (not scorpio::has_time_dim(fname)) {
-      EKAT_REQUIRE_MSG(scorpio::has_dim(fname, "time"),
-                       "[DataInterpolation] Error! Input file does not contain a 'time' dimension.\n"
-                       " - file name: " +
-                           fname + "\n");
+      EKAT_REQUIRE_MSG(
+          scorpio::has_dim(fname, "time"),
+          "[DataInterpolation] Error! Input file does not contain a 'time' dimension.\n"
+          " - file name: " +
+              fname + "\n");
       scorpio::mark_dim_as_time(fname, "time");
     }
     auto file_times = scorpio::get_all_times(fname);
-    EKAT_REQUIRE_MSG(file_times.size() > 0, "[DataInterpolation] Error! Input file contains no time variable.\n"
-                                            " - file name: " +
-                                                fname + "\n");
+    EKAT_REQUIRE_MSG(file_times.size() > 0,
+                     "[DataInterpolation] Error! Input file contains no time variable.\n"
+                     " - file name: " +
+                         fname + "\n");
 
     auto t_ref = ref_ts.is_valid() ? ref_ts : read_timestamp(fname, "reference_time_stamp");
 
@@ -236,17 +243,19 @@ void DataInterpolation::setup_time_database(const strvec_t &input_files, const u
     scorpio::release_file(fname);
 
     // Ensure time slices are sorted (it would make code messy otherwise)
-    EKAT_REQUIRE_MSG(std::is_sorted(times.back().begin(), times.back().end()),
-                     "[DataInterpolation] Error! One of the input files has time slices not sorted.\n"
-                     " - file name  : " +
-                         fname +
-                         "\n"
-                         " - time stamps: " +
-                         ekat::join(times.back(), ts2str, ", ") + "\n");
+    EKAT_REQUIRE_MSG(
+        std::is_sorted(times.back().begin(), times.back().end()),
+        "[DataInterpolation] Error! One of the input files has time slices not sorted.\n"
+        " - file name  : " +
+            fname +
+            "\n"
+            " - time stamps: " +
+            ekat::join(times.back(), ts2str, ", ") + "\n");
   }
 
   // Sort the files based on start date
-  auto fileCmp = [](const std::vector<util::TimeStamp> &times1, const std::vector<util::TimeStamp> &times2) {
+  auto fileCmp = [](const std::vector<util::TimeStamp> &times1,
+                    const std::vector<util::TimeStamp> &times2) {
     return times1.front() < times2.front();
   };
   std::sort(times.begin(), times.end(), fileCmp);
@@ -270,19 +279,20 @@ void DataInterpolation::setup_time_database(const strvec_t &input_files, const u
       // Ensure files don't overlap (it would be a mess)
       const auto &prev = times[i - 1];
       const auto &next = times[i];
-      EKAT_REQUIRE_MSG(prev.back() < next.front(),
-                       "[DataInterpolation] Error! The input files contain overlapping time slices.\n"
-                       " - file1 name : " +
-                           input_files[i - 1] +
-                           "\n"
-                           " - file2 name : " +
-                           input_files[i] +
-                           "\n"
-                           " - file1 times: " +
-                           ekat::join(prev, ts2str, ", ") +
-                           "\n"
-                           " - file2 times: " +
-                           ekat::join(next, ts2str, ", ") + "\n");
+      EKAT_REQUIRE_MSG(
+          prev.back() < next.front(),
+          "[DataInterpolation] Error! The input files contain overlapping time slices.\n"
+          " - file1 name : " +
+              input_files[i - 1] +
+              "\n"
+              " - file2 name : " +
+              input_files[i] +
+              "\n"
+              " - file1 times: " +
+              ekat::join(prev, ts2str, ", ") +
+              "\n"
+              " - file2 times: " +
+              ekat::join(next, ts2str, ", ") + "\n");
     }
   }
 
@@ -310,15 +320,18 @@ void DataInterpolation::setup_remappers(const RemapData &data) {
 int DataInterpolation::TimeDatabase::get_next_idx(int prev) const {
   int next = prev + 1;
   if (next >= size()) {
-    EKAT_REQUIRE_MSG(timeline == util::TimeLine::YearlyPeriodic,
-                     "[TimeDatabase::get_next_idx] Error! Requesting slice that is past the database end.\n");
+    EKAT_REQUIRE_MSG(
+        timeline == util::TimeLine::YearlyPeriodic,
+        "[TimeDatabase::get_next_idx] Error! Requesting slice that is past the database end.\n");
     next = next % size();
   }
   return next;
 }
 
 int DataInterpolation::TimeDatabase::find_interval(const util::TimeStamp &t) const {
-  EKAT_REQUIRE_MSG(size() > 1, "[TimeDatabase::find_interval] Error! The database has not been initialized yet.\n");
+  EKAT_REQUIRE_MSG(
+      size() > 1,
+      "[TimeDatabase::find_interval] Error! The database has not been initialized yet.\n");
 
   auto contains = [&](int beg, int end, const util::TimeStamp &t) {
     const auto &t_beg = slices[beg].time;
@@ -340,21 +353,22 @@ int DataInterpolation::TimeDatabase::find_interval(const util::TimeStamp &t) con
   // this is an error (in fact, there should have been an error before!).
   // But if the timeline is YearlyPeriodic, then it must be the case that
   // t is in the interval (slices[N],slices[0]).
-  EKAT_REQUIRE_MSG(timeline == util::TimeLine::YearlyPeriodic and contains(size(), 0, t),
-                   "[TimeDatabase::find_interval] Error! Could not locate interval containing input timestamp.\n"
-                   "  - input time : " +
-                       t.to_string() +
-                       "\n"
-                       "  - timeline   : " +
-                       (timeline == util::TimeLine::Linear ? "linear" : "yearly_periodic") +
-                       "\n"
-                       "  - first slice: " +
-                       slices.front().time.to_string() +
-                       "\n"
-                       "  - last slice : " +
-                       slices.back().time.to_string() +
-                       "\n"
-                       "Did you mean to use YearlyPeriodic timeline?\n");
+  EKAT_REQUIRE_MSG(
+      timeline == util::TimeLine::YearlyPeriodic and contains(size(), 0, t),
+      "[TimeDatabase::find_interval] Error! Could not locate interval containing input timestamp.\n"
+      "  - input time : " +
+          t.to_string() +
+          "\n"
+          "  - timeline   : " +
+          (timeline == util::TimeLine::Linear ? "linear" : "yearly_periodic") +
+          "\n"
+          "  - first slice: " +
+          slices.front().time.to_string() +
+          "\n"
+          "  - last slice : " +
+          slices.back().time.to_string() +
+          "\n"
+          "Did you mean to use YearlyPeriodic timeline?\n");
 
   // Since we are in YearlyPeriodic timeline, the interval starts at the last slice
   return size() - 1;
@@ -373,19 +387,20 @@ int DataInterpolation::get_input_files_dimlen(const std::string &dimname) const
                                                            fname + "\n");
 
     auto this_file_dimlen = scorpio::get_dimlen(fname, dimname);
-    EKAT_REQUIRE_MSG(dimlen == -1 or dimlen == this_file_dimlen, "Error! Input files do not agree on '" + dimname +
-                                                                     "' dimension length.\n"
-                                                                     "  - file1: " +
-                                                                     m_time_database.files.front() +
-                                                                     "\n"
-                                                                     "  - file2: " +
-                                                                     fname +
-                                                                     "\n"
-                                                                     "  - file1 dim len: " +
-                                                                     std::to_string(dimlen) +
-                                                                     "\n"
-                                                                     "  - file2 dim len: " +
-                                                                     std::to_string(this_file_dimlen) + "\n");
+    EKAT_REQUIRE_MSG(dimlen == -1 or dimlen == this_file_dimlen,
+                     "Error! Input files do not agree on '" + dimname +
+                         "' dimension length.\n"
+                         "  - file1: " +
+                         m_time_database.files.front() +
+                         "\n"
+                         "  - file2: " +
+                         fname +
+                         "\n"
+                         "  - file1 dim len: " +
+                         std::to_string(dimlen) +
+                         "\n"
+                         "  - file2 dim len: " +
+                         std::to_string(this_file_dimlen) + "\n");
     scorpio::release_file(fname);
 
     dimlen = this_file_dimlen;
@@ -404,13 +419,14 @@ void DataInterpolation::setup_horiz_remappers(const RemapData &data) {
   m_grid_after_hremap->reset_num_vertical_lev(nlevs_data);
 
   if (data.has_iop) {
-    EKAT_REQUIRE_MSG(not ekat::is_invalid(data.iop_lat) and not ekat::is_invalid(data.iop_lon),
-                     "Error! At least one between iop_lat and iop_lon appears to be valid in RemapData.\n"
-                     "  - iop_lat: "
-                         << data.iop_lat
-                         << "\n"
-                            "  - iop_lon: "
-                         << data.iop_lon << "\n");
+    EKAT_REQUIRE_MSG(
+        not ekat::is_invalid(data.iop_lat) and not ekat::is_invalid(data.iop_lon),
+        "Error! At least one between iop_lat and iop_lon appears to be valid in RemapData.\n"
+        "  - iop_lat: "
+            << data.iop_lat
+            << "\n"
+               "  - iop_lon: "
+            << data.iop_lon << "\n");
     // Create grid for IO and load lat/lon field in IO grid from any data file
     auto data_grid = create_point_grid("data", ncols_data, nlevs_data, m_model_grid->get_comm());
     auto lat_f     = data_grid->create_geometry_data("lat", data_grid->get_2d_scalar_layout());
@@ -419,21 +435,25 @@ void DataInterpolation::setup_horiz_remappers(const RemapData &data) {
     latlon_reader.read_variables();
 
     // Create IOP remappers
-    m_horiz_remapper_beg = std::make_shared<IOPRemapper>(data_grid, m_grid_after_hremap, data.iop_lat, data.iop_lon);
-    m_horiz_remapper_end = std::make_shared<IOPRemapper>(data_grid, m_grid_after_hremap, data.iop_lat, data.iop_lon);
+    m_horiz_remapper_beg =
+        std::make_shared<IOPRemapper>(data_grid, m_grid_after_hremap, data.iop_lat, data.iop_lon);
+    m_horiz_remapper_end =
+        std::make_shared<IOPRemapper>(data_grid, m_grid_after_hremap, data.iop_lat, data.iop_lon);
   } else if (data.hremap_file != "") {
-    m_horiz_remapper_beg = std::make_shared<RefiningRemapperP2P>(m_grid_after_hremap, data.hremap_file);
-    m_horiz_remapper_end = std::make_shared<RefiningRemapperP2P>(m_grid_after_hremap, data.hremap_file);
+    m_horiz_remapper_beg =
+        std::make_shared<RefiningRemapperP2P>(m_grid_after_hremap, data.hremap_file);
+    m_horiz_remapper_end =
+        std::make_shared<RefiningRemapperP2P>(m_grid_after_hremap, data.hremap_file);
   } else {
     // NO hremap of any kind. 'ncols' from the data must then match the model grid (nlev can differ)
-    EKAT_REQUIRE_MSG(
-        ncols_data == m_model_grid->get_num_global_dofs(),
-        "Error! No horiz remap was requested, but the 'ncol' dim from file does not match with the model grid one.\n"
-        " - model grid num global cols: " +
-            std::to_string(m_model_grid->get_num_global_dofs()) +
-            "\n"
-            " - input data num global cols: " +
-            std::to_string(ncols_data) + "\n");
+    EKAT_REQUIRE_MSG(ncols_data == m_model_grid->get_num_global_dofs(),
+                     "Error! No horiz remap was requested, but the 'ncol' dim from file does not "
+                     "match with the model grid one.\n"
+                     " - model grid num global cols: " +
+                         std::to_string(m_model_grid->get_num_global_dofs()) +
+                         "\n"
+                         " - input data num global cols: " +
+                         std::to_string(ncols_data) + "\n");
 
     using IDR          = IdentityRemapper;
     constexpr auto SAT = IDR::SrcAliasTgt;
@@ -453,14 +473,14 @@ void DataInterpolation::setup_vert_remapper(const RemapData &data) {
     // If no vert remap is requested, model_grid and grid_after_hremap MUST have same nlevs
     int model_nlevs = m_model_grid->get_num_vertical_levels();
     int data_nlevs  = m_grid_after_hremap->get_num_vertical_levels();
-    EKAT_REQUIRE_MSG(
-        model_nlevs == data_nlevs,
-        "Error! No vertical remap was requested, but the 'lev' dim from file does not match the model grid one.\n"
-        " - model grid num vert levels: " +
-            std::to_string(model_nlevs) +
-            "\n"
-            " - input data num vert levels: " +
-            std::to_string(data_nlevs) + "\n");
+    EKAT_REQUIRE_MSG(model_nlevs == data_nlevs,
+                     "Error! No vertical remap was requested, but the 'lev' dim from file does not "
+                     "match the model grid one.\n"
+                     " - model grid num vert levels: " +
+                         std::to_string(model_nlevs) +
+                         "\n"
+                         " - input data num vert levels: " +
+                         std::to_string(data_nlevs) + "\n");
     m_vert_remapper = std::make_shared<IDR>(m_grid_after_hremap, SAT);
     return;
   }
@@ -499,7 +519,7 @@ void DataInterpolation::setup_vert_remapper(const RemapData &data) {
   auto p_layout = m_vr_type == Static1D ? m_grid_after_hremap->get_vertical_layout(true)
                                         : m_grid_after_hremap->get_3d_scalar_layout(true);
   auto &p_data  = m_helper_pressure_fields["p_data"];
-  p_data        = Field(FieldIdentifier("p_data", p_layout, ekat::units::Pa, m_grid_after_hremap->name()));
+  p_data = Field(FieldIdentifier("p_data", p_layout, ekat::units::Pa, m_grid_after_hremap->name()));
   p_data.get_header().get_alloc_properties().request_allocation(SCREAM_PACK_SIZE);
   p_data.allocate_view();
   if (m_vr_type == Dynamic3D) {
@@ -508,8 +528,8 @@ void DataInterpolation::setup_vert_remapper(const RemapData &data) {
   } else if (m_vr_type == Dynamic3DRef) {
     // We load the surface pressure, and reconstruct p_data via p=ps*hybm(k) + p0*hyam(k)
     auto &ps = m_helper_pressure_fields["p_file"];
-    ps       = Field(FieldIdentifier(data.pname, m_grid_after_hremap->get_2d_scalar_layout(), ekat::units::Pa,
-                                     m_grid_after_hremap->name()));
+    ps       = Field(FieldIdentifier(data.pname, m_grid_after_hremap->get_2d_scalar_layout(),
+                                     ekat::units::Pa, m_grid_after_hremap->name()));
     ps.allocate_view();
 
     // We need to reconstruct the 3d pressure from ps, hybm, and hyam.
@@ -517,13 +537,17 @@ void DataInterpolation::setup_vert_remapper(const RemapData &data) {
     auto layout     = m_grid_after_hremap->get_vertical_layout(true);
     auto nondim     = ekat::units::Units::nondimensional();
     DataType real_t = DataType::RealType;
-    auto hyam       = m_grid_after_hremap->create_geometry_data("hyam", layout, nondim, real_t, SCREAM_PACK_SIZE);
-    auto hybm       = m_grid_after_hremap->create_geometry_data("hybm", layout, nondim, real_t, SCREAM_PACK_SIZE);
-    AtmosphereInput hvcoord_reader(m_time_database.files.front(), m_grid_after_hremap, {hyam, hybm}, true);
+    auto hyam =
+        m_grid_after_hremap->create_geometry_data("hyam", layout, nondim, real_t, SCREAM_PACK_SIZE);
+    auto hybm =
+        m_grid_after_hremap->create_geometry_data("hybm", layout, nondim, real_t, SCREAM_PACK_SIZE);
+    AtmosphereInput hvcoord_reader(m_time_database.files.front(), m_grid_after_hremap, {hyam, hybm},
+                                   true);
     hvcoord_reader.read_variables();
   } else if (m_vr_type == Static1D) {
     // Can load p now, since it's static
-    AtmosphereInput p_data_reader(m_time_database.files.front(), m_grid_after_hremap, {p_data.alias(data.pname)}, true);
+    AtmosphereInput p_data_reader(m_time_database.files.front(), m_grid_after_hremap,
+                                  {p_data.alias(data.pname)}, true);
     p_data_reader.read_variables();
   }
   vremap->set_source_pressure(m_helper_pressure_fields["p_data"], VerticalRemapper::Both);
@@ -544,8 +568,10 @@ void DataInterpolation::register_fields_in_remappers() {
   m_horiz_remapper_end->registration_begins();
   for (int i = 0; i < m_nfields; ++i) {
     const auto &f = m_vert_remapper->get_src_field(i);
-    m_horiz_remapper_beg->register_field_from_tgt(f.clone(f.name(), m_horiz_remapper_beg->get_src_grid()->name()));
-    m_horiz_remapper_end->register_field_from_tgt(f.clone(f.name(), m_horiz_remapper_end->get_src_grid()->name()));
+    m_horiz_remapper_beg->register_field_from_tgt(
+        f.clone(f.name(), m_horiz_remapper_beg->get_src_grid()->name()));
+    m_horiz_remapper_end->register_field_from_tgt(
+        f.clone(f.name(), m_horiz_remapper_end->get_src_grid()->name()));
   }
   if (m_vr_type == Dynamic3D or m_vr_type == Dynamic3DRef) {
     const auto &data_p = m_helper_pressure_fields["p_file"];
diff --git i/components/eamxx/src/share/util/eamxx_data_interpolation.hpp w/components/eamxx/src/share/util/eamxx_data_interpolation.hpp
index 27bc18d95a..2da258f9dc 100644
--- i/components/eamxx/src/share/util/eamxx_data_interpolation.hpp
+++ w/components/eamxx/src/share/util/eamxx_data_interpolation.hpp
@@ -32,12 +32,13 @@ public:
     std::string extrap_top = "P0";
     std::string extrap_bot = "P0";
     Real mask_value        = std::numeric_limits<Real>::quiet_NaN(); // Unused for P0 extrapolation
-    std::string pname;                                               // What we need to load from nc file
+    std::string pname; // What we need to load from nc file
     Field pmid, pint;
   };
 
   // Constructor(s) & Destructor
-  DataInterpolation(const std::shared_ptr<const AbstractGrid> &model_grid, const std::vector<Field> &fields);
+  DataInterpolation(const std::shared_ptr<const AbstractGrid> &model_grid,
+                    const std::vector<Field> &fields);
 
   ~DataInterpolation() = default;
 
@@ -87,7 +88,8 @@ protected:
   std::shared_ptr<AtmosphereInput> m_reader;
 
   std::shared_ptr<const AbstractGrid> m_model_grid;
-  std::shared_ptr<AbstractGrid> m_grid_after_hremap; // nonconst b/c we may need to set some geo data
+  std::shared_ptr<AbstractGrid>
+      m_grid_after_hremap; // nonconst b/c we may need to set some geo data
 
   std::vector<Field> m_fields;
 
diff --git i/components/eamxx/src/share/util/eamxx_deep_copy.hpp w/components/eamxx/src/share/util/eamxx_deep_copy.hpp
index 47193d1eef..6ac0740c43 100644
--- i/components/eamxx/src/share/util/eamxx_deep_copy.hpp
+++ w/components/eamxx/src/share/util/eamxx_deep_copy.hpp
@@ -16,8 +16,8 @@ struct ScreamDeepCopy {
 
   // Copy host data into 1d scalar view on Device
   template <typename ViewT>
-  static void copy_to_device(const std::vector<typename ViewT::value_type const *> &data, const std::vector<int> &sizes,
-                             std::vector<ViewT> &views) {
+  static void copy_to_device(const std::vector<typename ViewT::value_type const *> &data,
+                             const std::vector<int> &sizes, std::vector<ViewT> &views) {
     EKAT_ASSERT(ViewT::rank == 1);
     EKAT_ASSERT(data.size() == views.size());
     EKAT_ASSERT(data.size() == sizes.size());
@@ -36,8 +36,8 @@ struct ScreamDeepCopy {
 
   // Same as above function where all views have the same size
   template <typename ViewT>
-  static void copy_to_device(const std::vector<typename ViewT::value_type const *> &data, const int &size,
-                             std::vector<ViewT> &views) {
+  static void copy_to_device(const std::vector<typename ViewT::value_type const *> &data,
+                             const int &size, std::vector<ViewT> &views) {
     std::vector<int> sizes(data.size(), size);
     copy_to_device(data, sizes, views);
   }
@@ -63,8 +63,8 @@ struct ScreamDeepCopy {
 
   // Same as above function where all views have the same size
   template <typename ViewT>
-  static void copy_to_host(const std::vector<typename ViewT::non_const_value_type *> &data, const int &size,
-                           const std::vector<ViewT> &views) {
+  static void copy_to_host(const std::vector<typename ViewT::non_const_value_type *> &data,
+                           const int &size, const std::vector<ViewT> &views) {
     std::vector<int> sizes(data.size(), size);
     copy_to_host(data, sizes, views);
   }
diff --git i/components/eamxx/src/share/util/eamxx_family_tracking.hpp w/components/eamxx/src/share/util/eamxx_family_tracking.hpp
index 82429d34c8..9be86046ed 100644
--- i/components/eamxx/src/share/util/eamxx_family_tracking.hpp
+++ w/components/eamxx/src/share/util/eamxx_family_tracking.hpp
@@ -36,7 +36,8 @@ namespace scream {
  * a shared_ptr via lock() anymore).
  */
 
-template <typename DerivedType> class FamilyTracking : public ekat::enable_shared_from_this<DerivedType> {
+template <typename DerivedType>
+class FamilyTracking : public ekat::enable_shared_from_this<DerivedType> {
 public:
   using derived_type  = DerivedType;
   using tracking_type = FamilyTracking<derived_type>;
@@ -65,9 +66,10 @@ protected:
 template <typename DerivedType> FamilyTracking<DerivedType>::FamilyTracking() {
   // Note: we cannot put the static assert in the class decl, cause DerivedType
   //       is still incomplete at that point.
-  static_assert(std::is_base_of<tracking_type, derived_type>::value,
-                "Error! Do not instantiate FamilyTracking<T> if T does not inherit from FamilyTracking.\n"
-                "       This class exploits the Curiously Recurring Template Pattern (CRTP).\n");
+  static_assert(
+      std::is_base_of<tracking_type, derived_type>::value,
+      "Error! Do not instantiate FamilyTracking<T> if T does not inherit from FamilyTracking.\n"
+      "       This class exploits the Curiously Recurring Template Pattern (CRTP).\n");
 }
 
 template <typename DerivedType> FamilyTracking<DerivedType>::~FamilyTracking() {
@@ -119,7 +121,8 @@ template <typename DerivedType> FamilyTracking<DerivedType>::~FamilyTracking() {
 }
 
 template <typename DerivedType>
-void FamilyTracking<DerivedType>::create_parent_child_link(const std::shared_ptr<derived_type> &parent) {
+void FamilyTracking<DerivedType>::create_parent_child_link(
+    const std::shared_ptr<derived_type> &parent) {
   // Sanity checks
   EKAT_REQUIRE_MSG(this->shared_from_this(), "Error! Failure to get a shared object from *this.\n");
   EKAT_REQUIRE_MSG(m_parent == nullptr, "Error! This object already stores a parent.\n");
@@ -132,7 +135,9 @@ void FamilyTracking<DerivedType>::create_parent_child_link(const std::shared_ptr
 
   // Safety check. This should never happen, but just in case
   for (auto it : parent->get_children()) {
-    EKAT_REQUIRE_MSG(not is_same(it), "Error! This object is already in the list of children of the input parent.\n");
+    EKAT_REQUIRE_MSG(
+        not is_same(it),
+        "Error! This object is already in the list of children of the input parent.\n");
   }
 
   // Add myself as child in my parent's list
diff --git i/components/eamxx/src/share/util/eamxx_setup_random_test.hpp w/components/eamxx/src/share/util/eamxx_setup_random_test.hpp
index 2843db570a..396f942786 100644
--- i/components/eamxx/src/share/util/eamxx_setup_random_test.hpp
+++ w/components/eamxx/src/share/util/eamxx_setup_random_test.hpp
@@ -23,7 +23,8 @@ inline int get_random_test_seed(const ekat::Comm *comm = nullptr) {
     // Print seed to screen to trace tests that fail.
     std::cout << " For test " << test_name << ", random number generator seed: " << seed << "\n";
     if (catchRngSeed == 0) {
-      std::cout << "    Note: catch rng seed was 0 (default). We interpret that as a request to pick a random seed.\n"
+      std::cout << "    Note: catch rng seed was 0 (default). We interpret that as a request to "
+                   "pick a random seed.\n"
                    "    To reproduce a previous run, use --rng-seed N to provide the rng seed.\n\n";
     }
   }
@@ -47,7 +48,9 @@ Engine setup_random_test(const ekat::Comm *comm = nullptr, int *return_seed = nu
   return Engine(seed);
 }
 
-template <typename Engine = std::mt19937_64> Engine setup_random_test(const int seed) { return Engine(seed); }
+template <typename Engine = std::mt19937_64> Engine setup_random_test(const int seed) {
+  return Engine(seed);
+}
 
 } // namespace scream
 
diff --git i/components/eamxx/src/share/util/eamxx_time_interpolation.cpp w/components/eamxx/src/share/util/eamxx_time_interpolation.cpp
index bb7883a201..d3700fc58f 100644
--- i/components/eamxx/src/share/util/eamxx_time_interpolation.cpp
+++ w/components/eamxx/src/share/util/eamxx_time_interpolation.cpp
@@ -77,8 +77,10 @@ void TimeInterpolation::add_field(const Field &field_in, const bool store_shallo
   // First check that we haven't already added a field with the same name.
   const std::string name = field_in.name();
   EKAT_REQUIRE_MSG(!m_fm_time0->has_field(name) and !m_fm_time1->has_field(name),
-                   "Error!! TimeInterpolation:add_field, field + " << name << " has already been added." << "\n");
-  EKAT_REQUIRE_MSG(field_in.data_type() == DataType::FloatType or field_in.data_type() == DataType::DoubleType,
+                   "Error!! TimeInterpolation:add_field, field + "
+                       << name << " has already been added." << "\n");
+  EKAT_REQUIRE_MSG(field_in.data_type() == DataType::FloatType or
+                       field_in.data_type() == DataType::DoubleType,
                    "[TimeInterpolation] Error! Input field must have floating-point data type.\n"
                    " - field name: " +
                        field_in.name() +
@@ -157,7 +159,8 @@ void TimeInterpolation::initialize_data_from_files() {
   m_file_data_atm_input = std::make_shared<AtmosphereInput>(input_params, m_fm_time1);
   m_file_data_atm_input->set_logger(m_logger);
   // Assign the mask value gathered from the FillValue found in the source file.
-  // TODO: Should we make it possible to check if FillValue is in the metadata and only assign mask_value if it is?
+  // TODO: Should we make it possible to check if FillValue is in the metadata and only assign
+  // mask_value if it is?
   for (auto &name : m_field_names) {
     auto &field0    = m_fm_time0->get_field(name);
     auto &field1    = m_fm_time1->get_field(name);
@@ -185,10 +188,12 @@ void TimeInterpolation::initialize_data_from_files() {
 
     const auto &pio_var = scorpio::get_var(triplet_curr.filename, name);
     if (scorpio::refine_dtype(pio_var.nc_dtype) == "float") {
-      auto var_fill_value = scorpio::get_attribute<float>(triplet_curr.filename, name, "_FillValue");
+      auto var_fill_value =
+          scorpio::get_attribute<float>(triplet_curr.filename, name, "_FillValue");
       set_fill_value(var_fill_value);
     } else if (scorpio::refine_dtype(pio_var.nc_dtype) == "double") {
-      auto var_fill_value = scorpio::get_attribute<double>(triplet_curr.filename, name, "_FillValue");
+      auto var_fill_value =
+          scorpio::get_attribute<double>(triplet_curr.filename, name, "_FillValue");
       set_fill_value(var_fill_value);
     } else {
       EKAT_ERROR_MSG("Unrecognized/unsupported data type\n"
@@ -237,9 +242,9 @@ void TimeInterpolation::update_data_from_field(const Field &field_in) {
   auto &field0    = m_fm_time0->get_field(name);
   auto &field1    = m_fm_time1->get_field(name);
   std::swap(field0, field1);
-  // Now that we have swapped field0 and field 1 we need to grab field 1 from the field manager again.
-  // Alternatively we could just update `field0` which is now inside m_fm_time1, but choosing this
-  // approach for code readability.
+  // Now that we have swapped field0 and field 1 we need to grab field 1 from the field manager
+  // again. Alternatively we could just update `field0` which is now inside m_fm_time1, but choosing
+  // this approach for code readability.
   auto &field1_new = m_fm_time1->get_field(name);
   field1_new.deep_copy(field_in);
 }
@@ -262,13 +267,13 @@ void TimeInterpolation::print() {
  * We create a reference timestamp to use when sorting the data snaps.
  */
 void TimeInterpolation::set_file_data_triplets(const vos_type &list_of_files) {
-  EKAT_REQUIRE_MSG(list_of_files.size() > 0,
-                   "ERROR! TimeInterpolation::set_file_data_triplets - the list of files is empty. Please check.");
+  EKAT_REQUIRE_MSG(list_of_files.size() > 0, "ERROR! TimeInterpolation::set_file_data_triplets - "
+                                             "the list of files is empty. Please check.");
   TimeStamp ts_ref;
   // The first step is to grab all relevant metadata for the DataFromFileTriplet objects.
-  // We will store the times in a map and take advantage of maps natural sorting to organize the triplets
-  // in chronological order.  This ensures that if the list of files does not represent the chronological
-  // order to the data we will still have sorted data.
+  // We will store the times in a map and take advantage of maps natural sorting to organize the
+  // triplets in chronological order.  This ensures that if the list of files does not represent the
+  // chronological order to the data we will still have sorted data.
   vos_type filenames_tmp;
   std::vector<TimeStamp> timestamps_tmp;
   std::vector<int> time_idx_tmp;
@@ -309,7 +314,8 @@ void TimeInterpolation::set_file_data_triplets(const vos_type &list_of_files) {
       auto time = ts_snap.seconds_from(ts_ref);
       // Sanity check that we don't have multiples of the same timesnap
       EKAT_REQUIRE_MSG(map_of_times_to_vector_idx.count(time) == 0,
-                       "Error! TimeInterpolation::set_file_data_triplets - The same time step has been encountered "
+                       "Error! TimeInterpolation::set_file_data_triplets - The same time step has "
+                       "been encountered "
                        "more than once in the data files, please check\n"
                            << "    TimeStamp: " << ts_snap.to_string() << "\n"
                            << "     Filename: " << filename << "\n");
@@ -321,8 +327,9 @@ void TimeInterpolation::set_file_data_triplets(const vos_type &list_of_files) {
     }
     scorpio::release_file(filename);
   }
-  // Now that we have gathered all of the timesnaps we can arrange them in order as DataFromFileTriplet objects.
-  // Taking advantage of maps automatically self-sorting by the first arg.
+  // Now that we have gathered all of the timesnaps we can arrange them in order as
+  // DataFromFileTriplet objects. Taking advantage of maps automatically self-sorting by the first
+  // arg.
   for (auto a : map_of_times_to_vector_idx) {
     auto idx = a.second;
     DataFromFileTriplet my_trip;
@@ -348,15 +355,18 @@ void TimeInterpolation::read_data() {
     m_file_data_atm_input = std::make_shared<AtmosphereInput>(input_params, m_fm_time1);
     m_file_data_atm_input->set_logger(m_logger);
     // Also determine the FillValue, if used
-    // TODO: Should we make it possible to check if FillValue is in the metadata and only assign mask_value if it is?
+    // TODO: Should we make it possible to check if FillValue is in the metadata and only assign
+    // mask_value if it is?
     for (auto &name : m_field_names) {
       auto &field   = m_fm_time1->get_field(name);
       const auto dt = field.data_type();
       if (dt == DataType::FloatType) {
-        auto var_fill_value = scorpio::get_attribute<float>(triplet_curr.filename, name, "_FillValue");
+        auto var_fill_value =
+            scorpio::get_attribute<float>(triplet_curr.filename, name, "_FillValue");
         field.get_header().set_extra_data("mask_value", var_fill_value);
       } else if (dt == DataType::DoubleType) {
-        auto var_fill_value = scorpio::get_attribute<double>(triplet_curr.filename, name, "_FillValue");
+        auto var_fill_value =
+            scorpio::get_attribute<double>(triplet_curr.filename, name, "_FillValue");
         field.get_header().set_extra_data("mask_value", var_fill_value);
       } else {
         EKAT_ERROR_MSG("[TimeInterpolation] Unexpected/unsupported field data type.\n"
@@ -371,7 +381,8 @@ void TimeInterpolation::read_data() {
 
   if (m_logger) {
     m_logger->info(m_header);
-    m_logger->info("[EAMxx:time_interpolation] Reading data at time " + triplet_curr.timestamp.to_string());
+    m_logger->info("[EAMxx:time_interpolation] Reading data at time " +
+                   triplet_curr.timestamp.to_string());
   }
   m_file_data_atm_input->read_variables(triplet_curr.time_idx);
   m_time1 = triplet_curr.timestamp;
@@ -385,13 +396,14 @@ void TimeInterpolation::read_data() {
  */
 void TimeInterpolation::check_and_update_data(const TimeStamp &ts_in) {
   // First check if the passed timestamp is within the bounds of time0 and time1.
-  EKAT_REQUIRE_MSG(ts_in.seconds_from(m_time0) >= 0, "ERROR!!! TimeInterpolation::check_and_update_data - "
-                                                         << "Current timestamp of " << ts_in.to_string()
-                                                         << " is lower than the TimeInterpolation bounds of "
-                                                         << m_time0.to_string());
+  EKAT_REQUIRE_MSG(ts_in.seconds_from(m_time0) >= 0,
+                   "ERROR!!! TimeInterpolation::check_and_update_data - "
+                       << "Current timestamp of " << ts_in.to_string()
+                       << " is lower than the TimeInterpolation bounds of " << m_time0.to_string());
   if (m_time1.seconds_from(ts_in) < 0) {
     // The timestamp is out of bounds, need to load new data.
-    // First cycle through the DataFromFileTriplet's to find a timestamp that is greater than this one.
+    // First cycle through the DataFromFileTriplet's to find a timestamp that is greater than this
+    // one.
     bool found   = false;
     int step_cnt = 0; // Track how many triplets we passed to find one that worked.
     while (m_triplet_idx < static_cast<int>(m_file_data_triplets.size())) {
@@ -405,13 +417,15 @@ void TimeInterpolation::check_and_update_data(const TimeStamp &ts_in) {
       }
     }
     EKAT_REQUIRE_MSG(found, "ERROR!! TimeInterpolation::check_and_update_data - timestamp "
-                                << ts_in.to_string() << "is outside the bounds of the set of data files." << "\n"
+                                << ts_in.to_string()
+                                << "is outside the bounds of the set of data files." << "\n"
                                 << "     TimeStamp time0: " << m_time0.to_string() << "\n"
                                 << "     TimeStamp time1: " << m_time1.to_string() << "\n");
-    // Now we need to make sure we didn't jump more than one triplet, if we did then the data at time0 is
-    // incorrect.
+    // Now we need to make sure we didn't jump more than one triplet, if we did then the data at
+    // time0 is incorrect.
     if (step_cnt > 1) {
-      // Then we need to populate data for time1 as the previous triplet before shifting data to time0
+      // Then we need to populate data for time1 as the previous triplet before shifting data to
+      // time0
       --m_triplet_idx;
       read_data();
       ++m_triplet_idx;
@@ -421,9 +435,11 @@ void TimeInterpolation::check_and_update_data(const TimeStamp &ts_in) {
     update_timestamp(m_file_data_triplets[m_triplet_idx].timestamp);
     read_data();
     // Sanity Check
-    bool current_data_check = (ts_in.seconds_from(m_time0) >= 0) and (m_time1.seconds_from(ts_in) >= 0);
+    bool current_data_check =
+        (ts_in.seconds_from(m_time0) >= 0) and (m_time1.seconds_from(ts_in) >= 0);
     EKAT_REQUIRE_MSG(current_data_check,
-                     "ERROR!! TimeInterpolation::check_and_update_data - Something went wrong in updating data:\n"
+                     "ERROR!! TimeInterpolation::check_and_update_data - Something went wrong in "
+                     "updating data:\n"
                          << "      TimeStamp    IN: " << ts_in.to_string() << "\n"
                          << "      TimeStamp time0: " << m_time0.to_string() << "\n"
                          << "      TimeStamp time1: " << m_time1.to_string() << "\n");
diff --git i/components/eamxx/src/share/util/eamxx_time_interpolation.hpp w/components/eamxx/src/share/util/eamxx_time_interpolation.hpp
index 9fb3227372..6fed79c096 100644
--- i/components/eamxx/src/share/util/eamxx_time_interpolation.hpp
+++ w/components/eamxx/src/share/util/eamxx_time_interpolation.hpp
@@ -44,7 +44,8 @@ public:
   void print();
 
   // Option to add a logger
-  void set_logger(const std::shared_ptr<ekat::logger::LoggerBase> &logger, const std::string &header) {
+  void set_logger(const std::shared_ptr<ekat::logger::LoggerBase> &logger,
+                  const std::string &header) {
     m_logger = logger;
     m_header = header;
   }
diff --git i/components/eamxx/src/share/util/eamxx_time_stamp.cpp w/components/eamxx/src/share/util/eamxx_time_stamp.cpp
index e6e29429c3..c3c7687f44 100644
--- i/components/eamxx/src/share/util/eamxx_time_stamp.cpp
+++ w/components/eamxx/src/share/util/eamxx_time_stamp.cpp
@@ -33,21 +33,26 @@ bool is_leap_year(const int yy) {
 }
 
 int days_in_month(const int yy, const int mm) {
-  EKAT_REQUIRE_MSG(mm >= 1 && mm <= 12,
-                   "Error! Month out of bounds. Did you call `days_in_month` with yy and mm swapped?\n");
+  EKAT_REQUIRE_MSG(
+      mm >= 1 && mm <= 12,
+      "Error! Month out of bounds. Did you call `days_in_month` with yy and mm swapped?\n");
   constexpr int nonleap_days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
   constexpr int leap_days[12]    = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
   auto &arr                      = is_leap_year(yy) ? leap_days : nonleap_days;
   return arr[mm - 1];
 }
 
-TimeStamp::TimeStamp() : m_date(3, std::numeric_limits<int>::lowest()), m_time(3, std::numeric_limits<int>::lowest()) {
+TimeStamp::TimeStamp()
+    : m_date(3, std::numeric_limits<int>::lowest()), m_time(3, std::numeric_limits<int>::lowest()) {
   // Nothing to do here
 }
 
-TimeStamp::TimeStamp(const std::vector<int> &date, const std::vector<int> &time, const int num_steps) {
-  EKAT_REQUIRE_MSG(date.size() == 3, "Error! Date should consist of three ints: [year, month, day].\n");
-  EKAT_REQUIRE_MSG(time.size() == 3, "Error! Time of day should consist of three ints: [hour, min, sec].\n");
+TimeStamp::TimeStamp(const std::vector<int> &date, const std::vector<int> &time,
+                     const int num_steps) {
+  EKAT_REQUIRE_MSG(date.size() == 3,
+                   "Error! Date should consist of three ints: [year, month, day].\n");
+  EKAT_REQUIRE_MSG(time.size() == 3,
+                   "Error! Time of day should consist of three ints: [hour, min, sec].\n");
   EKAT_REQUIRE_MSG(num_steps >= 0, "Error! Number of steps should be a non-negative number.\n");
 
   const auto yy   = date[0];
@@ -71,8 +76,8 @@ TimeStamp::TimeStamp(const std::vector<int> &date, const std::vector<int> &time,
   m_num_steps = num_steps;
 }
 
-TimeStamp::TimeStamp(const int yy, const int mm, const int dd, const int h, const int min, const int sec,
-                     const int num_steps)
+TimeStamp::TimeStamp(const int yy, const int mm, const int dd, const int h, const int min,
+                     const int sec, const int num_steps)
     : TimeStamp({yy, mm, dd}, {h, min, sec}, num_steps) {
   // Nothing to do here
 }
@@ -137,10 +142,12 @@ TimeStamp &TimeStamp::operator+=(const double seconds) {
   //       but that should be the case here, for use cases in EAMxx.
   EKAT_REQUIRE_MSG(seconds >= 0, "Error! Cannot rewind time.\n");
   EKAT_REQUIRE_MSG((seconds - round(seconds)) < std::numeric_limits<double>::epsilon() * 10,
-                   "Error! Cannot update TimeStamp with non-integral number of seconds " << seconds << "\n");
+                   "Error! Cannot update TimeStamp with non-integral number of seconds " << seconds
+                                                                                         << "\n");
 
-  EKAT_REQUIRE_MSG(is_valid(), "Error! The time stamp contains uninitialized values.\n"
-                               "       To use this object, use operator= with a valid rhs first.\n");
+  EKAT_REQUIRE_MSG(is_valid(),
+                   "Error! The time stamp contains uninitialized values.\n"
+                   "       To use this object, use operator= with a valid rhs first.\n");
 
   auto &sec  = m_time[2];
   auto &min  = m_time[1];
diff --git i/components/eamxx/src/share/util/eamxx_time_stamp.hpp w/components/eamxx/src/share/util/eamxx_time_stamp.hpp
index 6f26dc8534..e033b13f38 100644
--- i/components/eamxx/src/share/util/eamxx_time_stamp.hpp
+++ w/components/eamxx/src/share/util/eamxx_time_stamp.hpp
@@ -14,7 +14,8 @@ class TimeStamp {
 public:
   TimeStamp();
   TimeStamp(const std::vector<int> &date, const std::vector<int> &time, const int num_steps = 0);
-  TimeStamp(const int yy, const int mm, int dd, const int h, const int min, const int sec, const int num_steps = 0);
+  TimeStamp(const int yy, const int mm, int dd, const int h, const int min, const int sec,
+            const int num_steps = 0);
   TimeStamp(const TimeStamp &) = default;
 
   // === Query methods === //
@@ -105,7 +106,8 @@ struct TimeInterval {
   double length     = -1; // the interval length
 
   TimeInterval() = default;
-  TimeInterval(const util::TimeStamp &b, const util::TimeStamp &e, TimeLine tl, bool do_compute_length = true)
+  TimeInterval(const util::TimeStamp &b, const util::TimeStamp &e, TimeLine tl,
+               bool do_compute_length = true)
       : beg(b), end(e), timeline(tl) {
     if (do_compute_length)
       compute_length();
diff --git i/components/eamxx/src/share/util/eamxx_universal_constants.hpp w/components/eamxx/src/share/util/eamxx_universal_constants.hpp
index dba5c5502d..753b8e598e 100644
--- i/components/eamxx/src/share/util/eamxx_universal_constants.hpp
+++ w/components/eamxx/src/share/util/eamxx_universal_constants.hpp
@@ -12,7 +12,8 @@ constexpr int seconds_per_day       = 86400;
 constexpr int days_per_nonleap_year = 365;
 
 // Universal fill value for variables
-// TODO: When we switch to supporting C++17 we can use a simple `inline constexpr` rather than a struct
+// TODO: When we switch to supporting C++17 we can use a simple `inline constexpr` rather than a
+// struct
 template <typename T> struct DefaultFillValue {
   static constexpr bool is_float = std::is_floating_point<T>::value;
   static constexpr bool is_int   = std::is_integral<T>::value;
diff --git i/components/eamxx/src/share/util/eamxx_utils.cpp w/components/eamxx/src/share/util/eamxx_utils.cpp
index e18068c59a..bec611f657 100644
--- i/components/eamxx/src/share/util/eamxx_utils.cpp
+++ w/components/eamxx/src/share/util/eamxx_utils.cpp
@@ -73,7 +73,8 @@ std::vector<std::string> globloc(const std::string &pattern) {
   int return_value = ::glob(pattern.c_str(), GLOB_TILDE, NULL, &glob_result);
   if (return_value != 0) {
     globfree(&glob_result);
-    EKAT_REQUIRE_MSG(return_value == 0, "glob() failed with return value " + std::to_string(return_value));
+    EKAT_REQUIRE_MSG(return_value == 0,
+                     "glob() failed with return value " + std::to_string(return_value));
   }
 
   std::vector<std::string> filenames;
diff --git i/components/eamxx/src/share/util/eamxx_utils.hpp w/components/eamxx/src/share/util/eamxx_utils.hpp
index 82e3804290..4db34f2bbf 100644
--- i/components/eamxx/src/share/util/eamxx_utils.hpp
+++ w/components/eamxx/src/share/util/eamxx_utils.hpp
@@ -31,9 +31,9 @@ long long get_mem_usage(const MemoryUnits u);
 // Micro-utility, that given an enum returns the underlying int.
 // The only use of this is if you need to sort scoped enums.
 template <typename EnumT>
-KOKKOS_FUNCTION constexpr
-    typename std::enable_if<std::is_enum<EnumT>::value, typename std::underlying_type<EnumT>::type>::type
-    etoi(const EnumT e) {
+KOKKOS_FUNCTION constexpr typename std::enable_if<std::is_enum<EnumT>::value,
+                                                  typename std::underlying_type<EnumT>::type>::type
+etoi(const EnumT e) {
   return static_cast<typename std::underlying_type<EnumT>::type>(e);
 }
 
@@ -183,7 +183,8 @@ template <typename T> std::list<T> contiguous_superset(const std::list<std::list
 
     // If we have a non-empty reminder, then all the caps must be
     // either at the front or the back of the lol, that is, either the first intersection
-    // is at pos=0, or the last at pos=lol.size()-1, or both (otherwise this group would be fragmented).
+    // is at pos=0, or the last at pos=lol.size()-1, or both (otherwise this group would be
+    // fragmented).
     if (remainder.size() > 0 && !(caps_pos.front() == 0 || caps_pos.back() == (lol.size() - 1))) {
       return std::list<T>();
     }
@@ -281,7 +282,8 @@ template <typename T> std::list<T> contiguous_superset(const std::list<std::list
  * This is used by the run_and_cmp tests.
  */
 template <typename Scalar, typename Toltype>
-Int compare(const std::string &label, const Scalar *a, const Scalar *b, const Int &n, const Toltype &tol) {
+Int compare(const std::string &label, const Scalar *a, const Scalar *b, const Int &n,
+            const Toltype &tol) {
 
   Int nerr1  = 0;
   Int nerr2  = 0;
@@ -378,7 +380,8 @@ struct DefaultMetadata {
     }
   }
 
-  void read_csv_file_to_maps(const std::string &filename, std::map<std::string, std::string> &name_2_standardname,
+  void read_csv_file_to_maps(const std::string &filename,
+                             std::map<std::string, std::string> &name_2_standardname,
                              std::map<std::string, std::string> &name_2_longname) {
     std::ifstream file(filename);
     EKAT_REQUIRE_MSG(file.is_open(), "Could not open the file: " + filename);
@@ -399,9 +402,12 @@ struct DefaultMetadata {
 
       if (isFirstLine) {
         // Sanity check: the first line contains the required headers
-        EKAT_REQUIRE_MSG(column1 == "variable" && column2 == "standard_name" && column3 == "long_name",
-                         "CSV file does not contain the required headers: variable, standard_name, long_name. Found: " +
-                             column1 + ", " + column2 + ", and " + column3 + " respectively in file " + filename);
+        EKAT_REQUIRE_MSG(column1 == "variable" && column2 == "standard_name" &&
+                             column3 == "long_name",
+                         "CSV file does not contain the required headers: variable, standard_name, "
+                         "long_name. Found: " +
+                             column1 + ", " + column2 + ", and " + column3 +
+                             " respectively in file " + filename);
         isFirstLine = false;
         continue;
       }
diff --git i/components/mpas-ocean/src/ppr w/components/mpas-ocean/src/ppr
--- i/components/mpas-ocean/src/ppr
+++ w/components/mpas-ocean/src/ppr
@@ -1 +1 @@
-Subproject commit 3c2246463d5de14f492139987bd84978b84e86ea
+Subproject commit 3c2246463d5de14f492139987bd84978b84e86ea-dirty
