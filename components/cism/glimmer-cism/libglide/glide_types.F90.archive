!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!                                                             
!   glide_types.F90.archive - part of the Glimmer Community Ice Sheet Model (Glimmer-CISM)  
!                                                              
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!   Copyright (C) 2005-2013
!   Glimmer-CISM contributors - see AUTHORS file for list of contributors
!
!   This file is part of Glimmer-CISM.
!
!   Glimmer-CISM is free software: you can redistribute it and/or modify it
!   under the terms of the Lesser GNU General Public License as published
!   by the Free Software Foundation, either version 3 of the License, or
!   (at your option) any later version.
!
!   Glimmer-CISM is distributed in the hope that it will be useful,
!   but WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!   Lesser GNU General Public License for more details.
!
!   You should have received a copy of the Lesser GNU General Public License
!   along with Glimmer-CISM. If not, see <http://www.gnu.org/licenses/>.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#ifdef HAVE_CONFIG_H
#include "config.inc"
#endif

module glide_types

  !*FD Holds type definitions for the derived types used by each 
  !*FD instance of the ice model. Originally, each of these types
  !*FD was a module containing variables, which were used as containers
  !*FD for global variables. However, the need to allow for multiple
  !*FD ice model instances meant that the nested derived types were instituted
  !*FD instead. However, there is probably one too many levels in this scheme. 
  !*FD It would be better if the different types here were contained in the 
  !*FD higher-level instance type (\texttt{glimmer\_params}), rather than 
  !*FD the intermediate model type (\texttt{glimmer\_global\_type}). 
  !*FD 
  !*FD Note that this \emph{is} now where the defaults are defined for these
  !*FD variables.
 
  use glimmer_sparse
  use glimmer_sparse_type
  use glimmer_global
  use glimmer_ncdf
  use isostasy_types
  use profile
  use glimmer_coordinates
  use glimmer_map_types, pi_dummy=>pi

  !These modules define internal workspace types.  We are including them so that they can appear in glide_types.
  use remap_glamutils

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_general

    !*FD Holds fundamental parameters of the ice model geometry.

    integer :: ewn = 0  !*FD The number of grid-points in the E-W direction.
    integer :: nsn = 0  !*FD The number of grid-points in the N-S direction.
    integer :: upn = 1  !*FD The number of vertical levels in the model.

    type(coordsystem_type) :: ice_grid  !*FD coordinate system of the ice grid
    type(coordsystem_type) :: velo_grid !*FD coordinate system of the velocity grid

    real(sp), dimension(:),pointer :: x0 => null() !original x0 grid 
    real(sp), dimension(:),pointer :: y0 => null() !original y0 grid
    real(sp), dimension(:),pointer :: x1 => null() !original x1 grid
    real(sp), dimension(:),pointer :: y1 => null() !original y1 grid
  end type glide_general

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  !Constants that describe the options available
  integer, parameter :: TEMP_SURFACE_AIR_TEMP = 0
  integer, parameter :: TEMP_FULL = 1
  integer, parameter :: TEMP_STEADY = 2
  integer, parameter :: TEMP_REMAP_ADV = 3

  integer, parameter :: FLWA_PATERSON_BUDD = 0
  integer, parameter :: FLWA_PATERSON_BUDD_CONST_TEMP = 1
  integer, parameter :: FLWA_CONST_FLWA = 2

  !...etc, don't have time to do all of these now

  integer, parameter :: EVOL_PSEUDO_DIFF = 0
  integer, parameter :: EVOL_ADI = 1
  integer, parameter :: EVOL_DIFFUSION = 2
  integer, parameter :: EVOL_INC_REMAP = 3
  integer, parameter :: EVOL_FO_UPWIND = 4  ! *sfp** added for summer modeling school

  integer, parameter :: SIGMA_BUILTIN_DEFAULT = 0 !Use default Sigma coordinate spacing
  integer, parameter :: SIGMA_BUILTIN_EVEN = 1 !Use an evenly spaced Sigma coordinate
  integer, parameter :: SIGMA_BUILTIN_PATTYN = 2 !Use Pattyn's sigma coordinates

  integer, parameter :: BWATER_LOCAL = 0
  integer, parameter :: BWATER_FLUX  = 1
  integer, parameter :: BWATER_NONE  = 2
  integer, parameter :: BWATER_BASAL_PROC = 3  !*mb* basal water available from basal proc. module
  integer, parameter :: BWATER_CONST = 4       !*mb* Constant thickness of water, e.g., to force Tpmp.

  integer, parameter :: HO_DIAG_NONE = 0
  integer, parameter :: HO_DIAG_PATTYN_UNSTAGGERED = 1
  integer, parameter :: HO_DIAG_PATTYN_STAGGERED = 2
  integer, parameter :: HO_DIAG_PP = 3 ! *sfp** added

  integer, parameter :: HO_PROG_SIAONLY = 0
  integer, parameter :: HO_PROG_PATTYN = 1
  integer, parameter :: HO_PROG_POLLARD = 2
  integer, parameter :: HO_PROG_BUELER = 3

!  integer, parameter :: HO_NONLIN_PICARD = 0    !*sfp* these are now defined in 'glimmer_sparse.F90'
!  integer, parameter :: HO_NONLIN_JFNK = 1

  integer, parameter :: HO_BETA_ALL_NAN = 0
  integer, parameter :: HO_BETA_USE_SOFT = 1
  integer, parameter :: HO_BETA_USE_BTRC = 2
  integer, parameter :: HO_BETA_USE_BETA = 3
  integer, parameter :: HO_BETA_SLIP_RATIO = 4

  integer, parameter :: HO_BSTRESS_LINEAR = 0
  integer, parameter :: HO_BSTRESS_PLASTIC = 1

  integer, parameter :: HO_EFVS_FULL = 0
  integer, parameter :: HO_EFVS_CONSTANT = 1
  integer, parameter :: HO_EFVS_MINIMUM = 2
    !*FD Flag that indicates how effective viscosity is computed
    !*FD \begin{description}
    !*FD \item[0] compute from effective strain rate
    !*FD \item[1] constant value
    !*FD \item[2] minimum value

  !*sfp* added the next two groups for HO T calcs.
  integer, parameter :: SIA_DISP = 0
  integer, parameter :: FIRSTORDER_DISP = 1
  integer, parameter :: SSA_DISP = 2

  integer, parameter :: SIA_BMELT = 0
  integer, parameter :: FIRSTORDER_BMELT = 1
  integer, parameter :: SSA_BMELT = 2

  integer, parameter :: HO_SOURCE_AVERAGED = 0
  integer, parameter :: HO_SOURCE_EXPLICIT = 1
  integer, parameter :: HO_SOURCE_DISABLED = 2

  !*mb* added option to use the basal proc. model
  integer, parameter :: BAS_PROC_DISABLED = 0
  integer, parameter :: BAS_PROC_FULLCALC = 1
  integer, parameter :: BAS_PROC_FASTCALC = 2

  type glide_options

    !*FD Holds user options controlling the methods used in the ice-model
    !*FD integration.

    integer :: whichtemp = 1

    !*FD Method of ice temperature calculation:
    !*FD \begin{description} 
    !*FD \item[0] Set column to surface air temperature
    !*FD \item[1] Do full temperature solution (also find vertical velocity
    !*FD and apparent vertical velocity)
    !*FD \item[2] Do NOTHING - hold temperatures steady at initial value  
    !*FD \item[3] Use remapping to advect temperature (no advection by glide_temp)
    !*FD \end{description}

    integer :: whichflwa = 0

    !*FD Method for calculating flow factor $A$:
    !*FD \begin{description} 
    !*FD \item[0] \emph{Paterson and Budd} relationship 
    !*FD \item[1] \emph{Paterson and Budd} relationship, 
    !*FD with temperature set to $-10^{\circ}\mathrm{C}$ 
    !*FD \item[2] Set equal to $1\times 10^{-16}\,\mathrm{yr}^{-1}
    !*FD \,\mathrm{Pa}^{-n}$
    !*FD \end{description}

    ! *mb* added
    integer :: which_bmod = 0
    !Options for the basal processes code
    !*FD \begin{description}
    !*FD \item[0] Disabled
    !*FD \item[1] Full calculation, with at least 3 nodes to represent the till layer
    !*FD \item[2] Fast calculation, using Tulaczyk empirical parametrization
    !*FD \end{description}

    integer :: whichbwat = 2

    !*FD Basal water depth: 
    !*FD \begin{description} 
    !*FD \item[0] Calculated from local basal water balance 
    !*FD \item[1] Compute the basal water flux, then find depth via calculation
    !*FD \item[2] Set to zero everywhere 
    !*FD \item[3] Calculated from till water content, in the basal processes module
    !*FD \item[4] Set to constant everywhere (10m).
    !*FD \end{description}

    integer :: whichmarn = 1

    !*FD Ice thickness: 
    !*FD \begin{description} 
    !*FD \item[0] No action 
    !*FD \item[1] Set thickness to zero if floating 
    !*FD \item[2] Set thickness to zero if relaxed bedrock is more 
    !*FD than certain water depth  
    !*FD \item[3] Lose fraction of ice when edge cell
    !*FD \end{description}

    integer :: whichbtrc = 0

    !*FD Basal slip coefficient: 
    !*FD \begin{description}
    !*FD \item[0] Set equal to zero everywhere
    !*FD \item[1] Set (non--zero) constant
    !*FD \item[2] Set to (non--zero) constant where temperature is at pressure melting point of ice, otherwise to zero
    !*FD \item[3] \texttt{tanh} function of basal water depth 
    !*FD \end{description}

    integer :: whichevol = 0

    !*FD Thickness evolution method:
    !*FD \begin{description}
    !*FD \item[0] Pseudo-diffusion approach 
    !*FD \item[2] Diffusion approach (also calculates velocities) 
    !*FD \item[3] Incremental remapping
    !*FD \item[4] 1st-order upwind scheme
    !*FD \end{description}

    integer :: whichwvel = 0

    !*FD Vertical velocities: 
    !*FD \begin{description}
    !*FD \item[0] Usual vertical integration 
    !*FD \item[1] Vertical integration constrained so that 
    !*FD upper kinematic B.C. obeyed 
    !*FD \end{description}

    integer :: whichrelaxed = 0
    !*FD relaxed topography:
    !*FD \begin{description}
    !*FD \item[0] get relaxed topo from separate variable
    !*FD \item[1] first time slice of input topo is relaxed
    !*FD \item[2] first time slice of input topo is in isostatic equilibrium
    !*FD \end{description}

    integer :: hotstart = 0
    !*FD hotstart the model
    !*FD \begin{description}
    !*FD \item[0] normal start-up
    !*FD \item[1] hotstart model from previous run
    !*FD \end{description}

    integer :: which_ho_diagnostic = 0
    !*FD Higher-order velocity computation scheme
    !*FD \begin{description}
    !*FD \item[0] Do not compute higher-order velocity estimate
    !*FD \item[1] Compute higher-order velocity estimate using Pattyn's model
    !*FD \end{description}

    integer :: which_ho_prognostic = 0
    !*FD Higher-order prognostic scheme.  Note that this flag applies only when
    !*FD using Glimmer's existing ice evolution functions; new evolution methods
    !*FD may be added that do not use the diffusive scheme.  In other words,
    !*FD this flag states how to transform the HO velocities into diffusion and
    !*FD basal velocity fields.
    !*FD \begin{description}
    !*FD \item[0] Do not not use higher-order velocities prognostically; compute
    !*FD          and output them but use SIA to evolve the ice
    !*FD \item[1] Pattyn scheme (compute higher-order diffusivities only)
    !*FD \item[2] Pollard scheme (Not implemented yet)
    !*FD \item[3] Bueler scheme (Not implemented yet)
    !*FD \end{description}

    integer :: which_ho_beta_in = 0
    !*FD Flag that indicates how to compute beta, the higher-order basal stress
    !*FD coefficient
    !*FD \begin{description}
    !*FD \item[0] Set to NaN everywhere (no sliding, ice glued to the bed)
    !*FD \item[1] Set to 1/soft (default)
    !*FD \item[2] Set to 1/btrc (re-computed at each time step)
    !*FD \item[3] Set to beta field of input netcdf file
    !*FD \end{description}

    integer :: which_ho_bstress = 0
    !*FD Flag that indicates which sliding law to use in higher-order velocity
    !*FD computations
    !*FD \begin{description}
    !*FD \item[0] Linear sliding law, $\tau_b = \beta u_b$
    !*FD \item[1] Plastic till sliding law, 
    !*FD $\tau_{b,i} = -\tau_c \frac{v_i}{\lVert v \rVert}

    ! options for using the Payne/Price higher-order dynamical core
    integer :: which_ho_babc = 4
    !*FD Flag that describes basal boundary condition for PP dyn core: 
    !*FD \begin{description}
    !*FD \item[0] constant value (hardcoded in, useful for debugging)
    !*FD \item[1] simple pattern ("     ")
    !*FD \item[2] use till yield stress from basal proc model
    !*FD \item[3] circular ice shelf
    !*FD \item[4] no slip everywhere
    !*FD \item[5] beta^2 field passed in from CISM
    !*FD \item[0] constant value (hardcoded in, useful for debugging)
    !*FD \item[1] simple pattern (hardcoded in, .... )
    !*FD \item[2] use till yield stress from basal proc model (Picard-type iteration)
    !*FD \item[3] circular ice shelf
    !*FD \item[4] no slip everywhere (using stress basal bc and large value for B^2)
    !*FD \item[5] beta^2 field passed in from CISM
    !*FD \item[6] no slip everywhere (using Dirichlet, no slip basal bc)
    !*FD \item[7] use till yield stress from basal proc model (Newton-type iteration)
    !*FD \end{description}

    integer :: which_ho_efvs = 0
    !*FD Flag that indicates how effective viscosity is computed for PP dyn core:
    !*FD \begin{description}
    !*FD \item[0] compute from effective strain rate
    !*FD \item[1] constant value

    integer :: which_ho_resid = 0
    !*FD Flag that indicates method for computing residual in PP dyn core: 
    !*FD \begin{description}
    !*FD \item[0] maxval 
    !*FD \item[1] maxval ignoring basal velocity 
    !*FD \item[2] mean value
    !*FD \begin{description}

    !*sfp* added
    integer :: which_disp = 0
    !*FD Flag that indicates method for computing the dissipation during the temperature calc.
    !*FD \begin{description}
    !*FD \item[0] for 0-order SIA approx
    !*FD \item[1] for 1-st order solution (e.g. Blatter-Pattyn)
    !*FD \item[2] for 1-st order depth-integrated solution (SSA)
    !*FD \end{description}

    !*sfp* added
    integer :: which_bmelt = 0
    !*FD Flag that indicates method for computing the frictional melt rate terms during temperature calc.
    !*FD \begin{description}
    !*FD \item[0] for 0-order SIA approx
    !*FD \item[1] for 1-st order solution (e.g. Blatter-Pattyn)
    !*FD \item[2] for 1-st order depth-integrated solution (SSA)
    !*FD \begin{description}

    integer :: which_ho_nonlinear = 0
    !*FD Flag that indicates method for solving the nonlinear iteration when solving 
    !*FD the first-order momentum balance
    !*FD \item[0] use the standard Picard iteration
    !*FD \item[1] use Jacobian Free Newton Krylov (JFNK) method

    integer :: which_ho_sparse = 0
    !*FD Flag that indicates method for solving the sparse linear system
    !*FD that arises from the higher-order solver
    !*FD \begin{description}
    !*FD \item[0] Biconjugate Gradient, Incomplete LU Preconditioner
    !*FD \item[1] GMRES, Incomplete LU Preconditioner
    !*FD \item[2] Unsymmetric multifrontal direct solver
    !*FD \item[3] interface to Trilinos
    !*FD \end{description}

    integer :: which_ho_sparse_fallback = -1
    !*FD Flag that indicates a sparse matrix solver that the higher-order 
    !*FD computation should fall back on if the primary choice fails.
    !*FD By default, this is set to -1 which indicates no fallback.
    !*FD Optimally, this should be set to a direct solver (such as UMFPACK)
    !*FD that can be used if the iterative solver fails.

    integer :: which_ho_source = 0
    !*FD Flag that indicates how to compute the source term of an ice shelf
    !*FD \begin{description}
    !*FD \item[0] Vertically averaged formulation (uniform pressure applied regardless of depth)
    !*FD \item[1] Vertically explicit formulation (pressue dependent on depth)
    !*FD \end{description}

    logical :: ho_include_thinice = .true.
    !*FD Whether or not to include thin ice in the higher order computation


    logical :: periodic_ew = .false.
    !*FD \begin{description}
    !*FD \item[0] no periodic EW boundary conditions
    !*FD \item[1] periodic EW boundary conditions
    !*FD \end{description}

    logical :: periodic_ns = .false.

    integer :: gthf = 0
    !*FD \begin{description}
    !*FD \item[0] no geothermal heat flux calculations
    !*FD \item[1] calculate gthf using 3d diffusion
    !*FD \end{description}

    integer :: which_sigma = 0
    !*FD \begin{description}
    !*FD \item[0] calculate sigma coordinates
    !*FD \item[1] sigma coordinates are given in external file
    !*FD \item[2] sigma coordinates are given in configuration file
    !*FD \end{description}

    integer :: which_sigma_builtin = 0
    !If Glimmer generates the sigma coordinates, selects which built-in sigma to
    !use
    !*FD \begin{description}
    !*FD \item[0] standard Glimmer setup
    !*FD \item[1] evenly spaced levels
    !*FD \item[2] Pattyn's sigma levels
    !*FD \end{description}

    integer :: diagnostic_run = 0

    !EIB! skip for now
    !integer :: use_plume = 0
    !*FD \begin{description}
    !*FD \item[0] standard bmlt calculation
    !*FD \item[1] use plume to calculate bmlt
    !*FD \end{description}

    integer :: basal_mbal = 0
    !*FD \begin{description}
    !*FD \item[0] Basal melt rate not included in continuity equation
    !*FD \item[1] Basal melt rate included in continuity equation
    !*FD \end{description}

  end type glide_options

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_geometry

    !*FD Holds fields and other information relating to the
    !*FD geometry of the ice sheet and bedrock.

    real, dimension(:,:), pointer :: temporary0 => null()
    !*FD temporary array used for masking velocity grid
    real, dimension(:,:), pointer :: temporary1 => null()
    !*FD temporary array used for masking temperature grid

    real(dp),dimension(:,:),pointer :: thck => null()
    !*FD The thickness of the ice, divided by \texttt{thk0}.

    real(dp),dimension(:,:),pointer :: usrf => null()
    !*FD The elevation of the upper ice surface, divided by \texttt{thk0}.

    real(dp),dimension(:,:),pointer :: lsrf => null() 
    !*FD The elevation of the lower ice surface, divided by \texttt{thk0}.

    real(dp),dimension(:,:),pointer :: topg => null() 
    !*FD The elevation of the topography, divided by \texttt{thk0}.

    real(dp),dimension(:,:,:),pointer :: age => null()
    !*FD The age of a given ice layer, divided by \texttt{tim0}.

    integer, dimension(:,:),pointer :: mask => null()
    !*FD Set to zero for all points where $\mathtt{thck}=0$, otherwise non-zero.
    !*FD the non-zero points are numbered in sequence from the bottom left to the 
    !*FD top right, going along the rows.

    integer, dimension(:,:),pointer :: thkmask => null()
    !*FD see glide_mask.f90 for possible values

    real(dp),dimension(:,:),pointer :: marine_bc_normal => null()
    !*FD NaN for all points except those that occur on the marine
    !*FD margin of an ice shelf, in which case contains the angle
    !*FD of the normal to the ice front. 

    integer :: totpts = 0
    !*FD The total number of points with non-zero thickness

    integer, dimension(4) :: dom   = 0      !*FD I have no idea what this is for.
    logical               :: empty = .true. !*FD I have no idea what this is for.

    real(dp) :: ivol, iarea,iareag, iareaf !*FD ice volume and ice area

  end type glide_geometry

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_geomderv

    !*FD Holds the horizontal and temporal derivatives of the thickness and
    !*FD upper surface elevation, as well as the thickness on the staggered grid.

    !*tb* Added a bunch of stuff here to clean up the higher order code that
    !I've been writing.  Might be worth it to add a mechanism to conditionally
    !allocate these depending on whether they are needed by the SIA core or by
    !the higher-order extensions

    !First derivatives on a staggered grid
    real(dp),dimension(:,:),pointer :: dthckdew => null() !*FD E-W derivative of thickness.
    real(dp),dimension(:,:),pointer :: dusrfdew => null() !*FD E-W derivative of upper surface elevation.
    real(dp),dimension(:,:),pointer :: dthckdns => null() !*FD N-S derivative of thickness.
    real(dp),dimension(:,:),pointer :: dusrfdns => null() !*FD N-S derivative of upper surface elevation.
    real(dp),dimension(:,:),pointer :: dlsrfdew => null() !*tb* added
    real(dp),dimension(:,:),pointer :: dlsrfdns => null() !*tb* added

    !Second derivatives on a staggered grid
    !*tb* added all of these
    real(dp),dimension(:,:),pointer :: d2usrfdew2 => null()
    real(dp),dimension(:,:),pointer :: d2usrfdns2 => null()
    real(dp),dimension(:,:),pointer :: d2thckdew2 => null()
    real(dp),dimension(:,:),pointer :: d2thckdns2 => null()

    !First derivatives on a nonstaggered grid
    !*tb* added all of these
    real(dp),dimension(:,:),pointer :: dthckdew_unstag => null() !*FD E-W derivative of thickness.
    real(dp),dimension(:,:),pointer :: dusrfdew_unstag => null() !*FD E-W derivative of upper surface elevation.
    real(dp),dimension(:,:),pointer :: dthckdns_unstag => null() !*FD N-S derivative of thickness.
    real(dp),dimension(:,:),pointer :: dusrfdns_unstag => null() !*FD N-S derivative of upper surface elevation.
    real(dp),dimension(:,:),pointer :: dlsrfdew_unstag => null()
    real(dp),dimension(:,:),pointer :: dlsrfdns_unstag => null()

    !Second derivatives on a nonstaggered grid
    !*tb* added all of these
    real(dp),dimension(:,:),pointer :: d2usrfdew2_unstag => null()
    real(dp),dimension(:,:),pointer :: d2usrfdns2_unstag => null()
    real(dp),dimension(:,:),pointer :: d2thckdew2_unstag => null()
    real(dp),dimension(:,:),pointer :: d2thckdns2_unstag => null()


    !Time derivatives
    real(dp),dimension(:,:),pointer :: dthckdtm => null() !*FD Temporal derivative of thickness.
    real(dp),dimension(:,:),pointer :: dusrfdtm => null() !*FD Temporal derivative of upper surface elevation.

    !Staggered grid versions of geometry variables
    real(dp),dimension(:,:),pointer :: stagthck => null() !*FD Thickness averaged onto the staggered grid.

    !*tb* added everything below
    real(dp),dimension(:,:),pointer :: stagusrf => null() !*FD Upper surface averaged onto the staggered grid
    real(dp),dimension(:,:),pointer :: staglsrf => null() !*FD Lower surface averaged onto the staggered grid
    real(dp),dimension(:,:),pointer :: stagtopg => null() !*FD Bedrock topography averaged onto the staggered grid
  end type glide_geomderv

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_velocity

    !*FD Holds the velocity fields in 2D and 3D. At least some of these fields
    !*FD are stored on the displaced grid.

    real(dp),dimension(:,:,:),pointer :: uvel  => null() !*FD 3D $x$-velocity.
    real(dp),dimension(:,:,:),pointer :: vvel  => null() !*FD 3D $y$-velocity.
    real(dp),dimension(:,:,:),pointer :: wvel  => null() !*FD 3D $z$-velocity.
    real(dp),dimension(:,:,:),pointer :: wgrd  => null() !*FD 3D grid vertical velocity.
    real(dp),dimension(:,:,:),pointer :: surfvel => null() !Surface velocity
    real(dp),dimension(:,:)  ,pointer :: uflx  => null() !*FD 
    real(dp),dimension(:,:)  ,pointer :: vflx  => null() !*FD 
    real(dp),dimension(:,:)  ,pointer :: diffu => null() !*FD 
    real(dp),dimension(:,:)  ,pointer :: total_diffu => null() !*FD total diffusivity
    real(dp),dimension(:,:)  ,pointer :: ubas  => null() !*FD 
    real(dp),dimension(:,:)  ,pointer :: ubas_tavg  => null()
    real(dp),dimension(:,:)  ,pointer :: vbas  => null() !*FD 
    real(dp),dimension(:,:)  ,pointer :: vbas_tavg  => null() 
    real(dp),dimension(:,:)  ,pointer :: bed_softness => null() !*FD bed softness parameter
    real(dp),dimension(:,:)  ,pointer :: btrc  => null() !*FD  basal traction
    real(dp),dimension(:,:)  ,pointer :: tau_x => null() !*FD basal shear stress, x-dir
    real(dp),dimension(:,:)  ,pointer :: tau_y => null() !*FD basal shear stress, y-dir
  end type glide_velocity

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_tensor
    real(dp), dimension(:,:,:), pointer :: scalar => null()
    real(dp), dimension(:,:,:), pointer :: xz => null()
    real(dp), dimension(:,:,:), pointer :: yz => null()
    real(dp), dimension(:,:,:), pointer :: xx => null()
    real(dp), dimension(:,:,:), pointer :: yy => null()
    real(dp), dimension(:,:,:), pointer :: xy => null()
  end type glide_tensor
  
  type glide_velocity_hom
    !*FD Holds velocity fields in 2D and 3D as computed by the Pattyn higher
    !*FD order model.  At least some of these fields are stored on the
    !*FD displaced grid.
    
    real(dp),dimension(:,:,:),pointer   :: uvel  => null() !*FD 3D $x$-velocity.
    real(dp),dimension(:,:,:),pointer   :: vvel  => null() !*FD 3D $y$-velocity.
    real(dp),dimension(:,:,:),pointer   :: wvel  => null() !*FD 3D $z$-velocity.
    real(dp),dimension(:,:,:),pointer   :: velnorm => null()
    
    real(dp),dimension(:,:,:),pointer   :: wgrd  => null() !*FD 3D grid vertical velocity.
    
    real(dp),dimension(:,:)  ,pointer   :: uflx  => null() !*FD     ! *sfp** changed this from 3d to 2d array 
    real(dp),dimension(:,:)  ,pointer   :: vflx  => null() !*FD     ! *sfp** changed this from 3d to 2d array 
    real(dp),dimension(:,:)  ,pointer   :: diffu_x => null() !*FD 
    real(dp),dimension(:,:)  ,pointer   :: diffu_y => null()
    real(dp),dimension(:,:)  ,pointer   :: total_diffu => null() !*FD total diffusivity
    real(dp),dimension(:,:)  ,pointer   :: beta  => null() !*FD basal shear coefficient
    real(dp),dimension(:,:,:),pointer :: btraction => null() !*FD x-dir (1,:,:) and y-dir (2,:,:) "consistent" basal 
                                                             !*FD traction fields (calculated from matrix coeffs) 
    type(glide_tensor)                  :: tau
    real(dp),dimension(:,:,:)  ,pointer :: gdsx => null() !*FD basal shear stress, x-dir
    real(dp),dimension(:,:,:)  ,pointer :: gdsy => null() !*FD basal shear stress, y-dir
    real(dp),dimension(:,:,:),pointer   :: efvs => null()
    integer, dimension(:,:)  ,pointer   :: velmask => null()
    !*FD A mask similar to glide_geometry%mask, but on the velocity grid instead of the
    !*FD ice grid.  This is to aid in converging higher-order velocities
    logical :: is_velocity_valid = .false. !*FD True if uvel, vvel contains a HOM-computed velocity (and thus is valid as initial guess)
    
    !*FD A mask that specifies where the velocity being read in should be held constant as a dirichlet condition
    integer, dimension(:,:), pointer    :: kinbcmask => null()
    integer, dimension(:,:), pointer    :: dynbcmask => null()
  end type glide_velocity_hom

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_climate
     !*FD Holds fields used to drive the model
     real(sp),dimension(:,:),pointer :: acab     => null() !*FD Annual mass balance.
     real(sp),dimension(:,:),pointer :: acab_tavg     => null() !*FD Annual mass balance (time average).
     real(sp),dimension(:,:),pointer :: artm     => null() !*FD Annual mean air temperature
     real(sp),dimension(:,:),pointer :: lati     => null() !*FD Latitudes of model grid points
     real(sp),dimension(:,:),pointer :: loni     => null() !*FD Longitudes of model grid points
     real(sp),dimension(:,:),pointer :: calving  => null() !*FD Calving flux (scaled as mass balance, thickness, etc)
     real(sp) :: eus = 0.                                  !*FD eustatic sea level
     real(sp),dimension(:,:),pointer :: backstress => null() !*FD Back stress field for use with the 
                                                             !*FD Van der veen grounding line scheme
     logical, dimension(:,:),pointer :: backstressmap => null() !*FD map of the backstress on the first time step
     real(sp) :: stressin = 0.92                                
     real(sp) :: stressout = 0.80
     real(sp) :: slidconst = 0.0
     real(sp) :: tempanmly                                  !*FD Temperature anomaly 
  end type glide_climate

  type glide_temper

    !*FD Holds fields relating to temperature.
    !whl - In standard Glide, temp and flwa live on the unstaggered vertical grid
    !      at layer interfaces.  But if whichtemp = 3 (remapping advection of 
    !      temperature), temp and flwa live on the staggered vertical grid, 
    !      at layer midpoints.
    !whl - added some heat flux terms: bfricflx, ucondflx, lcondflx, dissipcol
    !      Note: bheatflx, ucondflx, and lcondflx are defined as positive down,
    !            so they will generally be < 0.  
    !      However, bfricflx and dissipcol are defined to be >= 0.
    real(dp),dimension(:,:,:),pointer :: temp => null() !*FD 3D temperature field.
    real(dp),dimension(:,:),  pointer :: bheatflx => null() !*FD basal heat flux (geothermal)
    real(dp),dimension(:,:,:),pointer :: flwa => null() !*FD Glenn's $A$.
    real(dp),dimension(:,:),  pointer :: bwat => null() !*FD Basal water depth
    real(dp),dimension(:,:),  pointer :: bwatflx => null() !*FD Basal water flux 
    real(dp),dimension(:,:),  pointer :: stagbwat => null() !*FD Basal water depth in velo grid
    real(dp),dimension(:,:),  pointer :: bmlt => null() !*FD Basal melt-rate
    real(dp),dimension(:,:),  pointer :: bmlt_tavg => null() !*FD Basal melt-rate
    !EIB! present in gc2, not sure if still needed
    real(dp),dimension(:,:),  pointer :: stagbtemp => null() !*FD Basal temperature on velo grid
    real(dp),dimension(:,:),  pointer :: bpmp => null() !*FD Basal pressure melting point
    real(dp),dimension(:,:),  pointer :: stagbpmp => null() !*FD Basal pressure melting point on velo grid
    !EIB!
    real(dp),dimension(:,:),  pointer :: bfricflx => null() !*FD basal heat flux from friction
    real(dp),dimension(:,:),  pointer :: ucondflx => null() !*FD conductive heat flux at upper sfc
    real(dp),dimension(:,:),  pointer :: lcondflx => null() !*FD conductive heat flux at lower sfc
    real(dp),dimension(:,:),  pointer :: dissipcol => null() !*FD total heat dissipation in column
    
    integer  :: niter   = 0      !*FD
    real(sp) :: perturb = 0.0    !*FD
    real(sp) :: grid    = 0.0    !*FD
    integer  :: tpt     = 0      !*FD Pointer to time series data
    logical  :: first1  = .true. !*FD
    logical  :: newtemps = .false. !*FD new temperatures
  end type glide_temper

  type glide_lithot_type
     !*FD holds variables for temperature calculations in the lithosphere

     real(dp),dimension(:,:,:),pointer :: temp => null()    !*FD Three-dimensional temperature field.
     logical, dimension(:,:), pointer :: mask => null()     !*FD whether the point has been ice covered at some time

     integer :: num_dim = 1                                 !*FD either 1 or 3 for 1D/3D calculations

     ! The sparse matrix and linearised arrays
     type(sparse_matrix_type) :: fd_coeff, fd_coeff_slap
     integer :: all_bar_top
     real(dp), dimension(:), pointer :: rhs
     real(dp), dimension(:), pointer :: answer
     real(dp), dimension(:), pointer :: supd,diag,subd

     ! work arrays for solver
     real(dp), dimension(:), pointer :: rwork
     integer, dimension(:), pointer :: iwork
     integer mxnelt

     real(dp), dimension(:), pointer :: deltaz => null()    !*FD array holding grid spacing in z
     real(dp), dimension(:,:), pointer :: zfactors => null()!*FD array holding factors for finite differences of vertical diffu
     real(dp) :: xfactor,yfactor !*FD factors for finite differences of horizontal diffu


     real :: surft = 2.         !*FD surface temperature, used for calculating initial temperature distribution
     real :: mart  = 2.         !*FD sea floor temperature 
     integer :: nlayer = 20     !*FD number of layers in lithosphere
     real :: rock_base = -5000. !*FD depth below sea-level at which geothermal heat gradient is applied
     
     integer :: numt = 0        !*FD number time steps for spinning up GTHF calculations

     real(dp) :: rho_r = 3300.0d0 !*FD The density of lithosphere (kg m$^{-3}$)
     real(dp) :: shc_r = 1000.0d0 !*FD specific heat capcity of lithosphere (J kg$^{-1}$ K$^{-1}$)
     real(dp) :: con_r = 3.3d0    !*FD thermal conductivity of lithosphere (W m$^{-1}$ K$^{-1}$)

     real(dp) :: diffu = 0. !*FD diffusion coefficient

  end type glide_lithot_type

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_funits
    character(fname_length) :: sigfile=''                      !*FD sigma coordinates file
    character(fname_length) :: ncfile=''                       !*FD configuration file for netCDF I/O
    type(glimmer_nc_output),pointer :: out_first=>NULL()       !*FD first element of linked list defining netCDF outputs
    type(glimmer_nc_input), pointer :: in_first=>NULL()        !*FD first element of linked list defining netCDF inputs
  end type glide_funits

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_numerics

    !*FD Parameters relating to the model numerics.
    real(sp) :: tstart = 0.0      !*FD starting time
    real(sp) :: tend   = 20000.0  !*FD end time
    real(sp) :: time   =    0.0   !*FD main loop counter in years
    real(sp) :: tinc   =   20.0   !*FD time step of main loop in years 
    real(sp) :: ntem   =    1.0   !*FD temperature time step (multiplier of main time step)
    real(sp) :: nvel   =    1.0   !*FD velocity time step (multiplier of main time step)
    real(dp) :: alpha  =    0.5d0 !*FD richard suggests 1.5 - was a parameter in original
    real(dp) :: alphas =    0.5d0 !*FD was a parameter in the original
    real(dp) :: thklim =  100.0   
    real(dp) :: mlimit = -200.0d0
    real(dp) :: calving_fraction = 0.8d0
    real(dp) :: dew    =   20.0d3
    real(dp) :: dns    =   20.0d3
    real(dp) :: dt     =    0.0
    real(dp) :: dttem  =    0.0
    real(sp) :: nshlf  =    0.0

    integer  :: timecounter = 0   !*FD count time steps
    
    ! Vertical coordinate ---------------------------------------------------
                                                               
    real(dp),dimension(:),pointer :: sigma => null() !*FD Sigma values for vertical spacing of 
                                                     !*FD model levels
    real(dp),dimension(:),pointer :: stagsigma => null() !*FD Staggered values of sigma (layer midpts)

    integer :: profile_period = 100            !*FD profile frequency
    integer :: ndiag = 9999999                 !*FD diagnostic frequency
    integer :: idiag = 1                       !*FD grid indices for diagnostic point
    integer :: jdiag = 1
  end type glide_numerics

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ! variables for tracking the grounding line    
  type glide_grnd
    real(dp),dimension(:,:),pointer :: gl_ew => null()
    real(dp),dimension(:,:),pointer :: gl_ns => null()
    real(dp),dimension(:,:),pointer :: gline_flux => null() !*FD flux at the
                                                            !grounding line
  end type glide_grnd

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_velowk
    real(dp),dimension(:),  pointer :: depth    => null()
    real(dp),dimension(:),  pointer :: dupsw    => null()
    real(dp),dimension(:),  pointer :: depthw   => null()
    real(dp),dimension(:),  pointer :: suvel    => null()
    real(dp),dimension(:),  pointer :: svvel    => null()
    real(dp),dimension(:,:),pointer :: fslip    => null()
    real(dp),dimension(:,:),pointer :: dintflwa => null()
    real(dp),dimension(:),  pointer :: dups     => null()
    real(dp),dimension(4) :: fact
    real(dp),dimension(4) :: c    = 0.0
    real(dp) :: watwd  = 3.0d0
    real(dp) :: watct  = 10.0d0
    real(dp) :: trc0   = 0.0
    real(dp) :: trcmin = 0.0d0
    real(dp) :: marine = 1.0d0
    real(dp) :: trcmax = 10.0d0
    real(dp) :: btrac_const = 0.0d0
    real(dp) :: btrac_slope = 0.0d0
    real(dp) :: btrac_max = 0.d0
  end type glide_velowk

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_pcgdwk
    type(sparse_matrix_type) :: matrix
   
    real(dp),dimension(:),pointer :: rhsd    => null()
    real(dp),dimension(:),pointer :: answ    => null()
    real(dp),dimension(4)         :: fc      = 0.0
    real(dp),dimension(6)         :: fc2     = 0.0
    integer :: ct     = 0
  end type glide_pcgdwk

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_thckwk
     real(dp),dimension(:,:),  pointer :: oldthck   => null()
     real(dp),dimension(:,:),  pointer :: oldthck2  => null()
     real(dp),dimension(:,:),pointer :: float => null()
     real(dp),dimension(:,:,:),pointer :: olds      => null()
     integer  :: nwhich  = 2
     real(sp) :: oldtime = 0.0
     
     real(dp), dimension(:), pointer :: alpha => null()
     real(dp), dimension(:), pointer :: beta  => null()
     real(dp), dimension(:), pointer :: gamma => null()
     real(dp), dimension(:), pointer :: delta => null()

  end type glide_thckwk

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_tempwk
    real(dp),dimension(:,:,:),pointer :: inittemp => null()
    real(dp),dimension(:,:,:),pointer :: dissip   => null()
    real(dp),dimension(:,:,:),pointer :: compheat => null()
    real(dp),dimension(:,:,:),pointer :: initadvt => null()
    real(dp),dimension(:),    pointer :: dupa     => null()
    real(dp),dimension(:),    pointer :: dupb     => null()
    real(dp),dimension(:),    pointer :: dupc     => null()
    real(dp),dimension(:),    pointer :: c1       => null()
    real(dp),dimension(:,:),  pointer :: dups     => null()
    real(dp),dimension(:,:),  pointer :: wphi     => null()
    real(dp),dimension(:,:),  pointer :: bwatu    => null()
    real(dp),dimension(:,:),  pointer :: bwatv    => null()
    real(dp),dimension(:,:),  pointer :: fluxew   => null()
    real(dp),dimension(:,:),  pointer :: fluxns   => null()
    real(dp),dimension(:,:),  pointer :: bint     => null()
    real(dp),dimension(:,:),  pointer :: smth     => null()
    real(dp),dimension(:,:,:),pointer :: hadv_u   => null()
    real(dp),dimension(:,:,:),pointer :: hadv_v   => null()
    !*sfp** added space to the next 2 (cons, f) for use w/ HO and SSA dissip. calc. 
    real(dp),dimension(5)             :: cons     = 0.0
    real(dp),dimension(5)             :: f        = 0.0
    real(dp),dimension(8)             :: c        = 0.0
    real(dp),dimension(2)             :: slide_f
    real(dp) :: noflow      = -1
    real(dp),dimension(2) :: advconst = 0.0
    real(dp) :: zbed        = 0.0
    real(dp) :: dupn        = 0.0
    real(dp) :: wmax        = 0.0
    real(dp) :: dt_wat      = 0.0
    real(dp) :: watvel      = 0.0
    integer  :: nwat        = 0
  end type glide_tempwk

  type glide_gridwk 
  !*FD Various grid quantities needed for remapping scheme 
    real(dp),dimension(:,:),pointer :: hte    => null() 
    real(dp),dimension(:,:),pointer :: htn    => null() 
    real(dp),dimension(:,:),pointer :: dxt    => null() 
    real(dp),dimension(:,:),pointer :: dyt    => null() 
    real(dp),dimension(:,:),pointer :: tarea  => null() 
    real(dp),dimension(:,:),pointer :: tarear => null() 
    real(dp),dimension(:,:),pointer :: mask   => null() 
    real(dp),dimension(:,:),pointer :: xav    => null() 
    real(dp),dimension(:,:),pointer :: yav    => null() 
    real(dp),dimension(:,:),pointer :: xxav   => null() 
    real(dp),dimension(:,:),pointer :: xyav   => null() 
    real(dp),dimension(:,:),pointer :: yyav   => null() 
  end type glide_gridwk

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_paramets
    real(dp),dimension(5) :: bpar = (/ 0.2d0, 0.5d0, 0.0d0 ,1.0d-2, 1.0d0/)
    real(dp) :: btrac_const = 0.d0 ! m yr^{-1} Pa^{-1} (gets scaled during init)
    real(dp) :: btrac_slope = 0.0d0 ! Pa^{-1} (gets scaled during init)
    real(dp) :: btrac_max = 0.d0  !  m yr^{-1} Pa^{-1} (gets scaled during init)
    real(dp) :: geot   = -5.0d-2  ! W m^{-2}
    real(dp) :: flow_factor = 3.0d0   ! "fiddle" parameter for the Arrhenius relationship
    real(dp) :: slip_ratio = 1.0d0 ! Slip ratio, used only in higher order code when the slip ratio beta computation is requested
    real(dp) :: hydtim = 1000.0d0 ! yr^{-1} converted to s^{-1} and scaled, 
                                  ! 0 if no drainage = 0.0d0 * tim0 / scyr
    real(dp) :: bwat_smooth = 0.01d0 ! basal water field smoothing strength
    real(dp) :: default_flwa = 1.0d-16 !Glen's A to use in isothermal case (would change to e.g. 4.6e-18 in EISMINT-ROSS case)
  end type glide_paramets

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_basalproc
    !Tuneables, set in the config file 
    real (kind = dp):: fric=0.45d0                   ! Till coeff of internal friction: ND
    real (kind = dp):: etillo=0.7d0                  ! Till void ratio at No
    real (kind = dp):: No=1000.d0                    ! Reference value of till effective stress
    real (kind = dp):: Comp=0.12d0                   ! Till coeff of compressibility: ND
    real (kind = dp):: Cv = 1.0d-8                   ! Till hydraulic diffusivity: m2/s
    real (kind = dp):: Kh = 1.0d-10                  !Till hydraulic conductivity: m/s
    real (kind = dp):: Zs = 3.0d0                    ! Solid till thickness: m
    real (kind = dp):: aconst=994000000d0            ! Constant in till strength eq. (Pa)
    real (kind = dp):: bconst=21.7                   ! Constant in till strength eq. (ND)
    integer:: till_hot = 0
    integer:: tnodes = 5

    real(dp), dimension (:) , pointer :: till_dz => null()  !holds inital till layer spacing - 
    
    !Model variables that will be passed to other subroutines
    real(dp),dimension(:,:)  ,pointer :: minTauf => null() !Bed strength calculated with basal proc. mod.
    real(dp),dimension(:,:)  ,pointer :: Hwater  => null() !Water available from till layer (m)
    !Model variabled necessary for hotstart
    real(dp),dimension(:,:,:)  ,pointer :: u => null()     !Till excess pore pressure (Pa)
    real(dp),dimension(:,:,:)  ,pointer :: etill  => null()  !Till void ratio (ND)  
    
  end type glide_basalproc

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  type glide_prof_type
     integer :: geomderv
     integer :: hvelos
     integer :: ice_mask1
     integer :: temperature
     integer :: ice_evo
     integer :: ice_mask2
     integer :: isos_water
     integer :: isos
  end type glide_prof_type
  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  type glide_phaml
    real(dp),dimension(:,:),pointer :: uphaml => null()
    real(dp),dimension(:,:),pointer :: init_phaml => null()
    real(dp),dimension(:,:),pointer :: rs_phaml => null()
    !maybe put the x/y vectors here too just for simplicity
  end type glide_phaml
  
  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  type glide_global_type
    integer              :: model_id !*FD Used in the global model list for error handling purposes
    type(glide_general)  :: general
    type(glide_options)  :: options
    type(glide_geometry) :: geometry
    type(glide_geomderv) :: geomderv
    type(glide_velocity) :: velocity
    type(glide_velocity_hom) :: velocity_hom
    type(glide_climate)  :: climate
    type(glide_temper)   :: temper
    type(glide_lithot_type) :: lithot
    type(glide_funits)   :: funits
    type(glide_numerics) :: numerics
    type(glide_velowk)   :: velowk
    type(glide_pcgdwk)   :: pcgdwk
    type(glide_thckwk)   :: thckwk
    type(glide_tempwk)   :: tempwk
    type(glide_gridwk)   :: gridwk
    type(glide_paramets) :: paramets
    type(glimmap_proj)   :: projection
    type(glide_basalproc):: basalproc
    type(profile_type)   :: profile
    type(glide_prof_type) :: glide_prof
    type(isos_type)      :: isos
    type(glide_phaml)    :: phaml
    type(glide_grnd)     :: ground
    
    type(remap_glamutils_workspace) :: remap_wk

  end type glide_global_type

contains

  subroutine glide_allocarr(model)
    
    !*FD Allocates the model arrays, and initialises some of them to zero.
    !*FD These are the arrays allocated, and their dimensions:
    !*FD
    !*FD In \texttt{model\%temper}:
    !*FD \begin{itemize}
    !*FD \item \texttt{temp(upn,0:ewn+1,0:nsn+1))}
    !*FD \item \texttt{bheatflx(ewn,nsn))}
    !*FD \item \texttt{flwa(upn,ewn,nsn))}
    !*FD \item \texttt{bwat(ewn,nsn))}
    !*FD \item \texttt{bmlt(ewn,nsn))}
    !*FD \item \texttt{bfricflx(ewn,nsn))}
    !*FD \item \texttt{ucondflx(ewn,nsn))}
    !*FD \item \texttt{lcondflx(ewn,nsn))}
    !*FD \item \texttt{dissipcol(ewn,nsn))}
    !*FD \end{itemize}

    !*FD In \texttt{model\%velocity}:
    !*FD \begin{itemize}
    !*FD \item \texttt{uvel(upn,ewn-1,nsn-1))}
    !*FD \item \texttt{vvel(upn,ewn-1,nsn-1))}
    !*FD \item \texttt{wvel(upn,ewn,nsn))}
    !*FD \item \texttt{wgrd(upn,ewn,nsn))}
    !*FD \item \texttt{uflx(ewn-1,nsn-1))}
    !*FD \item \texttt{vflx(ewn-1,nsn-1))}
    !*FD \item \texttt{diffu(ewn,nsn))}
    !*FD \item \texttt{btrc(ewn,nsn))}
    !*FD \item \texttt{ubas(ewn,nsn))}
    !*FD \item \texttt{vbas(ewn,nsn))}
    !*FD \end{itemize}

    !*FD In \texttt{model\%climate}:
    !*FD \begin{itemize}
    !*FD \item \texttt{acab(ewn,nsn))}
    !*FD \item \texttt{artm(ewn,nsn))}
    !*FD \item \texttt{lati(ewn,nsn))}
    !*FD \item \texttt{loni(ewn,nsn))}
    !*FD \end{itemize}

    !*FD In \texttt{model\%geomderv}:
    !*FD \begin{itemize}
    !*FD \item \texttt{dthckdew(ewn,nsn))}
    !*FD \item \texttt{dusrfdew(ewn,nsn))}
    !*FD \item \texttt{dthckdns(ewn,nsn))}
    !*FD \item \texttt{dusrfdns(ewn,nsn))}
    !*FD \item \texttt{dthckdtm(ewn,nsn))}
    !*FD \item \texttt{dusrfdtm(ewn,nsn))}
    !*FD \item \texttt{stagthck(ewn-1,nsn-1))}
    !*FD \end{itemize}
  
    !*FD In \texttt{model\%geometry}:
    !*FD \begin{itemize}
    !*FD \item \texttt{thck(ewn,nsn))}
    !*FD \item \texttt{usrf(ewn,nsn))}
    !*FD \item \texttt{lsrf(ewn,nsn))}
    !*FD \item \texttt{topg(ewn,nsn))}
    !*FD \item \texttt{mask(ewn,nsn))}
    !*FD \item \texttt{age(ewn,nsn))}
    !*FD \end{itemize}

    !*FD In \texttt{model\%thckwk}:
    !*FD \begin{itemize}
    !*FD \item \texttt{olds(ewn,nsn,thckwk\%nwhich))}
    !*FD \end{itemize}

    !*FD In \texttt{model\%numerics}:
    !*FD \begin{itemize}
    !*FD \item \texttt{sigma(upn))}
    !*FD \end{itemize}

    !*FD In \texttt{model\%numerics}:
    !*FD \begin{itemize}
    !*FD \item \texttt{stagsigma(upn-1))}
    !*FD \end{itemize}

    use glimmer_log

    implicit none

    type(glide_global_type),intent(inout) :: model

    integer :: ewn,nsn,upn

    ! for simplicity, copy these values...

    ewn=model%general%ewn
    nsn=model%general%nsn
    upn=model%general%upn
    
    ! Allocate appropriately

    allocate(model%general%x0(ewn-1))!; model%general%x0 = 0.0
    allocate(model%general%y0(nsn-1))!; model%general%y0 = 0.0
    allocate(model%general%x1(ewn))!; model%general%x1 = 0.0
    allocate(model%general%y1(nsn))!; model%general%y1 = 0.0
    call coordsystem_allocate(model%general%ice_grid, model%temper%bheatflx)
    call coordsystem_allocate(model%general%ice_grid, model%temper%bwat)
    call coordsystem_allocate(model%general%ice_grid, model%temper%bwatflx)
    call coordsystem_allocate(model%general%velo_grid, model%temper%stagbwat)
    call coordsystem_allocate(model%general%ice_grid, model%temper%bmlt)
    call coordsystem_allocate(model%general%ice_grid, model%temper%bmlt_tavg)
    !EIB! from gc2, not sure still needed
    call coordsystem_allocate(model%general%velo_grid, model%temper%stagbtemp)
    call coordsystem_allocate(model%general%ice_grid, model%temper%bpmp)
    call coordsystem_allocate(model%general%ice_grid, model%temper%bwatflx)
    call coordsystem_allocate(model%general%velo_grid, model%temper%stagbpmp)
    !EIB!
    call coordsystem_allocate(model%general%ice_grid, model%temper%bfricflx)
    call coordsystem_allocate(model%general%ice_grid, model%temper%ucondflx)
    call coordsystem_allocate(model%general%ice_grid, model%temper%lcondflx)
    call coordsystem_allocate(model%general%ice_grid, model%temper%dissipcol)

!whl - For whichtemp = TEMP_REMAP_ADV, temperature and flow factor live on the staggered
!      vertical grid.  In this case, temperature and flwa are defined at the
!      midpoint of each of layers 1:upn-1.  The temperature (but not flwa)
!      is defined at the upper surface (k = 0) and lower surface (k = upn).
!whl - Since there is no temperature advection in glide_temp, the extra rows and 
!      columns (0, ewn+1, nsn+1) in the horizontal are not needed.
    if (model%options%whichtemp == TEMP_REMAP_ADV) then
       allocate(model%temper%temp(0:upn,1:ewn,1:nsn)); model%temper%temp = 0.0
       call coordsystem_allocate(model%general%ice_grid, upn-1, model%temper%flwa)
    else
       allocate(model%temper%temp(upn,0:ewn+1,0:nsn+1)); model%temper%temp = 0.0
       call coordsystem_allocate(model%general%ice_grid, upn, model%temper%flwa)
    endif

    allocate(model%lithot%temp(1:ewn,1:nsn,model%lithot%nlayer)); model%lithot%temp = 0.0
    call coordsystem_allocate(model%general%ice_grid, model%lithot%mask)

    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity%uvel)
    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity%vvel)
    call coordsystem_allocate(model%general%ice_grid, upn, model%velocity%wvel)
    call coordsystem_allocate(model%general%ice_grid, upn, model%velocity%wgrd)
    call coordsystem_allocate(model%general%velo_grid,upn,model%velocity%surfvel)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%uflx)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%vflx)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%diffu)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%total_diffu)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%bed_softness)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%btrc)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%ubas)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%ubas_tavg)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%vbas)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%vbas_tavg)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%tau_x)
    call coordsystem_allocate(model%general%velo_grid, model%velocity%tau_y)

    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%uvel)
    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%vvel)
    call coordsystem_allocate(model%general%ice_grid, upn, model%velocity_hom%wvel)
    call coordsystem_allocate(model%general%ice_grid, upn, model%velocity_hom%wgrd)
    !*sfp** changed the next two (uflx, vflx) from 3d to 2d arrays
    call coordsystem_allocate(model%general%velo_grid, model%velocity_hom%uflx)
    call coordsystem_allocate(model%general%velo_grid, model%velocity_hom%vflx)
    call coordsystem_allocate(model%general%velo_grid, model%velocity_hom%diffu_x)
    call coordsystem_allocate(model%general%velo_grid, model%velocity_hom%diffu_y)
    call coordsystem_allocate(model%general%velo_grid, model%velocity_hom%total_diffu)
    call coordsystem_allocate(model%general%velo_grid, model%velocity_hom%beta)
    call coordsystem_allocate(model%general%velo_grid, 2, model%velocity_hom%btraction)

! *sfp* changing dims of stress tensor arrays to be consistent with those expected by PP core 
!    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%tau%scalar)
!    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%tau%xz)
!    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%tau%yz)
!    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%tau%xx)
!    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%tau%yy)
!    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%tau%xy)
    call coordsystem_allocate(model%general%ice_grid, upn-1, model%velocity_hom%tau%scalar)
    call coordsystem_allocate(model%general%ice_grid, upn-1, model%velocity_hom%tau%xz)
    call coordsystem_allocate(model%general%ice_grid, upn-1, model%velocity_hom%tau%yz)
    call coordsystem_allocate(model%general%ice_grid, upn-1, model%velocity_hom%tau%xx)
    call coordsystem_allocate(model%general%ice_grid, upn-1, model%velocity_hom%tau%yy)
    call coordsystem_allocate(model%general%ice_grid, upn-1, model%velocity_hom%tau%xy)

    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%gdsx)
    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%gdsy)

! *sfp* changing dims of efvs array to be consistent with those expected by PP core 
!    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%efvs)
    call coordsystem_allocate(model%general%ice_grid, upn-1, model%velocity_hom%efvs)

    call coordsystem_allocate(model%general%velo_grid, model%velocity_hom%velmask)
    call coordsystem_allocate(model%general%velo_grid, upn, model%velocity_hom%velnorm)
    call coordsystem_allocate(model%general%velo_grid, model%velocity_hom%kinbcmask)
    call coordsystem_allocate(model%general%velo_grid, model%velocity_hom%dynbcmask)

    call coordsystem_allocate(model%general%ice_grid, model%climate%acab)
    call coordsystem_allocate(model%general%ice_grid, model%climate%acab_tavg)
    call coordsystem_allocate(model%general%ice_grid, model%climate%artm)
    call coordsystem_allocate(model%general%ice_grid, model%climate%lati)
    call coordsystem_allocate(model%general%ice_grid, model%climate%loni)
    call coordsystem_allocate(model%general%ice_grid, model%climate%calving)
    call coordsystem_allocate(model%general%ice_grid, model%climate%backstress)
    call coordsystem_allocate(model%general%ice_grid, model%climate%backstressmap)

    call coordsystem_allocate(model%general%velo_grid, model%geomderv%dthckdew)
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%dusrfdew)
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%dlsrfdew)    
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%dthckdns)
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%dusrfdns)
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%dlsrfdns)
    
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%d2usrfdew2)
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%d2usrfdns2)
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%d2thckdew2)
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%d2thckdns2)
    
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%dthckdew_unstag)
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%dusrfdew_unstag)
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%dlsrfdew_unstag)    
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%dthckdns_unstag)
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%dusrfdns_unstag)
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%dlsrfdns_unstag)
    
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%d2usrfdew2_unstag)
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%d2usrfdns2_unstag)
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%d2thckdew2_unstag)
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%d2thckdns2_unstag)

    call coordsystem_allocate(model%general%ice_grid, model%geomderv%dthckdtm)
    call coordsystem_allocate(model%general%ice_grid, model%geomderv%dusrfdtm)

    call coordsystem_allocate(model%general%velo_grid, model%geomderv%stagthck)
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%staglsrf)
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%stagusrf)
    call coordsystem_allocate(model%general%velo_grid, model%geomderv%stagtopg)
  
    call coordsystem_allocate(model%general%velo_grid, model%geometry%temporary0)
    call coordsystem_allocate(model%general%ice_grid, model%geometry%temporary1)
    call coordsystem_allocate(model%general%ice_grid, model%geometry%thck)
    call coordsystem_allocate(model%general%ice_grid, model%geometry%usrf)
    call coordsystem_allocate(model%general%ice_grid, model%geometry%lsrf)
    call coordsystem_allocate(model%general%ice_grid, model%geometry%topg)
    call coordsystem_allocate(model%general%ice_grid, upn, model%geometry%age)
    call coordsystem_allocate(model%general%ice_grid, model%geometry%mask)
    call coordsystem_allocate(model%general%ice_grid, model%geometry%thkmask)
    call coordsystem_allocate(model%general%ice_grid, model%geometry%marine_bc_normal)

    allocate(model%thckwk%olds(ewn,nsn,model%thckwk%nwhich))
    model%thckwk%olds = 0.0d0
    call coordsystem_allocate(model%general%ice_grid, model%thckwk%oldthck)
    call coordsystem_allocate(model%general%ice_grid, model%thckwk%oldthck2)
    call coordsystem_allocate(model%general%ice_grid, model%thckwk%float)

    ! If we already have sigma, don't reallocate
    if (associated(model%numerics%sigma)) then
       if (size(model%numerics%sigma)/=upn) then
          call write_log('Wrong number of sigma levels given',GM_FATAL)
       end if
    else
       allocate(model%numerics%sigma(upn))
    endif

    !whl - to do - might be useful to change to (0:upn)
    allocate(model%numerics%stagsigma(upn-1))
    ! allocate memory for grounding line
    allocate (model%ground%gl_ew(ewn-1,nsn))
    allocate (model%ground%gl_ns(ewn,nsn-1))
    allocate (model%ground%gline_flux(ewn,nsn)) 
    ! allocate memory for sparse matrix
    allocate (model%pcgdwk%rhsd(ewn*nsn))
    allocate (model%pcgdwk%answ(ewn*nsn))
    call new_sparse_matrix(ewn*nsn, 5*ewn*nsn, model%pcgdwk%matrix)

    ! allocate isostasy grids
    call isos_allocate(model%isos,ewn,nsn)

    !allocate phaml variables
    call coordsystem_allocate(model%general%ice_grid, model%phaml%init_phaml)
    call coordsystem_allocate(model%general%ice_grid, model%phaml%rs_phaml)
    call coordsystem_allocate(model%general%ice_grid, model%phaml%uphaml)
    ! allocate grid quantities for remapping scheme
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%hte) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%htn) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%dxt) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%dyt) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%tarea) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%tarear) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%mask) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%xav) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%yav) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%xxav) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%xyav) 
    call coordsystem_allocate(model%general%ice_grid, model%gridwk%yyav)

    !allocate basal processes variables
    call coordsystem_allocate(model%general%ice_grid, model%basalproc%Hwater)
    call coordsystem_allocate(model%general%velo_grid, model%basalproc%minTauf)
    allocate(model%basalproc%u (ewn-1,nsn-1,model%basalproc%tnodes)); model%basalproc%u=41.0d3
    allocate(model%basalproc%etill (ewn-1,nsn-1,model%basalproc%tnodes));model%basalproc%etill=0.5d0

  end subroutine glide_allocarr

  subroutine glide_deallocarr(model)
    !*FD deallocate model arrays
    implicit none
    type(glide_global_type),intent(inout) :: model

    deallocate(model%general%x0) 
    deallocate(model%general%y0) 
    deallocate(model%general%x1) 
    deallocate(model%general%y1) 

    deallocate(model%temper%temp)
    deallocate(model%temper%flwa)
    deallocate(model%temper%bheatflx)
    deallocate(model%temper%bwat)
    deallocate(model%temper%bwatflx)
    deallocate(model%temper%stagbwat)
    deallocate(model%temper%bmlt)
    deallocate(model%temper%bmlt_tavg)
    deallocate(model%temper%bfricflx)
    deallocate(model%temper%ucondflx)
    deallocate(model%temper%lcondflx)
    deallocate(model%temper%dissipcol)
    !EIB! allocated from gc2 portion
    deallocate(model%temper%stagbtemp)
    deallocate(model%temper%bpmp)
    deallocate(model%temper%stagbpmp)
    !EIB!
    deallocate(model%ground%gl_ns)
    deallocate(model%ground%gl_ew)
    deallocate(model%ground%gline_flux)

    deallocate(model%lithot%temp)
    deallocate(model%lithot%mask)

    deallocate(model%velocity%uvel)
    deallocate(model%velocity%vvel)
    deallocate(model%velocity%wvel)
    deallocate(model%velocity%wgrd)
    deallocate(model%velocity%surfvel)

    deallocate(model%velocity%uflx)
    deallocate(model%velocity%vflx)
    deallocate(model%velocity%diffu)
    deallocate(model%velocity%total_diffu)
    deallocate(model%velocity%bed_softness)
    deallocate(model%velocity%btrc)
    deallocate(model%velocity%ubas)
    deallocate(model%velocity%ubas_tavg)
    deallocate(model%velocity%vbas)
    deallocate(model%velocity%vbas_tavg)
    deallocate(model%velocity%tau_x)
    deallocate(model%velocity%tau_y)

    deallocate(model%velocity_hom%uvel)
    deallocate(model%velocity_hom%vvel)
    deallocate(model%velocity_hom%wvel)
    deallocate(model%velocity_hom%wgrd)
    deallocate(model%velocity_hom%uflx)
    deallocate(model%velocity_hom%vflx)
    deallocate(model%velocity_hom%diffu_x)
    deallocate(model%velocity_hom%diffu_y)
    deallocate(model%velocity_hom%total_diffu)
    deallocate(model%velocity_hom%beta)
    deallocate(model%velocity_hom%btraction)
    deallocate(model%velocity_hom%tau%scalar)
    deallocate(model%velocity_hom%tau%xz)
    deallocate(model%velocity_hom%tau%yz)
    deallocate(model%velocity_hom%tau%xx)
    deallocate(model%velocity_hom%tau%yy)
    deallocate(model%velocity_hom%tau%xy)
    deallocate(model%velocity_hom%gdsx)
    deallocate(model%velocity_hom%gdsy)
    deallocate(model%velocity_hom%efvs)
    deallocate(model%velocity_hom%velmask)
    deallocate(model%velocity_hom%velnorm)
    deallocate(model%velocity_hom%kinbcmask)
    deallocate(model%velocity_hom%dynbcmask)

    deallocate(model%climate%acab)
    deallocate(model%climate%acab_tavg)
    deallocate(model%climate%artm)
    deallocate(model%climate%lati)
    deallocate(model%climate%loni)
    deallocate(model%climate%backstress)
    deallocate(model%climate%backstressmap)

    deallocate(model%geomderv%dthckdew)
    deallocate(model%geomderv%dusrfdew)
    deallocate(model%geomderv%dlsrfdew)
    deallocate(model%geomderv%dthckdns)
    deallocate(model%geomderv%dusrfdns)
    deallocate(model%geomderv%dlsrfdns)

    deallocate(model%geomderv%d2usrfdew2)
    deallocate(model%geomderv%d2thckdew2)
    deallocate(model%geomderv%d2usrfdns2)
    deallocate(model%geomderv%d2thckdns2)

    deallocate(model%geomderv%dthckdew_unstag)
    deallocate(model%geomderv%dusrfdew_unstag)
    deallocate(model%geomderv%dlsrfdew_unstag)
    deallocate(model%geomderv%dthckdns_unstag)
    deallocate(model%geomderv%dusrfdns_unstag)
    deallocate(model%geomderv%dlsrfdns_unstag)

    deallocate(model%geomderv%d2usrfdew2_unstag)
    deallocate(model%geomderv%d2thckdew2_unstag)
    deallocate(model%geomderv%d2usrfdns2_unstag)
    deallocate(model%geomderv%d2thckdns2_unstag)

    deallocate(model%geomderv%dthckdtm)
    deallocate(model%geomderv%dusrfdtm)
    deallocate(model%geomderv%stagthck)
    deallocate(model%geomderv%stagusrf)
    deallocate(model%geomderv%staglsrf)
    deallocate(model%geomderv%stagtopg)

    deallocate(model%geometry%temporary0)
    deallocate(model%geometry%temporary1)
    deallocate(model%geometry%thck)
    deallocate(model%geometry%usrf)
    deallocate(model%geometry%lsrf)
    deallocate(model%geometry%topg)
    deallocate(model%geometry%age)
    deallocate(model%geometry%mask)
    deallocate(model%geometry%thkmask)
    deallocate(model%geometry%marine_bc_normal)

    deallocate(model%thckwk%olds)
    deallocate(model%thckwk%oldthck)
    deallocate(model%thckwk%oldthck2)
    deallocate(model%thckwk%float)
    deallocate(model%numerics%sigma)
    deallocate(model%numerics%stagsigma)
    
    !EIB! old
    !deallocate(model%pcgdwk%pcgrow,model%pcgdwk%pcgcol,model%pcgdwk%pcgval,model%pcgdwk%rhsd,model%pcgdwk%answ)
    !EIB! new
    deallocate(model%pcgdwk%rhsd,model%pcgdwk%answ)
    call del_sparse_matrix(model%pcgdwk%matrix)

    ! allocate isostasy grids
    call isos_deallocate(model%isos)

    !deallocate phaml variables
    deallocate(model%phaml%init_phaml)
    deallocate(model%phaml%rs_phaml)    
    deallocate(model%phaml%uphaml)
    ! deallocate grid quantities for remapping scheme
    deallocate(model%gridwk%hte) 
    deallocate(model%gridwk%htn) 
    deallocate(model%gridwk%dxt) 
    deallocate(model%gridwk%dyt) 
    deallocate(model%gridwk%tarea) 
    deallocate(model%gridwk%tarear) 
    deallocate(model%gridwk%mask) 
    deallocate(model%gridwk%xav) 
    deallocate(model%gridwk%yav) 
    deallocate(model%gridwk%xxav) 
    deallocate(model%gridwk%xyav) 
    deallocate(model%gridwk%yyav) 

    ! deallocate till variables
    deallocate(model%basalproc%Hwater)
    deallocate(model%basalproc%minTauf)
    deallocate(model%basalproc%u)
    deallocate(model%basalproc%etill)

  end subroutine glide_deallocarr

  ! some accessor functions
  function get_dew(model)
    !*FD return scaled x node spacing
    use glimmer_paramets, only : len0
    implicit none
    real(dp) :: get_dew
    type(glide_global_type) :: model

    get_dew = model%numerics%dew * len0
  end function get_dew

  function get_dns(model)
    !*FD return scaled y node spacing
    use glimmer_paramets, only : len0
    implicit none
    real(dp) :: get_dns
    type(glide_global_type) :: model

    get_dns = model%numerics%dns * len0
  end function get_dns

  function get_tstart(model)
    !*FD return start time
    implicit none
    real(sp) :: get_tstart
    type(glide_global_type) :: model
    
    get_tstart = model%numerics%tstart
  end function get_tstart

  function get_tend(model)
    !*FD return end time
    implicit none
    real(sp) :: get_tend
    type(glide_global_type) :: model
    
    get_tend = model%numerics%tend
  end function get_tend

  function get_tinc(model)
    !*FD return time increment
    implicit none
    real(sp) :: get_tinc
    type(glide_global_type) :: model
    
    get_tinc = model%numerics%tinc
  end function get_tinc

  function get_ewn(model)
    !*FD get number of nodes in x dir
    implicit none
    integer get_ewn
    type(glide_global_type) :: model

    get_ewn = model%general%ewn
  end function get_ewn

  function get_nsn(model)
    !*FD get number of nodes in y dir
    implicit none
    integer get_nsn
    type(glide_global_type) :: model

    get_nsn = model%general%nsn
  end function get_nsn
  
  subroutine set_time(model,time)
    !*FD Set the model time counter --- useful for
    !*FD fractional year output
    implicit none
    type(glide_global_type) :: model
    real :: time

    model%numerics%time=time
  end subroutine set_time

end module glide_types

