<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CICE: ice_transport_remap.F90 Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Types&nbsp;List</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>ice_transport_remap.F90</h1><a href="ice__transport__remap_8F90.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">!=======================================================================</span>
<a name="l00002"></a>00002 <span class="comment">!BOP</span>
<a name="l00003"></a>00003 <span class="comment">!</span>
<a name="l00004"></a>00004 <span class="comment">! !MODULE: ice_transport_remap - horizontal transport via incremental remapping</span>
<a name="l00005"></a>00005 <span class="comment">!</span>
<a name="l00006"></a>00006 <span class="comment">! !DESCRIPTION:</span>
<a name="l00007"></a>00007 <span class="comment">!</span>
<a name="l00008"></a>00008 <span class="comment">! Transports quantities using the second-order conservative remapping</span>
<a name="l00009"></a>00009 <span class="comment">! scheme developed by John Dukowicz and John Baumgardner (DB) and modified</span>
<a name="l00010"></a>00010 <span class="comment">! for sea ice by William Lipscomb and Elizabeth Hunke.</span>
<a name="l00011"></a>00011 <span class="comment">!</span>
<a name="l00012"></a>00012 <span class="comment">! References:</span>
<a name="l00013"></a>00013 <span class="comment">!</span>
<a name="l00014"></a>00014 <span class="comment">! Dukowicz, J. K., and J. R. Baumgardner, 2000: Incremental</span>
<a name="l00015"></a>00015 <span class="comment">!  remapping as a transport/advection algorithm, J. Comput. Phys.,</span>
<a name="l00016"></a>00016 <span class="comment">!  160, 318-335.</span>
<a name="l00017"></a>00017 <span class="comment">!</span>
<a name="l00018"></a>00018 <span class="comment">! Lipscomb, W. H., and E. C. Hunke, 2004: Modeling sea ice</span>
<a name="l00019"></a>00019 <span class="comment">!  transport using incremental remapping, Mon. Wea. Rev., 132,</span>
<a name="l00020"></a>00020 <span class="comment">!  1341-1354.</span>
<a name="l00021"></a>00021 <span class="comment">!</span>
<a name="l00022"></a>00022 <span class="comment">! !REVISION HISTORY:</span>
<a name="l00023"></a>00023 <span class="comment">!  SVN:$Id: ice_transport_remap.F 33 2006-11-13 19:51:14Z eclare $</span>
<a name="l00024"></a>00024 <span class="comment">!</span>
<a name="l00025"></a>00025 <span class="comment">! authors William H. Lipscomb, LANL</span>
<a name="l00026"></a>00026 <span class="comment">!         John Baumgardner, LANL</span>
<a name="l00027"></a>00027 <span class="comment">!</span>
<a name="l00028"></a>00028 <span class="comment">! 2003: Vectorized by Clifford Chen (Fujitsu) and William Lipscomb</span>
<a name="l00029"></a>00029 <span class="comment">! 2004-05: Block structure added (WHL)</span>
<a name="l00030"></a>00030 <span class="comment">! 2006: Moved remap driver to ice_transport_driver</span>
<a name="l00031"></a>00031 <span class="comment">!       Geometry changes: </span>
<a name="l00032"></a>00032 <span class="comment">!       (1) Reconstruct fields in stretched logically rectangular coordinates</span>
<a name="l00033"></a>00033 <span class="comment">!       (2) Modify geometry so that the area flux across each edge</span>
<a name="l00034"></a>00034 <span class="comment">!           can be specified (following an idea of Mats Bentsen)</span>
<a name="l00035"></a>00035 <span class="comment">!</span>
<a name="l00036"></a>00036 <span class="comment">! !INTERFACE:</span>
<a name="l00037"></a>00037 <span class="comment">!</span>
<a name="l00038"></a><a class="code" href="namespaceice__transport__remap.html">00038</a>       <span class="keyword">module</span> ice_transport_remap
<a name="l00039"></a>00039 <span class="comment">!</span>
<a name="l00040"></a>00040 <span class="comment">! !USES:</span>
<a name="l00041"></a>00041 <span class="comment">!</span>
<a name="l00042"></a>00042       use <span class="keywordflow">ice_kinds_mod</span>
<a name="l00043"></a>00043       use <span class="keywordflow">ice_communicate</span>, only: my_task, master_task, MPI_COMM_ICE
<a name="l00044"></a>00044       use <span class="keywordflow">ice_domain_size</span>
<a name="l00045"></a>00045       use <span class="keywordflow">ice_constants</span>
<a name="l00046"></a>00046       use <span class="keywordflow">ice_fileunits</span>, only: nu_diag
<a name="l00047"></a>00047       use <span class="keywordflow">perf_mod</span>,      only: t_startf, t_stopf, t_barrierf
<a name="l00048"></a>00048 <span class="comment">!</span>
<a name="l00049"></a>00049 <span class="comment">!EOP</span>
<a name="l00050"></a>00050 <span class="comment">!</span>
<a name="l00051"></a>00051       <span class="keyword">implicit none</span>
<a name="l00052"></a>00052       <span class="keywordtype">save</span>
<a name="l00053"></a>00053       <span class="keywordtype">private</span>
<a name="l00054"></a>00054       <span class="keywordtype">public</span> :: <a class="code" href="namespaceice__transport__remap.html#ae1b446db8b6220961bfcacd0c9b57fd4">init_remap</a>, <a class="code" href="namespaceice__transport__remap.html#af549caf7a8f27fcbe1cc3d9f8df4bacd">horizontal_remap</a>, <a class="code" href="namespaceice__transport__remap.html#a9a9fe0af7f01eed20d6df09ed2e8dc2a">make_masks</a>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">! NOTE: It would be better to pass in ntrace as an argument, but this slows</span>
<a name="l00057"></a>00057 <span class="comment">!       down the code considerably, at least on mauve.</span>
<a name="l00058"></a>00058 <span class="comment">! NOTE: For remapping, hice, hsno, qice, and qsno are considered tracers.</span>
<a name="l00059"></a>00059 <span class="comment">!       ntrace is not equal to ntrcr!</span>
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="namespaceice__transport__remap.html#a5012cc594b512eddae2a80fd91132217">00061</a>       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">parameter</span> ::                      
<a name="l00062"></a>00062          ntrace = 2+ntrcr+nilyr+nslyr  <span class="comment">! hice,hsno,qice,qsno,trcr</span>
<a name="l00063"></a>00063                           
<a name="l00064"></a><a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">00064</a>       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">parameter</span> ::     
<a name="l00065"></a>00065          ngroups  = 6      ,<span class="comment">! number of groups of triangles that</span>
<a name="l00066"></a>00066                              <span class="comment">! contribute transports across each edge</span>
<a name="l00067"></a>00067          nvert = 3           <span class="comment">! number of vertices in a triangle</span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069       <span class="comment">! for triangle integral formulas</span>
<a name="l00070"></a><a class="code" href="namespaceice__transport__remap.html#a4571153ae2d02f5b5251863d6bdabc37">00070</a>       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">parameter</span> ::   
<a name="l00071"></a>00071          p5625m = -9._dbl_kind/16._dbl_kind    ,
<a name="l00072"></a>00072          p52083 = 25._dbl_kind/48._dbl_kind
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="namespaceice__transport__remap.html#a2ea16fe2f40b061e8beaf561ebf7524c">00074</a>       <span class="keywordtype">logical (kind=log_kind)</span>, <span class="keywordtype">parameter</span> :: bugcheck = .false.
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="comment">!=======================================================================</span>
<a name="l00077"></a>00077 <span class="comment">! Here is some information about how the incremental remapping scheme</span>
<a name="l00078"></a>00078 <span class="comment">! works in CICE and how it can be adapted for use in other models.  </span>
<a name="l00079"></a>00079 <span class="comment">!</span>
<a name="l00080"></a>00080 <span class="comment">! The remapping routine is designed to transport a generic mass-like </span>
<a name="l00081"></a>00081 <span class="comment">! field (in CICE, the ice fractional area) along with an arbitrary number</span>
<a name="l00082"></a>00082 <span class="comment">! of tracers in two dimensions.  The velocity components are assumed </span>
<a name="l00083"></a>00083 <span class="comment">! to lie at grid cell corners and the transported scalars at cell centers. </span>
<a name="l00084"></a>00084 <span class="comment">! Incremental remapping has the following desirable properties: </span>
<a name="l00085"></a>00085 <span class="comment">! </span>
<a name="l00086"></a>00086 <span class="comment">! (1) Tracer monotonicity is preserved.  That is, no new local </span>
<a name="l00087"></a>00087 <span class="comment">!     extrema are produced in fields like ice thickness or internal </span>
<a name="l00088"></a>00088 <span class="comment">!     energy. </span>
<a name="l00089"></a>00089 <span class="comment">! (2) The reconstucted mass and tracer fields vary linearly in x and y. </span>
<a name="l00090"></a>00090 <span class="comment">!     This means that remapping is 2nd-order accurate in space, </span>
<a name="l00091"></a>00091 <span class="comment">!     except where horizontal gradients are limited to preserve </span>
<a name="l00092"></a>00092 <span class="comment">!     monotonicity. </span>
<a name="l00093"></a>00093 <span class="comment">! (3) There are economies of scale.  Transporting a single field </span>
<a name="l00094"></a>00094 <span class="comment">!     is rather expensive, but additional fields have a relatively </span>
<a name="l00095"></a>00095 <span class="comment">!     low marginal cost. </span>
<a name="l00096"></a>00096 <span class="comment">! </span>
<a name="l00097"></a>00097 <span class="comment">! The following generic conservation equations may be solved: </span>
<a name="l00098"></a>00098 <span class="comment">! </span>
<a name="l00099"></a>00099 <span class="comment">!            dm/dt = del*(u*m)             (0) </span>
<a name="l00100"></a>00100 <span class="comment">!       d(m*T1)/dt = del*(u*m*T1)          (1) </span>
<a name="l00101"></a>00101 <span class="comment">!    d(m*T1*T2)/dt = del*(u*m*T1*T2)       (2) </span>
<a name="l00102"></a>00102 <span class="comment">! d(m*T1*T2*T3)/dt = del*(u*m*T1*T2*T3)    (3) </span>
<a name="l00103"></a>00103 <span class="comment">!</span>
<a name="l00104"></a>00104 <span class="comment">! where d is a partial derivative, del is the 2D divergence operator,</span>
<a name="l00105"></a>00105 <span class="comment">! u is the horizontal velocity, m is the mass density field, and</span>
<a name="l00106"></a>00106 <span class="comment">! T1, T2, and T3 are tracers.</span>
<a name="l00107"></a>00107 <span class="comment">!</span>
<a name="l00108"></a>00108 <span class="comment">! In CICE, these equations have the form</span>
<a name="l00109"></a>00109 <span class="comment">! </span>
<a name="l00110"></a>00110 <span class="comment">!               da/dt = del*(u*a)          (4)</span>
<a name="l00111"></a>00111 <span class="comment">! dv/dt =   d(a*h)/dt = del*(u*a*h)        (5)</span>
<a name="l00112"></a>00112 <span class="comment">! de/dt = d(a*h*q)/dt = del*(u*a*h*q)      (6)</span>
<a name="l00113"></a>00113 <span class="comment">!            d(aT)/dt = del*(u*a*t)        (7)</span>
<a name="l00114"></a>00114 <span class="comment">! </span>
<a name="l00115"></a>00115 <span class="comment">! where a = fractional ice area, v = ice/snow volume, h = v/a = thickness, </span>
<a name="l00116"></a>00116 <span class="comment">! e = ice/snow internal energy (J/m^2), q = e/v = internal energy per </span>
<a name="l00117"></a>00117 <span class="comment">! unit volume (J/m^3), and T is a tracer.  These equations express </span>
<a name="l00118"></a>00118 <span class="comment">! conservation of ice area, volume, internal energy, and area-weighted</span>
<a name="l00119"></a>00119 <span class="comment">! tracer, respectively. </span>
<a name="l00120"></a>00120 <span class="comment">!</span>
<a name="l00121"></a>00121 <span class="comment">! (Note: In CICE, a, v and e are prognostic quantities from which</span>
<a name="l00122"></a>00122 <span class="comment">!  h and q are diagnosed.  The remapping routine works with tracers,</span>
<a name="l00123"></a>00123 <span class="comment">!  which means that h and q must be derived from a, v, and e before</span>
<a name="l00124"></a>00124 <span class="comment">!  calling the remapping routine.)  </span>
<a name="l00125"></a>00125 <span class="comment">!</span>
<a name="l00126"></a>00126 <span class="comment">! Earlier versions of CICE assumed fixed ice and snow density. </span>
<a name="l00127"></a>00127 <span class="comment">! Beginning with CICE 4.0, the ice and snow density can be variable. </span>
<a name="l00128"></a>00128 <span class="comment">! In this case, equations (5) and (6) are replaced by </span>
<a name="l00129"></a>00129 <span class="comment">! </span>
<a name="l00130"></a>00130 <span class="comment">! dv/dt =        d(a*h)/dt = del*(u*a*h)          (8)  </span>
<a name="l00131"></a>00131 <span class="comment">! dm/dt =    d(a*h*rho)/dt = del*(u*a*h*rho)      (9)</span>
<a name="l00132"></a>00132 <span class="comment">! de/dt = d(a*h*rho*qm)/dt = del*(u*a*h*rho*qm)   (10)</span>
<a name="l00133"></a>00133 <span class="comment">! </span>
<a name="l00134"></a>00134 <span class="comment">! where rho = density and qm = internal energy per unit mass (J/kg). </span>
<a name="l00135"></a>00135 <span class="comment">! Eq. (9) expresses mass conservation, which in the variable-density </span>
<a name="l00136"></a>00136 <span class="comment">! case is no longer equivalent to volume conservation (8). </span>
<a name="l00137"></a>00137 <span class="comment">!</span>
<a name="l00138"></a>00138 <span class="comment">! Tracers satisfying equations of the form (1) are called &quot;type 1.&quot; </span>
<a name="l00139"></a>00139 <span class="comment">! In CICE the paradigmatic type 1 tracers are hi and hs. </span>
<a name="l00140"></a>00140 <span class="comment">! </span>
<a name="l00141"></a>00141 <span class="comment">! Tracers satisfying equations of the form (2) are called &quot;type 2&quot;. </span>
<a name="l00142"></a>00142 <span class="comment">! The paradigmatic type 2 tracers are qi and qs (or rhoi and rhos </span>
<a name="l00143"></a>00143 <span class="comment">!  in the variable-density case). </span>
<a name="l00144"></a>00144 <span class="comment">! </span>
<a name="l00145"></a>00145 <span class="comment">! Tracers satisfying equations of the form (3) are called &quot;type 3.&quot;</span>
<a name="l00146"></a>00146 <span class="comment">! The paradigmatic type 3 tracers are qmi and qms in the variable-density</span>
<a name="l00147"></a>00147 <span class="comment">! case.  There are no such tracers in the constant-density case. </span>
<a name="l00148"></a>00148 <span class="comment">! </span>
<a name="l00149"></a>00149 <span class="comment">! The fields a, T1, and T2 are reconstructed in each grid cell with </span>
<a name="l00150"></a>00150 <span class="comment">! 2nd-order accuracy.  T3 is reconstructed with 1st-order accuracy </span>
<a name="l00151"></a>00151 <span class="comment">! (i.e., it is transported in upwind fashion) in order to avoid </span>
<a name="l00152"></a>00152 <span class="comment">! additional mathematical complexity. </span>
<a name="l00153"></a>00153 <span class="comment">! </span>
<a name="l00154"></a>00154 <span class="comment">! The mass-like field lives in the array &quot;mm&quot; (shorthand for mean </span>
<a name="l00155"></a>00155 <span class="comment">! mass) and the tracers fields in the array &quot;tm&quot; (mean tracers). </span>
<a name="l00156"></a>00156 <span class="comment">! In order to transport tracers correctly, the remapping routine </span>
<a name="l00157"></a>00157 <span class="comment">! needs to know the tracers types and relationships.  This is done </span>
<a name="l00158"></a>00158 <span class="comment">! as follows: </span>
<a name="l00159"></a>00159 <span class="comment">! </span>
<a name="l00160"></a>00160 <span class="comment">! Each field in the &quot;tm&quot; array is assigned an index, 1:ntrace. </span>
<a name="l00161"></a>00161 <span class="comment">! (Note: ntrace is not the same as ntrcr, the number of tracers </span>
<a name="l00162"></a>00162 <span class="comment">! in the trcrn state variable array.  For remapping purposes we </span>
<a name="l00163"></a>00163 <span class="comment">! have additional tracers hi, hs, qi and qs.) </span>
<a name="l00164"></a>00164 <span class="comment">! For standard CICE with ntrcr = 1, nilyr = 4, and nslyr = 1, the </span>
<a name="l00165"></a>00165 <span class="comment">! indexing is as follows: </span>
<a name="l00166"></a>00166 <span class="comment">! 1   = hi </span>
<a name="l00167"></a>00167 <span class="comment">! 2   = hs </span>
<a name="l00168"></a>00168 <span class="comment">! 3   = Ts </span>
<a name="l00169"></a>00169 <span class="comment">! 4-7 = qi </span>
<a name="l00170"></a>00170 <span class="comment">! 8   = qs </span>
<a name="l00171"></a>00171 <span class="comment">! </span>
<a name="l00172"></a>00172 <span class="comment">! The tracer types (1,2,3) are contained in the &quot;tracer_type&quot; array. </span>
<a name="l00173"></a>00173 <span class="comment">! For standard CICE: </span>
<a name="l00174"></a>00174 <span class="comment">! </span>
<a name="l00175"></a>00175 <span class="comment">!     tracer_type = (1 1 1 2 2 2 2 2) </span>
<a name="l00176"></a>00176 <span class="comment">! </span>
<a name="l00177"></a>00177 <span class="comment">! Type 2 and type 3 tracers are said to depend on type 1 tracers. </span>
<a name="l00178"></a>00178 <span class="comment">! For instance, qi depends on hi, which is to say that </span>
<a name="l00179"></a>00179 <span class="comment">! there is a conservation equation of the form (2) or (6). </span>
<a name="l00180"></a>00180 <span class="comment">! Thus we define a &quot;depend&quot; array.  For standard CICE: </span>
<a name="l00181"></a>00181 <span class="comment">! </span>
<a name="l00182"></a>00182 <span class="comment">!          depend = (0 0 0 1 1 1 1 2) </span>
<a name="l00183"></a>00183 <span class="comment">! </span>
<a name="l00184"></a>00184 <span class="comment">! which implies that elements 1-3 (hi, hs, Ts) are type 1, </span>
<a name="l00185"></a>00185 <span class="comment">! elements 4-7 (qi) depend on element 1 (hi), and element 8 (qs) </span>
<a name="l00186"></a>00186 <span class="comment">! depends on element 2 (hs). </span>
<a name="l00187"></a>00187 <span class="comment">!</span>
<a name="l00188"></a>00188 <span class="comment">! We also define a logical array &quot;has_dependents&quot;.  In standard CICE: </span>
<a name="l00189"></a>00189 <span class="comment">! </span>
<a name="l00190"></a>00190 <span class="comment">!  has_dependents = (T T F F F F F F), </span>
<a name="l00191"></a>00191 <span class="comment">! </span>
<a name="l00192"></a>00192 <span class="comment">! which means that only elements 1 and 2 (hi and hs) have dependent </span>
<a name="l00193"></a>00193 <span class="comment">! tracers. </span>
<a name="l00194"></a>00194 <span class="comment">! </span>
<a name="l00195"></a>00195 <span class="comment">! For the variable-density case, things are a bit more complicated. </span>
<a name="l00196"></a>00196 <span class="comment">! Suppose we have 4 variable-density ice layers and one variable- </span>
<a name="l00197"></a>00197 <span class="comment">! density snow layer.  Then the indexing is as follows: </span>
<a name="l00198"></a>00198 <span class="comment">! 1    = hi </span>
<a name="l00199"></a>00199 <span class="comment">! 2    = hs </span>
<a name="l00200"></a>00200 <span class="comment">! 3    = Ts </span>
<a name="l00201"></a>00201 <span class="comment">! 4-7  = rhoi </span>
<a name="l00202"></a>00202 <span class="comment">! 8    = rhos </span>
<a name="l00203"></a>00203 <span class="comment">! 9-12 = qmi </span>
<a name="l00204"></a>00204 <span class="comment">! 13   = qms </span>
<a name="l00205"></a>00205 <span class="comment">! </span>
<a name="l00206"></a>00206 <span class="comment">! The key arrays are: </span>
<a name="l00207"></a>00207 <span class="comment">! </span>
<a name="l00208"></a>00208 <span class="comment">!    tracer_type = (1 1 1 2 2 2 2 2 3 3 3 3 3) </span>
<a name="l00209"></a>00209 <span class="comment">! </span>
<a name="l00210"></a>00210 <span class="comment">!         depend = (0 0 0 1 1 1 1 2 4 5 6 7 8) </span>
<a name="l00211"></a>00211 <span class="comment">! </span>
<a name="l00212"></a>00212 <span class="comment">! has_dependents = (T T F T T T T T F F F F F) </span>
<a name="l00213"></a>00213 <span class="comment">! </span>
<a name="l00214"></a>00214 <span class="comment">! which imply that hi and hs are type 1 with dependents rhoi and rhos, </span>
<a name="l00215"></a>00215 <span class="comment">! while rhoi and rhos are type 2 with dependents qmi and qms. </span>
<a name="l00216"></a>00216 <span class="comment">! </span>
<a name="l00217"></a>00217 <span class="comment">! Tracers added to the ntrcr array are handled automatically </span>
<a name="l00218"></a>00218 <span class="comment">! by the remapping with little extra coding.  It is necessary </span>
<a name="l00219"></a>00219 <span class="comment">! only to provide the correct type and dependency information. </span>
<a name="l00220"></a>00220 <span class="comment">!</span>
<a name="l00221"></a>00221 <span class="comment">! When using this routine in other models, most of the tracer dependency</span>
<a name="l00222"></a>00222 <span class="comment">! apparatus may be irrelevant.  In a layered ocean model, for example,</span>
<a name="l00223"></a>00223 <span class="comment">! the transported fields are the layer thickness h (the mass density</span>
<a name="l00224"></a>00224 <span class="comment">! field) and two or more tracers (T, S, and various trace species).</span>
<a name="l00225"></a>00225 <span class="comment">! Suppose there are just two tracers, T and S.  Then the tracer arrays</span>
<a name="l00226"></a>00226 <span class="comment">! have the values:</span>
<a name="l00227"></a>00227 <span class="comment">!</span>
<a name="l00228"></a>00228 <span class="comment">!    tracer_type = (1 1)</span>
<a name="l00229"></a>00229 <span class="comment">!         depend = (0 0)</span>
<a name="l00230"></a>00230 <span class="comment">! has_dependents = (F F)</span>
<a name="l00231"></a>00231 <span class="comment">!</span>
<a name="l00232"></a>00232 <span class="comment">! which is to say that all tracer transport equations are of the form (1).</span>
<a name="l00233"></a>00233 <span class="comment">!</span>
<a name="l00234"></a>00234 <span class="comment">! The tracer dependency arrays are optional input arguments for the</span>
<a name="l00235"></a>00235 <span class="comment">! main remapping subroutine.  If these arrays are not passed in, they</span>
<a name="l00236"></a>00236 <span class="comment">! take on the default values tracer_type(:) = 1, depend(:) = 0, and</span>
<a name="l00237"></a>00237 <span class="comment">! has_dependents(:) = F, which are appropriate for most purposes.</span>
<a name="l00238"></a>00238 <span class="comment">!</span>
<a name="l00239"></a>00239 <span class="comment">! Another optional argument is integral_order.  If integral_order = 1,</span>
<a name="l00240"></a>00240 <span class="comment">! then the triangle integrals are exact for linear functions of x and y.</span>
<a name="l00241"></a>00241 <span class="comment">! If integral_order = 2, these integrals are exact for both linear and</span>
<a name="l00242"></a>00242 <span class="comment">! quadratic functions.  If integral_order = 3, integrals are exact for</span>
<a name="l00243"></a>00243 <span class="comment">! cubic functions as well.  If all tracers are of type 1, then the</span>
<a name="l00244"></a>00244 <span class="comment">! integrals of mass*tracer are quadratic, and integral_order = 2 is</span>
<a name="l00245"></a>00245 <span class="comment">! sufficient.  In CICE, where there are type 2 tracers, we integrate</span>
<a name="l00246"></a>00246 <span class="comment">! functions of the form mass*tracer1*tracer2.  Thus integral_order = 3</span>
<a name="l00247"></a>00247 <span class="comment">! is required for exactness, though integral_order = 2 may be good enough</span>
<a name="l00248"></a>00248 <span class="comment">! in practice.</span>
<a name="l00249"></a>00249 <span class="comment">!</span>
<a name="l00250"></a>00250 <span class="comment">! Finally, a few words about the edgearea fields:</span>
<a name="l00251"></a>00251 <span class="comment">!</span>
<a name="l00252"></a>00252 <span class="comment">! In earlier versions of this scheme, the divergence of the velocity</span>
<a name="l00253"></a>00253 <span class="comment">! field implied by the remapping was, in general, different from the</span>
<a name="l00254"></a>00254 <span class="comment">! value of del*u computed in the dynamics.  For energetic consistency</span>
<a name="l00255"></a>00255 <span class="comment">! (in CICE as well as in layered ocean models such as HYPOP),</span>
<a name="l00256"></a>00256 <span class="comment">! these two values should agree.  This can be ensured by setting</span>
<a name="l00257"></a>00257 <span class="comment">! l_fixed_area = T and specifying the area transported across each grid</span>
<a name="l00258"></a>00258 <span class="comment">! cell edge in the arrays edgearea_e and edgearea_n.  The departure</span>
<a name="l00259"></a>00259 <span class="comment">! regions are then tweaked, following an idea by Mats Bentsen, such</span>
<a name="l00260"></a>00260 <span class="comment">! that they have the desired area.  If l_fixed_area = F, these regions</span>
<a name="l00261"></a>00261 <span class="comment">! are not tweaked, and the edgearea arrays are output variables.</span>
<a name="l00262"></a>00262 <span class="comment">!   </span>
<a name="l00263"></a>00263 <span class="comment">!=======================================================================</span>
<a name="l00264"></a>00264 
<a name="l00265"></a>00265       <span class="keyword">contains</span>
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="comment">!=======================================================================</span>
<a name="l00268"></a>00268 <span class="comment">!</span>
<a name="l00269"></a>00269 <span class="comment">!BOP</span>
<a name="l00270"></a>00270 <span class="comment">!</span>
<a name="l00271"></a>00271 <span class="comment">! !IROUTINE: init_remap - initialize grid quantities used for remapping</span>
<a name="l00272"></a>00272 <span class="comment">!</span>
<a name="l00273"></a>00273 <span class="comment">! !INTERFACE:</span>
<a name="l00274"></a>00274 <span class="comment">!</span>
<a name="l00275"></a><a class="code" href="namespaceice__transport__remap.html#ae1b446db8b6220961bfcacd0c9b57fd4">00275</a>       <span class="keyword">subroutine </span><a class="code" href="namespaceice__transport__remap.html#ae1b446db8b6220961bfcacd0c9b57fd4">init_remap</a>
<a name="l00276"></a>00276 <span class="comment">!</span>
<a name="l00277"></a>00277 <span class="comment">! !DESCRIPTION:</span>
<a name="l00278"></a>00278 <span class="comment">!</span>
<a name="l00279"></a>00279 <span class="comment">! Grid quantities used by the remapping transport scheme</span>
<a name="l00280"></a>00280 <span class="comment">!</span>
<a name="l00281"></a>00281 <span class="comment">! !REVISION HISTORY:</span>
<a name="l00282"></a>00282 <span class="comment">!</span>
<a name="l00283"></a>00283 <span class="comment">! author William H. Lipscomb, LANL</span>
<a name="l00284"></a>00284 <span class="comment">!</span>
<a name="l00285"></a>00285 <span class="comment">! !USES:</span>
<a name="l00286"></a>00286 <span class="comment">!</span>
<a name="l00287"></a>00287       use <span class="keywordflow">ice_boundary</span>
<a name="l00288"></a>00288       use <span class="keywordflow">ice_domain</span>
<a name="l00289"></a>00289       use <span class="keywordflow">ice_blocks</span>
<a name="l00290"></a>00290       use <span class="keywordflow">ice_grid</span>, only: dxt, dyt,                      &amp;
<a name="l00291"></a>00291                           xav, yav, xxav, xyav, yyav,    &amp;
<a name="l00292"></a>00292                           xxxav, xxyav, xyyav, yyyav
<a name="l00293"></a>00293       use <span class="keywordflow">ice_exit</span>
<a name="l00294"></a>00294 <span class="comment">!</span>
<a name="l00295"></a>00295 <span class="comment">! !INPUT/OUTPUT PARAMETERS:</span>
<a name="l00296"></a>00296 <span class="comment">!</span>
<a name="l00297"></a>00297 <span class="comment">!EOP</span>
<a name="l00298"></a>00298 <span class="comment">!</span>
<a name="l00299"></a>00299       <span class="keywordtype">integer (kind=int_kind) </span>::     
<a name="l00300"></a>00300          i, j, iblk     <span class="comment">! standard indices</span>
<a name="l00301"></a>00301 
<a name="l00302"></a>00302       <span class="comment">! Compute grid cell average geometric quantities on the scaled</span>
<a name="l00303"></a>00303       <span class="comment">! rectangular grid with dx = 1, dy = 1.</span>
<a name="l00304"></a>00304       <span class="comment">!</span>
<a name="l00305"></a>00305       <span class="comment">! Note: On a rectangular grid, the integral of any odd function</span>
<a name="l00306"></a>00306       <span class="comment">!       of x or y = 0.</span>
<a name="l00307"></a>00307 
<a name="l00308"></a>00308       <span class="comment">!$OMP PARALLEL DO PRIVATE(iblk,i,j)</span>
<a name="l00309"></a>00309       <span class="keyword">do</span> iblk = 1, <a class="code" href="namespaceice__domain.html#aae3d2de717ee7a743c9635b3a9e35a95">nblocks</a>
<a name="l00310"></a>00310          <span class="keyword">do</span> j = 1, <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>
<a name="l00311"></a>00311          <span class="keyword">do</span> i = 1, <a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>
<a name="l00312"></a>00312             xav(i,j,iblk) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l00313"></a>00313             yav(i,j,iblk) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l00314"></a>00314 <span class="comment">!!!            These formulas would be used on a rectangular grid</span>
<a name="l00315"></a>00315 <span class="comment">!!!            with dimensions (dxt, dyt):  </span>
<a name="l00316"></a>00316 <span class="comment">!!!            xxav(i,j,iblk) = dxt(i,j,iblk)**2 / c12</span>
<a name="l00317"></a>00317 <span class="comment">!!!            yyav(i,j,iblk) = dyt(i,j,iblk)**2 / c12</span>
<a name="l00318"></a>00318             xxav(i,j,iblk) = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>/<a class="code" href="namespaceice__constants.html#ad58b4990ce1a83ae0c0ca55a61e8ed1e">c12</a>
<a name="l00319"></a>00319             yyav(i,j,iblk) = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>/<a class="code" href="namespaceice__constants.html#ad58b4990ce1a83ae0c0ca55a61e8ed1e">c12</a>
<a name="l00320"></a>00320             xyav(i,j,iblk) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l00321"></a>00321             xxxav(i,j,iblk) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l00322"></a>00322             xxyav(i,j,iblk) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l00323"></a>00323             xyyav(i,j,iblk) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l00324"></a>00324             yyyav(i,j,iblk) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l00325"></a>00325          <span class="keyword">enddo</span>
<a name="l00326"></a>00326          <span class="keyword">enddo</span>
<a name="l00327"></a>00327       <span class="keyword">enddo</span>
<a name="l00328"></a>00328       <span class="comment">!$OMP END PARALLEL DO</span>
<a name="l00329"></a>00329  
<a name="l00330"></a>00330 <span class="keyword">      end subroutine init_remap</span>
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 <span class="comment">!=======================================================================</span>
<a name="l00333"></a>00333 <span class="comment">!BOP</span>
<a name="l00334"></a>00334 <span class="comment">!</span>
<a name="l00335"></a>00335 <span class="comment">! !IROUTINE: horizontal_remap - incremental remapping transport scheme</span>
<a name="l00336"></a>00336 <span class="comment">!</span>
<a name="l00337"></a>00337 <span class="comment">! !INTERFACE:</span>
<a name="l00338"></a>00338 <span class="comment">!</span>
<a name="l00339"></a><a class="code" href="namespaceice__transport__remap.html#af549caf7a8f27fcbe1cc3d9f8df4bacd">00339</a>       <span class="keyword">subroutine </span><a class="code" href="namespaceice__transport__remap.html#af549caf7a8f27fcbe1cc3d9f8df4bacd">horizontal_remap</a> (dt,                            &amp;
<a name="l00340"></a>00340                                    uvel,              vvel,       &amp;
<a name="l00341"></a>00341                                    mm,                tm,         &amp;
<a name="l00342"></a>00342                                    l_fixed_area,                  &amp;
<a name="l00343"></a>00343                                    edgearea_e,        edgearea_n, &amp;
<a name="l00344"></a>00344                                    tracer_type_in,    depend_in,  &amp;
<a name="l00345"></a>00345                                    has_dependents_in,             &amp;
<a name="l00346"></a>00346                                    integral_order_in,             &amp;
<a name="l00347"></a>00347                                    l_dp_midpt_in)
<a name="l00348"></a>00348 <span class="comment">!</span>
<a name="l00349"></a>00349 <span class="comment">! !DESCRIPTION:</span>
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 <span class="comment">! Solve the transport equations for one timestep using the incremental</span>
<a name="l00352"></a>00352 <span class="comment">! remapping scheme developed by John Dukowicz and John Baumgardner (DB)</span>
<a name="l00353"></a>00353 <span class="comment">! and modified for sea ice by William Lipscomb and Elizabeth Hunke.</span>
<a name="l00354"></a>00354 <span class="comment">!</span>
<a name="l00355"></a>00355 <span class="comment">! This scheme preserves monotonicity of ice area and tracers.  That is,</span>
<a name="l00356"></a>00356 <span class="comment">! it does not produce new extrema.  It is second-order accurate in space,</span>
<a name="l00357"></a>00357 <span class="comment">! except where gradients are limited to preserve monotonicity. </span>
<a name="l00358"></a>00358 <span class="comment">!</span>
<a name="l00359"></a>00359 <span class="comment">! This version of the remapping allows the user to specify the areal</span>
<a name="l00360"></a>00360 <span class="comment">! flux across each edge, based on an idea developed by Mats Bentsen.</span>
<a name="l00361"></a>00361 <span class="comment">!</span>
<a name="l00362"></a>00362 <span class="comment">! !REVISION HISTORY:</span>
<a name="l00363"></a>00363 <span class="comment">!</span>
<a name="l00364"></a>00364 <span class="comment">! author William H. Lipscomb, LANL</span>
<a name="l00365"></a>00365 <span class="comment">! 2006: Moved driver (subroutine transport_remap) into separate module. </span>
<a name="l00366"></a>00366 <span class="comment">!       Geometry changes (logically rectangular coordinates, fixed</span>
<a name="l00367"></a>00367 <span class="comment">!        area fluxes)</span>
<a name="l00368"></a>00368 <span class="comment">!       </span>
<a name="l00369"></a>00369 <span class="comment">! !USES:</span>
<a name="l00370"></a>00370 <span class="comment">!</span>
<a name="l00371"></a>00371       use <span class="keywordflow">ice_boundary</span>
<a name="l00372"></a>00372       use <span class="keywordflow">ice_global_reductions</span>
<a name="l00373"></a>00373       use <span class="keywordflow">ice_domain</span>
<a name="l00374"></a>00374       use <span class="keywordflow">ice_blocks</span>
<a name="l00375"></a>00375       use <span class="keywordflow">ice_grid</span>, only: HTE, HTN, dxt, dyt, dxu, dyu,       &amp;
<a name="l00376"></a>00376                           tarea, tarear, hm,                  &amp;
<a name="l00377"></a>00377                           xav, yav, xxav, xyav, yyav,         &amp;
<a name="l00378"></a>00378                           xxxav, xxyav, xyyav, yyyav
<a name="l00379"></a>00379       use <span class="keywordflow">ice_exit</span>
<a name="l00380"></a>00380       use <span class="keywordflow">ice_calendar</span>, only: istep1
<a name="l00381"></a>00381       use <span class="keywordflow">ice_timers</span>
<a name="l00382"></a>00382 <span class="comment">!</span>
<a name="l00383"></a>00383 <span class="comment">! !INPUT/OUTPUT PARAMETERS:</span>
<a name="l00384"></a>00384 <span class="comment">!</span>
<a name="l00385"></a>00385       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(in)</span> ::     
<a name="l00386"></a>00386          dt      <span class="comment">! time step</span>
<a name="l00387"></a>00387 
<a name="l00388"></a>00388       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(in)</span>,       
<a name="l00389"></a>00389                 <span class="keywordtype">dimension(nx_block,ny_block,max_blocks) </span>::           
<a name="l00390"></a>00390          uvel       ,<span class="comment">! x-component of velocity (m/s)</span>
<a name="l00391"></a>00391          vvel         <span class="comment">! y-component of velocity (m/s)</span>
<a name="l00392"></a>00392 
<a name="l00393"></a>00393       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(inout)</span>,     
<a name="l00394"></a>00394          <span class="keywordtype">dimension (nx_block,ny_block,0:ncat,max_blocks) </span>::          
<a name="l00395"></a>00395          mm           <span class="comment">! mean mass values in each grid cell</span>
<a name="l00396"></a>00396 
<a name="l00397"></a>00397       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(inout)</span>,     
<a name="l00398"></a>00398          <span class="keywordtype">dimension (nx_block,ny_block,ntrace,ncat,max_blocks) </span>::     
<a name="l00399"></a>00399          tm           <span class="comment">! mean tracer values in each grid cell</span>
<a name="l00400"></a>00400 
<a name="l00401"></a>00401     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00402"></a>00402     <span class="comment">! If l_fixed_area is true, the area of each departure region is</span>
<a name="l00403"></a>00403     <span class="comment">!  computed in advance (e.g., by taking the divergence of the </span>
<a name="l00404"></a>00404     <span class="comment">!  velocity field and passed to locate_triangles.  The departure </span>
<a name="l00405"></a>00405     <span class="comment">!  regions are adjusted to obtain the desired area.</span>
<a name="l00406"></a>00406     <span class="comment">! If false, edgearea is computed in locate_triangles and passed out.</span>
<a name="l00407"></a>00407     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00408"></a>00408 
<a name="l00409"></a>00409       <span class="keywordtype">logical</span>, <span class="keywordtype">intent(in)</span> ::    
<a name="l00410"></a>00410          l_fixed_area     <span class="comment">! if true, edgearea_e and edgearea_n are prescribed</span>
<a name="l00411"></a>00411                           <span class="comment">! if false, edgearea is computed here and passed out</span>
<a name="l00412"></a>00412 
<a name="l00413"></a>00413       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension(nx_block,ny_block,max_blocks)</span>,  
<a name="l00414"></a>00414          <span class="keywordtype">intent(inout)</span> ::                                             
<a name="l00415"></a>00415          edgearea_e     ,<span class="comment">! area of departure regions for east edges</span>
<a name="l00416"></a>00416          edgearea_n       <span class="comment">! area of departure regions for north edges</span>
<a name="l00417"></a>00417 
<a name="l00418"></a>00418       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (ntrace)</span>, <span class="keywordtype">intent(in)</span>,     
<a name="l00419"></a>00419          <span class="keywordtype">optional</span> ::           
<a name="l00420"></a>00420          tracer_type_in       ,<span class="comment">! = 1, 2, or 3 (see comments above)</span>
<a name="l00421"></a>00421          depend_in              <span class="comment">! tracer dependencies (see above)</span>
<a name="l00422"></a>00422 
<a name="l00423"></a>00423       <span class="keywordtype">logical (kind=log_kind)</span>, <span class="keywordtype">dimension (ntrace)</span>, <span class="keywordtype">intent(in)</span>,     
<a name="l00424"></a>00424          <span class="keywordtype">optional</span> ::     
<a name="l00425"></a>00425          has_dependents_in      <span class="comment">! true if a tracer has dependent tracers</span>
<a name="l00426"></a>00426 
<a name="l00427"></a>00427       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(in)</span>, <span class="keywordtype">optional</span> ::     
<a name="l00428"></a>00428          integral_order_in      <span class="comment">! polynomial order for triangle integrals</span>
<a name="l00429"></a>00429 
<a name="l00430"></a>00430       <span class="keywordtype">logical (kind=log_kind)</span>, <span class="keywordtype">intent(in)</span>, <span class="keywordtype">optional</span> ::     
<a name="l00431"></a>00431          l_dp_midpt_in          <span class="comment">! if true, find departure points using</span>
<a name="l00432"></a>00432                                 <span class="comment">! corrected midpoint velocity</span>
<a name="l00433"></a>00433 <span class="comment">!</span>
<a name="l00434"></a>00434 <span class="comment">!EOP</span>
<a name="l00435"></a>00435 <span class="comment">!</span>
<a name="l00436"></a>00436       <span class="comment">! local variables</span>
<a name="l00437"></a>00437 
<a name="l00438"></a>00438       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (ntrace) </span>::     
<a name="l00439"></a>00439          tracer_type       ,<span class="comment">! = 1, 2, or 3 (see comments above)</span>
<a name="l00440"></a>00440          depend              <span class="comment">! tracer dependencies (see above)</span>
<a name="l00441"></a>00441 
<a name="l00442"></a>00442       <span class="keywordtype">logical (kind=log_kind)</span>, <span class="keywordtype">dimension (ntrace) </span>::     
<a name="l00443"></a>00443          has_dependents      <span class="comment">! true if a tracer has dependent tracers</span>
<a name="l00444"></a>00444 
<a name="l00445"></a>00445       <span class="keywordtype">integer (kind=int_kind) </span>::     
<a name="l00446"></a>00446          integral_order      <span class="comment">! polynomial order for triangle integrals</span>
<a name="l00447"></a>00447 
<a name="l00448"></a>00448       <span class="keywordtype">logical (kind=log_kind) </span>::     
<a name="l00449"></a>00449          l_dp_midpt          <span class="comment">! if true, find departure points using</span>
<a name="l00450"></a>00450                              <span class="comment">! corrected midpoint velocity</span>
<a name="l00451"></a>00451 
<a name="l00452"></a>00452       <span class="keywordtype">integer (kind=int_kind) </span>::     
<a name="l00453"></a>00453          i, j           ,<span class="comment">! horizontal indices</span>
<a name="l00454"></a>00454          iblk           ,<span class="comment">! block indices</span>
<a name="l00455"></a>00455          ilo,ihi,jlo,jhi,<span class="comment">! beginning and end of physical domain</span>
<a name="l00456"></a>00456          n                <span class="comment">! ice category index</span>
<a name="l00457"></a>00457 
<a name="l00458"></a>00458       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension(0:ncat,max_blocks) </span>::     
<a name="l00459"></a>00459          icellsnc         <span class="comment">! number of cells with ice</span>
<a name="l00460"></a>00460 
<a name="l00461"></a>00461       <span class="keywordtype">integer (kind=int_kind)</span>,     
<a name="l00462"></a>00462          <span class="keywordtype">dimension(nx_block*ny_block,0:ncat,max_blocks) </span>::     
<a name="l00463"></a>00463          indxinc, indxjnc   <span class="comment">! compressed i/j indices</span>
<a name="l00464"></a>00464 
<a name="l00465"></a>00465       <span class="keywordtype">type (</span><a class="code" href="typeice__blocks_1_1block.html">block</a><span class="keywordtype">)</span> ::     
<a name="l00466"></a>00466          this_block       <span class="comment">! block information for current block</span>
<a name="l00467"></a>00467 
<a name="l00468"></a>00468       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,max_blocks) </span>::     
<a name="l00469"></a>00469          dpx            ,<span class="comment">! x coordinates of departure points at cell corners</span>
<a name="l00470"></a>00470          dpy              <span class="comment">! y coordinates of departure points at cell corners</span>
<a name="l00471"></a>00471 
<a name="l00472"></a>00472       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension(nx_block,ny_block,0:ncat,max_blocks) </span>:: 
<a name="l00473"></a>00473          mc             ,<span class="comment">! mass at geometric center of cell</span>
<a name="l00474"></a>00474          mx, my         ,<span class="comment">! limited derivative of mass wrt x and y</span>
<a name="l00475"></a>00475          mmask            <span class="comment">! = 1. if mass is present, = 0. otherwise</span>
<a name="l00476"></a>00476 
<a name="l00477"></a>00477       <span class="keywordtype">real (kind=dbl_kind)</span>,      
<a name="l00478"></a>00478          <span class="keywordtype">dimension (nx_block,ny_block,ntrace,ncat,max_blocks) </span>::     
<a name="l00479"></a>00479          tc             ,<span class="comment">! tracer values at geometric center of cell</span>
<a name="l00480"></a>00480          tx, ty         ,<span class="comment">! limited derivative of tracer wrt x and y</span>
<a name="l00481"></a>00481          tmask            <span class="comment">! = 1. if tracer is present, = 0. otherwise</span>
<a name="l00482"></a>00482 
<a name="l00483"></a>00483       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,0:ncat,max_blocks) </span>::     
<a name="l00484"></a>00484          mflxe, mflxn     <span class="comment">! mass transports across E and N cell edges</span>
<a name="l00485"></a>00485 
<a name="l00486"></a>00486       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,ntrace,ncat,max_blocks) </span>::     
<a name="l00487"></a>00487          mtflxe, mtflxn   <span class="comment">! mass*tracer transports across E and N cell edges</span>
<a name="l00488"></a>00488 
<a name="l00489"></a>00489       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,ngroups,max_blocks) </span>::     
<a name="l00490"></a>00490          triarea          <span class="comment">! area of east-edge departure triangle</span>
<a name="l00491"></a>00491 
<a name="l00492"></a>00492       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,0:nvert,ngroups,max_blocks) </span>::  
<a name="l00493"></a>00493          xp, yp           <span class="comment">! x and y coordinates of special triangle points</span>
<a name="l00494"></a>00494                           <span class="comment">! (need 4 points for triangle integrals)</span>
<a name="l00495"></a>00495 
<a name="l00496"></a>00496       <span class="keywordtype">integer (kind=int_kind)</span>,     
<a name="l00497"></a>00497          <span class="keywordtype">dimension (nx_block,ny_block,ngroups,max_blocks) </span>::     
<a name="l00498"></a>00498          iflux          ,<span class="comment">! i index of cell contributing transport</span>
<a name="l00499"></a>00499          jflux            <span class="comment">! j index of cell contributing transport</span>
<a name="l00500"></a>00500 
<a name="l00501"></a>00501       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension(ngroups,max_blocks) </span>::     
<a name="l00502"></a>00502          icellsng         <span class="comment">! number of cells with ice</span>
<a name="l00503"></a>00503 
<a name="l00504"></a>00504       <span class="keywordtype">integer (kind=int_kind)</span>,     
<a name="l00505"></a>00505          <span class="keywordtype">dimension(nx_block*ny_block,ngroups,max_blocks) </span>::     
<a name="l00506"></a>00506          indxing, indxjng <span class="comment">! compressed i/j indices</span>
<a name="l00507"></a>00507 
<a name="l00508"></a>00508       <span class="keywordtype">logical (kind=log_kind)</span>, <span class="keywordtype">dimension(max_blocks) </span>::     
<a name="l00509"></a>00509          l_stop           <span class="comment">! if true, abort the model</span>
<a name="l00510"></a>00510 
<a name="l00511"></a>00511       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension(max_blocks) </span>::     
<a name="l00512"></a>00512          istop, jstop     <span class="comment">! indices of grid cell where model aborts</span>
<a name="l00513"></a>00513 
<a name="l00514"></a>00514       <span class="keywordtype">character (len=char_len)</span>, <span class="keywordtype">dimension(max_blocks) </span>::   
<a name="l00515"></a>00515          edge             <span class="comment">! &apos;north&apos; or &apos;east&apos;</span>
<a name="l00516"></a>00516 
<a name="l00517"></a>00517       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block) </span>:: 
<a name="l00518"></a>00518          worka, 
<a name="l00519"></a>00519          workb, 
<a name="l00520"></a>00520          workc, 
<a name="l00521"></a>00521          workd
<a name="l00522"></a>00522 
<a name="l00523"></a>00523       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,2,max_blocks) </span>::     
<a name="l00524"></a>00524           dpwork          
<a name="l00525"></a>00525  
<a name="l00526"></a>00526        <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension(nx_block,ny_block,2,0:ncat,max_blocks) </span>:: 
<a name="l00527"></a>00527           mwork
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="comment">!     call t_barrierf (&apos;cice_dyn_remap1_BARRIER&apos;,MPI_COMM_ICE)</span>
<a name="l00530"></a>00530 <span class="comment">!     call t_startf (&apos;cice_dyn_remap1&apos;)</span>
<a name="l00531"></a>00531 
<a name="l00532"></a>00532       l_stop = .false.
<a name="l00533"></a>00533       istop = 0
<a name="l00534"></a>00534       jstop = 0
<a name="l00535"></a>00535 
<a name="l00536"></a>00536     <span class="comment">!------------------------------------------------------------------- </span>
<a name="l00537"></a>00537     <span class="comment">! Initialize various remapping arrays and options</span>
<a name="l00538"></a>00538     <span class="comment">! These are either passed in as optional arguments or set to the</span>
<a name="l00539"></a>00539     <span class="comment">! default values.</span>
<a name="l00540"></a>00540     <span class="comment">!------------------------------------------------------------------- </span>
<a name="l00541"></a>00541 
<a name="l00542"></a>00542       <span class="keyword">if</span> (present(tracer_type_in)) <span class="keyword">then</span>
<a name="l00543"></a>00543          tracer_type(:) = tracer_type_in(:)
<a name="l00544"></a>00544       <span class="keyword">else</span>
<a name="l00545"></a>00545          tracer_type(:) = 1
<a name="l00546"></a>00546       <span class="keyword">endif</span>
<a name="l00547"></a>00547 
<a name="l00548"></a>00548       <span class="keyword">if</span> (present(depend_in)) <span class="keyword">then</span>
<a name="l00549"></a>00549          depend(:) = depend_in(:)
<a name="l00550"></a>00550       <span class="keyword">else</span>
<a name="l00551"></a>00551          depend(:) = 0
<a name="l00552"></a>00552       <span class="keyword">endif</span>
<a name="l00553"></a>00553 
<a name="l00554"></a>00554       <span class="keyword">if</span> (present(has_dependents_in)) <span class="keyword">then</span>
<a name="l00555"></a>00555          has_dependents(:) = has_dependents_in(:)
<a name="l00556"></a>00556       <span class="keyword">else</span>
<a name="l00557"></a>00557          has_dependents(:) = .false.
<a name="l00558"></a>00558       <span class="keyword">endif</span>
<a name="l00559"></a>00559 
<a name="l00560"></a>00560       <span class="keyword">if</span> (present(integral_order_in)) <span class="keyword">then</span>
<a name="l00561"></a>00561          integral_order = integral_order_in
<a name="l00562"></a>00562       <span class="keyword">else</span>
<a name="l00563"></a>00563          integral_order = 2   <span class="comment">! quadratic integrals</span>
<a name="l00564"></a>00564       <span class="keyword">endif</span>
<a name="l00565"></a>00565 
<a name="l00566"></a>00566       <span class="keyword">if</span> (present(l_dp_midpt_in)) <span class="keyword">then</span>
<a name="l00567"></a>00567          l_dp_midpt = l_dp_midpt_in
<a name="l00568"></a>00568       <span class="keyword">else</span>
<a name="l00569"></a>00569          l_dp_midpt = .false.
<a name="l00570"></a>00570       <span class="keyword">endif</span>
<a name="l00571"></a>00571 
<a name="l00572"></a>00572       worka(:,:) = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>
<a name="l00573"></a>00573       workb(:,:) = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>
<a name="l00574"></a>00574       workc(:,:) = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>
<a name="l00575"></a>00575       workd(:,:) = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 <span class="comment">!---!-------------------------------------------------------------------</span>
<a name="l00578"></a>00578 <span class="comment">!---! Remap the ice area and associated tracers.</span>
<a name="l00579"></a>00579 <span class="comment">!---! Remap the open water area (without tracers).</span>
<a name="l00580"></a>00580 <span class="comment">!---!-------------------------------------------------------------------</span>
<a name="l00581"></a>00581 
<a name="l00582"></a>00582       <span class="comment">!$OMP PARALLEL DO PRIVATE(iblk,this_block,ilo,ihi,jlo,jhi,n)</span>
<a name="l00583"></a>00583       <span class="keyword">do</span> iblk = 1, <a class="code" href="namespaceice__domain.html#aae3d2de717ee7a743c9635b3a9e35a95">nblocks</a>
<a name="l00584"></a>00584 
<a name="l00585"></a>00585          this_block = <a class="code" href="namespaceice__blocks.html#aa79bfef5022683234ed1b332af17f1de">get_block</a>(<a class="code" href="namespaceice__domain.html#a152cf5087ce1dccce8f5e147306320ae">blocks_ice</a>(iblk),iblk)         
<a name="l00586"></a>00586          ilo = this_block%ilo
<a name="l00587"></a>00587          ihi = this_block%ihi
<a name="l00588"></a>00588          jlo = this_block%jlo
<a name="l00589"></a>00589          jhi = this_block%jhi
<a name="l00590"></a>00590 
<a name="l00591"></a>00591     <span class="comment">!------------------------------------------------------------------- </span>
<a name="l00592"></a>00592     <span class="comment">! Compute masks and count ice cells.</span>
<a name="l00593"></a>00593     <span class="comment">! Masks are used to prevent tracer values in cells without ice from</span>
<a name="l00594"></a>00594     <span class="comment">!  being used to compute tracer gradients.</span>
<a name="l00595"></a>00595     <span class="comment">!------------------------------------------------------------------- </span>
<a name="l00596"></a>00596 
<a name="l00597"></a>00597          call <a class="code" href="namespaceice__transport__remap.html#a9a9fe0af7f01eed20d6df09ed2e8dc2a">make_masks </a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,           <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,             &amp;
<a name="l00598"></a>00598                           ilo, ihi,           jlo, jhi,             &amp;
<a name="l00599"></a>00599                           <a class="code" href="namespaceice__blocks.html#a75dd0bf2d3d80ac626a1effa70f77a35">nghost</a>,             has_dependents,       &amp;
<a name="l00600"></a>00600                           icellsnc (:,iblk),                        &amp;
<a name="l00601"></a>00601                           indxinc(:,:,iblk),  indxjnc  (:,:,iblk),  &amp;
<a name="l00602"></a>00602                           mm   (:,:,:,iblk),  mmask  (:,:,:,iblk),  &amp;
<a name="l00603"></a>00603                           tm (:,:,:,:,iblk),  tmask(:,:,:,:,iblk))
<a name="l00604"></a>00604 
<a name="l00605"></a>00605     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00606"></a>00606     <span class="comment">! Construct linear fields, limiting gradients to preserve monotonicity.</span>
<a name="l00607"></a>00607     <span class="comment">! Note: Pass in unit arrays instead of true distances HTE, HTN, etc.</span>
<a name="l00608"></a>00608     <span class="comment">!       The resulting gradients are in scaled coordinates.</span>
<a name="l00609"></a>00609     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00610"></a>00610 
<a name="l00611"></a>00611          <span class="comment">! open water</span>
<a name="l00612"></a>00612 
<a name="l00613"></a>00613          call <a class="code" href="namespaceice__transport__remap.html#a4c7f753ed3abe19124a7e719e3424dae">construct_fields</a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,           <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,           &amp;
<a name="l00614"></a>00614                                ilo, ihi,           jlo, jhi,           &amp;
<a name="l00615"></a>00615                                <a class="code" href="namespaceice__blocks.html#a75dd0bf2d3d80ac626a1effa70f77a35">nghost</a>,                                 &amp;
<a name="l00616"></a>00616                                tracer_type,        depend,             &amp;
<a name="l00617"></a>00617                                has_dependents,     icellsnc (0,iblk),  &amp;
<a name="l00618"></a>00618                                indxinc(:,0,iblk),  indxjnc(:,0,iblk),  &amp;
<a name="l00619"></a>00619 <span class="comment">!                               HTN     :,:,iblk),  HTE    (:,:,iblk),  &amp;</span>
<a name="l00620"></a>00620                                worka       (:,:),  workb       (:,:),  &amp;
<a name="l00621"></a>00621                                hm     (:,:,iblk),  xav    (:,:,iblk),  &amp;
<a name="l00622"></a>00622                                yav    (:,:,iblk),  xxav   (:,:,iblk),  &amp;
<a name="l00623"></a>00623                                xyav   (:,:,iblk),  yyav   (:,:,iblk),  &amp;
<a name="l00624"></a>00624                                xxxav  (:,:,iblk),  xxyav  (:,:,iblk),  &amp;
<a name="l00625"></a>00625                                xyyav  (:,:,iblk),  yyyav  (:,:,iblk),  &amp;
<a name="l00626"></a>00626 <span class="comment">!                               dxt    (:,:,iblk),  dyt    (:,:,iblk),  &amp;</span>
<a name="l00627"></a>00627                                workc       (:,:),  workd       (:,:),  &amp;
<a name="l00628"></a>00628                                mm   (:,:,0,iblk),  mc   (:,:,0,iblk),  &amp;
<a name="l00629"></a>00629                                mx   (:,:,0,iblk),  my   (:,:,0,iblk),  &amp;
<a name="l00630"></a>00630                                mmask(:,:,0,iblk) )
<a name="l00631"></a>00631 
<a name="l00632"></a>00632          <span class="comment">! ice categories</span>
<a name="l00633"></a>00633 
<a name="l00634"></a>00634          <span class="keyword">do</span> n = 1, <a class="code" href="namespaceice__domain__size.html#af6426e75baee1427e99bac2564d5afd7">ncat</a>
<a name="l00635"></a>00635 
<a name="l00636"></a>00636             call <a class="code" href="namespaceice__transport__remap.html#a4c7f753ed3abe19124a7e719e3424dae">construct_fields</a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,             <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,           &amp;
<a name="l00637"></a>00637                                   ilo, ihi,             jlo, jhi,           &amp;
<a name="l00638"></a>00638                                   <a class="code" href="namespaceice__blocks.html#a75dd0bf2d3d80ac626a1effa70f77a35">nghost</a>,                                   &amp;
<a name="l00639"></a>00639                                   tracer_type,          depend,             &amp;
<a name="l00640"></a>00640                                   has_dependents,       icellsnc (n,iblk),  &amp;
<a name="l00641"></a>00641                                   indxinc  (:,n,iblk),  indxjnc(:,n,iblk),  &amp;
<a name="l00642"></a>00642 <span class="comment">!                                  HTN      (:,:,iblk),  HTE    (:,:,iblk),  &amp;</span>
<a name="l00643"></a>00643                                   worka         (:,:),  workb       (:,:),  &amp;
<a name="l00644"></a>00644                                   hm       (:,:,iblk),  xav    (:,:,iblk),  &amp;
<a name="l00645"></a>00645                                   yav      (:,:,iblk),  xxav   (:,:,iblk),  &amp;
<a name="l00646"></a>00646                                   xyav     (:,:,iblk),  yyav   (:,:,iblk),  &amp;
<a name="l00647"></a>00647                                   xxxav    (:,:,iblk),  xxyav  (:,:,iblk),  &amp;
<a name="l00648"></a>00648                                   xyyav    (:,:,iblk),  yyyav  (:,:,iblk),  &amp;
<a name="l00649"></a>00649 <span class="comment">!                                  dxt      (:,:,iblk),  dyt   (:,:,iblk),   &amp;</span>
<a name="l00650"></a>00650                                   workc         (:,:),  workd       (:,:),  &amp;
<a name="l00651"></a>00651                                   mm     (:,:,n,iblk),  mc   (:,:,n,iblk),  &amp;
<a name="l00652"></a>00652                                   mx     (:,:,n,iblk),  my   (:,:,n,iblk),  &amp;
<a name="l00653"></a>00653                                   mmask  (:,:,n,iblk),                      &amp;
<a name="l00654"></a>00654                                   tm   (:,:,:,n,iblk),  tc (:,:,:,n,iblk),  &amp;
<a name="l00655"></a>00655                                   tx   (:,:,:,n,iblk),  ty (:,:,:,n,iblk),  &amp;
<a name="l00656"></a>00656                                   tmask(:,:,:,n,iblk) )
<a name="l00657"></a>00657 
<a name="l00658"></a>00658          <span class="keyword">enddo</span>                  <span class="comment">! n</span>
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00661"></a>00661     <span class="comment">! Given velocity field at cell corners, compute departure points</span>
<a name="l00662"></a>00662     <span class="comment">! of trajectories.</span>
<a name="l00663"></a>00663     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00664"></a>00664 
<a name="l00665"></a>00665          call <a class="code" href="namespaceice__transport__remap.html#a6b993110f808c259c52b05216684684f">departure_points</a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,        <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,        &amp;
<a name="l00666"></a>00666                                ilo, ihi,        jlo, jhi,        &amp;
<a name="l00667"></a>00667                                <a class="code" href="namespaceice__blocks.html#a75dd0bf2d3d80ac626a1effa70f77a35">nghost</a>,          dt,              &amp;
<a name="l00668"></a>00668                                uvel(:,:,iblk),  vvel(:,:,iblk),  &amp;
<a name="l00669"></a>00669                                <a class="code" href="namespaceice__grid.html#a9fecdcb5623bfc308ef4f2ddb4d284b6">dxu </a>(:,:,iblk),  <a class="code" href="namespaceice__grid.html#ad2b38c10d13244b2b4da1e461c2ef207">dyu </a>(:,:,iblk),  &amp;
<a name="l00670"></a>00670                                <a class="code" href="namespaceice__grid.html#a6d5e0411ab66c52d72c0bcc75f794eab">HTN </a>(:,:,iblk),  <a class="code" href="namespaceice__grid.html#a881253aa819ce18c46c4bffb3d558616">HTE </a>(:,:,iblk),  &amp;
<a name="l00671"></a>00671                                dpx (:,:,iblk),  dpy (:,:,iblk),  &amp;
<a name="l00672"></a>00672                                l_dp_midpt,      l_stop  (iblk),  &amp;
<a name="l00673"></a>00673                                istop   (iblk),  jstop   (iblk))
<a name="l00674"></a>00674 
<a name="l00675"></a>00675          <span class="keyword">if</span> (l_stop(iblk)) <span class="keyword">then</span>
<a name="l00676"></a>00676             this_block = <a class="code" href="namespaceice__blocks.html#aa79bfef5022683234ed1b332af17f1de">get_block</a>(<a class="code" href="namespaceice__domain.html#a152cf5087ce1dccce8f5e147306320ae">blocks_ice</a>(iblk),iblk)         
<a name="l00677"></a>00677             <span class="keyword">write</span>(<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;istep1, my_task, iblk =&apos;</span>,            &amp;
<a name="l00678"></a>00678                               <a class="code" href="namespaceice__calendar.html#a56f19d1b69c0acd3d8fd3a6f06855e48">istep1</a>, <a class="code" href="namespaceice__communicate.html#a70e729e746e2e5ec592ccba505136002">my_task</a>, iblk
<a name="l00679"></a>00679             <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;Global block:&apos;</span>, this_block%block_id
<a name="l00680"></a>00680             <span class="keyword">if</span> (istop(iblk) &gt; 0 .and. jstop(iblk) &gt; 0)             &amp;
<a name="l00681"></a>00681                  <span class="keyword">write</span>(<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;Global i and j:&apos;</span>,               &amp;
<a name="l00682"></a>00682                                   this_block%i_glob(istop(iblk)),  &amp;
<a name="l00683"></a>00683                                   this_block%j_glob(jstop(iblk)) 
<a name="l00684"></a>00684             call <a class="code" href="namespaceice__exit.html#a3fcf77109320e75f1268f41fe212d789">abort_ice</a>(<span class="stringliteral">&apos;remap transport: bad departure points&apos;</span>)
<a name="l00685"></a>00685          <span class="keyword">endif</span>
<a name="l00686"></a>00686 
<a name="l00687"></a>00687       <span class="keyword">enddo</span>                     <span class="comment">! iblk</span>
<a name="l00688"></a>00688       <span class="comment">!$OMP END PARALLEL DO</span>
<a name="l00689"></a>00689 
<a name="l00690"></a>00690 <span class="comment">!     call t_stopf (&apos;cice_dyn_remap1&apos;)</span>
<a name="l00691"></a>00691     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00692"></a>00692     <span class="comment">! Ghost cell updates</span>
<a name="l00693"></a>00693     <span class="comment">! If nghost &gt;= 2, these calls are not needed</span>
<a name="l00694"></a>00694     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00695"></a>00695 
<a name="l00696"></a>00696       <span class="keyword">if</span> (<a class="code" href="namespaceice__blocks.html#a75dd0bf2d3d80ac626a1effa70f77a35">nghost</a>==1) <span class="keyword">then</span>
<a name="l00697"></a>00697 
<a name="l00698"></a>00698 <span class="comment">!        call t_barrierf (&apos;cice_dyn_remap_update1_BARRIER&apos;,MPI_COMM_ICE)</span>
<a name="l00699"></a>00699 <span class="comment">!        call t_startf (&apos;cice_dyn_remap_update1&apos;)</span>
<a name="l00700"></a>00700          call <a class="code" href="namespaceice__timers.html#a308c3af934358cb1f050df7cce19ce79">ice_timer_start</a>(timer_bound)
<a name="l00701"></a>00701 
<a name="l00702"></a>00702          <span class="comment">! departure points</span>
<a name="l00703"></a>00703 
<a name="l00704"></a>00704          <span class="comment">! load em up</span>
<a name="l00705"></a>00705          <span class="comment">!$OMP PARALLEL DO PRIVATE(iblk,i,j)</span>
<a name="l00706"></a>00706          <span class="keyword">do</span> iblk = 1, <a class="code" href="namespaceice__domain.html#aae3d2de717ee7a743c9635b3a9e35a95">nblocks</a>
<a name="l00707"></a>00707             <span class="keyword">do</span> j = 1, <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>
<a name="l00708"></a>00708             <span class="keyword">do</span> i = 1, <a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>
<a name="l00709"></a>00709               dpwork(i,j,1,  iblk) = dpx(i,j,iblk)
<a name="l00710"></a>00710               dpwork(i,j,2,  iblk) = dpy(i,j,iblk)
<a name="l00711"></a>00711               mwork (i,j,1,:,iblk) = mx (i,j,:,iblk)
<a name="l00712"></a>00712               mwork (i,j,2,:,iblk) = my (i,j,:,iblk)
<a name="l00713"></a>00713             <span class="keyword">enddo</span>
<a name="l00714"></a>00714             <span class="keyword">enddo</span>
<a name="l00715"></a>00715          <span class="keyword">enddo</span>
<a name="l00716"></a>00716          <span class="comment">!$OMP END PARALLEL DO</span>
<a name="l00717"></a>00717 <span class="comment">!jw         call ice_HaloUpdate (dpx,                halo_info, &amp;</span>
<a name="l00718"></a>00718 <span class="comment">!jw                              field_loc_NEcorner, field_type_vector)</span>
<a name="l00719"></a>00719 <span class="comment">!jw         call ice_HaloUpdate (dpy,                halo_info, &amp;</span>
<a name="l00720"></a>00720 <span class="comment">!jw                              field_loc_NEcorner, field_type_vector)</span>
<a name="l00721"></a>00721          call ice_HaloUpdate (dpwork,             <a class="code" href="namespaceice__domain.html#a06df1ee3a618bfdd4e7f6445a5376604">halo_info</a>, &amp;
<a name="l00722"></a>00722                               <a class="code" href="namespaceice__constants.html#a6b38e42de787f72eabe064f976338775">field_loc_NEcorner</a>, <a class="code" href="namespaceice__constants.html#abd07ef2bb17edc4fea6e1fc901ab89f8">field_type_vector</a>)
<a name="l00723"></a>00723 
<a name="l00724"></a>00724          <span class="comment">! mass field</span>
<a name="l00725"></a>00725          call ice_HaloUpdate (mc,               <a class="code" href="namespaceice__domain.html#a06df1ee3a618bfdd4e7f6445a5376604">halo_info</a>, &amp;
<a name="l00726"></a>00726                               <a class="code" href="namespaceice__constants.html#a4c526a105da0fa08ad1877e55f6d60fc">field_loc_center</a>, <a class="code" href="namespaceice__constants.html#a98992b4bfb499ea1f7a0f6037c17a100">field_type_scalar</a>)
<a name="l00727"></a>00727 <span class="comment">!jw         call ice_HaloUpdate (mx,               halo_info, &amp;</span>
<a name="l00728"></a>00728 <span class="comment">!jw                              field_loc_center, field_type_vector)</span>
<a name="l00729"></a>00729 <span class="comment">!jw         call ice_HaloUpdate (my,               halo_info, &amp;</span>
<a name="l00730"></a>00730 <span class="comment">!jw                              field_loc_center, field_type_vector)</span>
<a name="l00731"></a>00731          call ice_HaloUpdate (mwork,            <a class="code" href="namespaceice__domain.html#a06df1ee3a618bfdd4e7f6445a5376604">halo_info</a>, &amp;
<a name="l00732"></a>00732                               <a class="code" href="namespaceice__constants.html#a4c526a105da0fa08ad1877e55f6d60fc">field_loc_center</a>, <a class="code" href="namespaceice__constants.html#abd07ef2bb17edc4fea6e1fc901ab89f8">field_type_vector</a>)
<a name="l00733"></a>00733 
<a name="l00734"></a>00734          <span class="comment">!$OMP PARALLEL DO PRIVATE(iblk,i,j)</span>
<a name="l00735"></a>00735          <span class="keyword">do</span> iblk = 1, <a class="code" href="namespaceice__domain.html#aae3d2de717ee7a743c9635b3a9e35a95">nblocks</a>
<a name="l00736"></a>00736             <span class="keyword">do</span> j = 1, <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>
<a name="l00737"></a>00737             <span class="keyword">do</span> i = 1, <a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>
<a name="l00738"></a>00738               dpx(i,j,  iblk) = dpwork(i,j,1,  iblk)
<a name="l00739"></a>00739               dpy(i,j,  iblk) = dpwork(i,j,2,  iblk)
<a name="l00740"></a>00740               mx (i,j,:,iblk) = mwork (i,j,1,:,iblk)
<a name="l00741"></a>00741               my (i,j,:,iblk) = mwork (i,j,2,:,iblk)
<a name="l00742"></a>00742             <span class="keyword">enddo</span>
<a name="l00743"></a>00743             <span class="keyword">enddo</span>
<a name="l00744"></a>00744          <span class="keyword">enddo</span>
<a name="l00745"></a>00745          <span class="comment">!$OMP END PARALLEL DO</span>
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <span class="comment">!        call t_stopf (&apos;cice_dyn_remap_update1&apos;)</span>
<a name="l00748"></a>00748 <span class="comment">!        call t_barrierf (&apos;cice_dyn_remap_update2_BARRIER&apos;,MPI_COMM_ICE)</span>
<a name="l00749"></a>00749 <span class="comment">!        call t_startf (&apos;cice_dyn_remap_update2&apos;)</span>
<a name="l00750"></a>00750 
<a name="l00751"></a>00751          <span class="comment">! tracer fields</span>
<a name="l00752"></a>00752          call ice_HaloUpdate (tc,               <a class="code" href="namespaceice__domain.html#a06df1ee3a618bfdd4e7f6445a5376604">halo_info</a>, &amp;
<a name="l00753"></a>00753                               <a class="code" href="namespaceice__constants.html#a4c526a105da0fa08ad1877e55f6d60fc">field_loc_center</a>, <a class="code" href="namespaceice__constants.html#a98992b4bfb499ea1f7a0f6037c17a100">field_type_scalar</a>)
<a name="l00754"></a>00754          call ice_HaloUpdate (tx,               <a class="code" href="namespaceice__domain.html#a06df1ee3a618bfdd4e7f6445a5376604">halo_info</a>, &amp;
<a name="l00755"></a>00755                               <a class="code" href="namespaceice__constants.html#a4c526a105da0fa08ad1877e55f6d60fc">field_loc_center</a>, <a class="code" href="namespaceice__constants.html#abd07ef2bb17edc4fea6e1fc901ab89f8">field_type_vector</a>)
<a name="l00756"></a>00756          call ice_HaloUpdate (ty,               <a class="code" href="namespaceice__domain.html#a06df1ee3a618bfdd4e7f6445a5376604">halo_info</a>, &amp;
<a name="l00757"></a>00757                               <a class="code" href="namespaceice__constants.html#a4c526a105da0fa08ad1877e55f6d60fc">field_loc_center</a>, <a class="code" href="namespaceice__constants.html#abd07ef2bb17edc4fea6e1fc901ab89f8">field_type_vector</a>)
<a name="l00758"></a>00758          call <a class="code" href="namespaceice__timers.html#ab483bb3b29e1839baf5a6bc2ad720ca8">ice_timer_stop</a>(timer_bound)
<a name="l00759"></a>00759 <span class="comment">!        call t_stopf (&apos;cice_dyn_remap_update2&apos;)</span>
<a name="l00760"></a>00760 
<a name="l00761"></a>00761       <span class="keyword">endif</span>  <span class="comment">! nghost</span>
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 <span class="comment">!     call t_barrierf (&apos;cice_dyn_remap2_BARRIER&apos;,MPI_COMM_ICE)</span>
<a name="l00764"></a>00764 <span class="comment">!     call t_startf (&apos;cice_dyn_remap2&apos;)</span>
<a name="l00765"></a>00765 
<a name="l00766"></a>00766       <span class="comment">!$OMP PARALLEL DO PRIVATE(iblk,this_block,ilo,ihi,jlo,jhi,n)</span>
<a name="l00767"></a>00767       <span class="keyword">do</span> iblk = 1, <a class="code" href="namespaceice__domain.html#aae3d2de717ee7a743c9635b3a9e35a95">nblocks</a>
<a name="l00768"></a>00768 
<a name="l00769"></a>00769          this_block = <a class="code" href="namespaceice__blocks.html#aa79bfef5022683234ed1b332af17f1de">get_block</a>(<a class="code" href="namespaceice__domain.html#a152cf5087ce1dccce8f5e147306320ae">blocks_ice</a>(iblk),iblk)         
<a name="l00770"></a>00770          ilo = this_block%ilo
<a name="l00771"></a>00771          ihi = this_block%ihi
<a name="l00772"></a>00772          jlo = this_block%jlo
<a name="l00773"></a>00773          jhi = this_block%jhi
<a name="l00774"></a>00774 
<a name="l00775"></a>00775     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00776"></a>00776     <span class="comment">! Transports for east cell edges.</span>
<a name="l00777"></a>00777     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00778"></a>00778 
<a name="l00779"></a>00779     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00780"></a>00780     <span class="comment">! Compute areas and vertices of departure triangles.</span>
<a name="l00781"></a>00781     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00782"></a>00782 
<a name="l00783"></a>00783          edge(iblk) = <span class="stringliteral">&apos;east&apos;</span>
<a name="l00784"></a>00784          call <a class="code" href="namespaceice__transport__remap.html#a5ed79661ddd56d26d4e863b7ec1b9a0a">locate_triangles</a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,              <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,           &amp;
<a name="l00785"></a>00785                                ilo, ihi,              jlo, jhi,           &amp;
<a name="l00786"></a>00786                                <a class="code" href="namespaceice__blocks.html#a75dd0bf2d3d80ac626a1effa70f77a35">nghost</a>,                edge(iblk),         &amp;
<a name="l00787"></a>00787                                icellsng    (:,iblk),                      &amp;
<a name="l00788"></a>00788                                indxing   (:,:,iblk),  indxjng(:,:,iblk),  &amp;
<a name="l00789"></a>00789                                dpx       (:,:,iblk),  dpy    (:,:,iblk),  &amp;
<a name="l00790"></a>00790                                <a class="code" href="namespaceice__grid.html#a9fecdcb5623bfc308ef4f2ddb4d284b6">dxu       </a>(:,:,iblk),  <a class="code" href="namespaceice__grid.html#ad2b38c10d13244b2b4da1e461c2ef207">dyu    </a>(:,:,iblk),  &amp;
<a name="l00791"></a>00791                                xp    (:,:,:,:,iblk),  yp (:,:,:,:,iblk),  &amp;
<a name="l00792"></a>00792                                iflux   (:,:,:,iblk),  jflux(:,:,:,iblk),  &amp;
<a name="l00793"></a>00793                                triarea (:,:,:,iblk),  l_fixed_area,       &amp;
<a name="l00794"></a>00794                                edgearea_e(:,:,iblk))
<a name="l00795"></a>00795 
<a name="l00796"></a>00796     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00797"></a>00797     <span class="comment">! Given triangle vertices, compute coordinates of triangle points</span>
<a name="l00798"></a>00798     <span class="comment">!  needed for transport integrals.</span>
<a name="l00799"></a>00799     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00800"></a>00800 
<a name="l00801"></a>00801          call <a class="code" href="namespaceice__transport__remap.html#a0118e9be4eed6545abe6b6d08ebea458">triangle_coordinates </a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,           <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,           &amp;
<a name="l00802"></a>00802                                     integral_order,     icellsng (:,iblk),  &amp;
<a name="l00803"></a>00803                                     indxing(:,:,iblk),  indxjng(:,:,iblk),  &amp;
<a name="l00804"></a>00804                                     xp (:,:,:,:,iblk),  yp (:,:,:,:,iblk))
<a name="l00805"></a>00805 
<a name="l00806"></a>00806     <span class="comment">! Compute the transport across east cell edges by summing contributions</span>
<a name="l00807"></a>00807     <span class="comment">! from each triangle.</span>
<a name="l00808"></a>00808     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00809"></a>00809 
<a name="l00810"></a>00810          <span class="comment">! open water</span>
<a name="l00811"></a>00811 
<a name="l00812"></a>00812          call <a class="code" href="namespaceice__transport__remap.html#a36c63f1390ec491939f47e64dab35e1e">transport_integrals</a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,           <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,             &amp;
<a name="l00813"></a>00813                                   icellsng (:,iblk),                        &amp;
<a name="l00814"></a>00814                                   indxing(:,:,iblk),  indxjng  (:,:,iblk),  &amp;
<a name="l00815"></a>00815                                   tracer_type,        depend,               &amp;
<a name="l00816"></a>00816                                   integral_order,     triarea(:,:,:,iblk),  &amp;
<a name="l00817"></a>00817                                   iflux(:,:,:,iblk),  jflux  (:,:,:,iblk),  &amp;
<a name="l00818"></a>00818                                   xp (:,:,:,:,iblk),  yp   (:,:,:,:,iblk),  &amp;
<a name="l00819"></a>00819                                   mc   (:,:,0,iblk),  mx     (:,:,0,iblk),  &amp;
<a name="l00820"></a>00820                                   my   (:,:,0,iblk),  mflxe  (:,:,0,iblk))
<a name="l00821"></a>00821 
<a name="l00822"></a>00822          <span class="comment">! ice categories</span>
<a name="l00823"></a>00823          <span class="keyword">do</span> n = 1, <a class="code" href="namespaceice__domain__size.html#af6426e75baee1427e99bac2564d5afd7">ncat</a>
<a name="l00824"></a>00824             call <a class="code" href="namespaceice__transport__remap.html#a36c63f1390ec491939f47e64dab35e1e">transport_integrals</a>                                       &amp;
<a name="l00825"></a>00825                                (<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,           <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,              &amp;
<a name="l00826"></a>00826                                 icellsng (:,iblk),                         &amp;
<a name="l00827"></a>00827                                 indxing(:,:,iblk),  indxjng   (:,:,iblk),  &amp;
<a name="l00828"></a>00828                                 tracer_type,        depend,                &amp;
<a name="l00829"></a>00829                                 integral_order,     triarea (:,:,:,iblk),  &amp;
<a name="l00830"></a>00830                                 iflux(:,:,:,iblk),  jflux   (:,:,:,iblk),  &amp;
<a name="l00831"></a>00831                                 xp (:,:,:,:,iblk),  yp    (:,:,:,:,iblk),  &amp;
<a name="l00832"></a>00832                                 mc   (:,:,n,iblk),  mx      (:,:,n,iblk),  &amp;
<a name="l00833"></a>00833                                 my   (:,:,n,iblk),  mflxe   (:,:,n,iblk),  &amp;
<a name="l00834"></a>00834                                 tc (:,:,:,n,iblk),  tx    (:,:,:,n,iblk),  &amp;
<a name="l00835"></a>00835                                 ty (:,:,:,n,iblk),  mtflxe(:,:,:,n,iblk))
<a name="l00836"></a>00836 
<a name="l00837"></a>00837          <span class="keyword">enddo</span>
<a name="l00838"></a>00838 
<a name="l00839"></a>00839     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00840"></a>00840     <span class="comment">! Repeat for north edges</span>
<a name="l00841"></a>00841     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00842"></a>00842 
<a name="l00843"></a>00843          edge(iblk) = <span class="stringliteral">&apos;north&apos;</span>
<a name="l00844"></a>00844          call <a class="code" href="namespaceice__transport__remap.html#a5ed79661ddd56d26d4e863b7ec1b9a0a">locate_triangles</a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,              <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,           &amp;
<a name="l00845"></a>00845                                ilo, ihi,              jlo, jhi,           &amp;
<a name="l00846"></a>00846                                <a class="code" href="namespaceice__blocks.html#a75dd0bf2d3d80ac626a1effa70f77a35">nghost</a>,                edge(iblk),         &amp;
<a name="l00847"></a>00847                                icellsng    (:,iblk),                      &amp;
<a name="l00848"></a>00848                                indxing   (:,:,iblk),  indxjng(:,:,iblk),  &amp;
<a name="l00849"></a>00849                                dpx       (:,:,iblk),  dpy    (:,:,iblk),  &amp;
<a name="l00850"></a>00850                                <a class="code" href="namespaceice__grid.html#a9fecdcb5623bfc308ef4f2ddb4d284b6">dxu       </a>(:,:,iblk),  <a class="code" href="namespaceice__grid.html#ad2b38c10d13244b2b4da1e461c2ef207">dyu    </a>(:,:,iblk),  &amp;
<a name="l00851"></a>00851                                xp    (:,:,:,:,iblk),  yp (:,:,:,:,iblk),  &amp;
<a name="l00852"></a>00852                                iflux   (:,:,:,iblk),  jflux(:,:,:,iblk),  &amp;
<a name="l00853"></a>00853                                triarea (:,:,:,iblk),  l_fixed_area,       &amp;
<a name="l00854"></a>00854                                edgearea_n(:,:,iblk))
<a name="l00855"></a>00855 
<a name="l00856"></a>00856          call <a class="code" href="namespaceice__transport__remap.html#a0118e9be4eed6545abe6b6d08ebea458">triangle_coordinates </a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,           <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,           &amp;
<a name="l00857"></a>00857                                     integral_order,     icellsng (:,iblk),  &amp;
<a name="l00858"></a>00858                                     indxing(:,:,iblk),  indxjng(:,:,iblk),  &amp;
<a name="l00859"></a>00859                                     xp (:,:,:,:,iblk),  yp (:,:,:,:,iblk))
<a name="l00860"></a>00860 
<a name="l00861"></a>00861          <span class="comment">! open water</span>
<a name="l00862"></a>00862          call <a class="code" href="namespaceice__transport__remap.html#a36c63f1390ec491939f47e64dab35e1e">transport_integrals</a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,           <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,             &amp;
<a name="l00863"></a>00863                                   icellsng (:,iblk),                        &amp;
<a name="l00864"></a>00864                                   indxing(:,:,iblk),  indxjng(:,:,iblk),    &amp;
<a name="l00865"></a>00865                                   tracer_type,        depend,               &amp;
<a name="l00866"></a>00866                                   integral_order,     triarea(:,:,:,iblk),  &amp;
<a name="l00867"></a>00867                                   iflux(:,:,:,iblk),  jflux  (:,:,:,iblk),  &amp;
<a name="l00868"></a>00868                                   xp (:,:,:,:,iblk),  yp   (:,:,:,:,iblk),  &amp;
<a name="l00869"></a>00869                                   mc   (:,:,0,iblk),  mx     (:,:,0,iblk),  &amp;
<a name="l00870"></a>00870                                   my   (:,:,0,iblk),  mflxn  (:,:,0,iblk))
<a name="l00871"></a>00871 
<a name="l00872"></a>00872          <span class="comment">! ice categories</span>
<a name="l00873"></a>00873          <span class="keyword">do</span> n = 1, <a class="code" href="namespaceice__domain__size.html#af6426e75baee1427e99bac2564d5afd7">ncat</a>
<a name="l00874"></a>00874             call <a class="code" href="namespaceice__transport__remap.html#a36c63f1390ec491939f47e64dab35e1e">transport_integrals</a>                                       &amp;
<a name="l00875"></a>00875                                (<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,           <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,              &amp;
<a name="l00876"></a>00876                                 icellsng (:,iblk),                         &amp;
<a name="l00877"></a>00877                                 indxing(:,:,iblk),  indxjng   (:,:,iblk),  &amp;
<a name="l00878"></a>00878                                 tracer_type,        depend,                &amp;
<a name="l00879"></a>00879                                 integral_order,     triarea (:,:,:,iblk),  &amp;
<a name="l00880"></a>00880                                 iflux(:,:,:,iblk),  jflux   (:,:,:,iblk),  &amp;
<a name="l00881"></a>00881                                 xp (:,:,:,:,iblk),  yp    (:,:,:,:,iblk),  &amp;
<a name="l00882"></a>00882                                 mc   (:,:,n,iblk),  mx      (:,:,n,iblk),  &amp;
<a name="l00883"></a>00883                                 my   (:,:,n,iblk),  mflxn   (:,:,n,iblk),  &amp;
<a name="l00884"></a>00884                                 tc (:,:,:,n,iblk),  tx    (:,:,:,n,iblk),  &amp;
<a name="l00885"></a>00885                                 ty (:,:,:,n,iblk),  mtflxn(:,:,:,n,iblk))
<a name="l00886"></a>00886 
<a name="l00887"></a>00887          <span class="keyword">enddo</span>                  <span class="comment">! n</span>
<a name="l00888"></a>00888 
<a name="l00889"></a>00889     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00890"></a>00890     <span class="comment">! Update the ice area and tracers.</span>
<a name="l00891"></a>00891     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l00892"></a>00892 
<a name="l00893"></a>00893          <span class="comment">! open water</span>
<a name="l00894"></a>00894 
<a name="l00895"></a>00895          call <a class="code" href="namespaceice__transport__remap.html#a2f57bc59a0a273bc0c6aff4104b094c0">update_fields </a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,           <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,          &amp;
<a name="l00896"></a>00896                              ilo, ihi,           jlo, jhi,          &amp;
<a name="l00897"></a>00897                              tracer_type,        depend,            &amp;
<a name="l00898"></a>00898                              tarear(:,:,iblk),   l_stop(iblk),      &amp;
<a name="l00899"></a>00899                              istop(iblk),        jstop (iblk),      &amp;
<a name="l00900"></a>00900                              mflxe(:,:,0,iblk),  mflxn(:,:,0,iblk), &amp;
<a name="l00901"></a>00901                              mm   (:,:,0,iblk))
<a name="l00902"></a>00902 
<a name="l00903"></a>00903          <span class="keyword">if</span> (l_stop(iblk)) <span class="keyword">then</span>
<a name="l00904"></a>00904             this_block = <a class="code" href="namespaceice__blocks.html#aa79bfef5022683234ed1b332af17f1de">get_block</a>(<a class="code" href="namespaceice__domain.html#a152cf5087ce1dccce8f5e147306320ae">blocks_ice</a>(iblk),iblk)         
<a name="l00905"></a>00905             <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;istep1, my_task, iblk, cat =&apos;</span>,      &amp;
<a name="l00906"></a>00906                                <a class="code" href="namespaceice__calendar.html#a56f19d1b69c0acd3d8fd3a6f06855e48">istep1</a>, <a class="code" href="namespaceice__communicate.html#a70e729e746e2e5ec592ccba505136002">my_task</a>, iblk, <span class="stringliteral">&apos;0&apos;</span>
<a name="l00907"></a>00907             <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;Global block:&apos;</span>, this_block%block_id
<a name="l00908"></a>00908             <span class="keyword">if</span> (istop(iblk) &gt; 0 .and. jstop(iblk) &gt; 0)             &amp;
<a name="l00909"></a>00909                  <span class="keyword">write</span>(<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;Global i and j:&apos;</span>,               &amp;
<a name="l00910"></a>00910                                   this_block%i_glob(istop(iblk)),  &amp;
<a name="l00911"></a>00911                                   this_block%j_glob(jstop(iblk)) 
<a name="l00912"></a>00912             call <a class="code" href="namespaceice__exit.html#a3fcf77109320e75f1268f41fe212d789">abort_ice </a>(<span class="stringliteral">&apos;ice remap_transport: negative area (open water)&apos;</span>)
<a name="l00913"></a>00913          <span class="keyword">endif</span>
<a name="l00914"></a>00914 
<a name="l00915"></a>00915 
<a name="l00916"></a>00916          <span class="comment">! ice categories</span>
<a name="l00917"></a>00917          <span class="keyword">do</span> n = 1, <a class="code" href="namespaceice__domain__size.html#af6426e75baee1427e99bac2564d5afd7">ncat</a>
<a name="l00918"></a>00918 
<a name="l00919"></a>00919             call <a class="code" href="namespaceice__transport__remap.html#a2f57bc59a0a273bc0c6aff4104b094c0">update_fields</a>(<a class="code" href="namespaceice__blocks.html#a130f3f9b102e86de209ee25eb36e44ba">nx_block</a>,              <a class="code" href="namespaceice__blocks.html#a9ad40e7eeb19aeb81a3010e0dd997c43">ny_block</a>,              &amp;
<a name="l00920"></a>00920                                ilo, ihi,              jlo, jhi,              &amp;
<a name="l00921"></a>00921                                tracer_type,           depend,                &amp;
<a name="l00922"></a>00922                                tarear(:,:,iblk),      l_stop(iblk),          &amp;
<a name="l00923"></a>00923                                istop(iblk),           jstop(iblk),           &amp;
<a name="l00924"></a>00924                                mflxe (:,:,  n,iblk),  mflxn (:,:,  n,iblk),  &amp;
<a name="l00925"></a>00925                                mm    (:,:,  n,iblk),                         &amp;
<a name="l00926"></a>00926                                mtflxe(:,:,:,n,iblk),  mtflxn(:,:,:,n,iblk),  &amp;
<a name="l00927"></a>00927                                tm    (:,:,:,n,iblk))
<a name="l00928"></a>00928 
<a name="l00929"></a>00929             <span class="keyword">if</span> (l_stop(iblk)) <span class="keyword">then</span>
<a name="l00930"></a>00930                this_block = <a class="code" href="namespaceice__blocks.html#aa79bfef5022683234ed1b332af17f1de">get_block</a>(<a class="code" href="namespaceice__domain.html#a152cf5087ce1dccce8f5e147306320ae">blocks_ice</a>(iblk),iblk)         
<a name="l00931"></a>00931                <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;istep1, my_task, iblk, cat =&apos;</span>,      &amp;
<a name="l00932"></a>00932                                   <a class="code" href="namespaceice__calendar.html#a56f19d1b69c0acd3d8fd3a6f06855e48">istep1</a>, <a class="code" href="namespaceice__communicate.html#a70e729e746e2e5ec592ccba505136002">my_task</a>, iblk, n
<a name="l00933"></a>00933                <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;Global block:&apos;</span>, this_block%block_id
<a name="l00934"></a>00934                <span class="keyword">if</span> (istop(iblk) &gt; 0 .and. jstop(iblk) &gt; 0)             &amp;
<a name="l00935"></a>00935                     <span class="keyword">write</span>(<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;Global i and j:&apos;</span>,               &amp;
<a name="l00936"></a>00936                                      this_block%i_glob(istop(iblk)),  &amp;
<a name="l00937"></a>00937                                      this_block%j_glob(jstop(iblk)) 
<a name="l00938"></a>00938                call <a class="code" href="namespaceice__exit.html#a3fcf77109320e75f1268f41fe212d789">abort_ice </a>(<span class="stringliteral">&apos;ice remap_transport: negative area (ice)&apos;</span>)
<a name="l00939"></a>00939             <span class="keyword">endif</span>
<a name="l00940"></a>00940          <span class="keyword">enddo</span>                  <span class="comment">! n</span>
<a name="l00941"></a>00941 
<a name="l00942"></a>00942       <span class="keyword">enddo</span>                     <span class="comment">! iblk</span>
<a name="l00943"></a>00943       <span class="comment">!$OMP END PARALLEL DO</span>
<a name="l00944"></a>00944 
<a name="l00945"></a>00945 <span class="comment">!     call t_stopf (&apos;cice_dyn_remap2&apos;)</span>
<a name="l00946"></a>00946 
<a name="l00947"></a>00947 <span class="keyword">      end subroutine horizontal_remap</span>
<a name="l00948"></a>00948 
<a name="l00949"></a>00949 <span class="comment">!=======================================================================</span>
<a name="l00950"></a>00950 <span class="comment">!</span>
<a name="l00951"></a>00951 <span class="comment">!BOP</span>
<a name="l00952"></a>00952 <span class="comment">!</span>
<a name="l00953"></a>00953 <span class="comment">! !IROUTINE: make_masks - make area and tracer masks</span>
<a name="l00954"></a>00954 <span class="comment">!</span>
<a name="l00955"></a>00955 <span class="comment">! !INTERFACE:</span>
<a name="l00956"></a>00956 <span class="comment">!</span>
<a name="l00957"></a><a class="code" href="namespaceice__transport__remap.html#a9a9fe0af7f01eed20d6df09ed2e8dc2a">00957</a>       <span class="keyword">subroutine </span><a class="code" href="namespaceice__transport__remap.html#a9a9fe0af7f01eed20d6df09ed2e8dc2a">make_masks</a> (nx_block, ny_block,           &amp;
<a name="l00958"></a>00958                              ilo, ihi, jlo, jhi,           &amp;
<a name="l00959"></a>00959                              nghost,   has_dependents,     &amp;
<a name="l00960"></a>00960                              icells,                       &amp;
<a name="l00961"></a>00961                              indxi,    indxj,              &amp;
<a name="l00962"></a>00962                              mm,       mmask,              &amp;
<a name="l00963"></a>00963                              tm,       tmask)
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="comment">!</span>
<a name="l00966"></a>00966 <span class="comment">! !DESCRIPTION:</span>
<a name="l00967"></a>00967 <span class="comment">!</span>
<a name="l00968"></a>00968 <span class="comment">! Make area and tracer masks.</span>
<a name="l00969"></a>00969 <span class="comment">!</span>
<a name="l00970"></a>00970 <span class="comment">! If an area is masked out (mm &lt; puny), then the values of tracers</span>
<a name="l00971"></a>00971 <span class="comment">!  in that grid cell are assumed to have no physical meaning.</span>
<a name="l00972"></a>00972 <span class="comment">!</span>
<a name="l00973"></a>00973 <span class="comment">! Similarly, if a tracer with dependents is masked out</span>
<a name="l00974"></a>00974 <span class="comment">!  (abs(tm) &lt; puny), then the values of its dependent tracers in that</span>
<a name="l00975"></a>00975 <span class="comment">!  grid cell are assumed to have no physical meaning.</span>
<a name="l00976"></a>00976 <span class="comment">! For example, the enthalpy value has no meaning if the thickness</span>
<a name="l00977"></a>00977 <span class="comment">!  is zero.</span>
<a name="l00978"></a>00978 <span class="comment">!</span>
<a name="l00979"></a>00979 <span class="comment">! !REVISION HISTORY:</span>
<a name="l00980"></a>00980 <span class="comment">!</span>
<a name="l00981"></a>00981 <span class="comment">! author William H. Lipscomb, LANL</span>
<a name="l00982"></a>00982 <span class="comment">!</span>
<a name="l00983"></a>00983 <span class="comment">! !USES:</span>
<a name="l00984"></a>00984 <span class="comment">!</span>
<a name="l00985"></a>00985 <span class="comment">! !INPUT/OUTPUT PARAMETERS:</span>
<a name="l00986"></a>00986 <span class="comment">!</span>
<a name="l00987"></a>00987       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(in)</span> ::     
<a name="l00988"></a>00988            nx_block, ny_block  ,<span class="comment">! block dimensions</span>
<a name="l00989"></a>00989            ilo,ihi,jlo,jhi     ,<span class="comment">! beginning and end of physical domain</span>
<a name="l00990"></a>00990            nghost                <span class="comment">! number of ghost cells</span>
<a name="l00991"></a>00991 
<a name="l00992"></a>00992       <span class="keywordtype">logical (kind=log_kind)</span>, <span class="keywordtype">dimension (ntrace)</span>, <span class="keywordtype">intent(in)</span> ::     
<a name="l00993"></a>00993            has_dependents      <span class="comment">! true if a tracer has dependent tracers</span>
<a name="l00994"></a>00994 
<a name="l00995"></a>00995       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension(0:ncat)</span>, <span class="keywordtype">intent(out)</span> ::     
<a name="l00996"></a>00996            icells         <span class="comment">! number of cells with ice</span>
<a name="l00997"></a>00997 
<a name="l00998"></a>00998       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension(nx_block*ny_block,0:ncat)</span>,     
<a name="l00999"></a>00999            <span class="keywordtype">intent(out)</span> ::     
<a name="l01000"></a>01000            indxi        ,<span class="comment">! compressed i/j indices</span>
<a name="l01001"></a>01001            indxj
<a name="l01002"></a>01002 
<a name="l01003"></a>01003       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,0:ncat)</span>,     
<a name="l01004"></a>01004            <span class="keywordtype">intent(in)</span> ::     
<a name="l01005"></a>01005            mm            <span class="comment">! mean ice area in each grid cell</span>
<a name="l01006"></a>01006 
<a name="l01007"></a>01007       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,0:ncat)</span>,     
<a name="l01008"></a>01008            <span class="keywordtype">intent(out)</span> ::     
<a name="l01009"></a>01009            mmask         <span class="comment">! = 1. if ice is present, else = 0.</span>
<a name="l01010"></a>01010 
<a name="l01011"></a>01011       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block, ny_block, ntrace, ncat)</span>,  
<a name="l01012"></a>01012            <span class="keywordtype">intent(in)</span>, <span class="keywordtype">optional</span> ::     
<a name="l01013"></a>01013            tm            <span class="comment">! mean tracer values in each grid cell</span>
<a name="l01014"></a>01014 
<a name="l01015"></a>01015       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block, ny_block, ntrace, ncat)</span>,  
<a name="l01016"></a>01016            <span class="keywordtype">intent(out)</span>, <span class="keywordtype">optional</span> ::     
<a name="l01017"></a>01017            tmask         <span class="comment">! = 1. if tracer is present, else = 0.</span>
<a name="l01018"></a>01018 <span class="comment">!</span>
<a name="l01019"></a>01019 <span class="comment">!EOP</span>
<a name="l01020"></a>01020 <span class="comment">!</span>
<a name="l01021"></a>01021       <span class="keywordtype">integer (kind=int_kind) </span>::     
<a name="l01022"></a>01022            i, j, ij       ,<span class="comment">! horizontal indices</span>
<a name="l01023"></a>01023            n              ,<span class="comment">! ice category index</span>
<a name="l01024"></a>01024            nt               <span class="comment">! tracer index</span>
<a name="l01025"></a>01025 
<a name="l01026"></a>01026       <span class="keyword">do</span> n = 0, <a class="code" href="namespaceice__domain__size.html#af6426e75baee1427e99bac2564d5afd7">ncat</a>
<a name="l01027"></a>01027          <span class="keyword">do</span> ij = 1, nx_block*ny_block
<a name="l01028"></a>01028             indxi(ij,n) = 0
<a name="l01029"></a>01029             indxj(ij,n) = 0
<a name="l01030"></a>01030          <span class="keyword">enddo</span>
<a name="l01031"></a>01031       <span class="keyword">enddo</span>
<a name="l01032"></a>01032 
<a name="l01033"></a>01033     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01034"></a>01034     <span class="comment">! open water mask</span>
<a name="l01035"></a>01035     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01036"></a>01036 
<a name="l01037"></a>01037       icells(0) = 0
<a name="l01038"></a>01038       <span class="keyword">do</span> j = 1, ny_block
<a name="l01039"></a>01039       <span class="keyword">do</span> i = 1, nx_block
<a name="l01040"></a>01040          <span class="keyword">if</span> (mm(i,j,0) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l01041"></a>01041             mmask(i,j,0) = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>
<a name="l01042"></a>01042             icells(0) = icells(0) + 1
<a name="l01043"></a>01043             ij = icells(0)
<a name="l01044"></a>01044             indxi(ij,0) = i
<a name="l01045"></a>01045             indxj(ij,0) = j
<a name="l01046"></a>01046          <span class="keyword">else</span>
<a name="l01047"></a>01047             mmask(i,j,0) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01048"></a>01048          <span class="keyword">endif</span>
<a name="l01049"></a>01049       <span class="keyword">enddo</span>
<a name="l01050"></a>01050       <span class="keyword">enddo</span>
<a name="l01051"></a>01051 
<a name="l01052"></a>01052       <span class="keyword">do</span> n = 1, <a class="code" href="namespaceice__domain__size.html#af6426e75baee1427e99bac2564d5afd7">ncat</a>
<a name="l01053"></a>01053 
<a name="l01054"></a>01054     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01055"></a>01055     <span class="comment">! Find grid cells where ice is present.</span>
<a name="l01056"></a>01056     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01057"></a>01057 
<a name="l01058"></a>01058          icells(n) = 0
<a name="l01059"></a>01059          <span class="keyword">do</span> j = 1, ny_block
<a name="l01060"></a>01060          <span class="keyword">do</span> i = 1, nx_block
<a name="l01061"></a>01061             <span class="keyword">if</span> (mm(i,j,n) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l01062"></a>01062                icells(n) = icells(n) + 1
<a name="l01063"></a>01063                ij = icells(n)
<a name="l01064"></a>01064                indxi(ij,n) = i
<a name="l01065"></a>01065                indxj(ij,n) = j
<a name="l01066"></a>01066             <span class="keyword">endif</span>               <span class="comment">! mm &gt; puny</span>
<a name="l01067"></a>01067          <span class="keyword">enddo</span>
<a name="l01068"></a>01068          <span class="keyword">enddo</span>
<a name="l01069"></a>01069 
<a name="l01070"></a>01070     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01071"></a>01071     <span class="comment">! ice area mask</span>
<a name="l01072"></a>01072     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01073"></a>01073 
<a name="l01074"></a>01074          mmask(:,:,n) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01075"></a>01075          <span class="keyword">do</span> ij = 1, icells(n)
<a name="l01076"></a>01076             i = indxi(ij,n)
<a name="l01077"></a>01077             j = indxj(ij,n)
<a name="l01078"></a>01078             mmask(i,j,n) = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>
<a name="l01079"></a>01079          <span class="keyword">enddo</span>
<a name="l01080"></a>01080 
<a name="l01081"></a>01081     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01082"></a>01082     <span class="comment">! tracer masks</span>
<a name="l01083"></a>01083     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01084"></a>01084 
<a name="l01085"></a>01085          <span class="keyword">if</span> (present(tm)) <span class="keyword">then</span>
<a name="l01086"></a>01086 
<a name="l01087"></a>01087             tmask(:,:,:,n) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01088"></a>01088             <span class="keyword">do</span> nt = 1, <a class="code" href="namespaceice__transport__remap.html#a5012cc594b512eddae2a80fd91132217">ntrace</a>
<a name="l01089"></a>01089                <span class="keyword">if</span> (has_dependents(nt)) <span class="keyword">then</span>
<a name="l01090"></a>01090                   <span class="keyword">do</span> ij = 1, icells(n)
<a name="l01091"></a>01091                      i = indxi(ij,n)
<a name="l01092"></a>01092                      j = indxj(ij,n)
<a name="l01093"></a>01093                      <span class="keyword">if</span> (abs(tm(i,j,nt,n)) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l01094"></a>01094                         tmask(i,j,nt,n) = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>
<a name="l01095"></a>01095                      <span class="keyword">endif</span>
<a name="l01096"></a>01096                   <span class="keyword">enddo</span>
<a name="l01097"></a>01097                <span class="keyword">endif</span>
<a name="l01098"></a>01098             <span class="keyword">enddo</span>
<a name="l01099"></a>01099 
<a name="l01100"></a>01100          <span class="keyword">endif</span>                     <span class="comment">! present(tm)</span>
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01103"></a>01103     <span class="comment">! Redefine icells</span>
<a name="l01104"></a>01104     <span class="comment">! For nghost = 1, exclude ghost cells</span>
<a name="l01105"></a>01105     <span class="comment">! For nghost = 2, include one layer of ghost cells</span>
<a name="l01106"></a>01106     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01107"></a>01107 
<a name="l01108"></a>01108          icells(n) = 0
<a name="l01109"></a>01109          <span class="keyword">do</span> j = jlo-nghost+1, jhi+nghost-1
<a name="l01110"></a>01110          <span class="keyword">do</span> i = ilo-nghost+1, ihi+nghost-1
<a name="l01111"></a>01111             <span class="keyword">if</span> (mm(i,j,n) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l01112"></a>01112                icells(n) = icells(n) + 1
<a name="l01113"></a>01113                ij = icells(n)
<a name="l01114"></a>01114                indxi(ij,n) = i
<a name="l01115"></a>01115                indxj(ij,n) = j
<a name="l01116"></a>01116             <span class="keyword">endif</span>               <span class="comment">! mm &gt; puny</span>
<a name="l01117"></a>01117          <span class="keyword">enddo</span>
<a name="l01118"></a>01118          <span class="keyword">enddo</span>
<a name="l01119"></a>01119       
<a name="l01120"></a>01120       <span class="keyword">enddo</span> <span class="comment">! n</span>
<a name="l01121"></a>01121 
<a name="l01122"></a>01122 <span class="keyword">      end subroutine make_masks</span>
<a name="l01123"></a>01123 
<a name="l01124"></a>01124 <span class="comment">!=======================================================================</span>
<a name="l01125"></a>01125 <span class="comment">!</span>
<a name="l01126"></a>01126 <span class="comment">!BOP</span>
<a name="l01127"></a>01127 <span class="comment">!</span>
<a name="l01128"></a>01128 <span class="comment">! !IROUTINE: construct_fields - construct fields of ice area and tracers</span>
<a name="l01129"></a>01129 <span class="comment">!</span>
<a name="l01130"></a>01130 <span class="comment">! !INTERFACE:</span>
<a name="l01131"></a>01131 <span class="comment">!</span>
<a name="l01132"></a><a class="code" href="namespaceice__transport__remap.html#a4c7f753ed3abe19124a7e719e3424dae">01132</a>       <span class="keyword">subroutine </span><a class="code" href="namespaceice__transport__remap.html#a4c7f753ed3abe19124a7e719e3424dae">construct_fields</a> (nx_block,       ny_block,   &amp;
<a name="l01133"></a>01133                                    ilo, ihi,       jlo, jhi,   &amp;
<a name="l01134"></a>01134                                    nghost,                     &amp;
<a name="l01135"></a>01135                                    tracer_type,    depend,     &amp;
<a name="l01136"></a>01136                                    has_dependents, icells,     &amp;
<a name="l01137"></a>01137                                    indxi,          indxj,      &amp;
<a name="l01138"></a>01138                                    HTN,            HTE,        &amp;
<a name="l01139"></a>01139                                    hm,             xav,        &amp;
<a name="l01140"></a>01140                                    yav,            xxav,       &amp;
<a name="l01141"></a>01141                                    xyav,           yyav,       &amp;
<a name="l01142"></a>01142                                    xxxav,          xxyav,      &amp;
<a name="l01143"></a>01143                                    xyyav,          yyyav,      &amp;
<a name="l01144"></a>01144                                    dxt,            dyt,        &amp;
<a name="l01145"></a>01145                                    mm,             mc,         &amp;
<a name="l01146"></a>01146                                    mx,             my,         &amp;
<a name="l01147"></a>01147                                    mmask,                      &amp;
<a name="l01148"></a>01148                                    tm,             tc,         &amp;
<a name="l01149"></a>01149                                    tx,             ty,         &amp;
<a name="l01150"></a>01150                                    tmask)
<a name="l01151"></a>01151 <span class="comment">!</span>
<a name="l01152"></a>01152 <span class="comment">! !DESCRIPTION:</span>
<a name="l01153"></a>01153 <span class="comment">!</span>
<a name="l01154"></a>01154 <span class="comment">! Construct fields of ice area and tracers.</span>
<a name="l01155"></a>01155 <span class="comment">!</span>
<a name="l01156"></a>01156 <span class="comment">! !REVISION HISTORY:</span>
<a name="l01157"></a>01157 <span class="comment">!</span>
<a name="l01158"></a>01158 <span class="comment">! authors William H. Lipscomb, LANL</span>
<a name="l01159"></a>01159 <span class="comment">!         John R. Baumgardner, LANL</span>
<a name="l01160"></a>01160 <span class="comment">!</span>
<a name="l01161"></a>01161 <span class="comment">! !USES:</span>
<a name="l01162"></a>01162 <span class="comment">!</span>
<a name="l01163"></a>01163 <span class="comment">! !INPUT/OUTPUT PARAMETERS:</span>
<a name="l01164"></a>01164 <span class="comment">!</span>
<a name="l01165"></a>01165       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l01166"></a>01166          nx_block, ny_block  ,<span class="comment">! block dimensions</span>
<a name="l01167"></a>01167          ilo,ihi,jlo,jhi     ,<span class="comment">! beginning and end of physical domain</span>
<a name="l01168"></a>01168          nghost              ,<span class="comment">! number of ghost cells</span>
<a name="l01169"></a>01169          icells                <span class="comment">! number of cells with mass</span>
<a name="l01170"></a>01170 
<a name="l01171"></a>01171       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (ntrace)</span>, <span class="keywordtype">intent(in)</span> ::     
<a name="l01172"></a>01172          tracer_type       ,<span class="comment">! = 1, 2, or 3 (see comments above)</span>
<a name="l01173"></a>01173          depend              <span class="comment">! tracer dependencies (see above)</span>
<a name="l01174"></a>01174 
<a name="l01175"></a>01175       <span class="keywordtype">logical (kind=log_kind)</span>, <span class="keywordtype">dimension (ntrace)</span>, <span class="keywordtype">intent(in)</span> ::     
<a name="l01176"></a>01176          has_dependents      <span class="comment">! true if a tracer has dependent tracers</span>
<a name="l01177"></a>01177 
<a name="l01178"></a>01178       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension(nx_block*ny_block)</span>, <span class="keywordtype">intent(in)</span> :: 
<a name="l01179"></a>01179          indxi          ,<span class="comment">! compressed i/j indices</span>
<a name="l01180"></a>01180          indxj
<a name="l01181"></a>01181 
<a name="l01182"></a>01182       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block)</span>,   
<a name="l01183"></a>01183          <span class="keywordtype">intent(in)</span> ::   
<a name="l01184"></a>01184          hm             ,<span class="comment">! land/boundary mask, thickness (T-cell)</span>
<a name="l01185"></a>01185          HTN            ,<span class="comment">! length of northern edge of T-cell (m)</span>
<a name="l01186"></a>01186          HTE            ,<span class="comment">! length of eastern edge of T-cell (m)</span>
<a name="l01187"></a>01187          xav,  yav              ,<span class="comment">! mean T-cell values of x, y</span>
<a name="l01188"></a>01188          xxav, xyav, yyav       ,<span class="comment">! mean T-cell values of xx, xy, yy</span>
<a name="l01189"></a>01189          xxxav,xxyav,xyyav,yyyav,<span class="comment">! mean T-cell values of , xxy, xyy, yyy</span>
<a name="l01190"></a>01190          dxt            ,<span class="comment">! grid cell width (m)</span>
<a name="l01191"></a>01191          dyt              <span class="comment">! grid cell height (m)</span>
<a name="l01192"></a>01192 
<a name="l01193"></a>01193       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block)</span>,   
<a name="l01194"></a>01194          <span class="keywordtype">intent(in)</span> ::   
<a name="l01195"></a>01195          mm            ,<span class="comment">! mean value of mass field</span>
<a name="l01196"></a>01196          mmask           <span class="comment">! = 1. if ice is present, = 0. otherwise</span>
<a name="l01197"></a>01197 
<a name="l01198"></a>01198       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,ntrace)</span>,   
<a name="l01199"></a>01199          <span class="keywordtype">intent(in)</span>, <span class="keywordtype">optional</span> ::   
<a name="l01200"></a>01200          tm             ,<span class="comment">! mean tracer</span>
<a name="l01201"></a>01201          tmask            <span class="comment">! = 1. if tracer is present, = 0. otherwise</span>
<a name="l01202"></a>01202 
<a name="l01203"></a>01203       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block)</span>,   
<a name="l01204"></a>01204          <span class="keywordtype">intent(out)</span> ::   
<a name="l01205"></a>01205          mc             ,<span class="comment">! mass value at geometric center of cell</span>
<a name="l01206"></a>01206          mx, my           <span class="comment">! limited derivative of mass wrt x and y</span>
<a name="l01207"></a>01207 
<a name="l01208"></a>01208       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,ntrace)</span>,   
<a name="l01209"></a>01209          <span class="keywordtype">intent(out)</span>, <span class="keywordtype">optional</span> ::   
<a name="l01210"></a>01210          tc             ,<span class="comment">! tracer at geometric center of cell</span>
<a name="l01211"></a>01211          tx, ty           <span class="comment">! limited derivative of tracer wrt x and y</span>
<a name="l01212"></a>01212 <span class="comment">!</span>
<a name="l01213"></a>01213 <span class="comment">!EOP</span>
<a name="l01214"></a>01214 <span class="comment">!</span>
<a name="l01215"></a>01215       <span class="keywordtype">integer (kind=int_kind) </span>::   
<a name="l01216"></a>01216          i, j           ,<span class="comment">! horizontal indices</span>
<a name="l01217"></a>01217          nt, nt1        ,<span class="comment">! tracer indices</span>
<a name="l01218"></a>01218          ij               <span class="comment">! combined i/j horizontal index</span>
<a name="l01219"></a>01219 
<a name="l01220"></a>01220       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block) </span>::    
<a name="l01221"></a>01221          mxav           ,<span class="comment">! x coordinate of center of mass</span>
<a name="l01222"></a>01222          myav             <span class="comment">! y coordinate of center of mass</span>
<a name="l01223"></a>01223 
<a name="l01224"></a>01224       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,ntrace) </span>::  
<a name="l01225"></a>01225          mtxav          ,<span class="comment">! x coordinate of center of mass*tracer</span>
<a name="l01226"></a>01226          mtyav            <span class="comment">! y coordinate of center of mass*tracer</span>
<a name="l01227"></a>01227 
<a name="l01228"></a>01228       <span class="keywordtype">real (kind=dbl_kind) </span>::   
<a name="l01229"></a>01229          w1, w2, w3, w4, w5, w6, w7   <span class="comment">! work variables</span>
<a name="l01230"></a>01230 
<a name="l01231"></a>01231     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01232"></a>01232     <span class="comment">! Compute field values at the geometric center of each grid cell,</span>
<a name="l01233"></a>01233     <span class="comment">! and compute limited gradients in the x and y directions.</span>
<a name="l01234"></a>01234     <span class="comment">!</span>
<a name="l01235"></a>01235     <span class="comment">! For second order accuracy, each state variable is approximated as</span>
<a name="l01236"></a>01236     <span class="comment">! a field varying linearly over x and y within each cell.  For each</span>
<a name="l01237"></a>01237     <span class="comment">! category, the integrated value of m(x,y) over the cell must</span>
<a name="l01238"></a>01238     <span class="comment">! equal mm(i,j,n)*tarea(i,j), where tarea(i,j) is the cell area.</span>
<a name="l01239"></a>01239     <span class="comment">! Similarly, the integrated value of m(x,y)*t(x,y) must equal</span>
<a name="l01240"></a>01240     <span class="comment">! the total mass*tracer, mm(i,j,n)*tm(i,j,n)*tarea(i,j).</span>
<a name="l01241"></a>01241     <span class="comment">!</span>
<a name="l01242"></a>01242     <span class="comment">! These integral conditions are satisfied for linear fields if we</span>
<a name="l01243"></a>01243     <span class="comment">! stipulate the following:</span>
<a name="l01244"></a>01244     <span class="comment">! (1) The mean mass, mm, is equal to the mass at the cell centroid.</span>
<a name="l01245"></a>01245     <span class="comment">! (2) The mean value tm1 of type 1 tracers is equal to the value</span>
<a name="l01246"></a>01246     <span class="comment">!     at the center of mass.</span>
<a name="l01247"></a>01247     <span class="comment">! (3) The mean value tm2 of type 2 tracers is equal to the value</span>
<a name="l01248"></a>01248     <span class="comment">!     at the center of mass*tm1, where tm2 depends on tm1.</span>
<a name="l01249"></a>01249     <span class="comment">!     (See comments at the top of the module.)</span>
<a name="l01250"></a>01250     <span class="comment">!</span>
<a name="l01251"></a>01251     <span class="comment">! We want to find the value of each state variable at a standard</span>
<a name="l01252"></a>01252     <span class="comment">! reference point, which we choose to be the geometric center of</span>
<a name="l01253"></a>01253     <span class="comment">! the cell.  The geometric center is located at the intersection</span>
<a name="l01254"></a>01254     <span class="comment">! of the line joining the midpoints of the north and south edges</span>
<a name="l01255"></a>01255     <span class="comment">! with the line joining the midpoints of the east and west edges.</span>
<a name="l01256"></a>01256     <span class="comment">! To find the value at the geometric center, we must know the</span>
<a name="l01257"></a>01257     <span class="comment">! location of the cell centroid/center of mass, along with the</span>
<a name="l01258"></a>01258     <span class="comment">! mean value and the gradients with respect to x and y.</span>
<a name="l01259"></a>01259     <span class="comment">!</span>
<a name="l01260"></a>01260     <span class="comment">! The cell gradients are first computed from the difference between</span>
<a name="l01261"></a>01261     <span class="comment">! values in the neighboring cells, then limited by requiring that</span>
<a name="l01262"></a>01262     <span class="comment">! no new extrema are created within the cell.</span>
<a name="l01263"></a>01263     <span class="comment">!</span>
<a name="l01264"></a>01264     <span class="comment">! For rectangular coordinates the centroid and the geometric</span>
<a name="l01265"></a>01265     <span class="comment">! center coincide, which means that some of the equations in this</span>
<a name="l01266"></a>01266     <span class="comment">! subroutine could be simplified.  However, the full equations</span>
<a name="l01267"></a>01267     <span class="comment">! are retained for generality.</span>
<a name="l01268"></a>01268     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01269"></a>01269 
<a name="l01270"></a>01270     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01271"></a>01271     <span class="comment">! Initialize</span>
<a name="l01272"></a>01272     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01273"></a>01273 
<a name="l01274"></a>01274       <span class="keyword">do</span> j = 1, ny_block
<a name="l01275"></a>01275       <span class="keyword">do</span> i = 1, nx_block
<a name="l01276"></a>01276          mc(i,j)  = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01277"></a>01277          mx(i,j)  = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01278"></a>01278          my(i,j)  = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01279"></a>01279          mxav(i,j) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01280"></a>01280          myav(i,j) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01281"></a>01281       <span class="keyword">enddo</span>
<a name="l01282"></a>01282       <span class="keyword">enddo</span>
<a name="l01283"></a>01283 
<a name="l01284"></a>01284       <span class="keyword">if</span> (present(tm)) <span class="keyword">then</span>
<a name="l01285"></a>01285          <span class="keyword">do</span> nt = 1, <a class="code" href="namespaceice__transport__remap.html#a5012cc594b512eddae2a80fd91132217">ntrace</a>
<a name="l01286"></a>01286             <span class="keyword">do</span> j = 1, ny_block
<a name="l01287"></a>01287             <span class="keyword">do</span> i = 1, nx_block
<a name="l01288"></a>01288                tc(i,j,nt) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01289"></a>01289                tx(i,j,nt) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01290"></a>01290                ty(i,j,nt) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01291"></a>01291             <span class="keyword">enddo</span>
<a name="l01292"></a>01292             <span class="keyword">enddo</span>
<a name="l01293"></a>01293          <span class="keyword">enddo</span>
<a name="l01294"></a>01294       <span class="keyword">endif</span>
<a name="l01295"></a>01295          
<a name="l01296"></a>01296       <span class="comment">! limited gradient of mass field in each cell (except masked cells)</span>
<a name="l01297"></a>01297       <span class="comment">! Note: The gradient is computed in scaled coordinates with</span>
<a name="l01298"></a>01298       <span class="comment">!       dxt = dyt = hte = htn = 1.</span>
<a name="l01299"></a>01299 
<a name="l01300"></a>01300       call <a class="code" href="namespaceice__transport__remap.html#ad0f2932484bf98ec16810e79b50b9117">limited_gradient </a>(nx_block, ny_block,   &amp;
<a name="l01301"></a>01301                              ilo, ihi, jlo, jhi,   &amp;
<a name="l01302"></a>01302                              nghost,               &amp;
<a name="l01303"></a>01303                              mm,       hm,         &amp;
<a name="l01304"></a>01304                              xav,      yav,        &amp;
<a name="l01305"></a>01305                              HTN,      HTE,        &amp;
<a name="l01306"></a>01306                              dxt,      dyt,        &amp;
<a name="l01307"></a>01307                              mx,       my)
<a name="l01308"></a>01308 
<a name="l01309"></a>01309       <span class="keyword">do</span> ij = 1,icells   <span class="comment">! ice is present</span>
<a name="l01310"></a>01310          i = indxi(ij)
<a name="l01311"></a>01311          j = indxj(ij)
<a name="l01312"></a>01312 
<a name="l01313"></a>01313          <span class="comment">! mass field at geometric center</span>
<a name="l01314"></a>01314          mc(i,j) = mm(i,j) - xav(i,j)*mx(i,j)   &amp;
<a name="l01315"></a>01315                            - yav(i,j)*my(i,j)
<a name="l01316"></a>01316 
<a name="l01317"></a>01317       <span class="keyword">enddo</span>                     <span class="comment">! ij</span>
<a name="l01318"></a>01318 
<a name="l01319"></a>01319       <span class="comment">! tracers</span>
<a name="l01320"></a>01320 
<a name="l01321"></a>01321       <span class="keyword">if</span> (present(tm)) <span class="keyword">then</span>
<a name="l01322"></a>01322 
<a name="l01323"></a>01323        <span class="keyword">do</span> ij = 1,icells       <span class="comment">! cells with mass</span>
<a name="l01324"></a>01324           i = indxi(ij)
<a name="l01325"></a>01325           j = indxj(ij)
<a name="l01326"></a>01326 
<a name="l01327"></a>01327          <span class="comment">! center of mass (mxav,myav) for each cell</span>
<a name="l01328"></a>01328           mxav(i,j) = (mx(i,j)*xxav(i,j)    &amp;
<a name="l01329"></a>01329                      + my(i,j)*xyav(i,j)    &amp;
<a name="l01330"></a>01330                      + mc(i,j)*xav (i,j)) / mm(i,j)
<a name="l01331"></a>01331           myav(i,j) = (mx(i,j)*xyav(i,j)    &amp;
<a name="l01332"></a>01332                      + my(i,j)*yyav(i,j)    &amp;
<a name="l01333"></a>01333                      + mc(i,j)*yav(i,j)) / mm(i,j)
<a name="l01334"></a>01334        <span class="keyword">enddo</span>
<a name="l01335"></a>01335 
<a name="l01336"></a>01336        <span class="keyword">do</span> nt = 1, <a class="code" href="namespaceice__transport__remap.html#a5012cc594b512eddae2a80fd91132217">ntrace</a>
<a name="l01337"></a>01337 
<a name="l01338"></a>01338          <span class="keyword">if</span> (tracer_type(nt)==1) <span class="keyword">then</span> <span class="comment">! independent of other tracers</span>
<a name="l01339"></a>01339 
<a name="l01340"></a>01340             call <a class="code" href="namespaceice__transport__remap.html#ad0f2932484bf98ec16810e79b50b9117">limited_gradient</a>(nx_block,     ny_block,  &amp;
<a name="l01341"></a>01341                                   ilo, ihi,     jlo, jhi,  &amp;
<a name="l01342"></a>01342                                   nghost,                  &amp;
<a name="l01343"></a>01343                                   tm(:,:,nt),   mmask,     &amp;
<a name="l01344"></a>01344                                   mxav,         myav,      &amp;
<a name="l01345"></a>01345                                   HTN,          HTE,       &amp;
<a name="l01346"></a>01346                                   dxt,          dyt,       &amp;
<a name="l01347"></a>01347                                   tx(:,:,nt),   ty(:,:,nt)) 
<a name="l01348"></a>01348 
<a name="l01349"></a>01349             <span class="keyword">if</span> (has_dependents(nt)) <span class="keyword">then</span>   <span class="comment">! need center of area*tracer</span>
<a name="l01350"></a>01350 
<a name="l01351"></a>01351                <span class="keyword">do</span> j = 1, ny_block
<a name="l01352"></a>01352                <span class="keyword">do</span> i = 1, nx_block
<a name="l01353"></a>01353                   mtxav(i,j,nt) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01354"></a>01354                   mtyav(i,j,nt) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01355"></a>01355                <span class="keyword">enddo</span>
<a name="l01356"></a>01356                <span class="keyword">enddo</span>
<a name="l01357"></a>01357 
<a name="l01358"></a>01358 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l01359"></a>01359 <span class="comment">!cdir nodep      !NEC</span>
<a name="l01360"></a>01360 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l01361"></a>01361                <span class="keyword">do</span> ij = 1, icells  <span class="comment">! Note: no tx or ty in ghost cells</span>
<a name="l01362"></a>01362                                   <span class="comment">! (bound calls are later)</span>
<a name="l01363"></a>01363                   i = indxi(ij)
<a name="l01364"></a>01364                   j = indxj(ij)
<a name="l01365"></a>01365 
<a name="l01366"></a>01366                   <span class="comment">! tracer value at geometric center</span>
<a name="l01367"></a>01367                   tc(i,j,nt) = tm(i,j,nt) - tx(i,j,nt)*mxav(i,j)   &amp;
<a name="l01368"></a>01368                                           - ty(i,j,nt)*myav(i,j)
<a name="l01369"></a>01369 
<a name="l01370"></a>01370                   <span class="keyword">if</span> (tmask(i,j,nt) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l01371"></a>01371 
<a name="l01372"></a>01372                      <span class="comment">! center of area*tracer</span>
<a name="l01373"></a>01373                      w1 = mc(i,j)*tc(i,j,nt)
<a name="l01374"></a>01374                      w2 = mc(i,j)*tx(i,j,nt)   &amp;
<a name="l01375"></a>01375                         + mx(i,j)*tc(i,j,nt)
<a name="l01376"></a>01376                      w3 = mc(i,j)*ty(i,j,nt)   &amp;
<a name="l01377"></a>01377                         + my(i,j)*tc(i,j,nt)
<a name="l01378"></a>01378                      w4 = mx(i,j)*tx(i,j,nt)
<a name="l01379"></a>01379                      w5 = mx(i,j)*ty(i,j,nt)   &amp;
<a name="l01380"></a>01380                         + my(i,j)*tx(i,j,nt)
<a name="l01381"></a>01381                      w6 = my(i,j)*ty(i,j,nt)
<a name="l01382"></a>01382                      w7 = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a> / (mm(i,j)*tm(i,j,nt))
<a name="l01383"></a>01383                      mtxav(i,j,nt) = (w1*xav (i,j)  + w2*xxav (i,j)   &amp;
<a name="l01384"></a>01384                                     + w3*xyav (i,j) + w4*xxxav(i,j)   &amp;
<a name="l01385"></a>01385                                     + w5*xxyav(i,j) + w6*xyyav(i,j))   &amp;
<a name="l01386"></a>01386                                     * w7
<a name="l01387"></a>01387                      mtyav(i,j,nt) = (w1*yav(i,j)   + w2*xyav (i,j)   &amp;
<a name="l01388"></a>01388                                     + w3*yyav(i,j)  + w4*xxyav(i,j)   &amp;
<a name="l01389"></a>01389                                     + w5*xyyav(i,j) + w6*yyyav(i,j))   &amp;
<a name="l01390"></a>01390                                     * w7
<a name="l01391"></a>01391                   <span class="keyword">endif</span>         <span class="comment">! tmask</span>
<a name="l01392"></a>01392 
<a name="l01393"></a>01393                <span class="keyword">enddo</span>            <span class="comment">! ij</span>
<a name="l01394"></a>01394 
<a name="l01395"></a>01395             <span class="keyword">else</span>                <span class="comment">! no dependents</span>
<a name="l01396"></a>01396 
<a name="l01397"></a>01397                <span class="keyword">do</span> ij = 1, icells      <span class="comment">! mass is present</span>
<a name="l01398"></a>01398                   i = indxi(ij)
<a name="l01399"></a>01399                   j = indxj(ij)
<a name="l01400"></a>01400 
<a name="l01401"></a>01401                   <span class="comment">! tracer value at geometric center</span>
<a name="l01402"></a>01402                   tc(i,j,nt) = tm(i,j,nt) - tx(i,j,nt)*mxav(i,j)   &amp;
<a name="l01403"></a>01403                                           - ty(i,j,nt)*myav(i,j)
<a name="l01404"></a>01404                <span class="keyword">enddo</span>            <span class="comment">! ij</span>
<a name="l01405"></a>01405 
<a name="l01406"></a>01406             <span class="keyword">endif</span>               <span class="comment">! has_dependents</span>
<a name="l01407"></a>01407 
<a name="l01408"></a>01408          elseif (tracer_type(nt)==2) <span class="keyword">then</span>   <span class="comment">! tracer nt depends on nt1</span>
<a name="l01409"></a>01409             nt1 = depend(nt)
<a name="l01410"></a>01410 
<a name="l01411"></a>01411             call <a class="code" href="namespaceice__transport__remap.html#ad0f2932484bf98ec16810e79b50b9117">limited_gradient</a>(nx_block,       ny_block,         &amp;
<a name="l01412"></a>01412                                   ilo, ihi,       jlo, jhi,         &amp;
<a name="l01413"></a>01413                                   nghost,                           &amp;
<a name="l01414"></a>01414                                   tm(:,:,nt),     tmask(:,:,nt1),   &amp;
<a name="l01415"></a>01415                                   mtxav(:,:,nt1), mtyav(:,:,nt1),   &amp;
<a name="l01416"></a>01416                                   HTN,            HTE,              &amp;
<a name="l01417"></a>01417                                   dxt,            dyt,              &amp;
<a name="l01418"></a>01418                                   tx(:,:,nt),     ty(:,:,nt))    
<a name="l01419"></a>01419 
<a name="l01420"></a>01420             <span class="keyword">do</span> ij = 1, icells     <span class="comment">! ice is present</span>
<a name="l01421"></a>01421                i = indxi(ij)
<a name="l01422"></a>01422                j = indxj(ij)
<a name="l01423"></a>01423                tc(i,j,nt) = tm(i,j,nt)                    &amp;
<a name="l01424"></a>01424                           - tx(i,j,nt) * mtxav(i,j,nt1)   &amp;
<a name="l01425"></a>01425                           - ty(i,j,nt) * mtyav(i,j,nt1)
<a name="l01426"></a>01426             <span class="keyword">enddo</span>               <span class="comment">! ij</span>
<a name="l01427"></a>01427 
<a name="l01428"></a>01428          elseif (tracer_type(nt)==3) <span class="keyword">then</span>  <span class="comment">! upwind approx; gradient = 0</span>
<a name="l01429"></a>01429 
<a name="l01430"></a>01430             <span class="keyword">do</span> ij = 1, icells
<a name="l01431"></a>01431                i = indxi(ij)
<a name="l01432"></a>01432                j = indxj(ij)
<a name="l01433"></a>01433 
<a name="l01434"></a>01434                tc(i,j,nt) = tm(i,j,nt)
<a name="l01435"></a>01435 <span class="comment">!               tx(i,j,nt) = c0   ! already initialized to 0.</span>
<a name="l01436"></a>01436 <span class="comment">!               ty(i,j,nt) = c0</span>
<a name="l01437"></a>01437             <span class="keyword">enddo</span>               <span class="comment">! ij</span>
<a name="l01438"></a>01438 
<a name="l01439"></a>01439          <span class="keyword">endif</span>                  <span class="comment">! tracer_type</span>
<a name="l01440"></a>01440        <span class="keyword">enddo</span>                    <span class="comment">! ntrace</span>
<a name="l01441"></a>01441 
<a name="l01442"></a>01442       <span class="keyword">endif</span>                     <span class="comment">! present (tm)</span>
<a name="l01443"></a>01443 
<a name="l01444"></a>01444 <span class="keyword">      end subroutine construct_fields</span>
<a name="l01445"></a>01445 
<a name="l01446"></a>01446 <span class="comment">!=======================================================================</span>
<a name="l01447"></a>01447 <span class="comment">!</span>
<a name="l01448"></a>01448 <span class="comment">!BOP</span>
<a name="l01449"></a>01449 <span class="comment">!</span>
<a name="l01450"></a>01450 <span class="comment">! !IROUTINE: limited_gradient - limited gradient of a scalar field</span>
<a name="l01451"></a>01451 <span class="comment">!</span>
<a name="l01452"></a>01452 <span class="comment">! !INTERFACE:</span>
<a name="l01453"></a>01453 <span class="comment">!</span>
<a name="l01454"></a><a class="code" href="namespaceice__transport__remap.html#ad0f2932484bf98ec16810e79b50b9117">01454</a>       <span class="keyword">subroutine </span><a class="code" href="namespaceice__transport__remap.html#ad0f2932484bf98ec16810e79b50b9117">limited_gradient</a> (nx_block, ny_block,   &amp;
<a name="l01455"></a>01455                                    ilo, ihi, jlo, jhi,   &amp;
<a name="l01456"></a>01456                                    nghost,               &amp;
<a name="l01457"></a>01457                                    phi,      phimask,    &amp;
<a name="l01458"></a>01458                                    cnx,      cny,        &amp;
<a name="l01459"></a>01459                                    HTN,      HTE,        &amp;
<a name="l01460"></a>01460                                    dxt,      dyt,        &amp;
<a name="l01461"></a>01461                                    gx,       gy)
<a name="l01462"></a>01462 <span class="comment">!</span>
<a name="l01463"></a>01463 <span class="comment">! !DESCRIPTION:</span>
<a name="l01464"></a>01464 <span class="comment">!</span>
<a name="l01465"></a>01465 <span class="comment">! Compute a limited gradient of the scalar field phi in scaled coordinates.</span>
<a name="l01466"></a>01466 <span class="comment">! &quot;Limited&quot; means that we do not create new extrema in phi.  For</span>
<a name="l01467"></a>01467 <span class="comment">! instance, field values at the cell corners can neither exceed the</span>
<a name="l01468"></a>01468 <span class="comment">! maximum of phi(i,j) in the cell and its eight neighbors, nor fall</span>
<a name="l01469"></a>01469 <span class="comment">! below the minimum.</span>
<a name="l01470"></a>01470 <span class="comment">!</span>
<a name="l01471"></a>01471 <span class="comment">! !REVISION HISTORY:</span>
<a name="l01472"></a>01472 <span class="comment">!</span>
<a name="l01473"></a>01473 <span class="comment">! authors William H. Lipscomb, LANL</span>
<a name="l01474"></a>01474 <span class="comment">!         John R. Baumgardner, LANL</span>
<a name="l01475"></a>01475 <span class="comment">!</span>
<a name="l01476"></a>01476 <span class="comment">! !USES:</span>
<a name="l01477"></a>01477 <span class="comment">!</span>
<a name="l01478"></a>01478 <span class="comment">! !INPUT/OUTPUT PARAMETERS:</span>
<a name="l01479"></a>01479 <span class="comment">!</span>
<a name="l01480"></a>01480       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l01481"></a>01481           nx_block, ny_block,<span class="comment">! block dimensions</span>
<a name="l01482"></a>01482           ilo,ihi,jlo,jhi ,<span class="comment">! beginning and end of physical domain</span>
<a name="l01483"></a>01483           nghost              <span class="comment">! number of ghost cells</span>
<a name="l01484"></a>01484 
<a name="l01485"></a>01485       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block)</span>,   
<a name="l01486"></a>01486            <span class="keywordtype">intent (in)</span> ::   
<a name="l01487"></a>01487           phi    ,<span class="comment">! input tracer field (mean values in each grid cell)</span>
<a name="l01488"></a>01488           cnx    ,<span class="comment">! x-coordinate of phi relative to geometric center of cell</span>
<a name="l01489"></a>01489           cny    ,<span class="comment">! y-coordinate of phi relative to geometric center of cell</span>
<a name="l01490"></a>01490           dxt    ,<span class="comment">! grid cell width (m)</span>
<a name="l01491"></a>01491           dyt    ,<span class="comment">! grid cell height (m)</span>
<a name="l01492"></a>01492           phimask ,
<a name="l01493"></a>01493           <span class="comment">! phimask(i,j) = 1 if phi(i,j) has physical meaning, = 0 otherwise.</span>
<a name="l01494"></a>01494           <span class="comment">! For instance, aice has no physical meaning in land cells,</span>
<a name="l01495"></a>01495           <span class="comment">! and hice no physical meaning where aice = 0.</span>
<a name="l01496"></a>01496           HTN    ,&amp;<span class="comment">! length of northern edge of T-cell (m)</span>
<a name="l01497"></a>01497           HTE      <span class="comment">! length of eastern edge of T-cell (m)</span>
<a name="l01498"></a>01498 
<a name="l01499"></a>01499       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block)</span>,   
<a name="l01500"></a>01500           <span class="keywordtype">intent(out)</span> ::   
<a name="l01501"></a>01501           gx     ,<span class="comment">! limited x-direction gradient</span>
<a name="l01502"></a>01502           gy       <span class="comment">! limited y-direction gradient</span>
<a name="l01503"></a>01503 <span class="comment">!</span>
<a name="l01504"></a>01504 <span class="comment">!EOP</span>
<a name="l01505"></a>01505 <span class="comment">!</span>
<a name="l01506"></a>01506       <span class="keywordtype">integer (kind=int_kind) </span>::   
<a name="l01507"></a>01507           i, j, ij        ,<span class="comment">! standard indices</span>
<a name="l01508"></a>01508           icells            <span class="comment">! number of cells to limit</span>
<a name="l01509"></a>01509 
<a name="l01510"></a>01510       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension(nx_block*ny_block) </span>::   
<a name="l01511"></a>01511           indxi, indxj   <span class="comment">! combined i/j horizontal indices</span>
<a name="l01512"></a>01512 
<a name="l01513"></a>01513       <span class="keywordtype">real (kind=dbl_kind) </span>::   
<a name="l01514"></a>01514           phi_nw, phi_n, phi_ne ,<span class="comment">! values of phi in 8 neighbor cells</span>
<a name="l01515"></a>01515           phi_w,         phi_e  ,
<a name="l01516"></a>01516           phi_sw, phi_s, phi_se ,
<a name="l01517"></a>01517           qmn, qmx     ,<span class="comment">! min and max value of phi within grid cell</span>
<a name="l01518"></a>01518           pmn, pmx     ,<span class="comment">! min and max value of phi among neighbor cells</span>
<a name="l01519"></a>01519           w1, w2, w3, w4 <span class="comment">! work variables</span>
<a name="l01520"></a>01520 
<a name="l01521"></a>01521       <span class="keywordtype">real (kind=dbl_kind) </span>::   
<a name="l01522"></a>01522           gxtmp, gytmp   <span class="comment">! temporary term for x- and y- limited gradient</span>
<a name="l01523"></a>01523 
<a name="l01524"></a>01524       gx(:,:) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01525"></a>01525       gy(:,:) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01526"></a>01526 
<a name="l01527"></a>01527       <span class="comment">! For nghost = 1, loop over physical cells and update ghost cells later</span>
<a name="l01528"></a>01528       <span class="comment">! For nghost = 2, loop over a layer of ghost cells and skip the update</span>
<a name="l01529"></a>01529 
<a name="l01530"></a>01530       icells = 0
<a name="l01531"></a>01531       <span class="keyword">do</span> j = jlo-nghost+1, jhi+nghost-1
<a name="l01532"></a>01532       <span class="keyword">do</span> i = ilo-nghost+1, ihi+nghost-1
<a name="l01533"></a>01533          <span class="keyword">if</span> (phimask(i,j) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l01534"></a>01534 
<a name="l01535"></a>01535 <span class="comment">!jw            icells = icells + 1</span>
<a name="l01536"></a>01536 <span class="comment">!jw            indxi(icells) = i</span>
<a name="l01537"></a>01537 <span class="comment">!jw            indxj(icells) = j</span>
<a name="l01538"></a>01538 <span class="comment">!jw         endif                  ! phimask &gt; puny</span>
<a name="l01539"></a>01539 <span class="comment">!jw      enddo</span>
<a name="l01540"></a>01540 <span class="comment">!jw      enddo</span>
<a name="l01541"></a>01541 
<a name="l01542"></a>01542 <span class="comment">!jw      do ij = 1, icells</span>
<a name="l01543"></a>01543 <span class="comment">!jw         i = indxi(ij)</span>
<a name="l01544"></a>01544 <span class="comment">!jw         j = indxj(ij)</span>
<a name="l01545"></a>01545 
<a name="l01546"></a>01546          <span class="comment">! Store values of phi in the 8 neighbor cells.</span>
<a name="l01547"></a>01547          <span class="comment">! Note: phimask = 1. or 0.  If phimask = 1., use the true value;</span>
<a name="l01548"></a>01548          <span class="comment">!  if phimask = 0., use the home cell value so that non-physical</span>
<a name="l01549"></a>01549          <span class="comment">!  values of phi do not contribute to the gradient.</span>
<a name="l01550"></a>01550          phi_nw = phimask(i-1,j+1) * phi(i-1,j+1)   &amp;
<a name="l01551"></a>01551             + (<a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>-phimask(i-1,j+1))* phi(i,j)
<a name="l01552"></a>01552          phi_n  = phimask(i,j+1)   * phi(i,j+1)   &amp;
<a name="l01553"></a>01553             + (<a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>-phimask(i,j+1))  * phi(i,j)
<a name="l01554"></a>01554          phi_ne = phimask(i+1,j+1) * phi(i+1,j+1)   &amp;
<a name="l01555"></a>01555             + (<a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>-phimask(i+1,j+1))* phi(i,j)
<a name="l01556"></a>01556          phi_w  = phimask(i-1,j)   * phi(i-1,j)   &amp;
<a name="l01557"></a>01557             + (<a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>-phimask(i-1,j))  * phi(i,j)
<a name="l01558"></a>01558          phi_e  = phimask(i+1,j)   * phi(i+1,j)   &amp;
<a name="l01559"></a>01559             + (<a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>-phimask(i+1,j))  * phi(i,j)
<a name="l01560"></a>01560          phi_sw = phimask(i-1,j-1) * phi(i-1,j-1)   &amp;
<a name="l01561"></a>01561             + (<a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>-phimask(i-1,j-1))* phi(i,j)
<a name="l01562"></a>01562          phi_s  = phimask(i,j-1)   * phi(i,j-1)   &amp;
<a name="l01563"></a>01563             + (<a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>-phimask(i,j-1))  * phi(i,j)
<a name="l01564"></a>01564          phi_se = phimask(i+1,j-1) * phi(i+1,j-1)   &amp;
<a name="l01565"></a>01565             + (<a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>-phimask(i+1,j-1))* phi(i,j)
<a name="l01566"></a>01566 
<a name="l01567"></a>01567          <span class="comment">! unlimited gradient components</span>
<a name="l01568"></a>01568          <span class="comment">! (factors of two cancel out)</span>
<a name="l01569"></a>01569 
<a name="l01570"></a>01570          gxtmp = (phi_e - phi(i,j)) / (dxt(i,j)   + dxt(i+1,j))   &amp;
<a name="l01571"></a>01571                + (phi(i,j) - phi_w) / (dxt(i-1,j) + dxt(i,j)  )
<a name="l01572"></a>01572          gytmp = (phi_n - phi(i,j)) / (dyt(i,j)   + dyt(i,j+1))   &amp;
<a name="l01573"></a>01573                + (phi(i,j) - phi_s) / (dyt(i,j-1) + dyt(i,j)  )
<a name="l01574"></a>01574 
<a name="l01575"></a>01575          <span class="comment">! minimum and maximum among the nine local cells</span>
<a name="l01576"></a>01576          pmn = min (phi_nw, phi_n,  phi_ne, phi_w, phi(i,j),   &amp;
<a name="l01577"></a>01577                     phi_e,  phi_sw, phi_s,  phi_se)
<a name="l01578"></a>01578          pmx = max (phi_nw, phi_n,  phi_ne, phi_w, phi(i,j),   &amp;
<a name="l01579"></a>01579                     phi_e,  phi_sw, phi_s,  phi_se)
<a name="l01580"></a>01580 
<a name="l01581"></a>01581          pmn = pmn - phi(i,j)
<a name="l01582"></a>01582          pmx = pmx - phi(i,j)
<a name="l01583"></a>01583 
<a name="l01584"></a>01584          <span class="comment">! minimum and maximum deviation of phi within the cell</span>
<a name="l01585"></a>01585 
<a name="l01586"></a>01586          w1  =  (<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*HTN(i,j)   - cnx(i,j)) * gxtmp   &amp;
<a name="l01587"></a>01587               + (<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*HTE(i,j)   - cny(i,j)) * gytmp
<a name="l01588"></a>01588          w2  =  (<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*HTN(i,j-1) - cnx(i,j)) * gxtmp   &amp;
<a name="l01589"></a>01589               - (<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*HTE(i,j)   + cny(i,j)) * gytmp
<a name="l01590"></a>01590          w3  = -(<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*HTN(i,j-1) + cnx(i,j)) * gxtmp   &amp;
<a name="l01591"></a>01591               - (<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*HTE(i-1,j) + cny(i,j)) * gytmp
<a name="l01592"></a>01592          w4  =  (<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*HTE(i-1,j) - cny(i,j)) * gytmp   &amp;
<a name="l01593"></a>01593               - (<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*HTN(i,j)   + cnx(i,j)) * gxtmp
<a name="l01594"></a>01594 
<a name="l01595"></a>01595          qmn = min (w1, w2, w3, w4)
<a name="l01596"></a>01596          qmx = max (w1, w2, w3, w4)
<a name="l01597"></a>01597 
<a name="l01598"></a>01598          <span class="comment">! Watch for underflows here</span>
<a name="l01599"></a>01599 
<a name="l01600"></a>01600          <span class="comment">! the limiting coefficient</span>
<a name="l01601"></a>01601          <span class="keyword">if</span> (abs(qmn) &gt; 1.0e-300_dbl_kind) <span class="keyword">then</span> <span class="comment">! &apos;abs(qmn) &gt; puny&apos; not sufficient</span>
<a name="l01602"></a>01602             w1 = max(<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>, pmn/qmn)
<a name="l01603"></a>01603          <span class="keyword">else</span>
<a name="l01604"></a>01604             w1 = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>
<a name="l01605"></a>01605          <span class="keyword">endif</span>
<a name="l01606"></a>01606 
<a name="l01607"></a>01607          <span class="keyword">if</span> (abs(qmx) &gt; 1.0e-300_dbl_kind) <span class="keyword">then</span>
<a name="l01608"></a>01608             w2 = max(<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>, pmx/qmx)
<a name="l01609"></a>01609          <span class="keyword">else</span>
<a name="l01610"></a>01610             w2 = <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>
<a name="l01611"></a>01611          <span class="keyword">endif</span>
<a name="l01612"></a>01612 
<a name="l01613"></a>01613          w1 = min(<a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>, w1, w2)
<a name="l01614"></a>01614 
<a name="l01615"></a>01615          <span class="comment">! Limit the gradient components</span>
<a name="l01616"></a>01616          gx(i,j) = w1 * gxtmp
<a name="l01617"></a>01617          gy(i,j) = w1 * gytmp
<a name="l01618"></a>01618 
<a name="l01619"></a>01619 <span class="comment">!jw      enddo                     ! ij</span>
<a name="l01620"></a>01620           <span class="keyword">endif</span>
<a name="l01621"></a>01621        <span class="keyword">enddo</span>
<a name="l01622"></a>01622       <span class="keyword">enddo</span>
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 <span class="keyword">      end subroutine limited_gradient</span>
<a name="l01625"></a>01625 
<a name="l01626"></a>01626 <span class="comment">!=======================================================================</span>
<a name="l01627"></a>01627 <span class="comment">!BOP</span>
<a name="l01628"></a>01628 <span class="comment">!</span>
<a name="l01629"></a>01629 <span class="comment">! !IROUTINE: departure_points - compute departure points of trajectories</span>
<a name="l01630"></a>01630 <span class="comment">!</span>
<a name="l01631"></a>01631 <span class="comment">! !INTERFACE:</span>
<a name="l01632"></a>01632 <span class="comment">!</span>
<a name="l01633"></a><a class="code" href="namespaceice__transport__remap.html#a6b993110f808c259c52b05216684684f">01633</a>       <span class="keyword">subroutine </span><a class="code" href="namespaceice__transport__remap.html#a6b993110f808c259c52b05216684684f">departure_points</a> (nx_block,   ny_block,   &amp;
<a name="l01634"></a>01634                                    ilo, ihi,   jlo, jhi,   &amp;
<a name="l01635"></a>01635                                    nghost,     dt,   &amp;
<a name="l01636"></a>01636                                    uvel,       vvel,    &amp;
<a name="l01637"></a>01637                                    dxu,        dyu,     &amp;
<a name="l01638"></a>01638                                    HTN,        HTE,     &amp;
<a name="l01639"></a>01639                                    dpx,        dpy,     &amp;
<a name="l01640"></a>01640                                    l_dp_midpt, l_stop,   &amp;
<a name="l01641"></a>01641                                    istop,      jstop)
<a name="l01642"></a>01642 <span class="comment">!</span>
<a name="l01643"></a>01643 <span class="comment">! !DESCRIPTION:</span>
<a name="l01644"></a>01644 <span class="comment">!</span>
<a name="l01645"></a>01645 <span class="comment">! Given velocity fields on cell corners, compute departure points</span>
<a name="l01646"></a>01646 <span class="comment">! of back trajectories in nondimensional coordinates.</span>
<a name="l01647"></a>01647 <span class="comment">!</span>
<a name="l01648"></a>01648 <span class="comment">! !REVISION HISTORY:</span>
<a name="l01649"></a>01649 <span class="comment">!</span>
<a name="l01650"></a>01650 <span class="comment">! author William H. Lipscomb, LANL</span>
<a name="l01651"></a>01651 <span class="comment">!</span>
<a name="l01652"></a>01652 <span class="comment">! !USES:</span>
<a name="l01653"></a>01653 <span class="comment">!</span>
<a name="l01654"></a>01654 <span class="comment">! !INPUT/OUTPUT PARAMETERS:</span>
<a name="l01655"></a>01655 <span class="comment">!</span>
<a name="l01656"></a>01656       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l01657"></a>01657          nx_block, ny_block,<span class="comment">! block dimensions</span>
<a name="l01658"></a>01658          ilo,ihi,jlo,jhi,   <span class="comment">! beginning and end of physical domain</span>
<a name="l01659"></a>01659          nghost              <span class="comment">! number of ghost cells</span>
<a name="l01660"></a>01660 
<a name="l01661"></a>01661       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l01662"></a>01662          dt               <span class="comment">! time step (s)</span>
<a name="l01663"></a>01663 
<a name="l01664"></a>01664       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l01665"></a>01665          uvel           ,<span class="comment">! x-component of velocity (m/s)</span>
<a name="l01666"></a>01666          vvel           ,<span class="comment">! y-component of velocity (m/s)</span>
<a name="l01667"></a>01667          dxu            ,<span class="comment">! E-W dimensions of U-cell (m)</span>
<a name="l01668"></a>01668          dyu            ,<span class="comment">! N-S dimensions of U-cell (m)</span>
<a name="l01669"></a>01669          HTN            ,<span class="comment">! length of north face of T-cell (m) </span>
<a name="l01670"></a>01670          HTE              <span class="comment">! length of east face of T-cell (m) </span>
<a name="l01671"></a>01671 
<a name="l01672"></a>01672       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block)</span>, <span class="keywordtype">intent(out)</span> ::   
<a name="l01673"></a>01673          dpx           ,<span class="comment">! coordinates of departure points (m)</span>
<a name="l01674"></a>01674          dpy             <span class="comment">! coordinates of departure points (m)</span>
<a name="l01675"></a>01675 
<a name="l01676"></a>01676       <span class="keywordtype">logical (kind=log_kind)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l01677"></a>01677          l_dp_midpt          <span class="comment">! if true, find departure points using</span>
<a name="l01678"></a>01678                              <span class="comment">! corrected midpoint velocity</span>
<a name="l01679"></a>01679 
<a name="l01680"></a>01680       <span class="keywordtype">logical (kind=log_kind)</span>, <span class="keywordtype">intent(inout)</span> ::   
<a name="l01681"></a>01681          l_stop       <span class="comment">! if true, abort on return</span>
<a name="l01682"></a>01682 
<a name="l01683"></a>01683       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(inout)</span> ::   
<a name="l01684"></a>01684          istop, jstop     <span class="comment">! indices of grid cell where model aborts </span>
<a name="l01685"></a>01685 <span class="comment">!</span>
<a name="l01686"></a>01686 <span class="comment">!EOP</span>
<a name="l01687"></a>01687 <span class="comment">!</span>
<a name="l01688"></a>01688       <span class="keywordtype">integer (kind=int_kind) </span>::   
<a name="l01689"></a>01689          i, j, i2, j2     <span class="comment">! horizontal indices</span>
<a name="l01690"></a>01690 
<a name="l01691"></a>01691       <span class="keywordtype">real (kind=dbl_kind) </span>::                  
<a name="l01692"></a>01692          mpx,  mpy      ,<span class="comment">! coordinates of midpoint of back trajectory,</span>
<a name="l01693"></a>01693                           <span class="comment">! relative to cell corner</span>
<a name="l01694"></a>01694          mpxt, mpyt     ,&amp;<span class="comment">! midpoint coordinates relative to cell center</span>
<a name="l01695"></a>01695          ump,  vmp        <span class="comment">! corrected velocity at midpoint</span>
<a name="l01696"></a>01696 
<a name="l01697"></a>01697     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01698"></a>01698     <span class="comment">! Estimate departure points.</span>
<a name="l01699"></a>01699     <span class="comment">! This estimate is 1st-order accurate in time; improve accuracy by</span>
<a name="l01700"></a>01700     <span class="comment">!  using midpoint approximation (to add later).</span>
<a name="l01701"></a>01701     <span class="comment">! For nghost = 1, loop over physical cells and update ghost cells later.</span>
<a name="l01702"></a>01702     <span class="comment">! For nghost = 2, loop over a layer of ghost cells and skip update.</span>
<a name="l01703"></a>01703     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01704"></a>01704 
<a name="l01705"></a>01705       dpx(:,:) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01706"></a>01706       dpy(:,:) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l01707"></a>01707 
<a name="l01708"></a>01708       <span class="keyword">do</span> j = jlo-nghost+1, jhi+nghost-1
<a name="l01709"></a>01709       <span class="keyword">do</span> i = ilo-nghost+1, ihi+nghost-1
<a name="l01710"></a>01710 
<a name="l01711"></a>01711          dpx(i,j) = -dt*uvel(i,j)
<a name="l01712"></a>01712          dpy(i,j) = -dt*vvel(i,j)
<a name="l01713"></a>01713 
<a name="l01714"></a>01714          <span class="comment">! Check for values out of bounds (more than one grid cell away)</span>
<a name="l01715"></a>01715          <span class="keyword">if</span> (dpx(i,j) &lt; -HTN(i,j) .or. dpx(i,j) &gt; HTN(i+1,j) .or.   &amp;
<a name="l01716"></a>01716              dpy(i,j) &lt; -HTE(i,j) .or. dpy(i,j) &gt; HTE(i,j+1)) <span class="keyword">then</span>
<a name="l01717"></a>01717             l_stop = .true.
<a name="l01718"></a>01718             istop = i
<a name="l01719"></a>01719             jstop = j
<a name="l01720"></a>01720          <span class="keyword">endif</span>
<a name="l01721"></a>01721 
<a name="l01722"></a>01722       <span class="keyword">enddo</span>
<a name="l01723"></a>01723       <span class="keyword">enddo</span>
<a name="l01724"></a>01724 
<a name="l01725"></a>01725       <span class="keyword">if</span> (l_stop) <span class="keyword">then</span>
<a name="l01726"></a>01726          i = istop
<a name="l01727"></a>01727          j = jstop
<a name="l01728"></a>01728          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos; &apos;</span>
<a name="l01729"></a>01729          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*)   &amp;
<a name="l01730"></a>01730                     <span class="stringliteral">&apos;Warning: Departure points out of bounds in remap&apos;</span>
<a name="l01731"></a>01731          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;my_task, i, j =&apos;</span>, <a class="code" href="namespaceice__communicate.html#a70e729e746e2e5ec592ccba505136002">my_task</a>, i, j
<a name="l01732"></a>01732          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;dpx, dpy =&apos;</span>, dpx(i,j), dpy(i,j)
<a name="l01733"></a>01733          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;HTN(i,j), HTN(i+1,j) =&apos;</span>, HTN(i,j), HTN(i+1,j)
<a name="l01734"></a>01734          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;HTE(i,j), HTE(i,j+1) =&apos;</span>, HTE(i,j), HTE(i,j+1)
<a name="l01735"></a>01735          return
<a name="l01736"></a>01736       <span class="keyword">endif</span>
<a name="l01737"></a>01737 
<a name="l01738"></a>01738       <span class="keyword">if</span> (l_dp_midpt) <span class="keyword">then</span> <span class="comment">! find dep pts using corrected midpt velocity </span>
<a name="l01739"></a>01739 
<a name="l01740"></a>01740        <span class="keyword">do</span> j = jlo-nghost+1, jhi+nghost-1
<a name="l01741"></a>01741        <span class="keyword">do</span> i = ilo-nghost+1, ihi+nghost-1
<a name="l01742"></a>01742          <span class="keyword">if</span> (uvel(i,j)/=<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .or. vvel(i,j)/=<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l01743"></a>01743  
<a name="l01744"></a>01744     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01745"></a>01745     <span class="comment">! Scale departure points to coordinate system in which grid cells</span>
<a name="l01746"></a>01746     <span class="comment">! have sides of unit length.</span>
<a name="l01747"></a>01747     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01748"></a>01748 
<a name="l01749"></a>01749             dpx(i,j) = dpx(i,j) / dxu(i,j)
<a name="l01750"></a>01750             dpy(i,j) = dpy(i,j) / dyu(i,j)
<a name="l01751"></a>01751 
<a name="l01752"></a>01752     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01753"></a>01753     <span class="comment">! Estimate midpoint of backward trajectory relative to corner (i,j).</span>
<a name="l01754"></a>01754     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01755"></a>01755 
<a name="l01756"></a>01756             mpx = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * dpx(i,j)
<a name="l01757"></a>01757             mpy = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * dpy(i,j)
<a name="l01758"></a>01758  
<a name="l01759"></a>01759     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01760"></a>01760     <span class="comment">! Determine the indices (i2,j2) of the cell where the trajectory lies.</span>
<a name="l01761"></a>01761     <span class="comment">! Compute the coordinates of the midpoint of the backward trajectory</span>
<a name="l01762"></a>01762     <span class="comment">!  relative to the cell center in a stretch coordinate system</span>
<a name="l01763"></a>01763     <span class="comment">!  with vertices at (1/2, 1/2), (1/2, -1/2), etc.</span>
<a name="l01764"></a>01764     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01765"></a>01765 
<a name="l01766"></a>01766             <span class="keyword">if</span> (mpx &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. mpy &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>    <span class="comment">! cell (i+1,j+1)</span>
<a name="l01767"></a>01767                i2 = i+1
<a name="l01768"></a>01768                j2 = j+1
<a name="l01769"></a>01769                mpxt = mpx - <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>
<a name="l01770"></a>01770                mpyt = mpy - <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>
<a name="l01771"></a>01771             elseif (mpx &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. mpy &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>  <span class="comment">! cell (i,j)</span>
<a name="l01772"></a>01772                i2 = i
<a name="l01773"></a>01773                j2 = j
<a name="l01774"></a>01774                mpxt = mpx + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>
<a name="l01775"></a>01775                mpyt = mpy + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>
<a name="l01776"></a>01776             elseif (mpx &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. mpy &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span> <span class="comment">! cell (i+1,j)</span>
<a name="l01777"></a>01777                i2 = i+1
<a name="l01778"></a>01778                j2 = j
<a name="l01779"></a>01779                mpxt = mpx - <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>
<a name="l01780"></a>01780                mpyt = mpy + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>
<a name="l01781"></a>01781             elseif (mpx &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. mpy &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span> <span class="comment">! cell (i,j+1)</span>
<a name="l01782"></a>01782                i2 = i
<a name="l01783"></a>01783                j2 = j+1
<a name="l01784"></a>01784                mpxt = mpx + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>
<a name="l01785"></a>01785                mpyt = mpy - <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>
<a name="l01786"></a>01786             <span class="keyword">endif</span>
<a name="l01787"></a>01787             
<a name="l01788"></a>01788     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01789"></a>01789     <span class="comment">! Using a bilinear approximation, estimate the velocity at the</span>
<a name="l01790"></a>01790     <span class="comment">! trajectory midpoint in the (i2,j2) reference frame.</span>
<a name="l01791"></a>01791     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01792"></a>01792  
<a name="l01793"></a>01793             ump = uvel(i2-1,j2-1)*(mpxt-<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)*(mpyt-<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)     &amp;
<a name="l01794"></a>01794                 - uvel(i2,  j2-1)*(mpxt+<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)*(mpyt-<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)     &amp;
<a name="l01795"></a>01795                 + uvel(i2,  j2  )*(mpxt+<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)*(mpyt+<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)     &amp;  
<a name="l01796"></a>01796                 - uvel(i2-1,j2  )*(mpxt-<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)*(mpyt+<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)
<a name="l01797"></a>01797  
<a name="l01798"></a>01798             vmp = vvel(i2-1,j2-1)*(mpxt-<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)*(mpyt-<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)     &amp;
<a name="l01799"></a>01799                 - vvel(i2,  j2-1)*(mpxt+<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)*(mpyt-<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)     &amp;
<a name="l01800"></a>01800                 + vvel(i2,  j2  )*(mpxt+<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)*(mpyt+<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)     &amp;
<a name="l01801"></a>01801                 - vvel(i2-1,j2  )*(mpxt-<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)*(mpyt+<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>)
<a name="l01802"></a>01802  
<a name="l01803"></a>01803     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01804"></a>01804     <span class="comment">! Use the midpoint velocity to estimate the coordinates of the</span>
<a name="l01805"></a>01805     <span class="comment">!  departure point relative to corner (i,j).</span>
<a name="l01806"></a>01806     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01807"></a>01807  
<a name="l01808"></a>01808             dpx(i,j) = -dt * ump
<a name="l01809"></a>01809             dpy(i,j) = -dt * vmp
<a name="l01810"></a>01810  
<a name="l01811"></a>01811          <span class="keyword">endif</span>               <span class="comment">! nonzero velocity</span>
<a name="l01812"></a>01812 
<a name="l01813"></a>01813        <span class="keyword">enddo</span>                 <span class="comment">! i</span>
<a name="l01814"></a>01814        <span class="keyword">enddo</span>                 <span class="comment">! j</span>
<a name="l01815"></a>01815  
<a name="l01816"></a>01816       <span class="keyword">endif</span>                  <span class="comment">! l_dp_midpt</span>
<a name="l01817"></a>01817 
<a name="l01818"></a>01818 <span class="keyword">      end subroutine departure_points</span>
<a name="l01819"></a>01819 
<a name="l01820"></a>01820 <span class="comment">!=======================================================================</span>
<a name="l01821"></a>01821 <span class="comment">!</span>
<a name="l01822"></a>01822 <span class="comment">!BOP</span>
<a name="l01823"></a>01823 <span class="comment">!</span>
<a name="l01824"></a>01824 <span class="comment">! !IROUTINE: locate_triangles - triangle info for cell edges</span>
<a name="l01825"></a>01825 <span class="comment">!</span>
<a name="l01826"></a>01826 <span class="comment">! !INTERFACE:</span>
<a name="l01827"></a>01827 <span class="comment">!</span>
<a name="l01828"></a><a class="code" href="namespaceice__transport__remap.html#a5ed79661ddd56d26d4e863b7ec1b9a0a">01828</a>       <span class="keyword">subroutine </span><a class="code" href="namespaceice__transport__remap.html#a5ed79661ddd56d26d4e863b7ec1b9a0a">locate_triangles</a> (nx_block,     ny_block,   &amp;
<a name="l01829"></a>01829                                    ilo, ihi,     jlo, jhi,   &amp;
<a name="l01830"></a>01830                                    nghost,       edge,       &amp;
<a name="l01831"></a>01831                                    icells,                   &amp;
<a name="l01832"></a>01832                                    indxi,        indxj,      &amp;
<a name="l01833"></a>01833                                    dpx,          dpy,        &amp;
<a name="l01834"></a>01834                                    dxu,          dyu,        &amp;
<a name="l01835"></a>01835                                    xp,           yp,         &amp;
<a name="l01836"></a>01836                                    iflux,        jflux,      &amp;
<a name="l01837"></a>01837                                    triarea,                  &amp;
<a name="l01838"></a>01838                                    l_fixed_area, edgearea)
<a name="l01839"></a>01839 <span class="comment">!</span>
<a name="l01840"></a>01840 
<a name="l01841"></a>01841 <span class="comment">! !DESCRIPTION:</span>
<a name="l01842"></a>01842 <span class="comment">!</span>
<a name="l01843"></a>01843 <span class="comment">! Compute areas and vertices of transport triangles for north or</span>
<a name="l01844"></a>01844 <span class="comment">!  east cell edges.</span>
<a name="l01845"></a>01845 <span class="comment">!</span>
<a name="l01846"></a>01846 <span class="comment">! !REVISION HISTORY:</span>
<a name="l01847"></a>01847 <span class="comment">!</span>
<a name="l01848"></a>01848 <span class="comment">! authors William H. Lipscomb, LANL</span>
<a name="l01849"></a>01849 <span class="comment">!         John R. Baumgardner, LANL</span>
<a name="l01850"></a>01850 <span class="comment">!</span>
<a name="l01851"></a>01851 <span class="comment">! !USES:</span>
<a name="l01852"></a>01852 <span class="comment">!</span>
<a name="l01853"></a>01853 <span class="comment">!</span>
<a name="l01854"></a>01854 <span class="comment">! !INPUT/OUTPUT PARAMETERS:</span>
<a name="l01855"></a>01855 <span class="comment">!</span>
<a name="l01856"></a>01856       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l01857"></a>01857          nx_block, ny_block,<span class="comment">! block dimensions</span>
<a name="l01858"></a>01858          ilo,ihi,jlo,jhi   ,<span class="comment">! beginning and end of physical domain</span>
<a name="l01859"></a>01859          nghost              <span class="comment">! number of ghost cells</span>
<a name="l01860"></a>01860 
<a name="l01861"></a>01861       <span class="keywordtype">character (len=char_len)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l01862"></a>01862          edge             <span class="comment">! &apos;north&apos; or &apos;east&apos;</span>
<a name="l01863"></a>01863 
<a name="l01864"></a>01864       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension(nx_block,ny_block)</span>, <span class="keywordtype">intent(in)</span> ::  
<a name="l01865"></a>01865          dpx            ,<span class="comment">! x coordinates of departure points at cell corners</span>
<a name="l01866"></a>01866          dpy            ,<span class="comment">! y coordinates of departure points at cell corners</span>
<a name="l01867"></a>01867          dxu            ,<span class="comment">! E-W dimension of U-cell (m)</span>
<a name="l01868"></a>01868          dyu              <span class="comment">! N-S dimension of U-cell (m)</span>
<a name="l01869"></a>01869 
<a name="l01870"></a>01870       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,0:nvert,ngroups)</span>,   
<a name="l01871"></a>01871          <span class="keywordtype">intent(out)</span> ::   
<a name="l01872"></a>01872          xp, yp           <span class="comment">! coordinates of triangle vertices</span>
<a name="l01873"></a>01873 
<a name="l01874"></a>01874       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,ngroups)</span>,   
<a name="l01875"></a>01875            <span class="keywordtype">intent(out)</span> ::   
<a name="l01876"></a>01876          triarea          <span class="comment">! area of departure triangle</span>
<a name="l01877"></a>01877 
<a name="l01878"></a>01878       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,ngroups)</span>,    
<a name="l01879"></a>01879          <span class="keywordtype">intent(out)</span> ::   
<a name="l01880"></a>01880          iflux          ,<span class="comment">! i index of cell contributing transport</span>
<a name="l01881"></a>01881          jflux            <span class="comment">! j index of cell contributing transport</span>
<a name="l01882"></a>01882 
<a name="l01883"></a>01883       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (ngroups)</span>, <span class="keywordtype">intent(out)</span> ::   
<a name="l01884"></a>01884          icells           <span class="comment">! number of cells where triarea &gt; puny</span>
<a name="l01885"></a>01885 
<a name="l01886"></a>01886       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (nx_block*ny_block,ngroups)</span>, 
<a name="l01887"></a>01887          <span class="keywordtype">intent(out)</span> ::                                               
<a name="l01888"></a>01888          indxi          ,<span class="comment">! compressed index in i-direction</span>
<a name="l01889"></a>01889          indxj            <span class="comment">! compressed index in j-direction</span>
<a name="l01890"></a>01890 
<a name="l01891"></a>01891       <span class="keywordtype">logical</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l01892"></a>01892          l_fixed_area     <span class="comment">! if true, the area of each departure region is</span>
<a name="l01893"></a>01893                           <span class="comment">!  passed in as edgearea</span>
<a name="l01894"></a>01894                           <span class="comment">! if false, edgearea if determined internally</span>
<a name="l01895"></a>01895                           <span class="comment">!  and is passed out</span>
<a name="l01896"></a>01896                           
<a name="l01897"></a>01897       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension(nx_block,ny_block)</span>, <span class="keywordtype">intent(inout)</span> ::   
<a name="l01898"></a>01898          edgearea         <span class="comment">! area of departure region for each edge</span>
<a name="l01899"></a>01899                           <span class="comment">! edgearea &gt; 0 for eastward/northward flow</span>
<a name="l01900"></a>01900 <span class="comment">!</span>
<a name="l01901"></a>01901 <span class="comment">!EOP</span>
<a name="l01902"></a>01902 <span class="comment">!</span>
<a name="l01903"></a>01903       <span class="keywordtype">integer (kind=int_kind) </span>::   
<a name="l01904"></a>01904          i, j, ij, ic   ,<span class="comment">! horizontal indices</span>
<a name="l01905"></a>01905          ib, ie, jb, je ,<span class="comment">! limits for loops over edges</span>
<a name="l01906"></a>01906          ng, nv         ,<span class="comment">! triangle indices</span>
<a name="l01907"></a>01907          ishift, jshift   <span class="comment">! differences between neighbor cells</span>
<a name="l01908"></a>01908 
<a name="l01909"></a>01909       <span class="keywordtype">integer (kind=int_kind) </span>::   
<a name="l01910"></a>01910          icellsd          <span class="comment">! number of cells where departure area &gt; 0.</span>
<a name="l01911"></a>01911 
<a name="l01912"></a>01912       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (nx_block*ny_block) </span>::  
<a name="l01913"></a>01913          indxid         ,<span class="comment">! compressed index in i-direction</span>
<a name="l01914"></a>01914          indxjd           <span class="comment">! compressed index in j-direction</span>
<a name="l01915"></a>01915 
<a name="l01916"></a>01916       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension(nx_block,ny_block) </span>::   
<a name="l01917"></a>01917          dx, dy         ,<span class="comment">! scaled departure points</span>
<a name="l01918"></a>01918          areafac_c      ,<span class="comment">! area scale factor at center of edge</span>
<a name="l01919"></a>01919          areafac_l      ,<span class="comment">! area scale factor at left corner</span>
<a name="l01920"></a>01920          areafac_r        <span class="comment">! area scale factor at right corner</span>
<a name="l01921"></a>01921 
<a name="l01922"></a>01922       <span class="keywordtype">real (kind=dbl_kind) </span>::   
<a name="l01923"></a>01923          xcl, ycl       ,<span class="comment">! coordinates of left corner point</span>
<a name="l01924"></a>01924                           <span class="comment">! (relative to midpoint of edge)</span>
<a name="l01925"></a>01925          xdl, ydl       ,&amp;<span class="comment">! left departure point</span>
<a name="l01926"></a>01926          xil, yil       ,&amp;<span class="comment">! left intersection point</span>
<a name="l01927"></a>01927          xcr, ycr       ,&amp;<span class="comment">! right corner point</span>
<a name="l01928"></a>01928          xdr, ydr       ,&amp;<span class="comment">! right departure point</span>
<a name="l01929"></a>01929          xir, yir       ,&amp;<span class="comment">! right intersection point</span>
<a name="l01930"></a>01930          xic, yic       ,&amp;<span class="comment">! x-axis intersection point</span>
<a name="l01931"></a>01931          xicl, yicl     ,&amp;<span class="comment">! left-hand x-axis intersection point</span>
<a name="l01932"></a>01932          xicr, yicr     ,&amp;<span class="comment">! right-hand x-axis intersection point</span>
<a name="l01933"></a>01933          xdm, ydm       ,&amp;<span class="comment">! midpoint of segment connecting DL and DR;</span>
<a name="l01934"></a>01934                           <span class="comment">! shifted if l_fixed_area = T</span>
<a name="l01935"></a>01935          dxc            ,&amp;<span class="comment">! xcr - xcl</span>
<a name="l01936"></a>01936          dxd            ,&amp;<span class="comment">! xdr - xdl</span>
<a name="l01937"></a>01937          md             ,&amp;<span class="comment">! slope of line connecting DL and DR</span>
<a name="l01938"></a>01938          mdl            ,&amp;<span class="comment">! slope of line connecting DL and DM</span>
<a name="l01939"></a>01939          mdr            ,&amp;<span class="comment">! slope of line connecting DR and DM</span>
<a name="l01940"></a>01940          ishift_tl, jshift_tl ,&amp;<span class="comment">! i,j indices of TL cell relative to edge</span>
<a name="l01941"></a>01941          ishift_bl, jshift_bl ,&amp;<span class="comment">! i,j indices of BL cell relative to edge</span>
<a name="l01942"></a>01942          ishift_tr, jshift_tr ,&amp;<span class="comment">! i,j indices of TR cell relative to edge</span>
<a name="l01943"></a>01943          ishift_br, jshift_br ,&amp;<span class="comment">! i,j indices of BR cell relative to edge</span>
<a name="l01944"></a>01944          ishift_tc, jshift_tc ,&amp;<span class="comment">! i,j indices of TC cell relative to edge</span>
<a name="l01945"></a>01945          ishift_bc, jshift_bc ,&amp;<span class="comment">! i,j indices of BC cell relative to edge</span>
<a name="l01946"></a>01946          area1, area2         ,&amp;<span class="comment">! temporary triangle areas</span>
<a name="l01947"></a>01947          area3, area4         ,&amp;<span class="comment">! </span>
<a name="l01948"></a>01948          area_c               ,&amp;<span class="comment">! center polygon area</span>
<a name="l01949"></a>01949          w1, w2                 <span class="comment">! work variables</span>
<a name="l01950"></a>01950 
<a name="l01951"></a>01951       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block,ny_block,ngroups) </span>::   
<a name="l01952"></a>01952          areafact         <span class="comment">! = 1 for positive flux, -1 for negative</span>
<a name="l01953"></a>01953 
<a name="l01954"></a>01954       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension(nx_block,ny_block) </span>::   
<a name="l01955"></a>01955          areasum          <span class="comment">! sum of triangle areas for a given edge</span>
<a name="l01956"></a>01956       
<a name="l01957"></a>01957     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l01958"></a>01958     <span class="comment">! Triangle notation:</span>
<a name="l01959"></a>01959     <span class="comment">! For each edge, there are 20 triangles that can contribute,</span>
<a name="l01960"></a>01960     <span class="comment">! but many of these are mutually exclusive.  It turns out that</span>
<a name="l01961"></a>01961     <span class="comment">! at most 5 triangles can contribute to transport integrals at once.</span>
<a name="l01962"></a>01962     <span class="comment">!</span>
<a name="l01963"></a>01963     <span class="comment">! See Figure 3 in DB for pictures of these triangles.</span>
<a name="l01964"></a>01964     <span class="comment">! See Table 1 in DB for logical conditions.</span>
<a name="l01965"></a>01965     <span class="comment">!</span>
<a name="l01966"></a>01966     <span class="comment">! For the north edge, DB refer to these triangles as:</span>
<a name="l01967"></a>01967     <span class="comment">! (1) NW, NW1, W, W2</span>
<a name="l01968"></a>01968     <span class="comment">! (2) NE, NE1, E, E2</span>
<a name="l01969"></a>01969     <span class="comment">! (3) NW2, W1, NE2, E1</span>
<a name="l01970"></a>01970     <span class="comment">! (4) H1a, H1b, N1a, N1b</span>
<a name="l01971"></a>01971     <span class="comment">! (5) H2a, H2b, N2a, N2b</span>
<a name="l01972"></a>01972     <span class="comment">!</span>
<a name="l01973"></a>01973     <span class="comment">! For the east edge, DB refer to these triangles as:</span>
<a name="l01974"></a>01974     <span class="comment">! (1) NE, NE1, N, N2</span>
<a name="l01975"></a>01975     <span class="comment">! (2) SE, SE1, S, S2</span>
<a name="l01976"></a>01976     <span class="comment">! (3) NE2, N1, SE2, S1</span>
<a name="l01977"></a>01977     <span class="comment">! (4) H1a, H1b, E1a, E2b</span>
<a name="l01978"></a>01978     <span class="comment">! (5) H2a, H2b, E2a, E2b</span>
<a name="l01979"></a>01979     <span class="comment">!</span>
<a name="l01980"></a>01980     <span class="comment">! The code below works for either north or east edges.</span>
<a name="l01981"></a>01981     <span class="comment">! The respective triangle labels are:</span>
<a name="l01982"></a>01982     <span class="comment">! (1) TL,  TL1, BL,  BL2</span>
<a name="l01983"></a>01983     <span class="comment">! (2) TR,  TR1, BR,  BR2</span>
<a name="l01984"></a>01984     <span class="comment">! (3) TL2, BL1, TR2, BR1</span>
<a name="l01985"></a>01985     <span class="comment">! (4) BC1a, BC1b, TC1a, TC2b</span>
<a name="l01986"></a>01986     <span class="comment">! (5) BC2a, BC2b, TC2a, TC2b</span>
<a name="l01987"></a>01987     <span class="comment">! </span>
<a name="l01988"></a>01988     <span class="comment">! where the cell labels are:</span>
<a name="l01989"></a>01989     <span class="comment">! </span>
<a name="l01990"></a>01990     <span class="comment">!          |        |</span>
<a name="l01991"></a>01991     <span class="comment">!     TL   |   TC   |   TR     (top left, center, right)</span>
<a name="l01992"></a>01992     <span class="comment">!          |        |</span>
<a name="l01993"></a>01993     <span class="comment">!   ------------------------</span>
<a name="l01994"></a>01994     <span class="comment">!          |        |</span>
<a name="l01995"></a>01995     <span class="comment">!     BL   |   BC   |   BR     (bottom left, center, right)</span>
<a name="l01996"></a>01996     <span class="comment">!          |        |</span>
<a name="l01997"></a>01997     <span class="comment">!</span>
<a name="l01998"></a>01998     <span class="comment">! and the transport is across the edge between cells TC and TB.</span>
<a name="l01999"></a>01999     <span class="comment">!</span>
<a name="l02000"></a>02000     <span class="comment">! Departure points are scaled to a local coordinate system</span>
<a name="l02001"></a>02001     <span class="comment">!  whose origin is at the midpoint of the edge.</span>
<a name="l02002"></a>02002     <span class="comment">! In this coordinate system, the lefthand corner CL = (-0.5,0)</span>
<a name="l02003"></a>02003     <span class="comment">!  and the righthand corner CR = (0.5, 0).</span>
<a name="l02004"></a>02004     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02005"></a>02005   
<a name="l02006"></a>02006     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02007"></a>02007     <span class="comment">! Initialize</span>
<a name="l02008"></a>02008     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02009"></a>02009 
<a name="l02010"></a>02010       areafac_c(:,:) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02011"></a>02011       areafac_l(:,:) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02012"></a>02012       areafac_r(:,:) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02013"></a>02013       <span class="keyword">do</span> ng = 1, <a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">ngroups</a>
<a name="l02014"></a>02014          <span class="keyword">do</span> j = 1, ny_block
<a name="l02015"></a>02015          <span class="keyword">do</span> i = 1, nx_block
<a name="l02016"></a>02016             triarea (i,j,ng) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02017"></a>02017             areafact(i,j,ng) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02018"></a>02018             iflux   (i,j,ng) = i
<a name="l02019"></a>02019             jflux   (i,j,ng) = j
<a name="l02020"></a>02020          <span class="keyword">enddo</span>
<a name="l02021"></a>02021          <span class="keyword">enddo</span>
<a name="l02022"></a>02022          <span class="keyword">do</span> nv = 0, nvert
<a name="l02023"></a>02023             <span class="keyword">do</span> j = 1, ny_block
<a name="l02024"></a>02024             <span class="keyword">do</span> i = 1, nx_block
<a name="l02025"></a>02025                xp(i,j,nv,ng) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02026"></a>02026                yp(i,j,nv,ng) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02027"></a>02027             <span class="keyword">enddo</span>
<a name="l02028"></a>02028             <span class="keyword">enddo</span>
<a name="l02029"></a>02029          <span class="keyword">enddo</span>
<a name="l02030"></a>02030       <span class="keyword">enddo</span>
<a name="l02031"></a>02031 
<a name="l02032"></a>02032       <span class="keyword">if</span> (trim(edge) == <span class="stringliteral">&apos;north&apos;</span>) <span class="keyword">then</span>
<a name="l02033"></a>02033 
<a name="l02034"></a>02034          <span class="comment">! loop size</span>
<a name="l02035"></a>02035 
<a name="l02036"></a>02036          ib = ilo
<a name="l02037"></a>02037          ie = ihi 
<a name="l02038"></a>02038          jb = jlo - nghost            <span class="comment">! lowest j index is a ghost cell</span>
<a name="l02039"></a>02039          je = jhi
<a name="l02040"></a>02040 
<a name="l02041"></a>02041          <span class="comment">! index shifts for neighbor cells</span>
<a name="l02042"></a>02042 
<a name="l02043"></a>02043          ishift_tl = -1
<a name="l02044"></a>02044          jshift_tl =  1
<a name="l02045"></a>02045          ishift_bl = -1
<a name="l02046"></a>02046          jshift_bl =  0
<a name="l02047"></a>02047          ishift_tr =  1
<a name="l02048"></a>02048          jshift_tr =  1
<a name="l02049"></a>02049          ishift_br =  1
<a name="l02050"></a>02050          jshift_br =  0
<a name="l02051"></a>02051          ishift_tc =  0
<a name="l02052"></a>02052          jshift_tc =  1
<a name="l02053"></a>02053          ishift_bc =  0
<a name="l02054"></a>02054          jshift_bc =  0
<a name="l02055"></a>02055 
<a name="l02056"></a>02056          <span class="comment">! area scale factor</span>
<a name="l02057"></a>02057 
<a name="l02058"></a>02058          <span class="keyword">do</span> j = jb, je
<a name="l02059"></a>02059          <span class="keyword">do</span> i = ib, ie
<a name="l02060"></a>02060             areafac_l(i,j) = dxu(i-1,j)*dyu(i-1,j) 
<a name="l02061"></a>02061             areafac_r(i,j) = dxu(i,j)*dyu(i,j) 
<a name="l02062"></a>02062             areafac_c(i,j) = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*(areafac_l(i,j) + areafac_r(i,j))
<a name="l02063"></a>02063          <span class="keyword">enddo</span>
<a name="l02064"></a>02064          <span class="keyword">enddo</span>
<a name="l02065"></a>02065 
<a name="l02066"></a>02066       <span class="keyword">else</span>                      <span class="comment">! east edge</span>
<a name="l02067"></a>02067 
<a name="l02068"></a>02068          <span class="comment">! loop size</span>
<a name="l02069"></a>02069 
<a name="l02070"></a>02070          ib = ilo - nghost            <span class="comment">! lowest i index is a ghost cell</span>
<a name="l02071"></a>02071          ie = ihi
<a name="l02072"></a>02072          jb = jlo
<a name="l02073"></a>02073          je = jhi
<a name="l02074"></a>02074 
<a name="l02075"></a>02075          <span class="comment">! index shifts for neighbor cells</span>
<a name="l02076"></a>02076 
<a name="l02077"></a>02077          ishift_tl =  1
<a name="l02078"></a>02078          jshift_tl =  1
<a name="l02079"></a>02079          ishift_bl =  0
<a name="l02080"></a>02080          jshift_bl =  1
<a name="l02081"></a>02081          ishift_tr =  1
<a name="l02082"></a>02082          jshift_tr = -1
<a name="l02083"></a>02083          ishift_br =  0
<a name="l02084"></a>02084          jshift_br = -1
<a name="l02085"></a>02085          ishift_tc =  1
<a name="l02086"></a>02086          jshift_tc =  0
<a name="l02087"></a>02087          ishift_bc =  0
<a name="l02088"></a>02088          jshift_bc =  0
<a name="l02089"></a>02089 
<a name="l02090"></a>02090          <span class="comment">! area scale factors</span>
<a name="l02091"></a>02091 
<a name="l02092"></a>02092          <span class="keyword">do</span> j = jb, je
<a name="l02093"></a>02093          <span class="keyword">do</span> i = ib, ie
<a name="l02094"></a>02094             areafac_l(i,j) = dxu(i,j)*dyu(i,j) 
<a name="l02095"></a>02095             areafac_r(i,j) = dxu(i,j-1)*dyu(i,j-1)
<a name="l02096"></a>02096             areafac_c(i,j) = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * (areafac_l(i,j) + areafac_r(i,j))
<a name="l02097"></a>02097          <span class="keyword">enddo</span>
<a name="l02098"></a>02098          <span class="keyword">enddo</span>
<a name="l02099"></a>02099 
<a name="l02100"></a>02100       <span class="keyword">endif</span>
<a name="l02101"></a>02101 
<a name="l02102"></a>02102     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02103"></a>02103     <span class="comment">! Compute mask for edges with nonzero departure areas</span>
<a name="l02104"></a>02104     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02105"></a>02105 
<a name="l02106"></a>02106       <span class="keyword">if</span> (l_fixed_area) <span class="keyword">then</span>
<a name="l02107"></a>02107          icellsd = 0
<a name="l02108"></a>02108          <span class="keyword">do</span> j = jb, je
<a name="l02109"></a>02109          <span class="keyword">do</span> i = ib, ie
<a name="l02110"></a>02110             <span class="keyword">if</span> (edgearea(i,j) /= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02111"></a>02111                icellsd = icellsd + 1
<a name="l02112"></a>02112                indxid(icellsd) = i
<a name="l02113"></a>02113                indxjd(icellsd) = j
<a name="l02114"></a>02114             <span class="keyword">endif</span>
<a name="l02115"></a>02115          <span class="keyword">enddo</span>
<a name="l02116"></a>02116          <span class="keyword">enddo</span>
<a name="l02117"></a>02117       <span class="keyword">else</span>
<a name="l02118"></a>02118          icellsd = 0
<a name="l02119"></a>02119          <span class="keyword">if</span> (trim(edge) == <span class="stringliteral">&apos;north&apos;</span>) <span class="keyword">then</span>
<a name="l02120"></a>02120             <span class="keyword">do</span> j = jb, je
<a name="l02121"></a>02121             <span class="keyword">do</span> i = ib, ie
<a name="l02122"></a>02122                <span class="keyword">if</span> (dpx(i-1,j)/=<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .or. dpy(i-1,j)/=<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>   &amp;
<a name="l02123"></a>02123                                   .or.                  &amp;
<a name="l02124"></a>02124                      dpx(i,j)/=<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .or.   dpy(i,j)/=<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02125"></a>02125                   icellsd = icellsd + 1
<a name="l02126"></a>02126                   indxid(icellsd) = i
<a name="l02127"></a>02127                   indxjd(icellsd) = j
<a name="l02128"></a>02128                <span class="keyword">endif</span>
<a name="l02129"></a>02129             <span class="keyword">enddo</span>
<a name="l02130"></a>02130             <span class="keyword">enddo</span>
<a name="l02131"></a>02131          <span class="keyword">else</span>       <span class="comment">! east edge</span>
<a name="l02132"></a>02132             <span class="keyword">do</span> j = jb, je
<a name="l02133"></a>02133             <span class="keyword">do</span> i = ib, ie
<a name="l02134"></a>02134                <span class="keyword">if</span> (dpx(i,j-1)/=<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .or. dpy(i,j-1)/=<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>   &amp;
<a name="l02135"></a>02135                                   .or.                  &amp;
<a name="l02136"></a>02136                      dpx(i,j)/=<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .or.   dpy(i,j)/=<a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02137"></a>02137                   icellsd = icellsd + 1
<a name="l02138"></a>02138                   indxid(icellsd) = i
<a name="l02139"></a>02139                   indxjd(icellsd) = j
<a name="l02140"></a>02140                <span class="keyword">endif</span>
<a name="l02141"></a>02141             <span class="keyword">enddo</span>
<a name="l02142"></a>02142             <span class="keyword">enddo</span>
<a name="l02143"></a>02143          <span class="keyword">endif</span>       <span class="comment">! edge = north/east</span>
<a name="l02144"></a>02144       <span class="keyword">endif</span>          <span class="comment">! l_fixed_area</span>
<a name="l02145"></a>02145 
<a name="l02146"></a>02146     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02147"></a>02147     <span class="comment">! Scale the departure points</span>
<a name="l02148"></a>02148     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02149"></a>02149 
<a name="l02150"></a>02150       <span class="keyword">do</span> j = 1, je
<a name="l02151"></a>02151       <span class="keyword">do</span> i = 1, ie
<a name="l02152"></a>02152          dx(i,j) = dpx(i,j) / dxu(i,j)
<a name="l02153"></a>02153          dy(i,j) = dpy(i,j) / dyu(i,j)
<a name="l02154"></a>02154       <span class="keyword">enddo</span>
<a name="l02155"></a>02155       <span class="keyword">enddo</span>
<a name="l02156"></a>02156 
<a name="l02157"></a>02157     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02158"></a>02158     <span class="comment">! Compute departure regions, divide into triangles, and locate</span>
<a name="l02159"></a>02159     <span class="comment">!  vertices of each triangle.</span>
<a name="l02160"></a>02160     <span class="comment">! Work in a nondimensional coordinate system in which lengths are</span>
<a name="l02161"></a>02161     <span class="comment">!  scaled by the local metric coefficients (dxu and dyu).</span>
<a name="l02162"></a>02162     <span class="comment">! Note: The do loop includes north faces of the j = 1 ghost cells</span>
<a name="l02163"></a>02163     <span class="comment">!       when edge = &apos;north&apos;.  The loop includes east faces of i = 1</span>
<a name="l02164"></a>02164     <span class="comment">!       ghost cells when edge = &apos;east&apos;.</span>
<a name="l02165"></a>02165     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02166"></a>02166 
<a name="l02167"></a>02167       <span class="keyword">do</span> ij = 1, icellsd
<a name="l02168"></a>02168          i = indxid(ij)
<a name="l02169"></a>02169          j = indxjd(ij)
<a name="l02170"></a>02170   
<a name="l02171"></a>02171          xcl = -<a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>
<a name="l02172"></a>02172          ycl =  <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02173"></a>02173 
<a name="l02174"></a>02174          xcr =  <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>
<a name="l02175"></a>02175          ycr =  <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02176"></a>02176 
<a name="l02177"></a>02177          <span class="comment">! Departure points</span>
<a name="l02178"></a>02178 
<a name="l02179"></a>02179          <span class="keyword">if</span> (trim(edge) == <span class="stringliteral">&apos;north&apos;</span>) <span class="keyword">then</span> <span class="comment">! north edge</span>
<a name="l02180"></a>02180             xdl = xcl + dx(i-1,j)
<a name="l02181"></a>02181             ydl = ycl + dy(i-1,j)
<a name="l02182"></a>02182             xdr = xcr + dx(i,j)
<a name="l02183"></a>02183             ydr = ycr + dy(i,j)
<a name="l02184"></a>02184          <span class="keyword">else</span>                   <span class="comment">! east edge; rotate trajectory by pi/2</span>
<a name="l02185"></a>02185             xdl = xcl - dy(i,j)
<a name="l02186"></a>02186             ydl = ycl + dx(i,j)
<a name="l02187"></a>02187             xdr = xcr - dy(i,j-1)
<a name="l02188"></a>02188             ydr = ycr + dx(i,j-1)
<a name="l02189"></a>02189          <span class="keyword">endif</span>
<a name="l02190"></a>02190 
<a name="l02191"></a>02191          xdm = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * (xdr + xdl)
<a name="l02192"></a>02192          ydm = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * (ydr + ydl)
<a name="l02193"></a>02193 
<a name="l02194"></a>02194          <span class="comment">! Intersection points</span>
<a name="l02195"></a>02195 
<a name="l02196"></a>02196          xil = xcl
<a name="l02197"></a>02197          yil = (xcl*(ydm-ydl) + xdm*ydl - xdl*ydm) / (xdm - xdl)
<a name="l02198"></a>02198          
<a name="l02199"></a>02199          xir = xcr
<a name="l02200"></a>02200          yir = (xcr*(ydr-ydm) - xdm*ydr + xdr*ydm) / (xdr - xdm) 
<a name="l02201"></a>02201          
<a name="l02202"></a>02202          md = (ydr - ydl) / (xdr - xdl)
<a name="l02203"></a>02203          
<a name="l02204"></a>02204          <span class="keyword">if</span> (abs(md) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l02205"></a>02205             xic = xdl - ydl/md
<a name="l02206"></a>02206          <span class="keyword">else</span>
<a name="l02207"></a>02207             xic = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02208"></a>02208          <span class="keyword">endif</span>
<a name="l02209"></a>02209          yic = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02210"></a>02210 
<a name="l02211"></a>02211          xicl = xic
<a name="l02212"></a>02212          yicl = yic
<a name="l02213"></a>02213          xicr = xic
<a name="l02214"></a>02214          yicr = yic
<a name="l02215"></a>02215 
<a name="l02216"></a>02216     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02217"></a>02217     <span class="comment">! Locate triangles in TL cell (NW for north edge, NE for east edge)</span>
<a name="l02218"></a>02218     <span class="comment">! and BL cell (W for north edge, N for east edge).</span>
<a name="l02219"></a>02219     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02220"></a>02220 
<a name="l02221"></a>02221          <span class="keyword">if</span> (yil &gt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xdl &lt; xcl .and. ydl &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02222"></a>02222 
<a name="l02223"></a>02223          <span class="comment">! TL (group 1)</span>
<a name="l02224"></a>02224 
<a name="l02225"></a>02225             ng = 1
<a name="l02226"></a>02226             xp    (i,j,1,ng) = xcl
<a name="l02227"></a>02227             yp    (i,j,1,ng) = ycl
<a name="l02228"></a>02228             xp    (i,j,2,ng) = xil
<a name="l02229"></a>02229             yp    (i,j,2,ng) = yil
<a name="l02230"></a>02230             xp    (i,j,3,ng) = xdl
<a name="l02231"></a>02231             yp    (i,j,3,ng) = ydl
<a name="l02232"></a>02232             iflux   (i,j,ng) = i + ishift_tl
<a name="l02233"></a>02233             jflux   (i,j,ng) = j + jshift_tl
<a name="l02234"></a>02234             areafact(i,j,ng) = -areafac_l(i,j)
<a name="l02235"></a>02235 
<a name="l02236"></a>02236          elseif (yil &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xdl &lt; xcl .and. ydl &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02237"></a>02237 
<a name="l02238"></a>02238          <span class="comment">! BL (group 1)</span>
<a name="l02239"></a>02239 
<a name="l02240"></a>02240             ng = 1
<a name="l02241"></a>02241             xp    (i,j,1,ng) = xcl
<a name="l02242"></a>02242             yp    (i,j,1,ng) = ycl
<a name="l02243"></a>02243             xp    (i,j,2,ng) = xdl
<a name="l02244"></a>02244             yp    (i,j,2,ng) = ydl
<a name="l02245"></a>02245             xp    (i,j,3,ng) = xil
<a name="l02246"></a>02246             yp    (i,j,3,ng) = yil
<a name="l02247"></a>02247             iflux   (i,j,ng) = i + ishift_bl
<a name="l02248"></a>02248             jflux   (i,j,ng) = j + jshift_bl
<a name="l02249"></a>02249             areafact(i,j,ng) = areafac_l(i,j)
<a name="l02250"></a>02250 
<a name="l02251"></a>02251          elseif (yil &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xdl &lt; xcl .and. ydl &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02252"></a>02252 
<a name="l02253"></a>02253          <span class="comment">! TL1 (group 1)</span>
<a name="l02254"></a>02254 
<a name="l02255"></a>02255             ng = 1
<a name="l02256"></a>02256             xp    (i,j,1,ng) = xcl
<a name="l02257"></a>02257             yp    (i,j,1,ng) = ycl
<a name="l02258"></a>02258             xp    (i,j,2,ng) = xdl
<a name="l02259"></a>02259             yp    (i,j,2,ng) = ydl
<a name="l02260"></a>02260             xp    (i,j,3,ng) = xic
<a name="l02261"></a>02261             yp    (i,j,3,ng) = yic
<a name="l02262"></a>02262             iflux   (i,j,ng) = i + ishift_tl
<a name="l02263"></a>02263             jflux   (i,j,ng) = j + jshift_tl
<a name="l02264"></a>02264             areafact(i,j,ng) = areafac_l(i,j)
<a name="l02265"></a>02265 
<a name="l02266"></a>02266          <span class="comment">! BL1 (group 3)</span>
<a name="l02267"></a>02267 
<a name="l02268"></a>02268             ng = 3
<a name="l02269"></a>02269             xp    (i,j,1,ng) = xcl
<a name="l02270"></a>02270             yp    (i,j,1,ng) = ycl
<a name="l02271"></a>02271             xp    (i,j,2,ng) = xic
<a name="l02272"></a>02272             yp    (i,j,2,ng) = yic
<a name="l02273"></a>02273             xp    (i,j,3,ng) = xil
<a name="l02274"></a>02274             yp    (i,j,3,ng) = yil
<a name="l02275"></a>02275             iflux   (i,j,ng) = i + ishift_bl
<a name="l02276"></a>02276             jflux   (i,j,ng) = j + jshift_bl
<a name="l02277"></a>02277             areafact(i,j,ng) = areafac_l(i,j)
<a name="l02278"></a>02278 
<a name="l02279"></a>02279          elseif (yil &gt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xdl &lt; xcl .and. ydl &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02280"></a>02280 
<a name="l02281"></a>02281          <span class="comment">! TL2 (group 3)</span>
<a name="l02282"></a>02282 
<a name="l02283"></a>02283             ng = 3
<a name="l02284"></a>02284             xp    (i,j,1,ng) = xcl
<a name="l02285"></a>02285             yp    (i,j,1,ng) = ycl
<a name="l02286"></a>02286             xp    (i,j,2,ng) = xil
<a name="l02287"></a>02287             yp    (i,j,2,ng) = yil
<a name="l02288"></a>02288             xp    (i,j,3,ng) = xic
<a name="l02289"></a>02289             yp    (i,j,3,ng) = yic
<a name="l02290"></a>02290             iflux   (i,j,ng) = i + ishift_tl
<a name="l02291"></a>02291             jflux   (i,j,ng) = j + jshift_tl
<a name="l02292"></a>02292             areafact(i,j,ng) = -areafac_l(i,j)
<a name="l02293"></a>02293 
<a name="l02294"></a>02294          <span class="comment">! BL2 (group 1)</span>
<a name="l02295"></a>02295 
<a name="l02296"></a>02296             ng = 1
<a name="l02297"></a>02297             xp    (i,j,1,ng) = xcl
<a name="l02298"></a>02298             yp    (i,j,1,ng) = ycl
<a name="l02299"></a>02299             xp    (i,j,2,ng) = xic
<a name="l02300"></a>02300             yp    (i,j,2,ng) = yic
<a name="l02301"></a>02301             xp    (i,j,3,ng) = xdl
<a name="l02302"></a>02302             yp    (i,j,3,ng) = ydl
<a name="l02303"></a>02303             iflux   (i,j,ng) = i + ishift_bl
<a name="l02304"></a>02304             jflux   (i,j,ng) = j + jshift_bl
<a name="l02305"></a>02305             areafact(i,j,ng) = -areafac_l(i,j)
<a name="l02306"></a>02306 
<a name="l02307"></a>02307          <span class="keyword">endif</span>                  <span class="comment">! TL and BL triangles</span>
<a name="l02308"></a>02308 
<a name="l02309"></a>02309     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02310"></a>02310     <span class="comment">! Locate triangles in TR cell (NE for north edge, SE for east edge)</span>
<a name="l02311"></a>02311     <span class="comment">! and in BR cell (E for north edge, S for east edge).</span>
<a name="l02312"></a>02312     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02313"></a>02313 
<a name="l02314"></a>02314          <span class="keyword">if</span> (yir &gt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xdr &gt;= xcr .and. ydr &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02315"></a>02315 
<a name="l02316"></a>02316          <span class="comment">! TR (group 2)</span>
<a name="l02317"></a>02317 
<a name="l02318"></a>02318             ng = 2
<a name="l02319"></a>02319             xp    (i,j,1,ng) = xcr
<a name="l02320"></a>02320             yp    (i,j,1,ng) = ycr
<a name="l02321"></a>02321             xp    (i,j,2,ng) = xdr
<a name="l02322"></a>02322             yp    (i,j,2,ng) = ydr
<a name="l02323"></a>02323             xp    (i,j,3,ng) = xir
<a name="l02324"></a>02324             yp    (i,j,3,ng) = yir
<a name="l02325"></a>02325             iflux   (i,j,ng) = i + ishift_tr
<a name="l02326"></a>02326             jflux   (i,j,ng) = j + jshift_tr
<a name="l02327"></a>02327             areafact(i,j,ng) = -areafac_r(i,j)
<a name="l02328"></a>02328 
<a name="l02329"></a>02329          elseif (yir &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xdr &gt;= xcr .and. ydr &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02330"></a>02330 
<a name="l02331"></a>02331          <span class="comment">! BR (group 2)</span>
<a name="l02332"></a>02332 
<a name="l02333"></a>02333             ng = 2
<a name="l02334"></a>02334             xp    (i,j,1,ng) = xcr
<a name="l02335"></a>02335             yp    (i,j,1,ng) = ycr
<a name="l02336"></a>02336             xp    (i,j,2,ng) = xir
<a name="l02337"></a>02337             yp    (i,j,2,ng) = yir
<a name="l02338"></a>02338             xp    (i,j,3,ng) = xdr
<a name="l02339"></a>02339             yp    (i,j,3,ng) = ydr
<a name="l02340"></a>02340             iflux   (i,j,ng) = i + ishift_br
<a name="l02341"></a>02341             jflux   (i,j,ng) = j + jshift_br
<a name="l02342"></a>02342             areafact(i,j,ng) = areafac_r(i,j)
<a name="l02343"></a>02343 
<a name="l02344"></a>02344          elseif (yir &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xdr &gt;= xcr  .and. ydr &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span> 
<a name="l02345"></a>02345 
<a name="l02346"></a>02346          <span class="comment">! TR1 (group 2)</span>
<a name="l02347"></a>02347 
<a name="l02348"></a>02348             ng = 2
<a name="l02349"></a>02349             xp    (i,j,1,ng) = xcr
<a name="l02350"></a>02350             yp    (i,j,1,ng) = ycr
<a name="l02351"></a>02351             xp    (i,j,2,ng) = xic
<a name="l02352"></a>02352             yp    (i,j,2,ng) = yic
<a name="l02353"></a>02353             xp    (i,j,3,ng) = xdr
<a name="l02354"></a>02354             yp    (i,j,3,ng) = ydr
<a name="l02355"></a>02355             iflux   (i,j,ng) = i + ishift_tr
<a name="l02356"></a>02356             jflux   (i,j,ng) = j + jshift_tr
<a name="l02357"></a>02357             areafact(i,j,ng) = areafac_r(i,j)
<a name="l02358"></a>02358 
<a name="l02359"></a>02359          <span class="comment">! BR1 (group 3)</span>
<a name="l02360"></a>02360 
<a name="l02361"></a>02361             ng = 3
<a name="l02362"></a>02362             xp    (i,j,1,ng) = xcr
<a name="l02363"></a>02363             yp    (i,j,1,ng) = ycr
<a name="l02364"></a>02364             xp    (i,j,2,ng) = xir
<a name="l02365"></a>02365             yp    (i,j,2,ng) = yir
<a name="l02366"></a>02366             xp    (i,j,3,ng) = xic
<a name="l02367"></a>02367             yp    (i,j,3,ng) = yic
<a name="l02368"></a>02368             iflux   (i,j,ng) = i + ishift_br
<a name="l02369"></a>02369             jflux   (i,j,ng) = j + jshift_br
<a name="l02370"></a>02370             areafact(i,j,ng) = areafac_r(i,j)
<a name="l02371"></a>02371 
<a name="l02372"></a>02372          elseif (yir &gt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xdr &gt;= xcr .and. ydr &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span> 
<a name="l02373"></a>02373 
<a name="l02374"></a>02374          <span class="comment">! TR2 (group 3)</span>
<a name="l02375"></a>02375 
<a name="l02376"></a>02376             ng = 3
<a name="l02377"></a>02377             xp    (i,j,1,ng) = xcr
<a name="l02378"></a>02378             yp    (i,j,1,ng) = ycr
<a name="l02379"></a>02379             xp    (i,j,2,ng) = xic
<a name="l02380"></a>02380             yp    (i,j,2,ng) = yic
<a name="l02381"></a>02381             xp    (i,j,3,ng) = xir
<a name="l02382"></a>02382             yp    (i,j,3,ng) = yir
<a name="l02383"></a>02383             iflux   (i,j,ng) = i + ishift_tr
<a name="l02384"></a>02384             jflux   (i,j,ng) = j + jshift_tr
<a name="l02385"></a>02385             areafact(i,j,ng) = -areafac_r(i,j)
<a name="l02386"></a>02386 
<a name="l02387"></a>02387          <span class="comment">! BR2 (group 2)</span>
<a name="l02388"></a>02388 
<a name="l02389"></a>02389             ng = 2                     
<a name="l02390"></a>02390             xp    (i,j,1,ng) = xcr
<a name="l02391"></a>02391             yp    (i,j,1,ng) = ycr
<a name="l02392"></a>02392             xp    (i,j,2,ng) = xdr
<a name="l02393"></a>02393             yp    (i,j,2,ng) = ydr
<a name="l02394"></a>02394             xp    (i,j,3,ng) = xic
<a name="l02395"></a>02395             yp    (i,j,3,ng) = yic
<a name="l02396"></a>02396             iflux   (i,j,ng) = i + ishift_br
<a name="l02397"></a>02397             jflux   (i,j,ng) = j + jshift_br
<a name="l02398"></a>02398             areafact(i,j,ng) = -areafac_r(i,j)
<a name="l02399"></a>02399 
<a name="l02400"></a>02400          <span class="keyword">endif</span>                  <span class="comment">! TR and BR triangles</span>
<a name="l02401"></a>02401 
<a name="l02402"></a>02402     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02403"></a>02403     <span class="comment">! Redefine departure points if not located in central cells (TC or BC)</span>
<a name="l02404"></a>02404     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02405"></a>02405 
<a name="l02406"></a>02406          <span class="keyword">if</span> (xdl &lt; xcl) <span class="keyword">then</span>
<a name="l02407"></a>02407             xdl = xil
<a name="l02408"></a>02408             ydl = yil
<a name="l02409"></a>02409          <span class="keyword">endif</span>
<a name="l02410"></a>02410 
<a name="l02411"></a>02411          <span class="keyword">if</span> (xdr &gt; xcr) <span class="keyword">then</span>
<a name="l02412"></a>02412             xdr = xir
<a name="l02413"></a>02413             ydr = yir
<a name="l02414"></a>02414          <span class="keyword">endif</span>
<a name="l02415"></a>02415 
<a name="l02416"></a>02416     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02417"></a>02417     <span class="comment">! For l_fixed_area = T, shift the midpoint so that the departure</span>
<a name="l02418"></a>02418     <span class="comment">! region has the prescribed area</span>
<a name="l02419"></a>02419     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02420"></a>02420 
<a name="l02421"></a>02421          <span class="keyword">if</span> (l_fixed_area) <span class="keyword">then</span>
<a name="l02422"></a>02422 
<a name="l02423"></a>02423             <span class="comment">! Sum the areas of the left and right triangles.</span>
<a name="l02424"></a>02424             <span class="comment">! Note that yp(i,j,1,ng) = 0 for all triangles, so we can</span>
<a name="l02425"></a>02425             <span class="comment">!  drop those terms from the area formula.</span>
<a name="l02426"></a>02426 
<a name="l02427"></a>02427             ng = 1
<a name="l02428"></a>02428             area1 = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * ( (xp(i,j,2,ng)-xp(i,j,1,ng)) *   &amp;
<a name="l02429"></a>02429                             yp(i,j,3,ng)                   &amp;
<a name="l02430"></a>02430                          -  yp(i,j,2,ng) *                 &amp;
<a name="l02431"></a>02431                            (xp(i,j,3,ng)-xp(i,j,1,ng)) )   &amp;
<a name="l02432"></a>02432                          * areafact(i,j,ng) 
<a name="l02433"></a>02433 
<a name="l02434"></a>02434             ng = 2
<a name="l02435"></a>02435             area2 = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * ( (xp(i,j,2,ng)-xp(i,j,1,ng)) *   &amp;
<a name="l02436"></a>02436                             yp(i,j,3,ng)                   &amp;
<a name="l02437"></a>02437                          -  yp(i,j,2,ng) *                 &amp;
<a name="l02438"></a>02438                            (xp(i,j,3,ng)-xp(i,j,1,ng)) )   &amp;
<a name="l02439"></a>02439                          * areafact(i,j,ng) 
<a name="l02440"></a>02440 
<a name="l02441"></a>02441             ng = 3
<a name="l02442"></a>02442             area3 = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * ( (xp(i,j,2,ng)-xp(i,j,1,ng)) *   &amp;
<a name="l02443"></a>02443                             yp(i,j,3,ng)                   &amp;
<a name="l02444"></a>02444                          -  yp(i,j,2,ng) *                 &amp;
<a name="l02445"></a>02445                            (xp(i,j,3,ng)-xp(i,j,1,ng)) )   &amp;
<a name="l02446"></a>02446                          * areafact(i,j,ng) 
<a name="l02447"></a>02447 
<a name="l02448"></a>02448             <span class="comment">!-----------------------------------------------------------</span>
<a name="l02449"></a>02449             <span class="comment">! Check whether the central triangles lie in one grid cell or two.</span>
<a name="l02450"></a>02450             <span class="comment">! If all are in one grid cell, then adjust the area of the central</span>
<a name="l02451"></a>02451             <span class="comment">!  region so that the sum of all triangle areas is equal to the</span>
<a name="l02452"></a>02452             <span class="comment">!  prescribed value.</span>
<a name="l02453"></a>02453             <span class="comment">! If two triangles are in one grid cell and one is in the other,</span>
<a name="l02454"></a>02454             <span class="comment">!  then compute the area of the lone triangle using an area factor</span>
<a name="l02455"></a>02455             <span class="comment">!  corresponding to the adjacent corner.  This is necessary to prevent</span>
<a name="l02456"></a>02456             <span class="comment">!  negative masses in some rare cases on curved grids.  Then adjust</span>
<a name="l02457"></a>02457             <span class="comment">!  the area of the remaining two-triangle region so that the sum of</span>
<a name="l02458"></a>02458             <span class="comment">!  all triangle areas has the prescribed value.</span>
<a name="l02459"></a>02459             <span class="comment">!-----------------------------------------------------------</span>
<a name="l02460"></a>02460 
<a name="l02461"></a>02461             <span class="keyword">if</span> (ydl*ydr &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>   <span class="comment">! Both DPs lie on same side of x-axis</span>
<a name="l02462"></a>02462 
<a name="l02463"></a>02463                <span class="comment">! compute required area of central departure region</span>
<a name="l02464"></a>02464                area_c  = edgearea(i,j) - area1 - area2 - area3
<a name="l02465"></a>02465 
<a name="l02466"></a>02466                <span class="comment">! shift midpoint so that the area of remaining triangles = area_c</span>
<a name="l02467"></a>02467                w1 = <a class="code" href="namespaceice__constants.html#a683e0c28523a17a5d2cd40066167570a">c2</a>*area_c/areafac_c(i,j)    &amp;
<a name="l02468"></a>02468                     + (xdr-xcl)*ydl + (xcr-xdl)*ydr
<a name="l02469"></a>02469                w2 = (xdr-xdl)**2 + (ydr-ydl)**2
<a name="l02470"></a>02470                w1 = w1/w2
<a name="l02471"></a>02471                xdm = xdm + (ydr - ydl) * w1
<a name="l02472"></a>02472                ydm = ydm - (xdr - xdl) * w1
<a name="l02473"></a>02473 
<a name="l02474"></a>02474                <span class="comment">! compute left and right intersection points</span>
<a name="l02475"></a>02475                mdl = (ydm - ydl) / (xdm - xdl)
<a name="l02476"></a>02476                mdr = (ydr - ydm) / (xdr - xdm)
<a name="l02477"></a>02477 
<a name="l02478"></a>02478                <span class="keyword">if</span> (abs(mdl) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l02479"></a>02479                   xicl = xdl - ydl/mdl
<a name="l02480"></a>02480                <span class="keyword">else</span>
<a name="l02481"></a>02481                   xicl = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02482"></a>02482                <span class="keyword">endif</span>
<a name="l02483"></a>02483                yicl = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02484"></a>02484 
<a name="l02485"></a>02485                <span class="keyword">if</span> (abs(mdr) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l02486"></a>02486                   xicr = xdr - ydr/mdr
<a name="l02487"></a>02487                <span class="keyword">else</span>
<a name="l02488"></a>02488                   xicr = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02489"></a>02489                <span class="keyword">endif</span>
<a name="l02490"></a>02490                yicr = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02491"></a>02491 
<a name="l02492"></a>02492             elseif (xic &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>  <span class="comment">! fix ICL = IC</span>
<a name="l02493"></a>02493 
<a name="l02494"></a>02494                xicl = xic
<a name="l02495"></a>02495                yicl = yic
<a name="l02496"></a>02496 
<a name="l02497"></a>02497                <span class="comment">! compute midpoint between ICL and DR</span>
<a name="l02498"></a>02498                xdm = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * (xdr + xicl)
<a name="l02499"></a>02499                ydm = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> *  ydr
<a name="l02500"></a>02500 
<a name="l02501"></a>02501                <span class="comment">! compute area of triangle adjacent to left corner </span>
<a name="l02502"></a>02502                area4 = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * (xcl - xic) * ydl * areafac_l(i,j)
<a name="l02503"></a>02503                area_c  = edgearea(i,j) - area1 - area2 - area3 - area4
<a name="l02504"></a>02504 
<a name="l02505"></a>02505                <span class="comment">! shift midpoint so that area of remaining triangles = area_c</span>
<a name="l02506"></a>02506                w1 = <a class="code" href="namespaceice__constants.html#a683e0c28523a17a5d2cd40066167570a">c2</a>*area_c/areafac_c(i,j) + (xcr-xic)*ydr
<a name="l02507"></a>02507                w2 = (xdr-xic)**2 + ydr**2
<a name="l02508"></a>02508                w1 = w1/w2
<a name="l02509"></a>02509                xdm = xdm + ydr*w1
<a name="l02510"></a>02510                ydm = ydm - (xdr - xic) * w1
<a name="l02511"></a>02511 
<a name="l02512"></a>02512                <span class="comment">! compute ICR</span>
<a name="l02513"></a>02513                mdr = (ydr - ydm) / (xdr - xdm)
<a name="l02514"></a>02514                <span class="keyword">if</span> (abs(mdr) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l02515"></a>02515                   xicr = xdr - ydr/mdr
<a name="l02516"></a>02516                <span class="keyword">else</span>
<a name="l02517"></a>02517                   xicr = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02518"></a>02518                <span class="keyword">endif</span>
<a name="l02519"></a>02519                yicr = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02520"></a>02520 
<a name="l02521"></a>02521             elseif (xic &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>  <span class="comment">! fix ICR = IR</span>
<a name="l02522"></a>02522 
<a name="l02523"></a>02523                xicr = xic
<a name="l02524"></a>02524                yicr = yic
<a name="l02525"></a>02525 
<a name="l02526"></a>02526                <span class="comment">! compute midpoint between ICR and DL </span>
<a name="l02527"></a>02527                xdm = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * (xicr + xdl)
<a name="l02528"></a>02528                ydm = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> *  ydl
<a name="l02529"></a>02529 
<a name="l02530"></a>02530                area4 = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * (xic - xcr) * ydr * areafac_r(i,j)
<a name="l02531"></a>02531                area_c  = edgearea(i,j) - area1 - area2 - area3 - area4
<a name="l02532"></a>02532 
<a name="l02533"></a>02533                <span class="comment">! shift midpoint so that area of remaining triangles = area_c</span>
<a name="l02534"></a>02534                w1 = <a class="code" href="namespaceice__constants.html#a683e0c28523a17a5d2cd40066167570a">c2</a>*area_c/areafac_c(i,j) + (xic-xcl)*ydl
<a name="l02535"></a>02535                w2 = (xic-xdl)**2 + ydl**2
<a name="l02536"></a>02536                w1 = w1/w2
<a name="l02537"></a>02537                xdm = xdm - ydl*w1
<a name="l02538"></a>02538                ydm = ydm - (xic - xdl) * w1
<a name="l02539"></a>02539 
<a name="l02540"></a>02540                <span class="comment">! compute ICL</span>
<a name="l02541"></a>02541 
<a name="l02542"></a>02542                mdl = (ydm - ydl) / (xdm - xdl)
<a name="l02543"></a>02543                <span class="keyword">if</span> (abs(mdl) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l02544"></a>02544                   xicl = xdl - ydl/mdl
<a name="l02545"></a>02545                <span class="keyword">else</span>
<a name="l02546"></a>02546                   xicl = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02547"></a>02547                <span class="keyword">endif</span>
<a name="l02548"></a>02548                yicl = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l02549"></a>02549 
<a name="l02550"></a>02550             <span class="keyword">endif</span>   <span class="comment">! ydl*ydr &gt;= c0</span>
<a name="l02551"></a>02551 
<a name="l02552"></a>02552          <span class="keyword">endif</span>  <span class="comment">! l_fixed_area</span>
<a name="l02553"></a>02553 
<a name="l02554"></a>02554     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02555"></a>02555     <span class="comment">! Locate triangles in BC cell (H for both north and east edges) </span>
<a name="l02556"></a>02556     <span class="comment">! and TC cell (N for north edge and E for east edge).</span>
<a name="l02557"></a>02557     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l02558"></a>02558 
<a name="l02559"></a>02559     <span class="comment">! Start with cases where both DPs lie in the same grid cell</span>
<a name="l02560"></a>02560 
<a name="l02561"></a>02561          <span class="keyword">if</span> (ydl &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydm &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02562"></a>02562 
<a name="l02563"></a>02563          <span class="comment">! TC1a (group 4)</span>
<a name="l02564"></a>02564 
<a name="l02565"></a>02565             ng = 4
<a name="l02566"></a>02566             xp    (i,j,1,ng) = xcl
<a name="l02567"></a>02567             yp    (i,j,1,ng) = ycl
<a name="l02568"></a>02568             xp    (i,j,2,ng) = xcr
<a name="l02569"></a>02569             yp    (i,j,2,ng) = ycr
<a name="l02570"></a>02570             xp    (i,j,3,ng) = xdl
<a name="l02571"></a>02571             yp    (i,j,3,ng) = ydl
<a name="l02572"></a>02572             iflux   (i,j,ng) = i + ishift_tc
<a name="l02573"></a>02573             jflux   (i,j,ng) = j + jshift_tc
<a name="l02574"></a>02574             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02575"></a>02575 
<a name="l02576"></a>02576          <span class="comment">! TC2a (group 5)</span>
<a name="l02577"></a>02577 
<a name="l02578"></a>02578             ng = 5
<a name="l02579"></a>02579             xp    (i,j,1,ng) = xcr
<a name="l02580"></a>02580             yp    (i,j,1,ng) = ycr
<a name="l02581"></a>02581             xp    (i,j,2,ng) = xdr
<a name="l02582"></a>02582             yp    (i,j,2,ng) = ydr
<a name="l02583"></a>02583             xp    (i,j,3,ng) = xdl
<a name="l02584"></a>02584             yp    (i,j,3,ng) = ydl
<a name="l02585"></a>02585             iflux   (i,j,ng) = i + ishift_tc
<a name="l02586"></a>02586             jflux   (i,j,ng) = j + jshift_tc
<a name="l02587"></a>02587             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02588"></a>02588 
<a name="l02589"></a>02589          <span class="comment">! TC3a (group 6)</span>
<a name="l02590"></a>02590             ng = 6
<a name="l02591"></a>02591             xp    (i,j,1,ng) = xdl
<a name="l02592"></a>02592             yp    (i,j,1,ng) = ydl
<a name="l02593"></a>02593             xp    (i,j,2,ng) = xdr
<a name="l02594"></a>02594             yp    (i,j,2,ng) = ydr
<a name="l02595"></a>02595             xp    (i,j,3,ng) = xdm
<a name="l02596"></a>02596             yp    (i,j,3,ng) = ydm
<a name="l02597"></a>02597             iflux   (i,j,ng) = i + ishift_tc
<a name="l02598"></a>02598             jflux   (i,j,ng) = j + jshift_tc
<a name="l02599"></a>02599             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02600"></a>02600 
<a name="l02601"></a>02601          elseif (ydl &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydm &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>  <span class="comment">! rare</span>
<a name="l02602"></a>02602 
<a name="l02603"></a>02603          <span class="comment">! TC1b (group 4)</span>
<a name="l02604"></a>02604 
<a name="l02605"></a>02605             ng = 4
<a name="l02606"></a>02606             xp    (i,j,1,ng) = xcl
<a name="l02607"></a>02607             yp    (i,j,1,ng) = ycl
<a name="l02608"></a>02608             xp    (i,j,2,ng) = xicl
<a name="l02609"></a>02609             yp    (i,j,2,ng) = yicl
<a name="l02610"></a>02610             xp    (i,j,3,ng) = xdl
<a name="l02611"></a>02611             yp    (i,j,3,ng) = ydl
<a name="l02612"></a>02612             iflux   (i,j,ng) = i + ishift_tc
<a name="l02613"></a>02613             jflux   (i,j,ng) = j + jshift_tc
<a name="l02614"></a>02614             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02615"></a>02615 
<a name="l02616"></a>02616          <span class="comment">! TC2b (group 5)</span>
<a name="l02617"></a>02617 
<a name="l02618"></a>02618             ng = 5
<a name="l02619"></a>02619             xp    (i,j,1,ng) = xcr
<a name="l02620"></a>02620             yp    (i,j,1,ng) = ycr
<a name="l02621"></a>02621             xp    (i,j,2,ng) = xdr
<a name="l02622"></a>02622             yp    (i,j,2,ng) = ydr
<a name="l02623"></a>02623             xp    (i,j,3,ng) = xicr
<a name="l02624"></a>02624             yp    (i,j,3,ng) = yicr
<a name="l02625"></a>02625             iflux   (i,j,ng) = i + ishift_tc
<a name="l02626"></a>02626             jflux   (i,j,ng) = j + jshift_tc
<a name="l02627"></a>02627             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02628"></a>02628 
<a name="l02629"></a>02629          <span class="comment">! BC3b (group 6)</span>
<a name="l02630"></a>02630 
<a name="l02631"></a>02631             ng = 6
<a name="l02632"></a>02632             xp    (i,j,1,ng) = xicr
<a name="l02633"></a>02633             yp    (i,j,1,ng) = yicr
<a name="l02634"></a>02634             xp    (i,j,2,ng) = xicl
<a name="l02635"></a>02635             yp    (i,j,2,ng) = yicl
<a name="l02636"></a>02636             xp    (i,j,3,ng) = xdm
<a name="l02637"></a>02637             yp    (i,j,3,ng) = ydm
<a name="l02638"></a>02638             iflux   (i,j,ng) = i + ishift_bc
<a name="l02639"></a>02639             jflux   (i,j,ng) = j + jshift_bc
<a name="l02640"></a>02640             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02641"></a>02641 
<a name="l02642"></a>02642          elseif (ydl &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydm &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02643"></a>02643 
<a name="l02644"></a>02644          <span class="comment">! BC1a (group 4)</span>
<a name="l02645"></a>02645 
<a name="l02646"></a>02646             ng = 4
<a name="l02647"></a>02647             xp    (i,j,1,ng) = xcl
<a name="l02648"></a>02648             yp    (i,j,1,ng) = ycl
<a name="l02649"></a>02649             xp    (i,j,2,ng) = xdl
<a name="l02650"></a>02650             yp    (i,j,2,ng) = ydl
<a name="l02651"></a>02651             xp    (i,j,3,ng) = xcr
<a name="l02652"></a>02652             yp    (i,j,3,ng) = ycr
<a name="l02653"></a>02653             iflux   (i,j,ng) = i + ishift_bc
<a name="l02654"></a>02654             jflux   (i,j,ng) = j + jshift_bc
<a name="l02655"></a>02655             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02656"></a>02656 
<a name="l02657"></a>02657          <span class="comment">! BC2a (group 5)</span>
<a name="l02658"></a>02658 
<a name="l02659"></a>02659             ng = 5
<a name="l02660"></a>02660             xp    (i,j,1,ng) = xcr
<a name="l02661"></a>02661             yp    (i,j,1,ng) = ycr
<a name="l02662"></a>02662             xp    (i,j,2,ng) = xdl
<a name="l02663"></a>02663             yp    (i,j,2,ng) = ydl
<a name="l02664"></a>02664             xp    (i,j,3,ng) = xdr
<a name="l02665"></a>02665             yp    (i,j,3,ng) = ydr
<a name="l02666"></a>02666             iflux   (i,j,ng) = i + ishift_bc
<a name="l02667"></a>02667             jflux   (i,j,ng) = j + jshift_bc
<a name="l02668"></a>02668             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02669"></a>02669 
<a name="l02670"></a>02670          <span class="comment">! BC3a (group 6)</span>
<a name="l02671"></a>02671 
<a name="l02672"></a>02672             ng = 6
<a name="l02673"></a>02673             xp    (i,j,1,ng) = xdl
<a name="l02674"></a>02674             yp    (i,j,1,ng) = ydl
<a name="l02675"></a>02675             xp    (i,j,2,ng) = xdm
<a name="l02676"></a>02676             yp    (i,j,2,ng) = ydm
<a name="l02677"></a>02677             xp    (i,j,3,ng) = xdr
<a name="l02678"></a>02678             yp    (i,j,3,ng) = ydr
<a name="l02679"></a>02679             iflux   (i,j,ng) = i + ishift_bc
<a name="l02680"></a>02680             jflux   (i,j,ng) = j + jshift_bc
<a name="l02681"></a>02681             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02682"></a>02682 
<a name="l02683"></a>02683          elseif (ydl &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydm &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>  <span class="comment">! rare</span>
<a name="l02684"></a>02684 
<a name="l02685"></a>02685          <span class="comment">! BC1b (group 4)</span>
<a name="l02686"></a>02686 
<a name="l02687"></a>02687             ng = 4
<a name="l02688"></a>02688             xp    (i,j,1,ng) = xcl
<a name="l02689"></a>02689             yp    (i,j,1,ng) = ycl
<a name="l02690"></a>02690             xp    (i,j,2,ng) = xdl
<a name="l02691"></a>02691             yp    (i,j,2,ng) = ydl
<a name="l02692"></a>02692             xp    (i,j,3,ng) = xicl
<a name="l02693"></a>02693             yp    (i,j,3,ng) = yicl
<a name="l02694"></a>02694             iflux   (i,j,ng) = i + ishift_bc
<a name="l02695"></a>02695             jflux   (i,j,ng) = j + jshift_bc
<a name="l02696"></a>02696             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02697"></a>02697 
<a name="l02698"></a>02698          <span class="comment">! BC2b (group 5)</span>
<a name="l02699"></a>02699 
<a name="l02700"></a>02700             ng = 5
<a name="l02701"></a>02701             xp    (i,j,1,ng) = xcr
<a name="l02702"></a>02702             yp    (i,j,1,ng) = ycr
<a name="l02703"></a>02703             xp    (i,j,2,ng) = xicr
<a name="l02704"></a>02704             yp    (i,j,2,ng) = yicr
<a name="l02705"></a>02705             xp    (i,j,3,ng) = xdr
<a name="l02706"></a>02706             yp    (i,j,3,ng) = ydr
<a name="l02707"></a>02707             iflux   (i,j,ng) = i + ishift_bc
<a name="l02708"></a>02708             jflux   (i,j,ng) = j + jshift_bc
<a name="l02709"></a>02709             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02710"></a>02710 
<a name="l02711"></a>02711          <span class="comment">! TC3b (group 6)</span>
<a name="l02712"></a>02712 
<a name="l02713"></a>02713             ng = 6
<a name="l02714"></a>02714             xp    (i,j,1,ng) = xicl
<a name="l02715"></a>02715             yp    (i,j,1,ng) = yicl
<a name="l02716"></a>02716             xp    (i,j,2,ng) = xicr
<a name="l02717"></a>02717             yp    (i,j,2,ng) = yicr
<a name="l02718"></a>02718             xp    (i,j,3,ng) = xdm
<a name="l02719"></a>02719             yp    (i,j,3,ng) = ydm
<a name="l02720"></a>02720             iflux   (i,j,ng) = i + ishift_tc
<a name="l02721"></a>02721             jflux   (i,j,ng) = j + jshift_tc
<a name="l02722"></a>02722             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02723"></a>02723 
<a name="l02724"></a>02724     <span class="comment">! Now consider cases where the two DPs lie in different grid cells</span>
<a name="l02725"></a>02725     <span class="comment">! For these cases, one triangle is given the area factor associated</span>
<a name="l02726"></a>02726     <span class="comment">!  with the adjacent corner, to avoid rare negative masses on curved grids.</span>
<a name="l02727"></a>02727 
<a name="l02728"></a>02728          elseif (ydl &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xic &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>  &amp;
<a name="l02729"></a>02729                                           .and. ydm &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02730"></a>02730 
<a name="l02731"></a>02731          <span class="comment">! TC1b (group 4)</span>
<a name="l02732"></a>02732 
<a name="l02733"></a>02733             ng = 4
<a name="l02734"></a>02734             xp    (i,j,1,ng) = xcl
<a name="l02735"></a>02735             yp    (i,j,1,ng) = ycl
<a name="l02736"></a>02736             xp    (i,j,2,ng) = xicr
<a name="l02737"></a>02737             yp    (i,j,2,ng) = yicr
<a name="l02738"></a>02738             xp    (i,j,3,ng) = xdl
<a name="l02739"></a>02739             yp    (i,j,3,ng) = ydl
<a name="l02740"></a>02740             iflux   (i,j,ng) = i + ishift_tc
<a name="l02741"></a>02741             jflux   (i,j,ng) = j + jshift_tc
<a name="l02742"></a>02742             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02743"></a>02743 
<a name="l02744"></a>02744          <span class="comment">! BC2b (group 5)</span>
<a name="l02745"></a>02745 
<a name="l02746"></a>02746             ng = 5
<a name="l02747"></a>02747             xp    (i,j,1,ng) = xcr
<a name="l02748"></a>02748             yp    (i,j,1,ng) = ycr
<a name="l02749"></a>02749             xp    (i,j,2,ng) = xicr
<a name="l02750"></a>02750             yp    (i,j,2,ng) = yicr
<a name="l02751"></a>02751             xp    (i,j,3,ng) = xdr
<a name="l02752"></a>02752             yp    (i,j,3,ng) = ydr
<a name="l02753"></a>02753             iflux   (i,j,ng) = i + ishift_bc
<a name="l02754"></a>02754             jflux   (i,j,ng) = j + jshift_bc
<a name="l02755"></a>02755             areafact(i,j,ng) = areafac_r(i,j)
<a name="l02756"></a>02756 
<a name="l02757"></a>02757          <span class="comment">! TC3b (group 6)</span>
<a name="l02758"></a>02758 
<a name="l02759"></a>02759             ng = 6
<a name="l02760"></a>02760             xp    (i,j,1,ng) = xdl
<a name="l02761"></a>02761             yp    (i,j,1,ng) = ydl
<a name="l02762"></a>02762             xp    (i,j,2,ng) = xicr
<a name="l02763"></a>02763             yp    (i,j,2,ng) = yicr
<a name="l02764"></a>02764             xp    (i,j,3,ng) = xdm
<a name="l02765"></a>02765             yp    (i,j,3,ng) = ydm
<a name="l02766"></a>02766             iflux   (i,j,ng) = i + ishift_tc
<a name="l02767"></a>02767             jflux   (i,j,ng) = j + jshift_tc
<a name="l02768"></a>02768             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02769"></a>02769 
<a name="l02770"></a>02770          elseif (ydl &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xic &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>  &amp;
<a name="l02771"></a>02771                                           .and. ydm &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> ) <span class="keyword">then</span>  <span class="comment">! less common</span>
<a name="l02772"></a>02772 
<a name="l02773"></a>02773          <span class="comment">! TC1b (group 4)</span>
<a name="l02774"></a>02774 
<a name="l02775"></a>02775             ng = 4
<a name="l02776"></a>02776             xp    (i,j,1,ng) = xcl
<a name="l02777"></a>02777             yp    (i,j,1,ng) = ycl
<a name="l02778"></a>02778             xp    (i,j,2,ng) = xicl
<a name="l02779"></a>02779             yp    (i,j,2,ng) = yicl
<a name="l02780"></a>02780             xp    (i,j,3,ng) = xdl
<a name="l02781"></a>02781             yp    (i,j,3,ng) = ydl
<a name="l02782"></a>02782             iflux   (i,j,ng) = i + ishift_tc
<a name="l02783"></a>02783             jflux   (i,j,ng) = j + jshift_tc
<a name="l02784"></a>02784             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02785"></a>02785 
<a name="l02786"></a>02786          <span class="comment">! BC2b (group 5)</span>
<a name="l02787"></a>02787 
<a name="l02788"></a>02788             ng = 5
<a name="l02789"></a>02789             xp    (i,j,1,ng) = xcr
<a name="l02790"></a>02790             yp    (i,j,1,ng) = ycr
<a name="l02791"></a>02791             xp    (i,j,2,ng) = xicr
<a name="l02792"></a>02792             yp    (i,j,2,ng) = yicr
<a name="l02793"></a>02793             xp    (i,j,3,ng) = xdr
<a name="l02794"></a>02794             yp    (i,j,3,ng) = ydr
<a name="l02795"></a>02795             iflux   (i,j,ng) = i + ishift_bc
<a name="l02796"></a>02796             jflux   (i,j,ng) = j + jshift_bc
<a name="l02797"></a>02797             areafact(i,j,ng) = areafac_r(i,j)
<a name="l02798"></a>02798 
<a name="l02799"></a>02799          <span class="comment">! BC3b (group 6)</span>
<a name="l02800"></a>02800 
<a name="l02801"></a>02801             ng = 6
<a name="l02802"></a>02802             xp    (i,j,1,ng) = xicr
<a name="l02803"></a>02803             yp    (i,j,1,ng) = yicr
<a name="l02804"></a>02804             xp    (i,j,2,ng) = xicl
<a name="l02805"></a>02805             yp    (i,j,2,ng) = yicl
<a name="l02806"></a>02806             xp    (i,j,3,ng) = xdm
<a name="l02807"></a>02807             yp    (i,j,3,ng) = ydm
<a name="l02808"></a>02808             iflux   (i,j,ng) = i + ishift_bc
<a name="l02809"></a>02809             jflux   (i,j,ng) = j + jshift_bc
<a name="l02810"></a>02810             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02811"></a>02811 
<a name="l02812"></a>02812          elseif (ydl &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xic &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>   &amp;
<a name="l02813"></a>02813                                           .and. ydm &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02814"></a>02814 
<a name="l02815"></a>02815          <span class="comment">! TC1b (group 4)</span>
<a name="l02816"></a>02816 
<a name="l02817"></a>02817             ng = 4
<a name="l02818"></a>02818             xp    (i,j,1,ng) = xcl
<a name="l02819"></a>02819             yp    (i,j,1,ng) = ycl
<a name="l02820"></a>02820             xp    (i,j,2,ng) = xicl
<a name="l02821"></a>02821             yp    (i,j,2,ng) = yicl
<a name="l02822"></a>02822             xp    (i,j,3,ng) = xdl
<a name="l02823"></a>02823             yp    (i,j,3,ng) = ydl
<a name="l02824"></a>02824             iflux   (i,j,ng) = i + ishift_tc
<a name="l02825"></a>02825             jflux   (i,j,ng) = j + jshift_tc
<a name="l02826"></a>02826             areafact(i,j,ng) = -areafac_l(i,j)
<a name="l02827"></a>02827 
<a name="l02828"></a>02828          <span class="comment">! BC2b (group 5)</span>
<a name="l02829"></a>02829 
<a name="l02830"></a>02830             ng = 5
<a name="l02831"></a>02831             xp    (i,j,1,ng) = xcr
<a name="l02832"></a>02832             yp    (i,j,1,ng) = ycr
<a name="l02833"></a>02833             xp    (i,j,2,ng) = xicl
<a name="l02834"></a>02834             yp    (i,j,2,ng) = yicl
<a name="l02835"></a>02835             xp    (i,j,3,ng) = xdr
<a name="l02836"></a>02836             yp    (i,j,3,ng) = ydr
<a name="l02837"></a>02837             iflux   (i,j,ng) = i + ishift_bc
<a name="l02838"></a>02838             jflux   (i,j,ng) = j + jshift_bc
<a name="l02839"></a>02839             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02840"></a>02840 
<a name="l02841"></a>02841          <span class="comment">! BC3b (group 6)</span>
<a name="l02842"></a>02842 
<a name="l02843"></a>02843             ng = 6
<a name="l02844"></a>02844             xp    (i,j,1,ng) = xdr
<a name="l02845"></a>02845             yp    (i,j,1,ng) = ydr
<a name="l02846"></a>02846             xp    (i,j,2,ng) = xicl
<a name="l02847"></a>02847             yp    (i,j,2,ng) = yicl
<a name="l02848"></a>02848             xp    (i,j,3,ng) = xdm
<a name="l02849"></a>02849             yp    (i,j,3,ng) = ydm
<a name="l02850"></a>02850             iflux   (i,j,ng) = i + ishift_bc
<a name="l02851"></a>02851             jflux   (i,j,ng) = j + jshift_bc
<a name="l02852"></a>02852             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02853"></a>02853 
<a name="l02854"></a>02854          elseif (ydl &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xic &lt;  <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>  &amp;
<a name="l02855"></a>02855                                           .and. ydm &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>  <span class="comment">! less common</span>
<a name="l02856"></a>02856 
<a name="l02857"></a>02857          <span class="comment">! TC1b (group 4)</span>
<a name="l02858"></a>02858 
<a name="l02859"></a>02859             ng = 4
<a name="l02860"></a>02860             xp    (i,j,1,ng) = xcl
<a name="l02861"></a>02861             yp    (i,j,1,ng) = ycl
<a name="l02862"></a>02862             xp    (i,j,2,ng) = xicl
<a name="l02863"></a>02863             yp    (i,j,2,ng) = yicl
<a name="l02864"></a>02864             xp    (i,j,3,ng) = xdl
<a name="l02865"></a>02865             yp    (i,j,3,ng) = ydl
<a name="l02866"></a>02866             iflux   (i,j,ng) = i + ishift_tc
<a name="l02867"></a>02867             jflux   (i,j,ng) = j + jshift_tc
<a name="l02868"></a>02868             areafact(i,j,ng) = -areafac_l(i,j)
<a name="l02869"></a>02869 
<a name="l02870"></a>02870          <span class="comment">! BC2b (group 5)</span>
<a name="l02871"></a>02871 
<a name="l02872"></a>02872             ng = 5
<a name="l02873"></a>02873             xp    (i,j,1,ng) = xcr
<a name="l02874"></a>02874             yp    (i,j,1,ng) = ycr
<a name="l02875"></a>02875             xp    (i,j,2,ng) = xicr
<a name="l02876"></a>02876             yp    (i,j,2,ng) = yicr
<a name="l02877"></a>02877             xp    (i,j,3,ng) = xdr
<a name="l02878"></a>02878             yp    (i,j,3,ng) = ydr
<a name="l02879"></a>02879             iflux   (i,j,ng) = i + ishift_bc
<a name="l02880"></a>02880             jflux   (i,j,ng) = j + jshift_bc
<a name="l02881"></a>02881             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02882"></a>02882 
<a name="l02883"></a>02883          <span class="comment">! TC3b (group 6)</span>
<a name="l02884"></a>02884 
<a name="l02885"></a>02885             ng = 6
<a name="l02886"></a>02886             xp    (i,j,1,ng) = xicl
<a name="l02887"></a>02887             yp    (i,j,1,ng) = yicl
<a name="l02888"></a>02888             xp    (i,j,2,ng) = xicr
<a name="l02889"></a>02889             yp    (i,j,2,ng) = yicr
<a name="l02890"></a>02890             xp    (i,j,3,ng) = xdm
<a name="l02891"></a>02891             yp    (i,j,3,ng) = ydm
<a name="l02892"></a>02892             iflux   (i,j,ng) = i + ishift_tc
<a name="l02893"></a>02893             jflux   (i,j,ng) = j + jshift_tc
<a name="l02894"></a>02894             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02895"></a>02895 
<a name="l02896"></a>02896          elseif (ydl &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xic &lt;  <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>  &amp;
<a name="l02897"></a>02897                                           .and. ydm &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02898"></a>02898 
<a name="l02899"></a>02899          <span class="comment">! BC1b (group 4)</span>
<a name="l02900"></a>02900 
<a name="l02901"></a>02901             ng = 4
<a name="l02902"></a>02902             xp    (i,j,1,ng) = xcl
<a name="l02903"></a>02903             yp    (i,j,1,ng) = ycl
<a name="l02904"></a>02904             xp    (i,j,2,ng) = xdl
<a name="l02905"></a>02905             yp    (i,j,2,ng) = ydl
<a name="l02906"></a>02906             xp    (i,j,3,ng) = xicl
<a name="l02907"></a>02907             yp    (i,j,3,ng) = yicl
<a name="l02908"></a>02908             iflux   (i,j,ng) = i + ishift_bc
<a name="l02909"></a>02909             jflux   (i,j,ng) = j + jshift_bc
<a name="l02910"></a>02910             areafact(i,j,ng) = areafac_l(i,j)
<a name="l02911"></a>02911 
<a name="l02912"></a>02912          <span class="comment">! TC2b (group 5)</span>
<a name="l02913"></a>02913 
<a name="l02914"></a>02914             ng = 5
<a name="l02915"></a>02915             xp    (i,j,1,ng) = xcr
<a name="l02916"></a>02916             yp    (i,j,1,ng) = ycr
<a name="l02917"></a>02917             xp    (i,j,2,ng) = xdr
<a name="l02918"></a>02918             yp    (i,j,2,ng) = ydr
<a name="l02919"></a>02919             xp    (i,j,3,ng) = xicl
<a name="l02920"></a>02920             yp    (i,j,3,ng) = yicl
<a name="l02921"></a>02921             iflux   (i,j,ng) = i + ishift_tc
<a name="l02922"></a>02922             jflux   (i,j,ng) = j + jshift_tc
<a name="l02923"></a>02923             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02924"></a>02924 
<a name="l02925"></a>02925          <span class="comment">! TC3b (group 6)</span>
<a name="l02926"></a>02926 
<a name="l02927"></a>02927             ng = 6
<a name="l02928"></a>02928             xp    (i,j,1,ng) = xicl
<a name="l02929"></a>02929             yp    (i,j,1,ng) = yicl
<a name="l02930"></a>02930             xp    (i,j,2,ng) = xdr
<a name="l02931"></a>02931             yp    (i,j,2,ng) = ydr
<a name="l02932"></a>02932             xp    (i,j,3,ng) = xdm
<a name="l02933"></a>02933             yp    (i,j,3,ng) = ydm
<a name="l02934"></a>02934             iflux   (i,j,ng) = i + ishift_tc
<a name="l02935"></a>02935             jflux   (i,j,ng) = j + jshift_tc
<a name="l02936"></a>02936             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02937"></a>02937 
<a name="l02938"></a>02938          elseif (ydl &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xic &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>  &amp;
<a name="l02939"></a>02939                                           .and. ydm &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span> <span class="comment">! less common</span>
<a name="l02940"></a>02940 
<a name="l02941"></a>02941          <span class="comment">! BC1b (group 4)</span>
<a name="l02942"></a>02942 
<a name="l02943"></a>02943             ng = 4
<a name="l02944"></a>02944             xp    (i,j,1,ng) = xcl
<a name="l02945"></a>02945             yp    (i,j,1,ng) = ycl
<a name="l02946"></a>02946             xp    (i,j,2,ng) = xdl
<a name="l02947"></a>02947             yp    (i,j,2,ng) = ydl
<a name="l02948"></a>02948             xp    (i,j,3,ng) = xicl
<a name="l02949"></a>02949             yp    (i,j,3,ng) = yicl
<a name="l02950"></a>02950             iflux   (i,j,ng) = i + ishift_bc
<a name="l02951"></a>02951             jflux   (i,j,ng) = j + jshift_bc
<a name="l02952"></a>02952             areafact(i,j,ng) = areafac_l(i,j)
<a name="l02953"></a>02953 
<a name="l02954"></a>02954          <span class="comment">! TC2b (group 5)</span>
<a name="l02955"></a>02955 
<a name="l02956"></a>02956             ng = 5
<a name="l02957"></a>02957             xp    (i,j,1,ng) = xcr
<a name="l02958"></a>02958             yp    (i,j,1,ng) = ycr
<a name="l02959"></a>02959             xp    (i,j,2,ng) = xdr
<a name="l02960"></a>02960             yp    (i,j,2,ng) = ydr
<a name="l02961"></a>02961             xp    (i,j,3,ng) = xicr
<a name="l02962"></a>02962             yp    (i,j,3,ng) = yicr
<a name="l02963"></a>02963             iflux   (i,j,ng) = i + ishift_tc
<a name="l02964"></a>02964             jflux   (i,j,ng) = j + jshift_tc
<a name="l02965"></a>02965             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l02966"></a>02966 
<a name="l02967"></a>02967          <span class="comment">! BC3b (group 6)</span>
<a name="l02968"></a>02968 
<a name="l02969"></a>02969             ng = 6
<a name="l02970"></a>02970             xp    (i,j,1,ng) = xicr
<a name="l02971"></a>02971             yp    (i,j,1,ng) = yicr
<a name="l02972"></a>02972             xp    (i,j,2,ng) = xicl
<a name="l02973"></a>02973             yp    (i,j,2,ng) = yicl
<a name="l02974"></a>02974             xp    (i,j,3,ng) = xdm
<a name="l02975"></a>02975             yp    (i,j,3,ng) = ydm
<a name="l02976"></a>02976             iflux   (i,j,ng) = i + ishift_bc
<a name="l02977"></a>02977             jflux   (i,j,ng) = j + jshift_bc
<a name="l02978"></a>02978             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02979"></a>02979 
<a name="l02980"></a>02980          elseif (ydl &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xic &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>  &amp;
<a name="l02981"></a>02981                                           .and. ydm &lt;  <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l02982"></a>02982 
<a name="l02983"></a>02983          <span class="comment">! BC1b (group 4)</span>
<a name="l02984"></a>02984 
<a name="l02985"></a>02985             ng = 4
<a name="l02986"></a>02986             xp    (i,j,1,ng) = xcl
<a name="l02987"></a>02987             yp    (i,j,1,ng) = ycl
<a name="l02988"></a>02988             xp    (i,j,2,ng) = xdl
<a name="l02989"></a>02989             yp    (i,j,2,ng) = ydl
<a name="l02990"></a>02990             xp    (i,j,3,ng) = xicr
<a name="l02991"></a>02991             yp    (i,j,3,ng) = yicr
<a name="l02992"></a>02992             iflux   (i,j,ng) = i + ishift_bc
<a name="l02993"></a>02993             jflux   (i,j,ng) = j + jshift_bc
<a name="l02994"></a>02994             areafact(i,j,ng) = areafac_c(i,j)
<a name="l02995"></a>02995 
<a name="l02996"></a>02996          <span class="comment">! TC2b (group 5)</span>
<a name="l02997"></a>02997 
<a name="l02998"></a>02998             ng = 5
<a name="l02999"></a>02999             xp    (i,j,1,ng) = xcr
<a name="l03000"></a>03000             yp    (i,j,1,ng) = ycr
<a name="l03001"></a>03001             xp    (i,j,2,ng) = xdr
<a name="l03002"></a>03002             yp    (i,j,2,ng) = ydr
<a name="l03003"></a>03003             xp    (i,j,3,ng) = xicr
<a name="l03004"></a>03004             yp    (i,j,3,ng) = yicr
<a name="l03005"></a>03005             iflux   (i,j,ng) = i + ishift_tc
<a name="l03006"></a>03006             jflux   (i,j,ng) = j + jshift_tc
<a name="l03007"></a>03007             areafact(i,j,ng) = -areafac_r(i,j)
<a name="l03008"></a>03008 
<a name="l03009"></a>03009          <span class="comment">! BC3b (group 6)</span>
<a name="l03010"></a>03010 
<a name="l03011"></a>03011             ng = 6
<a name="l03012"></a>03012             xp    (i,j,1,ng) = xicr
<a name="l03013"></a>03013             yp    (i,j,1,ng) = yicr
<a name="l03014"></a>03014             xp    (i,j,2,ng) = xdl
<a name="l03015"></a>03015             yp    (i,j,2,ng) = ydl
<a name="l03016"></a>03016             xp    (i,j,3,ng) = xdm
<a name="l03017"></a>03017             yp    (i,j,3,ng) = ydm
<a name="l03018"></a>03018             iflux   (i,j,ng) = i + ishift_bc
<a name="l03019"></a>03019             jflux   (i,j,ng) = j + jshift_bc
<a name="l03020"></a>03020             areafact(i,j,ng) = areafac_c(i,j)
<a name="l03021"></a>03021 
<a name="l03022"></a>03022          elseif (ydl &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. ydr &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and. xic &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>   &amp;
<a name="l03023"></a>03023                                           .and. ydm &gt;= <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>  <span class="comment">! less common</span>
<a name="l03024"></a>03024 
<a name="l03025"></a>03025          <span class="comment">! BC1b (group 4)</span>
<a name="l03026"></a>03026 
<a name="l03027"></a>03027             ng = 4
<a name="l03028"></a>03028             xp    (i,j,1,ng) = xcl
<a name="l03029"></a>03029             yp    (i,j,1,ng) = ycl
<a name="l03030"></a>03030             xp    (i,j,2,ng) = xdl
<a name="l03031"></a>03031             yp    (i,j,2,ng) = ydl
<a name="l03032"></a>03032             xp    (i,j,3,ng) = xicl
<a name="l03033"></a>03033             yp    (i,j,3,ng) = yicl
<a name="l03034"></a>03034             iflux   (i,j,ng) = i + ishift_bc
<a name="l03035"></a>03035             jflux   (i,j,ng) = j + jshift_bc
<a name="l03036"></a>03036             areafact(i,j,ng) = areafac_c(i,j)
<a name="l03037"></a>03037 
<a name="l03038"></a>03038          <span class="comment">! TC2b (group 5)</span>
<a name="l03039"></a>03039 
<a name="l03040"></a>03040             ng = 5
<a name="l03041"></a>03041             xp    (i,j,1,ng) = xcr
<a name="l03042"></a>03042             yp    (i,j,1,ng) = ycr
<a name="l03043"></a>03043             xp    (i,j,2,ng) = xdr
<a name="l03044"></a>03044             yp    (i,j,2,ng) = ydr
<a name="l03045"></a>03045             xp    (i,j,3,ng) = xicr
<a name="l03046"></a>03046             yp    (i,j,3,ng) = yicr
<a name="l03047"></a>03047             iflux   (i,j,ng) = i + ishift_tc
<a name="l03048"></a>03048             jflux   (i,j,ng) = j + jshift_tc
<a name="l03049"></a>03049             areafact(i,j,ng) = -areafac_r(i,j)
<a name="l03050"></a>03050 
<a name="l03051"></a>03051          <span class="comment">! TC3b (group 6)</span>
<a name="l03052"></a>03052 
<a name="l03053"></a>03053             ng = 6
<a name="l03054"></a>03054             xp    (i,j,1,ng) = xicl
<a name="l03055"></a>03055             yp    (i,j,1,ng) = yicl
<a name="l03056"></a>03056             xp    (i,j,2,ng) = xicr
<a name="l03057"></a>03057             yp    (i,j,2,ng) = yicr
<a name="l03058"></a>03058             xp    (i,j,3,ng) = xdm
<a name="l03059"></a>03059             yp    (i,j,3,ng) = ydm
<a name="l03060"></a>03060             iflux   (i,j,ng) = i + ishift_tc
<a name="l03061"></a>03061             jflux   (i,j,ng) = j + jshift_tc
<a name="l03062"></a>03062             areafact(i,j,ng) = -areafac_c(i,j)
<a name="l03063"></a>03063 
<a name="l03064"></a>03064          <span class="keyword">endif</span>                  <span class="comment">! TC and BC triangles</span>
<a name="l03065"></a>03065 
<a name="l03066"></a>03066       <span class="keyword">enddo</span>                     <span class="comment">! ij</span>
<a name="l03067"></a>03067 
<a name="l03068"></a>03068     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03069"></a>03069     <span class="comment">! Compute triangle areas with appropriate sign.</span>
<a name="l03070"></a>03070     <span class="comment">! These are found by computing the area in scaled coordinates and</span>
<a name="l03071"></a>03071     <span class="comment">!  multiplying by a scale factor (areafact).</span>
<a name="l03072"></a>03072     <span class="comment">! Note that the scale factor is positive for fluxes out of the cell </span>
<a name="l03073"></a>03073     <span class="comment">!  and negative for fluxes into the cell.</span>
<a name="l03074"></a>03074     <span class="comment">!</span>
<a name="l03075"></a>03075     <span class="comment">! Note: The triangle area formula below gives A &gt;=0 iff the triangle</span>
<a name="l03076"></a>03076     <span class="comment">!        points x1, x2, and x3 are taken in counterclockwise order.</span>
<a name="l03077"></a>03077     <span class="comment">!       These points are defined above in such a way that the</span>
<a name="l03078"></a>03078     <span class="comment">!        order is nearly always CCW.</span>
<a name="l03079"></a>03079     <span class="comment">!       In rare cases, we may compute A &lt; 0.  In this case,</span>
<a name="l03080"></a>03080     <span class="comment">!        the quadrilateral departure area is equal to the </span>
<a name="l03081"></a>03081     <span class="comment">!        difference of two triangle areas instead of the sum.</span>
<a name="l03082"></a>03082     <span class="comment">!        The fluxes work out correctly in the end.</span>
<a name="l03083"></a>03083     <span class="comment">!</span>
<a name="l03084"></a>03084     <span class="comment">! Also compute the cumulative area transported across each edge.</span>
<a name="l03085"></a>03085     <span class="comment">! If l_fixed_area = T, this area is compared to edgearea as a bug check.</span>
<a name="l03086"></a>03086     <span class="comment">! If l_fixed_area = F, this area is passed as an output array.</span>
<a name="l03087"></a>03087     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03088"></a>03088 
<a name="l03089"></a>03089       areasum(:,:) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l03090"></a>03090 
<a name="l03091"></a>03091       <span class="keyword">do</span> ng = 1, <a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">ngroups</a>
<a name="l03092"></a>03092          icells(ng) = 0
<a name="l03093"></a>03093 
<a name="l03094"></a>03094          <span class="keyword">do</span> ij = 1, icellsd
<a name="l03095"></a>03095             i = indxid(ij)
<a name="l03096"></a>03096             j = indxjd(ij)
<a name="l03097"></a>03097 
<a name="l03098"></a>03098             triarea(i,j,ng) = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> * ( (xp(i,j,2,ng)-xp(i,j,1,ng)) *   &amp;
<a name="l03099"></a>03099                                      (yp(i,j,3,ng)-yp(i,j,1,ng))   &amp;
<a name="l03100"></a>03100                                    - (yp(i,j,2,ng)-yp(i,j,1,ng)) *   &amp;
<a name="l03101"></a>03101                                      (xp(i,j,3,ng)-xp(i,j,1,ng)) )   &amp;
<a name="l03102"></a>03102                                    * areafact(i,j,ng) 
<a name="l03103"></a>03103 
<a name="l03104"></a>03104             <span class="keyword">if</span> (abs(triarea(i,j,ng)) &lt; <a class="code" href="namespaceice__constants.html#a31903ce34884165d6861b9004305bc01">eps16</a>*areafac_c(i,j)) <span class="keyword">then</span>
<a name="l03105"></a>03105                triarea(i,j,ng) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l03106"></a>03106             <span class="keyword">else</span>
<a name="l03107"></a>03107                icells(ng) = icells(ng) + 1 
<a name="l03108"></a>03108                ic = icells(ng)
<a name="l03109"></a>03109                indxi(ic,ng) = i
<a name="l03110"></a>03110                indxj(ic,ng) = j
<a name="l03111"></a>03111             <span class="keyword">endif</span>
<a name="l03112"></a>03112 
<a name="l03113"></a>03113             areasum(i,j) = areasum(i,j) + triarea(i,j,ng)
<a name="l03114"></a>03114 
<a name="l03115"></a>03115          <span class="keyword">enddo</span>                  <span class="comment">! ij</span>
<a name="l03116"></a>03116       <span class="keyword">enddo</span>                     <span class="comment">! ng</span>
<a name="l03117"></a>03117 
<a name="l03118"></a>03118       <span class="keyword">if</span> (l_fixed_area) <span class="keyword">then</span>
<a name="l03119"></a>03119        <span class="keyword">if</span> (<a class="code" href="namespaceice__transport__remap.html#a2ea16fe2f40b061e8beaf561ebf7524c">bugcheck</a>) <span class="keyword">then</span>   <span class="comment">! set bugcheck = F to speed up code</span>
<a name="l03120"></a>03120          <span class="keyword">do</span> ij = 1, icellsd
<a name="l03121"></a>03121             i = indxid(ij)
<a name="l03122"></a>03122             j = indxjd(ij)
<a name="l03123"></a>03123             <span class="keyword">if</span> (abs(areasum(i,j) - edgearea(i,j)) &gt; <a class="code" href="namespaceice__constants.html#a835bbe6345af20f392af6fe0435418df">eps13</a>*areafac_c(i,j)) <span class="keyword">then</span>
<a name="l03124"></a>03124                print*, <span class="stringliteral">&apos;&apos;</span>
<a name="l03125"></a>03125                print*, <span class="stringliteral">&apos;Areas do not add up: m, i, j, edge =&apos;</span>,   &amp;
<a name="l03126"></a>03126                         <a class="code" href="namespaceice__communicate.html#a70e729e746e2e5ec592ccba505136002">my_task</a>, i, j, trim(edge)
<a name="l03127"></a>03127                print*, <span class="stringliteral">&apos;edgearea =&apos;</span>, edgearea(i,j)
<a name="l03128"></a>03128                print*, <span class="stringliteral">&apos;areasum =&apos;</span>, areasum(i,j)
<a name="l03129"></a>03129                print*, <span class="stringliteral">&apos;areafac_c =&apos;</span>, areafac_c(i,j)
<a name="l03130"></a>03130                print*, <span class="stringliteral">&apos;&apos;</span>
<a name="l03131"></a>03131                print*, <span class="stringliteral">&apos;Triangle areas:&apos;</span>
<a name="l03132"></a>03132                <span class="keyword">do</span> ng = 1, <a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">ngroups</a>   <span class="comment">! not vector friendly</span>
<a name="l03133"></a>03133                   <span class="keyword">if</span> (abs(triarea(i,j,ng)) &gt; <a class="code" href="namespaceice__constants.html#a31903ce34884165d6861b9004305bc01">eps16</a>*abs(areafact(i,j,ng))) <span class="keyword">then</span>
<a name="l03134"></a>03134                      print*, ng, triarea(i,j,ng)
<a name="l03135"></a>03135                   <span class="keyword">endif</span>
<a name="l03136"></a>03136                <span class="keyword">enddo</span>
<a name="l03137"></a>03137             <span class="keyword">endif</span>
<a name="l03138"></a>03138          <span class="keyword">enddo</span>
<a name="l03139"></a>03139        <span class="keyword">endif</span>          <span class="comment">! bugcheck</span>
<a name="l03140"></a>03140 
<a name="l03141"></a>03141       <span class="keyword">else</span>            <span class="comment">! l_fixed_area = F</span>
<a name="l03142"></a>03142          <span class="keyword">do</span> ij = 1, icellsd
<a name="l03143"></a>03143             i = indxid(ij)
<a name="l03144"></a>03144             j = indxjd(ij)
<a name="l03145"></a>03145             edgearea(i,j) = areasum(i,j)
<a name="l03146"></a>03146          <span class="keyword">enddo</span>
<a name="l03147"></a>03147       <span class="keyword">endif</span>     <span class="comment">! l_fixed_area</span>
<a name="l03148"></a>03148 
<a name="l03149"></a>03149     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03150"></a>03150     <span class="comment">! Transform triangle vertices to a scaled coordinate system centered</span>
<a name="l03151"></a>03151     <span class="comment">!  in the cell containing the triangle.</span>
<a name="l03152"></a>03152     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03153"></a>03153 
<a name="l03154"></a>03154       <span class="keyword">if</span> (trim(edge) == <span class="stringliteral">&apos;north&apos;</span>) <span class="keyword">then</span>
<a name="l03155"></a>03155          <span class="keyword">do</span> ng = 1, <a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">ngroups</a>
<a name="l03156"></a>03156             <span class="keyword">do</span> nv = 1, nvert
<a name="l03157"></a>03157                <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03158"></a>03158                   i = indxi(ij,ng)
<a name="l03159"></a>03159                   j = indxj(ij,ng)
<a name="l03160"></a>03160                   ishift = iflux(i,j,ng) - i
<a name="l03161"></a>03161                   jshift = jflux(i,j,ng) - j
<a name="l03162"></a>03162                   xp(i,j,nv,ng) = xp(i,j,nv,ng) - <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>*ishift
<a name="l03163"></a>03163                   yp(i,j,nv,ng) = yp(i,j,nv,ng) + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> - <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>*jshift
<a name="l03164"></a>03164                <span class="keyword">enddo</span>            <span class="comment">! ij</span>
<a name="l03165"></a>03165             <span class="keyword">enddo</span>               <span class="comment">! nv</span>
<a name="l03166"></a>03166          <span class="keyword">enddo</span>                  <span class="comment">! ng</span>
<a name="l03167"></a>03167       <span class="keyword">else</span>                      <span class="comment">! east edge</span>
<a name="l03168"></a>03168          <span class="keyword">do</span> ng = 1, <a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">ngroups</a>
<a name="l03169"></a>03169             <span class="keyword">do</span> nv = 1, nvert
<a name="l03170"></a>03170                <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03171"></a>03171                   i = indxi(ij,ng)
<a name="l03172"></a>03172                   j = indxj(ij,ng)
<a name="l03173"></a>03173                   ishift = iflux(i,j,ng) - i
<a name="l03174"></a>03174                   jshift = jflux(i,j,ng) - j
<a name="l03175"></a>03175                   <span class="comment">! Note rotation of pi/2 here</span>
<a name="l03176"></a>03176                   w1 = xp(i,j,nv,ng)
<a name="l03177"></a>03177                   xp(i,j,nv,ng) =  yp(i,j,nv,ng) + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a> - <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>*ishift
<a name="l03178"></a>03178                   yp(i,j,nv,ng) = -w1 - <a class="code" href="namespaceice__constants.html#a74c3f6d59942aec40dda487c6af99039">c1</a>*jshift
<a name="l03179"></a>03179                <span class="keyword">enddo</span>            <span class="comment">! ij</span>
<a name="l03180"></a>03180             <span class="keyword">enddo</span>               <span class="comment">! nv</span>
<a name="l03181"></a>03181          <span class="keyword">enddo</span>                  <span class="comment">! ng</span>
<a name="l03182"></a>03182       <span class="keyword">endif</span>
<a name="l03183"></a>03183 
<a name="l03184"></a>03184       <span class="keyword">if</span> (<a class="code" href="namespaceice__transport__remap.html#a2ea16fe2f40b061e8beaf561ebf7524c">bugcheck</a>) <span class="keyword">then</span>
<a name="l03185"></a>03185          <span class="keyword">do</span> ng = 1, <a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">ngroups</a>
<a name="l03186"></a>03186          <span class="keyword">do</span> nv = 1, nvert
<a name="l03187"></a>03187             <span class="keyword">do</span> j = jb, je
<a name="l03188"></a>03188             <span class="keyword">do</span> i = ib, ie
<a name="l03189"></a>03189                <span class="keyword">if</span> (abs(triarea(i,j,ng)) &gt; <a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l03190"></a>03190                   <span class="keyword">if</span> (abs(xp(i,j,nv,ng)) &gt; <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>+<a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l03191"></a>03191                      print*, <span class="stringliteral">&apos;&apos;</span>
<a name="l03192"></a>03192                      print*, <span class="stringliteral">&apos;WARNING: xp =&apos;</span>, xp(i,j,nv,ng)
<a name="l03193"></a>03193                      print*, <span class="stringliteral">&apos;m, i, j, ng, nv =&apos;</span>, <a class="code" href="namespaceice__communicate.html#a70e729e746e2e5ec592ccba505136002">my_task</a>, i, j, ng, nv
<a name="l03194"></a>03194 <span class="comment">!                     print*, &apos;yil,xdl,xcl,ydl=&apos;,yil,xdl,xcl,ydl</span>
<a name="l03195"></a>03195 <span class="comment">!                     print*, &apos;yir,xdr,xcr,ydr=&apos;,yir,xdr,xcr,ydr</span>
<a name="l03196"></a>03196 <span class="comment">!                     print*, &apos;ydm=&apos;,ydm</span>
<a name="l03197"></a>03197 <span class="comment">!                      stop</span>
<a name="l03198"></a>03198                   <span class="keyword">endif</span>
<a name="l03199"></a>03199                   <span class="keyword">if</span> (abs(yp(i,j,nv,ng)) &gt; <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>+<a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>
<a name="l03200"></a>03200                      print*, <span class="stringliteral">&apos;&apos;</span>
<a name="l03201"></a>03201                      print*, <span class="stringliteral">&apos;WARNING: yp =&apos;</span>, yp(i,j,nv,ng)
<a name="l03202"></a>03202                      print*, <span class="stringliteral">&apos;m, i, j, ng, nv =&apos;</span>, <a class="code" href="namespaceice__communicate.html#a70e729e746e2e5ec592ccba505136002">my_task</a>, i, j, ng, nv
<a name="l03203"></a>03203                   <span class="keyword">endif</span>
<a name="l03204"></a>03204                <span class="keyword">endif</span>   <span class="comment">! triarea</span>
<a name="l03205"></a>03205             <span class="keyword">enddo</span>
<a name="l03206"></a>03206             <span class="keyword">enddo</span>
<a name="l03207"></a>03207          <span class="keyword">enddo</span>
<a name="l03208"></a>03208          <span class="keyword">enddo</span>
<a name="l03209"></a>03209       <span class="keyword">endif</span>  <span class="comment">! bugcheck</span>
<a name="l03210"></a>03210 
<a name="l03211"></a>03211 <span class="keyword">      end subroutine locate_triangles</span>
<a name="l03212"></a>03212 
<a name="l03213"></a>03213 <span class="comment">!=======================================================================</span>
<a name="l03214"></a>03214 <span class="comment">!</span>
<a name="l03215"></a>03215 <span class="comment">!BOP</span>
<a name="l03216"></a>03216 <span class="comment">! !IROUTINE: triangle_coordinates - find coordinates of quadrature points</span>
<a name="l03217"></a>03217 <span class="comment">!</span>
<a name="l03218"></a>03218 <span class="comment">! !INTERFACE:</span>
<a name="l03219"></a>03219 <span class="comment">!</span>
<a name="l03220"></a><a class="code" href="namespaceice__transport__remap.html#a0118e9be4eed6545abe6b6d08ebea458">03220</a>       <span class="keyword">subroutine </span><a class="code" href="namespaceice__transport__remap.html#a0118e9be4eed6545abe6b6d08ebea458">triangle_coordinates</a> (nx_block,       ny_block,  &amp;
<a name="l03221"></a>03221                                        integral_order, icells,    &amp;
<a name="l03222"></a>03222                                        indxi,          indxj,     &amp;
<a name="l03223"></a>03223                                        xp,             yp)
<a name="l03224"></a>03224 <span class="comment">!</span>
<a name="l03225"></a>03225 <span class="comment">! !DESCRIPTION:</span>
<a name="l03226"></a>03226 <span class="comment">!</span>
<a name="l03227"></a>03227 <span class="comment">! For each triangle, find the coordinates of the quadrature points needed</span>
<a name="l03228"></a>03228 <span class="comment">!  to compute integrals of linear, quadratic, or cubic polynomials,</span>
<a name="l03229"></a>03229 <span class="comment">!  using formulas from A.H. Stroud, Approximate Calculation of Multiple</span>
<a name="l03230"></a>03230 <span class="comment">!  Integrals, Prentice-Hall, 1971.  (Section 8.8, formula 3.1.)</span>
<a name="l03231"></a>03231 <span class="comment">! Linear functions can be integrated exactly by evaluating the function </span>
<a name="l03232"></a>03232 <span class="comment">!  at just one point (the midpoint).  Quadratic functions require</span>
<a name="l03233"></a>03233 <span class="comment">!  3 points, and cubics require 4 points.</span>
<a name="l03234"></a>03234 <span class="comment">! The default is cubic, but the code can be sped up slightly using </span>
<a name="l03235"></a>03235 <span class="comment">!  linear or quadratic integrals, usually with little loss of accuracy.</span>
<a name="l03236"></a>03236 <span class="comment">!</span>
<a name="l03237"></a>03237 <span class="comment">! The formulas are as follows:</span>
<a name="l03238"></a>03238 <span class="comment">!</span>
<a name="l03239"></a>03239 <span class="comment">! I1 = integral of f(x,y)*dA</span>
<a name="l03240"></a>03240 <span class="comment">!    = A * f(x0,y0)</span>
<a name="l03241"></a>03241 <span class="comment">! where A is the traingle area and (x0,y0) is the midpoint.</span>
<a name="l03242"></a>03242 <span class="comment">!</span>
<a name="l03243"></a>03243 <span class="comment">! I2 = A * (f(x1,y1) + f(x2,y2) + f(x3,y3))</span>
<a name="l03244"></a>03244 <span class="comment">! where these three points are located halfway between the midpoint</span>
<a name="l03245"></a>03245 <span class="comment">! and the three vertics of the triangle.</span>
<a name="l03246"></a>03246 <span class="comment">!</span>
<a name="l03247"></a>03247 <span class="comment">! I3 = A * [ -9/16 *  f(x0,y0)</span>
<a name="l03248"></a>03248 <span class="comment">!           + 25/48 * (f(x1,y1) + f(x2,y2) + f(x3,y3))]</span>
<a name="l03249"></a>03249 <span class="comment">! where (x0,y0) is the midpoint, and the other three points are</span>
<a name="l03250"></a>03250 <span class="comment">! located 2/5 of the way from the midpoint to the three vertices.</span>
<a name="l03251"></a>03251 <span class="comment">!</span>
<a name="l03252"></a>03252 <span class="comment">! !REVISION HISTORY:</span>
<a name="l03253"></a>03253 <span class="comment">!</span>
<a name="l03254"></a>03254 <span class="comment">! author William H. Lipscomb, LANL</span>
<a name="l03255"></a>03255 <span class="comment">!</span>
<a name="l03256"></a>03256 <span class="comment">! !USES:</span>
<a name="l03257"></a>03257 <span class="comment">!</span>
<a name="l03258"></a>03258 <span class="comment">! !INPUT/OUTPUT PARAMETERS:</span>
<a name="l03259"></a>03259 <span class="comment">!</span>
<a name="l03260"></a>03260       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l03261"></a>03261            nx_block, ny_block,<span class="comment">! block dimensions</span>
<a name="l03262"></a>03262            integral_order      <span class="comment">! polynomial order for quadrature integrals </span>
<a name="l03263"></a>03263 
<a name="l03264"></a>03264       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (ngroups)</span>, <span class="keywordtype">intent(in)</span> ::     
<a name="l03265"></a>03265            icells              <span class="comment">! number of cells where triarea &gt; puny</span>
<a name="l03266"></a>03266 
<a name="l03267"></a>03267       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (nx_block*ny_block,ngroups)</span>,     
<a name="l03268"></a>03268            <span class="keywordtype">intent(in)</span> ::     
<a name="l03269"></a>03269            indxi ,<span class="comment">! compressed index in i-direction</span>
<a name="l03270"></a>03270            indxj   <span class="comment">! compressed index in j-direction</span>
<a name="l03271"></a>03271 
<a name="l03272"></a>03272       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(inout)</span>,   
<a name="l03273"></a>03273            <span class="keywordtype">dimension (nx_block, ny_block, 0:nvert, ngroups) </span>::   
<a name="l03274"></a>03274            xp, yp          <span class="comment">! coordinates of triangle points</span>
<a name="l03275"></a>03275 <span class="comment">!</span>
<a name="l03276"></a>03276 <span class="comment">!EOP</span>
<a name="l03277"></a>03277 <span class="comment">!</span>
<a name="l03278"></a>03278       <span class="keywordtype">integer (kind=int_kind) </span>::   
<a name="l03279"></a>03279            i, j, ij          ,<span class="comment">! horizontal indices</span>
<a name="l03280"></a>03280            ng                  <span class="comment">! triangle index</span>
<a name="l03281"></a>03281 
<a name="l03282"></a>03282 
<a name="l03283"></a>03283       <span class="keyword">if</span> (integral_order == 1) <span class="keyword">then</span> <span class="comment">! linear (1-point formula)</span>
<a name="l03284"></a>03284 
<a name="l03285"></a>03285          <span class="keyword">do</span> ng = 1, <a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">ngroups</a>
<a name="l03286"></a>03286          <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03287"></a>03287             i = indxi(ij,ng)
<a name="l03288"></a>03288             j = indxj(ij,ng)
<a name="l03289"></a>03289 
<a name="l03290"></a>03290             <span class="comment">! coordinates of midpoint</span>
<a name="l03291"></a>03291             xp(i,j,0,ng) = <a class="code" href="namespaceice__constants.html#a9dfb9e1671683be9cb08717f174638cc">p333</a>   &amp;
<a name="l03292"></a>03292                         * (xp(i,j,1,ng) + xp(i,j,2,ng) + xp(i,j,3,ng))
<a name="l03293"></a>03293             yp(i,j,0,ng) = <a class="code" href="namespaceice__constants.html#a9dfb9e1671683be9cb08717f174638cc">p333</a>   &amp;
<a name="l03294"></a>03294                         * (yp(i,j,1,ng) + yp(i,j,2,ng) + yp(i,j,3,ng))
<a name="l03295"></a>03295 
<a name="l03296"></a>03296          <span class="keyword">enddo</span>                  <span class="comment">! ij</span>
<a name="l03297"></a>03297          <span class="keyword">enddo</span>                  <span class="comment">! ng</span>
<a name="l03298"></a>03298 
<a name="l03299"></a>03299       elseif (integral_order == 2) <span class="keyword">then</span> <span class="comment">! quadratic (3-point formula)</span>
<a name="l03300"></a>03300 
<a name="l03301"></a>03301 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l03302"></a>03302 <span class="comment">!cdir nodep      !NEC</span>
<a name="l03303"></a>03303 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l03304"></a>03304 
<a name="l03305"></a>03305          <span class="keyword">do</span> ng = 1, <a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">ngroups</a>
<a name="l03306"></a>03306          <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03307"></a>03307             i = indxi(ij,ng)
<a name="l03308"></a>03308             j = indxj(ij,ng)
<a name="l03309"></a>03309 
<a name="l03310"></a>03310             <span class="comment">! coordinates of midpoint</span>
<a name="l03311"></a>03311             xp(i,j,0,ng) = <a class="code" href="namespaceice__constants.html#a9dfb9e1671683be9cb08717f174638cc">p333</a>   &amp;
<a name="l03312"></a>03312                         * (xp(i,j,1,ng) + xp(i,j,2,ng) + xp(i,j,3,ng))
<a name="l03313"></a>03313             yp(i,j,0,ng) = <a class="code" href="namespaceice__constants.html#a9dfb9e1671683be9cb08717f174638cc">p333</a>   &amp;
<a name="l03314"></a>03314                         * (yp(i,j,1,ng) + yp(i,j,2,ng) + yp(i,j,3,ng))
<a name="l03315"></a>03315 
<a name="l03316"></a>03316             <span class="comment">! coordinates of the 3 points needed for integrals</span>
<a name="l03317"></a>03317 
<a name="l03318"></a>03318             xp(i,j,1,ng) = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*xp(i,j,1,ng) + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*xp(i,j,0,ng)
<a name="l03319"></a>03319             yp(i,j,1,ng) = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*yp(i,j,1,ng) + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*yp(i,j,0,ng)
<a name="l03320"></a>03320 
<a name="l03321"></a>03321             xp(i,j,2,ng) = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*xp(i,j,2,ng) + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*xp(i,j,0,ng)
<a name="l03322"></a>03322             yp(i,j,2,ng) = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*yp(i,j,2,ng) + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*yp(i,j,0,ng)
<a name="l03323"></a>03323 
<a name="l03324"></a>03324             xp(i,j,3,ng) = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*xp(i,j,3,ng) + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*xp(i,j,0,ng)
<a name="l03325"></a>03325             yp(i,j,3,ng) = <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*yp(i,j,3,ng) + <a class="code" href="namespaceice__constants.html#a26872e9df91fb7484a1a2ddefd7b71b0">p5</a>*yp(i,j,0,ng)
<a name="l03326"></a>03326 
<a name="l03327"></a>03327          <span class="keyword">enddo</span>                  <span class="comment">! ij</span>
<a name="l03328"></a>03328          <span class="keyword">enddo</span>                  <span class="comment">! ng</span>
<a name="l03329"></a>03329 
<a name="l03330"></a>03330       <span class="keyword">else</span>                      <span class="comment">! cubic (4-point formula)</span>
<a name="l03331"></a>03331 
<a name="l03332"></a>03332 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l03333"></a>03333 <span class="comment">!cdir nodep      !NEC</span>
<a name="l03334"></a>03334 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l03335"></a>03335          <span class="keyword">do</span> ng = 1, <a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">ngroups</a>
<a name="l03336"></a>03336          <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03337"></a>03337             i = indxi(ij,ng)
<a name="l03338"></a>03338             j = indxj(ij,ng)
<a name="l03339"></a>03339 
<a name="l03340"></a>03340             <span class="comment">! coordinates of midpoint</span>
<a name="l03341"></a>03341             xp(i,j,0,ng) = <a class="code" href="namespaceice__constants.html#a9dfb9e1671683be9cb08717f174638cc">p333</a>   &amp;
<a name="l03342"></a>03342                         * (xp(i,j,1,ng) + xp(i,j,2,ng) + xp(i,j,3,ng))
<a name="l03343"></a>03343             yp(i,j,0,ng) = <a class="code" href="namespaceice__constants.html#a9dfb9e1671683be9cb08717f174638cc">p333</a>   &amp;
<a name="l03344"></a>03344                         * (yp(i,j,1,ng) + yp(i,j,2,ng) + yp(i,j,3,ng))
<a name="l03345"></a>03345 
<a name="l03346"></a>03346             <span class="comment">! coordinates of the other 3 points needed for integrals</span>
<a name="l03347"></a>03347 
<a name="l03348"></a>03348             xp(i,j,1,ng) = <a class="code" href="namespaceice__constants.html#aa6ad846377c0f3b955303559a2262b78">p4</a>*xp(i,j,1,ng) + <a class="code" href="namespaceice__constants.html#a86103f3a8306abd46a8a68ede82f2ee4">p6</a>*xp(i,j,0,ng)
<a name="l03349"></a>03349             yp(i,j,1,ng) = <a class="code" href="namespaceice__constants.html#aa6ad846377c0f3b955303559a2262b78">p4</a>*yp(i,j,1,ng) + <a class="code" href="namespaceice__constants.html#a86103f3a8306abd46a8a68ede82f2ee4">p6</a>*yp(i,j,0,ng)
<a name="l03350"></a>03350 
<a name="l03351"></a>03351             xp(i,j,2,ng) = <a class="code" href="namespaceice__constants.html#aa6ad846377c0f3b955303559a2262b78">p4</a>*xp(i,j,2,ng) + <a class="code" href="namespaceice__constants.html#a86103f3a8306abd46a8a68ede82f2ee4">p6</a>*xp(i,j,0,ng)
<a name="l03352"></a>03352             yp(i,j,2,ng) = <a class="code" href="namespaceice__constants.html#aa6ad846377c0f3b955303559a2262b78">p4</a>*yp(i,j,2,ng) + <a class="code" href="namespaceice__constants.html#a86103f3a8306abd46a8a68ede82f2ee4">p6</a>*yp(i,j,0,ng)
<a name="l03353"></a>03353                
<a name="l03354"></a>03354             xp(i,j,3,ng) = <a class="code" href="namespaceice__constants.html#aa6ad846377c0f3b955303559a2262b78">p4</a>*xp(i,j,3,ng) + <a class="code" href="namespaceice__constants.html#a86103f3a8306abd46a8a68ede82f2ee4">p6</a>*xp(i,j,0,ng)
<a name="l03355"></a>03355             yp(i,j,3,ng) = <a class="code" href="namespaceice__constants.html#aa6ad846377c0f3b955303559a2262b78">p4</a>*yp(i,j,3,ng) + <a class="code" href="namespaceice__constants.html#a86103f3a8306abd46a8a68ede82f2ee4">p6</a>*yp(i,j,0,ng)
<a name="l03356"></a>03356                
<a name="l03357"></a>03357          <span class="keyword">enddo</span>                  <span class="comment">! ij</span>
<a name="l03358"></a>03358          <span class="keyword">enddo</span>                  <span class="comment">! ng</span>
<a name="l03359"></a>03359 
<a name="l03360"></a>03360       <span class="keyword">endif</span>
<a name="l03361"></a>03361 
<a name="l03362"></a>03362 <span class="keyword">      end subroutine triangle_coordinates</span>
<a name="l03363"></a>03363 
<a name="l03364"></a>03364 <span class="comment">!=======================================================================</span>
<a name="l03365"></a>03365 <span class="comment">!</span>
<a name="l03366"></a>03366 <span class="comment">!BOP</span>
<a name="l03367"></a>03367 <span class="comment">!</span>
<a name="l03368"></a>03368 <span class="comment">! !IROUTINE: transport_integrals - compute transports across each edge</span>
<a name="l03369"></a>03369 <span class="comment">!</span>
<a name="l03370"></a>03370 <span class="comment">! !INTERFACE:</span>
<a name="l03371"></a>03371 <span class="comment">!</span>
<a name="l03372"></a><a class="code" href="namespaceice__transport__remap.html#a36c63f1390ec491939f47e64dab35e1e">03372</a>       <span class="keyword">subroutine </span><a class="code" href="namespaceice__transport__remap.html#a36c63f1390ec491939f47e64dab35e1e">transport_integrals</a> (nx_block,       ny_block,    &amp;
<a name="l03373"></a>03373                                       icells,                      &amp;
<a name="l03374"></a>03374                                       indxi,          indxj,       &amp;
<a name="l03375"></a>03375                                       tracer_type,    depend,      &amp;
<a name="l03376"></a>03376                                       integral_order, triarea,     &amp;
<a name="l03377"></a>03377                                       iflux,          jflux,       &amp;
<a name="l03378"></a>03378                                       xp,             yp,          &amp;
<a name="l03379"></a>03379                                       mc,             mx,          &amp;
<a name="l03380"></a>03380                                       my,             mflx,       &amp;
<a name="l03381"></a>03381                                       tc,             tx,          &amp;
<a name="l03382"></a>03382                                       ty,             mtflx)
<a name="l03383"></a>03383 <span class="comment">!</span>
<a name="l03384"></a>03384 <span class="comment">! !DESCRIPTION:</span>
<a name="l03385"></a>03385 <span class="comment">!</span>
<a name="l03386"></a>03386 <span class="comment">! Compute the transports across each edge by integrating the mass</span>
<a name="l03387"></a>03387 <span class="comment">! and tracers over each departure triangle.</span>
<a name="l03388"></a>03388 <span class="comment">! Input variables have the same meanings as in the main subroutine.</span>
<a name="l03389"></a>03389 <span class="comment">! Repeated use of certain sums makes the calculation more efficient.</span>
<a name="l03390"></a>03390 <span class="comment">! Integral formulas are described in triangle_coordinates subroutine.</span>
<a name="l03391"></a>03391 <span class="comment">!</span>
<a name="l03392"></a>03392 <span class="comment">! !REVISION HISTORY:</span>
<a name="l03393"></a>03393 <span class="comment">!</span>
<a name="l03394"></a>03394 <span class="comment">! author William H. Lipscomb, LANL</span>
<a name="l03395"></a>03395 <span class="comment">!</span>
<a name="l03396"></a>03396 <span class="comment">! !USES:</span>
<a name="l03397"></a>03397 <span class="comment">!</span>
<a name="l03398"></a>03398 <span class="comment">! !INPUT/OUTPUT PARAMETERS:</span>
<a name="l03399"></a>03399 <span class="comment">!</span>
<a name="l03400"></a>03400       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l03401"></a>03401            nx_block, ny_block  ,<span class="comment">! block dimensions</span>
<a name="l03402"></a>03402            integral_order   <span class="comment">! polynomial order for quadrature integrals </span>
<a name="l03403"></a>03403 
<a name="l03404"></a>03404       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (ntrace)</span>, <span class="keywordtype">intent(in)</span> ::     
<a name="l03405"></a>03405            tracer_type       ,<span class="comment">! = 1, 2, or 3 (see comments above)</span>
<a name="l03406"></a>03406            depend              <span class="comment">! tracer dependencies (see above)</span>
<a name="l03407"></a>03407 
<a name="l03408"></a>03408       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (ngroups)</span>, <span class="keywordtype">intent(in)</span> ::     
<a name="l03409"></a>03409            icells           <span class="comment">! number of cells where triarea &gt; puny</span>
<a name="l03410"></a>03410 
<a name="l03411"></a>03411       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (nx_block*ny_block,ngroups)</span>,     
<a name="l03412"></a>03412            <span class="keywordtype">intent(in)</span> ::     
<a name="l03413"></a>03413            indxi ,<span class="comment">! compressed index in i-direction</span>
<a name="l03414"></a>03414            indxj   <span class="comment">! compressed index in j-direction</span>
<a name="l03415"></a>03415 
<a name="l03416"></a>03416       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(in)</span>,   
<a name="l03417"></a>03417            <span class="keywordtype">dimension (nx_block, ny_block, 0:nvert, ngroups) </span>::   
<a name="l03418"></a>03418            xp, yp           <span class="comment">! coordinates of triangle points</span>
<a name="l03419"></a>03419 
<a name="l03420"></a>03420       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(in)</span>,   
<a name="l03421"></a>03421            <span class="keywordtype">dimension (nx_block, ny_block, ngroups) </span>::   
<a name="l03422"></a>03422            triarea          <span class="comment">! triangle area</span>
<a name="l03423"></a>03423 
<a name="l03424"></a>03424       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(in)</span>,   
<a name="l03425"></a>03425            <span class="keywordtype">dimension (nx_block, ny_block, ngroups) </span>::   
<a name="l03426"></a>03426            iflux     ,
<a name="l03427"></a>03427            jflux
<a name="l03428"></a>03428 
<a name="l03429"></a>03429       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(in)</span>,   
<a name="l03430"></a>03430            <span class="keywordtype">dimension (nx_block, ny_block) </span>::   
<a name="l03431"></a>03431            mc, mx, my
<a name="l03432"></a>03432 
<a name="l03433"></a>03433       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(out)</span>,   
<a name="l03434"></a>03434            <span class="keywordtype">dimension (nx_block, ny_block) </span>::   
<a name="l03435"></a>03435            mflx
<a name="l03436"></a>03436 
<a name="l03437"></a>03437       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(in)</span>,   
<a name="l03438"></a>03438            <span class="keywordtype">dimension (nx_block, ny_block, ntrace)</span>, <span class="keywordtype">optional</span> ::   
<a name="l03439"></a>03439            tc, tx, ty
<a name="l03440"></a>03440 
<a name="l03441"></a>03441       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">intent(out)</span>,   
<a name="l03442"></a>03442            <span class="keywordtype">dimension (nx_block, ny_block, ntrace)</span>, <span class="keywordtype">optional</span> ::   
<a name="l03443"></a>03443            mtflx
<a name="l03444"></a>03444 <span class="comment">!</span>
<a name="l03445"></a>03445 <span class="comment">!EOP</span>
<a name="l03446"></a>03446 <span class="comment">!</span>
<a name="l03447"></a>03447       <span class="keywordtype">integer (kind=int_kind) </span>::   
<a name="l03448"></a>03448            i, j, ij      ,<span class="comment">! horizontal indices of edge</span>
<a name="l03449"></a>03449            i2, j2        ,<span class="comment">! horizontal indices of cell contributing transport</span>
<a name="l03450"></a>03450            ng            ,<span class="comment">! triangle index</span>
<a name="l03451"></a>03451            nt, nt1       ,<span class="comment">! tracer indices</span>
<a name="l03452"></a>03452            ilo,ihi,jlo,jhi <span class="comment">! beginning and end of physical domain</span>
<a name="l03453"></a>03453 
<a name="l03454"></a>03454       <span class="keywordtype">real (kind=dbl_kind) </span>::   
<a name="l03455"></a>03455            m0, m1, m2, m3         ,<span class="comment">! mass field at internal points</span>
<a name="l03456"></a>03456            w0, w1, w2, w3           <span class="comment">! work variables</span>
<a name="l03457"></a>03457 
<a name="l03458"></a>03458       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block, ny_block) </span>::   
<a name="l03459"></a>03459            msum, mxsum, mysum     ,<span class="comment">! sum of mass, mass*x, and mass*y</span>
<a name="l03460"></a>03460            mxxsum, mxysum, myysum   <span class="comment">! sum of mass*x*x, mass*x*y, mass*y*y</span>
<a name="l03461"></a>03461 
<a name="l03462"></a>03462       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block, ny_block, ntrace) </span>::   
<a name="l03463"></a>03463            mtsum            ,<span class="comment">! sum of mass*tracer</span>
<a name="l03464"></a>03464            mtxsum           ,<span class="comment">! sum of mass*tracer*x</span>
<a name="l03465"></a>03465            mtysum             <span class="comment">! sum of mass*tracer*y</span>
<a name="l03466"></a>03466 
<a name="l03467"></a>03467     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03468"></a>03468     <span class="comment">! Initialize</span>
<a name="l03469"></a>03469     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03470"></a>03470 
<a name="l03471"></a>03471       mflx(:,:) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l03472"></a>03472       <span class="keyword">if</span> (present(mtflx)) <span class="keyword">then</span>
<a name="l03473"></a>03473          <span class="keyword">do</span> nt = 1, <a class="code" href="namespaceice__transport__remap.html#a5012cc594b512eddae2a80fd91132217">ntrace</a>
<a name="l03474"></a>03474             mtflx(:,:,nt) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l03475"></a>03475          <span class="keyword">enddo</span>
<a name="l03476"></a>03476       <span class="keyword">endif</span>
<a name="l03477"></a>03477 
<a name="l03478"></a>03478     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03479"></a>03479     <span class="comment">! Main loop</span>
<a name="l03480"></a>03480     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03481"></a>03481 
<a name="l03482"></a>03482       <span class="keyword">do</span> ng = 1, <a class="code" href="namespaceice__transport__remap.html#a66c26988d6a99e211fdc9fd6cb9025c6">ngroups</a>
<a name="l03483"></a>03483 
<a name="l03484"></a>03484          <span class="keyword">if</span> (integral_order == 1) <span class="keyword">then</span>  <span class="comment">! linear (1-point formula)</span>
<a name="l03485"></a>03485 
<a name="l03486"></a>03486 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l03487"></a>03487 <span class="comment">!cdir nodep      !NEC</span>
<a name="l03488"></a>03488 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l03489"></a>03489             <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03490"></a>03490                i = indxi(ij,ng)
<a name="l03491"></a>03491                j = indxj(ij,ng)
<a name="l03492"></a>03492 
<a name="l03493"></a>03493                i2 = iflux(i,j,ng)
<a name="l03494"></a>03494                j2 = jflux(i,j,ng)
<a name="l03495"></a>03495 
<a name="l03496"></a>03496                <span class="comment">! mass transports</span>
<a name="l03497"></a>03497 
<a name="l03498"></a>03498                m0 = mc(i2,j2) + xp(i,j,0,ng)*mx(i2,j2)   &amp;
<a name="l03499"></a>03499                               + yp(i,j,0,ng)*my(i2,j2)
<a name="l03500"></a>03500                msum(i,j) = m0
<a name="l03501"></a>03501 
<a name="l03502"></a>03502                mflx(i,j) = mflx(i,j) + triarea(i,j,ng)*msum(i,j)
<a name="l03503"></a>03503 
<a name="l03504"></a>03504                <span class="comment">! quantities needed for tracer transports</span>
<a name="l03505"></a>03505                mxsum(i,j)  =         m0*xp(i,j,0,ng) 
<a name="l03506"></a>03506                mxxsum(i,j) = mxsum(i,j)*xp(i,j,0,ng) 
<a name="l03507"></a>03507                mxysum(i,j) = mxsum(i,j)*yp(i,j,0,ng) 
<a name="l03508"></a>03508                mysum(i,j)  =         m0*yp(i,j,0,ng) 
<a name="l03509"></a>03509                myysum(i,j) = mysum(i,j)*yp(i,j,0,ng) 
<a name="l03510"></a>03510             <span class="keyword">enddo</span>               <span class="comment">! ij</span>
<a name="l03511"></a>03511 
<a name="l03512"></a>03512          elseif (integral_order == 2) <span class="keyword">then</span>  <span class="comment">! quadratic (3-point formula)</span>
<a name="l03513"></a>03513 
<a name="l03514"></a>03514 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l03515"></a>03515 <span class="comment">!cdir nodep      !NEC</span>
<a name="l03516"></a>03516 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l03517"></a>03517             <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03518"></a>03518                i = indxi(ij,ng)
<a name="l03519"></a>03519                j = indxj(ij,ng)
<a name="l03520"></a>03520 
<a name="l03521"></a>03521                i2 = iflux(i,j,ng)
<a name="l03522"></a>03522                j2 = jflux(i,j,ng)
<a name="l03523"></a>03523 
<a name="l03524"></a>03524                <span class="comment">! mass transports</span>
<a name="l03525"></a>03525                <span class="comment">! Weighting factor of 1/3 is incorporated into the ice</span>
<a name="l03526"></a>03526                <span class="comment">! area terms m1, m2, and m3.</span>
<a name="l03527"></a>03527                m1 = <a class="code" href="namespaceice__constants.html#a9dfb9e1671683be9cb08717f174638cc">p333</a> * (mc(i2,j2) + xp(i,j,1,ng)*mx(i2,j2)   &amp;
<a name="l03528"></a>03528                                       + yp(i,j,1,ng)*my(i2,j2))
<a name="l03529"></a>03529                m2 = <a class="code" href="namespaceice__constants.html#a9dfb9e1671683be9cb08717f174638cc">p333</a> * (mc(i2,j2) + xp(i,j,2,ng)*mx(i2,j2)   &amp;
<a name="l03530"></a>03530                                       + yp(i,j,2,ng)*my(i2,j2))
<a name="l03531"></a>03531                m3 = <a class="code" href="namespaceice__constants.html#a9dfb9e1671683be9cb08717f174638cc">p333</a> * (mc(i2,j2) + xp(i,j,3,ng)*mx(i2,j2)   &amp;
<a name="l03532"></a>03532                                       + yp(i,j,3,ng)*my(i2,j2))
<a name="l03533"></a>03533                msum(i,j) = m1 + m2 + m3
<a name="l03534"></a>03534                mflx(i,j) = mflx(i,j) + triarea(i,j,ng)*msum(i,j)
<a name="l03535"></a>03535 
<a name="l03536"></a>03536                <span class="comment">! quantities needed for mass_tracer transports</span>
<a name="l03537"></a>03537                w1 = m1 * xp(i,j,1,ng)
<a name="l03538"></a>03538                w2 = m2 * xp(i,j,2,ng)
<a name="l03539"></a>03539                w3 = m3 * xp(i,j,3,ng)
<a name="l03540"></a>03540 
<a name="l03541"></a>03541                mxsum(i,j) = w1 + w2 + w3
<a name="l03542"></a>03542 
<a name="l03543"></a>03543                mxxsum(i,j) = w1*xp(i,j,1,ng) + w2*xp(i,j,2,ng)   &amp;
<a name="l03544"></a>03544                            + w3*xp(i,j,3,ng) 
<a name="l03545"></a>03545 
<a name="l03546"></a>03546                mxysum(i,j) = w1*yp(i,j,1,ng) + w2*yp(i,j,2,ng)   &amp;
<a name="l03547"></a>03547                            + w3*yp(i,j,3,ng)
<a name="l03548"></a>03548 
<a name="l03549"></a>03549                w1 = m1 * yp(i,j,1,ng)
<a name="l03550"></a>03550                w2 = m2 * yp(i,j,2,ng)
<a name="l03551"></a>03551                w3 = m3 * yp(i,j,3,ng)
<a name="l03552"></a>03552 
<a name="l03553"></a>03553                mysum(i,j) = w1 + w2 + w3
<a name="l03554"></a>03554 
<a name="l03555"></a>03555                myysum(i,j) = w1*yp(i,j,1,ng) + w2*yp(i,j,2,ng)   &amp;
<a name="l03556"></a>03556                            + w3*yp(i,j,3,ng)
<a name="l03557"></a>03557             <span class="keyword">enddo</span>               <span class="comment">! ij</span>
<a name="l03558"></a>03558 
<a name="l03559"></a>03559          <span class="keyword">else</span>                   <span class="comment">! cubic (4-point formula)</span>
<a name="l03560"></a>03560 
<a name="l03561"></a>03561 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l03562"></a>03562 <span class="comment">!cdir nodep      !NEC</span>
<a name="l03563"></a>03563 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l03564"></a>03564             <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03565"></a>03565                i = indxi(ij,ng)
<a name="l03566"></a>03566                j = indxj(ij,ng)
<a name="l03567"></a>03567 
<a name="l03568"></a>03568                i2 = iflux(i,j,ng)
<a name="l03569"></a>03569                j2 = jflux(i,j,ng)
<a name="l03570"></a>03570 
<a name="l03571"></a>03571                <span class="comment">! mass transports</span>
<a name="l03572"></a>03572 
<a name="l03573"></a>03573                <span class="comment">! Weighting factors are incorporated into the</span>
<a name="l03574"></a>03574                <span class="comment">! terms m0, m1, m2, and m3.</span>
<a name="l03575"></a>03575                m0 = <a class="code" href="namespaceice__transport__remap.html#a4571153ae2d02f5b5251863d6bdabc37">p5625m</a> * (mc(i2,j2) + xp(i,j,0,ng)*mx(i2,j2)   &amp;
<a name="l03576"></a>03576                                         + yp(i,j,0,ng)*my(i2,j2))
<a name="l03577"></a>03577                m1 = <a class="code" href="namespaceice__transport__remap.html#a61fb7fc0ff741aea883e70089a6f0ea8">p52083</a> * (mc(i2,j2) + xp(i,j,1,ng)*mx(i2,j2)   &amp;
<a name="l03578"></a>03578                                         + yp(i,j,1,ng)*my(i2,j2))
<a name="l03579"></a>03579                m2 = <a class="code" href="namespaceice__transport__remap.html#a61fb7fc0ff741aea883e70089a6f0ea8">p52083</a> * (mc(i2,j2) + xp(i,j,2,ng)*mx(i2,j2)   &amp;
<a name="l03580"></a>03580                                         + yp(i,j,2,ng)*my(i2,j2))
<a name="l03581"></a>03581                m3 = <a class="code" href="namespaceice__transport__remap.html#a61fb7fc0ff741aea883e70089a6f0ea8">p52083</a> * (mc(i2,j2) + xp(i,j,3,ng)*mx(i2,j2)   &amp;
<a name="l03582"></a>03582                                         + yp(i,j,3,ng)*my(i2,j2))
<a name="l03583"></a>03583                msum(i,j) = m0 + m1 + m2 + m3
<a name="l03584"></a>03584                mflx(i,j) = mflx(i,j) + triarea(i,j,ng)*msum(i,j)
<a name="l03585"></a>03585 
<a name="l03586"></a>03586                <span class="comment">! quantities needed for tracer transports</span>
<a name="l03587"></a>03587                w0 = m0 * xp(i,j,0,ng)
<a name="l03588"></a>03588                w1 = m1 * xp(i,j,1,ng)
<a name="l03589"></a>03589                w2 = m2 * xp(i,j,2,ng)
<a name="l03590"></a>03590                w3 = m3 * xp(i,j,3,ng)
<a name="l03591"></a>03591 
<a name="l03592"></a>03592                mxsum(i,j) = w0 + w1 + w2 + w3
<a name="l03593"></a>03593 
<a name="l03594"></a>03594                mxxsum(i,j) = w0*xp(i,j,0,ng) + w1*xp(i,j,1,ng)   &amp;
<a name="l03595"></a>03595                            + w2*xp(i,j,2,ng) + w3*xp(i,j,3,ng)
<a name="l03596"></a>03596 
<a name="l03597"></a>03597                mxysum(i,j) = w0*yp(i,j,0,ng) + w1*yp(i,j,1,ng)   &amp;
<a name="l03598"></a>03598                            + w2*yp(i,j,2,ng) + w3*yp(i,j,3,ng)
<a name="l03599"></a>03599 
<a name="l03600"></a>03600                w0 = m0 * yp(i,j,0,ng)
<a name="l03601"></a>03601                w1 = m1 * yp(i,j,1,ng)
<a name="l03602"></a>03602                w2 = m2 * yp(i,j,2,ng)
<a name="l03603"></a>03603                w3 = m3 * yp(i,j,3,ng)
<a name="l03604"></a>03604 
<a name="l03605"></a>03605                mysum(i,j) = w0 + w1 + w2 + w3
<a name="l03606"></a>03606 
<a name="l03607"></a>03607                myysum(i,j) = w0*yp(i,j,0,ng) + w1*yp(i,j,1,ng)   &amp;
<a name="l03608"></a>03608                            + w2*yp(i,j,2,ng) + w3*yp(i,j,3,ng)
<a name="l03609"></a>03609 
<a name="l03610"></a>03610             <span class="keyword">enddo</span>               <span class="comment">! ij</span>
<a name="l03611"></a>03611 
<a name="l03612"></a>03612          <span class="keyword">endif</span>                  <span class="comment">! integral_order</span>
<a name="l03613"></a>03613 
<a name="l03614"></a>03614          <span class="comment">! mass * tracer transports</span>
<a name="l03615"></a>03615 
<a name="l03616"></a>03616          <span class="keyword">if</span> (present(mtflx)) <span class="keyword">then</span>
<a name="l03617"></a>03617 
<a name="l03618"></a>03618             <span class="keyword">do</span> nt = 1, <a class="code" href="namespaceice__transport__remap.html#a5012cc594b512eddae2a80fd91132217">ntrace</a>
<a name="l03619"></a>03619                <span class="keyword">if</span> (tracer_type(nt)==1) <span class="keyword">then</span> <span class="comment">! does not depend on another tracer</span>
<a name="l03620"></a>03620 
<a name="l03621"></a>03621 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l03622"></a>03622 <span class="comment">!cdir nodep      !NEC</span>
<a name="l03623"></a>03623 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l03624"></a>03624                   <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03625"></a>03625                      i = indxi(ij,ng)
<a name="l03626"></a>03626                      j = indxj(ij,ng)
<a name="l03627"></a>03627 
<a name="l03628"></a>03628                      i2 = iflux(i,j,ng)
<a name="l03629"></a>03629                      j2 = jflux(i,j,ng)
<a name="l03630"></a>03630 
<a name="l03631"></a>03631                      mtsum(i,j,nt) =  msum(i,j) * tc(i2,j2,nt)   &amp;
<a name="l03632"></a>03632                                    + mxsum(i,j) * tx(i2,j2,nt)   &amp;
<a name="l03633"></a>03633                                    + mysum(i,j) * ty(i2,j2,nt)
<a name="l03634"></a>03634 
<a name="l03635"></a>03635                      mtflx(i,j,nt) = mtflx(i,j,nt)   &amp;
<a name="l03636"></a>03636                                  + triarea(i,j,ng) * mtsum(i,j,nt)
<a name="l03637"></a>03637 
<a name="l03638"></a>03638                      <span class="comment">! quantities needed for dependent tracers</span>
<a name="l03639"></a>03639 
<a name="l03640"></a>03640                      mtxsum(i,j,nt) =  mxsum(i,j) * tc(i2,j2,nt)   &amp;
<a name="l03641"></a>03641                                     + mxxsum(i,j) * tx(i2,j2,nt)   &amp;
<a name="l03642"></a>03642                                     + mxysum(i,j) * ty(i2,j2,nt)
<a name="l03643"></a>03643 
<a name="l03644"></a>03644                      mtysum(i,j,nt) =  mysum(i,j) * tc(i2,j2,nt)   &amp;
<a name="l03645"></a>03645                                     + mxysum(i,j) * tx(i2,j2,nt)   &amp;
<a name="l03646"></a>03646                                     + myysum(i,j) * ty(i2,j2,nt)
<a name="l03647"></a>03647                   <span class="keyword">enddo</span>         <span class="comment">! ij</span>
<a name="l03648"></a>03648 
<a name="l03649"></a>03649                elseif (tracer_type(nt)==2) <span class="keyword">then</span> <span class="comment">! depends on another tracer</span>
<a name="l03650"></a>03650                   nt1 = depend(nt)
<a name="l03651"></a>03651 
<a name="l03652"></a>03652 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l03653"></a>03653 <span class="comment">!cdir nodep      !NEC</span>
<a name="l03654"></a>03654 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l03655"></a>03655                   <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03656"></a>03656                      i = indxi(ij,ng)
<a name="l03657"></a>03657                      j = indxj(ij,ng)
<a name="l03658"></a>03658 
<a name="l03659"></a>03659                      i2 = iflux(i,j,ng)
<a name="l03660"></a>03660                      j2 = jflux(i,j,ng)
<a name="l03661"></a>03661 
<a name="l03662"></a>03662                      mtsum(i,j,nt) =  mtsum(i,j,nt1) * tc(i2,j2,nt)   &amp;
<a name="l03663"></a>03663                                    + mtxsum(i,j,nt1) * tx(i2,j2,nt)   &amp;
<a name="l03664"></a>03664                                    + mtysum(i,j,nt1) * ty(i2,j2,nt)
<a name="l03665"></a>03665 
<a name="l03666"></a>03666                      mtflx(i,j,nt) = mtflx(i,j,nt)   &amp;
<a name="l03667"></a>03667                                    + triarea(i,j,ng) * mtsum(i,j,nt)
<a name="l03668"></a>03668                   <span class="keyword">enddo</span>         <span class="comment">! ij</span>
<a name="l03669"></a>03669 
<a name="l03670"></a>03670 
<a name="l03671"></a>03671                elseif (tracer_type(nt)==3) <span class="keyword">then</span> <span class="comment">! depends on two tracers</span>
<a name="l03672"></a>03672                   nt1 = depend(nt)
<a name="l03673"></a>03673 
<a name="l03674"></a>03674 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l03675"></a>03675 <span class="comment">!cdir nodep      !NEC</span>
<a name="l03676"></a>03676 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l03677"></a>03677                   <span class="keyword">do</span> ij = 1, icells(ng)
<a name="l03678"></a>03678                      i = indxi(ij,ng)
<a name="l03679"></a>03679                      j = indxj(ij,ng)
<a name="l03680"></a>03680 
<a name="l03681"></a>03681                      i2 = iflux(i,j,ng)
<a name="l03682"></a>03682                      j2 = jflux(i,j,ng)
<a name="l03683"></a>03683 
<a name="l03684"></a>03684                      <span class="comment">! upwind approx (tx=ty=0) for type 3 tracers</span>
<a name="l03685"></a>03685                      mtsum(i,j,nt) =  mtsum(i,j,nt1) * tc(i2,j2,nt)
<a name="l03686"></a>03686 
<a name="l03687"></a>03687                      mtflx(i,j,nt) = mtflx(i,j,nt)   &amp;
<a name="l03688"></a>03688                                    + triarea(i,j,ng) * mtsum(i,j,nt)
<a name="l03689"></a>03689                   <span class="keyword">enddo</span>         <span class="comment">! ij</span>
<a name="l03690"></a>03690 
<a name="l03691"></a>03691                <span class="keyword">endif</span>            <span class="comment">! tracer type</span>
<a name="l03692"></a>03692             <span class="keyword">enddo</span>               <span class="comment">! ntrace</span>
<a name="l03693"></a>03693          <span class="keyword">endif</span>                  <span class="comment">! present(mtflx)</span>
<a name="l03694"></a>03694       <span class="keyword">enddo</span>                     <span class="comment">! ng</span>
<a name="l03695"></a>03695 
<a name="l03696"></a>03696 <span class="keyword">      end subroutine transport_integrals</span>
<a name="l03697"></a>03697 
<a name="l03698"></a>03698 <span class="comment">!=======================================================================</span>
<a name="l03699"></a>03699 <span class="comment">!</span>
<a name="l03700"></a>03700 <span class="comment">!BOP</span>
<a name="l03701"></a>03701 <span class="comment">!</span>
<a name="l03702"></a>03702 <span class="comment">! !IROUTINE: update_fields - compute new area and tracers</span>
<a name="l03703"></a>03703 <span class="comment">!</span>
<a name="l03704"></a>03704 <span class="comment">! !INTERFACE:</span>
<a name="l03705"></a>03705 <span class="comment">!</span>
<a name="l03706"></a><a class="code" href="namespaceice__transport__remap.html#a2f57bc59a0a273bc0c6aff4104b094c0">03706</a>       <span class="keyword">subroutine </span><a class="code" href="namespaceice__transport__remap.html#a2f57bc59a0a273bc0c6aff4104b094c0">update_fields</a> (nx_block,    ny_block,   &amp;
<a name="l03707"></a>03707                                 ilo, ihi,    jlo, jhi,   &amp;
<a name="l03708"></a>03708                                 tracer_type, depend,     &amp;
<a name="l03709"></a>03709                                 tarear,      l_stop,     &amp;
<a name="l03710"></a>03710                                 istop,       jstop,      &amp;
<a name="l03711"></a>03711                                 mflxe,       mflxn,      &amp;
<a name="l03712"></a>03712                                 mm,                      &amp;
<a name="l03713"></a>03713                                 mtflxe,      mtflxn,     &amp;
<a name="l03714"></a>03714                                 tm)
<a name="l03715"></a>03715 <span class="comment">!</span>
<a name="l03716"></a>03716 <span class="comment">! !DESCRIPTION:</span>
<a name="l03717"></a>03717 <span class="comment">!</span>
<a name="l03718"></a>03718 <span class="comment">! Given transports through cell edges, compute new area and tracers.</span>
<a name="l03719"></a>03719 <span class="comment">!</span>
<a name="l03720"></a>03720 <span class="comment">! !REVISION HISTORY:</span>
<a name="l03721"></a>03721 <span class="comment">!</span>
<a name="l03722"></a>03722 <span class="comment">! author William H. Lipscomb, LANL</span>
<a name="l03723"></a>03723 <span class="comment">!</span>
<a name="l03724"></a>03724 <span class="comment">! !USES:</span>
<a name="l03725"></a>03725 <span class="comment">!</span>
<a name="l03726"></a>03726 <span class="comment">! !INPUT/OUTPUT PARAMETERS:</span>
<a name="l03727"></a>03727 <span class="comment">!</span>
<a name="l03728"></a>03728       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(in)</span> ::   
<a name="l03729"></a>03729          nx_block, ny_block,<span class="comment">! block dimensions</span>
<a name="l03730"></a>03730          ilo,ihi,jlo,jhi     <span class="comment">! beginning and end of physical domain</span>
<a name="l03731"></a>03731 
<a name="l03732"></a>03732       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension (ntrace)</span>, <span class="keywordtype">intent(in)</span> ::     
<a name="l03733"></a>03733          tracer_type       ,<span class="comment">! = 1, 2, or 3 (see comments above)</span>
<a name="l03734"></a>03734          depend              <span class="comment">! tracer dependencies (see above)</span>
<a name="l03735"></a>03735 
<a name="l03736"></a>03736       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block, ny_block)</span>,   
<a name="l03737"></a>03737          <span class="keywordtype">intent(in)</span> ::   
<a name="l03738"></a>03738          mflxe, mflxn   ,<span class="comment">! mass transport across east and north cell edges</span>
<a name="l03739"></a>03739          tarear           <span class="comment">! 1/tarea</span>
<a name="l03740"></a>03740 
<a name="l03741"></a>03741       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block, ny_block)</span>,   
<a name="l03742"></a>03742          <span class="keywordtype">intent(inout)</span> ::   
<a name="l03743"></a>03743          mm               <span class="comment">! mass field (mean)</span>
<a name="l03744"></a>03744 
<a name="l03745"></a>03745       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block, ny_block, ntrace)</span>,   
<a name="l03746"></a>03746          <span class="keywordtype">intent(in)</span>, <span class="keywordtype">optional</span> ::   
<a name="l03747"></a>03747          mtflxe, mtflxn   <span class="comment">! mass*tracer transport across E and N cell edges</span>
<a name="l03748"></a>03748 
<a name="l03749"></a>03749       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension (nx_block, ny_block, ntrace)</span>,   
<a name="l03750"></a>03750          <span class="keywordtype">intent(inout)</span>, <span class="keywordtype">optional</span> ::   
<a name="l03751"></a>03751          tm               <span class="comment">! tracer fields</span>
<a name="l03752"></a>03752 
<a name="l03753"></a>03753       <span class="keywordtype">logical (kind=log_kind)</span>, <span class="keywordtype">intent(inout)</span> ::   
<a name="l03754"></a>03754          l_stop           <span class="comment">! if true, abort on return</span>
<a name="l03755"></a>03755 
<a name="l03756"></a>03756       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">intent(inout)</span> ::   
<a name="l03757"></a>03757          istop, jstop     <span class="comment">! indices of grid cell where model aborts </span>
<a name="l03758"></a>03758 
<a name="l03759"></a>03759 <span class="comment">!</span>
<a name="l03760"></a>03760 <span class="comment">!EOP</span>
<a name="l03761"></a>03761 <span class="comment">!</span>
<a name="l03762"></a>03762       <span class="keywordtype">integer (kind=int_kind) </span>::   
<a name="l03763"></a>03763          i, j           ,<span class="comment">! horizontal indices</span>
<a name="l03764"></a>03764          nt, nt1, nt2     <span class="comment">! tracer indices</span>
<a name="l03765"></a>03765 
<a name="l03766"></a>03766       <span class="keywordtype">real (kind=dbl_kind)</span>, <span class="keywordtype">dimension(nx_block,ny_block,ntrace) </span>::   
<a name="l03767"></a>03767          mtold            <span class="comment">! old mass*tracer</span>
<a name="l03768"></a>03768 
<a name="l03769"></a>03769       <span class="keywordtype">real (kind=dbl_kind) </span>::   
<a name="l03770"></a>03770          w1, w2           <span class="comment">! work variables</span>
<a name="l03771"></a>03771 
<a name="l03772"></a>03772       <span class="keywordtype">integer (kind=int_kind)</span>, <span class="keywordtype">dimension(nx_block*ny_block) </span>::   
<a name="l03773"></a>03773          indxi          ,<span class="comment">! compressed indices in i and j directions</span>
<a name="l03774"></a>03774          indxj
<a name="l03775"></a>03775 
<a name="l03776"></a>03776       <span class="keywordtype">integer (kind=int_kind) </span>::   
<a name="l03777"></a>03777          icells         ,<span class="comment">! number of cells with mm &gt; 0.</span>
<a name="l03778"></a>03778          ij               <span class="comment">! combined i/j horizontal index</span>
<a name="l03779"></a>03779 
<a name="l03780"></a>03780     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03781"></a>03781     <span class="comment">! Save starting values of mass*tracer</span>
<a name="l03782"></a>03782     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03783"></a>03783 
<a name="l03784"></a>03784       <span class="keyword">if</span> (present(tm)) <span class="keyword">then</span>
<a name="l03785"></a>03785          <span class="keyword">do</span> nt = 1, <a class="code" href="namespaceice__transport__remap.html#a5012cc594b512eddae2a80fd91132217">ntrace</a>
<a name="l03786"></a>03786             <span class="keyword">if</span> (tracer_type(nt)==1) <span class="keyword">then</span> <span class="comment">! does not depend on other tracers</span>
<a name="l03787"></a>03787                <span class="keyword">do</span> j = jlo, jhi
<a name="l03788"></a>03788                <span class="keyword">do</span> i = ilo, ihi
<a name="l03789"></a>03789                   mtold(i,j,nt) = mm(i,j) * tm(i,j,nt)
<a name="l03790"></a>03790                <span class="keyword">enddo</span>            <span class="comment">! i</span>
<a name="l03791"></a>03791                <span class="keyword">enddo</span>              <span class="comment">! j</span>
<a name="l03792"></a>03792             elseif (tracer_type(nt)==2) <span class="keyword">then</span>  <span class="comment">! depends on another tracer</span>
<a name="l03793"></a>03793                nt1 = depend(nt)
<a name="l03794"></a>03794                <span class="keyword">do</span> j = jlo, jhi
<a name="l03795"></a>03795                <span class="keyword">do</span> i = ilo, ihi
<a name="l03796"></a>03796                   mtold(i,j,nt) = mm(i,j) * tm(i,j,nt1) * tm(i,j,nt)
<a name="l03797"></a>03797                <span class="keyword">enddo</span>            <span class="comment">! i</span>
<a name="l03798"></a>03798                <span class="keyword">enddo</span>            <span class="comment">! j</span>
<a name="l03799"></a>03799             elseif (tracer_type(nt)==3) <span class="keyword">then</span>  <span class="comment">! depends on two tracers</span>
<a name="l03800"></a>03800                nt1 = depend(nt)
<a name="l03801"></a>03801                nt2 = depend(nt1)
<a name="l03802"></a>03802                <span class="keyword">do</span> j = jlo, jhi
<a name="l03803"></a>03803                <span class="keyword">do</span> i = ilo, ihi
<a name="l03804"></a>03804                   mtold(i,j,nt) = mm(i,j)    &amp;
<a name="l03805"></a>03805                             * tm(i,j,nt2) * tm(i,j,nt1) * tm(i,j,nt)
<a name="l03806"></a>03806                <span class="keyword">enddo</span>            <span class="comment">! i</span>
<a name="l03807"></a>03807                <span class="keyword">enddo</span>            <span class="comment">! j</span>
<a name="l03808"></a>03808 
<a name="l03809"></a>03809  
<a name="l03810"></a>03810             <span class="keyword">endif</span>               <span class="comment">! depend(nt) = 0</span>
<a name="l03811"></a>03811          <span class="keyword">enddo</span>                  <span class="comment">! nt</span>
<a name="l03812"></a>03812       <span class="keyword">endif</span>                     <span class="comment">! present(tm)</span>
<a name="l03813"></a>03813 
<a name="l03814"></a>03814     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03815"></a>03815     <span class="comment">! Update mass field</span>
<a name="l03816"></a>03816     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03817"></a>03817 
<a name="l03818"></a>03818       <span class="keyword">do</span> j = jlo, jhi
<a name="l03819"></a>03819       <span class="keyword">do</span> i = ilo, ihi
<a name="l03820"></a>03820 
<a name="l03821"></a>03821          w1 = mflxe(i,j) - mflxe(i-1,j)   &amp;
<a name="l03822"></a>03822             + mflxn(i,j) - mflxn(i,j-1)
<a name="l03823"></a>03823          mm(i,j) = mm(i,j) - w1*tarear(i,j)
<a name="l03824"></a>03824 
<a name="l03825"></a>03825          <span class="keyword">if</span> (mm(i,j) &lt; -<a class="code" href="namespaceice__constants.html#af5d2a72e22e7a53706b6a41ba932a67d">puny</a>) <span class="keyword">then</span>    <span class="comment">! abort with negative value</span>
<a name="l03826"></a>03826             l_stop = .true.
<a name="l03827"></a>03827             istop = i
<a name="l03828"></a>03828             jstop = j
<a name="l03829"></a>03829          elseif (mm(i,j) &lt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>   <span class="comment">! set to zero</span>
<a name="l03830"></a>03830             mm(i,j) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l03831"></a>03831          <span class="keyword">endif</span>
<a name="l03832"></a>03832 
<a name="l03833"></a>03833       <span class="keyword">enddo</span>
<a name="l03834"></a>03834       <span class="keyword">enddo</span>
<a name="l03835"></a>03835 
<a name="l03836"></a>03836       <span class="keyword">if</span> (l_stop) <span class="keyword">then</span>
<a name="l03837"></a>03837          i = istop
<a name="l03838"></a>03838          j = jstop
<a name="l03839"></a>03839          w1 = mflxe(i,j) - mflxe(i-1,j)   &amp;
<a name="l03840"></a>03840             + mflxn(i,j) - mflxn(i,j-1)
<a name="l03841"></a>03841          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos; &apos;</span>
<a name="l03842"></a>03842          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;New mass &lt; 0, i, j =&apos;</span>, i, j
<a name="l03843"></a>03843          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;Old mass =&apos;</span>, mm(i,j) + w1*tarear(i,j)
<a name="l03844"></a>03844          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;New mass =&apos;</span>, mm(i,j)
<a name="l03845"></a>03845          <span class="keyword">write</span> (<a class="code" href="namespaceice__fileunits.html#a5a65f292ace9ba700843f3e293922842">nu_diag</a>,*) <span class="stringliteral">&apos;Net transport =&apos;</span>, -w1*tarear(i,j)
<a name="l03846"></a>03846          return
<a name="l03847"></a>03847       <span class="keyword">endif</span>
<a name="l03848"></a>03848 
<a name="l03849"></a>03849     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03850"></a>03850     <span class="comment">! Update tracers</span>
<a name="l03851"></a>03851     <span class="comment">!-------------------------------------------------------------------</span>
<a name="l03852"></a>03852 
<a name="l03853"></a>03853       <span class="keyword">if</span> (present(tm)) <span class="keyword">then</span>
<a name="l03854"></a>03854 
<a name="l03855"></a>03855          icells = 0
<a name="l03856"></a>03856          <span class="keyword">do</span> j = jlo, jhi
<a name="l03857"></a>03857          <span class="keyword">do</span> i = ilo, ihi
<a name="l03858"></a>03858             <span class="keyword">if</span> (mm(i,j) &gt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span> <span class="comment">! grid cells with positive areas</span>
<a name="l03859"></a>03859                icells = icells + 1
<a name="l03860"></a>03860                indxi(icells) = i
<a name="l03861"></a>03861                indxj(icells) = j
<a name="l03862"></a>03862             <span class="keyword">endif</span>
<a name="l03863"></a>03863          <span class="keyword">enddo</span>                  <span class="comment">! i</span>
<a name="l03864"></a>03864          <span class="keyword">enddo</span>                  <span class="comment">! j</span>
<a name="l03865"></a>03865 
<a name="l03866"></a>03866          <span class="keyword">do</span> nt = 1, <a class="code" href="namespaceice__transport__remap.html#a5012cc594b512eddae2a80fd91132217">ntrace</a>
<a name="l03867"></a>03867 
<a name="l03868"></a>03868             <span class="keyword">do</span> j = jlo, jhi
<a name="l03869"></a>03869             <span class="keyword">do</span> i = ilo, ihi
<a name="l03870"></a>03870                tm(i,j,nt) = <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>
<a name="l03871"></a>03871             <span class="keyword">enddo</span>
<a name="l03872"></a>03872             <span class="keyword">enddo</span>
<a name="l03873"></a>03873 
<a name="l03874"></a>03874             <span class="keyword">if</span> (tracer_type(nt)==1) <span class="keyword">then</span> <span class="comment">! does not depend on other tracers</span>
<a name="l03875"></a>03875 
<a name="l03876"></a>03876                <span class="keyword">do</span> ij = 1, icells
<a name="l03877"></a>03877                   i = indxi(ij)
<a name="l03878"></a>03878                   j = indxj(ij)
<a name="l03879"></a>03879 
<a name="l03880"></a>03880                   w1  = mtflxe(i,j,nt) - mtflxe(i-1,j,nt)   &amp;
<a name="l03881"></a>03881                       + mtflxn(i,j,nt) - mtflxn(i,j-1,nt)
<a name="l03882"></a>03882                   tm(i,j,nt) = (mtold(i,j,nt) - w1*tarear(i,j))   &amp;
<a name="l03883"></a>03883                                 / mm(i,j)
<a name="l03884"></a>03884                <span class="keyword">enddo</span>            <span class="comment">! ij</span>
<a name="l03885"></a>03885 
<a name="l03886"></a>03886 
<a name="l03887"></a>03887             elseif (tracer_type(nt)==2) <span class="keyword">then</span> <span class="comment">! depends on another tracer</span>
<a name="l03888"></a>03888                nt1 = depend(nt)
<a name="l03889"></a>03889 
<a name="l03890"></a>03890 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l03891"></a>03891 <span class="comment">!cdir nodep      !NEC</span>
<a name="l03892"></a>03892 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l03893"></a>03893                <span class="keyword">do</span> ij = 1, icells
<a name="l03894"></a>03894                   i = indxi(ij)
<a name="l03895"></a>03895                   j = indxj(ij)
<a name="l03896"></a>03896 
<a name="l03897"></a>03897                   <span class="keyword">if</span> (abs(tm(i,j,nt1)) &gt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l03898"></a>03898                      w1  = mtflxe(i,j,nt) - mtflxe(i-1,j,nt)   &amp;
<a name="l03899"></a>03899                          + mtflxn(i,j,nt) - mtflxn(i,j-1,nt)
<a name="l03900"></a>03900                      tm(i,j,nt) = (mtold(i,j,nt) - w1*tarear(i,j))   &amp;
<a name="l03901"></a>03901                                  / (mm(i,j) * tm(i,j,nt1))
<a name="l03902"></a>03902                   <span class="keyword">endif</span>
<a name="l03903"></a>03903                <span class="keyword">enddo</span>            <span class="comment">! ij</span>
<a name="l03904"></a>03904 
<a name="l03905"></a>03905             elseif (tracer_type(nt)==3) <span class="keyword">then</span> <span class="comment">! depends on two tracers</span>
<a name="l03906"></a>03906                nt1 = depend(nt)
<a name="l03907"></a>03907                nt2 = depend(nt1)
<a name="l03908"></a>03908 
<a name="l03909"></a>03909 <span class="comment">!DIR$ CONCURRENT !Cray</span>
<a name="l03910"></a>03910 <span class="comment">!cdir nodep      !NEC</span>
<a name="l03911"></a>03911 <span class="comment">!ocl novrec      !Fujitsu</span>
<a name="l03912"></a>03912                <span class="keyword">do</span> ij = 1, icells
<a name="l03913"></a>03913                   i = indxi(ij)
<a name="l03914"></a>03914                   j = indxj(ij)
<a name="l03915"></a>03915 
<a name="l03916"></a>03916                   <span class="keyword">if</span> (abs(tm(i,j,nt1)) &gt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a> .and.   &amp;
<a name="l03917"></a>03917                       abs(tm(i,j,nt2)) &gt; <a class="code" href="namespaceice__constants.html#a8320d3c058c4ae0e12bbf1b11305e51e">c0</a>) <span class="keyword">then</span>
<a name="l03918"></a>03918                      w1  = mtflxe(i,j,nt) - mtflxe(i-1,j,nt)   &amp;
<a name="l03919"></a>03919                          + mtflxn(i,j,nt) - mtflxn(i,j-1,nt)
<a name="l03920"></a>03920                      tm(i,j,nt) = (mtold(i,j,nt) - w1*tarear(i,j))   &amp;
<a name="l03921"></a>03921                               / (mm(i,j) * tm(i,j,nt2) * tm(i,j,nt1))
<a name="l03922"></a>03922                   <span class="keyword">endif</span>
<a name="l03923"></a>03923                <span class="keyword">enddo</span>            <span class="comment">! ij</span>
<a name="l03924"></a>03924             <span class="keyword">endif</span>               <span class="comment">! tracer_type</span>
<a name="l03925"></a>03925          <span class="keyword">enddo</span>                  <span class="comment">! nt</span>
<a name="l03926"></a>03926       <span class="keyword">endif</span>                     <span class="comment">! present(tm)</span>
<a name="l03927"></a>03927 
<a name="l03928"></a>03928 <span class="keyword">      end subroutine update_fields</span>
<a name="l03929"></a>03929 
<a name="l03930"></a>03930 <span class="comment">!=======================================================================</span>
<a name="l03931"></a>03931 
<a name="l03932"></a>03932 <span class="keyword">      end module ice_transport_remap</span>
<a name="l03933"></a>03933 
<a name="l03934"></a>03934 <span class="comment">!=======================================================================</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 6 14:02:24 2009 for CICE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
