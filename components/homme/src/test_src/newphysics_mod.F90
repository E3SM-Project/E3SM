#ifndef CAM
#include "config.h"

module newphysics

! Implementation of the dcmip2012 dycore tests for the preqx dynamics target

use control_mod,          only: theta_hydrostatic_mode,&
                   case_planar_bubble, bubble_prec_type, bubble_rj_cpdry, bubble_rj_cpstar
use dimensions_mod,       only: np, nlev, nlevp , qsize, qsize_d, nelemd
use element_mod,          only: element_t
use element_state,        only: nt=>timelevels
use hybrid_mod,           only: hybrid_t
use kinds,                only: rl=>real_kind, iulog
use parallel_mod,         only: abortmp,iam
use reduction_mod,        only: parallelmax, parallelmin

use physical_constants,   only: bubble_const1, bubble_const2, bubble_const3, bubble_const4, &
                                bubble_t0_const, bubble_epsilo, bubble_e0, &
                                latvap, latice, &
                                gravit=>g, p0, &
                                rdry=>rgas, cpdry=>cp, cpv=>cpwater_vapor, cl, &
                                rvapor=>rwater_vapor, rhow

implicit none

!kessler constants, put into physconst mod
real(rl), parameter:: k1=0.001,k2=2.2,k3=0.875,a1=0.00001 !a1 should be 0.001
real(rl), parameter:: r1=0.525,r2=5.4e5,r3=2.55e6
real(rl), parameter:: r4=1.6,r5=124.9,r6=0.2046

contains

!pi is the result, it is \pi at midlevels
subroutine construct_hydro_pressure(dp,ptop,pi)

  real(rl), dimension(nlev), intent(in)  :: dp
  real(rl),                  intent(in)  :: ptop
  real(rl), dimension(nlev), intent(out) :: pi
  integer :: k
  real(rl) :: pi_upper

  pi_upper = ptop
  do k = 1, nlev
    pi_upper = pi_upper + dp(k)
    pi(k) = pi_upper - dp(k)/2
  enddo

end subroutine construct_hydro_pressure

subroutine convert_to_dry(q1,q2,q3,dp,dpdry,q1dry,q2dry,q3dry)

  real(rl), dimension(nlev), intent(in)  :: q1,q2,q3,dp,dpdry
  real(rl), dimension(nlev), intent(out) :: q1dry,q2dry,q3dry
  q1dry = q1 * dp /dpdry
  q2dry = q2 * dp /dpdry
  q3dry = q3 * dp /dpdry

end subroutine convert_to_dry

subroutine convert_to_wet(q1dry,q2dry,q3dry,dp,dpdry,q1,q2,q3)

  real(rl), dimension(nlev), intent(in)  :: q1dry,q2dry,q3dry,dp,dpdry
  real(rl), dimension(nlev), intent(out) :: q1,q2,q3
  q1 = q1dry * dpdry / dp
  q2 = q2dry * dpdry / dp
  q3 = q3dry * dpdry / dp

end subroutine convert_to_wet

subroutine accrecion_and_accumulation(qcdry,qrdry,dt)

  real(rl), dimension(nlev), intent(inout) :: qcdry,qrdry
  real(rl),                  intent(in)    :: dt
  integer  :: k
  real(rl) :: change

  !no movement between levels, no T change
  !accretion step, collection Cr = max ( k2 qc qr^k3, 0)
  do k=1,nlev
    change = dt * max ( k2*qcdry(k)*qrdry(k)**k3, 0.0)
    qcdry(k) = qcdry(k) - change
    qrdry(k) = qrdry(k) + change
  enddo

  !auto-accumulation step Ar = max ( k1 (qc - a), 0 )
  do k=1,nlev
    change = dt * max (k1*(qcdry(k) - a1), 0.0)
    qcdry(k) = qcdry(k) - change
    qrdry(k) = qrdry(k) + change
  enddo

end subroutine accrecion_and_accumulation

!does not need moisture
subroutine get_geo_from_drydp(Tempe, dpdry, pidry, zbottom, zi, zm, dz)

  real(rl), dimension(nlevp), intent(out) :: zi
  real(rl), dimension(nlev),  intent(out) :: zm, dz
  real(rl), dimension(nlev),  intent(in)  :: Tempe, dpdry, pidry
  real(rl),                   intent(in)  :: zbottom

  integer  :: k

  zi(nlevp) = zbottom
  do k=nlev,1,-1
    zi(k) = zi(k+1) + rdry*Tempe(k)*dpdry(k)/pidry(k)/gravit
  enddo
  dz(1:nlev) = zi(1:nlev) - zi(2:nlevp)
  zm(1:nlev) = (zi(1:nlev) + zi(2:nlevp))/2

end subroutine get_geo_from_drydp


subroutine sedimentation(qvdry,qcdry,qrdry,tempe,dpdry,pidry,zbottom,massleft,energyleft,dt)

  real(rl), dimension(nlev), intent(inout) :: qvdry,qcdry,qrdry,tempe
  real(rl), dimension(nlev), intent(in)    :: dpdry, pidry
  real(rl),                  intent(in)    :: zbottom,dt
  real(rl),                  intent(out)   :: massleft, energyleft

  integer  :: k, kk, d_ind
  real(rl) :: change, positt, velqr, T_new, cptermold, cptermnew
  real(rl), dimension(nlev)  :: zm, dz, rhodry
  real(rl), dimension(nlevp) :: zi

  massleft = 0.0; energyleft = 0.0

  call get_geo_from_drydp(tempe, dpdry, pidry, zbottom, zi, zm, dz)

  rhodry = dpdry / dz / gravit

  do k=1,nlev

    if(qrdry(k)>0.0) then
      ! Liquid water terminal velocity, using dry densities instead of wet
      ! in meter/sec
      velqr  = 36.34d0*(qrdry(k)*rhodry(k))**0.1364*sqrt(rhodry(nlev)/rhodry(k))

!print *, 'k, velqr, qr', k, velqr(k), qrdry(k)

      !check where it ends
       d_ind = k
       positt = zm(k) - velqr * dt
       !cell with kk index has boundaries zi(kk) and zi(kk+1)
       do kk=k+1,nlev
         if ( (positt > zi(kk)) .and. (positt <= zi(kk+1)) ) then
           d_ind = kk
           !kk = nlev ! does F allow this
         endif
       enddo

!print *, 'positt - zm(k)', positt - zm(k)
!if(d_ind > kk) then
!print *, k,kk
!endif

!hack
!positt = -100.0
!hack
if (k < nlev) then
  positt = zm(k+1)
  d_ind = k+1
else
  positt = -100.0
endif


       if(positt < zi(nlevp)) then
         !hit the bottom
         d_ind = -1
         massleft   = massleft   + qrdry(k) * dpdry(k)
!add nh term later
         energyleft = energyleft + qrdry(k) * dpdry(k) * ( cl*tempe(k) + latice )
         qrdry(k) = 0.0
       else
         !stuck in between
         !arrives to dest cell, recompute ratio for the dest cell
         change = qrdry(k)*dpdry(k)/dpdry(d_ind)
         !compute average temperature with new mass
         cptermold = cpdry + cpv * qvdry(d_ind) + cl * (qcdry(d_ind) + qrdry(d_ind))
         cptermnew = cptermold + cl*change
!add nh term later
         T_new = ( tempe(d_ind) * dpdry(d_ind) * cptermold + tempe(k) * dpdry(k) * qrdry(k) * cl ) / &
                  cptermnew / dpdry(d_ind)

!print *, 'T_new', T_new 
         tempe(d_ind) = T_new

         qrdry(k) = 0.0
         qrdry(d_ind) = qrdry(d_ind) + change
       endif
     endif !there was rain in cell
   end do ! k loop for sedim

end subroutine sedimentation


subroutine recompute_pressures(qvdry,qcdry,qrdry,dpdry,pidry,pprime,pi,pnh,dp)

  real(rl), dimension(nlev), intent(in)    :: qvdry,qcdry,qrdry
  real(rl), dimension(nlev), intent(in)    :: dpdry,pidry,pprime
  real(rl), dimension(nlev), intent(out)   :: dp,pi,pnh

  real(rl)  :: ptop
  real(rl), dimension(nlev)  :: dpi_from_water, pi_from_water

  ptop = 0.0

  dpi_from_water = dpdry*( qvdry + qcdry + qrdry )
  dp = dpi_from_water + dpdry

  call construct_hydro_pressure(dpi_from_water,ptop,pi_from_water)

  pi = pidry + pi_from_water
  pnh = pi + pprime

end subroutine recompute_pressures




subroutine rain_evaporation(qvdry,qcdry,qrdry,tempe,dpdry,ptop,zbottom,pprime)

  real(rl), dimension(nlev), intent(in)    :: qcdry
  real(rl), dimension(nlev), intent(inout) :: qvdry,qrdry,tempe
  real(rl), dimension(nlev), intent(in)    :: dpdry,pprime
  real(rl),                  intent(in)    :: zbottom,ptop

  integer  :: k
  real(rl) :: dq, qsat, qsatdry, cval
  real(rl), dimension(nlev)  :: zm,dz,rhodry,dpi,ppi,pnh,pidry
  real(rl), dimension(nlevp) :: zi

  dpi = dpdry*(1.0 + qvdry + qcdry + qrdry)

  !derived pressure values
  call construct_hydro_pressure(dpi,  ptop,ppi  )
  call construct_hydro_pressure(dpdry,ptop,pidry)
  pnh = ppi + pprime
  
  !we can use wet rho, but we will ignore thah here
                          !input                        !output
  call get_geo_from_drydp(tempe, dpdry, pidry, zbottom, zi, zm, dz)
  rhodry = dpdry / dz / gravit

  do k=1, nlev

    !r1=0.525,r2=5.4e5,r3=2.55e6 
    !r4=1.6,r5=124.9,r6=0.2046

    call qsat_kessler2(pnh(k), tempe(k), qsat)
    qsatdry = qsat*dpi(k)/dpdry(k)

    cval = r4 + r5*( (rhodry(k)*qrdry(k))**r6 )
    dq = (1 - qvdry(k)/qsatdry) * cval**r1
    dq = dq / ( r2 + r3/pnh(k)/qsat ) / rhodry(k)
    !change the sign to conform to the phase_change... routine
    dq = -dq
    dq = max( dq, -qcdry(k) )

    ! new values: qv = qv - dq, qr = qr + dq
    !notice liquid_in_use var is now qrdry
    call phase_change_gas_liquid_level( &
         qvdry(k),qrdry(k),qcdry(k),dq,tempe(k),dpdry(k),dpi(k),ppi(k),pnh(k) )

!if (dq > 0) then
! print *, 'yay, condensation',' qc', qcdry(k)
!endif

  enddo

end subroutine rain_evaporation



subroutine condensation_and_back_again(qvdry,qcdry,qrdry,tempe,dpdry,ptop,zbottom,pprime)

  real(rl), dimension(nlev), intent(in)    :: qrdry
  real(rl), dimension(nlev), intent(inout) :: qvdry,qcdry,tempe
  real(rl), dimension(nlev), intent(in)    :: dpdry, pprime
  real(rl),                  intent(in)    :: zbottom,ptop

  integer  :: k
  real(rl) :: dq, qsat, qsatdry
  real(rl), dimension(nlev)  :: dpi,ppi,pnh

  dpi = dpdry*(1.0 + qvdry + qcdry + qrdry)

  !derived pressure values
  call construct_hydro_pressure(dpi,ptop,ppi)
  pnh = ppi + pprime

  do k=1, nlev
    call qsat_kessler2(pnh(k), tempe(k), qsat)
    qsatdry = qsat*dpi(k)/dpdry(k)

    !assume condensation
    dq = qvdry(k) - qsatdry
    !except if
    if ( dq < 0.0 ) then
      !evaporation
      dq = max( dq, -qcdry(k) )
    endif
    ! new values: qv = qv - dq, qc = qc + dq

    call phase_change_gas_liquid_level( &
         qvdry(k),qcdry(k),qrdry(k),dq,tempe(k),dpdry(k),dpi(k),ppi(k),pnh(k) )

!if (dq > 0) then
! print *, 'yay, condensation',' qc', qcdry(k)
!endif

  enddo

end subroutine condensation_and_back_again


! convension: vapor = vapor - dq, liquid_in_use = liquid_in_use + dq
subroutine phase_change_gas_liquid_level(vapor,liquid_in_use,liquid_not_in_use,dq,tempe,dpdry,dp,pi,pnh)

  real(rl),  intent(in)    :: liquid_not_in_use
  real(rl),  intent(inout) :: vapor,liquid_in_use,tempe
  real(rl),  intent(in)    :: dpdry, dp, pi, pnh
  real(rl),  intent(in)    :: dq

  integer  :: k
  real(rl) :: T_new, cptermold, cptermnew, Lold, Lnew

  cptermold = cpdry     + cpv *  vapor     + cl * (liquid_in_use + liquid_not_in_use)
  cptermnew = cptermold + cpv * ( -dq )    + cl * dq

  Lold =        (latvap+latice) * vapor    + latice * (liquid_in_use + liquid_not_in_use)
  Lnew = Lold + (latvap+latice) * ( -dq )  + latice * dq

  !dpdry is cancelled from both sides
  T_new = ( tempe * cptermold + Lold - Lnew ) / cptermnew

  tempe = T_new

  vapor = vapor - dq
  liquid_in_use = liquid_in_use + dq

!if (dq > 0) then
! print *, 'yay, condensation',' qc', qcdry(k)
!endif

end subroutine phase_change_gas_liquid_level




subroutine compute_mass(qvdry,qcdry,qrdry,dpdry,mass)

  real(rl), dimension(nlev), intent(in)    :: qvdry,qcdry,qrdry
  real(rl), dimension(nlev), intent(in)    :: dpdry
  real(rl),                  intent(inout) :: mass

  integer  :: k

  mass = 0.0
  do k=1,nlev
    mass = mass + dpdry(k)*( 1.0 + qvdry(k) + qcdry(k) + qrdry(k) )
  enddo

end subroutine compute_mass




subroutine rj_new(qv_c,T_c,dp_c,p_c,ptop,massout,wasiactive)

  real(rl), dimension(nlev), intent(in)    :: p_c, dp_c
  real(rl), dimension(nlev), intent(inout) :: qv_c,T_c
  real(rl),                  intent(inout) :: massout
  real(rl),                  intent(in)    :: ptop
  logical,                   intent(inout) :: wasiactive

  real(rl) :: qsat, dp_loc, qv_loc, dpdry_loc, qvdry_loc, qsatdry, dq_loc, vapor_mass_change
  real(rl) :: T_loc, p_loc, pi_loc, L_old, L_new, rstar_old, rstar_new, hold, T_new
  real(rl) :: cpstarTerm_new
  real(rl), dimension(nlev) :: pi
  integer  :: k

  massout = 0.0

  call construct_hydro_pressure(dp_c,ptop,pi)

  do k=1, nlev
    call qsat_rj2(p_c(k), T_c(k), qsat)

    if (qv_c(k) > qsat) then
!print *, 'HEY RAIN!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
!stop
       wasiactive = .true. 
       !compute dry values
       dp_loc = dp_c(k)
       qv_loc = qv_c(k)
       dpdry_loc = dp_loc * (1.0 - qv_loc)
       qvdry_loc = qv_loc * dp_loc / dpdry_loc
       qsatdry = qsat * dp_loc / dpdry_loc     ! qv_new
       dq_loc = qvdry_loc - qsatdry            ! > 0 , is qliq_dry_new
       vapor_mass_change = dpdry_loc*dq_loc
       T_loc = T_c(k)
       p_loc = p_c(k)
       pi_loc = pi(k)

       !new Q will be qsatdry
       L_old = (latvap + latice) * qvdry_loc
       L_new = (latvap + latice) * qsatdry   + latice * dq_loc

       rstar_old = rdry * 1.0 + rvapor * qvdry_loc
       rstar_new = rdry * 1.0 + rvapor * qsatdry

!use extra term in dh=0 rule in case of NH or not
!#define HYY
#undef HYY
#ifndef HYY
       ! L and Rstar are in terms of q, so, enthalpy too
       hold = T_loc*( cpdry*1.0 + cpv*qvdry_loc ) + &
           (pi_loc/p_loc - 1) * rstar_old * T_loc + L_old
#else
       hold = T_loc*( cpdry*1.0 + cpv*qvdry_loc ) + &
                                                    L_old
#endif
       cpstarTerm_new = cpdry*1.0 + cpv*qsatdry + cl*dq_loc
       !hnew = T_new * (   cpstarTerm_new + ( (pi_loc - vapor_mass_change)/(p_loc - vapor_mass_change) - 1)*rstar_new   ) + &
       !       L_new
       !     = hold
#ifndef HYY
       T_new = (hold - L_new)/ &
       (   cpstarTerm_new + ( pi_loc/p_loc - 1)*rstar_new   )
#else
       T_new = (hold - L_new)/ &
       (   cpstarTerm_new   )
#endif
print *, 'T_new - T_c', T_new - T_c(k)

       !this does not need conversion wet-dry
       T_c(k)  = T_new
       qv_c(k) = qsat
       massout = massout + vapor_mass_change
     endif
  enddo
  
end subroutine rj_new



!in NH case, uses NH pressure
subroutine rj_old(qv_c,T_c,dp_c,p_c,massout,wasiactive)

  real(rl), dimension(nlev), intent(in)    :: p_c, dp_c
  real(rl), dimension(nlev), intent(inout) :: qv_c,T_c
  real(rl),                  intent(inout) :: massout
  logical,                   intent(inout) :: wasiactive

  real(rl) :: qsat, dq_loc
  integer :: k

  massout = 0.0

  do k=1, nlev
    call qsat_rj2(p_c(k), T_c(k), qsat)

    if (qv_c(k) > qsat) then
       wasiactive = .true.
!original RJ
       dq_loc = (qv_c(k) - qsat) &
         / (1.0 + (latvap/cpdry) * bubble_epsilo * latvap * qsat / (rdry*T_c(k)*T_c(k)))
       T_c(k)  = T_c(k)  + latvap / cpdry * dq_loc
       qv_c(k) = qv_c(k) - dq_loc
       massout = massout + dq_loc * dp_c(k)
     endif
  enddo

end subroutine rj_old




subroutine kessler_new_hy(qv_c,qc_c,qr_c,T_c,dp_c,p_c,ptop,zi_c,massout,energyout, &
                                            dt,wasiactive)

  real(rl), dimension(nlev), intent(in)    :: p_c, dp_c
  real(rl), dimension(nlevp),intent(in)    :: zi_c
  real(rl), dimension(nlev), intent(inout) :: qv_c,qc_c,qr_c,T_c
  real(rl),                  intent(inout) :: massout, energyout
  real(rl),                  intent(in)    :: ptop, dt
  logical,                   intent(inout) :: wasiactive

  real(rl), dimension(nlev) :: ppi, ppidry, pprime, ploc_c, dploc_c
  real(rl), dimension(nlev) :: dpdry_c, qvdry_c, qcdry_c, qrdry_c

  real(rl) :: zbottom, energy_start_timestep, energy_before, energy_after, loc_mass_p, loc_energy_p
  integer  :: k

  real(rl), parameter:: tol_energy = 1e-12, tol_mass = 1e-12

  massout = 0.0; energyout = 0.0
  zbottom = zi_c(nlevp)
  ploc_c = p_c
  dploc_c = dp_c

  !derived pressure values
  call construct_hydro_pressure(dp_c,ptop,ppi)
  pprime = p_c - ppi

  !derived dry pressure values
  !dry density, the only quantity that won't change
  dpdry_c = dp_c*(1.0 - qv_c - qc_c - qr_c)
  call construct_hydro_pressure(dpdry_c,ptop,ppidry)

  !convert all tracers to dry ratios
  call convert_to_dry(qv_c, qc_c, qr_c, dp_c, dpdry_c, qvdry_c, qcdry_c, qrdry_c)

  !if there is any water int he column
  if( any(qv_c>0).or.any(qc_c>0).or.any(qr_c>0) ) then

     !not exactly, as below conditions might not get triggered
     wasiactive = .true.
     ! Cr, Ar stages ----------------------------------------------------------
     call energy_hy_via_dry(qvdry_c,qcdry_c,qrdry_c,T_c,dpdry_c,ptop,zbottom,energy_before)
     energy_start_timestep = energy_before
     call accrecion_and_accumulation(qcdry_c, qrdry_c, dt)
     call energy_hy_via_dry(qvdry_c,qcdry_c,qrdry_c,T_c,dpdry_c,ptop,zbottom,energy_after)
     !print *, 'enbef - enafter', (energy_before - energy_after)/energy_after

     ! sedimentation ----------------------------------------------------------
     ! right now nh term is not used, so, no need to recompute wet hydro pressure and total nh pressure
     !so far, it is only part that has fluxes out
     call energy_hy_via_dry(qvdry_c,qcdry_c,qrdry_c,T_c,dpdry_c,ptop,zbottom,energy_before)
     call sedimentation(qvdry_c,qcdry_c,qrdry_c, T_c, dpdry_c,                    ppidry, zbottom, loc_mass_p,loc_energy_p,dt)
     call energy_hy_via_dry(qvdry_c,qcdry_c,qrdry_c,T_c,dpdry_c,ptop,zbottom,energy_after)
     !print *, 'Sedime:enbefore - enafter(up to flux)', (energy_before - energy_after - loc_energy_p)/energy_before
     massout = massout + loc_mass_p; energyout = energyout + loc_energy_p;

     ! evaporation of rain ----------------------------------------------------
  !call recompute_pressures(qvdry_c,qcdry_c,qrdry_c, dpdry_c,ppidry,pprime, ppi,ploc_c,dploc_c)
     call energy_hy_via_dry(qvdry_c,qcdry_c,qrdry_c,T_c,dpdry_c,ptop,zbottom,energy_before)
     call rain_evaporation(qvdry_c,qcdry_c,qrdry_c, T_c, dpdry_c,ptop,zbottom,pprime)
     call energy_hy_via_dry(qvdry_c,qcdry_c,qrdry_c,T_c,dpdry_c,ptop,zbottom,energy_after)
     !print *, 'Rain evap: enbefore - enafter(up to flux)', (energy_before - energy_after)/energy_before

     ! condensation <-> evaporation -------------------------------------------
  !call recompute_pressures(qvdry_c,qcdry_c,qrdry_c, dpdry_c,ppidry,pprime, ppi,ploc_c,dploc_c)
     call energy_hy_via_dry(qvdry_c,qcdry_c,qrdry_c,T_c,dpdry_c,ptop,zbottom,energy_before)
     call condensation_and_back_again(qvdry_c,qcdry_c,qrdry_c,T_c, dpdry_c,ptop,zbottom,pprime)
     call energy_hy_via_dry(qvdry_c,qcdry_c,qrdry_c,T_c,dpdry_c,ptop,zbottom,energy_after)
     !print *, 'Condensation: enbefore - enafter(up to flux)', (energy_before - energy_after)/energy_before

     !this works for now
     !if(energyout > tol_energy)then
     !print *, 'Total: en - en(up to flux)', (energy_start_timestep - energy_after - energyout)/energy_start_timestep
     !print *, 'energy flux, total energy after', energyout, energy_after
     !endif

     !if(energyout > tol_energy)then
     !print *, 'Energy flux comparison:', (energyout - cl*T_c(nlev)*massout)/energyout
     !endif

     !update q fields
     !WITH RESPECT TO OLD PRESSURE!
     ! this is wrong: dp_c = dpdry_c*(1.0 + qvdry_c + qcdry_c + qrdry_c)
     call convert_to_wet(qvdry_c, qcdry_c, qrdry_c, dp_c, dpdry_c, qv_c, qc_c, qr_c)

  endif ! any water >0

end subroutine kessler_new_hy



!give masses and pprime
subroutine energy_hy_via_mass(dpdry_c,dpv_c,dpc_c,dpr_c,T_c,ptop,zi_c,energy)

  real(rl), dimension(nlev), intent(in) :: dpdry_c, dpv_c, dpc_c, dpr_c
  real(rl), dimension(nlevp),intent(in) :: zi_c
  real(rl), dimension(nlev), intent(in) :: T_c
  real(rl),                  intent(in) :: ptop
  real(rl),                  intent(inout) :: energy

  real(rl) :: zbottom, pis, cpterm, Lterm
  integer  :: k

  zbottom = zi_c(nlevp)
  pis = ptop + sum(dpdry_c + dpv_c + dpc_c + dpr_c)

  !derived pressure values
  !call construct_hydro_pressure(dp_c,ptop,ppi)

  energy = zbottom * pis * gravit

  do k=1,nlev
    cpterm = cpdry*dpdry_c(k) + cpv * dpv_c(k) + cl * (dpc_c(k) + dpr_c(k))
    Lterm = (latvap+latice) * dpv_c(k) + latice * (dpc_c(k) + dpr_c(k))
    energy = energy + T_c(k)*cpterm + Lterm 
  enddo

end subroutine energy_hy_via_mass




subroutine energy_nh_via_mass(dpdry_c,dpv_c,dpc_c,dpr_c,T_c,ptop,zi_c,pprime,energy)

  real(rl), dimension(nlev), intent(in) :: dpdry_c, dpv_c, dpc_c, dpr_c, pprime
  real(rl), dimension(nlevp),intent(in) :: zi_c
  real(rl), dimension(nlev), intent(in) :: T_c
  real(rl),                  intent(in) :: ptop
  real(rl),                  intent(inout) :: energy

  real(rl) :: zbottom, pis, cpterm, Lterm, nhterm, rstar
  integer  :: k
  real(rl), dimension(nlev) :: ppi
  real(rl), dimension(nlev) :: pnh, dpi

  zbottom = zi_c(nlevp)
  dpi = dpdry_c + dpv_c + dpc_c + dpr_c
  pis = ptop + sum(dpi)

  !derived pressure values, on midlevels
  call construct_hydro_pressure(dpi,ptop,ppi)
  pnh = ppi + pprime

  energy = zbottom * pis * gravit

  do k=1,nlev
    cpterm = cpdry*dpdry_c(k) + cpv * dpv_c(k) + cl * (dpc_c(k) + dpr_c(k))

    Lterm  = (latvap+latice) * dpv_c(k) + latice * (dpc_c(k) + dpr_c(k))

    rstar = rdry*dpdry_c(k)/dpi(k) + rvapor*dpv_c(k)/dpi(k)

    nhterm = rstar*T_c(k)*(ppi(k)/pnh(k)-1.0)*dpi(k)

    energy = energy + T_c(k)*cpterm + Lterm + nhterm
  enddo

end subroutine energy_nh_via_mass




subroutine energy_hy_via_dry(qvdry,qcdry,qrdry,tempe,dpdry,ptop,zbottom,energy)

  real(rl), dimension(nlev), intent(in)    :: qrdry
  real(rl), dimension(nlev), intent(inout) :: qvdry,qcdry,tempe
  real(rl), dimension(nlev), intent(in)    :: dpdry
  real(rl),                  intent(inout) :: energy
  real(rl),                  intent(in)    :: zbottom, ptop

  integer  :: k
  real(rl) :: cpterm, Lterm, pis
  real(rl), dimension(nlev) :: dpi

  dpi = dpdry*(1.0 + qvdry + qcdry + qrdry)
  pis = ptop + sum(dpi)

  !dont do 1/g term
  energy = zbottom*pis*gravit
  do k=1,nlev
    cpterm = cpdry + cpv * qvdry(k) + cl * (qcdry(k) + qrdry(k))

    Lterm = (latvap+latice) * qvdry(k) + latice * (qcdry(k) + qrdry(k))

    energy = energy + dpdry(k)*( tempe(k)*cpterm + Lterm )
  enddo

end subroutine energy_hy_via_dry




subroutine energy_nh_via_dry(qvdry,qcdry,qrdry,tempe,dpdry,ptop,zbottom,pprime,energy)

  real(rl), dimension(nlev), intent(in)    :: qrdry, pprime
  real(rl), dimension(nlev), intent(inout) :: qvdry,qcdry,tempe
  real(rl), dimension(nlev), intent(in)    :: dpdry
  real(rl),                  intent(inout) :: energy
  real(rl),                  intent(in)    :: zbottom, ptop

  integer  :: k
  real(rl) :: cpterm, Lterm, rstar, nhterm, pis
  real(rl), dimension(nlev) :: pnh, dpi
  real(rl), dimension(nlev) :: ppi

  dpi = dpdry*(1.0 + qvdry + qcdry + qrdry)

  !derived pressure values
  call construct_hydro_pressure(dpi,ptop,ppi)
  pnh = ppi + pprime

  !dont do 1/g term
  energy = zbottom*ppi(nlevp)*gravit
  do k=1,nlev
    cpterm = cpdry + cpv * qvdry(k) + cl * (qcdry(k) + qrdry(k))

    Lterm = (latvap+latice) * qvdry(k) + latice * (qcdry(k) + qrdry(k))

    rstar = rdry + rvapor*qvdry(k)
 
    nhterm = rstar*tempe(k)*(ppi(k)/pnh(k)-1.0)

    energy = energy + dpdry(k)*( tempe(k)*cpterm + Lterm + nhterm )
  enddo

end subroutine energy_nh_via_dry



























!!!!!!!!!!! copy from dcmip16 FIX THAT!
subroutine qsat_kessler2(p, T, qsat)
  real(rl),         intent(out):: qsat
  real(rl),         intent(in) :: p, T
  qsat = bubble_const1 / p * exp( bubble_const2 * (T - bubble_const3) / ( T - bubble_const4 ) )
end subroutine qsat_kessler2

subroutine qsat_rj2(p, T, qsat)
  real(rl),         intent(out):: qsat
  real(rl),         intent(in) :: p, T
  qsat = bubble_epsilo * bubble_e0 / p * &
         exp(-(latvap/rvapor) * ((1.0/T)-(1.0/bubble_t0_const)))
end subroutine qsat_rj2


end module newphysics
#endif
