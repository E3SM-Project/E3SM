#!/usr/bin/env python3

"""
Namelist creator for E3SM's SCREAM component

This script takes the namelist_defaults_scream.xml file from the repo
and produces the processed $case/namelist_scream.xml. From the processed
file, raw input files are produced which should not be modified by users.
The user is allowed to modify $case/namelist_scream.xml either directly
via text editor or via atm-config-chg.

This script can be internally tested standalone via: buildnml --test

It is also encouraged to run pylint on this file when it gets changed:
python3 -m pylint --disable C --disable R buildnml
Some import errors are expected and can be ignored
"""

import os, sys, re
from collections import OrderedDict

import xml.etree.ElementTree as ET

_CIMEROOT = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..","..","..","cime")
sys.path.append(os.path.join(_CIMEROOT, "CIME", "Tools"))

# Add path to scream libs
sys.path.append(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "scripts"))

# Cime imports
from standard_script_setup import *
from CIME.case import Case
from CIME.utils import expect, safe_copy, SharedArea
from CIME.buildnml import parse_input

# SCREAM imports
from eamxx_buildnml_impl import get_valid_selectors, get_child, \
        resolve_all_inheritances, gen_atm_procs, find_node

from utils import ensure_yaml
ensure_yaml()
import yaml

logger = logging.getLogger(__name__)

CIME_VAR_RE = re.compile(r'[$][{](\w+)[}]')
METADATA_ATTRIBS = ("type", "valid_values")

###############################################################################
class MockCase(object):
###############################################################################

    def __init__(self, kv_dict):
        self._kv_dict = dict(kv_dict)

    def get_value(self, key):
        if key in self._kv_dict:
            return self._kv_dict[key]
        else:
            return None

###############################################################################
def do_cime_vars(entry, case):
###############################################################################
    """
    For a parameter value, process any references to case values ("${CASEVAR}")

    >>> case = MockCase({'foo':1, 'bar':2, 'baz_bar':'blah', 'baz2_bar2':4})
    >>> do_cime_vars('${foo}', case)
    '1'
    >>> do_cime_vars('hi ${foo} there', case)
    'hi 1 there'
    >>> do_cime_vars('hi ${foo}${bar} there', case)
    'hi 12 there'
    >>> do_cime_vars('hi ${baz_bar} there', case)
    'hi blah there'
    >>> do_cime_vars('hi ${baz2_bar2} there', case)
    'hi 4 there'
    >>> do_cime_vars('hi ${invalid} there', case)
    Traceback (most recent call last):
      ...
    CIME.utils.CIMEError: ERROR: Cannot resolve XML entry 'hi ${invalid} there', CIME has no value for 'invalid'
    """
    m = CIME_VAR_RE.search(entry)
    while m:
        cime_var = m.groups()[0]
        value = case.get_value(cime_var)
        expect(value is not None, "Cannot resolve XML entry '{}', CIME has no value for '{}'".format(entry, cime_var))
        entry = entry.replace("${{{}}}".format(cime_var), str(value))
        m = CIME_VAR_RE.search(entry)

    return entry

###############################################################################
def ordered_dump(data, item, Dumper=yaml.SafeDumper, **kwds):
###############################################################################
    """
    Copied from: https://stackoverflow.com/a/21912744
    Added ability to pass filename
    """
    class OrderedDumper(Dumper):
        pass
    def _dict_representer(dumper, data):
        return dumper.represent_mapping(
            yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
            data.items())
    OrderedDumper.add_representer(OrderedDict, _dict_representer)

    if isinstance(item, str) and item.endswith(".yaml"):
        # Item is a filepath
        with open(item, "w") as fd:
            return yaml.dump(data, fd, OrderedDumper, **kwds)
    else:
        return yaml.dump(data, item, OrderedDumper, **kwds)

###############################################################################
def evaluate_selectors(element, case, ez_selectors):
###############################################################################
    """
    Evaluate and remove selectors from the unprocessed XML nml file in the repo.

    Elements with selectors are removed. If the selector evaulates to True, then
    the corresponding element text becomes the new text value of the original
    (no-selectors, AKA default) element.

    The metadata attributes are kept, to allow checks during calls to atm-config-chg
    """
    child_values = {} # elem_name -> evaluated XML element
    children_to_remove = []
    for child in element:
        child_name = child.tag
        child_val = child.text

        # Note: in our system, an XML element is either a "node" (has children)
        # or a "leaf" (has a value).
        has_children = len(child) > 0
        if has_children:
            evaluate_selectors(child, case, ez_selectors)
        else:
            selectors = child.attrib
            if selectors:
                all_match = True
                is_first = False
                for k, v in selectors.items():
                    # Metadata attributes are used only when it's time to generate the input files
                    if k in selectors:
                        continue

                    val_re = re.compile(v)

                    if k in ez_selectors:
                        ez_env, ez_regex = ez_selectors[k]
                        case_val = case.get_value(ez_env)
                        expect(case_val is not None, "Bad easy selector '{}' definition. Relies on unknown case value '{}'".format(k, ez_env))

                        ez_regex_re = re.compile(ez_regex)
                        m = ez_regex_re.match(case_val)
                        if m:
                            groups = m.groups()
                            expect(len(groups) == 1, "Selector '{}' has invalid custom regex '{}' which does not capture exactly 1 group".format(k, ez_regex))
                            val = groups[0]
                        else:
                            # If the regex doesn't even match the case val, then we consider
                            # string below should ensure the selector will never match.
                            val = None

                    else:
                        val = case.get_value(k)
                        expect(val is not None, "Bad selector '{0}' for child '{1}'. '{0}' is not a valid case value or easy selector".format(k, child_name))


                    if val is None or val_re.match(val) is None:
                        all_match = False
                        break

                if all_match:
                    if child_name in child_values:
                        orig_child = child_values[child_name]
                        orig_child.text = do_cime_vars(child_val, case)

                    else:
                        is_first = True
                        child_values[child_name] = child
                        child.text = do_cime_vars(child_val, case)
                        for k in selectors.keys():
                            if k not in METADATA_ATTRIBS:
                                del child.attrib[k]

                if not is_first:
                    children_to_remove.append(child)

            else:
                expect(child_name not in child_values,
                       "child '{}' element without selectors occured after other parameter elements for this parameter".format(child_name))
                child_values[child_name] = child
                child.text = do_cime_vars(child_val, case)

    for child_to_remove in children_to_remove:
        element.remove(child_to_remove)

###############################################################################
def _create_raw_xml_file_impl(case, defaults_xml):
###############################################################################
    #  """
    #  >>> case = MockCase({'ATM_GRID':'ne4ne4', 'SCREAM_CMAKE_OPTIONS':'FOO=ON SCREAM_NUM_VERTICAL_LEV 128 BAR=OFF'})
    #  >>> test_empty_selectors = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...     <testval>42</testval>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> print(_create_raw_xml_file_impl(case, test_empty_selectors)[0])
    #  <namelist_defaults>
    #    <file name="test.yaml" format="yaml">
    #      <testval>42</testval>
    #    </file>
    #  </namelist_defaults>
    #  >>> _create_raw_xml_file_impl(case, test_empty_selectors)[1]
    #  {'test.yaml': {'testval': ['integer', None]}}
    #  >>> ######################################################################
    #  >>> test_err_repeat_val = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...     <testval>42</testval>
    #  ...     <testval>420</testval>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> _create_raw_xml_file_impl(case, test_err_repeat_val)
    #  Traceback (most recent call last):
    #    ...
    #  CIME.utils.CIMEError: ERROR: child 'testval' element without selectors occured after other parameter elements for this parameter
    #  >>> ######################################################################
    #  >>> test_err_bad_selector = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...     <testval>42</testval>
    #  ...     <testval foo="bar">420</testval>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> _create_raw_xml_file_impl(case, test_err_bad_selector)
    #  Traceback (most recent call last):
    #    ...
    #  CIME.utils.CIMEError: ERROR: Bad selector 'foo' for child 'testval'. 'foo' is not a valid case value or easy selector
    #  >>> ######################################################################
    #  >>> test_selector_default = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...     <selector name="hgrid" case_env="ATM_GRID"/>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...     <testval hgrid="ne4ne4">420</testval>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> print(_create_raw_xml_file_impl(case, test_selector_default)[0])
    #  <namelist_defaults>
    #    <file name="test.yaml" format="yaml">
    #      <testval>420</testval>
    #    </file>
    #  </namelist_defaults>
    #  >>> _create_raw_xml_file_impl(case, test_selector_default)[1]
    #  {'test.yaml': {'testval': ['integer', None]}}
    #  >>> ######################################################################
    #  >>> test_selector_no_match_default = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...     <selector name="hgrid" case_env="ATM_GRID"/>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...     <testval hgrid="no_match">420</testval>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> print(_create_raw_xml_file_impl(case, test_selector_no_match_default)[0])
    #  <namelist_defaults>
    #    <file name="test.yaml" format="yaml">
    #      </file>
    #  </namelist_defaults>
    #  >>> _create_raw_xml_file_impl(case, test_selector_no_match_default)[1]
    #  {'test.yaml': {}}
    #  >>> ######################################################################
    #  >>> test_err_wrong_order = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...     <selector name="hgrid" case_env="ATM_GRID"/>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...     <testval hgrid="ne4ne4">420</testval>
    #  ...     <testval>42</testval>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> _create_raw_xml_file_impl(case, test_err_wrong_order)
    #  Traceback (most recent call last):
    #    ...
    #  CIME.utils.CIMEError: ERROR: child 'testval' element without selectors occured after other parameter elements for this parameter
    #  >>> ######################################################################
    #  >>> test_err_bad_selector_def = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...     <selector name="hgrid" case_env="BADVAL"/>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...     <testval>42</testval>
    #  ...     <testval hgrid="ne4ne4">420</testval>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> _create_raw_xml_file_impl(case, test_err_bad_selector_def)
    #  Traceback (most recent call last):
    #    ...
    #  CIME.utils.CIMEError: ERROR: Bad easy selector 'hgrid' definition. Relies on unknown case value 'BADVAL'
    #  >>> ######################################################################
    #  >>> test_err_bad_selector_def_regex = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...     <selector name="hgrid" case_env="ATM_GRID" regex=".*"/>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...     <testval>42</testval>
    #  ...     <testval hgrid="ne4ne4">420</testval>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> _create_raw_xml_file_impl(case, test_err_bad_selector_def_regex)
    #  Traceback (most recent call last):
    #    ...
    #  CIME.utils.CIMEError: ERROR: Selector 'hgrid' has invalid custom regex '.*' which does not capture exactly 1 group
    #  >>> ######################################################################
    #  >>> full_test = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...     <selector name="hgrid" case_env="ATM_GRID"/>
    #  ...     <selector name="nlev" case_env="SCREAM_CMAKE_OPTIONS" regex=".*SCREAM_NUM_VERTICAL_LEV ([0-9]+).*"/>
    #  ...     <selector name="nomatch" case_env="SCREAM_CMAKE_OPTIONS" regex=".*(NO_MATCH).*"/>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...     <group1>
    #  ...       <testval>42</testval>
    #  ...       <testval2>123</testval2>
    #  ...       <interleave>hi</interleave>
    #  ...       <testval2 hgrid="ne4ne4">1234</testval2>
    #  ...     </group1>
    #  ...     <group2>
    #  ...       <testval>42</testval>
    #  ...       <testval2>123</testval2>
    #  ...       <interleave>hi</interleave>
    #  ...       <testval2 hgrid="ne4ne4">1234</testval2>
    #  ...       <prec_tester>1</prec_tester>
    #  ...       <prec_tester hgrid="ne4ne4" nlev="128">2</prec_tester>
    #  ...       <prec_tester nlev="128">3</prec_tester>
    #  ...       <foo>1</foo>
    #  ...       <foo hgrid=".*ne4.*">2</foo>
    #  ...       <bar>1</bar>
    #  ...       <bar hgrid="no_match">2</bar>
    #  ...       <baz>1</baz>
    #  ...       <baz hgrid="no_match" nlev="128">2</baz>
    #  ...       <bat>1</bat>
    #  ...       <bat nlev="128" hgrid="no_match">2</bat>
    #  ...       <sel_regex_no_match>1</sel_regex_no_match>
    #  ...       <sel_regex_no_match nomatch=".*">2</sel_regex_no_match>
    #  ...     </group2>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> print(_create_raw_xml_file_impl(case, full_test)[0])
    #  <namelist_defaults>
    #    <file name="test.yaml" format="yaml">
    #      <group1>
    #        <testval>42</testval>
    #        <testval2>1234</testval2>
    #        <interleave>hi</interleave>
    #        </group1>
    #      <group2>
    #        <testval>42</testval>
    #        <testval2>1234</testval2>
    #        <interleave>hi</interleave>
    #        <prec_tester>3</prec_tester>
    #        <foo>2</foo>
    #        <bar>1</bar>
    #        <baz>1</baz>
    #        <bat>1</bat>
    #        <sel_regex_no_match>1</sel_regex_no_match>
    #        </group2>
    #    </file>
    #  </namelist_defaults>
    #  >>> import pprint
    #  >>> pp = pprint.PrettyPrinter(indent=4)
    #  >>> pp.pprint(_create_raw_xml_file_impl(case, full_test)[1])
    #  {   'test.yaml': {   'group1': {   'interleave': ['string', None],
    #                                     'testval': ['integer', None],
    #                                     'testval2': ['integer', None]},
    #                       'group2': {   'bar': ['integer', None],
    #                                     'bat': ['integer', None],
    #                                     'baz': ['integer', None],
    #                                     'foo': ['integer', None],
    #                                     'interleave': ['string', None],
    #                                     'prec_tester': ['integer', None],
    #                                     'sel_regex_no_match': ['integer', None],
    #                                     'testval': ['integer', None],
    #                                     'testval2': ['integer', None]}}}
    #  >>> ######################################################################
    #  >>> test_metadata_override = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...     <selector name="hgrid" case_env="ATM_GRID"/>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...     <testval valid_values="1,2,3">1</testval>
    #  ...     <testval hgrid="ne4ne4" valid_values="1,2,3,4">2</testval>
    #  ...     <testval hgrid="no_match" valid_values="1,2,3,4,5">3</testval>
    #  ...     <testval2 valid_values="1,2,3">1</testval2>
    #  ...     <testval2 hgrid="ne4ne4">2</testval2>
    #  ...     <testval2 hgrid="no_match">3</testval2>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> _create_raw_xml_file_impl(case, test_metadata_override)[1]
    #  {'test.yaml': {'testval': ['integer', '1,2,3,4'], 'testval2': ['integer', '1,2,3']}}
    #  """
    root = defaults_xml.getroot()

    # 0. Remove internal sections, that are not to appear in the
    #    processed xml file.
    #    Note: get_valid_selectors also removes the section
    get_child(root,"input_files",remove=True)
    get_child(root,"generated_files",remove=True)
    compset_grids = get_child(root,"valid_grids",remove=True).text.split(',')
    selectors = get_valid_selectors(root)

    # 1. Resolve all inheritances, and evaluate all selectors
    resolve_all_inheritances(root)
    evaluate_selectors(root, case, selectors)

    # 2. Grab the atmosphere_processes macro list, with all the defaults
    atm_procs_defaults = get_child(root,"atmosphere_processes_defaults",remove=True)

    # 3. Get atm procs list
    atm_procs_list = get_child(atm_procs_defaults,"atm_procs_list",remove=True)

    # 4. Form the nested list of atm procs needed, append to atmosphere_driver section
    atm_procs = gen_atm_procs (atm_procs_list.text, atm_procs_defaults)
    atm_procs.tag = "atmosphere_processes"
    root.append(atm_procs);

    # 5. Check IC list
    ic = get_child(root,"Initial__Conditions")
    for grid in ic:
        if grid.tag not in compset_grids:
            ic.remove(grid)

    return root

###############################################################################
def create_raw_xml_file(case, caseroot):
###############################################################################
    """
    Create the raw $case/namelist_scream.xml file. This file is intended to be
    modified by users via editor or the atm-config-chg script if they want
    to make tweaks to input files (yaml and/or nml).
    """
    src = os.path.join(case.get_value("SRCROOT"), "components/scream/cime_config/namelist_defaults_scream.xml")

    raw_xml_file = os.path.join(caseroot, "namelist_scream.xml")
    with open(src, "r") as fd:
        defaults = ET.parse(fd)
        raw_xml = _create_raw_xml_file_impl(case,defaults)

    if os.path.exists(raw_xml_file):
        print("{} already exists, will not overwrite. Remove to regenerate".format(raw_xml_file))
    else:
        with open(raw_xml_file, "w") as fd:
            ET.ElementTree(raw_xml).write(fd, method='xml', encoding="unicode")

###############################################################################
def derive_type(entry):
###############################################################################
    refined_value = refine_type(entry)
    if isinstance(refined_value, list):
        refined_value = refined_value[0]

    if isinstance(refined_value, bool):
        return "logical"
    elif isinstance(refined_value, int):
        return "integer"
    elif isinstance(refined_value, float):
        return "real"
    elif isinstance(refined_value, str):
        return "string"
    else:
        expect(False, "Couldn't derive type of '{}'".format(entry))
        return None

###############################################################################
def refine_type(entry, force_type=None):
###############################################################################
    """
    Try to convert the text entry to the appropriate type based on its contents.
    """
    # We want to preserve strings representing lists
    if (entry[0]=="(" and entry[-1]==")") or \
       (entry[0]=="[" and entry[-1]=="]") :
        return entry

    if "," in entry:
        result = [refine_type(item.strip(), force_type=force_type) for item in entry.split(",") if item.strip() != ""]
        expected_type = type(result[0])
        for item in result[1:]:
            expect(isinstance(item, expected_type), "List '{}' has inconsistent types inside".format(entry))

        return result

    if force_type:
        try:
            if force_type == "logical":
                if entry.upper() == "TRUE":
                    return True
                elif entry.upper() == "FALSE":
                    return False
                else:
                    return bool(int(entry))

            elif force_type == "integer":
                return int(entry)
            elif force_type == "real":
                return float(entry)
            elif force_type == "string":
                return str(entry)
            else:
                expect(False, "Bad force_type '{}'".format(force_type))
                return None

        except ValueError:
            expect(False, "Could not use '{}' as type '{}'".format(entry, force_type))
            return None

    if entry.upper() == "TRUE":
        return True
    elif entry.upper() == "FALSE":
        return False

    try:
        v = int(entry)
        return v
    except ValueError:
        pass

    try:
        v = float(entry)
        return v
    except ValueError:
        return entry

###############################################################################
def check_valid(child_name, val, valids_str, child_type):
###############################################################################
    """
    Check that a parameter's value is in the valid list
    """
    valids = [refine_type(item.strip(), force_type=child_type) for item in valids_str.split(",")]
    expect(val in valids, "child '{}' has value '{}' that is not in the valid list ('{}')".format(child_name, str(val), str(valids)))

###############################################################################
def convert_to_dict(element):
###############################################################################
    """
    Convert an XML element to a dictonary where the tags are the keys
    """
    result = OrderedDict()
    for child in element:
        child_name = child.tag.replace("__", " ")
        child_val = child.text

        has_children = len(child) > 0
        if not has_children:
            result[child_name] = refine_type(child_val)
        else:
            result[child_name] = convert_to_dict(child)

    return result

###############################################################################
def _dump_to_nml_impl(dict_contents):
###############################################################################
    #  """
    #  >>> case = MockCase({'ATM_GRID':'ne4ne4', 'SCREAM_CMAKE_OPTIONS':'FOO=ON SCREAM_NUM_VERTICAL_LEV 128 BAR=OFF'})
    #  >>> nmlxml = '''
    #  ... <namelist_defaults>
    #  ...   <selectors>
    #  ...   </selectors>
    #  ...   <file name="test.yaml" format="yaml">
    #  ...   <group1>
    #  ...     <testval valid_values="42,43,44">42</testval>
    #  ...     <testval2>42.3</testval2>
    #  ...     <interleave>hi</interleave>
    #  ...    </group1>
    #  ...    <group2>
    #  ...      <testval>False</testval>
    #  ...      <testval2>1, 2, 3, 4</testval2>
    #  ...      <interleave>hi, there</interleave>
    #  ...    </group2>
    #  ...   </file>
    #  ... </namelist_defaults>
    #  ... '''
    #  >>> metadata = _create_raw_xml_file_impl(case, nmlxml)[1]["test.yaml"]
    #  >>> rawxml = '''
    #  ... <file name="test.yaml" format="yaml">
    #  ...   <group1>
    #  ...     <testval>42</testval>
    #  ...     <testval2>42.3</testval2>
    #  ...     <interleave>hi</interleave>
    #  ...    </group1>
    #  ...    <group2>
    #  ...      <testval>False</testval>
    #  ...      <testval2>1, 2, 3, 4.2</testval2>
    #  ...      <interleave>hi, there</interleave>
    #  ...    </group2>
    #  ...  </file>
    #  ... '''
    #  >>> root = ET.fromstring(rawxml)
    #  >>> _dump_to_nml_impl(convert_to_dict(root, metadata))
    #  Traceback (most recent call last):
    #    ...
    #  CIME.utils.CIMEError: ERROR: Could not use '4.2' as type 'integer'
    #  >>> ######################################################################
    #  >>> rawxml = '''
    #  ... <file name="test.yaml" format="yaml">
    #  ...   <group1>
    #  ...     <testval>39</testval>
    #  ...     <testval2>42.3</testval2>
    #  ...     <interleave>hi</interleave>
    #  ...    </group1>
    #  ...    <group2>
    #  ...      <testval>False</testval>
    #  ...      <testval2>1, 2, 3, 4</testval2>
    #  ...      <interleave>hi, there</interleave>
    #  ...    </group2>
    #  ...  </file>
    #  ... '''
    #  >>> root = ET.fromstring(rawxml)
    #  >>> _dump_to_nml_impl(convert_to_dict(root, metadata))
    #  Traceback (most recent call last):
    #    ...
    #  CIME.utils.CIMEError: ERROR: child 'testval' has value '39' that is not in the valid list ('[42, 43, 44]')
    #  >>> ######################################################################
    #  >>> rawxml = '''
    #  ... <file name="test.yaml" format="yaml">
    #  ...   <group1>
    #  ...     <testval>hi</testval>
    #  ...     <testval2>42.3</testval2>
    #  ...     <interleave>hi</interleave>
    #  ...    </group1>
    #  ...    <group2>
    #  ...      <testval>False</testval>
    #  ...      <testval2>1, 2, 3, 4</testval2>
    #  ...      <interleave>hi, there</interleave>
    #  ...    </group2>
    #  ...  </file>
    #  ... '''
    #  >>> root = ET.fromstring(rawxml)
    #  >>> _dump_to_nml_impl(convert_to_dict(root, metadata))
    #  Traceback (most recent call last):
    #    ...
    #  CIME.utils.CIMEError: ERROR: Could not use 'hi' as type 'integer'
    #  >>> ######################################################################
    #  >>> rawxml = '''
    #  ... <file name="test.yaml" format="yaml">
    #  ...   <group1>
    #  ...     <testval>42</testval>
    #  ...     <testval2>42.3</testval2>
    #  ...     <interleave>hi</interleave>
    #  ...    </group1>
    #  ...    <group2>
    #  ...      <testval>False</testval>
    #  ...      <testval2>1, 2, 3, 4</testval2>
    #  ...      <interleave>hi, there</interleave>
    #  ...      <alien_nation>hi, there</alien_nation>
    #  ...    </group2>
    #  ...  </file>
    #  ... '''
    #  >>> root = ET.fromstring(rawxml)
    #  >>> _dump_to_nml_impl(convert_to_dict(root, metadata))
    #  Traceback (most recent call last):
    #    ...
    #  CIME.utils.CIMEError: ERROR: No metadata for child 'alien_nation'
    #  >>> ######################################################################
    #  >>> rawxml = '''
    #  ... <file name="test.yaml" format="yaml">
    #  ...   <group1>
    #  ...     <testval>42</testval>
    #  ...     <testval2>42.3</testval2>
    #  ...     <interleave>hi</interleave>
    #  ...    </group1>
    #  ...    <group2>
    #  ...      <testval>False</testval>
    #  ...      <testval2>1, 2, 3, 4</testval2>
    #  ...      <interleave>hi, there</interleave>
    #  ...    </group2>
    #  ...  </file>
    #  ... '''
    #  >>> root = ET.fromstring(rawxml)
    #  >>> print(_dump_to_nml_impl(convert_to_dict(root, metadata)))
    #  &group1
    #  testval = 42
    #  testval2 = 42.3
    #  interleave = 'hi'
    #  /
    #  &group2
    #  testval = .false.
    #  testval2(:) = 1, 2, 3, 4
    #  interleave(:) = hi, there
    #  /
    #  <BLANKLINE>
    #  """
    result = ""
    for k, v in dict_contents.items():
        if isinstance(v, dict):
            result += "&{}\n".format(k)
            result += _dump_to_nml_impl(v)
            result += "/\n"

        elif isinstance(v, list):
            result += "{}(:) = {}\n".format(k, ", ".join([str(item) for item in v]))
        elif isinstance(v, bool):
            result += "{} = {}\n".format(k, ".true." if v else ".false.")
        elif isinstance(v, str):
            result += "{} = '{}'\n".format(k, v)
        else:
            result += "{} = {}\n".format(k, v)

    return result

###############################################################################
def dump_to_nml(dict_contents, fd):
###############################################################################
    """
    Convert a dictionary to namelist file
    """
    fd.write(
"""!---------------------------------------------------------------
! Do NOT modify this file. It is generated by scream/buildnml using
! the data from $case/namelist_scream.xml. If you want to make some
! local changes, you can edit this XML file or use atm-config-chg.
!---------------------------------------------------------------
""")

    fd.write(_dump_to_nml_impl(dict_contents))

###############################################################################
def create_input_files(caseroot, screamroot, rundir):
###############################################################################
    """
    Based on $case/namelist_scream.xml, create the actual input files.
    """
    raw_xml_file = os.path.join(caseroot, "namelist_scream.xml")
    with open(raw_xml_file, "r") as fd:
        tree = ET.parse(fd)
        raw_xml = tree.getroot()

    def_xml_file = os.path.join(screamroot, "cime_config/namelist_defaults_scream.xml")
    with open(def_xml_file, "r") as fd:
        tree = ET.parse(fd)
        generated_files = get_child(tree.getroot(),"generated_files")

    result = {}
    for file in generated_files:
        expect("name" in file.attrib, "file element missing required 'name' attribute")
        expect("format" in file.attrib, "file element missing required 'format' attribute")
        filename    = os.path.join(rundir, file.attrib["name"])
        file_format = file.attrib["format"]
        
        xml_sections = get_child(file,"sections").text.split(",")

        dict_contents = {}
        for section_name in xml_sections:
            section = get_child(raw_xml,section_name)
            dict_contents[section_name.replace("__"," ")] = convert_to_dict(section)

        if file_format == "yaml":
            with open(filename, "w") as fd:
                fd.write(
"""################################################################
# Do NOT modify this file. It is generated by scream/buildnml using
# the data from $case/namelist_scream.xml. If you want to make some
# local changes, you can edit this XML file or use atm-config-chg.
################################################################
""")
                ordered_dump(dict_contents, fd)

        elif file_format == "nml":
            with open(filename, "w") as fd:
                dump_to_nml(dict_contents, fd)

        else:
            expect(False, "Unknown input file format '{}'".format(file_format))

        result[file.attrib["name"]] = dict_contents

    return result

###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################
    expect(compname == "scream", compname)

    rundir   = case.get_value("RUNDIR")
    target   = os.path.join(rundir, "data")
    screamroot = os.path.join(case.get_value("SRCROOT"), "components/scream")
    srcdata    = os.path.join(screamroot,"data")

    #
    # Copy scream/data to rundir/data
    #
    with SharedArea():
        if not os.path.isdir(target):
            os.mkdir(target)

        for item in os.listdir(srcdata):
            # Do not overwrite existing files because that would remove any
            # local mods made by the user.
            if not os.path.exists(os.path.join(target, item)):
                safe_copy(os.path.join(srcdata, item), target)

        # Copy nml config change/query scripts
        safe_copy(os.path.join(screamroot, "scripts/atm-config-chg"), caseroot)

    #
    # Create the raw/processed XML input file and create input files
    # from it.
    #
    create_raw_xml_file(case, caseroot)
    files_as_dicts = create_input_files(caseroot, screamroot, rundir)

    #
    # Create input data list. This is the list of files that CIME needs
    # to ensure are present on the machine (possibly downloading them)
    #
    scream_input = files_as_dicts["data/scream_input.yaml"]
    ic_section = scream_input["Initial Conditions"]
    create_input_data_list_file(case,caseroot,screamroot,ic_section)

###############################################################################
def create_input_data_list_file(case,caseroot,screamroot,ic_section):
###############################################################################

    rundir   = case.get_value("RUNDIR")
    target   = os.path.join(rundir, "data")

    input_data_list_file = "{}/Buildconf/scream.input_data_list".format(caseroot)
    if os.path.exists(input_data_list_file):
        os.remove(input_data_list_file)

    def_xml_file = os.path.join(screamroot, "cime_config/namelist_defaults_scream.xml")
    with open(def_xml_file, "r") as fd:
        tree = ET.parse(fd)
        root = tree.getroot()
        tables = get_child(root,"input_files").text.split(',')

    with open(input_data_list_file, "w") as fd:
        for idx,grid in enumerate(ic_section.keys()):
            ic_file = ic_section[grid]
            fd.write("ic_file_{} = {}\n".format(idx,ic_file))
        for idx, table in enumerate(tables):
            fd.write("table_{} = {}\n".format(idx, table.strip()))

    # SCREAM is currently hardcoded to expect tables to be in data
    for table in tables:
        table_name = os.path.basename(table)
        tgt_table = os.path.join(target, table_name)
        if not os.path.exists(tgt_table) and not os.path.islink(tgt_table):
            os.symlink(table, os.path.join(target, table_name))


###############################################################################
def _main_func():
###############################################################################
    if "--test" in sys.argv:
        from doctest import testmod
        testmod()

    else:
        caseroot = parse_input(sys.argv)
        with Case(caseroot) as case:
            buildnml(case, caseroot, "scream")

if __name__ == "__main__":
    _main_func()
